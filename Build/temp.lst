
Build/temp.elf:     file format elf32-littlearm


Disassembly of section .flash_interrupts:

00000000 <VTABLE>:
   0:	20007000 	.word	0x20007000
   4:	00000411 	.word	0x00000411
   8:	000005a3 	.word	0x000005a3
   c:	00000d23 	.word	0x00000d23
  10:	00000d25 	.word	0x00000d25
  14:	00000d27 	.word	0x00000d27
  18:	00000d29 	.word	0x00000d29
	...
  2c:	00000d2b 	.word	0x00000d2b
  30:	00000d2d 	.word	0x00000d2d
  34:	00000000 	.word	0x00000000
  38:	00000d2f 	.word	0x00000d2f
  3c:	00000d31 	.word	0x00000d31
  40:	00000d33 	.word	0x00000d33
  44:	00000d33 	.word	0x00000d33
  48:	00000d33 	.word	0x00000d33
  4c:	00000d33 	.word	0x00000d33
  50:	00000d33 	.word	0x00000d33
  54:	00000d33 	.word	0x00000d33
  58:	00000d33 	.word	0x00000d33
  5c:	00000d33 	.word	0x00000d33
  60:	00000d33 	.word	0x00000d33
  64:	00000d33 	.word	0x00000d33
  68:	00000d33 	.word	0x00000d33
  6c:	00000d33 	.word	0x00000d33
  70:	00000d33 	.word	0x00000d33
  74:	00000d33 	.word	0x00000d33
  78:	00000d33 	.word	0x00000d33
  7c:	00000d33 	.word	0x00000d33
  80:	00000d33 	.word	0x00000d33
  84:	00000d33 	.word	0x00000d33
  88:	00000d33 	.word	0x00000d33
  8c:	00000d33 	.word	0x00000d33
  90:	00000d33 	.word	0x00000d33
  94:	00000d33 	.word	0x00000d33
  98:	00000d33 	.word	0x00000d33
  9c:	00000d33 	.word	0x00000d33
  a0:	00000d33 	.word	0x00000d33
  a4:	00000d33 	.word	0x00000d33
  a8:	00000d33 	.word	0x00000d33
  ac:	00000d33 	.word	0x00000d33
  b0:	00000d33 	.word	0x00000d33
  b4:	00000d33 	.word	0x00000d33
  b8:	00000d33 	.word	0x00000d33
  bc:	00000d33 	.word	0x00000d33
  c0:	00000d33 	.word	0x00000d33
  c4:	00000d33 	.word	0x00000d33
  c8:	00000d33 	.word	0x00000d33
  cc:	00000d33 	.word	0x00000d33
  d0:	00000d33 	.word	0x00000d33
  d4:	00000d33 	.word	0x00000d33
  d8:	00000d33 	.word	0x00000d33
  dc:	00000d33 	.word	0x00000d33
  e0:	00000d33 	.word	0x00000d33
  e4:	00000d33 	.word	0x00000d33
  e8:	00000d33 	.word	0x00000d33
  ec:	00000d33 	.word	0x00000d33
  f0:	00000d33 	.word	0x00000d33
  f4:	00000d33 	.word	0x00000d33
  f8:	00000d33 	.word	0x00000d33
  fc:	00000d33 	.word	0x00000d33
 100:	00000d33 	.word	0x00000d33
 104:	00000d33 	.word	0x00000d33
 108:	00000d33 	.word	0x00000d33
 10c:	00000d33 	.word	0x00000d33
 110:	00000d33 	.word	0x00000d33
 114:	00000d33 	.word	0x00000d33
 118:	00000d33 	.word	0x00000d33
 11c:	00000d33 	.word	0x00000d33
 120:	00000d33 	.word	0x00000d33
 124:	00000d33 	.word	0x00000d33
 128:	00000d33 	.word	0x00000d33
 12c:	00000d33 	.word	0x00000d33
 130:	00000d33 	.word	0x00000d33
 134:	00000d33 	.word	0x00000d33
 138:	00000d33 	.word	0x00000d33
 13c:	00000d33 	.word	0x00000d33
 140:	00000d33 	.word	0x00000d33
 144:	00000d33 	.word	0x00000d33
 148:	00000d33 	.word	0x00000d33
 14c:	00000d33 	.word	0x00000d33
 150:	00000d33 	.word	0x00000d33
 154:	00000d33 	.word	0x00000d33
 158:	00000d33 	.word	0x00000d33
 15c:	00000d33 	.word	0x00000d33
 160:	00000d33 	.word	0x00000d33
 164:	00000d33 	.word	0x00000d33
 168:	00000d33 	.word	0x00000d33
 16c:	00000d33 	.word	0x00000d33
 170:	00000d33 	.word	0x00000d33
 174:	00000d33 	.word	0x00000d33
 178:	00000d33 	.word	0x00000d33
 17c:	00000d33 	.word	0x00000d33
 180:	00000d33 	.word	0x00000d33
 184:	00000d33 	.word	0x00000d33
 188:	00000d33 	.word	0x00000d33
 18c:	00000d33 	.word	0x00000d33
 190:	00000d33 	.word	0x00000d33
 194:	00000d33 	.word	0x00000d33
 198:	00000d33 	.word	0x00000d33
 19c:	00000d33 	.word	0x00000d33
 1a0:	00000d33 	.word	0x00000d33
 1a4:	00000d33 	.word	0x00000d33
 1a8:	00000d33 	.word	0x00000d33
 1ac:	00000d33 	.word	0x00000d33
 1b0:	00000d33 	.word	0x00000d33
 1b4:	00000d33 	.word	0x00000d33
 1b8:	00000d33 	.word	0x00000d33
 1bc:	00000d33 	.word	0x00000d33
 1c0:	00000d33 	.word	0x00000d33
 1c4:	00000d33 	.word	0x00000d33
 1c8:	00000d33 	.word	0x00000d33
 1cc:	00000d33 	.word	0x00000d33
 1d0:	00000d33 	.word	0x00000d33
 1d4:	00000d33 	.word	0x00000d33
 1d8:	00000d33 	.word	0x00000d33
 1dc:	00000d33 	.word	0x00000d33
 1e0:	00000d33 	.word	0x00000d33
 1e4:	00000d33 	.word	0x00000d33
 1e8:	00000d33 	.word	0x00000d33
 1ec:	00000d33 	.word	0x00000d33
 1f0:	00000d33 	.word	0x00000d33
 1f4:	00000d33 	.word	0x00000d33
 1f8:	00000d33 	.word	0x00000d33
 1fc:	00000d33 	.word	0x00000d33
 200:	00000d33 	.word	0x00000d33
 204:	00000d33 	.word	0x00000d33
 208:	00000d33 	.word	0x00000d33
 20c:	00000d33 	.word	0x00000d33
 210:	00000d33 	.word	0x00000d33
 214:	00000d33 	.word	0x00000d33
 218:	00000d33 	.word	0x00000d33
 21c:	00000d33 	.word	0x00000d33
 220:	00000d33 	.word	0x00000d33
 224:	00000d33 	.word	0x00000d33
 228:	00000d33 	.word	0x00000d33
 22c:	00000d33 	.word	0x00000d33
 230:	00000d33 	.word	0x00000d33
 234:	00000d33 	.word	0x00000d33
 238:	00000d33 	.word	0x00000d33
 23c:	00000d33 	.word	0x00000d33
 240:	00000d33 	.word	0x00000d33
 244:	00000d33 	.word	0x00000d33
 248:	00000d33 	.word	0x00000d33
 24c:	00000d33 	.word	0x00000d33
 250:	00000d33 	.word	0x00000d33
 254:	00000d33 	.word	0x00000d33
 258:	00000d33 	.word	0x00000d33
 25c:	00000d33 	.word	0x00000d33
 260:	00000d33 	.word	0x00000d33
 264:	00000d33 	.word	0x00000d33
 268:	00000d33 	.word	0x00000d33
 26c:	00000d33 	.word	0x00000d33
 270:	00000d33 	.word	0x00000d33
 274:	00000d33 	.word	0x00000d33
 278:	00000d33 	.word	0x00000d33
 27c:	00000d33 	.word	0x00000d33
 280:	00000d33 	.word	0x00000d33
 284:	00000d33 	.word	0x00000d33
 288:	00000d33 	.word	0x00000d33
 28c:	00000d33 	.word	0x00000d33
 290:	00000d33 	.word	0x00000d33
 294:	00000d33 	.word	0x00000d33
 298:	00000d33 	.word	0x00000d33
 29c:	00000d33 	.word	0x00000d33
 2a0:	00000d33 	.word	0x00000d33
 2a4:	00000d33 	.word	0x00000d33
 2a8:	00000d33 	.word	0x00000d33
 2ac:	00000d33 	.word	0x00000d33
 2b0:	00000d33 	.word	0x00000d33
 2b4:	00000d33 	.word	0x00000d33
 2b8:	00000d33 	.word	0x00000d33
 2bc:	00000d33 	.word	0x00000d33
 2c0:	00000d33 	.word	0x00000d33
 2c4:	00000d33 	.word	0x00000d33
 2c8:	00000d33 	.word	0x00000d33
 2cc:	00000d33 	.word	0x00000d33
 2d0:	00000d33 	.word	0x00000d33
 2d4:	00000d33 	.word	0x00000d33
 2d8:	00000d33 	.word	0x00000d33
 2dc:	00000d33 	.word	0x00000d33
 2e0:	00000d33 	.word	0x00000d33
 2e4:	00000d33 	.word	0x00000d33
 2e8:	00000d33 	.word	0x00000d33
 2ec:	00000d33 	.word	0x00000d33
 2f0:	00000d33 	.word	0x00000d33
 2f4:	00000d33 	.word	0x00000d33
 2f8:	00000d33 	.word	0x00000d33
 2fc:	00000d33 	.word	0x00000d33
 300:	00000d33 	.word	0x00000d33
 304:	00000d33 	.word	0x00000d33
 308:	00000d33 	.word	0x00000d33
 30c:	00000d33 	.word	0x00000d33

Disassembly of section .flash:

00000410 <_start>:
     410:	b672      	cpsid	i
     412:	f04f 0000 	mov.w	r0, #0
     416:	f04f 0100 	mov.w	r1, #0
     41a:	f04f 0200 	mov.w	r2, #0
     41e:	f04f 0300 	mov.w	r3, #0
     422:	f04f 0400 	mov.w	r4, #0
     426:	f04f 0500 	mov.w	r5, #0
     42a:	f04f 0600 	mov.w	r6, #0
     42e:	f04f 0700 	mov.w	r7, #0
     432:	481b      	ldr	r0, [pc, #108]	; (4a0 <_end_of_eunit_test+0xa>)
     434:	f44f 1140 	mov.w	r1, #3145728	; 0x300000
     438:	6001      	str	r1, [r0, #0]

0000043a <SetVTOR>:
     43a:	481a      	ldr	r0, [pc, #104]	; (4a4 <_end_of_eunit_test+0xe>)
     43c:	491a      	ldr	r1, [pc, #104]	; (4a8 <_end_of_eunit_test+0x12>)
     43e:	6001      	str	r1, [r0, #0]

00000440 <SetCore0Stack>:
     440:	481a      	ldr	r0, [pc, #104]	; (4ac <_end_of_eunit_test+0x16>)
     442:	f380 8808 	msr	MSP, r0
     446:	e7ff      	b.n	448 <DisableSWT0>

00000448 <DisableSWT0>:
     448:	4819      	ldr	r0, [pc, #100]	; (4b0 <_end_of_eunit_test+0x1a>)
     44a:	f242 5120 	movw	r1, #9504	; 0x2520
     44e:	6001      	str	r1, [r0, #0]
     450:	4818      	ldr	r0, [pc, #96]	; (4b4 <_end_of_eunit_test+0x1e>)
     452:	f64f 71ff 	movw	r1, #65535	; 0xffff
     456:	6001      	str	r1, [r0, #0]
     458:	e7ff      	b.n	45a <RamInit>

0000045a <RamInit>:
     45a:	4817      	ldr	r0, [pc, #92]	; (4b8 <_end_of_eunit_test+0x22>)
     45c:	2800      	cmp	r0, #0
     45e:	d009      	beq.n	474 <DebuggerHeldCoreLoop>
     460:	4916      	ldr	r1, [pc, #88]	; (4bc <_end_of_eunit_test+0x26>)
     462:	4a17      	ldr	r2, [pc, #92]	; (4c0 <_end_of_eunit_test+0x2a>)
     464:	1a52      	subs	r2, r2, r1
     466:	3a01      	subs	r2, #1
     468:	dd04      	ble.n	474 <DebuggerHeldCoreLoop>
     46a:	2000      	movs	r0, #0
     46c:	2300      	movs	r3, #0

0000046e <SRAM_LOOP>:
     46e:	c109      	stmia	r1!, {r0, r3}
     470:	3a08      	subs	r2, #8
     472:	dafc      	bge.n	46e <SRAM_LOOP>

00000474 <DebuggerHeldCoreLoop>:
     474:	4813      	ldr	r0, [pc, #76]	; (4c4 <_end_of_eunit_test+0x2e>)
     476:	6800      	ldr	r0, [r0, #0]
     478:	f04f 315a 	mov.w	r1, #1515870810	; 0x5a5a5a5a
     47c:	4288      	cmp	r0, r1
     47e:	d0f9      	beq.n	474 <DebuggerHeldCoreLoop>

00000480 <_DATA_INIT>:
     480:	e7ff      	b.n	482 <_INIT_DATA_BSS>

00000482 <_INIT_DATA_BSS>:
     482:	f000 fb85 	bl	b90 <init_data_bss>

00000486 <__SYSTEM_INIT>:
     486:	f000 f81f 	bl	4c8 <SystemInit>

0000048a <_MAIN>:
     48a:	b662      	cpsie	i
     48c:	f000 fc44 	bl	d18 <startup_go_to_user_mode>
     490:	f000 fa0e 	bl	8b0 <main>

00000494 <MCAL_LTB_TRACE_OFF>:
     494:	bf00      	nop

00000496 <_end_of_eunit_test>:
     496:	e7fe      	b.n	496 <_end_of_eunit_test>
     498:	f3af 8000 	nop.w
     49c:	f3af 8000 	nop.w
     4a0:	40048004 	.word	0x40048004
     4a4:	e000ed08 	.word	0xe000ed08
     4a8:	1fff8800 	.word	0x1fff8800
     4ac:	20007000 	.word	0x20007000
     4b0:	40052000 	.word	0x40052000
     4b4:	40052008 	.word	0x40052008
     4b8:	00000001 	.word	0x00000001
     4bc:	1fff8000 	.word	0x1fff8000
     4c0:	20007000 	.word	0x20007000
     4c4:	1fff9900 	.word	0x1fff9900

000004c8 <SystemInit>:
#else
    __attribute__ ((section (".systeminit")))
#endif 

void SystemInit(void)
{
     4c8:	b508      	push	{r3, lr}
/**************************************************************************/
                      /* FPU ENABLE*/
/**************************************************************************/
#ifdef ENABLE_FPU
    /* Enable CP10 and CP11 coprocessors */
    S32_SCB->CPACR |= (S32_SCB_CPACR_CPx(10U, 3U) | S32_SCB_CPACR_CPx(11U, 3U)); 
     4ca:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     4ce:	f8d3 3d88 	ldr.w	r3, [r3, #3464]	; 0xd88
     4d2:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
     4d6:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
     4da:	f8c2 3d88 	str.w	r3, [r2, #3464]	; 0xd88

    ASM_KEYWORD("dsb");
     4de:	f3bf 8f4f 	dsb	sy
    ASM_KEYWORD("isb");
     4e2:	f3bf 8f6f 	isb	sy
#endif /* ENABLE_FPU */

#ifdef ENABLE_THREAD_MODE_ENTRY_CONFIGURATION
    S32_SCB->CCR    |=  1u;       /**< processor can enter Thread mode from any level under the 
     4e6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     4ea:	f8d3 3d14 	ldr.w	r3, [r3, #3348]	; 0xd14
     4ee:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
     4f2:	f043 0301 	orr.w	r3, r3, #1
     4f6:	f8c2 3d14 	str.w	r3, [r2, #3348]	; 0xd14
                                   control of an EXC_RETURN value, PendSV priority set to 0*/
#endif
    S32_SCB->SHPR3 &= ~S32_SCB_SHPR3_PRI_14_MASK; 
     4fa:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     4fe:	f8d3 3d20 	ldr.w	r3, [r3, #3360]	; 0xd20
     502:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
     506:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
     50a:	f8c2 3d20 	str.w	r3, [r2, #3360]	; 0xd20
    
    /* enable the AIPS */
    IP_AIPS->MPRA = 0x77777777;      
     50e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     512:	f04f 3277 	mov.w	r2, #2004318071	; 0x77777777
     516:	601a      	str	r2, [r3, #0]
    IP_AIPS->PACRA  = 0x0; 
     518:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     51c:	2200      	movs	r2, #0
     51e:	621a      	str	r2, [r3, #32]
    IP_AIPS->PACRB  = 0x0; 
     520:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     524:	2200      	movs	r2, #0
     526:	625a      	str	r2, [r3, #36]	; 0x24
    IP_AIPS->PACRD  = 0x0;
     528:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     52c:	2200      	movs	r2, #0
     52e:	62da      	str	r2, [r3, #44]	; 0x2c
    IP_AIPS->OPACR[0] = 0x0; 
     530:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     534:	2200      	movs	r2, #0
     536:	641a      	str	r2, [r3, #64]	; 0x40
    IP_AIPS->OPACR[1] = 0x0; 
     538:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     53c:	2200      	movs	r2, #0
     53e:	645a      	str	r2, [r3, #68]	; 0x44
    IP_AIPS->OPACR[2] = 0x0; 
     540:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     544:	2200      	movs	r2, #0
     546:	649a      	str	r2, [r3, #72]	; 0x48
    IP_AIPS->OPACR[3] = 0x0; 
     548:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     54c:	2200      	movs	r2, #0
     54e:	64da      	str	r2, [r3, #76]	; 0x4c
    IP_AIPS->OPACR[4] = 0x0; 
     550:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     554:	2200      	movs	r2, #0
     556:	651a      	str	r2, [r3, #80]	; 0x50
    IP_AIPS->OPACR[5] = 0x0; 
     558:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     55c:	2200      	movs	r2, #0
     55e:	655a      	str	r2, [r3, #84]	; 0x54
    IP_AIPS->OPACR[6] = 0x0; 
     560:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     564:	2200      	movs	r2, #0
     566:	659a      	str	r2, [r3, #88]	; 0x58
    IP_AIPS->OPACR[7] = 0x0; 
     568:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     56c:	2200      	movs	r2, #0
     56e:	65da      	str	r2, [r3, #92]	; 0x5c
    IP_AIPS->OPACR[8] = 0x0; 
     570:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     574:	2200      	movs	r2, #0
     576:	661a      	str	r2, [r3, #96]	; 0x60
    IP_AIPS->OPACR[9] = 0x0; 
     578:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     57c:	2200      	movs	r2, #0
     57e:	665a      	str	r2, [r3, #100]	; 0x64
    IP_AIPS->OPACR[10] = 0x0;
     580:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     584:	2200      	movs	r2, #0
     586:	669a      	str	r2, [r3, #104]	; 0x68
    IP_AIPS->OPACR[11] = 0x0;
     588:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     58c:	2200      	movs	r2, #0
     58e:	66da      	str	r2, [r3, #108]	; 0x6c

/**************************************************************************/
                      /* DEFAULT MEMORY ENABLE*/
/**************************************************************************/
    ASM_KEYWORD("dsb");
     590:	f3bf 8f4f 	dsb	sy
    ASM_KEYWORD("isb");
     594:	f3bf 8f6f 	isb	sy

#ifdef I_CACHE_ENABLE  
/**************************************************************************/
            /* ENABLE CACHE */
/**************************************************************************/
    (void)sys_m4_cache_init(CODE_CACHE);    
     598:	2000      	movs	r0, #0
     59a:	f000 fb8f 	bl	cbc <sys_m4_cache_init>
#endif
}
     59e:	bf00      	nop
     5a0:	bd08      	pop	{r3, pc}

000005a2 <NMI_Handler>:
#endif


void NMI_Handler(void)
{
    while(TRUE){};
     5a2:	e7fe      	b.n	5a2 <NMI_Handler>

000005a4 <__aeabi_uldivmod>:
     5a4:	b953      	cbnz	r3, 5bc <__aeabi_uldivmod+0x18>
     5a6:	b94a      	cbnz	r2, 5bc <__aeabi_uldivmod+0x18>
     5a8:	2900      	cmp	r1, #0
     5aa:	bf08      	it	eq
     5ac:	2800      	cmpeq	r0, #0
     5ae:	bf1c      	itt	ne
     5b0:	f04f 31ff 	movne.w	r1, #4294967295
     5b4:	f04f 30ff 	movne.w	r0, #4294967295
     5b8:	f000 b978 	b.w	8ac <__aeabi_idiv0>
     5bc:	f1ad 0c08 	sub.w	ip, sp, #8
     5c0:	e96d ce04 	strd	ip, lr, [sp, #-16]!
     5c4:	f000 f806 	bl	5d4 <__udivmoddi4>
     5c8:	f8dd e004 	ldr.w	lr, [sp, #4]
     5cc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     5d0:	b004      	add	sp, #16
     5d2:	4770      	bx	lr

000005d4 <__udivmoddi4>:
     5d4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     5d8:	9d08      	ldr	r5, [sp, #32]
     5da:	460e      	mov	r6, r1
     5dc:	4604      	mov	r4, r0
     5de:	468e      	mov	lr, r1
     5e0:	2b00      	cmp	r3, #0
     5e2:	d14c      	bne.n	67e <__udivmoddi4+0xaa>
     5e4:	428a      	cmp	r2, r1
     5e6:	4694      	mov	ip, r2
     5e8:	d967      	bls.n	6ba <__udivmoddi4+0xe6>
     5ea:	fab2 f282 	clz	r2, r2
     5ee:	b152      	cbz	r2, 606 <__udivmoddi4+0x32>
     5f0:	fa01 f302 	lsl.w	r3, r1, r2
     5f4:	f1c2 0120 	rsb	r1, r2, #32
     5f8:	fa20 f101 	lsr.w	r1, r0, r1
     5fc:	fa0c fc02 	lsl.w	ip, ip, r2
     600:	ea41 0e03 	orr.w	lr, r1, r3
     604:	4094      	lsls	r4, r2
     606:	ea4f 481c 	mov.w	r8, ip, lsr #16
     60a:	0c21      	lsrs	r1, r4, #16
     60c:	fbbe f6f8 	udiv	r6, lr, r8
     610:	fa1f f78c 	uxth.w	r7, ip
     614:	fb08 e316 	mls	r3, r8, r6, lr
     618:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
     61c:	fb06 f107 	mul.w	r1, r6, r7
     620:	4299      	cmp	r1, r3
     622:	d90a      	bls.n	63a <__udivmoddi4+0x66>
     624:	eb1c 0303 	adds.w	r3, ip, r3
     628:	f106 30ff 	add.w	r0, r6, #4294967295
     62c:	f080 811e 	bcs.w	86c <__udivmoddi4+0x298>
     630:	4299      	cmp	r1, r3
     632:	f240 811b 	bls.w	86c <__udivmoddi4+0x298>
     636:	3e02      	subs	r6, #2
     638:	4463      	add	r3, ip
     63a:	1a5b      	subs	r3, r3, r1
     63c:	b2a4      	uxth	r4, r4
     63e:	fbb3 f0f8 	udiv	r0, r3, r8
     642:	fb08 3310 	mls	r3, r8, r0, r3
     646:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
     64a:	fb00 f707 	mul.w	r7, r0, r7
     64e:	42a7      	cmp	r7, r4
     650:	d90a      	bls.n	668 <__udivmoddi4+0x94>
     652:	eb1c 0404 	adds.w	r4, ip, r4
     656:	f100 33ff 	add.w	r3, r0, #4294967295
     65a:	f080 8109 	bcs.w	870 <__udivmoddi4+0x29c>
     65e:	42a7      	cmp	r7, r4
     660:	f240 8106 	bls.w	870 <__udivmoddi4+0x29c>
     664:	4464      	add	r4, ip
     666:	3802      	subs	r0, #2
     668:	1be4      	subs	r4, r4, r7
     66a:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
     66e:	2100      	movs	r1, #0
     670:	b11d      	cbz	r5, 67a <__udivmoddi4+0xa6>
     672:	40d4      	lsrs	r4, r2
     674:	2300      	movs	r3, #0
     676:	e9c5 4300 	strd	r4, r3, [r5]
     67a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     67e:	428b      	cmp	r3, r1
     680:	d908      	bls.n	694 <__udivmoddi4+0xc0>
     682:	2d00      	cmp	r5, #0
     684:	f000 80ef 	beq.w	866 <__udivmoddi4+0x292>
     688:	2100      	movs	r1, #0
     68a:	e9c5 0600 	strd	r0, r6, [r5]
     68e:	4608      	mov	r0, r1
     690:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     694:	fab3 f183 	clz	r1, r3
     698:	2900      	cmp	r1, #0
     69a:	d149      	bne.n	730 <__udivmoddi4+0x15c>
     69c:	42b3      	cmp	r3, r6
     69e:	d302      	bcc.n	6a6 <__udivmoddi4+0xd2>
     6a0:	4282      	cmp	r2, r0
     6a2:	f200 80ff 	bhi.w	8a4 <__udivmoddi4+0x2d0>
     6a6:	1a84      	subs	r4, r0, r2
     6a8:	eb66 0303 	sbc.w	r3, r6, r3
     6ac:	2001      	movs	r0, #1
     6ae:	469e      	mov	lr, r3
     6b0:	2d00      	cmp	r5, #0
     6b2:	d0e2      	beq.n	67a <__udivmoddi4+0xa6>
     6b4:	e9c5 4e00 	strd	r4, lr, [r5]
     6b8:	e7df      	b.n	67a <__udivmoddi4+0xa6>
     6ba:	b902      	cbnz	r2, 6be <__udivmoddi4+0xea>
     6bc:	deff      	udf	#255	; 0xff
     6be:	fab2 f282 	clz	r2, r2
     6c2:	2a00      	cmp	r2, #0
     6c4:	f040 808e 	bne.w	7e4 <__udivmoddi4+0x210>
     6c8:	eba1 060c 	sub.w	r6, r1, ip
     6cc:	ea4f 471c 	mov.w	r7, ip, lsr #16
     6d0:	fa1f f38c 	uxth.w	r3, ip
     6d4:	2101      	movs	r1, #1
     6d6:	fbb6 fef7 	udiv	lr, r6, r7
     6da:	fb07 601e 	mls	r0, r7, lr, r6
     6de:	0c26      	lsrs	r6, r4, #16
     6e0:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
     6e4:	fb03 f00e 	mul.w	r0, r3, lr
     6e8:	42b0      	cmp	r0, r6
     6ea:	d908      	bls.n	6fe <__udivmoddi4+0x12a>
     6ec:	eb1c 0606 	adds.w	r6, ip, r6
     6f0:	f10e 38ff 	add.w	r8, lr, #4294967295
     6f4:	d202      	bcs.n	6fc <__udivmoddi4+0x128>
     6f6:	42b0      	cmp	r0, r6
     6f8:	f200 80d0 	bhi.w	89c <__udivmoddi4+0x2c8>
     6fc:	46c6      	mov	lr, r8
     6fe:	1a36      	subs	r6, r6, r0
     700:	b2a4      	uxth	r4, r4
     702:	fbb6 f0f7 	udiv	r0, r6, r7
     706:	fb07 6610 	mls	r6, r7, r0, r6
     70a:	ea44 4406 	orr.w	r4, r4, r6, lsl #16
     70e:	fb00 f303 	mul.w	r3, r0, r3
     712:	42a3      	cmp	r3, r4
     714:	d908      	bls.n	728 <__udivmoddi4+0x154>
     716:	eb1c 0404 	adds.w	r4, ip, r4
     71a:	f100 36ff 	add.w	r6, r0, #4294967295
     71e:	d202      	bcs.n	726 <__udivmoddi4+0x152>
     720:	42a3      	cmp	r3, r4
     722:	f200 80b8 	bhi.w	896 <__udivmoddi4+0x2c2>
     726:	4630      	mov	r0, r6
     728:	1ae4      	subs	r4, r4, r3
     72a:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     72e:	e79f      	b.n	670 <__udivmoddi4+0x9c>
     730:	f1c1 0720 	rsb	r7, r1, #32
     734:	fa22 f407 	lsr.w	r4, r2, r7
     738:	408b      	lsls	r3, r1
     73a:	4323      	orrs	r3, r4
     73c:	fa06 fc01 	lsl.w	ip, r6, r1
     740:	fa26 f407 	lsr.w	r4, r6, r7
     744:	fa20 f607 	lsr.w	r6, r0, r7
     748:	ea46 060c 	orr.w	r6, r6, ip
     74c:	ea4f 4913 	mov.w	r9, r3, lsr #16
     750:	fa00 f801 	lsl.w	r8, r0, r1
     754:	fbb4 fef9 	udiv	lr, r4, r9
     758:	0c30      	lsrs	r0, r6, #16
     75a:	fa1f fc83 	uxth.w	ip, r3
     75e:	fb09 441e 	mls	r4, r9, lr, r4
     762:	ea40 4404 	orr.w	r4, r0, r4, lsl #16
     766:	fb0e f00c 	mul.w	r0, lr, ip
     76a:	42a0      	cmp	r0, r4
     76c:	fa02 f201 	lsl.w	r2, r2, r1
     770:	d90a      	bls.n	788 <__udivmoddi4+0x1b4>
     772:	191c      	adds	r4, r3, r4
     774:	f10e 3aff 	add.w	sl, lr, #4294967295
     778:	f080 808b 	bcs.w	892 <__udivmoddi4+0x2be>
     77c:	42a0      	cmp	r0, r4
     77e:	f240 8088 	bls.w	892 <__udivmoddi4+0x2be>
     782:	f1ae 0e02 	sub.w	lr, lr, #2
     786:	441c      	add	r4, r3
     788:	1a24      	subs	r4, r4, r0
     78a:	b2b6      	uxth	r6, r6
     78c:	fbb4 f0f9 	udiv	r0, r4, r9
     790:	fb09 4410 	mls	r4, r9, r0, r4
     794:	ea46 4404 	orr.w	r4, r6, r4, lsl #16
     798:	fb00 fc0c 	mul.w	ip, r0, ip
     79c:	45a4      	cmp	ip, r4
     79e:	d907      	bls.n	7b0 <__udivmoddi4+0x1dc>
     7a0:	191c      	adds	r4, r3, r4
     7a2:	f100 36ff 	add.w	r6, r0, #4294967295
     7a6:	d270      	bcs.n	88a <__udivmoddi4+0x2b6>
     7a8:	45a4      	cmp	ip, r4
     7aa:	d96e      	bls.n	88a <__udivmoddi4+0x2b6>
     7ac:	3802      	subs	r0, #2
     7ae:	441c      	add	r4, r3
     7b0:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     7b4:	fba0 e602 	umull	lr, r6, r0, r2
     7b8:	eba4 040c 	sub.w	r4, r4, ip
     7bc:	42b4      	cmp	r4, r6
     7be:	46f4      	mov	ip, lr
     7c0:	46b1      	mov	r9, r6
     7c2:	d359      	bcc.n	878 <__udivmoddi4+0x2a4>
     7c4:	d056      	beq.n	874 <__udivmoddi4+0x2a0>
     7c6:	2d00      	cmp	r5, #0
     7c8:	d06e      	beq.n	8a8 <__udivmoddi4+0x2d4>
     7ca:	ebb8 030c 	subs.w	r3, r8, ip
     7ce:	eb64 0409 	sbc.w	r4, r4, r9
     7d2:	40cb      	lsrs	r3, r1
     7d4:	fa04 f707 	lsl.w	r7, r4, r7
     7d8:	431f      	orrs	r7, r3
     7da:	40cc      	lsrs	r4, r1
     7dc:	e9c5 7400 	strd	r7, r4, [r5]
     7e0:	2100      	movs	r1, #0
     7e2:	e74a      	b.n	67a <__udivmoddi4+0xa6>
     7e4:	f1c2 0020 	rsb	r0, r2, #32
     7e8:	fa24 f100 	lsr.w	r1, r4, r0
     7ec:	fa0c fc02 	lsl.w	ip, ip, r2
     7f0:	fa06 f302 	lsl.w	r3, r6, r2
     7f4:	fa26 f000 	lsr.w	r0, r6, r0
     7f8:	ea4f 471c 	mov.w	r7, ip, lsr #16
     7fc:	ea41 0603 	orr.w	r6, r1, r3
     800:	fbb0 f1f7 	udiv	r1, r0, r7
     804:	fa1f f38c 	uxth.w	r3, ip
     808:	fb07 0e11 	mls	lr, r7, r1, r0
     80c:	0c30      	lsrs	r0, r6, #16
     80e:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     812:	fb01 fe03 	mul.w	lr, r1, r3
     816:	4586      	cmp	lr, r0
     818:	fa04 f402 	lsl.w	r4, r4, r2
     81c:	d908      	bls.n	830 <__udivmoddi4+0x25c>
     81e:	eb1c 0000 	adds.w	r0, ip, r0
     822:	f101 38ff 	add.w	r8, r1, #4294967295
     826:	d232      	bcs.n	88e <__udivmoddi4+0x2ba>
     828:	4586      	cmp	lr, r0
     82a:	d930      	bls.n	88e <__udivmoddi4+0x2ba>
     82c:	3902      	subs	r1, #2
     82e:	4460      	add	r0, ip
     830:	eba0 000e 	sub.w	r0, r0, lr
     834:	b2b6      	uxth	r6, r6
     836:	fbb0 fef7 	udiv	lr, r0, r7
     83a:	fb07 001e 	mls	r0, r7, lr, r0
     83e:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
     842:	fb0e f003 	mul.w	r0, lr, r3
     846:	42b0      	cmp	r0, r6
     848:	d909      	bls.n	85e <__udivmoddi4+0x28a>
     84a:	eb1c 0606 	adds.w	r6, ip, r6
     84e:	f10e 38ff 	add.w	r8, lr, #4294967295
     852:	d218      	bcs.n	886 <__udivmoddi4+0x2b2>
     854:	42b0      	cmp	r0, r6
     856:	d916      	bls.n	886 <__udivmoddi4+0x2b2>
     858:	f1ae 0e02 	sub.w	lr, lr, #2
     85c:	4466      	add	r6, ip
     85e:	1a36      	subs	r6, r6, r0
     860:	ea4e 4101 	orr.w	r1, lr, r1, lsl #16
     864:	e737      	b.n	6d6 <__udivmoddi4+0x102>
     866:	4629      	mov	r1, r5
     868:	4628      	mov	r0, r5
     86a:	e706      	b.n	67a <__udivmoddi4+0xa6>
     86c:	4606      	mov	r6, r0
     86e:	e6e4      	b.n	63a <__udivmoddi4+0x66>
     870:	4618      	mov	r0, r3
     872:	e6f9      	b.n	668 <__udivmoddi4+0x94>
     874:	45f0      	cmp	r8, lr
     876:	d2a6      	bcs.n	7c6 <__udivmoddi4+0x1f2>
     878:	ebbe 0c02 	subs.w	ip, lr, r2
     87c:	eb66 0303 	sbc.w	r3, r6, r3
     880:	3801      	subs	r0, #1
     882:	4699      	mov	r9, r3
     884:	e79f      	b.n	7c6 <__udivmoddi4+0x1f2>
     886:	46c6      	mov	lr, r8
     888:	e7e9      	b.n	85e <__udivmoddi4+0x28a>
     88a:	4630      	mov	r0, r6
     88c:	e790      	b.n	7b0 <__udivmoddi4+0x1dc>
     88e:	4641      	mov	r1, r8
     890:	e7ce      	b.n	830 <__udivmoddi4+0x25c>
     892:	46d6      	mov	lr, sl
     894:	e778      	b.n	788 <__udivmoddi4+0x1b4>
     896:	4464      	add	r4, ip
     898:	3802      	subs	r0, #2
     89a:	e745      	b.n	728 <__udivmoddi4+0x154>
     89c:	f1ae 0e02 	sub.w	lr, lr, #2
     8a0:	4466      	add	r6, ip
     8a2:	e72c      	b.n	6fe <__udivmoddi4+0x12a>
     8a4:	4608      	mov	r0, r1
     8a6:	e703      	b.n	6b0 <__udivmoddi4+0xdc>
     8a8:	4629      	mov	r1, r5
     8aa:	e6e6      	b.n	67a <__udivmoddi4+0xa6>

000008ac <__aeabi_idiv0>:
     8ac:	4770      	bx	lr
     8ae:	bf00      	nop

000008b0 <main>:
 * In this case only one HTH is used for transmission with four message buffers. For reception 4 HRH are utilized.
 * 
 * 
 * @return Always zero
*/
int main( void ) {
     8b0:	b500      	push	{lr}
     8b2:	b097      	sub	sp, #92	; 0x5c
    //local data.
    //Transmit message (PDU) 0 (Message ID 0x100) for Can 0 controller.
    uint8 Message0_SDU[3] = { 0xDE, 0xF4, 0xC9 }; //Data payload for message.
     8b4:	4a2c      	ldr	r2, [pc, #176]	; (968 <main+0xb8>)
     8b6:	ab15      	add	r3, sp, #84	; 0x54
     8b8:	6812      	ldr	r2, [r2, #0]
     8ba:	4611      	mov	r1, r2
     8bc:	8019      	strh	r1, [r3, #0]
     8be:	3302      	adds	r3, #2
     8c0:	0c12      	lsrs	r2, r2, #16
     8c2:	701a      	strb	r2, [r3, #0]
    PduInfoType Message0 = {
     8c4:	ab15      	add	r3, sp, #84	; 0x54
     8c6:	9312      	str	r3, [sp, #72]	; 0x48
     8c8:	2300      	movs	r3, #0
     8ca:	9313      	str	r3, [sp, #76]	; 0x4c
     8cc:	2303      	movs	r3, #3
     8ce:	9314      	str	r3, [sp, #80]	; 0x50
        .SduDataPtr = Message0_SDU,
        .MetaDataPtr = NULL_PTR
    };

    //Transmit message (PDU) 1 (Message ID 0x101) for Can 0 controller.
    uint8 Message1_SDU[8] = { 0xAA, 0xDE, 0xF4, 0xC5, 0xB6, 0xFE, 0xCC, 0x07 }; //Data payload for message.
     8d0:	4a26      	ldr	r2, [pc, #152]	; (96c <main+0xbc>)
     8d2:	ab10      	add	r3, sp, #64	; 0x40
     8d4:	e892 0003 	ldmia.w	r2, {r0, r1}
     8d8:	e883 0003 	stmia.w	r3, {r0, r1}
    PduInfoType Message1 = {
     8dc:	ab10      	add	r3, sp, #64	; 0x40
     8de:	930d      	str	r3, [sp, #52]	; 0x34
     8e0:	2300      	movs	r3, #0
     8e2:	930e      	str	r3, [sp, #56]	; 0x38
     8e4:	2308      	movs	r3, #8
     8e6:	930f      	str	r3, [sp, #60]	; 0x3c
        .SduDataPtr = Message1_SDU,
        .MetaDataPtr = NULL_PTR
    };

    //Transmit message (PDU) 2 (Message ID 0x102) for Can 0 controller.
    uint8 Message2_SDU[12] = { 0xBB, 0xDE, 0xCC, 0xAA, 0x22, 0x33, 0xDD, 0x05, 0x09, 0x45, 0xFF, 0x33 }; //Data payload for message.
     8e8:	4a21      	ldr	r2, [pc, #132]	; (970 <main+0xc0>)
     8ea:	ab0a      	add	r3, sp, #40	; 0x28
     8ec:	ca07      	ldmia	r2, {r0, r1, r2}
     8ee:	e883 0007 	stmia.w	r3, {r0, r1, r2}
    PduInfoType Message2 = {
     8f2:	ab0a      	add	r3, sp, #40	; 0x28
     8f4:	9307      	str	r3, [sp, #28]
     8f6:	2300      	movs	r3, #0
     8f8:	9308      	str	r3, [sp, #32]
     8fa:	230c      	movs	r3, #12
     8fc:	9309      	str	r3, [sp, #36]	; 0x24
        .SduDataPtr = Message2_SDU,
        .MetaDataPtr = NULL_PTR
    };

    //Transmit message (PDU) 3 (Message ID 0x103) for Can 0 controller.
    uint8 Message3_SDU[9] = { 0xFF, 0xDD, 0x22, 0x44, 0x53, 0x11, 0x46, 0x59, 0xBB }; //Data payload for message.
     8fe:	4a1d      	ldr	r2, [pc, #116]	; (974 <main+0xc4>)
     900:	ab04      	add	r3, sp, #16
     902:	ca07      	ldmia	r2, {r0, r1, r2}
     904:	c303      	stmia	r3!, {r0, r1}
     906:	701a      	strb	r2, [r3, #0]
    PduInfoType Message3 = {
     908:	ab04      	add	r3, sp, #16
     90a:	9301      	str	r3, [sp, #4]
     90c:	2300      	movs	r3, #0
     90e:	9302      	str	r3, [sp, #8]
     910:	2309      	movs	r3, #9
     912:	9303      	str	r3, [sp, #12]
        .SduLength = 9,
        .SduDataPtr = Message3_SDU,
        .MetaDataPtr = NULL_PTR
    };

    EcuM_Init();    //MCU configuration.
     914:	f000 ff2a 	bl	176c <EcuM_Init>

    //SBC by default is in force normal mode so the CAN transceiver is already active.

    CanIf_SetControllerMode( CanIfFlexCan0 , CAN_CS_STARTED );   //Can 0 controller active in Can Bus.
     918:	2101      	movs	r1, #1
     91a:	2001      	movs	r0, #1
     91c:	f016 fc6e 	bl	171fc <CanIf_SetControllerMode>

    while ( 1u ) {
        //Transmit messages every 3s.
        CanIf_Transmit( CanIfTxPDU_0, &Message0 );   //Writing in Can 0 message buffer 4
     920:	ab12      	add	r3, sp, #72	; 0x48
     922:	4619      	mov	r1, r3
     924:	2000      	movs	r0, #0
     926:	f016 fb19 	bl	16f5c <CanIf_Transmit>
        CanIf_Transmit( CanIfTxPDU_1, &Message1 );   //Writing in Can 0 message buffer 5
     92a:	ab0d      	add	r3, sp, #52	; 0x34
     92c:	4619      	mov	r1, r3
     92e:	2001      	movs	r0, #1
     930:	f016 fb14 	bl	16f5c <CanIf_Transmit>
        CanIf_Transmit( CanIfTxPDU_2, &Message2 );   //Writing in Can 0 message buffer 6
     934:	ab07      	add	r3, sp, #28
     936:	4619      	mov	r1, r3
     938:	2002      	movs	r0, #2
     93a:	f016 fb0f 	bl	16f5c <CanIf_Transmit>
        CanIf_Transmit( CanIfTxPDU_3, &Message3 );   //Writing in Can 0 message buffer 7
     93e:	ab01      	add	r3, sp, #4
     940:	4619      	mov	r1, r3
     942:	2003      	movs	r0, #3
     944:	f016 fb0a 	bl	16f5c <CanIf_Transmit>

        while ( CanIf_Can0_bTxFlag == FALSE ); //Waiting until messages are transmitted.
     948:	bf00      	nop
     94a:	4b0b      	ldr	r3, [pc, #44]	; (978 <main+0xc8>)
     94c:	781b      	ldrb	r3, [r3, #0]
     94e:	f083 0301 	eor.w	r3, r3, #1
     952:	b2db      	uxtb	r3, r3
     954:	2b00      	cmp	r3, #0
     956:	d1f8      	bne.n	94a <main+0x9a>
        CanIf_Can0_bTxFlag = FALSE;  //Clearing transmit flag.
     958:	4b07      	ldr	r3, [pc, #28]	; (978 <main+0xc8>)
     95a:	2200      	movs	r2, #0
     95c:	701a      	strb	r2, [r3, #0]

        Delay( 3000 );  //Waiting 3s for next transmission.
     95e:	f640 30b8 	movw	r0, #3000	; 0xbb8
     962:	f000 ff23 	bl	17ac <Delay>
        CanIf_Transmit( CanIfTxPDU_0, &Message0 );   //Writing in Can 0 message buffer 4
     966:	e7db      	b.n	920 <main+0x70>
     968:	00017500 	.word	0x00017500
     96c:	00017504 	.word	0x00017504
     970:	0001750c 	.word	0x0001750c
     974:	00017518 	.word	0x00017518
     978:	1fff8b30 	.word	0x1fff8b30

0000097c <DevAssert>:
    #error "Unsupported architecture!"
#endif

/* Implement default assert macro */
static inline void DevAssert(volatile boolean x)
{
     97c:	b082      	sub	sp, #8
     97e:	4603      	mov	r3, r0
     980:	f88d 3007 	strb.w	r3, [sp, #7]
    if(x) { } else { for(;;) {ASM_KEYWORD(BREAKPOINT_INSTR);} }
     984:	f89d 3007 	ldrb.w	r3, [sp, #7]
     988:	b2db      	uxtb	r3, r3
     98a:	2b00      	cmp	r3, #0
     98c:	d101      	bne.n	992 <DevAssert+0x16>
     98e:	be00      	bkpt	0x0000
     990:	e7fd      	b.n	98e <DevAssert+0x12>
}
     992:	bf00      	nop
     994:	b002      	add	sp, #8
     996:	4770      	bx	lr

00000998 <Adc_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Adc_schm_read_msr(void)
{
     998:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     99a:	f3ef 8310 	mrs	r3, PRIMASK
     99e:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     9a0:	4623      	mov	r3, r4
}
     9a2:	4618      	mov	r0, r3
     9a4:	f85d 4b04 	ldr.w	r4, [sp], #4
     9a8:	4770      	bx	lr

000009aa <Can_43_FLEXCAN_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Can_43_FLEXCAN_schm_read_msr(void)
{
     9aa:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     9ac:	f3ef 8310 	mrs	r3, PRIMASK
     9b0:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     9b2:	4623      	mov	r3, r4
}
     9b4:	4618      	mov	r0, r3
     9b6:	f85d 4b04 	ldr.w	r4, [sp], #4
     9ba:	4770      	bx	lr

000009bc <Mcu_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Mcu_schm_read_msr(void)
{
     9bc:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     9be:	f3ef 8310 	mrs	r3, PRIMASK
     9c2:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     9c4:	4623      	mov	r3, r4
}
     9c6:	4618      	mov	r0, r3
     9c8:	f85d 4b04 	ldr.w	r4, [sp], #4
     9cc:	4770      	bx	lr

000009ce <Port_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Port_schm_read_msr(void)
{
     9ce:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     9d0:	f3ef 8310 	mrs	r3, PRIMASK
     9d4:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     9d6:	4623      	mov	r3, r4
}
     9d8:	4618      	mov	r0, r3
     9da:	f85d 4b04 	ldr.w	r4, [sp], #4
     9de:	4770      	bx	lr

000009e0 <Spi_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Spi_schm_read_msr(void)
{
     9e0:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     9e2:	f3ef 8310 	mrs	r3, PRIMASK
     9e6:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     9e8:	4623      	mov	r3, r4
}
     9ea:	4618      	mov	r0, r3
     9ec:	f85d 4b04 	ldr.w	r4, [sp], #4
     9f0:	4770      	bx	lr
	...

000009f4 <CDD_UserTxConfirmation_Can_0>:
 * @brief Callback function for the complete transmit of a PDU (registered) from Can0 controller.
 * 
 * @param TxPduId ID (container) of the PDU transmitted.
 * @param result Status of the transmision operation.
 */
void CDD_UserTxConfirmation_Can_0( PduIdType TxPduId, Std_ReturnType result ) {
     9f4:	b082      	sub	sp, #8
     9f6:	4603      	mov	r3, r0
     9f8:	460a      	mov	r2, r1
     9fa:	f8ad 3006 	strh.w	r3, [sp, #6]
     9fe:	4613      	mov	r3, r2
     a00:	f88d 3005 	strb.w	r3, [sp, #5]
    //local data.
    static uint8 Transmit_count = 0;    //Count of transmitted PDUs.
    (void)TxPduId;

    if ( result == E_OK ) { //Message was transmitted successfully.
     a04:	f89d 3005 	ldrb.w	r3, [sp, #5]
     a08:	2b00      	cmp	r3, #0
     a0a:	d10f      	bne.n	a2c <CDD_UserTxConfirmation_Can_0+0x38>
        Transmit_count++;
     a0c:	4b09      	ldr	r3, [pc, #36]	; (a34 <CDD_UserTxConfirmation_Can_0+0x40>)
     a0e:	781b      	ldrb	r3, [r3, #0]
     a10:	3301      	adds	r3, #1
     a12:	b2da      	uxtb	r2, r3
     a14:	4b07      	ldr	r3, [pc, #28]	; (a34 <CDD_UserTxConfirmation_Can_0+0x40>)
     a16:	701a      	strb	r2, [r3, #0]

        if ( Transmit_count == 4 ) { //All messages were transmitted
     a18:	4b06      	ldr	r3, [pc, #24]	; (a34 <CDD_UserTxConfirmation_Can_0+0x40>)
     a1a:	781b      	ldrb	r3, [r3, #0]
     a1c:	2b04      	cmp	r3, #4
     a1e:	d105      	bne.n	a2c <CDD_UserTxConfirmation_Can_0+0x38>
            Transmit_count = 0;
     a20:	4b04      	ldr	r3, [pc, #16]	; (a34 <CDD_UserTxConfirmation_Can_0+0x40>)
     a22:	2200      	movs	r2, #0
     a24:	701a      	strb	r2, [r3, #0]
            CanIf_Can0_bTxFlag = TRUE;
     a26:	4b04      	ldr	r3, [pc, #16]	; (a38 <CDD_UserTxConfirmation_Can_0+0x44>)
     a28:	2201      	movs	r2, #1
     a2a:	701a      	strb	r2, [r3, #0]
        }

    }
}
     a2c:	bf00      	nop
     a2e:	b002      	add	sp, #8
     a30:	4770      	bx	lr
     a32:	bf00      	nop
     a34:	1fff98f4 	.word	0x1fff98f4
     a38:	1fff8b30 	.word	0x1fff8b30

00000a3c <CDD_UserRxIndication_Can_0>:
 * @brief Callback function for the reception of a PDU (registered) of interest for the Can0 controller.
 * 
 * @param RxPduId ID (container) of the PDU received.
 * @param PduInfoPtr Pointer to PDU received (message)
 */
void CDD_UserRxIndication_Can_0( PduIdType RxPduId, const PduInfoType* PduInfoPtr ) {
     a3c:	b086      	sub	sp, #24
     a3e:	4603      	mov	r3, r0
     a40:	9100      	str	r1, [sp, #0]
     a42:	f8ad 3006 	strh.w	r3, [sp, #6]
    //local data.
    static uint8 counters_RXPDU[4];
    uint8 Data[8];  //Data payload received.

    //Obtaining data received.
    for ( uint8 i = 0; i < PduInfoPtr->SduLength; i++ ) {
     a46:	2300      	movs	r3, #0
     a48:	f88d 3017 	strb.w	r3, [sp, #23]
     a4c:	e010      	b.n	a70 <CDD_UserRxIndication_Can_0+0x34>
        Data[i] = PduInfoPtr->SduDataPtr[i];
     a4e:	9b00      	ldr	r3, [sp, #0]
     a50:	681a      	ldr	r2, [r3, #0]
     a52:	f89d 3017 	ldrb.w	r3, [sp, #23]
     a56:	441a      	add	r2, r3
     a58:	f89d 3017 	ldrb.w	r3, [sp, #23]
     a5c:	7812      	ldrb	r2, [r2, #0]
     a5e:	a906      	add	r1, sp, #24
     a60:	440b      	add	r3, r1
     a62:	f803 2c0c 	strb.w	r2, [r3, #-12]
    for ( uint8 i = 0; i < PduInfoPtr->SduLength; i++ ) {
     a66:	f89d 3017 	ldrb.w	r3, [sp, #23]
     a6a:	3301      	adds	r3, #1
     a6c:	f88d 3017 	strb.w	r3, [sp, #23]
     a70:	f89d 2017 	ldrb.w	r2, [sp, #23]
     a74:	9b00      	ldr	r3, [sp, #0]
     a76:	689b      	ldr	r3, [r3, #8]
     a78:	429a      	cmp	r2, r3
     a7a:	d3e8      	bcc.n	a4e <CDD_UserRxIndication_Can_0+0x12>
    }

    //Verifying which message was received.
    switch ( RxPduId ) {
     a7c:	f8bd 3006 	ldrh.w	r3, [sp, #6]
     a80:	2b03      	cmp	r3, #3
     a82:	d827      	bhi.n	ad4 <CDD_UserRxIndication_Can_0+0x98>
     a84:	a201      	add	r2, pc, #4	; (adr r2, a8c <CDD_UserRxIndication_Can_0+0x50>)
     a86:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
     a8a:	bf00      	nop
     a8c:	00000a9d 	.word	0x00000a9d
     a90:	00000aab 	.word	0x00000aab
     a94:	00000ab9 	.word	0x00000ab9
     a98:	00000ac7 	.word	0x00000ac7
        case 0: //ID 0x200 received
            counters_RXPDU[0]++;
     a9c:	4b11      	ldr	r3, [pc, #68]	; (ae4 <CDD_UserRxIndication_Can_0+0xa8>)
     a9e:	781b      	ldrb	r3, [r3, #0]
     aa0:	3301      	adds	r3, #1
     aa2:	b2da      	uxtb	r2, r3
     aa4:	4b0f      	ldr	r3, [pc, #60]	; (ae4 <CDD_UserRxIndication_Can_0+0xa8>)
     aa6:	701a      	strb	r2, [r3, #0]
        break;
     aa8:	e015      	b.n	ad6 <CDD_UserRxIndication_Can_0+0x9a>
        case 1: //ID 0x201 received
            counters_RXPDU[1]++;
     aaa:	4b0e      	ldr	r3, [pc, #56]	; (ae4 <CDD_UserRxIndication_Can_0+0xa8>)
     aac:	785b      	ldrb	r3, [r3, #1]
     aae:	3301      	adds	r3, #1
     ab0:	b2da      	uxtb	r2, r3
     ab2:	4b0c      	ldr	r3, [pc, #48]	; (ae4 <CDD_UserRxIndication_Can_0+0xa8>)
     ab4:	705a      	strb	r2, [r3, #1]
        break;
     ab6:	e00e      	b.n	ad6 <CDD_UserRxIndication_Can_0+0x9a>
        case 2: //ID 0x202 received
            counters_RXPDU[2]++;
     ab8:	4b0a      	ldr	r3, [pc, #40]	; (ae4 <CDD_UserRxIndication_Can_0+0xa8>)
     aba:	789b      	ldrb	r3, [r3, #2]
     abc:	3301      	adds	r3, #1
     abe:	b2da      	uxtb	r2, r3
     ac0:	4b08      	ldr	r3, [pc, #32]	; (ae4 <CDD_UserRxIndication_Can_0+0xa8>)
     ac2:	709a      	strb	r2, [r3, #2]
        break;
     ac4:	e007      	b.n	ad6 <CDD_UserRxIndication_Can_0+0x9a>
        case 3: //ID 0x203 received
            counters_RXPDU[3]++;
     ac6:	4b07      	ldr	r3, [pc, #28]	; (ae4 <CDD_UserRxIndication_Can_0+0xa8>)
     ac8:	78db      	ldrb	r3, [r3, #3]
     aca:	3301      	adds	r3, #1
     acc:	b2da      	uxtb	r2, r3
     ace:	4b05      	ldr	r3, [pc, #20]	; (ae4 <CDD_UserRxIndication_Can_0+0xa8>)
     ad0:	70da      	strb	r2, [r3, #3]
        break;
     ad2:	e000      	b.n	ad6 <CDD_UserRxIndication_Can_0+0x9a>
        default:
        break;
     ad4:	bf00      	nop
    }
    
    CanIf_Can0_bRxFlag = TRUE;   //Message received.
     ad6:	4b04      	ldr	r3, [pc, #16]	; (ae8 <CDD_UserRxIndication_Can_0+0xac>)
     ad8:	2201      	movs	r2, #1
     ada:	701a      	strb	r2, [r3, #0]
}
     adc:	bf00      	nop
     ade:	b006      	add	sp, #24
     ae0:	4770      	bx	lr
     ae2:	bf00      	nop
     ae4:	1fff98f8 	.word	0x1fff98f8
     ae8:	1fff8b31 	.word	0x1fff8b31

00000aec <CDD_UserTxConfirmation_Can_2>:
 * @brief Callback function for the complete transmit of a PDU (registered) from Can2 controller.
 * 
 * @param TxPduId ID (container) of the PDU transmitted.
 * @param result Status of the transmision operation.
 */
void CDD_UserTxConfirmation_Can_2( PduIdType TxPduId, Std_ReturnType result ) {
     aec:	b082      	sub	sp, #8
     aee:	4603      	mov	r3, r0
     af0:	460a      	mov	r2, r1
     af2:	f8ad 3006 	strh.w	r3, [sp, #6]
     af6:	4613      	mov	r3, r2
     af8:	f88d 3005 	strb.w	r3, [sp, #5]
    //local data.
    static uint8 Transmit_count = 0;    //Count of transmitted PDUs.
    (void)TxPduId;

    if ( result == E_OK ) { //Message was transmitted successfully.
     afc:	f89d 3005 	ldrb.w	r3, [sp, #5]
     b00:	2b00      	cmp	r3, #0
     b02:	d108      	bne.n	b16 <CDD_UserTxConfirmation_Can_2+0x2a>
        Transmit_count++;
     b04:	4b05      	ldr	r3, [pc, #20]	; (b1c <CDD_UserTxConfirmation_Can_2+0x30>)
     b06:	781b      	ldrb	r3, [r3, #0]
     b08:	3301      	adds	r3, #1
     b0a:	b2da      	uxtb	r2, r3
     b0c:	4b03      	ldr	r3, [pc, #12]	; (b1c <CDD_UserTxConfirmation_Can_2+0x30>)
     b0e:	701a      	strb	r2, [r3, #0]
        CanIf_Can2_bTxFlag = TRUE;
     b10:	4b03      	ldr	r3, [pc, #12]	; (b20 <CDD_UserTxConfirmation_Can_2+0x34>)
     b12:	2201      	movs	r2, #1
     b14:	701a      	strb	r2, [r3, #0]
    }
}
     b16:	bf00      	nop
     b18:	b002      	add	sp, #8
     b1a:	4770      	bx	lr
     b1c:	1fff98fc 	.word	0x1fff98fc
     b20:	1fff8b32 	.word	0x1fff8b32

00000b24 <CDD_UserRxIndication_Can_2>:
 * @brief Callback function for the reception of a PDU (registered) of interest for the Can2 controller.
 * 
 * @param RxPduId ID (container) of the PDU received.
 * @param PduInfoPtr Pointer to PDU received (message)
 */
void CDD_UserRxIndication_Can_2( PduIdType RxPduId, const PduInfoType* PduInfoPtr ) {
     b24:	b086      	sub	sp, #24
     b26:	4603      	mov	r3, r0
     b28:	9100      	str	r1, [sp, #0]
     b2a:	f8ad 3006 	strh.w	r3, [sp, #6]
    //local data.
    static uint8 counter_RXPDU4 = 0;   //Message rx 1 counter.
    uint8 Data[8];  //Data payload received.

    //Obtaining data received.
    for ( uint8 i = 0; i < PduInfoPtr->SduLength; i++ ) {
     b2e:	2300      	movs	r3, #0
     b30:	f88d 3017 	strb.w	r3, [sp, #23]
     b34:	e010      	b.n	b58 <CDD_UserRxIndication_Can_2+0x34>
        Data[i] = PduInfoPtr->SduDataPtr[i];
     b36:	9b00      	ldr	r3, [sp, #0]
     b38:	681a      	ldr	r2, [r3, #0]
     b3a:	f89d 3017 	ldrb.w	r3, [sp, #23]
     b3e:	441a      	add	r2, r3
     b40:	f89d 3017 	ldrb.w	r3, [sp, #23]
     b44:	7812      	ldrb	r2, [r2, #0]
     b46:	a906      	add	r1, sp, #24
     b48:	440b      	add	r3, r1
     b4a:	f803 2c0c 	strb.w	r2, [r3, #-12]
    for ( uint8 i = 0; i < PduInfoPtr->SduLength; i++ ) {
     b4e:	f89d 3017 	ldrb.w	r3, [sp, #23]
     b52:	3301      	adds	r3, #1
     b54:	f88d 3017 	strb.w	r3, [sp, #23]
     b58:	f89d 2017 	ldrb.w	r2, [sp, #23]
     b5c:	9b00      	ldr	r3, [sp, #0]
     b5e:	689b      	ldr	r3, [r3, #8]
     b60:	429a      	cmp	r2, r3
     b62:	d3e8      	bcc.n	b36 <CDD_UserRxIndication_Can_2+0x12>
    }

    //Verifying which message was received.
    switch ( RxPduId ) {
     b64:	f8bd 3006 	ldrh.w	r3, [sp, #6]
     b68:	2b04      	cmp	r3, #4
     b6a:	d106      	bne.n	b7a <CDD_UserRxIndication_Can_2+0x56>
        case 4: //ID 0x400 received
            counter_RXPDU4++;
     b6c:	4b06      	ldr	r3, [pc, #24]	; (b88 <CDD_UserRxIndication_Can_2+0x64>)
     b6e:	781b      	ldrb	r3, [r3, #0]
     b70:	3301      	adds	r3, #1
     b72:	b2da      	uxtb	r2, r3
     b74:	4b04      	ldr	r3, [pc, #16]	; (b88 <CDD_UserRxIndication_Can_2+0x64>)
     b76:	701a      	strb	r2, [r3, #0]
        break;
     b78:	e000      	b.n	b7c <CDD_UserRxIndication_Can_2+0x58>
        default:
        break;
     b7a:	bf00      	nop
    }
    
    CanIf_Can2_bRxFlag = TRUE;   //Message received.
     b7c:	4b03      	ldr	r3, [pc, #12]	; (b8c <CDD_UserRxIndication_Can_2+0x68>)
     b7e:	2201      	movs	r2, #1
     b80:	701a      	strb	r2, [r3, #0]
}
     b82:	bf00      	nop
     b84:	b006      	add	sp, #24
     b86:	4770      	bx	lr
     b88:	1fff98fd 	.word	0x1fff98fd
     b8c:	1fff8b33 	.word	0x1fff8b33

00000b90 <init_data_bss>:
 * Implements    : init_data_bss_Activity
 *END**************************************************************************/
void init_data_bss(void);

void init_data_bss(void)
{
     b90:	b08a      	sub	sp, #40	; 0x28
    const Sys_CopyLayoutType * copy_layout;
    const Sys_ZeroLayoutType * zero_layout;
    const uint8 * rom;
    uint8 * ram;
    uint32 len = 0U;
     b92:	2300      	movs	r3, #0
     b94:	9307      	str	r3, [sp, #28]
    uint32 size = 0U;
     b96:	2300      	movs	r3, #0
     b98:	9306      	str	r3, [sp, #24]
    uint32 i = 0U;
     b9a:	2300      	movs	r3, #0
     b9c:	9309      	str	r3, [sp, #36]	; 0x24
    uint32 j = 0U;
     b9e:	2300      	movs	r3, #0
     ba0:	9308      	str	r3, [sp, #32]

    const uint32 * initTable_Ptr = (uint32 *)__INIT_TABLE;
     ba2:	4b44      	ldr	r3, [pc, #272]	; (cb4 <init_data_bss+0x124>)
     ba4:	9305      	str	r3, [sp, #20]
    const uint32 * zeroTable_Ptr = (uint32*)__ZERO_TABLE;
     ba6:	4b44      	ldr	r3, [pc, #272]	; (cb8 <init_data_bss+0x128>)
     ba8:	9304      	str	r3, [sp, #16]

    /* Copy initialized table */
    len = *initTable_Ptr;
     baa:	9b05      	ldr	r3, [sp, #20]
     bac:	681b      	ldr	r3, [r3, #0]
     bae:	9307      	str	r3, [sp, #28]
    initTable_Ptr++;
     bb0:	9b05      	ldr	r3, [sp, #20]
     bb2:	3304      	adds	r3, #4
     bb4:	9305      	str	r3, [sp, #20]
    copy_layout = (const Sys_CopyLayoutType *)initTable_Ptr;
     bb6:	9b05      	ldr	r3, [sp, #20]
     bb8:	9303      	str	r3, [sp, #12]
    for(i = 0; i < len; i++)
     bba:	2300      	movs	r3, #0
     bbc:	9309      	str	r3, [sp, #36]	; 0x24
     bbe:	e03d      	b.n	c3c <init_data_bss+0xac>
    {
        rom = copy_layout[i].rom_start;
     bc0:	9a09      	ldr	r2, [sp, #36]	; 0x24
     bc2:	4613      	mov	r3, r2
     bc4:	005b      	lsls	r3, r3, #1
     bc6:	4413      	add	r3, r2
     bc8:	009b      	lsls	r3, r3, #2
     bca:	461a      	mov	r2, r3
     bcc:	9b03      	ldr	r3, [sp, #12]
     bce:	4413      	add	r3, r2
     bd0:	685b      	ldr	r3, [r3, #4]
     bd2:	9300      	str	r3, [sp, #0]
        ram = copy_layout[i].ram_start;
     bd4:	9a09      	ldr	r2, [sp, #36]	; 0x24
     bd6:	4613      	mov	r3, r2
     bd8:	005b      	lsls	r3, r3, #1
     bda:	4413      	add	r3, r2
     bdc:	009b      	lsls	r3, r3, #2
     bde:	461a      	mov	r2, r3
     be0:	9b03      	ldr	r3, [sp, #12]
     be2:	4413      	add	r3, r2
     be4:	681b      	ldr	r3, [r3, #0]
     be6:	9301      	str	r3, [sp, #4]
        size = (uint32)copy_layout[i].rom_end - (uint32)copy_layout[i].rom_start;
     be8:	9a09      	ldr	r2, [sp, #36]	; 0x24
     bea:	4613      	mov	r3, r2
     bec:	005b      	lsls	r3, r3, #1
     bee:	4413      	add	r3, r2
     bf0:	009b      	lsls	r3, r3, #2
     bf2:	461a      	mov	r2, r3
     bf4:	9b03      	ldr	r3, [sp, #12]
     bf6:	4413      	add	r3, r2
     bf8:	689b      	ldr	r3, [r3, #8]
     bfa:	4619      	mov	r1, r3
     bfc:	9a09      	ldr	r2, [sp, #36]	; 0x24
     bfe:	4613      	mov	r3, r2
     c00:	005b      	lsls	r3, r3, #1
     c02:	4413      	add	r3, r2
     c04:	009b      	lsls	r3, r3, #2
     c06:	461a      	mov	r2, r3
     c08:	9b03      	ldr	r3, [sp, #12]
     c0a:	4413      	add	r3, r2
     c0c:	685b      	ldr	r3, [r3, #4]
     c0e:	1acb      	subs	r3, r1, r3
     c10:	9306      	str	r3, [sp, #24]

        for(j = 0UL; j < size; j++)
     c12:	2300      	movs	r3, #0
     c14:	9308      	str	r3, [sp, #32]
     c16:	e00a      	b.n	c2e <init_data_bss+0x9e>
        {
            ram[j] = rom[j];
     c18:	9a00      	ldr	r2, [sp, #0]
     c1a:	9b08      	ldr	r3, [sp, #32]
     c1c:	441a      	add	r2, r3
     c1e:	9901      	ldr	r1, [sp, #4]
     c20:	9b08      	ldr	r3, [sp, #32]
     c22:	440b      	add	r3, r1
     c24:	7812      	ldrb	r2, [r2, #0]
     c26:	701a      	strb	r2, [r3, #0]
        for(j = 0UL; j < size; j++)
     c28:	9b08      	ldr	r3, [sp, #32]
     c2a:	3301      	adds	r3, #1
     c2c:	9308      	str	r3, [sp, #32]
     c2e:	9a08      	ldr	r2, [sp, #32]
     c30:	9b06      	ldr	r3, [sp, #24]
     c32:	429a      	cmp	r2, r3
     c34:	d3f0      	bcc.n	c18 <init_data_bss+0x88>
    for(i = 0; i < len; i++)
     c36:	9b09      	ldr	r3, [sp, #36]	; 0x24
     c38:	3301      	adds	r3, #1
     c3a:	9309      	str	r3, [sp, #36]	; 0x24
     c3c:	9a09      	ldr	r2, [sp, #36]	; 0x24
     c3e:	9b07      	ldr	r3, [sp, #28]
     c40:	429a      	cmp	r2, r3
     c42:	d3bd      	bcc.n	bc0 <init_data_bss+0x30>
        }
    }
    
    /* Clear zero table */
    len = *zeroTable_Ptr;
     c44:	9b04      	ldr	r3, [sp, #16]
     c46:	681b      	ldr	r3, [r3, #0]
     c48:	9307      	str	r3, [sp, #28]
    zeroTable_Ptr++;
     c4a:	9b04      	ldr	r3, [sp, #16]
     c4c:	3304      	adds	r3, #4
     c4e:	9304      	str	r3, [sp, #16]
    zero_layout = (const Sys_ZeroLayoutType *)zeroTable_Ptr;
     c50:	9b04      	ldr	r3, [sp, #16]
     c52:	9302      	str	r3, [sp, #8]
    for(i = 0; i < len; i++)
     c54:	2300      	movs	r3, #0
     c56:	9309      	str	r3, [sp, #36]	; 0x24
     c58:	e024      	b.n	ca4 <init_data_bss+0x114>
    {
        ram = zero_layout[i].ram_start;
     c5a:	9b09      	ldr	r3, [sp, #36]	; 0x24
     c5c:	00db      	lsls	r3, r3, #3
     c5e:	9a02      	ldr	r2, [sp, #8]
     c60:	4413      	add	r3, r2
     c62:	681b      	ldr	r3, [r3, #0]
     c64:	9301      	str	r3, [sp, #4]
        size = (uint32)zero_layout[i].ram_end - (uint32)zero_layout[i].ram_start;
     c66:	9b09      	ldr	r3, [sp, #36]	; 0x24
     c68:	00db      	lsls	r3, r3, #3
     c6a:	9a02      	ldr	r2, [sp, #8]
     c6c:	4413      	add	r3, r2
     c6e:	685b      	ldr	r3, [r3, #4]
     c70:	4619      	mov	r1, r3
     c72:	9b09      	ldr	r3, [sp, #36]	; 0x24
     c74:	00db      	lsls	r3, r3, #3
     c76:	9a02      	ldr	r2, [sp, #8]
     c78:	4413      	add	r3, r2
     c7a:	681b      	ldr	r3, [r3, #0]
     c7c:	1acb      	subs	r3, r1, r3
     c7e:	9306      	str	r3, [sp, #24]

        for(j = 0UL; j < size; j++)
     c80:	2300      	movs	r3, #0
     c82:	9308      	str	r3, [sp, #32]
     c84:	e007      	b.n	c96 <init_data_bss+0x106>
        {
            ram[j] = 0U;
     c86:	9a01      	ldr	r2, [sp, #4]
     c88:	9b08      	ldr	r3, [sp, #32]
     c8a:	4413      	add	r3, r2
     c8c:	2200      	movs	r2, #0
     c8e:	701a      	strb	r2, [r3, #0]
        for(j = 0UL; j < size; j++)
     c90:	9b08      	ldr	r3, [sp, #32]
     c92:	3301      	adds	r3, #1
     c94:	9308      	str	r3, [sp, #32]
     c96:	9a08      	ldr	r2, [sp, #32]
     c98:	9b06      	ldr	r3, [sp, #24]
     c9a:	429a      	cmp	r2, r3
     c9c:	d3f3      	bcc.n	c86 <init_data_bss+0xf6>
    for(i = 0; i < len; i++)
     c9e:	9b09      	ldr	r3, [sp, #36]	; 0x24
     ca0:	3301      	adds	r3, #1
     ca2:	9309      	str	r3, [sp, #36]	; 0x24
     ca4:	9a09      	ldr	r2, [sp, #36]	; 0x24
     ca6:	9b07      	ldr	r3, [sp, #28]
     ca8:	429a      	cmp	r2, r3
     caa:	d3d6      	bcc.n	c5a <init_data_bss+0xca>
        }
    }
}
     cac:	bf00      	nop
     cae:	bf00      	nop
     cb0:	b00a      	add	sp, #40	; 0x28
     cb2:	4770      	bx	lr
     cb4:	00019bec 	.word	0x00019bec
     cb8:	00019c08 	.word	0x00019c08

00000cbc <sys_m4_cache_init>:
{
     cbc:	b084      	sub	sp, #16
     cbe:	4603      	mov	r3, r0
     cc0:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 RetValue = CACHE_OK;
     cc4:	2300      	movs	r3, #0
     cc6:	f88d 300f 	strb.w	r3, [sp, #15]
  if (cache == CODE_CACHE)
     cca:	f89d 3007 	ldrb.w	r3, [sp, #7]
     cce:	2b00      	cmp	r3, #0
     cd0:	d118      	bne.n	d04 <sys_m4_cache_init+0x48>
      IP_LMEM->PCCCR = 0x05000000UL;
     cd2:	4b10      	ldr	r3, [pc, #64]	; (d14 <sys_m4_cache_init+0x58>)
     cd4:	f04f 62a0 	mov.w	r2, #83886080	; 0x5000000
     cd8:	601a      	str	r2, [r3, #0]
      IP_LMEM->PCCCR |= LMEM_PCCCR_GO(1);
     cda:	4b0e      	ldr	r3, [pc, #56]	; (d14 <sys_m4_cache_init+0x58>)
     cdc:	681b      	ldr	r3, [r3, #0]
     cde:	4a0d      	ldr	r2, [pc, #52]	; (d14 <sys_m4_cache_init+0x58>)
     ce0:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
     ce4:	6013      	str	r3, [r2, #0]
      while((IP_LMEM->PCCCR & LMEM_PCCCR_GO_MASK) == LMEM_PCCCR_GO_MASK){};
     ce6:	bf00      	nop
     ce8:	4b0a      	ldr	r3, [pc, #40]	; (d14 <sys_m4_cache_init+0x58>)
     cea:	681b      	ldr	r3, [r3, #0]
     cec:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
     cf0:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
     cf4:	d0f8      	beq.n	ce8 <sys_m4_cache_init+0x2c>
      IP_LMEM->PCCCR |= LMEM_PCCCR_ENCACHE(1);
     cf6:	4b07      	ldr	r3, [pc, #28]	; (d14 <sys_m4_cache_init+0x58>)
     cf8:	681b      	ldr	r3, [r3, #0]
     cfa:	4a06      	ldr	r2, [pc, #24]	; (d14 <sys_m4_cache_init+0x58>)
     cfc:	f043 0301 	orr.w	r3, r3, #1
     d00:	6013      	str	r3, [r2, #0]
     d02:	e002      	b.n	d0a <sys_m4_cache_init+0x4e>
     RetValue = CACHE_INVALID_PARAM;
     d04:	2301      	movs	r3, #1
     d06:	f88d 300f 	strb.w	r3, [sp, #15]
  return RetValue;
     d0a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
     d0e:	4618      	mov	r0, r3
     d10:	b004      	add	sp, #16
     d12:	4770      	bx	lr
     d14:	e0082000 	.word	0xe0082000

00000d18 <startup_go_to_user_mode>:
}
     d18:	bf00      	nop
     d1a:	4770      	bx	lr

00000d1c <Sys_GetCoreID>:
    return 0U;
     d1c:	2300      	movs	r3, #0
}
     d1e:	4618      	mov	r0, r3
     d20:	4770      	bx	lr

00000d22 <HardFault_Handler>:
}
void HardFault_Handler(void)
{
    while(TRUE){};
     d22:	e7fe      	b.n	d22 <HardFault_Handler>

00000d24 <MemManage_Handler>:
}
void MemManage_Handler(void)
{
    while(TRUE){};
     d24:	e7fe      	b.n	d24 <MemManage_Handler>

00000d26 <BusFault_Handler>:
}
void BusFault_Handler(void)
{
    while(TRUE){};
     d26:	e7fe      	b.n	d26 <BusFault_Handler>

00000d28 <UsageFault_Handler>:
}
void UsageFault_Handler(void)
{
    while(TRUE){};
     d28:	e7fe      	b.n	d28 <UsageFault_Handler>

00000d2a <SVC_Handler>:

#ifndef MCAL_ENABLE_USER_MODE_SUPPORT
void SVC_Handler(void)  __attribute__ ((weak));               /* SVCall Handler */
void SVC_Handler(void)
{
    while(TRUE){};
     d2a:	e7fe      	b.n	d2a <SVC_Handler>

00000d2c <DebugMon_Handler>:
    ASM_KEYWORD("pop {r0}");
}
#endif
void DebugMon_Handler(void)
{
    while(TRUE){};
     d2c:	e7fe      	b.n	d2c <DebugMon_Handler>

00000d2e <PendSV_Handler>:
}
void PendSV_Handler(void)
{
    while(TRUE){};
     d2e:	e7fe      	b.n	d2e <PendSV_Handler>

00000d30 <SysTick_Handler>:
}
void SysTick_Handler(void)
{
    while(TRUE){};
     d30:	e7fe      	b.n	d30 <SysTick_Handler>

00000d32 <undefined_handler>:
}
void undefined_handler(void)
{
   while(TRUE){};
     d32:	e7fe      	b.n	d32 <undefined_handler>

00000d34 <_DoInit>:
      if (pRTTCBInit->acID[0] != 'S') {                                                      \
        _DoInit();                                                                           \
      }                                                                                      \
    } while (0)

static void _DoInit(void) {
     d34:	b500      	push	{lr}
     d36:	b083      	sub	sp, #12
  static const char _aInitStr[] = "\0\0\0\0\0\0TTR REGGES";  // Init complete ID string to make sure that things also work if RTT is linked to a no-init memory area
  unsigned i;
  //
  // Initialize control block
  //
  p                     = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access control block uncached so that nothing in the cache ever becomes dirty and all changes are visible in HW directly
     d38:	4b26      	ldr	r3, [pc, #152]	; (dd4 <_DoInit+0xa0>)
     d3a:	9300      	str	r3, [sp, #0]
  memset((SEGGER_RTT_CB*)p, 0, sizeof(_SEGGER_RTT));         // Make sure that the RTT CB is always zero initialized.
     d3c:	22a8      	movs	r2, #168	; 0xa8
     d3e:	2100      	movs	r1, #0
     d40:	9800      	ldr	r0, [sp, #0]
     d42:	f000 fd67 	bl	1814 <memset>
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
     d46:	9b00      	ldr	r3, [sp, #0]
     d48:	2203      	movs	r2, #3
     d4a:	611a      	str	r2, [r3, #16]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
     d4c:	9b00      	ldr	r3, [sp, #0]
     d4e:	2203      	movs	r2, #3
     d50:	615a      	str	r2, [r3, #20]
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
     d52:	9b00      	ldr	r3, [sp, #0]
     d54:	4a20      	ldr	r2, [pc, #128]	; (dd8 <_DoInit+0xa4>)
     d56:	619a      	str	r2, [r3, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
     d58:	9b00      	ldr	r3, [sp, #0]
     d5a:	4a20      	ldr	r2, [pc, #128]	; (ddc <_DoInit+0xa8>)
     d5c:	61da      	str	r2, [r3, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
     d5e:	9b00      	ldr	r3, [sp, #0]
     d60:	f44f 6280 	mov.w	r2, #1024	; 0x400
     d64:	621a      	str	r2, [r3, #32]
  p->aUp[0].RdOff         = 0u;
     d66:	9b00      	ldr	r3, [sp, #0]
     d68:	2200      	movs	r2, #0
     d6a:	629a      	str	r2, [r3, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
     d6c:	9b00      	ldr	r3, [sp, #0]
     d6e:	2200      	movs	r2, #0
     d70:	625a      	str	r2, [r3, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
     d72:	9b00      	ldr	r3, [sp, #0]
     d74:	2200      	movs	r2, #0
     d76:	62da      	str	r2, [r3, #44]	; 0x2c
  //
  // Initialize down buffer 0
  //
  p->aDown[0].sName         = "Terminal";
     d78:	9b00      	ldr	r3, [sp, #0]
     d7a:	4a17      	ldr	r2, [pc, #92]	; (dd8 <_DoInit+0xa4>)
     d7c:	661a      	str	r2, [r3, #96]	; 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
     d7e:	9b00      	ldr	r3, [sp, #0]
     d80:	4a17      	ldr	r2, [pc, #92]	; (de0 <_DoInit+0xac>)
     d82:	665a      	str	r2, [r3, #100]	; 0x64
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
     d84:	9b00      	ldr	r3, [sp, #0]
     d86:	2210      	movs	r2, #16
     d88:	669a      	str	r2, [r3, #104]	; 0x68
  p->aDown[0].RdOff         = 0u;
     d8a:	9b00      	ldr	r3, [sp, #0]
     d8c:	2200      	movs	r2, #0
     d8e:	671a      	str	r2, [r3, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
     d90:	9b00      	ldr	r3, [sp, #0]
     d92:	2200      	movs	r2, #0
     d94:	66da      	str	r2, [r3, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
     d96:	9b00      	ldr	r3, [sp, #0]
     d98:	2200      	movs	r2, #0
     d9a:	675a      	str	r2, [r3, #116]	; 0x74
  //
  // Finish initialization of the control block.
  // Copy Id string backwards to make sure that "SEGGER RTT" is not found in initializer memory (usually flash),
  // as this would cause J-Link to "find" the control block at a wrong address.
  //
  RTT__DMB();                       // Force order of memory accesses for cores that may perform out-of-order memory accesses
     d9c:	f3bf 8f5f 	dmb	sy
  for (i = 0; i < sizeof(_aInitStr) - 1; ++i) {
     da0:	2300      	movs	r3, #0
     da2:	9301      	str	r3, [sp, #4]
     da4:	e00c      	b.n	dc0 <_DoInit+0x8c>
    p->acID[i] = _aInitStr[sizeof(_aInitStr) - 2 - i];  // Skip terminating \0 at the end of the array
     da6:	9b01      	ldr	r3, [sp, #4]
     da8:	f1c3 030f 	rsb	r3, r3, #15
     dac:	4a0d      	ldr	r2, [pc, #52]	; (de4 <_DoInit+0xb0>)
     dae:	5cd1      	ldrb	r1, [r2, r3]
     db0:	9a00      	ldr	r2, [sp, #0]
     db2:	9b01      	ldr	r3, [sp, #4]
     db4:	4413      	add	r3, r2
     db6:	460a      	mov	r2, r1
     db8:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < sizeof(_aInitStr) - 1; ++i) {
     dba:	9b01      	ldr	r3, [sp, #4]
     dbc:	3301      	adds	r3, #1
     dbe:	9301      	str	r3, [sp, #4]
     dc0:	9b01      	ldr	r3, [sp, #4]
     dc2:	2b0f      	cmp	r3, #15
     dc4:	d9ef      	bls.n	da6 <_DoInit+0x72>
  }
  RTT__DMB();                       // Force order of memory accesses for cores that may perform out-of-order memory accesses
     dc6:	f3bf 8f5f 	dmb	sy
}
     dca:	bf00      	nop
     dcc:	b003      	add	sp, #12
     dce:	f85d fb04 	ldr.w	pc, [sp], #4
     dd2:	bf00      	nop
     dd4:	1fff991c 	.word	0x1fff991c
     dd8:	00017ef8 	.word	0x00017ef8
     ddc:	1fff99c4 	.word	0x1fff99c4
     de0:	1fff9dc4 	.word	0x1fff9dc4
     de4:	00019bc8 	.word	0x00019bc8

00000de8 <_WriteBlocking>:
*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
*
*  Return value
*    >= 0 - Number of bytes written into buffer.
*/
static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
     de8:	b500      	push	{lr}
     dea:	b08b      	sub	sp, #44	; 0x2c
     dec:	9003      	str	r0, [sp, #12]
     dee:	9102      	str	r1, [sp, #8]
     df0:	9201      	str	r2, [sp, #4]
  unsigned WrOff;
  volatile char* pDst;
  //
  // Write data to buffer and handle wrap-around if necessary
  //
  NumBytesWritten = 0u;
     df2:	2300      	movs	r3, #0
     df4:	9308      	str	r3, [sp, #32]
  WrOff = pRing->WrOff;
     df6:	9b03      	ldr	r3, [sp, #12]
     df8:	68db      	ldr	r3, [r3, #12]
     dfa:	9307      	str	r3, [sp, #28]
  do {
    RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
     dfc:	9b03      	ldr	r3, [sp, #12]
     dfe:	691b      	ldr	r3, [r3, #16]
     e00:	9306      	str	r3, [sp, #24]
    if (RdOff > WrOff) {
     e02:	9a06      	ldr	r2, [sp, #24]
     e04:	9b07      	ldr	r3, [sp, #28]
     e06:	429a      	cmp	r2, r3
     e08:	d905      	bls.n	e16 <_WriteBlocking+0x2e>
      NumBytesToWrite = RdOff - WrOff - 1u;
     e0a:	9a06      	ldr	r2, [sp, #24]
     e0c:	9b07      	ldr	r3, [sp, #28]
     e0e:	1ad3      	subs	r3, r2, r3
     e10:	3b01      	subs	r3, #1
     e12:	9309      	str	r3, [sp, #36]	; 0x24
     e14:	e007      	b.n	e26 <_WriteBlocking+0x3e>
    } else {
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
     e16:	9b03      	ldr	r3, [sp, #12]
     e18:	689a      	ldr	r2, [r3, #8]
     e1a:	9906      	ldr	r1, [sp, #24]
     e1c:	9b07      	ldr	r3, [sp, #28]
     e1e:	1acb      	subs	r3, r1, r3
     e20:	4413      	add	r3, r2
     e22:	3b01      	subs	r3, #1
     e24:	9309      	str	r3, [sp, #36]	; 0x24
    }
    NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
     e26:	9b03      	ldr	r3, [sp, #12]
     e28:	689a      	ldr	r2, [r3, #8]
     e2a:	9b07      	ldr	r3, [sp, #28]
     e2c:	1ad3      	subs	r3, r2, r3
     e2e:	9a09      	ldr	r2, [sp, #36]	; 0x24
     e30:	4293      	cmp	r3, r2
     e32:	bf28      	it	cs
     e34:	4613      	movcs	r3, r2
     e36:	9309      	str	r3, [sp, #36]	; 0x24
    NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
     e38:	9a09      	ldr	r2, [sp, #36]	; 0x24
     e3a:	9b01      	ldr	r3, [sp, #4]
     e3c:	4293      	cmp	r3, r2
     e3e:	bf28      	it	cs
     e40:	4613      	movcs	r3, r2
     e42:	9309      	str	r3, [sp, #36]	; 0x24
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
     e44:	9b03      	ldr	r3, [sp, #12]
     e46:	685a      	ldr	r2, [r3, #4]
     e48:	9b07      	ldr	r3, [sp, #28]
     e4a:	4413      	add	r3, r2
     e4c:	9305      	str	r3, [sp, #20]
    WrOff           += NumBytesToWrite;
    while (NumBytesToWrite--) {
      *pDst++ = *pBuffer++;
    };
#else
    SEGGER_RTT_MEMCPY((void*)pDst, pBuffer, NumBytesToWrite);
     e4e:	9a09      	ldr	r2, [sp, #36]	; 0x24
     e50:	9902      	ldr	r1, [sp, #8]
     e52:	9805      	ldr	r0, [sp, #20]
     e54:	f000 fcd0 	bl	17f8 <memcpy>
    NumBytesWritten += NumBytesToWrite;
     e58:	9a08      	ldr	r2, [sp, #32]
     e5a:	9b09      	ldr	r3, [sp, #36]	; 0x24
     e5c:	4413      	add	r3, r2
     e5e:	9308      	str	r3, [sp, #32]
    pBuffer         += NumBytesToWrite;
     e60:	9a02      	ldr	r2, [sp, #8]
     e62:	9b09      	ldr	r3, [sp, #36]	; 0x24
     e64:	4413      	add	r3, r2
     e66:	9302      	str	r3, [sp, #8]
    NumBytes        -= NumBytesToWrite;
     e68:	9a01      	ldr	r2, [sp, #4]
     e6a:	9b09      	ldr	r3, [sp, #36]	; 0x24
     e6c:	1ad3      	subs	r3, r2, r3
     e6e:	9301      	str	r3, [sp, #4]
    WrOff           += NumBytesToWrite;
     e70:	9a07      	ldr	r2, [sp, #28]
     e72:	9b09      	ldr	r3, [sp, #36]	; 0x24
     e74:	4413      	add	r3, r2
     e76:	9307      	str	r3, [sp, #28]
#endif
    if (WrOff == pRing->SizeOfBuffer) {
     e78:	9b03      	ldr	r3, [sp, #12]
     e7a:	689b      	ldr	r3, [r3, #8]
     e7c:	9a07      	ldr	r2, [sp, #28]
     e7e:	429a      	cmp	r2, r3
     e80:	d101      	bne.n	e86 <_WriteBlocking+0x9e>
      WrOff = 0u;
     e82:	2300      	movs	r3, #0
     e84:	9307      	str	r3, [sp, #28]
    }
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
     e86:	f3bf 8f5f 	dmb	sy
    pRing->WrOff = WrOff;
     e8a:	9b03      	ldr	r3, [sp, #12]
     e8c:	9a07      	ldr	r2, [sp, #28]
     e8e:	60da      	str	r2, [r3, #12]
  } while (NumBytes);
     e90:	9b01      	ldr	r3, [sp, #4]
     e92:	2b00      	cmp	r3, #0
     e94:	d1b2      	bne.n	dfc <_WriteBlocking+0x14>
  return NumBytesWritten;
     e96:	9b08      	ldr	r3, [sp, #32]
}
     e98:	4618      	mov	r0, r3
     e9a:	b00b      	add	sp, #44	; 0x2c
     e9c:	f85d fb04 	ldr.w	pc, [sp], #4

00000ea0 <_WriteNoCheck>:
*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
*
*  Notes
*    (1) If there might not be enough space in the "Up"-buffer, call _WriteBlocking
*/
static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
     ea0:	b500      	push	{lr}
     ea2:	b089      	sub	sp, #36	; 0x24
     ea4:	9003      	str	r0, [sp, #12]
     ea6:	9102      	str	r1, [sp, #8]
     ea8:	9201      	str	r2, [sp, #4]
  unsigned NumBytesAtOnce;
  unsigned WrOff;
  unsigned Rem;
  volatile char* pDst;

  WrOff = pRing->WrOff;
     eaa:	9b03      	ldr	r3, [sp, #12]
     eac:	68db      	ldr	r3, [r3, #12]
     eae:	9307      	str	r3, [sp, #28]
  Rem = pRing->SizeOfBuffer - WrOff;
     eb0:	9b03      	ldr	r3, [sp, #12]
     eb2:	689a      	ldr	r2, [r3, #8]
     eb4:	9b07      	ldr	r3, [sp, #28]
     eb6:	1ad3      	subs	r3, r2, r3
     eb8:	9306      	str	r3, [sp, #24]
  if (Rem > NumBytes) {
     eba:	9a06      	ldr	r2, [sp, #24]
     ebc:	9b01      	ldr	r3, [sp, #4]
     ebe:	429a      	cmp	r2, r3
     ec0:	d911      	bls.n	ee6 <_WriteNoCheck+0x46>
    //
    // All data fits before wrap around
    //
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
     ec2:	9b03      	ldr	r3, [sp, #12]
     ec4:	685a      	ldr	r2, [r3, #4]
     ec6:	9b07      	ldr	r3, [sp, #28]
     ec8:	4413      	add	r3, r2
     eca:	9304      	str	r3, [sp, #16]
      *pDst++ = *pData++;
    };
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    pRing->WrOff = WrOff;
#else
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytes);
     ecc:	9a01      	ldr	r2, [sp, #4]
     ece:	9902      	ldr	r1, [sp, #8]
     ed0:	9804      	ldr	r0, [sp, #16]
     ed2:	f000 fc91 	bl	17f8 <memcpy>
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
     ed6:	f3bf 8f5f 	dmb	sy
    pRing->WrOff = WrOff + NumBytes;
     eda:	9a07      	ldr	r2, [sp, #28]
     edc:	9b01      	ldr	r3, [sp, #4]
     ede:	441a      	add	r2, r3
     ee0:	9b03      	ldr	r3, [sp, #12]
     ee2:	60da      	str	r2, [r3, #12]
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    pRing->WrOff = NumBytesAtOnce;
#endif
  }
}
     ee4:	e01f      	b.n	f26 <_WriteNoCheck+0x86>
    NumBytesAtOnce = Rem;
     ee6:	9b06      	ldr	r3, [sp, #24]
     ee8:	9305      	str	r3, [sp, #20]
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
     eea:	9b03      	ldr	r3, [sp, #12]
     eec:	685a      	ldr	r2, [r3, #4]
     eee:	9b07      	ldr	r3, [sp, #28]
     ef0:	4413      	add	r3, r2
     ef2:	9304      	str	r3, [sp, #16]
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytesAtOnce);
     ef4:	9a05      	ldr	r2, [sp, #20]
     ef6:	9902      	ldr	r1, [sp, #8]
     ef8:	9804      	ldr	r0, [sp, #16]
     efa:	f000 fc7d 	bl	17f8 <memcpy>
    NumBytesAtOnce = NumBytes - Rem;
     efe:	9a01      	ldr	r2, [sp, #4]
     f00:	9b06      	ldr	r3, [sp, #24]
     f02:	1ad3      	subs	r3, r2, r3
     f04:	9305      	str	r3, [sp, #20]
    pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
     f06:	9b03      	ldr	r3, [sp, #12]
     f08:	685b      	ldr	r3, [r3, #4]
     f0a:	9304      	str	r3, [sp, #16]
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
     f0c:	9a02      	ldr	r2, [sp, #8]
     f0e:	9b06      	ldr	r3, [sp, #24]
     f10:	4413      	add	r3, r2
     f12:	9a05      	ldr	r2, [sp, #20]
     f14:	4619      	mov	r1, r3
     f16:	9804      	ldr	r0, [sp, #16]
     f18:	f000 fc6e 	bl	17f8 <memcpy>
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
     f1c:	f3bf 8f5f 	dmb	sy
    pRing->WrOff = NumBytesAtOnce;
     f20:	9b03      	ldr	r3, [sp, #12]
     f22:	9a05      	ldr	r2, [sp, #20]
     f24:	60da      	str	r2, [r3, #12]
}
     f26:	bf00      	nop
     f28:	b009      	add	sp, #36	; 0x24
     f2a:	f85d fb04 	ldr.w	pc, [sp], #4

00000f2e <_GetAvailWriteSpace>:
*    pRing        Ring buffer to check.
*
*  Return value
*    Number of bytes that are free in the buffer.
*/
static unsigned _GetAvailWriteSpace(SEGGER_RTT_BUFFER_UP* pRing) {
     f2e:	b086      	sub	sp, #24
     f30:	9001      	str	r0, [sp, #4]
  unsigned r;
  //
  // Avoid warnings regarding volatile access order.  It's not a problem
  // in this case, but dampen compiler enthusiasm.
  //
  RdOff = pRing->RdOff;
     f32:	9b01      	ldr	r3, [sp, #4]
     f34:	691b      	ldr	r3, [r3, #16]
     f36:	9304      	str	r3, [sp, #16]
  WrOff = pRing->WrOff;
     f38:	9b01      	ldr	r3, [sp, #4]
     f3a:	68db      	ldr	r3, [r3, #12]
     f3c:	9303      	str	r3, [sp, #12]
  if (RdOff <= WrOff) {
     f3e:	9a04      	ldr	r2, [sp, #16]
     f40:	9b03      	ldr	r3, [sp, #12]
     f42:	429a      	cmp	r2, r3
     f44:	d808      	bhi.n	f58 <_GetAvailWriteSpace+0x2a>
    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
     f46:	9b01      	ldr	r3, [sp, #4]
     f48:	689a      	ldr	r2, [r3, #8]
     f4a:	9b03      	ldr	r3, [sp, #12]
     f4c:	1ad2      	subs	r2, r2, r3
     f4e:	9b04      	ldr	r3, [sp, #16]
     f50:	4413      	add	r3, r2
     f52:	3b01      	subs	r3, #1
     f54:	9305      	str	r3, [sp, #20]
     f56:	e004      	b.n	f62 <_GetAvailWriteSpace+0x34>
  } else {
    r = RdOff - WrOff - 1u;
     f58:	9a04      	ldr	r2, [sp, #16]
     f5a:	9b03      	ldr	r3, [sp, #12]
     f5c:	1ad3      	subs	r3, r2, r3
     f5e:	3b01      	subs	r3, #1
     f60:	9305      	str	r3, [sp, #20]
  }
  return r;
     f62:	9b05      	ldr	r3, [sp, #20]
}
     f64:	4618      	mov	r0, r3
     f66:	b006      	add	sp, #24
     f68:	4770      	bx	lr
	...

00000f6c <SEGGER_RTT_WriteNoLock>:
*    (1) Data is stored according to buffer flags.
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
     f6c:	b500      	push	{lr}
     f6e:	b089      	sub	sp, #36	; 0x24
     f70:	9003      	str	r0, [sp, #12]
     f72:	9102      	str	r1, [sp, #8]
     f74:	9201      	str	r2, [sp, #4]
  const char*           pData;
  SEGGER_RTT_BUFFER_UP* pRing;
  //
  // Get "to-host" ring buffer.
  //
  pData = (const char *)pBuffer;
     f76:	9b02      	ldr	r3, [sp, #8]
     f78:	9306      	str	r3, [sp, #24]
  pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
     f7a:	9b03      	ldr	r3, [sp, #12]
     f7c:	1c5a      	adds	r2, r3, #1
     f7e:	4613      	mov	r3, r2
     f80:	005b      	lsls	r3, r3, #1
     f82:	4413      	add	r3, r2
     f84:	00db      	lsls	r3, r3, #3
     f86:	4a20      	ldr	r2, [pc, #128]	; (1008 <SEGGER_RTT_WriteNoLock+0x9c>)
     f88:	4413      	add	r3, r2
     f8a:	9305      	str	r3, [sp, #20]
  //
  // How we output depends upon the mode...
  //
  switch (pRing->Flags) {
     f8c:	9b05      	ldr	r3, [sp, #20]
     f8e:	695b      	ldr	r3, [r3, #20]
     f90:	2b02      	cmp	r3, #2
     f92:	d029      	beq.n	fe8 <SEGGER_RTT_WriteNoLock+0x7c>
     f94:	2b02      	cmp	r3, #2
     f96:	d82e      	bhi.n	ff6 <SEGGER_RTT_WriteNoLock+0x8a>
     f98:	2b00      	cmp	r3, #0
     f9a:	d002      	beq.n	fa2 <SEGGER_RTT_WriteNoLock+0x36>
     f9c:	2b01      	cmp	r3, #1
     f9e:	d013      	beq.n	fc8 <SEGGER_RTT_WriteNoLock+0x5c>
     fa0:	e029      	b.n	ff6 <SEGGER_RTT_WriteNoLock+0x8a>
  case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
    //
    // If we are in skip mode and there is no space for the whole
    // of this output, don't bother.
    //
    Avail = _GetAvailWriteSpace(pRing);
     fa2:	9805      	ldr	r0, [sp, #20]
     fa4:	f7ff ffc3 	bl	f2e <_GetAvailWriteSpace>
     fa8:	9004      	str	r0, [sp, #16]
    if (Avail < NumBytes) {
     faa:	9a04      	ldr	r2, [sp, #16]
     fac:	9b01      	ldr	r3, [sp, #4]
     fae:	429a      	cmp	r2, r3
     fb0:	d202      	bcs.n	fb8 <SEGGER_RTT_WriteNoLock+0x4c>
      Status = 0u;
     fb2:	2300      	movs	r3, #0
     fb4:	9307      	str	r3, [sp, #28]
    } else {
      Status = NumBytes;
      _WriteNoCheck(pRing, pData, NumBytes);
    }
    break;
     fb6:	e021      	b.n	ffc <SEGGER_RTT_WriteNoLock+0x90>
      Status = NumBytes;
     fb8:	9b01      	ldr	r3, [sp, #4]
     fba:	9307      	str	r3, [sp, #28]
      _WriteNoCheck(pRing, pData, NumBytes);
     fbc:	9a01      	ldr	r2, [sp, #4]
     fbe:	9906      	ldr	r1, [sp, #24]
     fc0:	9805      	ldr	r0, [sp, #20]
     fc2:	f7ff ff6d 	bl	ea0 <_WriteNoCheck>
    break;
     fc6:	e019      	b.n	ffc <SEGGER_RTT_WriteNoLock+0x90>
  case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
    //
    // If we are in trim mode, trim to what we can output without blocking.
    //
    Avail = _GetAvailWriteSpace(pRing);
     fc8:	9805      	ldr	r0, [sp, #20]
     fca:	f7ff ffb0 	bl	f2e <_GetAvailWriteSpace>
     fce:	9004      	str	r0, [sp, #16]
    Status = Avail < NumBytes ? Avail : NumBytes;
     fd0:	9a01      	ldr	r2, [sp, #4]
     fd2:	9b04      	ldr	r3, [sp, #16]
     fd4:	4293      	cmp	r3, r2
     fd6:	bf28      	it	cs
     fd8:	4613      	movcs	r3, r2
     fda:	9307      	str	r3, [sp, #28]
    _WriteNoCheck(pRing, pData, Status);
     fdc:	9a07      	ldr	r2, [sp, #28]
     fde:	9906      	ldr	r1, [sp, #24]
     fe0:	9805      	ldr	r0, [sp, #20]
     fe2:	f7ff ff5d 	bl	ea0 <_WriteNoCheck>
    break;
     fe6:	e009      	b.n	ffc <SEGGER_RTT_WriteNoLock+0x90>
  case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
    //
    // If we are in blocking mode, output everything.
    //
    Status = _WriteBlocking(pRing, pData, NumBytes);
     fe8:	9a01      	ldr	r2, [sp, #4]
     fea:	9906      	ldr	r1, [sp, #24]
     fec:	9805      	ldr	r0, [sp, #20]
     fee:	f7ff fefb 	bl	de8 <_WriteBlocking>
     ff2:	9007      	str	r0, [sp, #28]
    break;
     ff4:	e002      	b.n	ffc <SEGGER_RTT_WriteNoLock+0x90>
  default:
    Status = 0u;
     ff6:	2300      	movs	r3, #0
     ff8:	9307      	str	r3, [sp, #28]
    break;
     ffa:	bf00      	nop
  }
  //
  // Finish up.
  //
  return Status;
     ffc:	9b07      	ldr	r3, [sp, #28]
}
     ffe:	4618      	mov	r0, r3
    1000:	b009      	add	sp, #36	; 0x24
    1002:	f85d fb04 	ldr.w	pc, [sp], #4
    1006:	bf00      	nop
    1008:	1fff991c 	.word	0x1fff991c

0000100c <SEGGER_RTT_Write>:
*    Number of bytes which have been stored in the "Up"-buffer.
*
*  Notes
*    (1) Data is stored according to buffer flags.
*/
unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    100c:	b500      	push	{lr}
    100e:	b089      	sub	sp, #36	; 0x24
    1010:	9003      	str	r0, [sp, #12]
    1012:	9102      	str	r1, [sp, #8]
    1014:	9201      	str	r2, [sp, #4]
  unsigned Status;

  INIT();
    1016:	4b0f      	ldr	r3, [pc, #60]	; (1054 <SEGGER_RTT_Write+0x48>)
    1018:	9307      	str	r3, [sp, #28]
    101a:	9b07      	ldr	r3, [sp, #28]
    101c:	781b      	ldrb	r3, [r3, #0]
    101e:	b2db      	uxtb	r3, r3
    1020:	2b53      	cmp	r3, #83	; 0x53
    1022:	d001      	beq.n	1028 <SEGGER_RTT_Write+0x1c>
    1024:	f7ff fe86 	bl	d34 <_DoInit>
  SEGGER_RTT_LOCK();
    1028:	f3ef 8311 	mrs	r3, BASEPRI
    102c:	f04f 0120 	mov.w	r1, #32
    1030:	f381 8811 	msr	BASEPRI, r1
    1034:	9306      	str	r3, [sp, #24]
  Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);  // Call the non-locking write function
    1036:	9a01      	ldr	r2, [sp, #4]
    1038:	9902      	ldr	r1, [sp, #8]
    103a:	9803      	ldr	r0, [sp, #12]
    103c:	f7ff ff96 	bl	f6c <SEGGER_RTT_WriteNoLock>
    1040:	9005      	str	r0, [sp, #20]
  SEGGER_RTT_UNLOCK();
    1042:	9b06      	ldr	r3, [sp, #24]
    1044:	f383 8811 	msr	BASEPRI, r3
  return Status;
    1048:	9b05      	ldr	r3, [sp, #20]
}
    104a:	4618      	mov	r0, r3
    104c:	b009      	add	sp, #36	; 0x24
    104e:	f85d fb04 	ldr.w	pc, [sp], #4
    1052:	bf00      	nop
    1054:	1fff991c 	.word	0x1fff991c

00001058 <SEGGER_RTT_Init>:
*  Function description
*    Initializes the RTT Control Block.
*    Should be used in RAM targets, at start of the application.
*
*/
void SEGGER_RTT_Init (void) {
    1058:	b508      	push	{r3, lr}
  _DoInit();
    105a:	f7ff fe6b 	bl	d34 <_DoInit>
}
    105e:	bf00      	nop
    1060:	bd08      	pop	{r3, pc}

00001062 <_StoreChar>:
*/
/*********************************************************************
*
*       _StoreChar
*/
static void _StoreChar(SEGGER_RTT_PRINTF_DESC * p, char c) {
    1062:	b500      	push	{lr}
    1064:	b085      	sub	sp, #20
    1066:	9001      	str	r0, [sp, #4]
    1068:	460b      	mov	r3, r1
    106a:	f88d 3003 	strb.w	r3, [sp, #3]
  unsigned Cnt;

  Cnt = p->Cnt;
    106e:	9b01      	ldr	r3, [sp, #4]
    1070:	689b      	ldr	r3, [r3, #8]
    1072:	9303      	str	r3, [sp, #12]
  if ((Cnt + 1u) <= p->BufferSize) {
    1074:	9b03      	ldr	r3, [sp, #12]
    1076:	1c5a      	adds	r2, r3, #1
    1078:	9b01      	ldr	r3, [sp, #4]
    107a:	685b      	ldr	r3, [r3, #4]
    107c:	429a      	cmp	r2, r3
    107e:	d80f      	bhi.n	10a0 <_StoreChar+0x3e>
    *(p->pBuffer + Cnt) = c;
    1080:	9b01      	ldr	r3, [sp, #4]
    1082:	681a      	ldr	r2, [r3, #0]
    1084:	9b03      	ldr	r3, [sp, #12]
    1086:	4413      	add	r3, r2
    1088:	f89d 2003 	ldrb.w	r2, [sp, #3]
    108c:	701a      	strb	r2, [r3, #0]
    p->Cnt = Cnt + 1u;
    108e:	9b03      	ldr	r3, [sp, #12]
    1090:	1c5a      	adds	r2, r3, #1
    1092:	9b01      	ldr	r3, [sp, #4]
    1094:	609a      	str	r2, [r3, #8]
    p->ReturnValue++;
    1096:	9b01      	ldr	r3, [sp, #4]
    1098:	68db      	ldr	r3, [r3, #12]
    109a:	1c5a      	adds	r2, r3, #1
    109c:	9b01      	ldr	r3, [sp, #4]
    109e:	60da      	str	r2, [r3, #12]
  }
  //
  // Write part of string, when the buffer is full
  //
  if (p->Cnt == p->BufferSize) {
    10a0:	9b01      	ldr	r3, [sp, #4]
    10a2:	689a      	ldr	r2, [r3, #8]
    10a4:	9b01      	ldr	r3, [sp, #4]
    10a6:	685b      	ldr	r3, [r3, #4]
    10a8:	429a      	cmp	r2, r3
    10aa:	d115      	bne.n	10d8 <_StoreChar+0x76>
    if (SEGGER_RTT_Write(p->RTTBufferIndex, p->pBuffer, p->Cnt) != p->Cnt) {
    10ac:	9b01      	ldr	r3, [sp, #4]
    10ae:	6918      	ldr	r0, [r3, #16]
    10b0:	9b01      	ldr	r3, [sp, #4]
    10b2:	6819      	ldr	r1, [r3, #0]
    10b4:	9b01      	ldr	r3, [sp, #4]
    10b6:	689b      	ldr	r3, [r3, #8]
    10b8:	461a      	mov	r2, r3
    10ba:	f7ff ffa7 	bl	100c <SEGGER_RTT_Write>
    10be:	4602      	mov	r2, r0
    10c0:	9b01      	ldr	r3, [sp, #4]
    10c2:	689b      	ldr	r3, [r3, #8]
    10c4:	429a      	cmp	r2, r3
    10c6:	d004      	beq.n	10d2 <_StoreChar+0x70>
      p->ReturnValue = -1;
    10c8:	9b01      	ldr	r3, [sp, #4]
    10ca:	f04f 32ff 	mov.w	r2, #4294967295
    10ce:	60da      	str	r2, [r3, #12]
    } else {
      p->Cnt = 0u;
    }
  }
}
    10d0:	e002      	b.n	10d8 <_StoreChar+0x76>
      p->Cnt = 0u;
    10d2:	9b01      	ldr	r3, [sp, #4]
    10d4:	2200      	movs	r2, #0
    10d6:	609a      	str	r2, [r3, #8]
}
    10d8:	bf00      	nop
    10da:	b005      	add	sp, #20
    10dc:	f85d fb04 	ldr.w	pc, [sp], #4

000010e0 <_PrintUnsigned>:

/*********************************************************************
*
*       _PrintUnsigned
*/
static void _PrintUnsigned(SEGGER_RTT_PRINTF_DESC * pBufferDesc, unsigned v, unsigned Base, unsigned NumDigits, unsigned FieldWidth, unsigned FormatFlags) {
    10e0:	b500      	push	{lr}
    10e2:	b08b      	sub	sp, #44	; 0x2c
    10e4:	9003      	str	r0, [sp, #12]
    10e6:	9102      	str	r1, [sp, #8]
    10e8:	9201      	str	r2, [sp, #4]
    10ea:	9300      	str	r3, [sp, #0]
  unsigned Digit;
  unsigned Number;
  unsigned Width;
  char c;

  Number = v;
    10ec:	9b02      	ldr	r3, [sp, #8]
    10ee:	9308      	str	r3, [sp, #32]
  Digit = 1u;
    10f0:	2301      	movs	r3, #1
    10f2:	9309      	str	r3, [sp, #36]	; 0x24
  //
  // Get actual field width
  //
  Width = 1u;
    10f4:	2301      	movs	r3, #1
    10f6:	9307      	str	r3, [sp, #28]
  while (Number >= Base) {
    10f8:	e007      	b.n	110a <_PrintUnsigned+0x2a>
    Number = (Number / Base);
    10fa:	9a08      	ldr	r2, [sp, #32]
    10fc:	9b01      	ldr	r3, [sp, #4]
    10fe:	fbb2 f3f3 	udiv	r3, r2, r3
    1102:	9308      	str	r3, [sp, #32]
    Width++;
    1104:	9b07      	ldr	r3, [sp, #28]
    1106:	3301      	adds	r3, #1
    1108:	9307      	str	r3, [sp, #28]
  while (Number >= Base) {
    110a:	9a08      	ldr	r2, [sp, #32]
    110c:	9b01      	ldr	r3, [sp, #4]
    110e:	429a      	cmp	r2, r3
    1110:	d2f3      	bcs.n	10fa <_PrintUnsigned+0x1a>
  }
  if (NumDigits > Width) {
    1112:	9a00      	ldr	r2, [sp, #0]
    1114:	9b07      	ldr	r3, [sp, #28]
    1116:	429a      	cmp	r2, r3
    1118:	d901      	bls.n	111e <_PrintUnsigned+0x3e>
    Width = NumDigits;
    111a:	9b00      	ldr	r3, [sp, #0]
    111c:	9307      	str	r3, [sp, #28]
  }
  //
  // Print leading chars if necessary
  //
  if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) {
    111e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    1120:	f003 0301 	and.w	r3, r3, #1
    1124:	2b00      	cmp	r3, #0
    1126:	d128      	bne.n	117a <_PrintUnsigned+0x9a>
    if (FieldWidth != 0u) {
    1128:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    112a:	2b00      	cmp	r3, #0
    112c:	d025      	beq.n	117a <_PrintUnsigned+0x9a>
      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && (NumDigits == 0u)) {
    112e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    1130:	f003 0302 	and.w	r3, r3, #2
    1134:	2b00      	cmp	r3, #0
    1136:	d006      	beq.n	1146 <_PrintUnsigned+0x66>
    1138:	9b00      	ldr	r3, [sp, #0]
    113a:	2b00      	cmp	r3, #0
    113c:	d103      	bne.n	1146 <_PrintUnsigned+0x66>
        c = '0';
    113e:	2330      	movs	r3, #48	; 0x30
    1140:	f88d 301b 	strb.w	r3, [sp, #27]
    1144:	e002      	b.n	114c <_PrintUnsigned+0x6c>
      } else {
        c = ' ';
    1146:	2320      	movs	r3, #32
    1148:	f88d 301b 	strb.w	r3, [sp, #27]
      }
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    114c:	e00c      	b.n	1168 <_PrintUnsigned+0x88>
        FieldWidth--;
    114e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    1150:	3b01      	subs	r3, #1
    1152:	930c      	str	r3, [sp, #48]	; 0x30
        _StoreChar(pBufferDesc, c);
    1154:	f89d 301b 	ldrb.w	r3, [sp, #27]
    1158:	4619      	mov	r1, r3
    115a:	9803      	ldr	r0, [sp, #12]
    115c:	f7ff ff81 	bl	1062 <_StoreChar>
        if (pBufferDesc->ReturnValue < 0) {
    1160:	9b03      	ldr	r3, [sp, #12]
    1162:	68db      	ldr	r3, [r3, #12]
    1164:	2b00      	cmp	r3, #0
    1166:	db07      	blt.n	1178 <_PrintUnsigned+0x98>
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    1168:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    116a:	2b00      	cmp	r3, #0
    116c:	d005      	beq.n	117a <_PrintUnsigned+0x9a>
    116e:	9a07      	ldr	r2, [sp, #28]
    1170:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    1172:	429a      	cmp	r2, r3
    1174:	d3eb      	bcc.n	114e <_PrintUnsigned+0x6e>
    1176:	e000      	b.n	117a <_PrintUnsigned+0x9a>
          break;
    1178:	bf00      	nop
        }
      }
    }
  }
  if (pBufferDesc->ReturnValue >= 0) {
    117a:	9b03      	ldr	r3, [sp, #12]
    117c:	68db      	ldr	r3, [r3, #12]
    117e:	2b00      	cmp	r3, #0
    1180:	db55      	blt.n	122e <_PrintUnsigned+0x14e>
    // Compute Digit.
    // Loop until Digit has the value of the highest digit required.
    // Example: If the output is 345 (Base 10), loop 2 times until Digit is 100.
    //
    while (1) {
      if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
    1182:	9b00      	ldr	r3, [sp, #0]
    1184:	2b01      	cmp	r3, #1
    1186:	d903      	bls.n	1190 <_PrintUnsigned+0xb0>
        NumDigits--;
    1188:	9b00      	ldr	r3, [sp, #0]
    118a:	3b01      	subs	r3, #1
    118c:	9300      	str	r3, [sp, #0]
    118e:	e009      	b.n	11a4 <_PrintUnsigned+0xc4>
      } else {
        Div = v / Digit;
    1190:	9a02      	ldr	r2, [sp, #8]
    1192:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1194:	fbb2 f3f3 	udiv	r3, r2, r3
    1198:	9305      	str	r3, [sp, #20]
        if (Div < Base) {        // Is our divider big enough to extract the highest digit from value? => Done
    119a:	9a05      	ldr	r2, [sp, #20]
    119c:	9b01      	ldr	r3, [sp, #4]
    119e:	429a      	cmp	r2, r3
    11a0:	d200      	bcs.n	11a4 <_PrintUnsigned+0xc4>
          break;
    11a2:	e005      	b.n	11b0 <_PrintUnsigned+0xd0>
        }
      }
      Digit *= Base;
    11a4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    11a6:	9a01      	ldr	r2, [sp, #4]
    11a8:	fb02 f303 	mul.w	r3, r2, r3
    11ac:	9309      	str	r3, [sp, #36]	; 0x24
      if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
    11ae:	e7e8      	b.n	1182 <_PrintUnsigned+0xa2>
    }
    //
    // Output digits
    //
    do {
      Div = v / Digit;
    11b0:	9a02      	ldr	r2, [sp, #8]
    11b2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    11b4:	fbb2 f3f3 	udiv	r3, r2, r3
    11b8:	9305      	str	r3, [sp, #20]
      v -= Div * Digit;
    11ba:	9b05      	ldr	r3, [sp, #20]
    11bc:	9a09      	ldr	r2, [sp, #36]	; 0x24
    11be:	fb02 f303 	mul.w	r3, r2, r3
    11c2:	9a02      	ldr	r2, [sp, #8]
    11c4:	1ad3      	subs	r3, r2, r3
    11c6:	9302      	str	r3, [sp, #8]
      _StoreChar(pBufferDesc, _aV2C[Div]);
    11c8:	4a1b      	ldr	r2, [pc, #108]	; (1238 <_PrintUnsigned+0x158>)
    11ca:	9b05      	ldr	r3, [sp, #20]
    11cc:	4413      	add	r3, r2
    11ce:	781b      	ldrb	r3, [r3, #0]
    11d0:	4619      	mov	r1, r3
    11d2:	9803      	ldr	r0, [sp, #12]
    11d4:	f7ff ff45 	bl	1062 <_StoreChar>
      if (pBufferDesc->ReturnValue < 0) {
    11d8:	9b03      	ldr	r3, [sp, #12]
    11da:	68db      	ldr	r3, [r3, #12]
    11dc:	2b00      	cmp	r3, #0
    11de:	db08      	blt.n	11f2 <_PrintUnsigned+0x112>
        break;
      }
      Digit /= Base;
    11e0:	9a09      	ldr	r2, [sp, #36]	; 0x24
    11e2:	9b01      	ldr	r3, [sp, #4]
    11e4:	fbb2 f3f3 	udiv	r3, r2, r3
    11e8:	9309      	str	r3, [sp, #36]	; 0x24
    } while (Digit);
    11ea:	9b09      	ldr	r3, [sp, #36]	; 0x24
    11ec:	2b00      	cmp	r3, #0
    11ee:	d1df      	bne.n	11b0 <_PrintUnsigned+0xd0>
    11f0:	e000      	b.n	11f4 <_PrintUnsigned+0x114>
        break;
    11f2:	bf00      	nop
    //
    // Print trailing spaces if necessary
    //
    if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == FORMAT_FLAG_LEFT_JUSTIFY) {
    11f4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    11f6:	f003 0301 	and.w	r3, r3, #1
    11fa:	2b00      	cmp	r3, #0
    11fc:	d017      	beq.n	122e <_PrintUnsigned+0x14e>
      if (FieldWidth != 0u) {
    11fe:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    1200:	2b00      	cmp	r3, #0
    1202:	d014      	beq.n	122e <_PrintUnsigned+0x14e>
        while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    1204:	e00a      	b.n	121c <_PrintUnsigned+0x13c>
          FieldWidth--;
    1206:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    1208:	3b01      	subs	r3, #1
    120a:	930c      	str	r3, [sp, #48]	; 0x30
          _StoreChar(pBufferDesc, ' ');
    120c:	2120      	movs	r1, #32
    120e:	9803      	ldr	r0, [sp, #12]
    1210:	f7ff ff27 	bl	1062 <_StoreChar>
          if (pBufferDesc->ReturnValue < 0) {
    1214:	9b03      	ldr	r3, [sp, #12]
    1216:	68db      	ldr	r3, [r3, #12]
    1218:	2b00      	cmp	r3, #0
    121a:	db07      	blt.n	122c <_PrintUnsigned+0x14c>
        while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    121c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    121e:	2b00      	cmp	r3, #0
    1220:	d005      	beq.n	122e <_PrintUnsigned+0x14e>
    1222:	9a07      	ldr	r2, [sp, #28]
    1224:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    1226:	429a      	cmp	r2, r3
    1228:	d3ed      	bcc.n	1206 <_PrintUnsigned+0x126>
          }
        }
      }
    }
  }
}
    122a:	e000      	b.n	122e <_PrintUnsigned+0x14e>
            break;
    122c:	bf00      	nop
}
    122e:	bf00      	nop
    1230:	b00b      	add	sp, #44	; 0x2c
    1232:	f85d fb04 	ldr.w	pc, [sp], #4
    1236:	bf00      	nop
    1238:	00019bdc 	.word	0x00019bdc

0000123c <_PrintInt>:

/*********************************************************************
*
*       _PrintInt
*/
static void _PrintInt(SEGGER_RTT_PRINTF_DESC * pBufferDesc, int v, unsigned Base, unsigned NumDigits, unsigned FieldWidth, unsigned FormatFlags) {
    123c:	b500      	push	{lr}
    123e:	b089      	sub	sp, #36	; 0x24
    1240:	9005      	str	r0, [sp, #20]
    1242:	9104      	str	r1, [sp, #16]
    1244:	9203      	str	r2, [sp, #12]
    1246:	9302      	str	r3, [sp, #8]
  unsigned Width;
  int Number;

  Number = (v < 0) ? -v : v;
    1248:	9b04      	ldr	r3, [sp, #16]
    124a:	2b00      	cmp	r3, #0
    124c:	bfb8      	it	lt
    124e:	425b      	neglt	r3, r3
    1250:	9306      	str	r3, [sp, #24]

  //
  // Get actual field width
  //
  Width = 1u;
    1252:	2301      	movs	r3, #1
    1254:	9307      	str	r3, [sp, #28]
  while (Number >= (int)Base) {
    1256:	e007      	b.n	1268 <_PrintInt+0x2c>
    Number = (Number / (int)Base);
    1258:	9b03      	ldr	r3, [sp, #12]
    125a:	9a06      	ldr	r2, [sp, #24]
    125c:	fb92 f3f3 	sdiv	r3, r2, r3
    1260:	9306      	str	r3, [sp, #24]
    Width++;
    1262:	9b07      	ldr	r3, [sp, #28]
    1264:	3301      	adds	r3, #1
    1266:	9307      	str	r3, [sp, #28]
  while (Number >= (int)Base) {
    1268:	9b03      	ldr	r3, [sp, #12]
    126a:	9a06      	ldr	r2, [sp, #24]
    126c:	429a      	cmp	r2, r3
    126e:	daf3      	bge.n	1258 <_PrintInt+0x1c>
  }
  if (NumDigits > Width) {
    1270:	9a02      	ldr	r2, [sp, #8]
    1272:	9b07      	ldr	r3, [sp, #28]
    1274:	429a      	cmp	r2, r3
    1276:	d901      	bls.n	127c <_PrintInt+0x40>
    Width = NumDigits;
    1278:	9b02      	ldr	r3, [sp, #8]
    127a:	9307      	str	r3, [sp, #28]
  }
  if ((FieldWidth > 0u) && ((v < 0) || ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN))) {
    127c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    127e:	2b00      	cmp	r3, #0
    1280:	d00a      	beq.n	1298 <_PrintInt+0x5c>
    1282:	9b04      	ldr	r3, [sp, #16]
    1284:	2b00      	cmp	r3, #0
    1286:	db04      	blt.n	1292 <_PrintInt+0x56>
    1288:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    128a:	f003 0304 	and.w	r3, r3, #4
    128e:	2b00      	cmp	r3, #0
    1290:	d002      	beq.n	1298 <_PrintInt+0x5c>
    FieldWidth--;
    1292:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1294:	3b01      	subs	r3, #1
    1296:	930a      	str	r3, [sp, #40]	; 0x28
  }

  //
  // Print leading spaces if necessary
  //
  if ((((FormatFlags & FORMAT_FLAG_PAD_ZERO) == 0u) || (NumDigits != 0u)) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u)) {
    1298:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    129a:	f003 0302 	and.w	r3, r3, #2
    129e:	2b00      	cmp	r3, #0
    12a0:	d002      	beq.n	12a8 <_PrintInt+0x6c>
    12a2:	9b02      	ldr	r3, [sp, #8]
    12a4:	2b00      	cmp	r3, #0
    12a6:	d01c      	beq.n	12e2 <__BSS_SRAM_SIZE+0x32>
    12a8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    12aa:	f003 0301 	and.w	r3, r3, #1
    12ae:	2b00      	cmp	r3, #0
    12b0:	d117      	bne.n	12e2 <__BSS_SRAM_SIZE+0x32>
    if (FieldWidth != 0u) {
    12b2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    12b4:	2b00      	cmp	r3, #0
    12b6:	d014      	beq.n	12e2 <__BSS_SRAM_SIZE+0x32>
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    12b8:	e00a      	b.n	12d0 <__BSS_SRAM_SIZE+0x20>
        FieldWidth--;
    12ba:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    12bc:	3b01      	subs	r3, #1
    12be:	930a      	str	r3, [sp, #40]	; 0x28
        _StoreChar(pBufferDesc, ' ');
    12c0:	2120      	movs	r1, #32
    12c2:	9805      	ldr	r0, [sp, #20]
    12c4:	f7ff fecd 	bl	1062 <_StoreChar>
        if (pBufferDesc->ReturnValue < 0) {
    12c8:	9b05      	ldr	r3, [sp, #20]
    12ca:	68db      	ldr	r3, [r3, #12]
    12cc:	2b00      	cmp	r3, #0
    12ce:	db07      	blt.n	12e0 <__BSS_SRAM_SIZE+0x30>
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    12d0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    12d2:	2b00      	cmp	r3, #0
    12d4:	d005      	beq.n	12e2 <__BSS_SRAM_SIZE+0x32>
    12d6:	9a07      	ldr	r2, [sp, #28]
    12d8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    12da:	429a      	cmp	r2, r3
    12dc:	d3ed      	bcc.n	12ba <__BSS_SRAM_SIZE+0xa>
    12de:	e000      	b.n	12e2 <__BSS_SRAM_SIZE+0x32>
          break;
    12e0:	bf00      	nop
    }
  }
  //
  // Print sign if necessary
  //
  if (pBufferDesc->ReturnValue >= 0) {
    12e2:	9b05      	ldr	r3, [sp, #20]
    12e4:	68db      	ldr	r3, [r3, #12]
    12e6:	2b00      	cmp	r3, #0
    12e8:	db4a      	blt.n	1380 <__BSS_SRAM_SIZE+0xd0>
    if (v < 0) {
    12ea:	9b04      	ldr	r3, [sp, #16]
    12ec:	2b00      	cmp	r3, #0
    12ee:	da07      	bge.n	1300 <__BSS_SRAM_SIZE+0x50>
      v = -v;
    12f0:	9b04      	ldr	r3, [sp, #16]
    12f2:	425b      	negs	r3, r3
    12f4:	9304      	str	r3, [sp, #16]
      _StoreChar(pBufferDesc, '-');
    12f6:	212d      	movs	r1, #45	; 0x2d
    12f8:	9805      	ldr	r0, [sp, #20]
    12fa:	f7ff feb2 	bl	1062 <_StoreChar>
    12fe:	e008      	b.n	1312 <__BSS_SRAM_SIZE+0x62>
    } else if ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN) {
    1300:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1302:	f003 0304 	and.w	r3, r3, #4
    1306:	2b00      	cmp	r3, #0
    1308:	d003      	beq.n	1312 <__BSS_SRAM_SIZE+0x62>
      _StoreChar(pBufferDesc, '+');
    130a:	212b      	movs	r1, #43	; 0x2b
    130c:	9805      	ldr	r0, [sp, #20]
    130e:	f7ff fea8 	bl	1062 <_StoreChar>
    } else {

    }
    if (pBufferDesc->ReturnValue >= 0) {
    1312:	9b05      	ldr	r3, [sp, #20]
    1314:	68db      	ldr	r3, [r3, #12]
    1316:	2b00      	cmp	r3, #0
    1318:	db32      	blt.n	1380 <__BSS_SRAM_SIZE+0xd0>
      //
      // Print leading zeros if necessary
      //
      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) && (NumDigits == 0u)) {
    131a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    131c:	f003 0302 	and.w	r3, r3, #2
    1320:	2b00      	cmp	r3, #0
    1322:	d01f      	beq.n	1364 <__BSS_SRAM_SIZE+0xb4>
    1324:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1326:	f003 0301 	and.w	r3, r3, #1
    132a:	2b00      	cmp	r3, #0
    132c:	d11a      	bne.n	1364 <__BSS_SRAM_SIZE+0xb4>
    132e:	9b02      	ldr	r3, [sp, #8]
    1330:	2b00      	cmp	r3, #0
    1332:	d117      	bne.n	1364 <__BSS_SRAM_SIZE+0xb4>
        if (FieldWidth != 0u) {
    1334:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1336:	2b00      	cmp	r3, #0
    1338:	d014      	beq.n	1364 <__BSS_SRAM_SIZE+0xb4>
          while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    133a:	e00a      	b.n	1352 <__BSS_SRAM_SIZE+0xa2>
            FieldWidth--;
    133c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    133e:	3b01      	subs	r3, #1
    1340:	930a      	str	r3, [sp, #40]	; 0x28
            _StoreChar(pBufferDesc, '0');
    1342:	2130      	movs	r1, #48	; 0x30
    1344:	9805      	ldr	r0, [sp, #20]
    1346:	f7ff fe8c 	bl	1062 <_StoreChar>
            if (pBufferDesc->ReturnValue < 0) {
    134a:	9b05      	ldr	r3, [sp, #20]
    134c:	68db      	ldr	r3, [r3, #12]
    134e:	2b00      	cmp	r3, #0
    1350:	db07      	blt.n	1362 <__BSS_SRAM_SIZE+0xb2>
          while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    1352:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1354:	2b00      	cmp	r3, #0
    1356:	d005      	beq.n	1364 <__BSS_SRAM_SIZE+0xb4>
    1358:	9a07      	ldr	r2, [sp, #28]
    135a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    135c:	429a      	cmp	r2, r3
    135e:	d3ed      	bcc.n	133c <__BSS_SRAM_SIZE+0x8c>
    1360:	e000      	b.n	1364 <__BSS_SRAM_SIZE+0xb4>
              break;
    1362:	bf00      	nop
            }
          }
        }
      }
      if (pBufferDesc->ReturnValue >= 0) {
    1364:	9b05      	ldr	r3, [sp, #20]
    1366:	68db      	ldr	r3, [r3, #12]
    1368:	2b00      	cmp	r3, #0
    136a:	db09      	blt.n	1380 <__BSS_SRAM_SIZE+0xd0>
        //
        // Print number without sign
        //
        _PrintUnsigned(pBufferDesc, (unsigned)v, Base, NumDigits, FieldWidth, FormatFlags);
    136c:	9904      	ldr	r1, [sp, #16]
    136e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1370:	9301      	str	r3, [sp, #4]
    1372:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1374:	9300      	str	r3, [sp, #0]
    1376:	9b02      	ldr	r3, [sp, #8]
    1378:	9a03      	ldr	r2, [sp, #12]
    137a:	9805      	ldr	r0, [sp, #20]
    137c:	f7ff feb0 	bl	10e0 <_PrintUnsigned>
      }
    }
  }
}
    1380:	bf00      	nop
    1382:	b009      	add	sp, #36	; 0x24
    1384:	f85d fb04 	ldr.w	pc, [sp], #4

00001388 <SEGGER_RTT_vprintf>:
*
*  Return values
*    >= 0:  Number of bytes which have been stored in the "Up"-buffer.
*     < 0:  Error
*/
int SEGGER_RTT_vprintf(unsigned BufferIndex, const char * sFormat, va_list * pParamList) {
    1388:	b500      	push	{lr}
    138a:	b0a3      	sub	sp, #140	; 0x8c
    138c:	9005      	str	r0, [sp, #20]
    138e:	9104      	str	r1, [sp, #16]
    1390:	9203      	str	r2, [sp, #12]
  unsigned NumDigits;
  unsigned FormatFlags;
  unsigned FieldWidth;
  char acBuffer[SEGGER_RTT_PRINTF_BUFFER_SIZE];

  BufferDesc.pBuffer        = acBuffer;
    1392:	ab06      	add	r3, sp, #24
    1394:	9316      	str	r3, [sp, #88]	; 0x58
  BufferDesc.BufferSize     = SEGGER_RTT_PRINTF_BUFFER_SIZE;
    1396:	2340      	movs	r3, #64	; 0x40
    1398:	9317      	str	r3, [sp, #92]	; 0x5c
  BufferDesc.Cnt            = 0u;
    139a:	2300      	movs	r3, #0
    139c:	9318      	str	r3, [sp, #96]	; 0x60
  BufferDesc.RTTBufferIndex = BufferIndex;
    139e:	9b05      	ldr	r3, [sp, #20]
    13a0:	931a      	str	r3, [sp, #104]	; 0x68
  BufferDesc.ReturnValue    = 0;
    13a2:	2300      	movs	r3, #0
    13a4:	9319      	str	r3, [sp, #100]	; 0x64

  do {
    c = *sFormat;
    13a6:	9b04      	ldr	r3, [sp, #16]
    13a8:	781b      	ldrb	r3, [r3, #0]
    13aa:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
    sFormat++;
    13ae:	9b04      	ldr	r3, [sp, #16]
    13b0:	3301      	adds	r3, #1
    13b2:	9304      	str	r3, [sp, #16]
    if (c == 0u) {
    13b4:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    13b8:	2b00      	cmp	r3, #0
    13ba:	f000 819c 	beq.w	16f6 <SEGGER_RTT_vprintf+0x36e>
      break;
    }
    if (c == '%') {
    13be:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    13c2:	2b25      	cmp	r3, #37	; 0x25
    13c4:	f040 818b 	bne.w	16de <SEGGER_RTT_vprintf+0x356>
      //
      // Filter out flags
      //
      FormatFlags = 0u;
    13c8:	2300      	movs	r3, #0
    13ca:	931e      	str	r3, [sp, #120]	; 0x78
      v = 1;
    13cc:	2301      	movs	r3, #1
    13ce:	9320      	str	r3, [sp, #128]	; 0x80
      do {
        c = *sFormat;
    13d0:	9b04      	ldr	r3, [sp, #16]
    13d2:	781b      	ldrb	r3, [r3, #0]
    13d4:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
        switch (c) {
    13d8:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    13dc:	3b23      	subs	r3, #35	; 0x23
    13de:	2b0d      	cmp	r3, #13
    13e0:	d83e      	bhi.n	1460 <SEGGER_RTT_vprintf+0xd8>
    13e2:	a201      	add	r2, pc, #4	; (adr r2, 13e8 <SEGGER_RTT_vprintf+0x60>)
    13e4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    13e8:	00001451 	.word	0x00001451
    13ec:	00001461 	.word	0x00001461
    13f0:	00001461 	.word	0x00001461
    13f4:	00001461 	.word	0x00001461
    13f8:	00001461 	.word	0x00001461
    13fc:	00001461 	.word	0x00001461
    1400:	00001461 	.word	0x00001461
    1404:	00001461 	.word	0x00001461
    1408:	00001441 	.word	0x00001441
    140c:	00001461 	.word	0x00001461
    1410:	00001421 	.word	0x00001421
    1414:	00001461 	.word	0x00001461
    1418:	00001461 	.word	0x00001461
    141c:	00001431 	.word	0x00001431
        case '-': FormatFlags |= FORMAT_FLAG_LEFT_JUSTIFY; sFormat++; break;
    1420:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    1422:	f043 0301 	orr.w	r3, r3, #1
    1426:	931e      	str	r3, [sp, #120]	; 0x78
    1428:	9b04      	ldr	r3, [sp, #16]
    142a:	3301      	adds	r3, #1
    142c:	9304      	str	r3, [sp, #16]
    142e:	e01a      	b.n	1466 <SEGGER_RTT_vprintf+0xde>
        case '0': FormatFlags |= FORMAT_FLAG_PAD_ZERO;     sFormat++; break;
    1430:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    1432:	f043 0302 	orr.w	r3, r3, #2
    1436:	931e      	str	r3, [sp, #120]	; 0x78
    1438:	9b04      	ldr	r3, [sp, #16]
    143a:	3301      	adds	r3, #1
    143c:	9304      	str	r3, [sp, #16]
    143e:	e012      	b.n	1466 <SEGGER_RTT_vprintf+0xde>
        case '+': FormatFlags |= FORMAT_FLAG_PRINT_SIGN;   sFormat++; break;
    1440:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    1442:	f043 0304 	orr.w	r3, r3, #4
    1446:	931e      	str	r3, [sp, #120]	; 0x78
    1448:	9b04      	ldr	r3, [sp, #16]
    144a:	3301      	adds	r3, #1
    144c:	9304      	str	r3, [sp, #16]
    144e:	e00a      	b.n	1466 <SEGGER_RTT_vprintf+0xde>
        case '#': FormatFlags |= FORMAT_FLAG_ALTERNATE;    sFormat++; break;
    1450:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    1452:	f043 0308 	orr.w	r3, r3, #8
    1456:	931e      	str	r3, [sp, #120]	; 0x78
    1458:	9b04      	ldr	r3, [sp, #16]
    145a:	3301      	adds	r3, #1
    145c:	9304      	str	r3, [sp, #16]
    145e:	e002      	b.n	1466 <SEGGER_RTT_vprintf+0xde>
        default:  v = 0; break;
    1460:	2300      	movs	r3, #0
    1462:	9320      	str	r3, [sp, #128]	; 0x80
    1464:	bf00      	nop
        }
      } while (v);
    1466:	9b20      	ldr	r3, [sp, #128]	; 0x80
    1468:	2b00      	cmp	r3, #0
    146a:	d1b1      	bne.n	13d0 <SEGGER_RTT_vprintf+0x48>
      //
      // filter out field with
      //
      FieldWidth = 0u;
    146c:	2300      	movs	r3, #0
    146e:	931d      	str	r3, [sp, #116]	; 0x74
      do {
        c = *sFormat;
    1470:	9b04      	ldr	r3, [sp, #16]
    1472:	781b      	ldrb	r3, [r3, #0]
    1474:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
        if ((c < '0') || (c > '9')) {
    1478:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    147c:	2b2f      	cmp	r3, #47	; 0x2f
    147e:	d912      	bls.n	14a6 <SEGGER_RTT_vprintf+0x11e>
    1480:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    1484:	2b39      	cmp	r3, #57	; 0x39
    1486:	d80e      	bhi.n	14a6 <SEGGER_RTT_vprintf+0x11e>
          break;
        }
        sFormat++;
    1488:	9b04      	ldr	r3, [sp, #16]
    148a:	3301      	adds	r3, #1
    148c:	9304      	str	r3, [sp, #16]
        FieldWidth = (FieldWidth * 10u) + ((unsigned)c - '0');
    148e:	9a1d      	ldr	r2, [sp, #116]	; 0x74
    1490:	4613      	mov	r3, r2
    1492:	009b      	lsls	r3, r3, #2
    1494:	4413      	add	r3, r2
    1496:	005b      	lsls	r3, r3, #1
    1498:	461a      	mov	r2, r3
    149a:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    149e:	4413      	add	r3, r2
    14a0:	3b30      	subs	r3, #48	; 0x30
    14a2:	931d      	str	r3, [sp, #116]	; 0x74
        c = *sFormat;
    14a4:	e7e4      	b.n	1470 <SEGGER_RTT_vprintf+0xe8>
      } while (1);

      //
      // Filter out precision (number of digits to display)
      //
      NumDigits = 0u;
    14a6:	2300      	movs	r3, #0
    14a8:	931f      	str	r3, [sp, #124]	; 0x7c
      c = *sFormat;
    14aa:	9b04      	ldr	r3, [sp, #16]
    14ac:	781b      	ldrb	r3, [r3, #0]
    14ae:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
      if (c == '.') {
    14b2:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    14b6:	2b2e      	cmp	r3, #46	; 0x2e
    14b8:	d11d      	bne.n	14f6 <SEGGER_RTT_vprintf+0x16e>
        sFormat++;
    14ba:	9b04      	ldr	r3, [sp, #16]
    14bc:	3301      	adds	r3, #1
    14be:	9304      	str	r3, [sp, #16]
        do {
          c = *sFormat;
    14c0:	9b04      	ldr	r3, [sp, #16]
    14c2:	781b      	ldrb	r3, [r3, #0]
    14c4:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
          if ((c < '0') || (c > '9')) {
    14c8:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    14cc:	2b2f      	cmp	r3, #47	; 0x2f
    14ce:	d912      	bls.n	14f6 <SEGGER_RTT_vprintf+0x16e>
    14d0:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    14d4:	2b39      	cmp	r3, #57	; 0x39
    14d6:	d80e      	bhi.n	14f6 <SEGGER_RTT_vprintf+0x16e>
            break;
          }
          sFormat++;
    14d8:	9b04      	ldr	r3, [sp, #16]
    14da:	3301      	adds	r3, #1
    14dc:	9304      	str	r3, [sp, #16]
          NumDigits = NumDigits * 10u + ((unsigned)c - '0');
    14de:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
    14e0:	4613      	mov	r3, r2
    14e2:	009b      	lsls	r3, r3, #2
    14e4:	4413      	add	r3, r2
    14e6:	005b      	lsls	r3, r3, #1
    14e8:	461a      	mov	r2, r3
    14ea:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    14ee:	4413      	add	r3, r2
    14f0:	3b30      	subs	r3, #48	; 0x30
    14f2:	931f      	str	r3, [sp, #124]	; 0x7c
          c = *sFormat;
    14f4:	e7e4      	b.n	14c0 <SEGGER_RTT_vprintf+0x138>
        } while (1);
      }
      //
      // Filter out length modifier
      //
      c = *sFormat;
    14f6:	9b04      	ldr	r3, [sp, #16]
    14f8:	781b      	ldrb	r3, [r3, #0]
    14fa:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
      do {
        if ((c == 'l') || (c == 'h')) {
    14fe:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    1502:	2b6c      	cmp	r3, #108	; 0x6c
    1504:	d003      	beq.n	150e <SEGGER_RTT_vprintf+0x186>
    1506:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    150a:	2b68      	cmp	r3, #104	; 0x68
    150c:	d107      	bne.n	151e <SEGGER_RTT_vprintf+0x196>
          sFormat++;
    150e:	9b04      	ldr	r3, [sp, #16]
    1510:	3301      	adds	r3, #1
    1512:	9304      	str	r3, [sp, #16]
          c = *sFormat;
    1514:	9b04      	ldr	r3, [sp, #16]
    1516:	781b      	ldrb	r3, [r3, #0]
    1518:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
        if ((c == 'l') || (c == 'h')) {
    151c:	e7ef      	b.n	14fe <SEGGER_RTT_vprintf+0x176>
        }
      } while (1);
      //
      // Handle specifiers
      //
      switch (c) {
    151e:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    1522:	2b25      	cmp	r3, #37	; 0x25
    1524:	f000 80d0 	beq.w	16c8 <SEGGER_RTT_vprintf+0x340>
    1528:	2b25      	cmp	r3, #37	; 0x25
    152a:	f2c0 80d3 	blt.w	16d4 <SEGGER_RTT_vprintf+0x34c>
    152e:	2b78      	cmp	r3, #120	; 0x78
    1530:	f300 80d0 	bgt.w	16d4 <SEGGER_RTT_vprintf+0x34c>
    1534:	2b58      	cmp	r3, #88	; 0x58
    1536:	f2c0 80cd 	blt.w	16d4 <SEGGER_RTT_vprintf+0x34c>
    153a:	3b58      	subs	r3, #88	; 0x58
    153c:	2b20      	cmp	r3, #32
    153e:	f200 80c9 	bhi.w	16d4 <SEGGER_RTT_vprintf+0x34c>
    1542:	a201      	add	r2, pc, #4	; (adr r2, 1548 <SEGGER_RTT_vprintf+0x1c0>)
    1544:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    1548:	00001639 	.word	0x00001639
    154c:	000016d5 	.word	0x000016d5
    1550:	000016d5 	.word	0x000016d5
    1554:	000016d5 	.word	0x000016d5
    1558:	000016d5 	.word	0x000016d5
    155c:	000016d5 	.word	0x000016d5
    1560:	000016d5 	.word	0x000016d5
    1564:	000016d5 	.word	0x000016d5
    1568:	000016d5 	.word	0x000016d5
    156c:	000016d5 	.word	0x000016d5
    1570:	000016d5 	.word	0x000016d5
    1574:	000015cd 	.word	0x000015cd
    1578:	000015f1 	.word	0x000015f1
    157c:	000016d5 	.word	0x000016d5
    1580:	000016d5 	.word	0x000016d5
    1584:	000016d5 	.word	0x000016d5
    1588:	000016d5 	.word	0x000016d5
    158c:	000016d5 	.word	0x000016d5
    1590:	000016d5 	.word	0x000016d5
    1594:	000016d5 	.word	0x000016d5
    1598:	000016d5 	.word	0x000016d5
    159c:	000016d5 	.word	0x000016d5
    15a0:	000016d5 	.word	0x000016d5
    15a4:	000016d5 	.word	0x000016d5
    15a8:	000016a5 	.word	0x000016a5
    15ac:	000016d5 	.word	0x000016d5
    15b0:	000016d5 	.word	0x000016d5
    15b4:	0000165d 	.word	0x0000165d
    15b8:	000016d5 	.word	0x000016d5
    15bc:	00001615 	.word	0x00001615
    15c0:	000016d5 	.word	0x000016d5
    15c4:	000016d5 	.word	0x000016d5
    15c8:	00001639 	.word	0x00001639
      case 'c': {
        char c0;
        v = va_arg(*pParamList, int);
    15cc:	9b03      	ldr	r3, [sp, #12]
    15ce:	681b      	ldr	r3, [r3, #0]
    15d0:	1d19      	adds	r1, r3, #4
    15d2:	9a03      	ldr	r2, [sp, #12]
    15d4:	6011      	str	r1, [r2, #0]
    15d6:	681b      	ldr	r3, [r3, #0]
    15d8:	9320      	str	r3, [sp, #128]	; 0x80
        c0 = (char)v;
    15da:	9b20      	ldr	r3, [sp, #128]	; 0x80
    15dc:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
        _StoreChar(&BufferDesc, c0);
    15e0:	f89d 206f 	ldrb.w	r2, [sp, #111]	; 0x6f
    15e4:	ab16      	add	r3, sp, #88	; 0x58
    15e6:	4611      	mov	r1, r2
    15e8:	4618      	mov	r0, r3
    15ea:	f7ff fd3a 	bl	1062 <_StoreChar>
        break;
    15ee:	e072      	b.n	16d6 <SEGGER_RTT_vprintf+0x34e>
      }
      case 'd':
        v = va_arg(*pParamList, int);
    15f0:	9b03      	ldr	r3, [sp, #12]
    15f2:	681b      	ldr	r3, [r3, #0]
    15f4:	1d19      	adds	r1, r3, #4
    15f6:	9a03      	ldr	r2, [sp, #12]
    15f8:	6011      	str	r1, [r2, #0]
    15fa:	681b      	ldr	r3, [r3, #0]
    15fc:	9320      	str	r3, [sp, #128]	; 0x80
        _PrintInt(&BufferDesc, v, 10u, NumDigits, FieldWidth, FormatFlags);
    15fe:	a816      	add	r0, sp, #88	; 0x58
    1600:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    1602:	9301      	str	r3, [sp, #4]
    1604:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    1606:	9300      	str	r3, [sp, #0]
    1608:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    160a:	220a      	movs	r2, #10
    160c:	9920      	ldr	r1, [sp, #128]	; 0x80
    160e:	f7ff fe15 	bl	123c <_PrintInt>
        break;
    1612:	e060      	b.n	16d6 <SEGGER_RTT_vprintf+0x34e>
      case 'u':
        v = va_arg(*pParamList, int);
    1614:	9b03      	ldr	r3, [sp, #12]
    1616:	681b      	ldr	r3, [r3, #0]
    1618:	1d19      	adds	r1, r3, #4
    161a:	9a03      	ldr	r2, [sp, #12]
    161c:	6011      	str	r1, [r2, #0]
    161e:	681b      	ldr	r3, [r3, #0]
    1620:	9320      	str	r3, [sp, #128]	; 0x80
        _PrintUnsigned(&BufferDesc, (unsigned)v, 10u, NumDigits, FieldWidth, FormatFlags);
    1622:	9920      	ldr	r1, [sp, #128]	; 0x80
    1624:	a816      	add	r0, sp, #88	; 0x58
    1626:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    1628:	9301      	str	r3, [sp, #4]
    162a:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    162c:	9300      	str	r3, [sp, #0]
    162e:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    1630:	220a      	movs	r2, #10
    1632:	f7ff fd55 	bl	10e0 <_PrintUnsigned>
        break;
    1636:	e04e      	b.n	16d6 <SEGGER_RTT_vprintf+0x34e>
      case 'x':
      case 'X':
        v = va_arg(*pParamList, int);
    1638:	9b03      	ldr	r3, [sp, #12]
    163a:	681b      	ldr	r3, [r3, #0]
    163c:	1d19      	adds	r1, r3, #4
    163e:	9a03      	ldr	r2, [sp, #12]
    1640:	6011      	str	r1, [r2, #0]
    1642:	681b      	ldr	r3, [r3, #0]
    1644:	9320      	str	r3, [sp, #128]	; 0x80
        _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, NumDigits, FieldWidth, FormatFlags);
    1646:	9920      	ldr	r1, [sp, #128]	; 0x80
    1648:	a816      	add	r0, sp, #88	; 0x58
    164a:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    164c:	9301      	str	r3, [sp, #4]
    164e:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    1650:	9300      	str	r3, [sp, #0]
    1652:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    1654:	2210      	movs	r2, #16
    1656:	f7ff fd43 	bl	10e0 <_PrintUnsigned>
        break;
    165a:	e03c      	b.n	16d6 <SEGGER_RTT_vprintf+0x34e>
      case 's':
        {
          const char * s = va_arg(*pParamList, const char *);
    165c:	9b03      	ldr	r3, [sp, #12]
    165e:	681b      	ldr	r3, [r3, #0]
    1660:	1d19      	adds	r1, r3, #4
    1662:	9a03      	ldr	r2, [sp, #12]
    1664:	6011      	str	r1, [r2, #0]
    1666:	681b      	ldr	r3, [r3, #0]
    1668:	931c      	str	r3, [sp, #112]	; 0x70
          if (s == NULL) {
    166a:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    166c:	2b00      	cmp	r3, #0
    166e:	d101      	bne.n	1674 <SEGGER_RTT_vprintf+0x2ec>
            s = "(NULL)";  // Print (NULL) instead of crashing or breaking, as it is more informative to the user.
    1670:	4b2c      	ldr	r3, [pc, #176]	; (1724 <SEGGER_RTT_vprintf+0x39c>)
    1672:	931c      	str	r3, [sp, #112]	; 0x70
          }
          do {
            c = *s;
    1674:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    1676:	781b      	ldrb	r3, [r3, #0]
    1678:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
            s++;
    167c:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    167e:	3301      	adds	r3, #1
    1680:	931c      	str	r3, [sp, #112]	; 0x70
            if (c == '\0') {
    1682:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    1686:	2b00      	cmp	r3, #0
    1688:	d00a      	beq.n	16a0 <SEGGER_RTT_vprintf+0x318>
              break;
            }
           _StoreChar(&BufferDesc, c);
    168a:	f89d 2087 	ldrb.w	r2, [sp, #135]	; 0x87
    168e:	ab16      	add	r3, sp, #88	; 0x58
    1690:	4611      	mov	r1, r2
    1692:	4618      	mov	r0, r3
    1694:	f7ff fce5 	bl	1062 <_StoreChar>
          } while (BufferDesc.ReturnValue >= 0);
    1698:	9b19      	ldr	r3, [sp, #100]	; 0x64
    169a:	2b00      	cmp	r3, #0
    169c:	daea      	bge.n	1674 <SEGGER_RTT_vprintf+0x2ec>
        }
        break;
    169e:	e01a      	b.n	16d6 <SEGGER_RTT_vprintf+0x34e>
              break;
    16a0:	bf00      	nop
        break;
    16a2:	e018      	b.n	16d6 <SEGGER_RTT_vprintf+0x34e>
      case 'p':
        v = va_arg(*pParamList, int);
    16a4:	9b03      	ldr	r3, [sp, #12]
    16a6:	681b      	ldr	r3, [r3, #0]
    16a8:	1d19      	adds	r1, r3, #4
    16aa:	9a03      	ldr	r2, [sp, #12]
    16ac:	6011      	str	r1, [r2, #0]
    16ae:	681b      	ldr	r3, [r3, #0]
    16b0:	9320      	str	r3, [sp, #128]	; 0x80
        _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, 8u, 8u, 0u);
    16b2:	9920      	ldr	r1, [sp, #128]	; 0x80
    16b4:	a816      	add	r0, sp, #88	; 0x58
    16b6:	2300      	movs	r3, #0
    16b8:	9301      	str	r3, [sp, #4]
    16ba:	2308      	movs	r3, #8
    16bc:	9300      	str	r3, [sp, #0]
    16be:	2308      	movs	r3, #8
    16c0:	2210      	movs	r2, #16
    16c2:	f7ff fd0d 	bl	10e0 <_PrintUnsigned>
        break;
    16c6:	e006      	b.n	16d6 <SEGGER_RTT_vprintf+0x34e>
      case '%':
        _StoreChar(&BufferDesc, '%');
    16c8:	ab16      	add	r3, sp, #88	; 0x58
    16ca:	2125      	movs	r1, #37	; 0x25
    16cc:	4618      	mov	r0, r3
    16ce:	f7ff fcc8 	bl	1062 <_StoreChar>
        break;
    16d2:	e000      	b.n	16d6 <SEGGER_RTT_vprintf+0x34e>
      default:
        break;
    16d4:	bf00      	nop
      }
      sFormat++;
    16d6:	9b04      	ldr	r3, [sp, #16]
    16d8:	3301      	adds	r3, #1
    16da:	9304      	str	r3, [sp, #16]
    16dc:	e006      	b.n	16ec <SEGGER_RTT_vprintf+0x364>
    } else {
      _StoreChar(&BufferDesc, c);
    16de:	f89d 2087 	ldrb.w	r2, [sp, #135]	; 0x87
    16e2:	ab16      	add	r3, sp, #88	; 0x58
    16e4:	4611      	mov	r1, r2
    16e6:	4618      	mov	r0, r3
    16e8:	f7ff fcbb 	bl	1062 <_StoreChar>
    }
  } while (BufferDesc.ReturnValue >= 0);
    16ec:	9b19      	ldr	r3, [sp, #100]	; 0x64
    16ee:	2b00      	cmp	r3, #0
    16f0:	f6bf ae59 	bge.w	13a6 <SEGGER_RTT_vprintf+0x1e>
    16f4:	e000      	b.n	16f8 <SEGGER_RTT_vprintf+0x370>
      break;
    16f6:	bf00      	nop

  if (BufferDesc.ReturnValue > 0) {
    16f8:	9b19      	ldr	r3, [sp, #100]	; 0x64
    16fa:	2b00      	cmp	r3, #0
    16fc:	dd0c      	ble.n	1718 <SEGGER_RTT_vprintf+0x390>
    //
    // Write remaining data, if any
    //
    if (BufferDesc.Cnt != 0u) {
    16fe:	9b18      	ldr	r3, [sp, #96]	; 0x60
    1700:	2b00      	cmp	r3, #0
    1702:	d005      	beq.n	1710 <SEGGER_RTT_vprintf+0x388>
      SEGGER_RTT_Write(BufferIndex, acBuffer, BufferDesc.Cnt);
    1704:	9a18      	ldr	r2, [sp, #96]	; 0x60
    1706:	ab06      	add	r3, sp, #24
    1708:	4619      	mov	r1, r3
    170a:	9805      	ldr	r0, [sp, #20]
    170c:	f7ff fc7e 	bl	100c <SEGGER_RTT_Write>
    }
    BufferDesc.ReturnValue += (int)BufferDesc.Cnt;
    1710:	9b19      	ldr	r3, [sp, #100]	; 0x64
    1712:	9a18      	ldr	r2, [sp, #96]	; 0x60
    1714:	4413      	add	r3, r2
    1716:	9319      	str	r3, [sp, #100]	; 0x64
  }
  return BufferDesc.ReturnValue;
    1718:	9b19      	ldr	r3, [sp, #100]	; 0x64
}
    171a:	4618      	mov	r0, r3
    171c:	b023      	add	sp, #140	; 0x8c
    171e:	f85d fb04 	ldr.w	pc, [sp], #4
    1722:	bf00      	nop
    1724:	00017f04 	.word	0x00017f04

00001728 <SEGGER_RTT_printf>:
*          u: Print the argument as an unsigned integer
*          x: Print the argument as an hexadecimal integer
*          s: Print the string pointed to by the argument
*          p: Print the argument as an 8-digit hexadecimal integer. (Argument shall be a pointer to void.)
*/
int SEGGER_RTT_printf(unsigned BufferIndex, const char * sFormat, ...) {
    1728:	b40e      	push	{r1, r2, r3}
    172a:	b500      	push	{lr}
    172c:	b084      	sub	sp, #16
    172e:	9001      	str	r0, [sp, #4]
  int r;
  va_list ParamList;

  va_start(ParamList, sFormat);
    1730:	ab06      	add	r3, sp, #24
    1732:	9302      	str	r3, [sp, #8]
  r = SEGGER_RTT_vprintf(BufferIndex, sFormat, &ParamList);
    1734:	ab02      	add	r3, sp, #8
    1736:	461a      	mov	r2, r3
    1738:	9905      	ldr	r1, [sp, #20]
    173a:	9801      	ldr	r0, [sp, #4]
    173c:	f7ff fe24 	bl	1388 <SEGGER_RTT_vprintf>
    1740:	9003      	str	r0, [sp, #12]
  va_end(ParamList);
  return r;
    1742:	9b03      	ldr	r3, [sp, #12]
}
    1744:	4618      	mov	r0, r3
    1746:	b004      	add	sp, #16
    1748:	f85d eb04 	ldr.w	lr, [sp], #4
    174c:	b003      	add	sp, #12
    174e:	4770      	bx	lr

00001750 <MCU_clocks>:
 *  -SIRCDIV1_CLK -->8 Mhz
 *  -SIRCDIV2_CLK -->8 Mhz
 *  -SOSCDIV1_CLK  -->Disabled
 *  -SOSCDIV2_CLK  -->Disabled
 */
void MCU_clocks( void ) {
    1750:	b508      	push	{r3, lr}
    /*Init Mcu module, including internal PLL, reference to Mcu Config structure can 
    be found at Mcu_PBcfg.h and PLL defines at Mcu_Cfg.h*/
    Mcu_Init( &Mcu_Config );//Initializing MCU driver
    1752:	4805      	ldr	r0, [pc, #20]	; (1768 <MCU_clocks+0x18>)
    1754:	f004 fa38 	bl	5bc8 <Mcu_Init>
    Mcu_SetMode( Run_mode );//MCU on run mode.
    1758:	2000      	movs	r0, #0
    175a:	f004 fae9 	bl	5d30 <Mcu_SetMode>
    Mcu_InitClock( Clocks_conf_0 );//Executing clock configurations established in container.
    175e:	2000      	movs	r0, #0
    1760:	f004 fab0 	bl	5cc4 <Mcu_InitClock>

    //Configuring Pll clock.
    /*while ( Mcu_GetPllStatus() != MCU_PLL_LOCKED );//Waiting until PLL is locked.
    Mcu_DistributePllClock();//Executing pll clock configuration established in container.*/
}
    1764:	bf00      	nop
    1766:	bd08      	pop	{r3, pc}
    1768:	00019440 	.word	0x00019440

0000176c <EcuM_Init>:
/**
 * @brief This function initialices the microcontroller and the peripherals
 * 
 * 
 */
void EcuM_Init( void ) {   
    176c:	b508      	push	{r3, lr}
    MCU_clocks();
    176e:	f7ff ffef 	bl	1750 <MCU_clocks>
    OsIf_Init( NULL_PTR );  //Init Osif timer.
    1772:	2000      	movs	r0, #0
    1774:	f000 fbd1 	bl	1f1a <OsIf_Init>
    Platform_Init( NULL_PTR );  //Init platform driver and configuration.
    1778:	2000      	movs	r0, #0
    177a:	f000 fa71 	bl	1c60 <Platform_Init>
    Port_Init( &Port_Config );  //Init port driver and configuration.
    177e:	4807      	ldr	r0, [pc, #28]	; (179c <EcuM_Init+0x30>)
    1780:	f004 feba 	bl	64f8 <Port_Init>
    Spi_Init( &Spi_Config );    //Init spi driver and configuration.
    1784:	4806      	ldr	r0, [pc, #24]	; (17a0 <EcuM_Init+0x34>)
    1786:	f008 f8b5 	bl	98f4 <Spi_Init>
    Can_43_FLEXCAN_Init( &Can_43_FLEXCAN_Config );  //Init FlexCan driver
    178a:	4806      	ldr	r0, [pc, #24]	; (17a4 <EcuM_Init+0x38>)
    178c:	f008 fdbc 	bl	a308 <Can_43_FLEXCAN_Init>
    CanIf_Init( &CanIf_Config );    //Init CanIf driver.
    1790:	4805      	ldr	r0, [pc, #20]	; (17a8 <EcuM_Init+0x3c>)
    1792:	f015 fbd9 	bl	16f48 <CanIf_Init>
}
    1796:	bf00      	nop
    1798:	bd08      	pop	{r3, pc}
    179a:	bf00      	nop
    179c:	00019aa8 	.word	0x00019aa8
    17a0:	00019ba8 	.word	0x00019ba8
    17a4:	00018f04 	.word	0x00018f04
    17a8:	00018ce0 	.word	0x00018ce0

000017ac <Delay>:
/**
 * @brief This function is a delay in ms using the osif timer.
 * 
 * @param ms Delay in ms.
 */
void Delay( uint32 ms ) {
    17ac:	b500      	push	{lr}
    17ae:	b087      	sub	sp, #28
    17b0:	9001      	str	r0, [sp, #4]
    uint32 Timeout = OsIf_MicrosToTicks( ms * 1000u, OSIF_COUNTER_SYSTEM );
    17b2:	9b01      	ldr	r3, [sp, #4]
    17b4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    17b8:	fb02 f303 	mul.w	r3, r2, r3
    17bc:	2101      	movs	r1, #1
    17be:	4618      	mov	r0, r3
    17c0:	f000 fc00 	bl	1fc4 <OsIf_MicrosToTicks>
    17c4:	9004      	str	r0, [sp, #16]
    uint32 SeedTick = OsIf_GetCounter( OSIF_COUNTER_SYSTEM );
    17c6:	2001      	movs	r0, #1
    17c8:	f000 fbb0 	bl	1f2c <OsIf_GetCounter>
    17cc:	4603      	mov	r3, r0
    17ce:	9303      	str	r3, [sp, #12]
    uint32 ElapsedTime = 0u;
    17d0:	2300      	movs	r3, #0
    17d2:	9305      	str	r3, [sp, #20]

    do {
        ElapsedTime += OsIf_GetElapsed( &SeedTick, OSIF_COUNTER_SYSTEM );
    17d4:	ab03      	add	r3, sp, #12
    17d6:	2101      	movs	r1, #1
    17d8:	4618      	mov	r0, r3
    17da:	f000 fbc0 	bl	1f5e <OsIf_GetElapsed>
    17de:	4602      	mov	r2, r0
    17e0:	9b05      	ldr	r3, [sp, #20]
    17e2:	4413      	add	r3, r2
    17e4:	9305      	str	r3, [sp, #20]
    } while( ElapsedTime < Timeout );
    17e6:	9a05      	ldr	r2, [sp, #20]
    17e8:	9b04      	ldr	r3, [sp, #16]
    17ea:	429a      	cmp	r2, r3
    17ec:	d3f2      	bcc.n	17d4 <Delay+0x28>
    17ee:	bf00      	nop
    17f0:	bf00      	nop
    17f2:	b007      	add	sp, #28
    17f4:	f85d fb04 	ldr.w	pc, [sp], #4

000017f8 <memcpy>:
    17f8:	440a      	add	r2, r1
    17fa:	4291      	cmp	r1, r2
    17fc:	f100 33ff 	add.w	r3, r0, #4294967295
    1800:	d100      	bne.n	1804 <memcpy+0xc>
    1802:	4770      	bx	lr
    1804:	b510      	push	{r4, lr}
    1806:	f811 4b01 	ldrb.w	r4, [r1], #1
    180a:	f803 4f01 	strb.w	r4, [r3, #1]!
    180e:	4291      	cmp	r1, r2
    1810:	d1f9      	bne.n	1806 <memcpy+0xe>
    1812:	bd10      	pop	{r4, pc}

00001814 <memset>:
    1814:	4402      	add	r2, r0
    1816:	4603      	mov	r3, r0
    1818:	4293      	cmp	r3, r2
    181a:	d100      	bne.n	181e <memset+0xa>
    181c:	4770      	bx	lr
    181e:	f803 1b01 	strb.w	r1, [r3], #1
    1822:	e7f9      	b.n	1818 <memset+0x4>

00001824 <IntCtrl_Ip_InstallHandlerPrivileged>:
#endif

void IntCtrl_Ip_InstallHandlerPrivileged(IRQn_Type eIrqNumber,
                               const IntCtrl_Ip_IrqHandlerType pfNewHandler,
                               IntCtrl_Ip_IrqHandlerType* const pfOldHandler)
{
    1824:	b500      	push	{lr}
    1826:	b087      	sub	sp, #28
    1828:	9003      	str	r0, [sp, #12]
    182a:	9102      	str	r1, [sp, #8]
    182c:	9201      	str	r2, [sp, #4]
#if (INT_CTRL_IP_DEV_ERROR_DETECT == STD_ON)
    /* Check IRQ number - dev_irqNumber is used to avoid compiler warning */
    sint32 dev_irqNumber = (sint32)eIrqNumber;
    182e:	9b03      	ldr	r3, [sp, #12]
    1830:	9305      	str	r3, [sp, #20]
    DevAssert((sint32)INT_CTRL_IP_IRQ_MIN <= dev_irqNumber);
    1832:	9b05      	ldr	r3, [sp, #20]
    1834:	43db      	mvns	r3, r3
    1836:	0fdb      	lsrs	r3, r3, #31
    1838:	b2db      	uxtb	r3, r3
    183a:	4618      	mov	r0, r3
    183c:	f7ff f89e 	bl	97c <DevAssert>
    DevAssert(dev_irqNumber <= (sint32)INT_CTRL_IP_IRQ_MAX);
    1840:	9b05      	ldr	r3, [sp, #20]
    1842:	2b7a      	cmp	r3, #122	; 0x7a
    1844:	bfd4      	ite	le
    1846:	2301      	movle	r3, #1
    1848:	2300      	movgt	r3, #0
    184a:	b2db      	uxtb	r3, r3
    184c:	4618      	mov	r0, r3
    184e:	f7ff f895 	bl	97c <DevAssert>
#if (MCAL_PLATFORM_ARM == MCAL_ARM_MARCH)
#if defined(S32K3XX) || defined(SAF85) || defined(S32R41)
    DevAssert(S32_SCB->VTOR >= (uint32)__RAM_INTERRUPT_START);
#else
    DevAssert(S32_SCB->VTOR >= (uint32)__INT_SRAM_START);
    1852:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    1856:	f8d3 3d08 	ldr.w	r3, [r3, #3336]	; 0xd08
    185a:	4a14      	ldr	r2, [pc, #80]	; (18ac <IntCtrl_Ip_InstallHandlerPrivileged+0x88>)
    185c:	4293      	cmp	r3, r2
    185e:	bf2c      	ite	cs
    1860:	2301      	movcs	r3, #1
    1862:	2300      	movcc	r3, #0
    1864:	b2db      	uxtb	r3, r3
    1866:	4618      	mov	r0, r3
    1868:	f7ff f888 	bl	97c <DevAssert>

    /* Set handler into vector table */
    pVectorRam[((sint32)eIrqNumber)] = pfNewHandler;
    OsIf_ResumeAllInterrupts();
#else
    IntCtrl_Ip_IrqHandlerType *pVectorRam = (IntCtrl_Ip_IrqHandlerType *)S32_SCB->VTOR;
    186c:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    1870:	f8d3 3d08 	ldr.w	r3, [r3, #3336]	; 0xd08
    1874:	9304      	str	r3, [sp, #16]

    /* Save the former handler pointer */
    if (pfOldHandler != NULL_PTR)
    1876:	9b01      	ldr	r3, [sp, #4]
    1878:	2b00      	cmp	r3, #0
    187a:	d007      	beq.n	188c <IntCtrl_Ip_InstallHandlerPrivileged+0x68>
    {
        *pfOldHandler = (IntCtrl_Ip_IrqHandlerType)pVectorRam[((sint32)eIrqNumber) + 16];
    187c:	9b03      	ldr	r3, [sp, #12]
    187e:	3310      	adds	r3, #16
    1880:	009b      	lsls	r3, r3, #2
    1882:	9a04      	ldr	r2, [sp, #16]
    1884:	4413      	add	r3, r2
    1886:	681a      	ldr	r2, [r3, #0]
    1888:	9b01      	ldr	r3, [sp, #4]
    188a:	601a      	str	r2, [r3, #0]
    }

    /* Set handler into vector table */
    pVectorRam[((sint32)eIrqNumber) + 16] = pfNewHandler;
    188c:	9b03      	ldr	r3, [sp, #12]
    188e:	3310      	adds	r3, #16
    1890:	009b      	lsls	r3, r3, #2
    1892:	9a04      	ldr	r2, [sp, #16]
    1894:	4413      	add	r3, r2
    1896:	9a02      	ldr	r2, [sp, #8]
    1898:	601a      	str	r2, [r3, #0]
    S32_SCB->ICIALLU = 0UL;
#endif
    
#endif /* (INT_CTRL_IP_CORTEXR == STD_ON) || (INT_CTRL_IP_CORTEXA == STD_ON) */
/*LDRA_NOANALYSIS*/
    MCAL_INSTRUCTION_SYNC_BARRIER();
    189a:	f3bf 8f6f 	isb	sy
    MCAL_DATA_SYNC_BARRIER();
    189e:	f3bf 8f4f 	dsb	sy
/*LDRA_ANALYSIS*/    
}
    18a2:	bf00      	nop
    18a4:	b007      	add	sp, #28
    18a6:	f85d fb04 	ldr.w	pc, [sp], #4
    18aa:	bf00      	nop
    18ac:	1fff8000 	.word	0x1fff8000

000018b0 <IntCtrl_Ip_EnableIrqPrivileged>:

void IntCtrl_Ip_EnableIrqPrivileged(IRQn_Type eIrqNumber)
{
    18b0:	b500      	push	{lr}
    18b2:	b083      	sub	sp, #12
    18b4:	9001      	str	r0, [sp, #4]

#if (INT_CTRL_IP_DEV_ERROR_DETECT == STD_ON)
    /* Check IRQ number - dev_irqNumber is used to avoid compiler warning */
    DevAssert(0 <= (sint32)eIrqNumber);
    18b6:	9b01      	ldr	r3, [sp, #4]
    18b8:	43db      	mvns	r3, r3
    18ba:	0fdb      	lsrs	r3, r3, #31
    18bc:	b2db      	uxtb	r3, r3
    18be:	4618      	mov	r0, r3
    18c0:	f7ff f85c 	bl	97c <DevAssert>
    DevAssert((sint32)eIrqNumber <= (sint32)INT_CTRL_IP_IRQ_MAX);
    18c4:	9b01      	ldr	r3, [sp, #4]
    18c6:	2b7a      	cmp	r3, #122	; 0x7a
    18c8:	bfd4      	ite	le
    18ca:	2301      	movle	r3, #1
    18cc:	2300      	movgt	r3, #0
    18ce:	b2db      	uxtb	r3, r3
    18d0:	4618      	mov	r0, r3
    18d2:	f7ff f853 	bl	97c <DevAssert>
    {
        S32_GICD->GICD_ISENABLER[((uint32)(eIrqNumber) >> 5U) - 1U] = (uint32)(1UL << ((uint32)(eIrqNumber) & (uint32)0x1FU));
    }
#endif
#else
    S32_NVIC->ISER[(uint32)(eIrqNumber) >> 5U] = (uint32)(1UL << ((uint32)(eIrqNumber) & (uint32)0x1FU));
    18d6:	9b01      	ldr	r3, [sp, #4]
    18d8:	f003 021f 	and.w	r2, r3, #31
    18dc:	4905      	ldr	r1, [pc, #20]	; (18f4 <IntCtrl_Ip_EnableIrqPrivileged+0x44>)
    18de:	9b01      	ldr	r3, [sp, #4]
    18e0:	095b      	lsrs	r3, r3, #5
    18e2:	2001      	movs	r0, #1
    18e4:	fa00 f202 	lsl.w	r2, r0, r2
    18e8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif
}
    18ec:	bf00      	nop
    18ee:	b003      	add	sp, #12
    18f0:	f85d fb04 	ldr.w	pc, [sp], #4
    18f4:	e000e100 	.word	0xe000e100

000018f8 <IntCtrl_Ip_DisableIrqPrivileged>:

void IntCtrl_Ip_DisableIrqPrivileged(IRQn_Type eIrqNumber)
{
    18f8:	b500      	push	{lr}
    18fa:	b083      	sub	sp, #12
    18fc:	9001      	str	r0, [sp, #4]
#if (INT_CTRL_IP_DEV_ERROR_DETECT == STD_ON)
    /* Check IRQ number - dev_irqNumber is used to avoid compiler warning */
    DevAssert(0 <= (sint32)eIrqNumber);
    18fe:	9b01      	ldr	r3, [sp, #4]
    1900:	43db      	mvns	r3, r3
    1902:	0fdb      	lsrs	r3, r3, #31
    1904:	b2db      	uxtb	r3, r3
    1906:	4618      	mov	r0, r3
    1908:	f7ff f838 	bl	97c <DevAssert>
    DevAssert((sint32)eIrqNumber <= (sint32)INT_CTRL_IP_IRQ_MAX);
    190c:	9b01      	ldr	r3, [sp, #4]
    190e:	2b7a      	cmp	r3, #122	; 0x7a
    1910:	bfd4      	ite	le
    1912:	2301      	movle	r3, #1
    1914:	2300      	movgt	r3, #0
    1916:	b2db      	uxtb	r3, r3
    1918:	4618      	mov	r0, r3
    191a:	f7ff f82f 	bl	97c <DevAssert>
    {
        S32_GICD->GICD_ICENABLER[((uint32)(eIrqNumber) >> 5U) - 1U] = (uint32)(1UL << ((uint32)(eIrqNumber) & (uint32)0x1FU));
    }
#endif
#else
    S32_NVIC->ICER[(uint32)(eIrqNumber) >> 5U] = (uint32)(1UL << ((uint32)(eIrqNumber) & (uint32)0x1FU));
    191e:	9b01      	ldr	r3, [sp, #4]
    1920:	f003 021f 	and.w	r2, r3, #31
    1924:	4906      	ldr	r1, [pc, #24]	; (1940 <IntCtrl_Ip_DisableIrqPrivileged+0x48>)
    1926:	9b01      	ldr	r3, [sp, #4]
    1928:	095b      	lsrs	r3, r3, #5
    192a:	2001      	movs	r0, #1
    192c:	fa00 f202 	lsl.w	r2, r0, r2
    1930:	3320      	adds	r3, #32
    1932:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif
}
    1936:	bf00      	nop
    1938:	b003      	add	sp, #12
    193a:	f85d fb04 	ldr.w	pc, [sp], #4
    193e:	bf00      	nop
    1940:	e000e100 	.word	0xe000e100

00001944 <IntCtrl_Ip_SetPriorityPrivileged>:

void IntCtrl_Ip_SetPriorityPrivileged(IRQn_Type eIrqNumber, uint8 u8Priority)
{
    1944:	b500      	push	{lr}
    1946:	b085      	sub	sp, #20
    1948:	9001      	str	r0, [sp, #4]
    194a:	460b      	mov	r3, r1
    194c:	f88d 3003 	strb.w	r3, [sp, #3]

#if (INT_CTRL_IP_DEV_ERROR_DETECT == STD_ON)

    /* Check IRQ number and priority - dev_irqNumber is used to avoid compiler warning */
    DevAssert((sint32)INT_CTRL_IP_IRQ_MIN <= (sint32)eIrqNumber);
    1950:	9b01      	ldr	r3, [sp, #4]
    1952:	43db      	mvns	r3, r3
    1954:	0fdb      	lsrs	r3, r3, #31
    1956:	b2db      	uxtb	r3, r3
    1958:	4618      	mov	r0, r3
    195a:	f7ff f80f 	bl	97c <DevAssert>
    DevAssert((sint32)eIrqNumber <= (sint32)INT_CTRL_IP_IRQ_MAX);
    195e:	9b01      	ldr	r3, [sp, #4]
    1960:	2b7a      	cmp	r3, #122	; 0x7a
    1962:	bfd4      	ite	le
    1964:	2301      	movle	r3, #1
    1966:	2300      	movgt	r3, #0
    1968:	b2db      	uxtb	r3, r3
    196a:	4618      	mov	r0, r3
    196c:	f7ff f806 	bl	97c <DevAssert>
#if (INT_CTRL_IP_CORTEXM == STD_ON)
    DevAssert(u8Priority < (uint8)(1U << INT_CTRL_IP_NVIC_PRIO_BITS));
    1970:	f89d 3003 	ldrb.w	r3, [sp, #3]
    1974:	2b0f      	cmp	r3, #15
    1976:	bf94      	ite	ls
    1978:	2301      	movls	r3, #1
    197a:	2300      	movhi	r3, #0
    197c:	b2db      	uxtb	r3, r3
    197e:	4618      	mov	r0, r3
    1980:	f7fe fffc 	bl	97c <DevAssert>
#endif

#endif /* (INT_CTRL_IP_DEV_ERROR_DETECT == STD_ON) */

#if (INT_CTRL_IP_CORTEXM == STD_ON)
    uint8 shift = (uint8) (8U - INT_CTRL_IP_NVIC_PRIO_BITS);
    1984:	2304      	movs	r3, #4
    1986:	f88d 300f 	strb.w	r3, [sp, #15]
    #if (INT_CTRL_IP_CORTEXM0PLUS == STD_OFF)
        /* Set Priority for device specific Interrupts */
        S32_NVIC->IP[(uint32)(eIrqNumber)] = (uint8)((((uint32)u8Priority) << shift) & 0xFFUL);
    198a:	f89d 2003 	ldrb.w	r2, [sp, #3]
    198e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    1992:	fa02 f103 	lsl.w	r1, r2, r3
    1996:	4a05      	ldr	r2, [pc, #20]	; (19ac <IntCtrl_Ip_SetPriorityPrivileged+0x68>)
    1998:	9b01      	ldr	r3, [sp, #4]
    199a:	b2c9      	uxtb	r1, r1
    199c:	4413      	add	r3, r2
    199e:	460a      	mov	r2, r1
    19a0:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
            IP_GIC500->GICD.IPRIORITYR[iprVectorId] &= ~(0xFFUL << priByteShift);
            IP_GIC500->GICD.IPRIORITYR[iprVectorId] |= ((uint32)(((((uint32)u8Priority) << shift_gic)) & 0xFFUL)) << priByteShift;
        }
    #endif
#endif
}
    19a4:	bf00      	nop
    19a6:	b005      	add	sp, #20
    19a8:	f85d fb04 	ldr.w	pc, [sp], #4
    19ac:	e000e100 	.word	0xe000e100

000019b0 <IntCtrl_Ip_GetPriorityPrivileged>:

uint8 IntCtrl_Ip_GetPriorityPrivileged(IRQn_Type eIrqNumber)
{
    19b0:	b500      	push	{lr}
    19b2:	b085      	sub	sp, #20
    19b4:	9001      	str	r0, [sp, #4]
#if (INT_CTRL_IP_DEV_ERROR_DETECT == STD_ON)

    /* Check IRQ number */
    DevAssert(INT_CTRL_IP_IRQ_MIN <= eIrqNumber);
    19b6:	9b01      	ldr	r3, [sp, #4]
    19b8:	43db      	mvns	r3, r3
    19ba:	0fdb      	lsrs	r3, r3, #31
    19bc:	b2db      	uxtb	r3, r3
    19be:	4618      	mov	r0, r3
    19c0:	f7fe ffdc 	bl	97c <DevAssert>
    DevAssert((sint32)eIrqNumber <= (sint32)INT_CTRL_IP_IRQ_MAX);
    19c4:	9b01      	ldr	r3, [sp, #4]
    19c6:	2b7a      	cmp	r3, #122	; 0x7a
    19c8:	bfd4      	ite	le
    19ca:	2301      	movle	r3, #1
    19cc:	2300      	movgt	r3, #0
    19ce:	b2db      	uxtb	r3, r3
    19d0:	4618      	mov	r0, r3
    19d2:	f7fe ffd3 	bl	97c <DevAssert>

    uint8 priority;


#if (INT_CTRL_IP_CORTEXM == STD_ON)
    uint8 shift = (uint8)(8U - INT_CTRL_IP_NVIC_PRIO_BITS);
    19d6:	2304      	movs	r3, #4
    19d8:	f88d 300f 	strb.w	r3, [sp, #15]
    #if (INT_CTRL_IP_CORTEXM0PLUS == STD_OFF)
        /* Get Priority for device specific Interrupts  */
        priority = (uint8)(S32_NVIC->IP[(uint32)(eIrqNumber)] >> shift);
    19dc:	4a09      	ldr	r2, [pc, #36]	; (1a04 <IntCtrl_Ip_GetPriorityPrivileged+0x54>)
    19de:	9b01      	ldr	r3, [sp, #4]
    19e0:	4413      	add	r3, r2
    19e2:	f893 3300 	ldrb.w	r3, [r3, #768]	; 0x300
    19e6:	b2db      	uxtb	r3, r3
    19e8:	461a      	mov	r2, r3
    19ea:	f89d 300f 	ldrb.w	r3, [sp, #15]
    19ee:	fa42 f303 	asr.w	r3, r2, r3
    19f2:	f88d 300e 	strb.w	r3, [sp, #14]
            uint8 priByteShift = (uint8)((((uint8)(eIrqNumber)) & 0x3U) << 3U);
            priority = ((uint8)(IP_GIC500->GICD.IPRIORITYR[iprVectorId] >> priByteShift)) >> shift_gic;
        }
    #endif
#endif
    return priority;
    19f6:	f89d 300e 	ldrb.w	r3, [sp, #14]
}
    19fa:	4618      	mov	r0, r3
    19fc:	b005      	add	sp, #20
    19fe:	f85d fb04 	ldr.w	pc, [sp], #4
    1a02:	bf00      	nop
    1a04:	e000e100 	.word	0xe000e100

00001a08 <IntCtrl_Ip_ClearPendingPrivileged>:

void IntCtrl_Ip_ClearPendingPrivileged(IRQn_Type eIrqNumber)
{
    1a08:	b500      	push	{lr}
    1a0a:	b083      	sub	sp, #12
    1a0c:	9001      	str	r0, [sp, #4]

#if (INT_CTRL_IP_DEV_ERROR_DETECT == STD_ON)
    /* Check IRQ number */
    DevAssert(0 <= (sint32)eIrqNumber);
    1a0e:	9b01      	ldr	r3, [sp, #4]
    1a10:	43db      	mvns	r3, r3
    1a12:	0fdb      	lsrs	r3, r3, #31
    1a14:	b2db      	uxtb	r3, r3
    1a16:	4618      	mov	r0, r3
    1a18:	f7fe ffb0 	bl	97c <DevAssert>
    DevAssert((sint32)eIrqNumber <= (sint32)INT_CTRL_IP_IRQ_MAX);
    1a1c:	9b01      	ldr	r3, [sp, #4]
    1a1e:	2b7a      	cmp	r3, #122	; 0x7a
    1a20:	bfd4      	ite	le
    1a22:	2301      	movle	r3, #1
    1a24:	2300      	movgt	r3, #0
    1a26:	b2db      	uxtb	r3, r3
    1a28:	4618      	mov	r0, r3
    1a2a:	f7fe ffa7 	bl	97c <DevAssert>
    }
#endif

#else
    /* Clear Pending Interrupt */
    S32_NVIC->ICPR[(uint32)(eIrqNumber) >> 5U] = (uint32)(1UL << ((uint32)(eIrqNumber) & (uint32)0x1FU));
    1a2e:	9b01      	ldr	r3, [sp, #4]
    1a30:	f003 021f 	and.w	r2, r3, #31
    1a34:	4906      	ldr	r1, [pc, #24]	; (1a50 <IntCtrl_Ip_ClearPendingPrivileged+0x48>)
    1a36:	9b01      	ldr	r3, [sp, #4]
    1a38:	095b      	lsrs	r3, r3, #5
    1a3a:	2001      	movs	r0, #1
    1a3c:	fa00 f202 	lsl.w	r2, r0, r2
    1a40:	3360      	adds	r3, #96	; 0x60
    1a42:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif

}
    1a46:	bf00      	nop
    1a48:	b003      	add	sp, #12
    1a4a:	f85d fb04 	ldr.w	pc, [sp], #4
    1a4e:	bf00      	nop
    1a50:	e000e100 	.word	0xe000e100

00001a54 <IntCtrl_Ip_Init>:
 * @internal
 * @brief         Initializes the configured interrupts at interrupt controller level.
 * @implements    IntCtrl_Ip_Init_Activity
 */
IntCtrl_Ip_StatusType IntCtrl_Ip_Init(const IntCtrl_Ip_CtrlConfigType *pIntCtrlCtrlConfig)
{
    1a54:	b500      	push	{lr}
    1a56:	b085      	sub	sp, #20
    1a58:	9001      	str	r0, [sp, #4]
#if (INT_CTRL_IP_ENABLE_VTOR_CONFIG == STD_ON)
    S32_SCB->VTOR = pIntCtrlCtrlConfig->u32VectorTableAddress;
#endif

#if (INT_CTRL_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(pIntCtrlCtrlConfig != NULL_PTR);
    1a5a:	9b01      	ldr	r3, [sp, #4]
    1a5c:	2b00      	cmp	r3, #0
    1a5e:	bf14      	ite	ne
    1a60:	2301      	movne	r3, #1
    1a62:	2300      	moveq	r3, #0
    1a64:	b2db      	uxtb	r3, r3
    1a66:	4618      	mov	r0, r3
    1a68:	f7fe ff88 	bl	97c <DevAssert>
    DevAssert(pIntCtrlCtrlConfig->u32ConfigIrqCount <= INT_CTRL_IP_IRQ_COUNT);
    1a6c:	9b01      	ldr	r3, [sp, #4]
    1a6e:	681b      	ldr	r3, [r3, #0]
    1a70:	2b59      	cmp	r3, #89	; 0x59
    1a72:	bf94      	ite	ls
    1a74:	2301      	movls	r3, #1
    1a76:	2300      	movhi	r3, #0
    1a78:	b2db      	uxtb	r3, r3
    1a7a:	4618      	mov	r0, r3
    1a7c:	f7fe ff7e 	bl	97c <DevAssert>
#endif
    uint32 irqIdx;
    for (irqIdx = 0; irqIdx < pIntCtrlCtrlConfig->u32ConfigIrqCount; irqIdx++)
    1a80:	2300      	movs	r3, #0
    1a82:	9303      	str	r3, [sp, #12]
    1a84:	e05d      	b.n	1b42 <IntCtrl_Ip_Init+0xee>
    {
        IntCtrl_Ip_ClearPending(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
    1a86:	9b01      	ldr	r3, [sp, #4]
    1a88:	6859      	ldr	r1, [r3, #4]
    1a8a:	9a03      	ldr	r2, [sp, #12]
    1a8c:	4613      	mov	r3, r2
    1a8e:	005b      	lsls	r3, r3, #1
    1a90:	4413      	add	r3, r2
    1a92:	009b      	lsls	r3, r3, #2
    1a94:	440b      	add	r3, r1
    1a96:	681b      	ldr	r3, [r3, #0]
    1a98:	4618      	mov	r0, r3
    1a9a:	f000 f899 	bl	1bd0 <IntCtrl_Ip_ClearPending>
        IntCtrl_Ip_SetPriority(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    1a9e:	9b01      	ldr	r3, [sp, #4]
    1aa0:	6859      	ldr	r1, [r3, #4]
    1aa2:	9a03      	ldr	r2, [sp, #12]
    1aa4:	4613      	mov	r3, r2
    1aa6:	005b      	lsls	r3, r3, #1
    1aa8:	4413      	add	r3, r2
    1aaa:	009b      	lsls	r3, r3, #2
    1aac:	440b      	add	r3, r1
    1aae:	6818      	ldr	r0, [r3, #0]
                               pIntCtrlCtrlConfig->aIrqConfig[irqIdx].u8IrqPriority);
    1ab0:	9b01      	ldr	r3, [sp, #4]
    1ab2:	6859      	ldr	r1, [r3, #4]
    1ab4:	9a03      	ldr	r2, [sp, #12]
    1ab6:	4613      	mov	r3, r2
    1ab8:	005b      	lsls	r3, r3, #1
    1aba:	4413      	add	r3, r2
    1abc:	009b      	lsls	r3, r3, #2
    1abe:	440b      	add	r3, r1
        IntCtrl_Ip_SetPriority(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    1ac0:	795b      	ldrb	r3, [r3, #5]
    1ac2:	4619      	mov	r1, r3
    1ac4:	f000 f869 	bl	1b9a <IntCtrl_Ip_SetPriority>

        /* Install the configured handler */
        IntCtrl_Ip_InstallHandler(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    1ac8:	9b01      	ldr	r3, [sp, #4]
    1aca:	6859      	ldr	r1, [r3, #4]
    1acc:	9a03      	ldr	r2, [sp, #12]
    1ace:	4613      	mov	r3, r2
    1ad0:	005b      	lsls	r3, r3, #1
    1ad2:	4413      	add	r3, r2
    1ad4:	009b      	lsls	r3, r3, #2
    1ad6:	440b      	add	r3, r1
    1ad8:	6818      	ldr	r0, [r3, #0]
                                  pIntCtrlCtrlConfig->aIrqConfig[irqIdx].pfHandler,
    1ada:	9b01      	ldr	r3, [sp, #4]
    1adc:	6859      	ldr	r1, [r3, #4]
    1ade:	9a03      	ldr	r2, [sp, #12]
    1ae0:	4613      	mov	r3, r2
    1ae2:	005b      	lsls	r3, r3, #1
    1ae4:	4413      	add	r3, r2
    1ae6:	009b      	lsls	r3, r3, #2
    1ae8:	440b      	add	r3, r1
        IntCtrl_Ip_InstallHandler(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    1aea:	689b      	ldr	r3, [r3, #8]
    1aec:	2200      	movs	r2, #0
    1aee:	4619      	mov	r1, r3
    1af0:	f000 f831 	bl	1b56 <IntCtrl_Ip_InstallHandler>
                                  NULL_PTR);

        if (pIntCtrlCtrlConfig->aIrqConfig[irqIdx].bIrqEnabled)
    1af4:	9b01      	ldr	r3, [sp, #4]
    1af6:	6859      	ldr	r1, [r3, #4]
    1af8:	9a03      	ldr	r2, [sp, #12]
    1afa:	4613      	mov	r3, r2
    1afc:	005b      	lsls	r3, r3, #1
    1afe:	4413      	add	r3, r2
    1b00:	009b      	lsls	r3, r3, #2
    1b02:	440b      	add	r3, r1
    1b04:	791b      	ldrb	r3, [r3, #4]
    1b06:	2b00      	cmp	r3, #0
    1b08:	d00c      	beq.n	1b24 <IntCtrl_Ip_Init+0xd0>
        {
            IntCtrl_Ip_EnableIrq(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
    1b0a:	9b01      	ldr	r3, [sp, #4]
    1b0c:	6859      	ldr	r1, [r3, #4]
    1b0e:	9a03      	ldr	r2, [sp, #12]
    1b10:	4613      	mov	r3, r2
    1b12:	005b      	lsls	r3, r3, #1
    1b14:	4413      	add	r3, r2
    1b16:	009b      	lsls	r3, r3, #2
    1b18:	440b      	add	r3, r1
    1b1a:	681b      	ldr	r3, [r3, #0]
    1b1c:	4618      	mov	r0, r3
    1b1e:	f000 f828 	bl	1b72 <IntCtrl_Ip_EnableIrq>
    1b22:	e00b      	b.n	1b3c <IntCtrl_Ip_Init+0xe8>
        }
        else
        {
            IntCtrl_Ip_DisableIrq(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
    1b24:	9b01      	ldr	r3, [sp, #4]
    1b26:	6859      	ldr	r1, [r3, #4]
    1b28:	9a03      	ldr	r2, [sp, #12]
    1b2a:	4613      	mov	r3, r2
    1b2c:	005b      	lsls	r3, r3, #1
    1b2e:	4413      	add	r3, r2
    1b30:	009b      	lsls	r3, r3, #2
    1b32:	440b      	add	r3, r1
    1b34:	681b      	ldr	r3, [r3, #0]
    1b36:	4618      	mov	r0, r3
    1b38:	f000 f825 	bl	1b86 <IntCtrl_Ip_DisableIrq>
    for (irqIdx = 0; irqIdx < pIntCtrlCtrlConfig->u32ConfigIrqCount; irqIdx++)
    1b3c:	9b03      	ldr	r3, [sp, #12]
    1b3e:	3301      	adds	r3, #1
    1b40:	9303      	str	r3, [sp, #12]
    1b42:	9b01      	ldr	r3, [sp, #4]
    1b44:	681b      	ldr	r3, [r3, #0]
    1b46:	9a03      	ldr	r2, [sp, #12]
    1b48:	429a      	cmp	r2, r3
    1b4a:	d39c      	bcc.n	1a86 <IntCtrl_Ip_Init+0x32>
        }
    }

    return INTCTRL_IP_STATUS_SUCCESS;
    1b4c:	2300      	movs	r3, #0
}
    1b4e:	4618      	mov	r0, r3
    1b50:	b005      	add	sp, #20
    1b52:	f85d fb04 	ldr.w	pc, [sp], #4

00001b56 <IntCtrl_Ip_InstallHandler>:
 * @implements    IntCtrl_Ip_InstallHandler_Activity
 */
void IntCtrl_Ip_InstallHandler(IRQn_Type eIrqNumber,
                               const IntCtrl_Ip_IrqHandlerType pfNewHandler,
                               IntCtrl_Ip_IrqHandlerType* const pfOldHandler)
{
    1b56:	b500      	push	{lr}
    1b58:	b085      	sub	sp, #20
    1b5a:	9003      	str	r0, [sp, #12]
    1b5c:	9102      	str	r1, [sp, #8]
    1b5e:	9201      	str	r2, [sp, #4]
    Call_IntCtrl_Ip_InstallHandlerPrivileged(eIrqNumber,pfNewHandler,pfOldHandler);
    1b60:	9a01      	ldr	r2, [sp, #4]
    1b62:	9902      	ldr	r1, [sp, #8]
    1b64:	9803      	ldr	r0, [sp, #12]
    1b66:	f7ff fe5d 	bl	1824 <IntCtrl_Ip_InstallHandlerPrivileged>
}
    1b6a:	bf00      	nop
    1b6c:	b005      	add	sp, #20
    1b6e:	f85d fb04 	ldr.w	pc, [sp], #4

00001b72 <IntCtrl_Ip_EnableIrq>:
 * @internal
 * @brief         Enables an interrupt request.
 * @implements    IntCtrl_Ip_EnableIrq_Activity
 */
void IntCtrl_Ip_EnableIrq(IRQn_Type eIrqNumber)
{
    1b72:	b500      	push	{lr}
    1b74:	b083      	sub	sp, #12
    1b76:	9001      	str	r0, [sp, #4]
    Call_IntCtrl_Ip_EnableIrqPrivileged(eIrqNumber);
    1b78:	9801      	ldr	r0, [sp, #4]
    1b7a:	f7ff fe99 	bl	18b0 <IntCtrl_Ip_EnableIrqPrivileged>
}
    1b7e:	bf00      	nop
    1b80:	b003      	add	sp, #12
    1b82:	f85d fb04 	ldr.w	pc, [sp], #4

00001b86 <IntCtrl_Ip_DisableIrq>:
 * @internal
 * @brief         Disables an interrupt request.
 * @implements    IntCtrl_Ip_DisableIrq_Activity
 */
void IntCtrl_Ip_DisableIrq(IRQn_Type eIrqNumber)
{
    1b86:	b500      	push	{lr}
    1b88:	b083      	sub	sp, #12
    1b8a:	9001      	str	r0, [sp, #4]
    Call_IntCtrl_Ip_DisableIrqPrivileged(eIrqNumber);
    1b8c:	9801      	ldr	r0, [sp, #4]
    1b8e:	f7ff feb3 	bl	18f8 <IntCtrl_Ip_DisableIrqPrivileged>
}
    1b92:	bf00      	nop
    1b94:	b003      	add	sp, #12
    1b96:	f85d fb04 	ldr.w	pc, [sp], #4

00001b9a <IntCtrl_Ip_SetPriority>:
 * @internal
 * @brief         Sets the priority for an interrupt request.
 * @implements    IntCtrl_Ip_SetPriority_Activity
 */
void IntCtrl_Ip_SetPriority(IRQn_Type eIrqNumber, uint8 u8Priority)
{
    1b9a:	b500      	push	{lr}
    1b9c:	b083      	sub	sp, #12
    1b9e:	9001      	str	r0, [sp, #4]
    1ba0:	460b      	mov	r3, r1
    1ba2:	f88d 3003 	strb.w	r3, [sp, #3]
    Call_IntCtrl_Ip_SetPriorityPrivileged(eIrqNumber,u8Priority);
    1ba6:	f89d 3003 	ldrb.w	r3, [sp, #3]
    1baa:	4619      	mov	r1, r3
    1bac:	9801      	ldr	r0, [sp, #4]
    1bae:	f7ff fec9 	bl	1944 <IntCtrl_Ip_SetPriorityPrivileged>
}
    1bb2:	bf00      	nop
    1bb4:	b003      	add	sp, #12
    1bb6:	f85d fb04 	ldr.w	pc, [sp], #4

00001bba <IntCtrl_Ip_GetPriority>:
 * @internal
 * @brief         Gets the priority for an interrupt request.
 * @implements    IntCtrl_Ip_GetPriority_Activity
 */
uint8 IntCtrl_Ip_GetPriority(IRQn_Type eIrqNumber)
{
    1bba:	b500      	push	{lr}
    1bbc:	b083      	sub	sp, #12
    1bbe:	9001      	str	r0, [sp, #4]
    return (uint8)Call_IntCtrl_Ip_GetPriorityPrivileged(eIrqNumber);
    1bc0:	9801      	ldr	r0, [sp, #4]
    1bc2:	f7ff fef5 	bl	19b0 <IntCtrl_Ip_GetPriorityPrivileged>
    1bc6:	4603      	mov	r3, r0
}
    1bc8:	4618      	mov	r0, r3
    1bca:	b003      	add	sp, #12
    1bcc:	f85d fb04 	ldr.w	pc, [sp], #4

00001bd0 <IntCtrl_Ip_ClearPending>:
 * @internal
 * @brief         Clears the pending flag for an interrupt request.
 * @implements    IntCtrl_Ip_ClearPending_Activity
 */
void IntCtrl_Ip_ClearPending(IRQn_Type eIrqNumber)
{
    1bd0:	b500      	push	{lr}
    1bd2:	b083      	sub	sp, #12
    1bd4:	9001      	str	r0, [sp, #4]
    Call_IntCtrl_Ip_ClearPendingPrivileged(eIrqNumber);
    1bd6:	9801      	ldr	r0, [sp, #4]
    1bd8:	f7ff ff16 	bl	1a08 <IntCtrl_Ip_ClearPendingPrivileged>
}
    1bdc:	bf00      	nop
    1bde:	b003      	add	sp, #12
    1be0:	f85d fb04 	ldr.w	pc, [sp], #4

00001be4 <Platform_Ipw_SetIrq>:
/**
 * @internal
 * @brief         Enables/disables an interrupt by calling the Interrupt Controller IP layer.
 */
static inline void Platform_Ipw_SetIrq(IRQn_Type eIrqNumber, boolean bEnable)
{
    1be4:	b500      	push	{lr}
    1be6:	b083      	sub	sp, #12
    1be8:	9001      	str	r0, [sp, #4]
    1bea:	460b      	mov	r3, r1
    1bec:	f88d 3003 	strb.w	r3, [sp, #3]
    if (bEnable)
    1bf0:	f89d 3003 	ldrb.w	r3, [sp, #3]
    1bf4:	2b00      	cmp	r3, #0
    1bf6:	d003      	beq.n	1c00 <Platform_Ipw_SetIrq+0x1c>
    {
        IntCtrl_Ip_EnableIrq(eIrqNumber);
    1bf8:	9801      	ldr	r0, [sp, #4]
    1bfa:	f7ff ffba 	bl	1b72 <IntCtrl_Ip_EnableIrq>
    }
    else
    {
        IntCtrl_Ip_DisableIrq(eIrqNumber);
    }
}
    1bfe:	e002      	b.n	1c06 <Platform_Ipw_SetIrq+0x22>
        IntCtrl_Ip_DisableIrq(eIrqNumber);
    1c00:	9801      	ldr	r0, [sp, #4]
    1c02:	f7ff ffc0 	bl	1b86 <IntCtrl_Ip_DisableIrq>
}
    1c06:	bf00      	nop
    1c08:	b003      	add	sp, #12
    1c0a:	f85d fb04 	ldr.w	pc, [sp], #4

00001c0e <Platform_Ipw_SetIrqPriority>:
/**
 * @internal
 * @brief         Sets the priority of an interrupt by calling the Interrupt Controller IP layer.
 */
static inline void Platform_Ipw_SetIrqPriority(IRQn_Type eIrqNumber, uint8 u8Priority)
{
    1c0e:	b500      	push	{lr}
    1c10:	b083      	sub	sp, #12
    1c12:	9001      	str	r0, [sp, #4]
    1c14:	460b      	mov	r3, r1
    1c16:	f88d 3003 	strb.w	r3, [sp, #3]
    IntCtrl_Ip_SetPriority(eIrqNumber, u8Priority);
    1c1a:	f89d 3003 	ldrb.w	r3, [sp, #3]
    1c1e:	4619      	mov	r1, r3
    1c20:	9801      	ldr	r0, [sp, #4]
    1c22:	f7ff ffba 	bl	1b9a <IntCtrl_Ip_SetPriority>
}
    1c26:	bf00      	nop
    1c28:	b003      	add	sp, #12
    1c2a:	f85d fb04 	ldr.w	pc, [sp], #4

00001c2e <Platform_Ipw_GetIrqPriority>:
/**
 * @internal
 * @brief         Returns the priority of an interrupt by calling the Interrupt Controller IP layer.
 */
static inline uint8 Platform_Ipw_GetIrqPriority(IRQn_Type eIrqNumber)
{
    1c2e:	b500      	push	{lr}
    1c30:	b083      	sub	sp, #12
    1c32:	9001      	str	r0, [sp, #4]
    return IntCtrl_Ip_GetPriority(eIrqNumber);
    1c34:	9801      	ldr	r0, [sp, #4]
    1c36:	f7ff ffc0 	bl	1bba <IntCtrl_Ip_GetPriority>
    1c3a:	4603      	mov	r3, r0
}
    1c3c:	4618      	mov	r0, r3
    1c3e:	b003      	add	sp, #12
    1c40:	f85d fb04 	ldr.w	pc, [sp], #4

00001c44 <Platform_Ipw_InstallIrqHandler>:
 * @brief         Installs a new interrupt handler by calling the Interrupt Controller IP layer.
 */
static inline void Platform_Ipw_InstallIrqHandler(IRQn_Type eIrqNumber,
                                                  const IntCtrl_Ip_IrqHandlerType pfNewHandler,
                                                  IntCtrl_Ip_IrqHandlerType* const pfOldHandler)
{
    1c44:	b500      	push	{lr}
    1c46:	b085      	sub	sp, #20
    1c48:	9003      	str	r0, [sp, #12]
    1c4a:	9102      	str	r1, [sp, #8]
    1c4c:	9201      	str	r2, [sp, #4]
    IntCtrl_Ip_InstallHandler(eIrqNumber, pfNewHandler, pfOldHandler);
    1c4e:	9a01      	ldr	r2, [sp, #4]
    1c50:	9902      	ldr	r1, [sp, #8]
    1c52:	9803      	ldr	r0, [sp, #12]
    1c54:	f7ff ff7f 	bl	1b56 <IntCtrl_Ip_InstallHandler>
}
    1c58:	bf00      	nop
    1c5a:	b005      	add	sp, #20
    1c5c:	f85d fb04 	ldr.w	pc, [sp], #4

00001c60 <Platform_Init>:
 * @internal
 * @brief         Initializes the platform settings based on user configuration.
 * @implements    Platform_Init_Activity
 */
void Platform_Init(const Platform_ConfigType *pConfig)
{
    1c60:	b500      	push	{lr}
    1c62:	b085      	sub	sp, #20
    1c64:	9001      	str	r0, [sp, #4]
    uint8 u8CoreId;

    u8CoreId = (uint8)Platform_GetCoreID();
    1c66:	2300      	movs	r3, #0
    1c68:	f88d 300f 	strb.w	r3, [sp, #15]
    (void)pConfig;
#if (PLATFORM_DEV_ERROR_DETECT == STD_ON)
    if (NULL_PTR != pConfig)
    1c6c:	9b01      	ldr	r3, [sp, #4]
    1c6e:	2b00      	cmp	r3, #0
    1c70:	d006      	beq.n	1c80 <Platform_Init+0x20>
    {
        (void)Det_ReportError((uint16)CDD_PLATFORM_MODULE_ID, 0U, PLATFORM_INIT_ID, PLATFORM_E_PARAM_POINTER);
    1c72:	2301      	movs	r3, #1
    1c74:	2220      	movs	r2, #32
    1c76:	2100      	movs	r1, #0
    1c78:	20ff      	movs	r0, #255	; 0xff
    1c7a:	f015 f88b 	bl	16d94 <Det_ReportError>
        }
#endif /*(PLATFORM_MULTICORE_SUPPORT == STD_ON)*/
    }
#endif /* (PLATFORM_DEV_ERROR_DETECT == STD_ON)*/

}
    1c7e:	e008      	b.n	1c92 <Platform_Init+0x32>
            Platform_Ipw_Init(Platform_Config[u8CoreId]->pIpwConfig);
    1c80:	f89d 300f 	ldrb.w	r3, [sp, #15]
    1c84:	4a05      	ldr	r2, [pc, #20]	; (1c9c <Platform_Init+0x3c>)
    1c86:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    1c8a:	681b      	ldr	r3, [r3, #0]
    1c8c:	4618      	mov	r0, r3
    1c8e:	f000 f917 	bl	1ec0 <Platform_Ipw_Init>
}
    1c92:	bf00      	nop
    1c94:	b005      	add	sp, #20
    1c96:	f85d fb04 	ldr.w	pc, [sp], #4
    1c9a:	bf00      	nop
    1c9c:	0001946c 	.word	0x0001946c

00001ca0 <Platform_SetIrq>:
 * @internal
 * @brief         Configures (enables/disables) an interrupt request.
 * @implements    Platform_SetIrq_Activity
 */
Std_ReturnType Platform_SetIrq(IRQn_Type eIrqNumber, boolean bEnable)
{
    1ca0:	b500      	push	{lr}
    1ca2:	b085      	sub	sp, #20
    1ca4:	9001      	str	r0, [sp, #4]
    1ca6:	460b      	mov	r3, r1
    1ca8:	f88d 3003 	strb.w	r3, [sp, #3]
    Std_ReturnType RetValue = (Std_ReturnType)E_OK;
    1cac:	2300      	movs	r3, #0
    1cae:	f88d 300f 	strb.w	r3, [sp, #15]

#if (PLATFORM_DEV_ERROR_DETECT == STD_ON)
    if (((sint32)eIrqNumber > (sint32)INT_CTRL_IP_IRQ_MAX) || \
    1cb2:	9b01      	ldr	r3, [sp, #4]
    1cb4:	2b7a      	cmp	r3, #122	; 0x7a
    1cb6:	dc02      	bgt.n	1cbe <Platform_SetIrq+0x1e>
    1cb8:	9b01      	ldr	r3, [sp, #4]
    1cba:	2b00      	cmp	r3, #0
    1cbc:	da09      	bge.n	1cd2 <Platform_SetIrq+0x32>
        ((sint32)INT_CTRL_IP_IRQ_MIN > (sint32)eIrqNumber))
    {
        (void)Det_ReportError(CDD_PLATFORM_MODULE_ID, 0U, PLATFORM_SET_IRQ_ID, PLATFORM_E_PARAM_OUT_OF_RANGE);
    1cbe:	2302      	movs	r3, #2
    1cc0:	2221      	movs	r2, #33	; 0x21
    1cc2:	2100      	movs	r1, #0
    1cc4:	20ff      	movs	r0, #255	; 0xff
    1cc6:	f015 f865 	bl	16d94 <Det_ReportError>
        RetValue = (Std_ReturnType)E_NOT_OK;
    1cca:	2301      	movs	r3, #1
    1ccc:	f88d 300f 	strb.w	r3, [sp, #15]
    1cd0:	e005      	b.n	1cde <Platform_SetIrq+0x3e>
    }
    else
#endif
    {
        Platform_Ipw_SetIrq(eIrqNumber, bEnable);
    1cd2:	f89d 3003 	ldrb.w	r3, [sp, #3]
    1cd6:	4619      	mov	r1, r3
    1cd8:	9801      	ldr	r0, [sp, #4]
    1cda:	f7ff ff83 	bl	1be4 <Platform_Ipw_SetIrq>
    }
    return RetValue;
    1cde:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    1ce2:	4618      	mov	r0, r3
    1ce4:	b005      	add	sp, #20
    1ce6:	f85d fb04 	ldr.w	pc, [sp], #4

00001cea <Platform_SetIrqPriority>:
 * @internal
 * @brief         Configures the priority of an interrupt request.
 * @implements    Platform_SetIrqPriority_Activity
 */
Std_ReturnType Platform_SetIrqPriority(IRQn_Type eIrqNumber, uint8 u8Priority)
{
    1cea:	b500      	push	{lr}
    1cec:	b085      	sub	sp, #20
    1cee:	9001      	str	r0, [sp, #4]
    1cf0:	460b      	mov	r3, r1
    1cf2:	f88d 3003 	strb.w	r3, [sp, #3]
    Std_ReturnType RetValue = (Std_ReturnType)E_OK;
    1cf6:	2300      	movs	r3, #0
    1cf8:	f88d 300f 	strb.w	r3, [sp, #15]

#if (PLATFORM_DEV_ERROR_DETECT == STD_ON)
#if (INT_CTRL_IP_CORTEXM == STD_ON)
    if (((sint32)eIrqNumber > (sint32)INT_CTRL_IP_IRQ_MAX) || \
    1cfc:	9b01      	ldr	r3, [sp, #4]
    1cfe:	2b7a      	cmp	r3, #122	; 0x7a
    1d00:	dc06      	bgt.n	1d10 <Platform_SetIrqPriority+0x26>
    1d02:	9b01      	ldr	r3, [sp, #4]
    1d04:	2b00      	cmp	r3, #0
    1d06:	db03      	blt.n	1d10 <Platform_SetIrqPriority+0x26>
        ((sint32)INT_CTRL_IP_IRQ_MIN > (sint32)eIrqNumber) || \
    1d08:	f89d 3003 	ldrb.w	r3, [sp, #3]
    1d0c:	2b0f      	cmp	r3, #15
    1d0e:	d909      	bls.n	1d24 <Platform_SetIrqPriority+0x3a>
    if (((sint32)eIrqNumber > (sint32)INT_CTRL_IP_IRQ_MAX) || \
        ((sint32)INT_CTRL_IP_IRQ_MIN > (sint32)eIrqNumber) || \
        (u8Priority >= (uint8)(1U << INT_CTRL_IP_GIC_PRIO_BITS)))
#endif
    {
        (void)Det_ReportError(CDD_PLATFORM_MODULE_ID, 0U, PLATFORM_SET_IRQ_PRIO_ID, PLATFORM_E_PARAM_OUT_OF_RANGE);
    1d10:	2302      	movs	r3, #2
    1d12:	2222      	movs	r2, #34	; 0x22
    1d14:	2100      	movs	r1, #0
    1d16:	20ff      	movs	r0, #255	; 0xff
    1d18:	f015 f83c 	bl	16d94 <Det_ReportError>
        RetValue = (Std_ReturnType)E_NOT_OK;
    1d1c:	2301      	movs	r3, #1
    1d1e:	f88d 300f 	strb.w	r3, [sp, #15]
    1d22:	e005      	b.n	1d30 <Platform_SetIrqPriority+0x46>
    }
    else
#endif
    {
        Platform_Ipw_SetIrqPriority(eIrqNumber, u8Priority);
    1d24:	f89d 3003 	ldrb.w	r3, [sp, #3]
    1d28:	4619      	mov	r1, r3
    1d2a:	9801      	ldr	r0, [sp, #4]
    1d2c:	f7ff ff6f 	bl	1c0e <Platform_Ipw_SetIrqPriority>
    }
    return RetValue;
    1d30:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    1d34:	4618      	mov	r0, r3
    1d36:	b005      	add	sp, #20
    1d38:	f85d fb04 	ldr.w	pc, [sp], #4

00001d3c <Platform_GetIrqPriority>:
 * @internal
 * @brief         Returns the priority of an interrupt request.
 * @implements    Platform_GetIrqPriority_Activity
 */
Std_ReturnType Platform_GetIrqPriority(IRQn_Type eIrqNumber, uint8 * u8Priority)
{
    1d3c:	b500      	push	{lr}
    1d3e:	b085      	sub	sp, #20
    1d40:	9001      	str	r0, [sp, #4]
    1d42:	9100      	str	r1, [sp, #0]
    Std_ReturnType RetValue = (Std_ReturnType)E_OK;
    1d44:	2300      	movs	r3, #0
    1d46:	f88d 300f 	strb.w	r3, [sp, #15]

#if (PLATFORM_DEV_ERROR_DETECT == STD_ON)
    if (((sint32)eIrqNumber > (sint32)INT_CTRL_IP_IRQ_MAX) || \
    1d4a:	9b01      	ldr	r3, [sp, #4]
    1d4c:	2b7a      	cmp	r3, #122	; 0x7a
    1d4e:	dc02      	bgt.n	1d56 <Platform_GetIrqPriority+0x1a>
    1d50:	9b01      	ldr	r3, [sp, #4]
    1d52:	2b00      	cmp	r3, #0
    1d54:	da09      	bge.n	1d6a <Platform_GetIrqPriority+0x2e>
        ((sint32)INT_CTRL_IP_IRQ_MIN > (sint32)eIrqNumber))
    {
        (void)Det_ReportError(CDD_PLATFORM_MODULE_ID, 0U, PLATFORM_GET_IRQ_PRIO_ID, PLATFORM_E_PARAM_OUT_OF_RANGE);
    1d56:	2302      	movs	r3, #2
    1d58:	2223      	movs	r2, #35	; 0x23
    1d5a:	2100      	movs	r1, #0
    1d5c:	20ff      	movs	r0, #255	; 0xff
    1d5e:	f015 f819 	bl	16d94 <Det_ReportError>
        RetValue = (Std_ReturnType)E_NOT_OK;
    1d62:	2301      	movs	r3, #1
    1d64:	f88d 300f 	strb.w	r3, [sp, #15]
    1d68:	e013      	b.n	1d92 <Platform_GetIrqPriority+0x56>
    }
    else if (u8Priority == NULL_PTR)
    1d6a:	9b00      	ldr	r3, [sp, #0]
    1d6c:	2b00      	cmp	r3, #0
    1d6e:	d109      	bne.n	1d84 <Platform_GetIrqPriority+0x48>
    {
        (void)Det_ReportError(CDD_PLATFORM_MODULE_ID, 0U, PLATFORM_GET_IRQ_PRIO_ID, PLATFORM_E_PARAM_POINTER);
    1d70:	2301      	movs	r3, #1
    1d72:	2223      	movs	r2, #35	; 0x23
    1d74:	2100      	movs	r1, #0
    1d76:	20ff      	movs	r0, #255	; 0xff
    1d78:	f015 f80c 	bl	16d94 <Det_ReportError>
        RetValue = (Std_ReturnType)E_NOT_OK;
    1d7c:	2301      	movs	r3, #1
    1d7e:	f88d 300f 	strb.w	r3, [sp, #15]
    1d82:	e006      	b.n	1d92 <Platform_GetIrqPriority+0x56>
    }
    else
#endif
    {
        *u8Priority = Platform_Ipw_GetIrqPriority(eIrqNumber);
    1d84:	9801      	ldr	r0, [sp, #4]
    1d86:	f7ff ff52 	bl	1c2e <Platform_Ipw_GetIrqPriority>
    1d8a:	4603      	mov	r3, r0
    1d8c:	461a      	mov	r2, r3
    1d8e:	9b00      	ldr	r3, [sp, #0]
    1d90:	701a      	strb	r2, [r3, #0]
    }

    return RetValue;
    1d92:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    1d96:	4618      	mov	r0, r3
    1d98:	b005      	add	sp, #20
    1d9a:	f85d fb04 	ldr.w	pc, [sp], #4

00001d9e <Platform_InstallIrqHandler>:
 * @implements    Platform_InstallIrqHandler_Activity
 */
Std_ReturnType Platform_InstallIrqHandler(IRQn_Type eIrqNumber,
                                          const Platform_IrqHandlerType pfNewHandler,
                                          Platform_IrqHandlerType* const pfOldHandler)
{
    1d9e:	b500      	push	{lr}
    1da0:	b087      	sub	sp, #28
    1da2:	9003      	str	r0, [sp, #12]
    1da4:	9102      	str	r1, [sp, #8]
    1da6:	9201      	str	r2, [sp, #4]
    Std_ReturnType RetValue = (Std_ReturnType)E_OK;
    1da8:	2300      	movs	r3, #0
    1daa:	f88d 3017 	strb.w	r3, [sp, #23]

#if (PLATFORM_DEV_ERROR_DETECT == STD_ON)
    if (((sint32)eIrqNumber > (sint32)INT_CTRL_IP_IRQ_MAX) || \
    1dae:	9b03      	ldr	r3, [sp, #12]
    1db0:	2b7a      	cmp	r3, #122	; 0x7a
    1db2:	dc02      	bgt.n	1dba <Platform_InstallIrqHandler+0x1c>
    1db4:	9b03      	ldr	r3, [sp, #12]
    1db6:	2b00      	cmp	r3, #0
    1db8:	da09      	bge.n	1dce <Platform_InstallIrqHandler+0x30>
        ((sint32)INT_CTRL_IP_IRQ_MIN > (sint32)eIrqNumber))
    {
        (void)Det_ReportError(CDD_PLATFORM_MODULE_ID, 0U, PLATFORM_INSTALL_HANDLER_ID, PLATFORM_E_PARAM_OUT_OF_RANGE);
    1dba:	2302      	movs	r3, #2
    1dbc:	2224      	movs	r2, #36	; 0x24
    1dbe:	2100      	movs	r1, #0
    1dc0:	20ff      	movs	r0, #255	; 0xff
    1dc2:	f014 ffe7 	bl	16d94 <Det_ReportError>
        RetValue = (Std_ReturnType)E_NOT_OK;
    1dc6:	2301      	movs	r3, #1
    1dc8:	f88d 3017 	strb.w	r3, [sp, #23]
    1dcc:	e004      	b.n	1dd8 <Platform_InstallIrqHandler+0x3a>
    }
    else
#endif
    {
        Platform_Ipw_InstallIrqHandler(eIrqNumber, pfNewHandler, pfOldHandler);
    1dce:	9a01      	ldr	r2, [sp, #4]
    1dd0:	9902      	ldr	r1, [sp, #8]
    1dd2:	9803      	ldr	r0, [sp, #12]
    1dd4:	f7ff ff36 	bl	1c44 <Platform_Ipw_InstallIrqHandler>
    }
    return RetValue;
    1dd8:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    1ddc:	4618      	mov	r0, r3
    1dde:	b007      	add	sp, #28
    1de0:	f85d fb04 	ldr.w	pc, [sp], #4

00001de4 <Platform_Ipw_InitIntCtrl>:
#endif



static Std_ReturnType Platform_Ipw_InitIntCtrl(const IntCtrl_Ip_CtrlConfigType *pIntCtrlCtrlConfig)
{
    1de4:	b500      	push	{lr}
    1de6:	b085      	sub	sp, #20
    1de8:	9001      	str	r0, [sp, #4]
    uint32 irqIdx;
    
    for (irqIdx = 0; irqIdx < pIntCtrlCtrlConfig->u32ConfigIrqCount; irqIdx++)
    1dea:	2300      	movs	r3, #0
    1dec:	9303      	str	r3, [sp, #12]
    1dee:	e05d      	b.n	1eac <Platform_Ipw_InitIntCtrl+0xc8>
    {   
        IntCtrl_Ip_ClearPending(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
    1df0:	9b01      	ldr	r3, [sp, #4]
    1df2:	6859      	ldr	r1, [r3, #4]
    1df4:	9a03      	ldr	r2, [sp, #12]
    1df6:	4613      	mov	r3, r2
    1df8:	005b      	lsls	r3, r3, #1
    1dfa:	4413      	add	r3, r2
    1dfc:	009b      	lsls	r3, r3, #2
    1dfe:	440b      	add	r3, r1
    1e00:	681b      	ldr	r3, [r3, #0]
    1e02:	4618      	mov	r0, r3
    1e04:	f7ff fee4 	bl	1bd0 <IntCtrl_Ip_ClearPending>
        /* interrupt number for which the priority is set */
        IntCtrl_Ip_SetPriority(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    1e08:	9b01      	ldr	r3, [sp, #4]
    1e0a:	6859      	ldr	r1, [r3, #4]
    1e0c:	9a03      	ldr	r2, [sp, #12]
    1e0e:	4613      	mov	r3, r2
    1e10:	005b      	lsls	r3, r3, #1
    1e12:	4413      	add	r3, r2
    1e14:	009b      	lsls	r3, r3, #2
    1e16:	440b      	add	r3, r1
    1e18:	6818      	ldr	r0, [r3, #0]
                               pIntCtrlCtrlConfig->aIrqConfig[irqIdx].u8IrqPriority);
    1e1a:	9b01      	ldr	r3, [sp, #4]
    1e1c:	6859      	ldr	r1, [r3, #4]
    1e1e:	9a03      	ldr	r2, [sp, #12]
    1e20:	4613      	mov	r3, r2
    1e22:	005b      	lsls	r3, r3, #1
    1e24:	4413      	add	r3, r2
    1e26:	009b      	lsls	r3, r3, #2
    1e28:	440b      	add	r3, r1
        IntCtrl_Ip_SetPriority(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    1e2a:	795b      	ldrb	r3, [r3, #5]
    1e2c:	4619      	mov	r1, r3
    1e2e:	f7ff feb4 	bl	1b9a <IntCtrl_Ip_SetPriority>
        /* Install the configured handler */
        IntCtrl_Ip_InstallHandler(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    1e32:	9b01      	ldr	r3, [sp, #4]
    1e34:	6859      	ldr	r1, [r3, #4]
    1e36:	9a03      	ldr	r2, [sp, #12]
    1e38:	4613      	mov	r3, r2
    1e3a:	005b      	lsls	r3, r3, #1
    1e3c:	4413      	add	r3, r2
    1e3e:	009b      	lsls	r3, r3, #2
    1e40:	440b      	add	r3, r1
    1e42:	6818      	ldr	r0, [r3, #0]
                                  pIntCtrlCtrlConfig->aIrqConfig[irqIdx].pfHandler,
    1e44:	9b01      	ldr	r3, [sp, #4]
    1e46:	6859      	ldr	r1, [r3, #4]
    1e48:	9a03      	ldr	r2, [sp, #12]
    1e4a:	4613      	mov	r3, r2
    1e4c:	005b      	lsls	r3, r3, #1
    1e4e:	4413      	add	r3, r2
    1e50:	009b      	lsls	r3, r3, #2
    1e52:	440b      	add	r3, r1
        IntCtrl_Ip_InstallHandler(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    1e54:	689b      	ldr	r3, [r3, #8]
    1e56:	2200      	movs	r2, #0
    1e58:	4619      	mov	r1, r3
    1e5a:	f7ff fe7c 	bl	1b56 <IntCtrl_Ip_InstallHandler>
                                  NULL_PTR);

        /* Enable interrupt */                       
        if (pIntCtrlCtrlConfig->aIrqConfig[irqIdx].bIrqEnabled)
    1e5e:	9b01      	ldr	r3, [sp, #4]
    1e60:	6859      	ldr	r1, [r3, #4]
    1e62:	9a03      	ldr	r2, [sp, #12]
    1e64:	4613      	mov	r3, r2
    1e66:	005b      	lsls	r3, r3, #1
    1e68:	4413      	add	r3, r2
    1e6a:	009b      	lsls	r3, r3, #2
    1e6c:	440b      	add	r3, r1
    1e6e:	791b      	ldrb	r3, [r3, #4]
    1e70:	2b00      	cmp	r3, #0
    1e72:	d00c      	beq.n	1e8e <Platform_Ipw_InitIntCtrl+0xaa>
        {   
            /* enables the interrupt request at interrupt controller level. */
            IntCtrl_Ip_EnableIrq(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
    1e74:	9b01      	ldr	r3, [sp, #4]
    1e76:	6859      	ldr	r1, [r3, #4]
    1e78:	9a03      	ldr	r2, [sp, #12]
    1e7a:	4613      	mov	r3, r2
    1e7c:	005b      	lsls	r3, r3, #1
    1e7e:	4413      	add	r3, r2
    1e80:	009b      	lsls	r3, r3, #2
    1e82:	440b      	add	r3, r1
    1e84:	681b      	ldr	r3, [r3, #0]
    1e86:	4618      	mov	r0, r3
    1e88:	f7ff fe73 	bl	1b72 <IntCtrl_Ip_EnableIrq>
    1e8c:	e00b      	b.n	1ea6 <Platform_Ipw_InitIntCtrl+0xc2>
        }
        else
        {   
            /* disables the interrupt request at interrupt controller level.*/
            IntCtrl_Ip_DisableIrq(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
    1e8e:	9b01      	ldr	r3, [sp, #4]
    1e90:	6859      	ldr	r1, [r3, #4]
    1e92:	9a03      	ldr	r2, [sp, #12]
    1e94:	4613      	mov	r3, r2
    1e96:	005b      	lsls	r3, r3, #1
    1e98:	4413      	add	r3, r2
    1e9a:	009b      	lsls	r3, r3, #2
    1e9c:	440b      	add	r3, r1
    1e9e:	681b      	ldr	r3, [r3, #0]
    1ea0:	4618      	mov	r0, r3
    1ea2:	f7ff fe70 	bl	1b86 <IntCtrl_Ip_DisableIrq>
    for (irqIdx = 0; irqIdx < pIntCtrlCtrlConfig->u32ConfigIrqCount; irqIdx++)
    1ea6:	9b03      	ldr	r3, [sp, #12]
    1ea8:	3301      	adds	r3, #1
    1eaa:	9303      	str	r3, [sp, #12]
    1eac:	9b01      	ldr	r3, [sp, #4]
    1eae:	681b      	ldr	r3, [r3, #0]
    1eb0:	9a03      	ldr	r2, [sp, #12]
    1eb2:	429a      	cmp	r2, r3
    1eb4:	d39c      	bcc.n	1df0 <Platform_Ipw_InitIntCtrl+0xc>
        }
    }

    return E_OK;
    1eb6:	2300      	movs	r3, #0
}
    1eb8:	4618      	mov	r0, r3
    1eba:	b005      	add	sp, #20
    1ebc:	f85d fb04 	ldr.w	pc, [sp], #4

00001ec0 <Platform_Ipw_Init>:

/**
 * @brief         Initializes the platform settings based on user configuration.
 */
void Platform_Ipw_Init(const Platform_Ipw_ConfigType *pConfig)
{    
    1ec0:	b500      	push	{lr}
    1ec2:	b085      	sub	sp, #20
    1ec4:	9001      	str	r0, [sp, #4]
#if ((PLATFORM_SYS_CFG == STD_ON)&&(INT_CTRL_IP_CORTEXM == STD_ON))
    uint8 irqIdx;
#endif
    Std_ReturnType ret = (Std_ReturnType)E_OK;
    1ec6:	2300      	movs	r3, #0
    1ec8:	f88d 300f 	strb.w	r3, [sp, #15]

    /* Initialize interrupts at interrupt controller level */
    if (NULL_PTR != pConfig->pIntCtrlConfig)
    1ecc:	9b01      	ldr	r3, [sp, #4]
    1ece:	681b      	ldr	r3, [r3, #0]
    1ed0:	2b00      	cmp	r3, #0
    1ed2:	d007      	beq.n	1ee4 <Platform_Ipw_Init+0x24>
    {
        ret = Platform_Ipw_InitIntCtrl(pConfig->pIntCtrlConfig);
    1ed4:	9b01      	ldr	r3, [sp, #4]
    1ed6:	681b      	ldr	r3, [r3, #0]
    1ed8:	4618      	mov	r0, r3
    1eda:	f7ff ff83 	bl	1de4 <Platform_Ipw_InitIntCtrl>
    1ede:	4603      	mov	r3, r0
    1ee0:	f88d 300f 	strb.w	r3, [sp, #15]
    }

    if(ret == (Std_ReturnType)E_OK)
    1ee4:	f89d 300f 	ldrb.w	r3, [sp, #15]
    1ee8:	2b00      	cmp	r3, #0
            /* Call_System_Ip_SetAhbSlavePriority((pConfig->aSystemConfig)->bAhbSlavePriority); */
#endif
        }  
#endif
    }
}
    1eea:	bf00      	nop
    1eec:	b005      	add	sp, #20
    1eee:	f85d fb04 	ldr.w	pc, [sp], #4

00001ef2 <OsIf_Timer_Dummy_GetCounter>:
 * Description   : Get counter value.
 * 
 *END**************************************************************************/
static inline uint32 OsIf_Timer_Dummy_GetCounter(void)
{
    return 0U;
    1ef2:	2300      	movs	r3, #0
}
    1ef4:	4618      	mov	r0, r3
    1ef6:	4770      	bx	lr

00001ef8 <OsIf_Timer_Dummy_GetElapsed>:
 * Function Name : OsIf_Timer_Dummy_GetElapsed.
 * Description   : Get elapsed value.
 * 
 *END**************************************************************************/
static inline uint32 OsIf_Timer_Dummy_GetElapsed(const uint32 * const CurrentRef)
{
    1ef8:	b082      	sub	sp, #8
    1efa:	9001      	str	r0, [sp, #4]
    (void)CurrentRef;
    return 1U;
    1efc:	2301      	movs	r3, #1
}
    1efe:	4618      	mov	r0, r3
    1f00:	b002      	add	sp, #8
    1f02:	4770      	bx	lr

00001f04 <OsIf_Timer_Dummy_SetTimerFrequency>:
 * Function Name : OsIf_Timer_Dummy_SetTimerFrequency.
 * Description   : Set timer frequency.
 * 
 *END**************************************************************************/
static inline void OsIf_Timer_Dummy_SetTimerFrequency(uint32 Freq)
{
    1f04:	b082      	sub	sp, #8
    1f06:	9001      	str	r0, [sp, #4]
    (void)Freq;
}
    1f08:	bf00      	nop
    1f0a:	b002      	add	sp, #8
    1f0c:	4770      	bx	lr

00001f0e <OsIf_Timer_Dummy_MicrosToTicks>:
 * Function Name : OsIf_Timer_Dummy_MicrosToTicks.
 * Description   : Convert micro second to ticks.
 * 
 *END**************************************************************************/
static inline uint32 OsIf_Timer_Dummy_MicrosToTicks(uint32 Micros)
{
    1f0e:	b082      	sub	sp, #8
    1f10:	9001      	str	r0, [sp, #4]
    return Micros;
    1f12:	9b01      	ldr	r3, [sp, #4]
}
    1f14:	4618      	mov	r0, r3
    1f16:	b002      	add	sp, #8
    1f18:	4770      	bx	lr

00001f1a <OsIf_Init>:
 * Description   : OsIf initialization.
 * @implements OsIf_Init_Activity
 * 
 *END**************************************************************************/
void OsIf_Init(const void* Config)
{
    1f1a:	b500      	push	{lr}
    1f1c:	b083      	sub	sp, #12
    1f1e:	9001      	str	r0, [sp, #4]
#else
    (void)Config;
#endif /* (STD_ON == OSIF_DEV_ERROR_DETECT) */

#if (OSIF_USE_SYSTEM_TIMER == STD_ON)
    OsIf_Timer_System_Init();
    1f20:	f000 f86c 	bl	1ffc <OsIf_Timer_System_Init>
#endif /* (OSIF_USE_SYSTEM_TIMER == STD_ON) */
#if (OSIF_USE_CUSTOM_TIMER == STD_ON)
    OsIf_Timer_Custom_Init();
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
}
    1f24:	bf00      	nop
    1f26:	b003      	add	sp, #12
    1f28:	f85d fb04 	ldr.w	pc, [sp], #4

00001f2c <OsIf_GetCounter>:
 * Description   : Get counter value.
 * @implements OsIf_GetCounter_Activity
 * 
 *END**************************************************************************/
uint32 OsIf_GetCounter(OsIf_CounterType SelectedCounter)
{
    1f2c:	b500      	push	{lr}
    1f2e:	b085      	sub	sp, #20
    1f30:	9001      	str	r0, [sp, #4]
    uint32 Value = 0U;
    1f32:	2300      	movs	r3, #0
    1f34:	9303      	str	r3, [sp, #12]

    switch (SelectedCounter){
    1f36:	9b01      	ldr	r3, [sp, #4]
    1f38:	2b00      	cmp	r3, #0
    1f3a:	d003      	beq.n	1f44 <OsIf_GetCounter+0x18>
    1f3c:	9b01      	ldr	r3, [sp, #4]
    1f3e:	2b01      	cmp	r3, #1
    1f40:	d004      	beq.n	1f4c <OsIf_GetCounter+0x20>
            Value = OsIf_Timer_Custom_GetCounter();
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
    1f42:	e007      	b.n	1f54 <OsIf_GetCounter+0x28>
            Value = OsIf_Timer_Dummy_GetCounter();
    1f44:	f7ff ffd5 	bl	1ef2 <OsIf_Timer_Dummy_GetCounter>
    1f48:	9003      	str	r0, [sp, #12]
            break;
    1f4a:	e003      	b.n	1f54 <OsIf_GetCounter+0x28>
            Value = OsIf_Timer_System_GetCounter();
    1f4c:	f000 f872 	bl	2034 <OsIf_Timer_System_GetCounter>
    1f50:	9003      	str	r0, [sp, #12]
            break;
    1f52:	bf00      	nop
    }

    return Value;
    1f54:	9b03      	ldr	r3, [sp, #12]
}
    1f56:	4618      	mov	r0, r3
    1f58:	b005      	add	sp, #20
    1f5a:	f85d fb04 	ldr.w	pc, [sp], #4

00001f5e <OsIf_GetElapsed>:
 * Description   : Get elapsed value.
 * @implements OsIf_GetElapsed_Activity
 * 
 *END**************************************************************************/
uint32 OsIf_GetElapsed(uint32 * const CurrentRef, OsIf_CounterType SelectedCounter)
{
    1f5e:	b500      	push	{lr}
    1f60:	b085      	sub	sp, #20
    1f62:	9001      	str	r0, [sp, #4]
    1f64:	9100      	str	r1, [sp, #0]
    uint32 Value = 0U;
    1f66:	2300      	movs	r3, #0
    1f68:	9303      	str	r3, [sp, #12]

    switch (SelectedCounter){
    1f6a:	9b00      	ldr	r3, [sp, #0]
    1f6c:	2b00      	cmp	r3, #0
    1f6e:	d003      	beq.n	1f78 <OsIf_GetElapsed+0x1a>
    1f70:	9b00      	ldr	r3, [sp, #0]
    1f72:	2b01      	cmp	r3, #1
    1f74:	d005      	beq.n	1f82 <OsIf_GetElapsed+0x24>
            Value = OsIf_Timer_Custom_GetElapsed(CurrentRef);
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
    1f76:	e009      	b.n	1f8c <OsIf_GetElapsed+0x2e>
            Value = OsIf_Timer_Dummy_GetElapsed(CurrentRef);
    1f78:	9801      	ldr	r0, [sp, #4]
    1f7a:	f7ff ffbd 	bl	1ef8 <OsIf_Timer_Dummy_GetElapsed>
    1f7e:	9003      	str	r0, [sp, #12]
            break;
    1f80:	e004      	b.n	1f8c <OsIf_GetElapsed+0x2e>
            Value = OsIf_Timer_System_GetElapsed(CurrentRef);
    1f82:	9801      	ldr	r0, [sp, #4]
    1f84:	f000 f864 	bl	2050 <OsIf_Timer_System_GetElapsed>
    1f88:	9003      	str	r0, [sp, #12]
            break;
    1f8a:	bf00      	nop
    }

    return Value;
    1f8c:	9b03      	ldr	r3, [sp, #12]
}
    1f8e:	4618      	mov	r0, r3
    1f90:	b005      	add	sp, #20
    1f92:	f85d fb04 	ldr.w	pc, [sp], #4

00001f96 <OsIf_SetTimerFrequency>:
 * @implements OsIf_SetTimerFrequency_Activity
 * 
 *END**************************************************************************/
/* @implements OsIf_SetTimerFrequency_Activity */
void OsIf_SetTimerFrequency(uint32 Freq, OsIf_CounterType SelectedCounter)
{
    1f96:	b500      	push	{lr}
    1f98:	b083      	sub	sp, #12
    1f9a:	9001      	str	r0, [sp, #4]
    1f9c:	9100      	str	r1, [sp, #0]
    switch (SelectedCounter){
    1f9e:	9b00      	ldr	r3, [sp, #0]
    1fa0:	2b00      	cmp	r3, #0
    1fa2:	d003      	beq.n	1fac <OsIf_SetTimerFrequency+0x16>
    1fa4:	9b00      	ldr	r3, [sp, #0]
    1fa6:	2b01      	cmp	r3, #1
    1fa8:	d004      	beq.n	1fb4 <OsIf_SetTimerFrequency+0x1e>
            OsIf_Timer_Custom_SetTimerFrequency(Freq);
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
    1faa:	e007      	b.n	1fbc <OsIf_SetTimerFrequency+0x26>
            OsIf_Timer_Dummy_SetTimerFrequency(Freq);
    1fac:	9801      	ldr	r0, [sp, #4]
    1fae:	f7ff ffa9 	bl	1f04 <OsIf_Timer_Dummy_SetTimerFrequency>
            break;
    1fb2:	e003      	b.n	1fbc <OsIf_SetTimerFrequency+0x26>
            OsIf_Timer_System_SetTimerFrequency(Freq);
    1fb4:	9801      	ldr	r0, [sp, #4]
    1fb6:	f000 f85b 	bl	2070 <OsIf_Timer_System_SetTimerFrequency>
            break;
    1fba:	bf00      	nop
    }
}
    1fbc:	bf00      	nop
    1fbe:	b003      	add	sp, #12
    1fc0:	f85d fb04 	ldr.w	pc, [sp], #4

00001fc4 <OsIf_MicrosToTicks>:
 * Description   : Convert micro second to ticks.
 * @implements OsIf_MicrosToTicks_Activity
 * 
 *END**************************************************************************/
uint32 OsIf_MicrosToTicks(uint32 Micros, OsIf_CounterType SelectedCounter)
{
    1fc4:	b500      	push	{lr}
    1fc6:	b085      	sub	sp, #20
    1fc8:	9001      	str	r0, [sp, #4]
    1fca:	9100      	str	r1, [sp, #0]
    uint32 Value = 0U;
    1fcc:	2300      	movs	r3, #0
    1fce:	9303      	str	r3, [sp, #12]

    switch (SelectedCounter){
    1fd0:	9b00      	ldr	r3, [sp, #0]
    1fd2:	2b00      	cmp	r3, #0
    1fd4:	d003      	beq.n	1fde <OsIf_MicrosToTicks+0x1a>
    1fd6:	9b00      	ldr	r3, [sp, #0]
    1fd8:	2b01      	cmp	r3, #1
    1fda:	d005      	beq.n	1fe8 <OsIf_MicrosToTicks+0x24>
            Value = OsIf_Timer_Custom_MicrosToTicks(Micros);
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
    1fdc:	e009      	b.n	1ff2 <OsIf_MicrosToTicks+0x2e>
            Value = OsIf_Timer_Dummy_MicrosToTicks(Micros);
    1fde:	9801      	ldr	r0, [sp, #4]
    1fe0:	f7ff ff95 	bl	1f0e <OsIf_Timer_Dummy_MicrosToTicks>
    1fe4:	9003      	str	r0, [sp, #12]
            break;
    1fe6:	e004      	b.n	1ff2 <OsIf_MicrosToTicks+0x2e>
            Value = OsIf_Timer_System_MicrosToTicks(Micros);
    1fe8:	9801      	ldr	r0, [sp, #4]
    1fea:	f000 f84f 	bl	208c <OsIf_Timer_System_MicrosToTicks>
    1fee:	9003      	str	r0, [sp, #12]
            break;
    1ff0:	bf00      	nop
    }

    return Value;
    1ff2:	9b03      	ldr	r3, [sp, #12]
}
    1ff4:	4618      	mov	r0, r3
    1ff6:	b005      	add	sp, #20
    1ff8:	f85d fb04 	ldr.w	pc, [sp], #4

00001ffc <OsIf_Timer_System_Init>:
 * Function Name : OsIf_Timer_System_Init.
 * Description   : Initialize system timer.
 * 
 *END**************************************************************************/
void OsIf_Timer_System_Init(void)
{
    1ffc:	b500      	push	{lr}
    1ffe:	b083      	sub	sp, #12
    uint32 CoreId = OsIfCoreID();
    2000:	2300      	movs	r3, #0
    2002:	9301      	str	r3, [sp, #4]

#if (defined(USING_OS_AUTOSAROS) || (STD_ON == OSIF_DEV_ERROR_DETECT))
    OsIf_apxInternalCfg[CoreId] = OsIf_apxPredefinedConfig[CoreId];
#endif /* (defined(USING_OS_AUTOSAROS) || (STD_ON == OSIF_DEV_ERROR_DETECT)) */
#if (!defined(USING_OS_FREERTOS) && !defined(USING_OS_ZEPHYR))
    OsIf_au32InternalFrequencies[CoreId] = OsIf_apxPredefinedConfig[CoreId]->counterFrequency;
    2004:	4a09      	ldr	r2, [pc, #36]	; (202c <OsIf_Timer_System_Init+0x30>)
    2006:	9b01      	ldr	r3, [sp, #4]
    2008:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    200c:	685a      	ldr	r2, [r3, #4]
    200e:	4908      	ldr	r1, [pc, #32]	; (2030 <OsIf_Timer_System_Init+0x34>)
    2010:	9b01      	ldr	r3, [sp, #4]
    2012:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#elif defined(USING_OS_ZEPHYR)
    /* ZephyrOS */
    OsIf_au32InternalFrequencies[CoreId] = sys_clock_hw_cycles_per_sec();
#elif defined(USING_OS_BAREMETAL)
    /* Baremetal */
    Trusted_OsIf_Timer_System_Internal_Init(OsIf_au32InternalFrequencies[CoreId]);
    2016:	4a06      	ldr	r2, [pc, #24]	; (2030 <OsIf_Timer_System_Init+0x34>)
    2018:	9b01      	ldr	r3, [sp, #4]
    201a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    201e:	4618      	mov	r0, r3
    2020:	f000 f868 	bl	20f4 <OsIf_Timer_System_Internal_Init>
#endif
#if (STD_ON == OSIF_DEV_ERROR_DETECT)
    }
#endif /* (STD_ON == OSIF_DEV_ERROR_DETECT) */
}
    2024:	bf00      	nop
    2026:	b003      	add	sp, #12
    2028:	f85d fb04 	ldr.w	pc, [sp], #4
    202c:	00019464 	.word	0x00019464
    2030:	1fff8b38 	.word	0x1fff8b38

00002034 <OsIf_Timer_System_GetCounter>:
 * Function Name : OsIf_Timer_System_GetCounter.
 * Description   : Get counter value from system timer.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_GetCounter(void)
{
    2034:	b500      	push	{lr}
    2036:	b083      	sub	sp, #12
    uint32 Counter = 0U;
    2038:	2300      	movs	r3, #0
    203a:	9301      	str	r3, [sp, #4]
    uint32 CoreId = OsIfCoreID();
    203c:	2300      	movs	r3, #0
    203e:	9300      	str	r3, [sp, #0]
        (void)CoreId;
        Counter = Trusted_k_cycle_get_32();
#elif defined(USING_OS_FREERTOS) || defined(USING_OS_BAREMETAL)
        /* FreeRTOS and Baremetal*/
        (void)CoreId;
        Counter = Trusted_OsIf_Timer_System_Internal_GetCounter();
    2040:	f000 f86c 	bl	211c <OsIf_Timer_System_Internal_GetCounter>
    2044:	9001      	str	r0, [sp, #4]
#endif
    }

    return Counter;
    2046:	9b01      	ldr	r3, [sp, #4]
}
    2048:	4618      	mov	r0, r3
    204a:	b003      	add	sp, #12
    204c:	f85d fb04 	ldr.w	pc, [sp], #4

00002050 <OsIf_Timer_System_GetElapsed>:
 * Function Name : OsIf_Timer_System_GetElapsed.
 * Description   : Get elapsed value from system timer.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_GetElapsed(uint32 * const CurrentRef)
{
    2050:	b500      	push	{lr}
    2052:	b085      	sub	sp, #20
    2054:	9001      	str	r0, [sp, #4]
    uint32 Elapsed = 0U;
    2056:	2300      	movs	r3, #0
    2058:	9303      	str	r3, [sp, #12]
    uint32 CoreId = OsIfCoreID();
    205a:	2300      	movs	r3, #0
    205c:	9302      	str	r3, [sp, #8]
        *CurrentRef = CurrentVal;
        (void)CoreId;
#elif defined(USING_OS_FREERTOS) || defined(USING_OS_BAREMETAL)
        /* FreeRTOS and Baremetal*/
        (void)CoreId;
        Elapsed = Trusted_OsIf_Timer_System_Internal_GetElapsed(CurrentRef);
    205e:	9801      	ldr	r0, [sp, #4]
    2060:	f000 f864 	bl	212c <OsIf_Timer_System_Internal_GetElapsed>
    2064:	9003      	str	r0, [sp, #12]
#endif
    }

    return Elapsed;
    2066:	9b03      	ldr	r3, [sp, #12]
}
    2068:	4618      	mov	r0, r3
    206a:	b005      	add	sp, #20
    206c:	f85d fb04 	ldr.w	pc, [sp], #4

00002070 <OsIf_Timer_System_SetTimerFrequency>:
 * Function Name : OsIf_Timer_System_SetTimerFrequency.
 * Description   : Set system timer frequency.
 * 
 *END**************************************************************************/
void OsIf_Timer_System_SetTimerFrequency(uint32 Freq)
{
    2070:	b084      	sub	sp, #16
    2072:	9001      	str	r0, [sp, #4]
    uint32 CoreId = OsIfCoreID();
    2074:	2300      	movs	r3, #0
    2076:	9303      	str	r3, [sp, #12]
        (void)CoreId;
        (void)Freq;
        /* As of 2.6.0: "The frequency of this counter is required to be steady over time" */
#elif defined(USING_OS_FREERTOS) || defined(USING_OS_BAREMETAL)
        /* FreeRTOS and Baremetal*/
        OsIf_au32InternalFrequencies[CoreId] = Freq;
    2078:	4903      	ldr	r1, [pc, #12]	; (2088 <OsIf_Timer_System_SetTimerFrequency+0x18>)
    207a:	9b03      	ldr	r3, [sp, #12]
    207c:	9a01      	ldr	r2, [sp, #4]
    207e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif
    }
}
    2082:	bf00      	nop
    2084:	b004      	add	sp, #16
    2086:	4770      	bx	lr
    2088:	1fff8b38 	.word	0x1fff8b38

0000208c <OsIf_Timer_System_MicrosToTicks>:
 * Function Name : OsIf_Timer_System_MicrosToTicks.
 * Description   : Convert micro second to ticks based on system timer frequency.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_MicrosToTicks(uint32 Micros)
{
    208c:	b5f0      	push	{r4, r5, r6, r7, lr}
    208e:	b087      	sub	sp, #28
    2090:	9001      	str	r0, [sp, #4]
    uint64 interim;
    uint32 ticks = 0U;
    2092:	2100      	movs	r1, #0
    2094:	9105      	str	r1, [sp, #20]
    uint32 CoreId = OsIfCoreID();
    2096:	2100      	movs	r1, #0
    2098:	9104      	str	r1, [sp, #16]
    #endif /* defined(USING_OS_AUTOSAROS) */
    }
    else
#endif /* (STD_ON == OSIF_DEV_ERROR_DETECT)  */
    {
        interim = Micros * (uint64)OsIf_au32InternalFrequencies[CoreId];
    209a:	9901      	ldr	r1, [sp, #4]
    209c:	2000      	movs	r0, #0
    209e:	460e      	mov	r6, r1
    20a0:	4607      	mov	r7, r0
    20a2:	4812      	ldr	r0, [pc, #72]	; (20ec <OsIf_Timer_System_MicrosToTicks+0x60>)
    20a4:	9904      	ldr	r1, [sp, #16]
    20a6:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
    20aa:	2000      	movs	r0, #0
    20ac:	460c      	mov	r4, r1
    20ae:	4605      	mov	r5, r0
    20b0:	fb04 f007 	mul.w	r0, r4, r7
    20b4:	fb06 f105 	mul.w	r1, r6, r5
    20b8:	4401      	add	r1, r0
    20ba:	fba6 2304 	umull	r2, r3, r6, r4
    20be:	4419      	add	r1, r3
    20c0:	460b      	mov	r3, r1
    20c2:	e9cd 2302 	strd	r2, r3, [sp, #8]
    20c6:	e9cd 2302 	strd	r2, r3, [sp, #8]
        interim /= 1000000u;
    20ca:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    20ce:	4a08      	ldr	r2, [pc, #32]	; (20f0 <OsIf_Timer_System_MicrosToTicks+0x64>)
    20d0:	f04f 0300 	mov.w	r3, #0
    20d4:	f7fe fa66 	bl	5a4 <__aeabi_uldivmod>
    20d8:	4602      	mov	r2, r0
    20da:	460b      	mov	r3, r1
    20dc:	e9cd 2302 	strd	r2, r3, [sp, #8]
        /* check that computed value fits in 32 bits */
        OSIF_DEV_ASSERT(interim <= 0xFFFFFFFFu);
        ticks = (uint32)(interim & 0xFFFFFFFFu);
    20e0:	9b02      	ldr	r3, [sp, #8]
    20e2:	9305      	str	r3, [sp, #20]
    }

    return ticks;
    20e4:	9b05      	ldr	r3, [sp, #20]
}
    20e6:	4618      	mov	r0, r3
    20e8:	b007      	add	sp, #28
    20ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
    20ec:	1fff8b38 	.word	0x1fff8b38
    20f0:	000f4240 	.word	0x000f4240

000020f4 <OsIf_Timer_System_Internal_Init>:
 * Function Name : OsIf_Timer_System_Internal_Init.
 * Description   : Initialize systick timer.
 * 
 *END**************************************************************************/
void OsIf_Timer_System_Internal_Init(uint32 SystemCounterFreq)
{
    20f4:	b082      	sub	sp, #8
    20f6:	9001      	str	r0, [sp, #4]
    (void)SystemCounterFreq;

    /* For Cortex-M0 devices the systick counter is initialized with an undefined
     value, so make sure to initialize it to 0 before starting */
    S32_SysTick->CSRr = S32_SysTick_CSR_ENABLE(0u);
    20f8:	4b07      	ldr	r3, [pc, #28]	; (2118 <OsIf_Timer_System_Internal_Init+0x24>)
    20fa:	2200      	movs	r2, #0
    20fc:	601a      	str	r2, [r3, #0]
    S32_SysTick->RVR = S32_SysTick_RVR_RELOAD(SYSTICK_MAX);
    20fe:	4b06      	ldr	r3, [pc, #24]	; (2118 <OsIf_Timer_System_Internal_Init+0x24>)
    2100:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
    2104:	605a      	str	r2, [r3, #4]
    S32_SysTick->CVR = S32_SysTick_CVR_CURRENT(0U);
    2106:	4b04      	ldr	r3, [pc, #16]	; (2118 <OsIf_Timer_System_Internal_Init+0x24>)
    2108:	2200      	movs	r2, #0
    210a:	609a      	str	r2, [r3, #8]
    S32_SysTick->CSRr = S32_SysTick_CSR_ENABLE(1u) | S32_SysTick_CSR_TICKINT(0u) | S32_SysTick_CSR_CLKSOURCE(1u);
    210c:	4b02      	ldr	r3, [pc, #8]	; (2118 <OsIf_Timer_System_Internal_Init+0x24>)
    210e:	2205      	movs	r2, #5
    2110:	601a      	str	r2, [r3, #0]
}
    2112:	bf00      	nop
    2114:	b002      	add	sp, #8
    2116:	4770      	bx	lr
    2118:	e000e010 	.word	0xe000e010

0000211c <OsIf_Timer_System_Internal_GetCounter>:
 * Description   : Get systick counter value.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_Internal_GetCounter(void)
{
    return SYSTICK_GET_COUNTER();
    211c:	4b02      	ldr	r3, [pc, #8]	; (2128 <OsIf_Timer_System_Internal_GetCounter+0xc>)
    211e:	689b      	ldr	r3, [r3, #8]
    2120:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
}
    2124:	4618      	mov	r0, r3
    2126:	4770      	bx	lr
    2128:	e000e010 	.word	0xe000e010

0000212c <OsIf_Timer_System_Internal_GetElapsed>:
 * Function Name : OsIf_Timer_System_Internal_GetElapsed.
 * Description   : Get systick elapsed value.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_Internal_GetElapsed(uint32 * const CurrentRef)
{
    212c:	b084      	sub	sp, #16
    212e:	9001      	str	r0, [sp, #4]
    uint32 CurrentVal = SYSTICK_GET_COUNTER();
    2130:	4b10      	ldr	r3, [pc, #64]	; (2174 <OsIf_Timer_System_Internal_GetElapsed+0x48>)
    2132:	689b      	ldr	r3, [r3, #8]
    2134:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    2138:	9302      	str	r3, [sp, #8]
    uint32 dif = 0U;
    213a:	2300      	movs	r3, #0
    213c:	9303      	str	r3, [sp, #12]

    if (SYSTICK_OVERFLOWED((CurrentVal), (*CurrentRef)))
    213e:	9b01      	ldr	r3, [sp, #4]
    2140:	681b      	ldr	r3, [r3, #0]
    2142:	9a02      	ldr	r2, [sp, #8]
    2144:	429a      	cmp	r2, r3
    2146:	d909      	bls.n	215c <OsIf_Timer_System_Internal_GetElapsed+0x30>
    {
        /* overflow occurred */
        dif = SYSTICK_DELTA_OUTER(CurrentVal, *CurrentRef, SYSTICK_MAX);
    2148:	9b01      	ldr	r3, [sp, #4]
    214a:	681a      	ldr	r2, [r3, #0]
    214c:	9b02      	ldr	r3, [sp, #8]
    214e:	1ad3      	subs	r3, r2, r3
    2150:	f103 13ff 	add.w	r3, r3, #16711935	; 0xff00ff
    2154:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
    2158:	9303      	str	r3, [sp, #12]
    215a:	e004      	b.n	2166 <OsIf_Timer_System_Internal_GetElapsed+0x3a>
    }
    else
    {
        /* overflow did not occur */
        dif = SYSTICK_DELTA_INNER(*CurrentRef, CurrentVal);
    215c:	9b01      	ldr	r3, [sp, #4]
    215e:	681a      	ldr	r2, [r3, #0]
    2160:	9b02      	ldr	r3, [sp, #8]
    2162:	1ad3      	subs	r3, r2, r3
    2164:	9303      	str	r3, [sp, #12]
    }
    *CurrentRef = CurrentVal;
    2166:	9b01      	ldr	r3, [sp, #4]
    2168:	9a02      	ldr	r2, [sp, #8]
    216a:	601a      	str	r2, [r3, #0]

    return dif;
    216c:	9b03      	ldr	r3, [sp, #12]
}
    216e:	4618      	mov	r0, r3
    2170:	b004      	add	sp, #16
    2172:	4770      	bx	lr
    2174:	e000e010 	.word	0xe000e010

00002178 <Clock_Ip_NotificatonsEmptyCallback>:
 *
 *END**************************************************************************/
static void Clock_Ip_NotificatonsEmptyCallback( Clock_Ip_NotificationType Notification,
                                                Clock_Ip_NameType ClockName
                                               )
{
    2178:	b082      	sub	sp, #8
    217a:	9001      	str	r0, [sp, #4]
    217c:	9100      	str	r1, [sp, #0]
    /* No implementation */
    (void)Notification;
    (void)ClockName;
}
    217e:	bf00      	nop
    2180:	b002      	add	sp, #8
    2182:	4770      	bx	lr

00002184 <Clock_Ip_UpdateDriverContext>:
 * Function Name : Clock_Ip_UpdateDriverContext.
 * Description   : Updates context of the driver, internal memory, clock objects.
 *
 *END**************************************************************************/
static void Clock_Ip_UpdateDriverContext(Clock_Ip_ClockConfigType const * Config)
{
    2184:	b500      	push	{lr}
    2186:	b085      	sub	sp, #20
    2188:	9001      	str	r0, [sp, #4]
    uint8 Index;
    (void)Config;
    Clock_Ip_bSentFromUpdateDriverContext = TRUE;
    218a:	4b24      	ldr	r3, [pc, #144]	; (221c <Clock_Ip_UpdateDriverContext+0x98>)
    218c:	2201      	movs	r2, #1
    218e:	701a      	strb	r2, [r3, #0]
    /* Initialize clock objects */
    Clock_Ip_Command(Clock_Ip_pxConfig, CLOCK_IP_INITIALIZE_CLOCK_OBJECTS_COMMAND);
    2190:	4b23      	ldr	r3, [pc, #140]	; (2220 <Clock_Ip_UpdateDriverContext+0x9c>)
    2192:	681b      	ldr	r3, [r3, #0]
    2194:	2102      	movs	r1, #2
    2196:	4618      	mov	r0, r3
    2198:	f003 fc32 	bl	5a00 <Clock_Ip_Command>

    for (Index = 0U; Index < Config->ExtClksCount; Index++)    /* Set external signal frequency. */
    219c:	2300      	movs	r3, #0
    219e:	f88d 300f 	strb.w	r3, [sp, #15]
    21a2:	e015      	b.n	21d0 <Clock_Ip_UpdateDriverContext+0x4c>
    {
        Clock_Ip_SetExternalSignalFrequency(Config->ExtClks[Index].Name, Config->ExtClks[Index].Value);
    21a4:	f89d 300f 	ldrb.w	r3, [sp, #15]
    21a8:	9a01      	ldr	r2, [sp, #4]
    21aa:	334a      	adds	r3, #74	; 0x4a
    21ac:	00db      	lsls	r3, r3, #3
    21ae:	4413      	add	r3, r2
    21b0:	6858      	ldr	r0, [r3, #4]
    21b2:	f89d 300f 	ldrb.w	r3, [sp, #15]
    21b6:	9a01      	ldr	r2, [sp, #4]
    21b8:	334a      	adds	r3, #74	; 0x4a
    21ba:	00db      	lsls	r3, r3, #3
    21bc:	4413      	add	r3, r2
    21be:	689b      	ldr	r3, [r3, #8]
    21c0:	4619      	mov	r1, r3
    21c2:	f001 fadc 	bl	377e <Clock_Ip_SetExternalSignalFrequency>
    for (Index = 0U; Index < Config->ExtClksCount; Index++)    /* Set external signal frequency. */
    21c6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    21ca:	3301      	adds	r3, #1
    21cc:	f88d 300f 	strb.w	r3, [sp, #15]
    21d0:	9b01      	ldr	r3, [sp, #4]
    21d2:	7bdb      	ldrb	r3, [r3, #15]
    21d4:	f89d 200f 	ldrb.w	r2, [sp, #15]
    21d8:	429a      	cmp	r2, r3
    21da:	d3e3      	bcc.n	21a4 <Clock_Ip_UpdateDriverContext+0x20>
    }

    /* Call empty callbacks */
    Clock_Ip_CallEmptyCallbacks();
    21dc:	f000 f824 	bl	2228 <Clock_Ip_CallEmptyCallbacks>

#if CLOCK_IP_CONFIGURED_FREQUENCIES_COUNT > 0U

    for (Index = 1U; Index < Config->ConfigureFrequenciesCount; Index++)
    21e0:	2301      	movs	r3, #1
    21e2:	f88d 300f 	strb.w	r3, [sp, #15]
    21e6:	e00e      	b.n	2206 <Clock_Ip_UpdateDriverContext+0x82>
    {
        Clock_Ip_FreqIds[Config->ConfiguredFrequencies[Index].Name] = Index;
    21e8:	f89d 200f 	ldrb.w	r2, [sp, #15]
    21ec:	9b01      	ldr	r3, [sp, #4]
    21ee:	327e      	adds	r2, #126	; 0x7e
    21f0:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    21f4:	490b      	ldr	r1, [pc, #44]	; (2224 <Clock_Ip_UpdateDriverContext+0xa0>)
    21f6:	f89d 200f 	ldrb.w	r2, [sp, #15]
    21fa:	54ca      	strb	r2, [r1, r3]
    for (Index = 1U; Index < Config->ConfigureFrequenciesCount; Index++)
    21fc:	f89d 300f 	ldrb.w	r3, [sp, #15]
    2200:	3301      	adds	r3, #1
    2202:	f88d 300f 	strb.w	r3, [sp, #15]
    2206:	9b01      	ldr	r3, [sp, #4]
    2208:	7cdb      	ldrb	r3, [r3, #19]
    220a:	f89d 200f 	ldrb.w	r2, [sp, #15]
    220e:	429a      	cmp	r2, r3
    2210:	d3ea      	bcc.n	21e8 <Clock_Ip_UpdateDriverContext+0x64>
    }

#endif /* CLOCK_IP_CONFIGURED_FREQUENCIES_COUNT > 0U */
}
    2212:	bf00      	nop
    2214:	bf00      	nop
    2216:	b005      	add	sp, #20
    2218:	f85d fb04 	ldr.w	pc, [sp], #4
    221c:	1fff8b10 	.word	0x1fff8b10
    2220:	1fff8b3c 	.word	0x1fff8b3c
    2224:	1fff8b48 	.word	0x1fff8b48

00002228 <Clock_Ip_CallEmptyCallbacks>:

#define CLOCK_IP_NO_CALLBACK 0U

/* Call empty callbacks to improve CCOV*/
static void Clock_Ip_CallEmptyCallbacks(void)
{
    2228:	b508      	push	{r3, lr}

    if (FALSE == FunctionWasCalled)
    222a:	4b23      	ldr	r3, [pc, #140]	; (22b8 <Clock_Ip_CallEmptyCallbacks+0x90>)
    222c:	781b      	ldrb	r3, [r3, #0]
    222e:	f083 0301 	eor.w	r3, r3, #1
    2232:	b2db      	uxtb	r3, r3
    2234:	2b00      	cmp	r3, #0
    2236:	d03d      	beq.n	22b4 <Clock_Ip_CallEmptyCallbacks+0x8c>
    {
        FunctionWasCalled = TRUE;
    2238:	4b1f      	ldr	r3, [pc, #124]	; (22b8 <Clock_Ip_CallEmptyCallbacks+0x90>)
    223a:	2201      	movs	r2, #1
    223c:	701a      	strb	r2, [r3, #0]

        Clock_Ip_axCmuCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR, 0U);
    223e:	4b1f      	ldr	r3, [pc, #124]	; (22bc <Clock_Ip_CallEmptyCallbacks+0x94>)
    2240:	685b      	ldr	r3, [r3, #4]
    2242:	2100      	movs	r1, #0
    2244:	2000      	movs	r0, #0
    2246:	4798      	blx	r3
        Clock_Ip_axCmuCallbacks[CLOCK_IP_NO_CALLBACK].Disable(RESERVED_CLK);
    2248:	4b1c      	ldr	r3, [pc, #112]	; (22bc <Clock_Ip_CallEmptyCallbacks+0x94>)
    224a:	689b      	ldr	r3, [r3, #8]
    224c:	2057      	movs	r0, #87	; 0x57
    224e:	4798      	blx	r3

        Clock_Ip_axDividerCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    2250:	4b1b      	ldr	r3, [pc, #108]	; (22c0 <Clock_Ip_CallEmptyCallbacks+0x98>)
    2252:	681b      	ldr	r3, [r3, #0]
    2254:	2000      	movs	r0, #0
    2256:	4798      	blx	r3

        Clock_Ip_axDividerTriggerCallbacks[CLOCK_IP_NO_CALLBACK].Configure(NULL_PTR);
    2258:	4b1a      	ldr	r3, [pc, #104]	; (22c4 <Clock_Ip_CallEmptyCallbacks+0x9c>)
    225a:	681b      	ldr	r3, [r3, #0]
    225c:	2000      	movs	r0, #0
    225e:	4798      	blx	r3

        Clock_Ip_axExtOscCallbacks[CLOCK_IP_NO_CALLBACK].Reset(NULL_PTR);
    2260:	4b19      	ldr	r3, [pc, #100]	; (22c8 <Clock_Ip_CallEmptyCallbacks+0xa0>)
    2262:	681b      	ldr	r3, [r3, #0]
    2264:	2000      	movs	r0, #0
    2266:	4798      	blx	r3

        Clock_Ip_axFracDivCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    2268:	4b18      	ldr	r3, [pc, #96]	; (22cc <Clock_Ip_CallEmptyCallbacks+0xa4>)
    226a:	685b      	ldr	r3, [r3, #4]
    226c:	2000      	movs	r0, #0
    226e:	4798      	blx	r3
        (void)Clock_Ip_axFracDivCallbacks[CLOCK_IP_NO_CALLBACK].Complete(RESERVED_CLK);
    2270:	4b16      	ldr	r3, [pc, #88]	; (22cc <Clock_Ip_CallEmptyCallbacks+0xa4>)
    2272:	689b      	ldr	r3, [r3, #8]
    2274:	2057      	movs	r0, #87	; 0x57
    2276:	4798      	blx	r3

        Clock_Ip_axGateCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    2278:	4b15      	ldr	r3, [pc, #84]	; (22d0 <Clock_Ip_CallEmptyCallbacks+0xa8>)
    227a:	681b      	ldr	r3, [r3, #0]
    227c:	2000      	movs	r0, #0
    227e:	4798      	blx	r3
        Clock_Ip_axGateCallbacks[CLOCK_IP_NO_CALLBACK].Update(RESERVED_CLK,FALSE);
    2280:	4b13      	ldr	r3, [pc, #76]	; (22d0 <Clock_Ip_CallEmptyCallbacks+0xa8>)
    2282:	685b      	ldr	r3, [r3, #4]
    2284:	2100      	movs	r1, #0
    2286:	2057      	movs	r0, #87	; 0x57
    2288:	4798      	blx	r3

        Clock_Ip_axIntOscCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    228a:	4b12      	ldr	r3, [pc, #72]	; (22d4 <Clock_Ip_CallEmptyCallbacks+0xac>)
    228c:	681b      	ldr	r3, [r3, #0]
    228e:	2000      	movs	r0, #0
    2290:	4798      	blx	r3

        Clock_Ip_axPllCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    2292:	4b11      	ldr	r3, [pc, #68]	; (22d8 <Clock_Ip_CallEmptyCallbacks+0xb0>)
    2294:	685b      	ldr	r3, [r3, #4]
    2296:	2000      	movs	r0, #0
    2298:	4798      	blx	r3
        (void)Clock_Ip_axPllCallbacks[CLOCK_IP_NO_CALLBACK].Complete(RESERVED_CLK);
    229a:	4b0f      	ldr	r3, [pc, #60]	; (22d8 <Clock_Ip_CallEmptyCallbacks+0xb0>)
    229c:	689b      	ldr	r3, [r3, #8]
    229e:	2057      	movs	r0, #87	; 0x57
    22a0:	4798      	blx	r3

        Clock_Ip_axSelectorCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    22a2:	4b0e      	ldr	r3, [pc, #56]	; (22dc <Clock_Ip_CallEmptyCallbacks+0xb4>)
    22a4:	685b      	ldr	r3, [r3, #4]
    22a6:	2000      	movs	r0, #0
    22a8:	4798      	blx	r3

        Clock_Ip_axPcfsCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR, 0U);
    22aa:	4b0d      	ldr	r3, [pc, #52]	; (22e0 <Clock_Ip_CallEmptyCallbacks+0xb8>)
    22ac:	681b      	ldr	r3, [r3, #0]
    22ae:	2100      	movs	r1, #0
    22b0:	2000      	movs	r0, #0
    22b2:	4798      	blx	r3
    }
}
    22b4:	bf00      	nop
    22b6:	bd08      	pop	{r3, pc}
    22b8:	1fff8b40 	.word	0x1fff8b40
    22bc:	000185a8 	.word	0x000185a8
    22c0:	000184bc 	.word	0x000184bc
    22c4:	000184f8 	.word	0x000184f8
    22c8:	00018500 	.word	0x00018500
    22cc:	00018528 	.word	0x00018528
    22d0:	00018534 	.word	0x00018534
    22d4:	0001856c 	.word	0x0001856c
    22d8:	000185b8 	.word	0x000185b8
    22dc:	000185e4 	.word	0x000185e4
    22e0:	000185e0 	.word	0x000185e0

000022e4 <Clock_Ip_ResetClockConfiguration>:

static void Clock_Ip_ResetClockConfiguration(Clock_Ip_ClockConfigType const * Config)
{
    22e4:	b500      	push	{lr}
    22e6:	b085      	sub	sp, #20
    22e8:	9001      	str	r0, [sp, #4]
    uint32 CallbackIndex;
    uint32 Index;

    for (Index = Config->SelectorsCount ; Index > 0U; Index--)    /* Ramp down all selectors from configuration to SAFE_CLOCK */
    22ea:	9b01      	ldr	r3, [sp, #4]
    22ec:	7adb      	ldrb	r3, [r3, #11]
    22ee:	9303      	str	r3, [sp, #12]
    22f0:	e01f      	b.n	2332 <Clock_Ip_ResetClockConfiguration+0x4e>
    {
        CallbackIndex = Clock_Ip_au8SelectorCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Selectors[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    22f2:	9b03      	ldr	r3, [sp, #12]
    22f4:	1e5a      	subs	r2, r3, #1
    22f6:	9b01      	ldr	r3, [sp, #4]
    22f8:	320d      	adds	r2, #13
    22fa:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
    22fe:	495a      	ldr	r1, [pc, #360]	; (2468 <Clock_Ip_ResetClockConfiguration+0x184>)
    2300:	4613      	mov	r3, r2
    2302:	00db      	lsls	r3, r3, #3
    2304:	4413      	add	r3, r2
    2306:	440b      	add	r3, r1
    2308:	3301      	adds	r3, #1
    230a:	781b      	ldrb	r3, [r3, #0]
    230c:	461a      	mov	r2, r3
    230e:	4b57      	ldr	r3, [pc, #348]	; (246c <Clock_Ip_ResetClockConfiguration+0x188>)
    2310:	5c9b      	ldrb	r3, [r3, r2]
    2312:	9302      	str	r3, [sp, #8]
        Clock_Ip_axSelectorCallbacks[CallbackIndex].Reset(&Config->Selectors[Index - 1U]);
    2314:	4a56      	ldr	r2, [pc, #344]	; (2470 <Clock_Ip_ResetClockConfiguration+0x18c>)
    2316:	9b02      	ldr	r3, [sp, #8]
    2318:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    231c:	9a03      	ldr	r2, [sp, #12]
    231e:	3a01      	subs	r2, #1
    2320:	320d      	adds	r2, #13
    2322:	00d2      	lsls	r2, r2, #3
    2324:	9901      	ldr	r1, [sp, #4]
    2326:	440a      	add	r2, r1
    2328:	4610      	mov	r0, r2
    232a:	4798      	blx	r3
    for (Index = Config->SelectorsCount ; Index > 0U; Index--)    /* Ramp down all selectors from configuration to SAFE_CLOCK */
    232c:	9b03      	ldr	r3, [sp, #12]
    232e:	3b01      	subs	r3, #1
    2330:	9303      	str	r3, [sp, #12]
    2332:	9b03      	ldr	r3, [sp, #12]
    2334:	2b00      	cmp	r3, #0
    2336:	d1dc      	bne.n	22f2 <Clock_Ip_ResetClockConfiguration+0xe>
    }

    for (Index = Config->FracDivsCount; Index > 0U; Index--)    /* Put in reset state all fractional dividers from configuration */
    2338:	9b01      	ldr	r3, [sp, #4]
    233a:	7b9b      	ldrb	r3, [r3, #14]
    233c:	9303      	str	r3, [sp, #12]
    233e:	e026      	b.n	238e <Clock_Ip_ResetClockConfiguration+0xaa>
    {
        CallbackIndex = Clock_Ip_au8FractionalDividerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->FracDivs[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    2340:	9b03      	ldr	r3, [sp, #12]
    2342:	3b01      	subs	r3, #1
    2344:	9a01      	ldr	r2, [sp, #4]
    2346:	3324      	adds	r3, #36	; 0x24
    2348:	011b      	lsls	r3, r3, #4
    234a:	4413      	add	r3, r2
    234c:	3304      	adds	r3, #4
    234e:	681a      	ldr	r2, [r3, #0]
    2350:	4945      	ldr	r1, [pc, #276]	; (2468 <Clock_Ip_ResetClockConfiguration+0x184>)
    2352:	4613      	mov	r3, r2
    2354:	00db      	lsls	r3, r3, #3
    2356:	4413      	add	r3, r2
    2358:	440b      	add	r3, r1
    235a:	3301      	adds	r3, #1
    235c:	781b      	ldrb	r3, [r3, #0]
    235e:	461a      	mov	r2, r3
    2360:	4b44      	ldr	r3, [pc, #272]	; (2474 <Clock_Ip_ResetClockConfiguration+0x190>)
    2362:	5c9b      	ldrb	r3, [r3, r2]
    2364:	9302      	str	r3, [sp, #8]
        Clock_Ip_axFracDivCallbacks[CallbackIndex].Reset(&Config->FracDivs[Index - 1U]);
    2366:	4944      	ldr	r1, [pc, #272]	; (2478 <Clock_Ip_ResetClockConfiguration+0x194>)
    2368:	9a02      	ldr	r2, [sp, #8]
    236a:	4613      	mov	r3, r2
    236c:	005b      	lsls	r3, r3, #1
    236e:	4413      	add	r3, r2
    2370:	009b      	lsls	r3, r3, #2
    2372:	440b      	add	r3, r1
    2374:	681b      	ldr	r3, [r3, #0]
    2376:	9a03      	ldr	r2, [sp, #12]
    2378:	3a01      	subs	r2, #1
    237a:	3224      	adds	r2, #36	; 0x24
    237c:	0112      	lsls	r2, r2, #4
    237e:	9901      	ldr	r1, [sp, #4]
    2380:	440a      	add	r2, r1
    2382:	3204      	adds	r2, #4
    2384:	4610      	mov	r0, r2
    2386:	4798      	blx	r3
    for (Index = Config->FracDivsCount; Index > 0U; Index--)    /* Put in reset state all fractional dividers from configuration */
    2388:	9b03      	ldr	r3, [sp, #12]
    238a:	3b01      	subs	r3, #1
    238c:	9303      	str	r3, [sp, #12]
    238e:	9b03      	ldr	r3, [sp, #12]
    2390:	2b00      	cmp	r3, #0
    2392:	d1d5      	bne.n	2340 <Clock_Ip_ResetClockConfiguration+0x5c>
    }

    for (Index = Config->PllsCount; Index > 0U; Index--)       /* Power down all plls from configuration */
    2394:	9b01      	ldr	r3, [sp, #4]
    2396:	7a9b      	ldrb	r3, [r3, #10]
    2398:	9303      	str	r3, [sp, #12]
    239a:	e02a      	b.n	23f2 <Clock_Ip_ResetClockConfiguration+0x10e>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Plls[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    239c:	9b03      	ldr	r3, [sp, #12]
    239e:	1e5a      	subs	r2, r3, #1
    23a0:	9901      	ldr	r1, [sp, #4]
    23a2:	4613      	mov	r3, r2
    23a4:	009b      	lsls	r3, r3, #2
    23a6:	4413      	add	r3, r2
    23a8:	00db      	lsls	r3, r3, #3
    23aa:	440b      	add	r3, r1
    23ac:	3340      	adds	r3, #64	; 0x40
    23ae:	681a      	ldr	r2, [r3, #0]
    23b0:	492d      	ldr	r1, [pc, #180]	; (2468 <Clock_Ip_ResetClockConfiguration+0x184>)
    23b2:	4613      	mov	r3, r2
    23b4:	00db      	lsls	r3, r3, #3
    23b6:	4413      	add	r3, r2
    23b8:	440b      	add	r3, r1
    23ba:	3301      	adds	r3, #1
    23bc:	781b      	ldrb	r3, [r3, #0]
    23be:	461a      	mov	r2, r3
    23c0:	4b2e      	ldr	r3, [pc, #184]	; (247c <Clock_Ip_ResetClockConfiguration+0x198>)
    23c2:	5c9b      	ldrb	r3, [r3, r2]
    23c4:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPllCallbacks[CallbackIndex].Reset(&Config->Plls[Index - 1U]);
    23c6:	492e      	ldr	r1, [pc, #184]	; (2480 <Clock_Ip_ResetClockConfiguration+0x19c>)
    23c8:	9a02      	ldr	r2, [sp, #8]
    23ca:	4613      	mov	r3, r2
    23cc:	009b      	lsls	r3, r3, #2
    23ce:	4413      	add	r3, r2
    23d0:	009b      	lsls	r3, r3, #2
    23d2:	440b      	add	r3, r1
    23d4:	6819      	ldr	r1, [r3, #0]
    23d6:	9b03      	ldr	r3, [sp, #12]
    23d8:	1e5a      	subs	r2, r3, #1
    23da:	4613      	mov	r3, r2
    23dc:	009b      	lsls	r3, r3, #2
    23de:	4413      	add	r3, r2
    23e0:	00db      	lsls	r3, r3, #3
    23e2:	3340      	adds	r3, #64	; 0x40
    23e4:	9a01      	ldr	r2, [sp, #4]
    23e6:	4413      	add	r3, r2
    23e8:	4618      	mov	r0, r3
    23ea:	4788      	blx	r1
    for (Index = Config->PllsCount; Index > 0U; Index--)       /* Power down all plls from configuration */
    23ec:	9b03      	ldr	r3, [sp, #12]
    23ee:	3b01      	subs	r3, #1
    23f0:	9303      	str	r3, [sp, #12]
    23f2:	9b03      	ldr	r3, [sp, #12]
    23f4:	2b00      	cmp	r3, #0
    23f6:	d1d1      	bne.n	239c <Clock_Ip_ResetClockConfiguration+0xb8>
    }

    for (Index = Config->XoscsCount; Index > 0U; Index--)     /* Power down all xoscs from configuration */
    23f8:	9b01      	ldr	r3, [sp, #4]
    23fa:	7a5b      	ldrb	r3, [r3, #9]
    23fc:	9303      	str	r3, [sp, #12]
    23fe:	e02b      	b.n	2458 <Clock_Ip_ResetClockConfiguration+0x174>
    {
        CallbackIndex = Clock_Ip_au8XoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Xoscs[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    2400:	9b03      	ldr	r3, [sp, #12]
    2402:	1e5a      	subs	r2, r3, #1
    2404:	9901      	ldr	r1, [sp, #4]
    2406:	4613      	mov	r3, r2
    2408:	009b      	lsls	r3, r3, #2
    240a:	4413      	add	r3, r2
    240c:	009b      	lsls	r3, r3, #2
    240e:	440b      	add	r3, r1
    2410:	332c      	adds	r3, #44	; 0x2c
    2412:	681a      	ldr	r2, [r3, #0]
    2414:	4914      	ldr	r1, [pc, #80]	; (2468 <Clock_Ip_ResetClockConfiguration+0x184>)
    2416:	4613      	mov	r3, r2
    2418:	00db      	lsls	r3, r3, #3
    241a:	4413      	add	r3, r2
    241c:	440b      	add	r3, r1
    241e:	3301      	adds	r3, #1
    2420:	781b      	ldrb	r3, [r3, #0]
    2422:	461a      	mov	r2, r3
    2424:	4b17      	ldr	r3, [pc, #92]	; (2484 <Clock_Ip_ResetClockConfiguration+0x1a0>)
    2426:	5c9b      	ldrb	r3, [r3, r2]
    2428:	9302      	str	r3, [sp, #8]
        Clock_Ip_axExtOscCallbacks[CallbackIndex].Reset(&Config->Xoscs[Index - 1U]);
    242a:	4917      	ldr	r1, [pc, #92]	; (2488 <Clock_Ip_ResetClockConfiguration+0x1a4>)
    242c:	9a02      	ldr	r2, [sp, #8]
    242e:	4613      	mov	r3, r2
    2430:	009b      	lsls	r3, r3, #2
    2432:	4413      	add	r3, r2
    2434:	009b      	lsls	r3, r3, #2
    2436:	440b      	add	r3, r1
    2438:	6819      	ldr	r1, [r3, #0]
    243a:	9b03      	ldr	r3, [sp, #12]
    243c:	1e5a      	subs	r2, r3, #1
    243e:	4613      	mov	r3, r2
    2440:	009b      	lsls	r3, r3, #2
    2442:	4413      	add	r3, r2
    2444:	009b      	lsls	r3, r3, #2
    2446:	3328      	adds	r3, #40	; 0x28
    2448:	9a01      	ldr	r2, [sp, #4]
    244a:	4413      	add	r3, r2
    244c:	3304      	adds	r3, #4
    244e:	4618      	mov	r0, r3
    2450:	4788      	blx	r1
    for (Index = Config->XoscsCount; Index > 0U; Index--)     /* Power down all xoscs from configuration */
    2452:	9b03      	ldr	r3, [sp, #12]
    2454:	3b01      	subs	r3, #1
    2456:	9303      	str	r3, [sp, #12]
    2458:	9b03      	ldr	r3, [sp, #12]
    245a:	2b00      	cmp	r3, #0
    245c:	d1d0      	bne.n	2400 <Clock_Ip_ResetClockConfiguration+0x11c>
    }
}
    245e:	bf00      	nop
    2460:	bf00      	nop
    2462:	b005      	add	sp, #20
    2464:	f85d fb04 	ldr.w	pc, [sp], #4
    2468:	00017fac 	.word	0x00017fac
    246c:	00017f7c 	.word	0x00017f7c
    2470:	000185e4 	.word	0x000185e4
    2474:	00017f5c 	.word	0x00017f5c
    2478:	00018528 	.word	0x00018528
    247c:	00017f6c 	.word	0x00017f6c
    2480:	000185b8 	.word	0x000185b8
    2484:	00017f2c 	.word	0x00017f2c
    2488:	00018500 	.word	0x00018500

0000248c <Clock_Ip_Init>:
 *                 enabled, for example, if the external oscillator is used, please setup correctly.
 *
 * @implements Clock_Ip_Init_Activity
 * END**********************************************************************************/
Clock_Ip_StatusType Clock_Ip_Init(Clock_Ip_ClockConfigType const * Config)
{
    248c:	b500      	push	{lr}
    248e:	b085      	sub	sp, #20
    2490:	9001      	str	r0, [sp, #4]
    Clock_Ip_StatusType ClockStatus = CLOCK_IP_ERROR;
    2492:	2301      	movs	r3, #1
    2494:	9303      	str	r3, [sp, #12]
    Clock_Ip_Command(Config, CLOCK_IP_SET_USER_ACCESS_ALLOWED_COMMAND);
  #endif
#endif
    CLOCK_IP_DEV_ASSERT(NULL_PTR != Config);

    Clock_Ip_InitClock(Config);
    2496:	9801      	ldr	r0, [sp, #4]
    2498:	f000 f818 	bl	24cc <Clock_Ip_InitClock>

    if (DriverContext.ClockTreeIsConsumingPll)
    249c:	4b0a      	ldr	r3, [pc, #40]	; (24c8 <Clock_Ip_Init+0x3c>)
    249e:	781b      	ldrb	r3, [r3, #0]
    24a0:	2b00      	cmp	r3, #0
    24a2:	d00a      	beq.n	24ba <Clock_Ip_Init+0x2e>
    {
        PllStatus = Clock_Ip_GetPllStatus();
    24a4:	f000 fb74 	bl	2b90 <Clock_Ip_GetPllStatus>
    24a8:	9002      	str	r0, [sp, #8]
        if (CLOCK_IP_PLL_LOCKED == PllStatus)
    24aa:	9b02      	ldr	r3, [sp, #8]
    24ac:	2b00      	cmp	r3, #0
    24ae:	d106      	bne.n	24be <Clock_Ip_Init+0x32>
        {
            Clock_Ip_DistributePll();
    24b0:	f000 fbf2 	bl	2c98 <Clock_Ip_DistributePll>
            ClockStatus = CLOCK_IP_SUCCESS;
    24b4:	2300      	movs	r3, #0
    24b6:	9303      	str	r3, [sp, #12]
    24b8:	e001      	b.n	24be <Clock_Ip_Init+0x32>
        }
    }
    else
    {
        ClockStatus = CLOCK_IP_SUCCESS;
    24ba:	2300      	movs	r3, #0
    24bc:	9303      	str	r3, [sp, #12]
    }

    return ClockStatus;
    24be:	9b03      	ldr	r3, [sp, #12]
}
    24c0:	4618      	mov	r0, r3
    24c2:	b005      	add	sp, #20
    24c4:	f85d fb04 	ldr.w	pc, [sp], #4
    24c8:	1fff8b44 	.word	0x1fff8b44

000024cc <Clock_Ip_InitClock>:
 *                 shall be initialized) and shall return without waiting until the PLL is locked.
 *
 * @implements Clock_Ip_InitClock_Activity
 * END**********************************************************************************/
void Clock_Ip_InitClock(Clock_Ip_ClockConfigType const * Config)
{
    24cc:	b510      	push	{r4, lr}
    24ce:	b084      	sub	sp, #16
    24d0:	9001      	str	r0, [sp, #4]
#endif

    CLOCK_IP_DEV_ASSERT(NULL_PTR != Config);

    /* Save the current clock configuration to be used by "Clock_Ip_DistributePllClock". */
    Clock_Ip_pxConfig = Config;
    24d2:	4a9f      	ldr	r2, [pc, #636]	; (2750 <Clock_Ip_InitClock+0x284>)
    24d4:	9b01      	ldr	r3, [sp, #4]
    24d6:	6013      	str	r3, [r2, #0]

    /* Platform specific initialization:
     * DFS reset, FIRC_CLK configuration etc. */
    Clock_Ip_Command(Config, CLOCK_IP_INITIALIZE_PLATFORM_COMMAND);
    24d8:	2101      	movs	r1, #1
    24da:	9801      	ldr	r0, [sp, #4]
    24dc:	f003 fa90 	bl	5a00 <Clock_Ip_Command>

    /* Clear all the settings for CMU0/1/2... */
    /* In case one clock configuration has the CMU disabled, then need to make the transition to
    reset state of CMU modules. */
    if (NULL_PTR != Clock_Ip_pxConfig)
    24e0:	4b9b      	ldr	r3, [pc, #620]	; (2750 <Clock_Ip_InitClock+0x284>)
    24e2:	681b      	ldr	r3, [r3, #0]
    24e4:	2b00      	cmp	r3, #0
    24e6:	d030      	beq.n	254a <Clock_Ip_InitClock+0x7e>
    {
        for (Index = 0U; Index < Config->CmusCount; Index++)    /* Reset all clock monitor units from previous configuration. */
    24e8:	2300      	movs	r3, #0
    24ea:	9303      	str	r3, [sp, #12]
    24ec:	e027      	b.n	253e <Clock_Ip_InitClock+0x72>
        {
            CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    24ee:	9901      	ldr	r1, [sp, #4]
    24f0:	9a03      	ldr	r2, [sp, #12]
    24f2:	4613      	mov	r3, r2
    24f4:	009b      	lsls	r3, r3, #2
    24f6:	4413      	add	r3, r2
    24f8:	009b      	lsls	r3, r3, #2
    24fa:	440b      	add	r3, r1
    24fc:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    2500:	681a      	ldr	r2, [r3, #0]
    2502:	4994      	ldr	r1, [pc, #592]	; (2754 <Clock_Ip_InitClock+0x288>)
    2504:	4613      	mov	r3, r2
    2506:	00db      	lsls	r3, r3, #3
    2508:	4413      	add	r3, r2
    250a:	440b      	add	r3, r1
    250c:	3301      	adds	r3, #1
    250e:	781b      	ldrb	r3, [r3, #0]
    2510:	461a      	mov	r2, r3
    2512:	4b91      	ldr	r3, [pc, #580]	; (2758 <Clock_Ip_InitClock+0x28c>)
    2514:	5c9b      	ldrb	r3, [r3, r2]
    2516:	9302      	str	r3, [sp, #8]
            Clock_Ip_axCmuCallbacks[CallbackIndex].Reset(&Config->Cmus[Index]);
    2518:	4a90      	ldr	r2, [pc, #576]	; (275c <Clock_Ip_InitClock+0x290>)
    251a:	9b02      	ldr	r3, [sp, #8]
    251c:	011b      	lsls	r3, r3, #4
    251e:	4413      	add	r3, r2
    2520:	6819      	ldr	r1, [r3, #0]
    2522:	9a03      	ldr	r2, [sp, #12]
    2524:	4613      	mov	r3, r2
    2526:	009b      	lsls	r3, r3, #2
    2528:	4413      	add	r3, r2
    252a:	009b      	lsls	r3, r3, #2
    252c:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    2530:	9a01      	ldr	r2, [sp, #4]
    2532:	4413      	add	r3, r2
    2534:	4618      	mov	r0, r3
    2536:	4788      	blx	r1
        for (Index = 0U; Index < Config->CmusCount; Index++)    /* Reset all clock monitor units from previous configuration. */
    2538:	9b03      	ldr	r3, [sp, #12]
    253a:	3301      	adds	r3, #1
    253c:	9303      	str	r3, [sp, #12]
    253e:	9b01      	ldr	r3, [sp, #4]
    2540:	7c9b      	ldrb	r3, [r3, #18]
    2542:	461a      	mov	r2, r3
    2544:	9b03      	ldr	r3, [sp, #12]
    2546:	4293      	cmp	r3, r2
    2548:	d3d1      	bcc.n	24ee <Clock_Ip_InitClock+0x22>

    /*********************************************************************
     ***  Ramp down to safe configuration. Reset elements from clock tree:
     ***  selectors, fractional dividers, plls and xoscs
     ***********************************************************************/
    Clock_Ip_ResetClockConfiguration(Config);
    254a:	9801      	ldr	r0, [sp, #4]
    254c:	f7ff feca 	bl	22e4 <Clock_Ip_ResetClockConfiguration>
    /*******************************************************
     *** Load the new configuration. Selectors that might
     *** be clocked from PLLs shouldn't be configured.
     *******************************************************/

    for (Index = 0U; Index < Config->IrcoscsCount; Index++)   /* Set internal oscillators from configuration */
    2550:	2300      	movs	r3, #0
    2552:	9303      	str	r3, [sp, #12]
    2554:	e029      	b.n	25aa <Clock_Ip_InitClock+0xde>
    {
        CallbackIndex = Clock_Ip_au8IrcoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Ircoscs[Index].Name][CLOCK_IP_CALLBACK]];
    2556:	9901      	ldr	r1, [sp, #4]
    2558:	9a03      	ldr	r2, [sp, #12]
    255a:	4613      	mov	r3, r2
    255c:	005b      	lsls	r3, r3, #1
    255e:	4413      	add	r3, r2
    2560:	009b      	lsls	r3, r3, #2
    2562:	440b      	add	r3, r1
    2564:	3314      	adds	r3, #20
    2566:	681a      	ldr	r2, [r3, #0]
    2568:	497a      	ldr	r1, [pc, #488]	; (2754 <Clock_Ip_InitClock+0x288>)
    256a:	4613      	mov	r3, r2
    256c:	00db      	lsls	r3, r3, #3
    256e:	4413      	add	r3, r2
    2570:	440b      	add	r3, r1
    2572:	3301      	adds	r3, #1
    2574:	781b      	ldrb	r3, [r3, #0]
    2576:	461a      	mov	r2, r3
    2578:	4b79      	ldr	r3, [pc, #484]	; (2760 <Clock_Ip_InitClock+0x294>)
    257a:	5c9b      	ldrb	r3, [r3, r2]
    257c:	9302      	str	r3, [sp, #8]
        Clock_Ip_axIntOscCallbacks[CallbackIndex].Set(&Config->Ircoscs[Index]);
    257e:	4979      	ldr	r1, [pc, #484]	; (2764 <Clock_Ip_InitClock+0x298>)
    2580:	9a02      	ldr	r2, [sp, #8]
    2582:	4613      	mov	r3, r2
    2584:	005b      	lsls	r3, r3, #1
    2586:	4413      	add	r3, r2
    2588:	009b      	lsls	r3, r3, #2
    258a:	440b      	add	r3, r1
    258c:	6819      	ldr	r1, [r3, #0]
    258e:	9a03      	ldr	r2, [sp, #12]
    2590:	4613      	mov	r3, r2
    2592:	005b      	lsls	r3, r3, #1
    2594:	4413      	add	r3, r2
    2596:	009b      	lsls	r3, r3, #2
    2598:	3310      	adds	r3, #16
    259a:	9a01      	ldr	r2, [sp, #4]
    259c:	4413      	add	r3, r2
    259e:	3304      	adds	r3, #4
    25a0:	4618      	mov	r0, r3
    25a2:	4788      	blx	r1
    for (Index = 0U; Index < Config->IrcoscsCount; Index++)   /* Set internal oscillators from configuration */
    25a4:	9b03      	ldr	r3, [sp, #12]
    25a6:	3301      	adds	r3, #1
    25a8:	9303      	str	r3, [sp, #12]
    25aa:	9b01      	ldr	r3, [sp, #4]
    25ac:	7a1b      	ldrb	r3, [r3, #8]
    25ae:	461a      	mov	r2, r3
    25b0:	9b03      	ldr	r3, [sp, #12]
    25b2:	4293      	cmp	r3, r2
    25b4:	d3cf      	bcc.n	2556 <Clock_Ip_InitClock+0x8a>
    }

    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Configure all xoscs from configuration */
    25b6:	2300      	movs	r3, #0
    25b8:	9303      	str	r3, [sp, #12]
    25ba:	e02a      	b.n	2612 <Clock_Ip_InitClock+0x146>
    {
        CallbackIndex = Clock_Ip_au8XoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Xoscs[Index].Name][CLOCK_IP_CALLBACK]];
    25bc:	9901      	ldr	r1, [sp, #4]
    25be:	9a03      	ldr	r2, [sp, #12]
    25c0:	4613      	mov	r3, r2
    25c2:	009b      	lsls	r3, r3, #2
    25c4:	4413      	add	r3, r2
    25c6:	009b      	lsls	r3, r3, #2
    25c8:	440b      	add	r3, r1
    25ca:	332c      	adds	r3, #44	; 0x2c
    25cc:	681a      	ldr	r2, [r3, #0]
    25ce:	4961      	ldr	r1, [pc, #388]	; (2754 <Clock_Ip_InitClock+0x288>)
    25d0:	4613      	mov	r3, r2
    25d2:	00db      	lsls	r3, r3, #3
    25d4:	4413      	add	r3, r2
    25d6:	440b      	add	r3, r1
    25d8:	3301      	adds	r3, #1
    25da:	781b      	ldrb	r3, [r3, #0]
    25dc:	461a      	mov	r2, r3
    25de:	4b62      	ldr	r3, [pc, #392]	; (2768 <Clock_Ip_InitClock+0x29c>)
    25e0:	5c9b      	ldrb	r3, [r3, r2]
    25e2:	9302      	str	r3, [sp, #8]
        Clock_Ip_axExtOscCallbacks[CallbackIndex].Set(&Config->Xoscs[Index]);
    25e4:	4961      	ldr	r1, [pc, #388]	; (276c <Clock_Ip_InitClock+0x2a0>)
    25e6:	9a02      	ldr	r2, [sp, #8]
    25e8:	4613      	mov	r3, r2
    25ea:	009b      	lsls	r3, r3, #2
    25ec:	4413      	add	r3, r2
    25ee:	009b      	lsls	r3, r3, #2
    25f0:	440b      	add	r3, r1
    25f2:	3304      	adds	r3, #4
    25f4:	6819      	ldr	r1, [r3, #0]
    25f6:	9a03      	ldr	r2, [sp, #12]
    25f8:	4613      	mov	r3, r2
    25fa:	009b      	lsls	r3, r3, #2
    25fc:	4413      	add	r3, r2
    25fe:	009b      	lsls	r3, r3, #2
    2600:	3328      	adds	r3, #40	; 0x28
    2602:	9a01      	ldr	r2, [sp, #4]
    2604:	4413      	add	r3, r2
    2606:	3304      	adds	r3, #4
    2608:	4618      	mov	r0, r3
    260a:	4788      	blx	r1
    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Configure all xoscs from configuration */
    260c:	9b03      	ldr	r3, [sp, #12]
    260e:	3301      	adds	r3, #1
    2610:	9303      	str	r3, [sp, #12]
    2612:	9b01      	ldr	r3, [sp, #4]
    2614:	7a5b      	ldrb	r3, [r3, #9]
    2616:	461a      	mov	r2, r3
    2618:	9b03      	ldr	r3, [sp, #12]
    261a:	4293      	cmp	r3, r2
    261c:	d3ce      	bcc.n	25bc <Clock_Ip_InitClock+0xf0>
    }

    /* Initialize clock objects, internal driver data */
    Clock_Ip_UpdateDriverContext(Config);
    261e:	9801      	ldr	r0, [sp, #4]
    2620:	f7ff fdb0 	bl	2184 <Clock_Ip_UpdateDriverContext>

    /* Configure the PCFS  */
    for (Index = 0U; Index < Config->PcfsCount; Index++)       /* Configure all progressive frequency switching clocks from configuration */
    2624:	2300      	movs	r3, #0
    2626:	9303      	str	r3, [sp, #12]
    2628:	e028      	b.n	267c <Clock_Ip_InitClock+0x1b0>
    {
        CallbackIndex = Clock_Ip_au8PcfsCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Pcfs[Index].Name][CLOCK_IP_CALLBACK]];
    262a:	9901      	ldr	r1, [sp, #4]
    262c:	9a03      	ldr	r2, [sp, #12]
    262e:	4613      	mov	r3, r2
    2630:	009b      	lsls	r3, r3, #2
    2632:	4413      	add	r3, r2
    2634:	009b      	lsls	r3, r3, #2
    2636:	440b      	add	r3, r1
    2638:	f503 736f 	add.w	r3, r3, #956	; 0x3bc
    263c:	681a      	ldr	r2, [r3, #0]
    263e:	4945      	ldr	r1, [pc, #276]	; (2754 <Clock_Ip_InitClock+0x288>)
    2640:	4613      	mov	r3, r2
    2642:	00db      	lsls	r3, r3, #3
    2644:	4413      	add	r3, r2
    2646:	440b      	add	r3, r1
    2648:	3301      	adds	r3, #1
    264a:	781b      	ldrb	r3, [r3, #0]
    264c:	461a      	mov	r2, r3
    264e:	4b48      	ldr	r3, [pc, #288]	; (2770 <Clock_Ip_InitClock+0x2a4>)
    2650:	5c9b      	ldrb	r3, [r3, r2]
    2652:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPcfsCallbacks[CallbackIndex].Set(&Config->Pcfs[Index], Index);
    2654:	4a47      	ldr	r2, [pc, #284]	; (2774 <Clock_Ip_InitClock+0x2a8>)
    2656:	9b02      	ldr	r3, [sp, #8]
    2658:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
    265c:	9a03      	ldr	r2, [sp, #12]
    265e:	4613      	mov	r3, r2
    2660:	009b      	lsls	r3, r3, #2
    2662:	4413      	add	r3, r2
    2664:	009b      	lsls	r3, r3, #2
    2666:	f503 736e 	add.w	r3, r3, #952	; 0x3b8
    266a:	9a01      	ldr	r2, [sp, #4]
    266c:	4413      	add	r3, r2
    266e:	3304      	adds	r3, #4
    2670:	9903      	ldr	r1, [sp, #12]
    2672:	4618      	mov	r0, r3
    2674:	47a0      	blx	r4
    for (Index = 0U; Index < Config->PcfsCount; Index++)       /* Configure all progressive frequency switching clocks from configuration */
    2676:	9b03      	ldr	r3, [sp, #12]
    2678:	3301      	adds	r3, #1
    267a:	9303      	str	r3, [sp, #12]
    267c:	9b01      	ldr	r3, [sp, #4]
    267e:	7c5b      	ldrb	r3, [r3, #17]
    2680:	461a      	mov	r2, r3
    2682:	9b03      	ldr	r3, [sp, #12]
    2684:	4293      	cmp	r3, r2
    2686:	d3d0      	bcc.n	262a <Clock_Ip_InitClock+0x15e>
    }

    /* Configure the clock divider triggers that are under MCU control */
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    2688:	2300      	movs	r3, #0
    268a:	9303      	str	r3, [sp, #12]
    268c:	e026      	b.n	26dc <Clock_Ip_InitClock+0x210>
    {
        CallbackIndex = Clock_Ip_au8DividerTriggerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->DividerTriggers[Index].Name][CLOCK_IP_CALLBACK]];
    268e:	9901      	ldr	r1, [sp, #4]
    2690:	9a03      	ldr	r2, [sp, #12]
    2692:	4613      	mov	r3, r2
    2694:	005b      	lsls	r3, r3, #1
    2696:	4413      	add	r3, r2
    2698:	009b      	lsls	r3, r3, #2
    269a:	440b      	add	r3, r1
    269c:	f503 730e 	add.w	r3, r3, #568	; 0x238
    26a0:	681a      	ldr	r2, [r3, #0]
    26a2:	492c      	ldr	r1, [pc, #176]	; (2754 <Clock_Ip_InitClock+0x288>)
    26a4:	4613      	mov	r3, r2
    26a6:	00db      	lsls	r3, r3, #3
    26a8:	4413      	add	r3, r2
    26aa:	440b      	add	r3, r1
    26ac:	3301      	adds	r3, #1
    26ae:	781b      	ldrb	r3, [r3, #0]
    26b0:	461a      	mov	r2, r3
    26b2:	4b31      	ldr	r3, [pc, #196]	; (2778 <Clock_Ip_InitClock+0x2ac>)
    26b4:	5c9b      	ldrb	r3, [r3, r2]
    26b6:	9302      	str	r3, [sp, #8]
        Clock_Ip_axDividerTriggerCallbacks[CallbackIndex].Configure(&Config->DividerTriggers[Index]);
    26b8:	4a30      	ldr	r2, [pc, #192]	; (277c <Clock_Ip_InitClock+0x2b0>)
    26ba:	9b02      	ldr	r3, [sp, #8]
    26bc:	f852 1033 	ldr.w	r1, [r2, r3, lsl #3]
    26c0:	9a03      	ldr	r2, [sp, #12]
    26c2:	4613      	mov	r3, r2
    26c4:	005b      	lsls	r3, r3, #1
    26c6:	4413      	add	r3, r2
    26c8:	009b      	lsls	r3, r3, #2
    26ca:	f503 730e 	add.w	r3, r3, #568	; 0x238
    26ce:	9a01      	ldr	r2, [sp, #4]
    26d0:	4413      	add	r3, r2
    26d2:	4618      	mov	r0, r3
    26d4:	4788      	blx	r1
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    26d6:	9b03      	ldr	r3, [sp, #12]
    26d8:	3301      	adds	r3, #1
    26da:	9303      	str	r3, [sp, #12]
    26dc:	9b01      	ldr	r3, [sp, #4]
    26de:	7b5b      	ldrb	r3, [r3, #13]
    26e0:	461a      	mov	r2, r3
    26e2:	9b03      	ldr	r3, [sp, #12]
    26e4:	4293      	cmp	r3, r2
    26e6:	d3d2      	bcc.n	268e <Clock_Ip_InitClock+0x1c2>
    }

    /* Configure the clock dividers that are under MCU control */
    for (Index = 0U; Index < Config->DividersCount; Index++)    /* Set dividers from configuration. */
    26e8:	2300      	movs	r3, #0
    26ea:	9303      	str	r3, [sp, #12]
    26ec:	e026      	b.n	273c <Clock_Ip_InitClock+0x270>
    {
        CallbackIndex = Clock_Ip_au8DividerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Dividers[Index].Name][CLOCK_IP_CALLBACK]];
    26ee:	9901      	ldr	r1, [sp, #4]
    26f0:	9a03      	ldr	r2, [sp, #12]
    26f2:	4613      	mov	r3, r2
    26f4:	005b      	lsls	r3, r3, #1
    26f6:	4413      	add	r3, r2
    26f8:	009b      	lsls	r3, r3, #2
    26fa:	440b      	add	r3, r1
    26fc:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    2700:	681a      	ldr	r2, [r3, #0]
    2702:	4914      	ldr	r1, [pc, #80]	; (2754 <Clock_Ip_InitClock+0x288>)
    2704:	4613      	mov	r3, r2
    2706:	00db      	lsls	r3, r3, #3
    2708:	4413      	add	r3, r2
    270a:	440b      	add	r3, r1
    270c:	3301      	adds	r3, #1
    270e:	781b      	ldrb	r3, [r3, #0]
    2710:	461a      	mov	r2, r3
    2712:	4b1b      	ldr	r3, [pc, #108]	; (2780 <Clock_Ip_InitClock+0x2b4>)
    2714:	5c9b      	ldrb	r3, [r3, r2]
    2716:	9302      	str	r3, [sp, #8]
        Clock_Ip_axDividerCallbacks[CallbackIndex].Set(&Config->Dividers[Index]);
    2718:	4a1a      	ldr	r2, [pc, #104]	; (2784 <Clock_Ip_InitClock+0x2b8>)
    271a:	9b02      	ldr	r3, [sp, #8]
    271c:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    2720:	9a03      	ldr	r2, [sp, #12]
    2722:	4613      	mov	r3, r2
    2724:	005b      	lsls	r3, r3, #1
    2726:	4413      	add	r3, r2
    2728:	009b      	lsls	r3, r3, #2
    272a:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    272e:	9a01      	ldr	r2, [sp, #4]
    2730:	4413      	add	r3, r2
    2732:	4618      	mov	r0, r3
    2734:	4788      	blx	r1
    for (Index = 0U; Index < Config->DividersCount; Index++)    /* Set dividers from configuration. */
    2736:	9b03      	ldr	r3, [sp, #12]
    2738:	3301      	adds	r3, #1
    273a:	9303      	str	r3, [sp, #12]
    273c:	9b01      	ldr	r3, [sp, #4]
    273e:	7b1b      	ldrb	r3, [r3, #12]
    2740:	461a      	mov	r2, r3
    2742:	9b03      	ldr	r3, [sp, #12]
    2744:	4293      	cmp	r3, r2
    2746:	d3d2      	bcc.n	26ee <Clock_Ip_InitClock+0x222>
    }

    /* Trigger update for all divider trigger that are under MCU control */
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    2748:	2300      	movs	r3, #0
    274a:	9303      	str	r3, [sp, #12]
    274c:	e044      	b.n	27d8 <Clock_Ip_InitClock+0x30c>
    274e:	bf00      	nop
    2750:	1fff8b3c 	.word	0x1fff8b3c
    2754:	00017fac 	.word	0x00017fac
    2758:	00017f9c 	.word	0x00017f9c
    275c:	000185a8 	.word	0x000185a8
    2760:	00017f3c 	.word	0x00017f3c
    2764:	0001856c 	.word	0x0001856c
    2768:	00017f2c 	.word	0x00017f2c
    276c:	00018500 	.word	0x00018500
    2770:	00017f8c 	.word	0x00017f8c
    2774:	000185e0 	.word	0x000185e0
    2778:	00017f1c 	.word	0x00017f1c
    277c:	000184f8 	.word	0x000184f8
    2780:	00017f0c 	.word	0x00017f0c
    2784:	000184bc 	.word	0x000184bc
    {
        CallbackIndex = Clock_Ip_au8DividerTriggerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->DividerTriggers[Index].Name][CLOCK_IP_CALLBACK]];
    2788:	9901      	ldr	r1, [sp, #4]
    278a:	9a03      	ldr	r2, [sp, #12]
    278c:	4613      	mov	r3, r2
    278e:	005b      	lsls	r3, r3, #1
    2790:	4413      	add	r3, r2
    2792:	009b      	lsls	r3, r3, #2
    2794:	440b      	add	r3, r1
    2796:	f503 730e 	add.w	r3, r3, #568	; 0x238
    279a:	681a      	ldr	r2, [r3, #0]
    279c:	49ac      	ldr	r1, [pc, #688]	; (2a50 <Clock_Ip_InitClock+0x584>)
    279e:	4613      	mov	r3, r2
    27a0:	00db      	lsls	r3, r3, #3
    27a2:	4413      	add	r3, r2
    27a4:	440b      	add	r3, r1
    27a6:	3301      	adds	r3, #1
    27a8:	781b      	ldrb	r3, [r3, #0]
    27aa:	461a      	mov	r2, r3
    27ac:	4ba9      	ldr	r3, [pc, #676]	; (2a54 <Clock_Ip_InitClock+0x588>)
    27ae:	5c9b      	ldrb	r3, [r3, r2]
    27b0:	9302      	str	r3, [sp, #8]
        Clock_Ip_axDividerTriggerCallbacks[CallbackIndex].TriggerUpdate(&Config->DividerTriggers[Index]);
    27b2:	4aa9      	ldr	r2, [pc, #676]	; (2a58 <Clock_Ip_InitClock+0x58c>)
    27b4:	9b02      	ldr	r3, [sp, #8]
    27b6:	00db      	lsls	r3, r3, #3
    27b8:	4413      	add	r3, r2
    27ba:	6859      	ldr	r1, [r3, #4]
    27bc:	9a03      	ldr	r2, [sp, #12]
    27be:	4613      	mov	r3, r2
    27c0:	005b      	lsls	r3, r3, #1
    27c2:	4413      	add	r3, r2
    27c4:	009b      	lsls	r3, r3, #2
    27c6:	f503 730e 	add.w	r3, r3, #568	; 0x238
    27ca:	9a01      	ldr	r2, [sp, #4]
    27cc:	4413      	add	r3, r2
    27ce:	4618      	mov	r0, r3
    27d0:	4788      	blx	r1
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    27d2:	9b03      	ldr	r3, [sp, #12]
    27d4:	3301      	adds	r3, #1
    27d6:	9303      	str	r3, [sp, #12]
    27d8:	9b01      	ldr	r3, [sp, #4]
    27da:	7b5b      	ldrb	r3, [r3, #13]
    27dc:	461a      	mov	r2, r3
    27de:	9b03      	ldr	r3, [sp, #12]
    27e0:	4293      	cmp	r3, r2
    27e2:	d3d1      	bcc.n	2788 <Clock_Ip_InitClock+0x2bc>
    }

    /* Configure PLL clock generators */
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Configure all plls from configuration asynchronously. Do not enable. */
    27e4:	2300      	movs	r3, #0
    27e6:	9303      	str	r3, [sp, #12]
    27e8:	e029      	b.n	283e <Clock_Ip_InitClock+0x372>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Plls[Index].Name][CLOCK_IP_CALLBACK]];
    27ea:	9901      	ldr	r1, [sp, #4]
    27ec:	9a03      	ldr	r2, [sp, #12]
    27ee:	4613      	mov	r3, r2
    27f0:	009b      	lsls	r3, r3, #2
    27f2:	4413      	add	r3, r2
    27f4:	00db      	lsls	r3, r3, #3
    27f6:	440b      	add	r3, r1
    27f8:	3340      	adds	r3, #64	; 0x40
    27fa:	681a      	ldr	r2, [r3, #0]
    27fc:	4994      	ldr	r1, [pc, #592]	; (2a50 <Clock_Ip_InitClock+0x584>)
    27fe:	4613      	mov	r3, r2
    2800:	00db      	lsls	r3, r3, #3
    2802:	4413      	add	r3, r2
    2804:	440b      	add	r3, r1
    2806:	3301      	adds	r3, #1
    2808:	781b      	ldrb	r3, [r3, #0]
    280a:	461a      	mov	r2, r3
    280c:	4b93      	ldr	r3, [pc, #588]	; (2a5c <Clock_Ip_InitClock+0x590>)
    280e:	5c9b      	ldrb	r3, [r3, r2]
    2810:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPllCallbacks[CallbackIndex].Set(&Config->Plls[Index]);
    2812:	4993      	ldr	r1, [pc, #588]	; (2a60 <Clock_Ip_InitClock+0x594>)
    2814:	9a02      	ldr	r2, [sp, #8]
    2816:	4613      	mov	r3, r2
    2818:	009b      	lsls	r3, r3, #2
    281a:	4413      	add	r3, r2
    281c:	009b      	lsls	r3, r3, #2
    281e:	440b      	add	r3, r1
    2820:	3304      	adds	r3, #4
    2822:	6819      	ldr	r1, [r3, #0]
    2824:	9a03      	ldr	r2, [sp, #12]
    2826:	4613      	mov	r3, r2
    2828:	009b      	lsls	r3, r3, #2
    282a:	4413      	add	r3, r2
    282c:	00db      	lsls	r3, r3, #3
    282e:	3340      	adds	r3, #64	; 0x40
    2830:	9a01      	ldr	r2, [sp, #4]
    2832:	4413      	add	r3, r2
    2834:	4618      	mov	r0, r3
    2836:	4788      	blx	r1
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Configure all plls from configuration asynchronously. Do not enable. */
    2838:	9b03      	ldr	r3, [sp, #12]
    283a:	3301      	adds	r3, #1
    283c:	9303      	str	r3, [sp, #12]
    283e:	9b01      	ldr	r3, [sp, #4]
    2840:	7a9b      	ldrb	r3, [r3, #10]
    2842:	461a      	mov	r2, r3
    2844:	9b03      	ldr	r3, [sp, #12]
    2846:	4293      	cmp	r3, r2
    2848:	d3cf      	bcc.n	27ea <Clock_Ip_InitClock+0x31e>
    }

    for (Index = 0U; Index < Config->CmusCount; Index++)     /* Set the Clock Monitoring Units that are under mcu control. Cmus are not enabled. */
    284a:	2300      	movs	r3, #0
    284c:	9303      	str	r3, [sp, #12]
    284e:	e029      	b.n	28a4 <Clock_Ip_InitClock+0x3d8>
    {
        CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    2850:	9901      	ldr	r1, [sp, #4]
    2852:	9a03      	ldr	r2, [sp, #12]
    2854:	4613      	mov	r3, r2
    2856:	009b      	lsls	r3, r3, #2
    2858:	4413      	add	r3, r2
    285a:	009b      	lsls	r3, r3, #2
    285c:	440b      	add	r3, r1
    285e:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    2862:	681a      	ldr	r2, [r3, #0]
    2864:	497a      	ldr	r1, [pc, #488]	; (2a50 <Clock_Ip_InitClock+0x584>)
    2866:	4613      	mov	r3, r2
    2868:	00db      	lsls	r3, r3, #3
    286a:	4413      	add	r3, r2
    286c:	440b      	add	r3, r1
    286e:	3301      	adds	r3, #1
    2870:	781b      	ldrb	r3, [r3, #0]
    2872:	461a      	mov	r2, r3
    2874:	4b7b      	ldr	r3, [pc, #492]	; (2a64 <Clock_Ip_InitClock+0x598>)
    2876:	5c9b      	ldrb	r3, [r3, r2]
    2878:	9302      	str	r3, [sp, #8]
        Clock_Ip_axCmuCallbacks[CallbackIndex].Set(&Config->Cmus[Index], Index);
    287a:	4a7b      	ldr	r2, [pc, #492]	; (2a68 <Clock_Ip_InitClock+0x59c>)
    287c:	9b02      	ldr	r3, [sp, #8]
    287e:	011b      	lsls	r3, r3, #4
    2880:	4413      	add	r3, r2
    2882:	3304      	adds	r3, #4
    2884:	681c      	ldr	r4, [r3, #0]
    2886:	9a03      	ldr	r2, [sp, #12]
    2888:	4613      	mov	r3, r2
    288a:	009b      	lsls	r3, r3, #2
    288c:	4413      	add	r3, r2
    288e:	009b      	lsls	r3, r3, #2
    2890:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    2894:	9a01      	ldr	r2, [sp, #4]
    2896:	4413      	add	r3, r2
    2898:	9903      	ldr	r1, [sp, #12]
    289a:	4618      	mov	r0, r3
    289c:	47a0      	blx	r4
    for (Index = 0U; Index < Config->CmusCount; Index++)     /* Set the Clock Monitoring Units that are under mcu control. Cmus are not enabled. */
    289e:	9b03      	ldr	r3, [sp, #12]
    28a0:	3301      	adds	r3, #1
    28a2:	9303      	str	r3, [sp, #12]
    28a4:	9b01      	ldr	r3, [sp, #4]
    28a6:	7c9b      	ldrb	r3, [r3, #18]
    28a8:	461a      	mov	r2, r3
    28aa:	9b03      	ldr	r3, [sp, #12]
    28ac:	4293      	cmp	r3, r2
    28ae:	d3cf      	bcc.n	2850 <Clock_Ip_InitClock+0x384>
    }

    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Wait for all xoscs from configuration to lock */
    28b0:	2300      	movs	r3, #0
    28b2:	9303      	str	r3, [sp, #12]
    28b4:	e02a      	b.n	290c <Clock_Ip_InitClock+0x440>
    {
        CallbackIndex = Clock_Ip_au8XoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Xoscs[Index].Name][CLOCK_IP_CALLBACK]];
    28b6:	9901      	ldr	r1, [sp, #4]
    28b8:	9a03      	ldr	r2, [sp, #12]
    28ba:	4613      	mov	r3, r2
    28bc:	009b      	lsls	r3, r3, #2
    28be:	4413      	add	r3, r2
    28c0:	009b      	lsls	r3, r3, #2
    28c2:	440b      	add	r3, r1
    28c4:	332c      	adds	r3, #44	; 0x2c
    28c6:	681a      	ldr	r2, [r3, #0]
    28c8:	4961      	ldr	r1, [pc, #388]	; (2a50 <Clock_Ip_InitClock+0x584>)
    28ca:	4613      	mov	r3, r2
    28cc:	00db      	lsls	r3, r3, #3
    28ce:	4413      	add	r3, r2
    28d0:	440b      	add	r3, r1
    28d2:	3301      	adds	r3, #1
    28d4:	781b      	ldrb	r3, [r3, #0]
    28d6:	461a      	mov	r2, r3
    28d8:	4b64      	ldr	r3, [pc, #400]	; (2a6c <Clock_Ip_InitClock+0x5a0>)
    28da:	5c9b      	ldrb	r3, [r3, r2]
    28dc:	9302      	str	r3, [sp, #8]
        Clock_Ip_axExtOscCallbacks[CallbackIndex].Complete(&Config->Xoscs[Index]);
    28de:	4964      	ldr	r1, [pc, #400]	; (2a70 <Clock_Ip_InitClock+0x5a4>)
    28e0:	9a02      	ldr	r2, [sp, #8]
    28e2:	4613      	mov	r3, r2
    28e4:	009b      	lsls	r3, r3, #2
    28e6:	4413      	add	r3, r2
    28e8:	009b      	lsls	r3, r3, #2
    28ea:	440b      	add	r3, r1
    28ec:	3308      	adds	r3, #8
    28ee:	6819      	ldr	r1, [r3, #0]
    28f0:	9a03      	ldr	r2, [sp, #12]
    28f2:	4613      	mov	r3, r2
    28f4:	009b      	lsls	r3, r3, #2
    28f6:	4413      	add	r3, r2
    28f8:	009b      	lsls	r3, r3, #2
    28fa:	3328      	adds	r3, #40	; 0x28
    28fc:	9a01      	ldr	r2, [sp, #4]
    28fe:	4413      	add	r3, r2
    2900:	3304      	adds	r3, #4
    2902:	4618      	mov	r0, r3
    2904:	4788      	blx	r1
    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Wait for all xoscs from configuration to lock */
    2906:	9b03      	ldr	r3, [sp, #12]
    2908:	3301      	adds	r3, #1
    290a:	9303      	str	r3, [sp, #12]
    290c:	9b01      	ldr	r3, [sp, #4]
    290e:	7a5b      	ldrb	r3, [r3, #9]
    2910:	461a      	mov	r2, r3
    2912:	9b03      	ldr	r3, [sp, #12]
    2914:	4293      	cmp	r3, r2
    2916:	d3ce      	bcc.n	28b6 <Clock_Ip_InitClock+0x3ea>
    }

    /* Configure PLL clock generators */
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Enable plls according to configuration asynchronously. Do not wait. */
    2918:	2300      	movs	r3, #0
    291a:	9303      	str	r3, [sp, #12]
    291c:	e029      	b.n	2972 <Clock_Ip_InitClock+0x4a6>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Plls[Index].Name][CLOCK_IP_CALLBACK]];
    291e:	9901      	ldr	r1, [sp, #4]
    2920:	9a03      	ldr	r2, [sp, #12]
    2922:	4613      	mov	r3, r2
    2924:	009b      	lsls	r3, r3, #2
    2926:	4413      	add	r3, r2
    2928:	00db      	lsls	r3, r3, #3
    292a:	440b      	add	r3, r1
    292c:	3340      	adds	r3, #64	; 0x40
    292e:	681a      	ldr	r2, [r3, #0]
    2930:	4947      	ldr	r1, [pc, #284]	; (2a50 <Clock_Ip_InitClock+0x584>)
    2932:	4613      	mov	r3, r2
    2934:	00db      	lsls	r3, r3, #3
    2936:	4413      	add	r3, r2
    2938:	440b      	add	r3, r1
    293a:	3301      	adds	r3, #1
    293c:	781b      	ldrb	r3, [r3, #0]
    293e:	461a      	mov	r2, r3
    2940:	4b46      	ldr	r3, [pc, #280]	; (2a5c <Clock_Ip_InitClock+0x590>)
    2942:	5c9b      	ldrb	r3, [r3, r2]
    2944:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPllCallbacks[CallbackIndex].Enable(&Config->Plls[Index]);
    2946:	4946      	ldr	r1, [pc, #280]	; (2a60 <Clock_Ip_InitClock+0x594>)
    2948:	9a02      	ldr	r2, [sp, #8]
    294a:	4613      	mov	r3, r2
    294c:	009b      	lsls	r3, r3, #2
    294e:	4413      	add	r3, r2
    2950:	009b      	lsls	r3, r3, #2
    2952:	440b      	add	r3, r1
    2954:	330c      	adds	r3, #12
    2956:	6819      	ldr	r1, [r3, #0]
    2958:	9a03      	ldr	r2, [sp, #12]
    295a:	4613      	mov	r3, r2
    295c:	009b      	lsls	r3, r3, #2
    295e:	4413      	add	r3, r2
    2960:	00db      	lsls	r3, r3, #3
    2962:	3340      	adds	r3, #64	; 0x40
    2964:	9a01      	ldr	r2, [sp, #4]
    2966:	4413      	add	r3, r2
    2968:	4618      	mov	r0, r3
    296a:	4788      	blx	r1
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Enable plls according to configuration asynchronously. Do not wait. */
    296c:	9b03      	ldr	r3, [sp, #12]
    296e:	3301      	adds	r3, #1
    2970:	9303      	str	r3, [sp, #12]
    2972:	9b01      	ldr	r3, [sp, #4]
    2974:	7a9b      	ldrb	r3, [r3, #10]
    2976:	461a      	mov	r2, r3
    2978:	9b03      	ldr	r3, [sp, #12]
    297a:	4293      	cmp	r3, r2
    297c:	d3cf      	bcc.n	291e <Clock_Ip_InitClock+0x452>
    }

    /* Configure fractional dividers */
    /* Note: The DFS configuration might actually need to be done after we
     * know that the PLLs are all locked in "Clock_Ip_GetPllStatus". */
    for (Index = 0U; Index < Config->FracDivsCount; Index++)    /* Configure all fractional dividers from configuration asynchronously. Do not wait. */
    297e:	2300      	movs	r3, #0
    2980:	9303      	str	r3, [sp, #12]
    2982:	e025      	b.n	29d0 <Clock_Ip_InitClock+0x504>
    {
        CallbackIndex = Clock_Ip_au8FractionalDividerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->FracDivs[Index].Name][CLOCK_IP_CALLBACK]];
    2984:	9a01      	ldr	r2, [sp, #4]
    2986:	9b03      	ldr	r3, [sp, #12]
    2988:	3324      	adds	r3, #36	; 0x24
    298a:	011b      	lsls	r3, r3, #4
    298c:	4413      	add	r3, r2
    298e:	3304      	adds	r3, #4
    2990:	681a      	ldr	r2, [r3, #0]
    2992:	492f      	ldr	r1, [pc, #188]	; (2a50 <Clock_Ip_InitClock+0x584>)
    2994:	4613      	mov	r3, r2
    2996:	00db      	lsls	r3, r3, #3
    2998:	4413      	add	r3, r2
    299a:	440b      	add	r3, r1
    299c:	3301      	adds	r3, #1
    299e:	781b      	ldrb	r3, [r3, #0]
    29a0:	461a      	mov	r2, r3
    29a2:	4b34      	ldr	r3, [pc, #208]	; (2a74 <Clock_Ip_InitClock+0x5a8>)
    29a4:	5c9b      	ldrb	r3, [r3, r2]
    29a6:	9302      	str	r3, [sp, #8]
        Clock_Ip_axFracDivCallbacks[CallbackIndex].Set(&Config->FracDivs[Index]);
    29a8:	4933      	ldr	r1, [pc, #204]	; (2a78 <Clock_Ip_InitClock+0x5ac>)
    29aa:	9a02      	ldr	r2, [sp, #8]
    29ac:	4613      	mov	r3, r2
    29ae:	005b      	lsls	r3, r3, #1
    29b0:	4413      	add	r3, r2
    29b2:	009b      	lsls	r3, r3, #2
    29b4:	440b      	add	r3, r1
    29b6:	3304      	adds	r3, #4
    29b8:	681b      	ldr	r3, [r3, #0]
    29ba:	9a03      	ldr	r2, [sp, #12]
    29bc:	3224      	adds	r2, #36	; 0x24
    29be:	0112      	lsls	r2, r2, #4
    29c0:	9901      	ldr	r1, [sp, #4]
    29c2:	440a      	add	r2, r1
    29c4:	3204      	adds	r2, #4
    29c6:	4610      	mov	r0, r2
    29c8:	4798      	blx	r3
    for (Index = 0U; Index < Config->FracDivsCount; Index++)    /* Configure all fractional dividers from configuration asynchronously. Do not wait. */
    29ca:	9b03      	ldr	r3, [sp, #12]
    29cc:	3301      	adds	r3, #1
    29ce:	9303      	str	r3, [sp, #12]
    29d0:	9b01      	ldr	r3, [sp, #4]
    29d2:	7b9b      	ldrb	r3, [r3, #14]
    29d4:	461a      	mov	r2, r3
    29d6:	9b03      	ldr	r3, [sp, #12]
    29d8:	4293      	cmp	r3, r2
    29da:	d3d3      	bcc.n	2984 <Clock_Ip_InitClock+0x4b8>
    }

    DriverContext.ClockTreeIsConsumingPll = FALSE;                                  /* Check if clock tree is using a PLL output */
    29dc:	4b27      	ldr	r3, [pc, #156]	; (2a7c <Clock_Ip_InitClock+0x5b0>)
    29de:	2200      	movs	r2, #0
    29e0:	701a      	strb	r2, [r3, #0]
#if (defined(CLOCK_IP_SUPPORTS_WAIT_STATES))
#if(CLOCK_IP_SUPPORTS_WAIT_STATES == STD_ON)
    DriverContext.WaitStatesAreSupported = TRUE;                                    /* Wait states are supported */
#else 
    DriverContext.WaitStatesAreSupported = FALSE;                                   /* Wait states are not supported */ 
    29e2:	4b26      	ldr	r3, [pc, #152]	; (2a7c <Clock_Ip_InitClock+0x5b0>)
    29e4:	2200      	movs	r2, #0
    29e6:	705a      	strb	r2, [r3, #1]
#endif /*CLOCK_IP_SUPPORTS_WAIT_STATES == STD_ON */
#else 
    DriverContext.WaitStatesAreSupported = FALSE;                                   /* Wait states are not supported */ 
#endif /* #if (defined(CLOCK_IP_SUPPORTS_WAIT_STATES)) */
    DriverContext.HwPllsNo = CLOCK_IP_NUMBER_OF_HARDWARE_PLL;                       /* Number of plls */
    29e8:	4b24      	ldr	r3, [pc, #144]	; (2a7c <Clock_Ip_InitClock+0x5b0>)
    29ea:	2201      	movs	r2, #1
    29ec:	709a      	strb	r2, [r3, #2]
    DriverContext.HwDfsNo = CLOCK_IP_NUMBER_OF_HARDWARE_DFS;                        /* Number of fractional dividers */
    29ee:	4b23      	ldr	r3, [pc, #140]	; (2a7c <Clock_Ip_InitClock+0x5b0>)
    29f0:	2200      	movs	r2, #0
    29f2:	70da      	strb	r2, [r3, #3]


    /* Configure wait states */
    Clock_Ip_SetWaitStates();
    29f4:	f000 fa9c 	bl	2f30 <Clock_Ip_SetWaitStates>
    /* Switch the clock multiplexers under MCU control to the configured source clocks */
    /* Note: if the configured source clock of a ClockMux is the output clock of a PLL/DFS,
     * the configuration will be skipped and the respective ClockMux will be switched in
     * the "Clock_Ip_DistributePllClock" function instead, when the source clock will have
     * stabilized already. */
    for (Index = 0U; Index < Config->SelectorsCount; Index++)    /* Set only if selected inputs are not clocked from PLLs */
    29f8:	2300      	movs	r3, #0
    29fa:	9303      	str	r3, [sp, #12]
    29fc:	e04c      	b.n	2a98 <Clock_Ip_InitClock+0x5cc>
    {
        if ((PLL_TYPE != Clock_Ip_aeSourceTypeClockName[Config->Selectors[Index].Value]))
    29fe:	9a01      	ldr	r2, [sp, #4]
    2a00:	9b03      	ldr	r3, [sp, #12]
    2a02:	330d      	adds	r3, #13
    2a04:	00db      	lsls	r3, r3, #3
    2a06:	4413      	add	r3, r2
    2a08:	685b      	ldr	r3, [r3, #4]
    2a0a:	4a1d      	ldr	r2, [pc, #116]	; (2a80 <Clock_Ip_InitClock+0x5b4>)
    2a0c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    2a10:	2b03      	cmp	r3, #3
    2a12:	d03b      	beq.n	2a8c <Clock_Ip_InitClock+0x5c0>
        {

            CallbackIndex = Clock_Ip_au8SelectorCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Selectors[Index].Name][CLOCK_IP_CALLBACK]];
    2a14:	9b01      	ldr	r3, [sp, #4]
    2a16:	9a03      	ldr	r2, [sp, #12]
    2a18:	320d      	adds	r2, #13
    2a1a:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
    2a1e:	490c      	ldr	r1, [pc, #48]	; (2a50 <Clock_Ip_InitClock+0x584>)
    2a20:	4613      	mov	r3, r2
    2a22:	00db      	lsls	r3, r3, #3
    2a24:	4413      	add	r3, r2
    2a26:	440b      	add	r3, r1
    2a28:	3301      	adds	r3, #1
    2a2a:	781b      	ldrb	r3, [r3, #0]
    2a2c:	461a      	mov	r2, r3
    2a2e:	4b15      	ldr	r3, [pc, #84]	; (2a84 <Clock_Ip_InitClock+0x5b8>)
    2a30:	5c9b      	ldrb	r3, [r3, r2]
    2a32:	9302      	str	r3, [sp, #8]
            Clock_Ip_axSelectorCallbacks[CallbackIndex].Set(&Config->Selectors[Index]);
    2a34:	4a14      	ldr	r2, [pc, #80]	; (2a88 <Clock_Ip_InitClock+0x5bc>)
    2a36:	9b02      	ldr	r3, [sp, #8]
    2a38:	00db      	lsls	r3, r3, #3
    2a3a:	4413      	add	r3, r2
    2a3c:	685b      	ldr	r3, [r3, #4]
    2a3e:	9a03      	ldr	r2, [sp, #12]
    2a40:	320d      	adds	r2, #13
    2a42:	00d2      	lsls	r2, r2, #3
    2a44:	9901      	ldr	r1, [sp, #4]
    2a46:	440a      	add	r2, r1
    2a48:	4610      	mov	r0, r2
    2a4a:	4798      	blx	r3
    2a4c:	e021      	b.n	2a92 <Clock_Ip_InitClock+0x5c6>
    2a4e:	bf00      	nop
    2a50:	00017fac 	.word	0x00017fac
    2a54:	00017f1c 	.word	0x00017f1c
    2a58:	000184f8 	.word	0x000184f8
    2a5c:	00017f6c 	.word	0x00017f6c
    2a60:	000185b8 	.word	0x000185b8
    2a64:	00017f9c 	.word	0x00017f9c
    2a68:	000185a8 	.word	0x000185a8
    2a6c:	00017f2c 	.word	0x00017f2c
    2a70:	00018500 	.word	0x00018500
    2a74:	00017f5c 	.word	0x00017f5c
    2a78:	00018528 	.word	0x00018528
    2a7c:	1fff8b44 	.word	0x1fff8b44
    2a80:	000183f8 	.word	0x000183f8
    2a84:	00017f7c 	.word	0x00017f7c
    2a88:	000185e4 	.word	0x000185e4
        }
        else
        {
            /* At least one mux is consuming pll */
            DriverContext.ClockTreeIsConsumingPll = TRUE;
    2a8c:	4b3a      	ldr	r3, [pc, #232]	; (2b78 <Clock_Ip_InitClock+0x6ac>)
    2a8e:	2201      	movs	r2, #1
    2a90:	701a      	strb	r2, [r3, #0]
    for (Index = 0U; Index < Config->SelectorsCount; Index++)    /* Set only if selected inputs are not clocked from PLLs */
    2a92:	9b03      	ldr	r3, [sp, #12]
    2a94:	3301      	adds	r3, #1
    2a96:	9303      	str	r3, [sp, #12]
    2a98:	9b01      	ldr	r3, [sp, #4]
    2a9a:	7adb      	ldrb	r3, [r3, #11]
    2a9c:	461a      	mov	r2, r3
    2a9e:	9b03      	ldr	r3, [sp, #12]
    2aa0:	4293      	cmp	r3, r2
    2aa2:	d3ac      	bcc.n	29fe <Clock_Ip_InitClock+0x532>
        }
    }

    /* Check if the clock tree is using a PLL output */
    if ( FALSE == DriverContext.ClockTreeIsConsumingPll )
    2aa4:	4b34      	ldr	r3, [pc, #208]	; (2b78 <Clock_Ip_InitClock+0x6ac>)
    2aa6:	781b      	ldrb	r3, [r3, #0]
    2aa8:	f083 0301 	eor.w	r3, r3, #1
    2aac:	b2db      	uxtb	r3, r3
    2aae:	2b00      	cmp	r3, #0
    2ab0:	d05e      	beq.n	2b70 <Clock_Ip_InitClock+0x6a4>
    {
        for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    2ab2:	2300      	movs	r3, #0
    2ab4:	9303      	str	r3, [sp, #12]
    2ab6:	e01f      	b.n	2af8 <Clock_Ip_InitClock+0x62c>
        {
            CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Gates[Index].Name][CLOCK_IP_CALLBACK]];
    2ab8:	9a01      	ldr	r2, [sp, #4]
    2aba:	9b03      	ldr	r3, [sp, #12]
    2abc:	334e      	adds	r3, #78	; 0x4e
    2abe:	00db      	lsls	r3, r3, #3
    2ac0:	4413      	add	r3, r2
    2ac2:	685a      	ldr	r2, [r3, #4]
    2ac4:	492d      	ldr	r1, [pc, #180]	; (2b7c <Clock_Ip_InitClock+0x6b0>)
    2ac6:	4613      	mov	r3, r2
    2ac8:	00db      	lsls	r3, r3, #3
    2aca:	4413      	add	r3, r2
    2acc:	440b      	add	r3, r1
    2ace:	3301      	adds	r3, #1
    2ad0:	781b      	ldrb	r3, [r3, #0]
    2ad2:	461a      	mov	r2, r3
    2ad4:	4b2a      	ldr	r3, [pc, #168]	; (2b80 <Clock_Ip_InitClock+0x6b4>)
    2ad6:	5c9b      	ldrb	r3, [r3, r2]
    2ad8:	9302      	str	r3, [sp, #8]
            Clock_Ip_axGateCallbacks[CallbackIndex].Set(&Config->Gates[Index]);
    2ada:	4a2a      	ldr	r2, [pc, #168]	; (2b84 <Clock_Ip_InitClock+0x6b8>)
    2adc:	9b02      	ldr	r3, [sp, #8]
    2ade:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    2ae2:	9a03      	ldr	r2, [sp, #12]
    2ae4:	324e      	adds	r2, #78	; 0x4e
    2ae6:	00d2      	lsls	r2, r2, #3
    2ae8:	9901      	ldr	r1, [sp, #4]
    2aea:	440a      	add	r2, r1
    2aec:	3204      	adds	r2, #4
    2aee:	4610      	mov	r0, r2
    2af0:	4798      	blx	r3
        for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    2af2:	9b03      	ldr	r3, [sp, #12]
    2af4:	3301      	adds	r3, #1
    2af6:	9303      	str	r3, [sp, #12]
    2af8:	9b01      	ldr	r3, [sp, #4]
    2afa:	7c1b      	ldrb	r3, [r3, #16]
    2afc:	461a      	mov	r2, r3
    2afe:	9b03      	ldr	r3, [sp, #12]
    2b00:	4293      	cmp	r3, r2
    2b02:	d3d9      	bcc.n	2ab8 <Clock_Ip_InitClock+0x5ec>
        }

        /* Enable the Clock Monitoring Units ( CMU0 .. n ) according to configuration. */
        for (Index = 0U; Index < Config->CmusCount; Index++)
    2b04:	2300      	movs	r3, #0
    2b06:	9303      	str	r3, [sp, #12]
    2b08:	e028      	b.n	2b5c <Clock_Ip_InitClock+0x690>
        {
            CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    2b0a:	9901      	ldr	r1, [sp, #4]
    2b0c:	9a03      	ldr	r2, [sp, #12]
    2b0e:	4613      	mov	r3, r2
    2b10:	009b      	lsls	r3, r3, #2
    2b12:	4413      	add	r3, r2
    2b14:	009b      	lsls	r3, r3, #2
    2b16:	440b      	add	r3, r1
    2b18:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    2b1c:	681a      	ldr	r2, [r3, #0]
    2b1e:	4917      	ldr	r1, [pc, #92]	; (2b7c <Clock_Ip_InitClock+0x6b0>)
    2b20:	4613      	mov	r3, r2
    2b22:	00db      	lsls	r3, r3, #3
    2b24:	4413      	add	r3, r2
    2b26:	440b      	add	r3, r1
    2b28:	3301      	adds	r3, #1
    2b2a:	781b      	ldrb	r3, [r3, #0]
    2b2c:	461a      	mov	r2, r3
    2b2e:	4b16      	ldr	r3, [pc, #88]	; (2b88 <Clock_Ip_InitClock+0x6bc>)
    2b30:	5c9b      	ldrb	r3, [r3, r2]
    2b32:	9302      	str	r3, [sp, #8]
            Clock_Ip_axCmuCallbacks[CallbackIndex].Enable(&Config->Cmus[Index]);
    2b34:	4a15      	ldr	r2, [pc, #84]	; (2b8c <Clock_Ip_InitClock+0x6c0>)
    2b36:	9b02      	ldr	r3, [sp, #8]
    2b38:	011b      	lsls	r3, r3, #4
    2b3a:	4413      	add	r3, r2
    2b3c:	330c      	adds	r3, #12
    2b3e:	6819      	ldr	r1, [r3, #0]
    2b40:	9a03      	ldr	r2, [sp, #12]
    2b42:	4613      	mov	r3, r2
    2b44:	009b      	lsls	r3, r3, #2
    2b46:	4413      	add	r3, r2
    2b48:	009b      	lsls	r3, r3, #2
    2b4a:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    2b4e:	9a01      	ldr	r2, [sp, #4]
    2b50:	4413      	add	r3, r2
    2b52:	4618      	mov	r0, r3
    2b54:	4788      	blx	r1
        for (Index = 0U; Index < Config->CmusCount; Index++)
    2b56:	9b03      	ldr	r3, [sp, #12]
    2b58:	3301      	adds	r3, #1
    2b5a:	9303      	str	r3, [sp, #12]
    2b5c:	9b01      	ldr	r3, [sp, #4]
    2b5e:	7c9b      	ldrb	r3, [r3, #18]
    2b60:	461a      	mov	r2, r3
    2b62:	9b03      	ldr	r3, [sp, #12]
    2b64:	4293      	cmp	r3, r2
    2b66:	d3d0      	bcc.n	2b0a <Clock_Ip_InitClock+0x63e>
        }
        /* Disable safe clock if it is supported by platform and it is configured/required. */
        /* Note: Safe clock is the fast internal oscillator clock. It is clocking the clock tree until pll is distributed.
         * At the end of configuration it can be disabled if it is supported on this platform and required/configured. */
        Clock_Ip_Command(Config, CLOCK_IP_DISABLE_SAFE_CLOCK_COMMAND);
    2b68:	2104      	movs	r1, #4
    2b6a:	9801      	ldr	r0, [sp, #4]
    2b6c:	f002 ff48 	bl	5a00 <Clock_Ip_Command>
    {
        /* The clock tree is using at least one PLL/DFS output clock as source. */
        /* The user must wait until the PLLs and DFSs are locked by polling Clock_Ip_GetPllStatus */
        /* and then call "Clock_Ip_DistributePllClock" */
    }
}
    2b70:	bf00      	nop
    2b72:	b004      	add	sp, #16
    2b74:	bd10      	pop	{r4, pc}
    2b76:	bf00      	nop
    2b78:	1fff8b44 	.word	0x1fff8b44
    2b7c:	00017fac 	.word	0x00017fac
    2b80:	00017f4c 	.word	0x00017f4c
    2b84:	00018534 	.word	0x00018534
    2b88:	00017f9c 	.word	0x00017f9c
    2b8c:	000185a8 	.word	0x000185a8

00002b90 <Clock_Ip_GetPllStatus>:
 * will calculate frequencies only.
 *
 * @implements Clock_Ip_GetPllStatus_Activity
 * END**********************************************************************************/
Clock_Ip_PllStatusType Clock_Ip_GetPllStatus(void)
{
    2b90:	b500      	push	{lr}
    2b92:	b087      	sub	sp, #28
    Clock_Ip_PllStatusType RetValue = CLOCK_IP_PLL_STATUS_UNDEFINED;
    2b94:	2302      	movs	r3, #2
    2b96:	9305      	str	r3, [sp, #20]
    Clock_Ip_DfsStatusType DfsStatus;

    uint32 Index;
    uint32 CallbackIndex;

    for (Index = 0U; Index < DriverContext.HwPllsNo; Index++)
    2b98:	2300      	movs	r3, #0
    2b9a:	9304      	str	r3, [sp, #16]
    2b9c:	e02c      	b.n	2bf8 <Clock_Ip_GetPllStatus+0x68>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_aeHwPllName[Index]][CLOCK_IP_CALLBACK]];
    2b9e:	4a36      	ldr	r2, [pc, #216]	; (2c78 <Clock_Ip_GetPllStatus+0xe8>)
    2ba0:	9b04      	ldr	r3, [sp, #16]
    2ba2:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    2ba6:	4935      	ldr	r1, [pc, #212]	; (2c7c <Clock_Ip_GetPllStatus+0xec>)
    2ba8:	4613      	mov	r3, r2
    2baa:	00db      	lsls	r3, r3, #3
    2bac:	4413      	add	r3, r2
    2bae:	440b      	add	r3, r1
    2bb0:	3301      	adds	r3, #1
    2bb2:	781b      	ldrb	r3, [r3, #0]
    2bb4:	461a      	mov	r2, r3
    2bb6:	4b32      	ldr	r3, [pc, #200]	; (2c80 <Clock_Ip_GetPllStatus+0xf0>)
    2bb8:	5c9b      	ldrb	r3, [r3, r2]
    2bba:	9303      	str	r3, [sp, #12]
        PllStatus = Clock_Ip_axPllCallbacks[CallbackIndex].Complete(Clock_Ip_aeHwPllName[Index]);
    2bbc:	4931      	ldr	r1, [pc, #196]	; (2c84 <Clock_Ip_GetPllStatus+0xf4>)
    2bbe:	9a03      	ldr	r2, [sp, #12]
    2bc0:	4613      	mov	r3, r2
    2bc2:	009b      	lsls	r3, r3, #2
    2bc4:	4413      	add	r3, r2
    2bc6:	009b      	lsls	r3, r3, #2
    2bc8:	440b      	add	r3, r1
    2bca:	3308      	adds	r3, #8
    2bcc:	681b      	ldr	r3, [r3, #0]
    2bce:	492a      	ldr	r1, [pc, #168]	; (2c78 <Clock_Ip_GetPllStatus+0xe8>)
    2bd0:	9a04      	ldr	r2, [sp, #16]
    2bd2:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    2bd6:	4610      	mov	r0, r2
    2bd8:	4798      	blx	r3
    2bda:	9002      	str	r0, [sp, #8]
        if (STATUS_PLL_UNLOCKED == PllStatus)
    2bdc:	9b02      	ldr	r3, [sp, #8]
    2bde:	2b01      	cmp	r3, #1
    2be0:	d102      	bne.n	2be8 <Clock_Ip_GetPllStatus+0x58>
        {
            RetValue = CLOCK_IP_PLL_UNLOCKED;
    2be2:	2301      	movs	r3, #1
    2be4:	9305      	str	r3, [sp, #20]
            break;
    2be6:	e00d      	b.n	2c04 <Clock_Ip_GetPllStatus+0x74>
        }
        else
        {
            if (STATUS_PLL_LOCKED == PllStatus)
    2be8:	9b02      	ldr	r3, [sp, #8]
    2bea:	2b02      	cmp	r3, #2
    2bec:	d101      	bne.n	2bf2 <Clock_Ip_GetPllStatus+0x62>
            {
                RetValue = CLOCK_IP_PLL_LOCKED;
    2bee:	2300      	movs	r3, #0
    2bf0:	9305      	str	r3, [sp, #20]
    for (Index = 0U; Index < DriverContext.HwPllsNo; Index++)
    2bf2:	9b04      	ldr	r3, [sp, #16]
    2bf4:	3301      	adds	r3, #1
    2bf6:	9304      	str	r3, [sp, #16]
    2bf8:	4b23      	ldr	r3, [pc, #140]	; (2c88 <Clock_Ip_GetPllStatus+0xf8>)
    2bfa:	789b      	ldrb	r3, [r3, #2]
    2bfc:	461a      	mov	r2, r3
    2bfe:	9b04      	ldr	r3, [sp, #16]
    2c00:	4293      	cmp	r3, r2
    2c02:	d3cc      	bcc.n	2b9e <Clock_Ip_GetPllStatus+0xe>
            }
        }
    }

    if (CLOCK_IP_PLL_LOCKED == RetValue)
    2c04:	9b05      	ldr	r3, [sp, #20]
    2c06:	2b00      	cmp	r3, #0
    2c08:	d130      	bne.n	2c6c <Clock_Ip_GetPllStatus+0xdc>
    {
        for (Index = 0U; Index < DriverContext.HwDfsNo; Index++)
    2c0a:	2300      	movs	r3, #0
    2c0c:	9304      	str	r3, [sp, #16]
    2c0e:	e027      	b.n	2c60 <Clock_Ip_GetPllStatus+0xd0>
        {
            CallbackIndex = Clock_Ip_au8FractionalDividerCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_aeHwDfsName[Index]][CLOCK_IP_CALLBACK]];
    2c10:	4a1e      	ldr	r2, [pc, #120]	; (2c8c <Clock_Ip_GetPllStatus+0xfc>)
    2c12:	9b04      	ldr	r3, [sp, #16]
    2c14:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    2c18:	4918      	ldr	r1, [pc, #96]	; (2c7c <Clock_Ip_GetPllStatus+0xec>)
    2c1a:	4613      	mov	r3, r2
    2c1c:	00db      	lsls	r3, r3, #3
    2c1e:	4413      	add	r3, r2
    2c20:	440b      	add	r3, r1
    2c22:	3301      	adds	r3, #1
    2c24:	781b      	ldrb	r3, [r3, #0]
    2c26:	461a      	mov	r2, r3
    2c28:	4b19      	ldr	r3, [pc, #100]	; (2c90 <Clock_Ip_GetPllStatus+0x100>)
    2c2a:	5c9b      	ldrb	r3, [r3, r2]
    2c2c:	9303      	str	r3, [sp, #12]
            DfsStatus = Clock_Ip_axFracDivCallbacks[CallbackIndex].Complete(Clock_Ip_aeHwDfsName[Index]);
    2c2e:	4919      	ldr	r1, [pc, #100]	; (2c94 <Clock_Ip_GetPllStatus+0x104>)
    2c30:	9a03      	ldr	r2, [sp, #12]
    2c32:	4613      	mov	r3, r2
    2c34:	005b      	lsls	r3, r3, #1
    2c36:	4413      	add	r3, r2
    2c38:	009b      	lsls	r3, r3, #2
    2c3a:	440b      	add	r3, r1
    2c3c:	3308      	adds	r3, #8
    2c3e:	681b      	ldr	r3, [r3, #0]
    2c40:	4912      	ldr	r1, [pc, #72]	; (2c8c <Clock_Ip_GetPllStatus+0xfc>)
    2c42:	9a04      	ldr	r2, [sp, #16]
    2c44:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    2c48:	4610      	mov	r0, r2
    2c4a:	4798      	blx	r3
    2c4c:	9001      	str	r0, [sp, #4]
            if (STATUS_DFS_UNLOCKED == DfsStatus)
    2c4e:	9b01      	ldr	r3, [sp, #4]
    2c50:	2b01      	cmp	r3, #1
    2c52:	d102      	bne.n	2c5a <Clock_Ip_GetPllStatus+0xca>
            {
                RetValue = CLOCK_IP_PLL_UNLOCKED;
    2c54:	2301      	movs	r3, #1
    2c56:	9305      	str	r3, [sp, #20]
                break;
    2c58:	e008      	b.n	2c6c <Clock_Ip_GetPllStatus+0xdc>
        for (Index = 0U; Index < DriverContext.HwDfsNo; Index++)
    2c5a:	9b04      	ldr	r3, [sp, #16]
    2c5c:	3301      	adds	r3, #1
    2c5e:	9304      	str	r3, [sp, #16]
    2c60:	4b09      	ldr	r3, [pc, #36]	; (2c88 <Clock_Ip_GetPllStatus+0xf8>)
    2c62:	78db      	ldrb	r3, [r3, #3]
    2c64:	461a      	mov	r2, r3
    2c66:	9b04      	ldr	r3, [sp, #16]
    2c68:	4293      	cmp	r3, r2
    2c6a:	d3d1      	bcc.n	2c10 <Clock_Ip_GetPllStatus+0x80>
            }
        }
    }

    return RetValue;
    2c6c:	9b05      	ldr	r3, [sp, #20]
}
    2c6e:	4618      	mov	r0, r3
    2c70:	b007      	add	sp, #28
    2c72:	f85d fb04 	ldr.w	pc, [sp], #4
    2c76:	bf00      	nop
    2c78:	000184b4 	.word	0x000184b4
    2c7c:	00017fac 	.word	0x00017fac
    2c80:	00017f6c 	.word	0x00017f6c
    2c84:	000185b8 	.word	0x000185b8
    2c88:	1fff8b44 	.word	0x1fff8b44
    2c8c:	000184b8 	.word	0x000184b8
    2c90:	00017f5c 	.word	0x00017f5c
    2c94:	00018528 	.word	0x00018528

00002c98 <Clock_Ip_DistributePll>:
 * The function will not distribute the PLL clock if the driver state does not allow it, or the PLL is not stable.
 *
 * @implements Clock_Ip_DistributePll_Activity
 * END**********************************************************************************/
void Clock_Ip_DistributePll(void)
{
    2c98:	b500      	push	{lr}
    2c9a:	b083      	sub	sp, #12
    uint32 CallbackIndex;

    CLOCK_IP_DEV_ASSERT(NULL_PTR != Clock_Ip_pxConfig);
    /* 'Clock_Ip_pxConfig' is set by Clock_Ip_InitClock().
     *  It doesn't make sense to call PLL distribution without clock initialization. */
    if (NULL_PTR != Clock_Ip_pxConfig)
    2c9c:	4b55      	ldr	r3, [pc, #340]	; (2df4 <Clock_Ip_DistributePll+0x15c>)
    2c9e:	681b      	ldr	r3, [r3, #0]
    2ca0:	2b00      	cmp	r3, #0
    2ca2:	f000 80a2 	beq.w	2dea <Clock_Ip_DistributePll+0x152>
    {
        for (Index = 0U; Index < Clock_Ip_pxConfig->SelectorsCount; Index++)    /* Set only if selected inputs are clocked from PLLs */
    2ca6:	2300      	movs	r3, #0
    2ca8:	9301      	str	r3, [sp, #4]
    2caa:	e02c      	b.n	2d06 <Clock_Ip_DistributePll+0x6e>
        {
            if (PLL_TYPE == Clock_Ip_aeSourceTypeClockName[Clock_Ip_pxConfig->Selectors[Index].Value])
    2cac:	4b51      	ldr	r3, [pc, #324]	; (2df4 <Clock_Ip_DistributePll+0x15c>)
    2cae:	681a      	ldr	r2, [r3, #0]
    2cb0:	9b01      	ldr	r3, [sp, #4]
    2cb2:	330d      	adds	r3, #13
    2cb4:	00db      	lsls	r3, r3, #3
    2cb6:	4413      	add	r3, r2
    2cb8:	685b      	ldr	r3, [r3, #4]
    2cba:	4a4f      	ldr	r2, [pc, #316]	; (2df8 <Clock_Ip_DistributePll+0x160>)
    2cbc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    2cc0:	2b03      	cmp	r3, #3
    2cc2:	d11d      	bne.n	2d00 <Clock_Ip_DistributePll+0x68>
            {

                CallbackIndex = Clock_Ip_au8SelectorCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_pxConfig->Selectors[Index].Name][CLOCK_IP_CALLBACK]];
    2cc4:	4b4b      	ldr	r3, [pc, #300]	; (2df4 <Clock_Ip_DistributePll+0x15c>)
    2cc6:	681b      	ldr	r3, [r3, #0]
    2cc8:	9a01      	ldr	r2, [sp, #4]
    2cca:	320d      	adds	r2, #13
    2ccc:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
    2cd0:	494a      	ldr	r1, [pc, #296]	; (2dfc <Clock_Ip_DistributePll+0x164>)
    2cd2:	4613      	mov	r3, r2
    2cd4:	00db      	lsls	r3, r3, #3
    2cd6:	4413      	add	r3, r2
    2cd8:	440b      	add	r3, r1
    2cda:	3301      	adds	r3, #1
    2cdc:	781b      	ldrb	r3, [r3, #0]
    2cde:	461a      	mov	r2, r3
    2ce0:	4b47      	ldr	r3, [pc, #284]	; (2e00 <Clock_Ip_DistributePll+0x168>)
    2ce2:	5c9b      	ldrb	r3, [r3, r2]
    2ce4:	9300      	str	r3, [sp, #0]
                Clock_Ip_axSelectorCallbacks[CallbackIndex].Set(&Clock_Ip_pxConfig->Selectors[Index]);
    2ce6:	4a47      	ldr	r2, [pc, #284]	; (2e04 <Clock_Ip_DistributePll+0x16c>)
    2ce8:	9b00      	ldr	r3, [sp, #0]
    2cea:	00db      	lsls	r3, r3, #3
    2cec:	4413      	add	r3, r2
    2cee:	685b      	ldr	r3, [r3, #4]
    2cf0:	4a40      	ldr	r2, [pc, #256]	; (2df4 <Clock_Ip_DistributePll+0x15c>)
    2cf2:	6811      	ldr	r1, [r2, #0]
    2cf4:	9a01      	ldr	r2, [sp, #4]
    2cf6:	320d      	adds	r2, #13
    2cf8:	00d2      	lsls	r2, r2, #3
    2cfa:	440a      	add	r2, r1
    2cfc:	4610      	mov	r0, r2
    2cfe:	4798      	blx	r3
        for (Index = 0U; Index < Clock_Ip_pxConfig->SelectorsCount; Index++)    /* Set only if selected inputs are clocked from PLLs */
    2d00:	9b01      	ldr	r3, [sp, #4]
    2d02:	3301      	adds	r3, #1
    2d04:	9301      	str	r3, [sp, #4]
    2d06:	4b3b      	ldr	r3, [pc, #236]	; (2df4 <Clock_Ip_DistributePll+0x15c>)
    2d08:	681b      	ldr	r3, [r3, #0]
    2d0a:	7adb      	ldrb	r3, [r3, #11]
    2d0c:	461a      	mov	r2, r3
    2d0e:	9b01      	ldr	r3, [sp, #4]
    2d10:	4293      	cmp	r3, r2
    2d12:	d3cb      	bcc.n	2cac <Clock_Ip_DistributePll+0x14>
        }

        /* In the case of PLL is enabled but PLL clock source is not used by any clock Mux.
           So, no need to re-configure for CMUs, because they are configured by Clock_Ip_InitClock */
        /* Check if the clock tree is using a PLL output */
        if ( DriverContext.ClockTreeIsConsumingPll )
    2d14:	4b3c      	ldr	r3, [pc, #240]	; (2e08 <Clock_Ip_DistributePll+0x170>)
    2d16:	781b      	ldrb	r3, [r3, #0]
    2d18:	2b00      	cmp	r3, #0
    2d1a:	d066      	beq.n	2dea <Clock_Ip_DistributePll+0x152>
        {
            for (Index = 0U; Index < Clock_Ip_pxConfig->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    2d1c:	2300      	movs	r3, #0
    2d1e:	9301      	str	r3, [sp, #4]
    2d20:	e021      	b.n	2d66 <Clock_Ip_DistributePll+0xce>
            {
                CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_pxConfig->Gates[Index].Name][CLOCK_IP_CALLBACK]];
    2d22:	4b34      	ldr	r3, [pc, #208]	; (2df4 <Clock_Ip_DistributePll+0x15c>)
    2d24:	681a      	ldr	r2, [r3, #0]
    2d26:	9b01      	ldr	r3, [sp, #4]
    2d28:	334e      	adds	r3, #78	; 0x4e
    2d2a:	00db      	lsls	r3, r3, #3
    2d2c:	4413      	add	r3, r2
    2d2e:	685a      	ldr	r2, [r3, #4]
    2d30:	4932      	ldr	r1, [pc, #200]	; (2dfc <Clock_Ip_DistributePll+0x164>)
    2d32:	4613      	mov	r3, r2
    2d34:	00db      	lsls	r3, r3, #3
    2d36:	4413      	add	r3, r2
    2d38:	440b      	add	r3, r1
    2d3a:	3301      	adds	r3, #1
    2d3c:	781b      	ldrb	r3, [r3, #0]
    2d3e:	461a      	mov	r2, r3
    2d40:	4b32      	ldr	r3, [pc, #200]	; (2e0c <Clock_Ip_DistributePll+0x174>)
    2d42:	5c9b      	ldrb	r3, [r3, r2]
    2d44:	9300      	str	r3, [sp, #0]
                Clock_Ip_axGateCallbacks[CallbackIndex].Set(&Clock_Ip_pxConfig->Gates[Index]);
    2d46:	4a32      	ldr	r2, [pc, #200]	; (2e10 <Clock_Ip_DistributePll+0x178>)
    2d48:	9b00      	ldr	r3, [sp, #0]
    2d4a:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    2d4e:	4a29      	ldr	r2, [pc, #164]	; (2df4 <Clock_Ip_DistributePll+0x15c>)
    2d50:	6811      	ldr	r1, [r2, #0]
    2d52:	9a01      	ldr	r2, [sp, #4]
    2d54:	324e      	adds	r2, #78	; 0x4e
    2d56:	00d2      	lsls	r2, r2, #3
    2d58:	440a      	add	r2, r1
    2d5a:	3204      	adds	r2, #4
    2d5c:	4610      	mov	r0, r2
    2d5e:	4798      	blx	r3
            for (Index = 0U; Index < Clock_Ip_pxConfig->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    2d60:	9b01      	ldr	r3, [sp, #4]
    2d62:	3301      	adds	r3, #1
    2d64:	9301      	str	r3, [sp, #4]
    2d66:	4b23      	ldr	r3, [pc, #140]	; (2df4 <Clock_Ip_DistributePll+0x15c>)
    2d68:	681b      	ldr	r3, [r3, #0]
    2d6a:	7c1b      	ldrb	r3, [r3, #16]
    2d6c:	461a      	mov	r2, r3
    2d6e:	9b01      	ldr	r3, [sp, #4]
    2d70:	4293      	cmp	r3, r2
    2d72:	d3d6      	bcc.n	2d22 <Clock_Ip_DistributePll+0x8a>
            }

            /* Enable the Clock Monitoring Units ( CMU0 .. n ) according to configuration. */
            for (Index = 0U; Index < Clock_Ip_pxConfig->CmusCount; Index++)
    2d74:	2300      	movs	r3, #0
    2d76:	9301      	str	r3, [sp, #4]
    2d78:	e02a      	b.n	2dd0 <Clock_Ip_DistributePll+0x138>
            {
                CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_pxConfig->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    2d7a:	4b1e      	ldr	r3, [pc, #120]	; (2df4 <Clock_Ip_DistributePll+0x15c>)
    2d7c:	6819      	ldr	r1, [r3, #0]
    2d7e:	9a01      	ldr	r2, [sp, #4]
    2d80:	4613      	mov	r3, r2
    2d82:	009b      	lsls	r3, r3, #2
    2d84:	4413      	add	r3, r2
    2d86:	009b      	lsls	r3, r3, #2
    2d88:	440b      	add	r3, r1
    2d8a:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    2d8e:	681a      	ldr	r2, [r3, #0]
    2d90:	491a      	ldr	r1, [pc, #104]	; (2dfc <Clock_Ip_DistributePll+0x164>)
    2d92:	4613      	mov	r3, r2
    2d94:	00db      	lsls	r3, r3, #3
    2d96:	4413      	add	r3, r2
    2d98:	440b      	add	r3, r1
    2d9a:	3301      	adds	r3, #1
    2d9c:	781b      	ldrb	r3, [r3, #0]
    2d9e:	461a      	mov	r2, r3
    2da0:	4b1c      	ldr	r3, [pc, #112]	; (2e14 <Clock_Ip_DistributePll+0x17c>)
    2da2:	5c9b      	ldrb	r3, [r3, r2]
    2da4:	9300      	str	r3, [sp, #0]
                Clock_Ip_axCmuCallbacks[CallbackIndex].Enable(&Clock_Ip_pxConfig->Cmus[Index]);
    2da6:	4a1c      	ldr	r2, [pc, #112]	; (2e18 <Clock_Ip_DistributePll+0x180>)
    2da8:	9b00      	ldr	r3, [sp, #0]
    2daa:	011b      	lsls	r3, r3, #4
    2dac:	4413      	add	r3, r2
    2dae:	330c      	adds	r3, #12
    2db0:	6819      	ldr	r1, [r3, #0]
    2db2:	4b10      	ldr	r3, [pc, #64]	; (2df4 <Clock_Ip_DistributePll+0x15c>)
    2db4:	6818      	ldr	r0, [r3, #0]
    2db6:	9a01      	ldr	r2, [sp, #4]
    2db8:	4613      	mov	r3, r2
    2dba:	009b      	lsls	r3, r3, #2
    2dbc:	4413      	add	r3, r2
    2dbe:	009b      	lsls	r3, r3, #2
    2dc0:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    2dc4:	4403      	add	r3, r0
    2dc6:	4618      	mov	r0, r3
    2dc8:	4788      	blx	r1
            for (Index = 0U; Index < Clock_Ip_pxConfig->CmusCount; Index++)
    2dca:	9b01      	ldr	r3, [sp, #4]
    2dcc:	3301      	adds	r3, #1
    2dce:	9301      	str	r3, [sp, #4]
    2dd0:	4b08      	ldr	r3, [pc, #32]	; (2df4 <Clock_Ip_DistributePll+0x15c>)
    2dd2:	681b      	ldr	r3, [r3, #0]
    2dd4:	7c9b      	ldrb	r3, [r3, #18]
    2dd6:	461a      	mov	r2, r3
    2dd8:	9b01      	ldr	r3, [sp, #4]
    2dda:	4293      	cmp	r3, r2
    2ddc:	d3cd      	bcc.n	2d7a <Clock_Ip_DistributePll+0xe2>
            }

            /* Disable safe clock if it is supported by platform and it is configured/required. */
            /* Note: Safe clock is the fast internal oscillator clock. It is clocking the clock tree until pll is distributed.
             * At the end of configuration it can be disabled if it is supported on this platform and required/configured. */
            Clock_Ip_Command(Clock_Ip_pxConfig, CLOCK_IP_DISABLE_SAFE_CLOCK_COMMAND);
    2dde:	4b05      	ldr	r3, [pc, #20]	; (2df4 <Clock_Ip_DistributePll+0x15c>)
    2de0:	681b      	ldr	r3, [r3, #0]
    2de2:	2104      	movs	r1, #4
    2de4:	4618      	mov	r0, r3
    2de6:	f002 fe0b 	bl	5a00 <Clock_Ip_Command>
        }
    }
}
    2dea:	bf00      	nop
    2dec:	b003      	add	sp, #12
    2dee:	f85d fb04 	ldr.w	pc, [sp], #4
    2df2:	bf00      	nop
    2df4:	1fff8b3c 	.word	0x1fff8b3c
    2df8:	000183f8 	.word	0x000183f8
    2dfc:	00017fac 	.word	0x00017fac
    2e00:	00017f7c 	.word	0x00017f7c
    2e04:	000185e4 	.word	0x000185e4
    2e08:	1fff8b44 	.word	0x1fff8b44
    2e0c:	00017f4c 	.word	0x00017f4c
    2e10:	00018534 	.word	0x00018534
    2e14:	00017f9c 	.word	0x00017f9c
    2e18:	000185a8 	.word	0x000185a8

00002e1c <Clock_Ip_DisableClockMonitor>:
 * Description   : Disables a clock monitor.
 *
 * @implements Clock_Ip_DisableClockMonitor_Activity
 * END**********************************************************************************/
void Clock_Ip_DisableClockMonitor(Clock_Ip_NameType ClockName)
{
    2e1c:	b500      	push	{lr}
    2e1e:	b085      	sub	sp, #20
    2e20:	9001      	str	r0, [sp, #4]

    uint32 CallbackIndex;

    CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[ClockName][CLOCK_IP_CALLBACK]];
    2e22:	490c      	ldr	r1, [pc, #48]	; (2e54 <Clock_Ip_DisableClockMonitor+0x38>)
    2e24:	9a01      	ldr	r2, [sp, #4]
    2e26:	4613      	mov	r3, r2
    2e28:	00db      	lsls	r3, r3, #3
    2e2a:	4413      	add	r3, r2
    2e2c:	440b      	add	r3, r1
    2e2e:	3301      	adds	r3, #1
    2e30:	781b      	ldrb	r3, [r3, #0]
    2e32:	461a      	mov	r2, r3
    2e34:	4b08      	ldr	r3, [pc, #32]	; (2e58 <Clock_Ip_DisableClockMonitor+0x3c>)
    2e36:	5c9b      	ldrb	r3, [r3, r2]
    2e38:	9303      	str	r3, [sp, #12]
    Clock_Ip_axCmuCallbacks[CallbackIndex].Disable(ClockName);
    2e3a:	4a08      	ldr	r2, [pc, #32]	; (2e5c <Clock_Ip_DisableClockMonitor+0x40>)
    2e3c:	9b03      	ldr	r3, [sp, #12]
    2e3e:	011b      	lsls	r3, r3, #4
    2e40:	4413      	add	r3, r2
    2e42:	3308      	adds	r3, #8
    2e44:	681b      	ldr	r3, [r3, #0]
    2e46:	9801      	ldr	r0, [sp, #4]
    2e48:	4798      	blx	r3
}
    2e4a:	bf00      	nop
    2e4c:	b005      	add	sp, #20
    2e4e:	f85d fb04 	ldr.w	pc, [sp], #4
    2e52:	bf00      	nop
    2e54:	00017fac 	.word	0x00017fac
    2e58:	00017f9c 	.word	0x00017f9c
    2e5c:	000185a8 	.word	0x000185a8

00002e60 <Clock_Ip_InstallNotificationsCallback>:
 * Description   : This function installs a callback for clock notifications.
 *
 * @implements Clock_Ip_InstallNotificationsCallback_Activity
 * END**********************************************************************************/
void Clock_Ip_InstallNotificationsCallback(Clock_Ip_NotificationsCallbackType Callback)
{
    2e60:	b082      	sub	sp, #8
    2e62:	9001      	str	r0, [sp, #4]
    CLOCK_IP_DEV_ASSERT(NULL_PTR != Callback);

    Clock_Ip_pfkNotificationsCallback = Callback;
    2e64:	4a02      	ldr	r2, [pc, #8]	; (2e70 <Clock_Ip_InstallNotificationsCallback+0x10>)
    2e66:	9b01      	ldr	r3, [sp, #4]
    2e68:	6013      	str	r3, [r2, #0]
}
    2e6a:	bf00      	nop
    2e6c:	b002      	add	sp, #8
    2e6e:	4770      	bx	lr
    2e70:	1fff8b14 	.word	0x1fff8b14

00002e74 <Clock_Ip_DisableModuleClock>:
 * Description   : Disables clock for a peripheral.
 *
 * @implements Clock_Ip_DisableModuleClock_Activity
 * END**********************************************************************************/
void Clock_Ip_DisableModuleClock(Clock_Ip_NameType ClockName)
{
    2e74:	b500      	push	{lr}
    2e76:	b085      	sub	sp, #20
    2e78:	9001      	str	r0, [sp, #4]

    uint32 CallbackIndex;

    CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[ClockName][CLOCK_IP_CALLBACK]];
    2e7a:	490c      	ldr	r1, [pc, #48]	; (2eac <Clock_Ip_DisableModuleClock+0x38>)
    2e7c:	9a01      	ldr	r2, [sp, #4]
    2e7e:	4613      	mov	r3, r2
    2e80:	00db      	lsls	r3, r3, #3
    2e82:	4413      	add	r3, r2
    2e84:	440b      	add	r3, r1
    2e86:	3301      	adds	r3, #1
    2e88:	781b      	ldrb	r3, [r3, #0]
    2e8a:	461a      	mov	r2, r3
    2e8c:	4b08      	ldr	r3, [pc, #32]	; (2eb0 <Clock_Ip_DisableModuleClock+0x3c>)
    2e8e:	5c9b      	ldrb	r3, [r3, r2]
    2e90:	9303      	str	r3, [sp, #12]
    Clock_Ip_axGateCallbacks[CallbackIndex].Update(ClockName,TRUE);
    2e92:	4a08      	ldr	r2, [pc, #32]	; (2eb4 <Clock_Ip_DisableModuleClock+0x40>)
    2e94:	9b03      	ldr	r3, [sp, #12]
    2e96:	00db      	lsls	r3, r3, #3
    2e98:	4413      	add	r3, r2
    2e9a:	685b      	ldr	r3, [r3, #4]
    2e9c:	2101      	movs	r1, #1
    2e9e:	9801      	ldr	r0, [sp, #4]
    2ea0:	4798      	blx	r3
}
    2ea2:	bf00      	nop
    2ea4:	b005      	add	sp, #20
    2ea6:	f85d fb04 	ldr.w	pc, [sp], #4
    2eaa:	bf00      	nop
    2eac:	00017fac 	.word	0x00017fac
    2eb0:	00017f4c 	.word	0x00017f4c
    2eb4:	00018534 	.word	0x00018534

00002eb8 <Clock_Ip_EnableModuleClock>:
 * Description   : Enable clock for a peripheral.
 *
 * @implements Clock_Ip_EnableModuleClock_Activity
 * END**********************************************************************************/
void Clock_Ip_EnableModuleClock(Clock_Ip_NameType ClockName)
{
    2eb8:	b500      	push	{lr}
    2eba:	b085      	sub	sp, #20
    2ebc:	9001      	str	r0, [sp, #4]

    uint32 CallbackIndex;

    CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[ClockName][CLOCK_IP_CALLBACK]];
    2ebe:	490c      	ldr	r1, [pc, #48]	; (2ef0 <Clock_Ip_EnableModuleClock+0x38>)
    2ec0:	9a01      	ldr	r2, [sp, #4]
    2ec2:	4613      	mov	r3, r2
    2ec4:	00db      	lsls	r3, r3, #3
    2ec6:	4413      	add	r3, r2
    2ec8:	440b      	add	r3, r1
    2eca:	3301      	adds	r3, #1
    2ecc:	781b      	ldrb	r3, [r3, #0]
    2ece:	461a      	mov	r2, r3
    2ed0:	4b08      	ldr	r3, [pc, #32]	; (2ef4 <Clock_Ip_EnableModuleClock+0x3c>)
    2ed2:	5c9b      	ldrb	r3, [r3, r2]
    2ed4:	9303      	str	r3, [sp, #12]
    Clock_Ip_axGateCallbacks[CallbackIndex].Update(ClockName,FALSE);
    2ed6:	4a08      	ldr	r2, [pc, #32]	; (2ef8 <Clock_Ip_EnableModuleClock+0x40>)
    2ed8:	9b03      	ldr	r3, [sp, #12]
    2eda:	00db      	lsls	r3, r3, #3
    2edc:	4413      	add	r3, r2
    2ede:	685b      	ldr	r3, [r3, #4]
    2ee0:	2100      	movs	r1, #0
    2ee2:	9801      	ldr	r0, [sp, #4]
    2ee4:	4798      	blx	r3
}
    2ee6:	bf00      	nop
    2ee8:	b005      	add	sp, #20
    2eea:	f85d fb04 	ldr.w	pc, [sp], #4
    2eee:	bf00      	nop
    2ef0:	00017fac 	.word	0x00017fac
    2ef4:	00017f4c 	.word	0x00017f4c
    2ef8:	00018534 	.word	0x00018534

00002efc <Clock_Ip_PowerModeChangeNotification>:
 * Description   : Notifies clock driver when a power mode is changed.
 *
 * @implements Clock_Ip_PowerModeChangeNotification_Activity
 * END**********************************************************************************/
void Clock_Ip_PowerModeChangeNotification(Clock_Ip_PowerModesType PowerMode,Clock_Ip_PowerNotificationType Notification)
{
    2efc:	b500      	push	{lr}
    2efe:	b083      	sub	sp, #12
    2f00:	9001      	str	r0, [sp, #4]
    2f02:	9100      	str	r1, [sp, #0]
    Clock_Ip_bSentFromUpdateDriverContext  = FALSE;
    2f04:	4b08      	ldr	r3, [pc, #32]	; (2f28 <Clock_Ip_PowerModeChangeNotification+0x2c>)
    2f06:	2200      	movs	r2, #0
    2f08:	701a      	strb	r2, [r3, #0]
    Clock_Ip_Command(Clock_Ip_pxConfig, CLOCK_IP_INITIALIZE_CLOCK_OBJECTS_COMMAND);
    2f0a:	4b08      	ldr	r3, [pc, #32]	; (2f2c <Clock_Ip_PowerModeChangeNotification+0x30>)
    2f0c:	681b      	ldr	r3, [r3, #0]
    2f0e:	2102      	movs	r1, #2
    2f10:	4618      	mov	r0, r3
    2f12:	f002 fd75 	bl	5a00 <Clock_Ip_Command>

    Clock_Ip_ClockPowerModeChangeNotification(PowerMode, Notification);
    2f16:	9900      	ldr	r1, [sp, #0]
    2f18:	9801      	ldr	r0, [sp, #4]
    2f1a:	f002 fc51 	bl	57c0 <Clock_Ip_ClockPowerModeChangeNotification>
}
    2f1e:	bf00      	nop
    2f20:	b003      	add	sp, #12
    2f22:	f85d fb04 	ldr.w	pc, [sp], #4
    2f26:	bf00      	nop
    2f28:	1fff8b10 	.word	0x1fff8b10
    2f2c:	1fff8b3c 	.word	0x1fff8b3c

00002f30 <Clock_Ip_SetWaitStates>:
 * Function Name : Clock_Ip_SetWaitStates
 * Description   : Hardware wait states are not supported, checking function.
 *
 *END**************************************************************************/
static void Clock_Ip_SetWaitStates(void)
{
    2f30:	b082      	sub	sp, #8
    uint32 Counter = CLOCK_IP_WAIT_STATES_DELAY;
    2f32:	f06f 5380 	mvn.w	r3, #268435456	; 0x10000000
    2f36:	9301      	str	r3, [sp, #4]
    
    /* HW doesn't support wait states configuration */
    if (DriverContext.WaitStatesAreSupported)
    2f38:	4b06      	ldr	r3, [pc, #24]	; (2f54 <Clock_Ip_SetWaitStates+0x24>)
    2f3a:	785b      	ldrb	r3, [r3, #1]
    2f3c:	2b00      	cmp	r3, #0
    2f3e:	d005      	beq.n	2f4c <Clock_Ip_SetWaitStates+0x1c>
        /* Wait states are not supported by HW,
           insert a delay . */

        do
        {
            Counter--;
    2f40:	9b01      	ldr	r3, [sp, #4]
    2f42:	3b01      	subs	r3, #1
    2f44:	9301      	str	r3, [sp, #4]
        }
        while(Counter > 0u);
    2f46:	9b01      	ldr	r3, [sp, #4]
    2f48:	2b00      	cmp	r3, #0
    2f4a:	d1f9      	bne.n	2f40 <Clock_Ip_SetWaitStates+0x10>
    }
}
    2f4c:	bf00      	nop
    2f4e:	b002      	add	sp, #8
    2f50:	4770      	bx	lr
    2f52:	bf00      	nop
    2f54:	1fff8b44 	.word	0x1fff8b44

00002f58 <Clock_Ip_ReportClockErrors>:
 * Function Name : Clock_Ip_ReportClockErrors
 * Description   : Report clock error
 *
 *END**************************************************************************/
void Clock_Ip_ReportClockErrors(Clock_Ip_NotificationType Error, Clock_Ip_NameType ClockName)
{
    2f58:	b500      	push	{lr}
    2f5a:	b083      	sub	sp, #12
    2f5c:	9001      	str	r0, [sp, #4]
    2f5e:	9100      	str	r1, [sp, #0]
    Clock_Ip_pfkNotificationsCallback(Error,ClockName);
    2f60:	4b04      	ldr	r3, [pc, #16]	; (2f74 <Clock_Ip_ReportClockErrors+0x1c>)
    2f62:	681b      	ldr	r3, [r3, #0]
    2f64:	9900      	ldr	r1, [sp, #0]
    2f66:	9801      	ldr	r0, [sp, #4]
    2f68:	4798      	blx	r3
}
    2f6a:	bf00      	nop
    2f6c:	b003      	add	sp, #12
    2f6e:	f85d fb04 	ldr.w	pc, [sp], #4
    2f72:	bf00      	nop
    2f74:	1fff8b14 	.word	0x1fff8b14

00002f78 <Clock_Ip_StartTimeout>:
 *END**************************************************************************/
void Clock_Ip_StartTimeout(uint32 *StartTimeOut,
                       uint32 *ElapsedTimeOut,
                       uint32 *TimeoutTicksOut,
                       uint32 TimeoutUs)
{
    2f78:	b500      	push	{lr}
    2f7a:	b085      	sub	sp, #20
    2f7c:	9003      	str	r0, [sp, #12]
    2f7e:	9102      	str	r1, [sp, #8]
    2f80:	9201      	str	r2, [sp, #4]
    2f82:	9300      	str	r3, [sp, #0]
    *StartTimeOut    = OsIf_GetCounter(CLOCK_IP_TIMEOUT_TYPE);
    2f84:	2000      	movs	r0, #0
    2f86:	f7fe ffd1 	bl	1f2c <OsIf_GetCounter>
    2f8a:	4602      	mov	r2, r0
    2f8c:	9b03      	ldr	r3, [sp, #12]
    2f8e:	601a      	str	r2, [r3, #0]
    *ElapsedTimeOut  = 0U;
    2f90:	9b02      	ldr	r3, [sp, #8]
    2f92:	2200      	movs	r2, #0
    2f94:	601a      	str	r2, [r3, #0]
    *TimeoutTicksOut = OsIf_MicrosToTicks(TimeoutUs, CLOCK_IP_TIMEOUT_TYPE);
    2f96:	2100      	movs	r1, #0
    2f98:	9800      	ldr	r0, [sp, #0]
    2f9a:	f7ff f813 	bl	1fc4 <OsIf_MicrosToTicks>
    2f9e:	4602      	mov	r2, r0
    2fa0:	9b01      	ldr	r3, [sp, #4]
    2fa2:	601a      	str	r2, [r3, #0]
}
    2fa4:	bf00      	nop
    2fa6:	b005      	add	sp, #20
    2fa8:	f85d fb04 	ldr.w	pc, [sp], #4

00002fac <Clock_Ip_TimeoutExpired>:
 *
 *END**************************************************************************/
boolean Clock_Ip_TimeoutExpired(uint32 *StartTimeInOut,
                            uint32 *ElapsedTimeInOut,
                            uint32 TimeoutTicks)
{
    2fac:	b500      	push	{lr}
    2fae:	b087      	sub	sp, #28
    2fb0:	9003      	str	r0, [sp, #12]
    2fb2:	9102      	str	r1, [sp, #8]
    2fb4:	9201      	str	r2, [sp, #4]
    boolean RetVal = FALSE;
    2fb6:	2300      	movs	r3, #0
    2fb8:	f88d 3017 	strb.w	r3, [sp, #23]
    *ElapsedTimeInOut += OsIf_GetElapsed(StartTimeInOut, CLOCK_IP_TIMEOUT_TYPE);
    2fbc:	2100      	movs	r1, #0
    2fbe:	9803      	ldr	r0, [sp, #12]
    2fc0:	f7fe ffcd 	bl	1f5e <OsIf_GetElapsed>
    2fc4:	4602      	mov	r2, r0
    2fc6:	9b02      	ldr	r3, [sp, #8]
    2fc8:	681b      	ldr	r3, [r3, #0]
    2fca:	441a      	add	r2, r3
    2fcc:	9b02      	ldr	r3, [sp, #8]
    2fce:	601a      	str	r2, [r3, #0]

    if (*ElapsedTimeInOut >= TimeoutTicks)
    2fd0:	9b02      	ldr	r3, [sp, #8]
    2fd2:	681b      	ldr	r3, [r3, #0]
    2fd4:	9a01      	ldr	r2, [sp, #4]
    2fd6:	429a      	cmp	r2, r3
    2fd8:	d802      	bhi.n	2fe0 <Clock_Ip_TimeoutExpired+0x34>
    {
        RetVal = TRUE;
    2fda:	2301      	movs	r3, #1
    2fdc:	f88d 3017 	strb.w	r3, [sp, #23]
    }
    return RetVal;
    2fe0:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    2fe4:	4618      	mov	r0, r3
    2fe6:	b007      	add	sp, #28
    2fe8:	f85d fb04 	ldr.w	pc, [sp], #4

00002fec <Clock_Ip_Callback_DividerEmpty>:
/* Clock start section code */

#include "Mcu_MemMap.h"

static void Clock_Ip_Callback_DividerEmpty(Clock_Ip_DividerConfigType const* Config)
{
    2fec:	b082      	sub	sp, #8
    2fee:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    2ff0:	bf00      	nop
    2ff2:	b002      	add	sp, #8
    2ff4:	4770      	bx	lr

00002ff6 <Clock_Ip_SetScgAsyncDiv1>:

#ifdef CLOCK_IP_SCG_ASYNC_DIV1
static void Clock_Ip_SetScgAsyncDiv1(Clock_Ip_DividerConfigType const* Config)
{
    2ff6:	b500      	push	{lr}
    2ff8:	b083      	sub	sp, #12
    2ffa:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2ffc:	9b01      	ldr	r3, [sp, #4]
    2ffe:	2b00      	cmp	r3, #0
    3000:	d002      	beq.n	3008 <Clock_Ip_SetScgAsyncDiv1+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgAsyncDiv1_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgAsyncDiv1_TrustedCall(Config);
    3002:	9801      	ldr	r0, [sp, #4]
    3004:	f000 f8ad 	bl	3162 <Clock_Ip_SetScgAsyncDiv1_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3008:	bf00      	nop
    300a:	b003      	add	sp, #12
    300c:	f85d fb04 	ldr.w	pc, [sp], #4

00003010 <Clock_Ip_SetScgAsyncDiv2>:
#endif

#ifdef CLOCK_IP_SCG_ASYNC_DIV2
static void Clock_Ip_SetScgAsyncDiv2(Clock_Ip_DividerConfigType const* Config)
{
    3010:	b500      	push	{lr}
    3012:	b083      	sub	sp, #12
    3014:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3016:	9b01      	ldr	r3, [sp, #4]
    3018:	2b00      	cmp	r3, #0
    301a:	d002      	beq.n	3022 <Clock_Ip_SetScgAsyncDiv2+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgAsyncDiv2_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgAsyncDiv2_TrustedCall(Config);
    301c:	9801      	ldr	r0, [sp, #4]
    301e:	f000 f8cd 	bl	31bc <Clock_Ip_SetScgAsyncDiv2_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3022:	bf00      	nop
    3024:	b003      	add	sp, #12
    3026:	f85d fb04 	ldr.w	pc, [sp], #4

0000302a <Clock_Ip_SetScgRunDivcore>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_RUN
static void Clock_Ip_SetScgRunDivcore(Clock_Ip_DividerConfigType const* Config)
{
    302a:	b500      	push	{lr}
    302c:	b083      	sub	sp, #12
    302e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3030:	9b01      	ldr	r3, [sp, #4]
    3032:	2b00      	cmp	r3, #0
    3034:	d002      	beq.n	303c <Clock_Ip_SetScgRunDivcore+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunDivcore_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunDivcore_TrustedCall(Config);
    3036:	9801      	ldr	r0, [sp, #4]
    3038:	f000 f8ee 	bl	3218 <Clock_Ip_SetScgRunDivcore_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    303c:	bf00      	nop
    303e:	b003      	add	sp, #12
    3040:	f85d fb04 	ldr.w	pc, [sp], #4

00003044 <Clock_Ip_SetScgRunDivbus>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_RUN
static void Clock_Ip_SetScgRunDivbus(Clock_Ip_DividerConfigType const* Config)
{
    3044:	b500      	push	{lr}
    3046:	b083      	sub	sp, #12
    3048:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    304a:	9b01      	ldr	r3, [sp, #4]
    304c:	2b00      	cmp	r3, #0
    304e:	d002      	beq.n	3056 <Clock_Ip_SetScgRunDivbus+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunDivbus_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunDivbus_TrustedCall(Config);
    3050:	9801      	ldr	r0, [sp, #4]
    3052:	f000 f8f9 	bl	3248 <Clock_Ip_SetScgRunDivbus_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3056:	bf00      	nop
    3058:	b003      	add	sp, #12
    305a:	f85d fb04 	ldr.w	pc, [sp], #4

0000305e <Clock_Ip_SetScgRunDivslow>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_RUN
static void Clock_Ip_SetScgRunDivslow(Clock_Ip_DividerConfigType const* Config)
{
    305e:	b500      	push	{lr}
    3060:	b083      	sub	sp, #12
    3062:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3064:	9b01      	ldr	r3, [sp, #4]
    3066:	2b00      	cmp	r3, #0
    3068:	d002      	beq.n	3070 <Clock_Ip_SetScgRunDivslow+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunDivslow_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunDivslow_TrustedCall(Config);
    306a:	9801      	ldr	r0, [sp, #4]
    306c:	f000 f904 	bl	3278 <Clock_Ip_SetScgRunDivslow_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3070:	bf00      	nop
    3072:	b003      	add	sp, #12
    3074:	f85d fb04 	ldr.w	pc, [sp], #4

00003078 <Clock_Ip_SetScgVlprDivcore>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_VLPR
static void Clock_Ip_SetScgVlprDivcore(Clock_Ip_DividerConfigType const* Config)
{
    3078:	b500      	push	{lr}
    307a:	b083      	sub	sp, #12
    307c:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    307e:	9b01      	ldr	r3, [sp, #4]
    3080:	2b00      	cmp	r3, #0
    3082:	d002      	beq.n	308a <Clock_Ip_SetScgVlprDivcore+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprDivcore_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprDivcore_TrustedCall(Config);
    3084:	9801      	ldr	r0, [sp, #4]
    3086:	f000 f90f 	bl	32a8 <Clock_Ip_SetScgVlprDivcore_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    308a:	bf00      	nop
    308c:	b003      	add	sp, #12
    308e:	f85d fb04 	ldr.w	pc, [sp], #4

00003092 <Clock_Ip_SetScgVlprDivbus>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_VLPR
static void Clock_Ip_SetScgVlprDivbus(Clock_Ip_DividerConfigType const* Config)
{
    3092:	b500      	push	{lr}
    3094:	b083      	sub	sp, #12
    3096:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3098:	9b01      	ldr	r3, [sp, #4]
    309a:	2b00      	cmp	r3, #0
    309c:	d002      	beq.n	30a4 <Clock_Ip_SetScgVlprDivbus+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprDivbus_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprDivbus_TrustedCall(Config);
    309e:	9801      	ldr	r0, [sp, #4]
    30a0:	f000 f91a 	bl	32d8 <Clock_Ip_SetScgVlprDivbus_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    30a4:	bf00      	nop
    30a6:	b003      	add	sp, #12
    30a8:	f85d fb04 	ldr.w	pc, [sp], #4

000030ac <Clock_Ip_SetScgVlprDivslow>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_VLPR
static void Clock_Ip_SetScgVlprDivslow(Clock_Ip_DividerConfigType const* Config)
{
    30ac:	b500      	push	{lr}
    30ae:	b083      	sub	sp, #12
    30b0:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    30b2:	9b01      	ldr	r3, [sp, #4]
    30b4:	2b00      	cmp	r3, #0
    30b6:	d002      	beq.n	30be <Clock_Ip_SetScgVlprDivslow+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprDivslow_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprDivslow_TrustedCall(Config);
    30b8:	9801      	ldr	r0, [sp, #4]
    30ba:	f000 f925 	bl	3308 <Clock_Ip_SetScgVlprDivslow_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    30be:	bf00      	nop
    30c0:	b003      	add	sp, #12
    30c2:	f85d fb04 	ldr.w	pc, [sp], #4

000030c6 <Clock_Ip_SetScgHsrunDivcore>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_HSRUN
static void Clock_Ip_SetScgHsrunDivcore(Clock_Ip_DividerConfigType const* Config)
{
    30c6:	b500      	push	{lr}
    30c8:	b083      	sub	sp, #12
    30ca:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    30cc:	9b01      	ldr	r3, [sp, #4]
    30ce:	2b00      	cmp	r3, #0
    30d0:	d002      	beq.n	30d8 <Clock_Ip_SetScgHsrunDivcore+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunDivcore_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunDivcore_TrustedCall(Config);
    30d2:	9801      	ldr	r0, [sp, #4]
    30d4:	f000 f930 	bl	3338 <Clock_Ip_SetScgHsrunDivcore_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    30d8:	bf00      	nop
    30da:	b003      	add	sp, #12
    30dc:	f85d fb04 	ldr.w	pc, [sp], #4

000030e0 <Clock_Ip_SetScgHsrunDivbus>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_HSRUN
static void Clock_Ip_SetScgHsrunDivbus(Clock_Ip_DividerConfigType const* Config)
{
    30e0:	b500      	push	{lr}
    30e2:	b083      	sub	sp, #12
    30e4:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    30e6:	9b01      	ldr	r3, [sp, #4]
    30e8:	2b00      	cmp	r3, #0
    30ea:	d002      	beq.n	30f2 <Clock_Ip_SetScgHsrunDivbus+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunDivbus_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunDivbus_TrustedCall(Config);
    30ec:	9801      	ldr	r0, [sp, #4]
    30ee:	f000 f93b 	bl	3368 <Clock_Ip_SetScgHsrunDivbus_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    30f2:	bf00      	nop
    30f4:	b003      	add	sp, #12
    30f6:	f85d fb04 	ldr.w	pc, [sp], #4

000030fa <Clock_Ip_SetScgHsrunDivslow>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_HSRUN
static void Clock_Ip_SetScgHsrunDivslow(Clock_Ip_DividerConfigType const* Config)
{
    30fa:	b500      	push	{lr}
    30fc:	b083      	sub	sp, #12
    30fe:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3100:	9b01      	ldr	r3, [sp, #4]
    3102:	2b00      	cmp	r3, #0
    3104:	d002      	beq.n	310c <Clock_Ip_SetScgHsrunDivslow+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunDivslow_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunDivslow_TrustedCall(Config);
    3106:	9801      	ldr	r0, [sp, #4]
    3108:	f000 f946 	bl	3398 <Clock_Ip_SetScgHsrunDivslow_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    310c:	bf00      	nop
    310e:	b003      	add	sp, #12
    3110:	f85d fb04 	ldr.w	pc, [sp], #4

00003114 <Clock_Ip_SetSimClkoutDiv>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_DIV
static void Clock_Ip_SetSimClkoutDiv(Clock_Ip_DividerConfigType const *Config)
{
    3114:	b500      	push	{lr}
    3116:	b083      	sub	sp, #12
    3118:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    311a:	9b01      	ldr	r3, [sp, #4]
    311c:	2b00      	cmp	r3, #0
    311e:	d002      	beq.n	3126 <Clock_Ip_SetSimClkoutDiv+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimClkoutDiv_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimClkoutDiv_TrustedCall(Config);
    3120:	9801      	ldr	r0, [sp, #4]
    3122:	f000 f951 	bl	33c8 <Clock_Ip_SetSimClkoutDiv_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3126:	bf00      	nop
    3128:	b003      	add	sp, #12
    312a:	f85d fb04 	ldr.w	pc, [sp], #4

0000312e <Clock_Ip_SetPccPcdDivFrac>:
#endif

#ifdef CLOCK_IP_PCC_PCD_FRAC
static void Clock_Ip_SetPccPcdDivFrac(Clock_Ip_DividerConfigType const* Config)
{
    312e:	b500      	push	{lr}
    3130:	b083      	sub	sp, #12
    3132:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3134:	9b01      	ldr	r3, [sp, #4]
    3136:	2b00      	cmp	r3, #0
    3138:	d002      	beq.n	3140 <Clock_Ip_SetPccPcdDivFrac+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetPccPcdDivFrac_TrustedCall,(Config));
      #else
        Clock_Ip_SetPccPcdDivFrac_TrustedCall(Config);
    313a:	9801      	ldr	r0, [sp, #4]
    313c:	f000 f95e 	bl	33fc <Clock_Ip_SetPccPcdDivFrac_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3140:	bf00      	nop
    3142:	b003      	add	sp, #12
    3144:	f85d fb04 	ldr.w	pc, [sp], #4

00003148 <Clock_Ip_SetSimTraceDivMul>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_DIV_MUL
static void Clock_Ip_SetSimTraceDivMul(Clock_Ip_DividerConfigType const* Config)
{
    3148:	b500      	push	{lr}
    314a:	b083      	sub	sp, #12
    314c:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    314e:	9b01      	ldr	r3, [sp, #4]
    3150:	2b00      	cmp	r3, #0
    3152:	d002      	beq.n	315a <Clock_Ip_SetSimTraceDivMul+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimTraceDivMul_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimTraceDivMul_TrustedCall(Config);
    3154:	9801      	ldr	r0, [sp, #4]
    3156:	f000 f98b 	bl	3470 <Clock_Ip_SetSimTraceDivMul_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    315a:	bf00      	nop
    315c:	b003      	add	sp, #12
    315e:	f85d fb04 	ldr.w	pc, [sp], #4

00003162 <Clock_Ip_SetScgAsyncDiv1_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SCG_ASYNC_DIV1
void Clock_Ip_SetScgAsyncDiv1_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    3162:	b086      	sub	sp, #24
    3164:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    3166:	9b01      	ldr	r3, [sp, #4]
    3168:	681a      	ldr	r2, [r3, #0]
    316a:	4911      	ldr	r1, [pc, #68]	; (31b0 <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x4e>)
    316c:	4613      	mov	r3, r2
    316e:	00db      	lsls	r3, r3, #3
    3170:	4413      	add	r3, r2
    3172:	440b      	add	r3, r1
    3174:	781b      	ldrb	r3, [r3, #0]
    3176:	9305      	str	r3, [sp, #20]
    uint32 DividerValue  = Clock_Ip_au8DividerValueHardwareValue[Config->Value];    /* Hw value corresponding to divider value. Translate the value by which is divided to hardware value. */
    3178:	9b01      	ldr	r3, [sp, #4]
    317a:	685b      	ldr	r3, [r3, #4]
    317c:	4a0d      	ldr	r2, [pc, #52]	; (31b4 <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x52>)
    317e:	5cd3      	ldrb	r3, [r2, r3]
    3180:	9304      	str	r3, [sp, #16]


    RegValue = Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV;
    3182:	4a0d      	ldr	r2, [pc, #52]	; (31b8 <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x56>)
    3184:	9b05      	ldr	r3, [sp, #20]
    3186:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    318a:	681b      	ldr	r3, [r3, #0]
    318c:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_SIRCDIV_SIRCDIV1_MASK;
    318e:	9b03      	ldr	r3, [sp, #12]
    3190:	f023 0307 	bic.w	r3, r3, #7
    3194:	9303      	str	r3, [sp, #12]
    RegValue |= (DividerValue << SCG_SIRCDIV_SIRCDIV1_SHIFT);
    3196:	9a03      	ldr	r2, [sp, #12]
    3198:	9b04      	ldr	r3, [sp, #16]
    319a:	4313      	orrs	r3, r2
    319c:	9303      	str	r3, [sp, #12]
    Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV = RegValue;
    319e:	4a06      	ldr	r2, [pc, #24]	; (31b8 <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x56>)
    31a0:	9b05      	ldr	r3, [sp, #20]
    31a2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    31a6:	9a03      	ldr	r2, [sp, #12]
    31a8:	601a      	str	r2, [r3, #0]
}
    31aa:	bf00      	nop
    31ac:	b006      	add	sp, #24
    31ae:	4770      	bx	lr
    31b0:	00017fac 	.word	0x00017fac
    31b4:	000183a4 	.word	0x000183a4
    31b8:	000183e8 	.word	0x000183e8

000031bc <Clock_Ip_SetScgAsyncDiv2_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_ASYNC_DIV2
void Clock_Ip_SetScgAsyncDiv2_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    31bc:	b086      	sub	sp, #24
    31be:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    31c0:	9b01      	ldr	r3, [sp, #4]
    31c2:	681a      	ldr	r2, [r3, #0]
    31c4:	4911      	ldr	r1, [pc, #68]	; (320c <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x50>)
    31c6:	4613      	mov	r3, r2
    31c8:	00db      	lsls	r3, r3, #3
    31ca:	4413      	add	r3, r2
    31cc:	440b      	add	r3, r1
    31ce:	781b      	ldrb	r3, [r3, #0]
    31d0:	9305      	str	r3, [sp, #20]
    uint32 DividerValue  = Clock_Ip_au8DividerValueHardwareValue[Config->Value];    /* Hw value corresponding to divider value. Translate the value by which is divided to hardware value. */
    31d2:	9b01      	ldr	r3, [sp, #4]
    31d4:	685b      	ldr	r3, [r3, #4]
    31d6:	4a0e      	ldr	r2, [pc, #56]	; (3210 <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x54>)
    31d8:	5cd3      	ldrb	r3, [r2, r3]
    31da:	9304      	str	r3, [sp, #16]

    RegValue = Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV;
    31dc:	4a0d      	ldr	r2, [pc, #52]	; (3214 <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x58>)
    31de:	9b05      	ldr	r3, [sp, #20]
    31e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    31e4:	681b      	ldr	r3, [r3, #0]
    31e6:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_SIRCDIV_SIRCDIV2_MASK;
    31e8:	9b03      	ldr	r3, [sp, #12]
    31ea:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    31ee:	9303      	str	r3, [sp, #12]
    RegValue |= (DividerValue << SCG_SIRCDIV_SIRCDIV2_SHIFT);
    31f0:	9b04      	ldr	r3, [sp, #16]
    31f2:	021b      	lsls	r3, r3, #8
    31f4:	9a03      	ldr	r2, [sp, #12]
    31f6:	4313      	orrs	r3, r2
    31f8:	9303      	str	r3, [sp, #12]
    Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV = RegValue;
    31fa:	4a06      	ldr	r2, [pc, #24]	; (3214 <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x58>)
    31fc:	9b05      	ldr	r3, [sp, #20]
    31fe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    3202:	9a03      	ldr	r2, [sp, #12]
    3204:	601a      	str	r2, [r3, #0]
}
    3206:	bf00      	nop
    3208:	b006      	add	sp, #24
    320a:	4770      	bx	lr
    320c:	00017fac 	.word	0x00017fac
    3210:	000183a4 	.word	0x000183a4
    3214:	000183e8 	.word	0x000183e8

00003218 <Clock_Ip_SetScgRunDivcore_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_RUN
/* Set divider value of CORE_RUN_CLK to register */
void Clock_Ip_SetScgRunDivcore_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    3218:	b084      	sub	sp, #16
    321a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->RCCR;
    321c:	4b09      	ldr	r3, [pc, #36]	; (3244 <Clock_Ip_SetScgRunDivcore_TrustedCall+0x2c>)
    321e:	695b      	ldr	r3, [r3, #20]
    3220:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_RCCR_DIVCORE_MASK;
    3222:	9b03      	ldr	r3, [sp, #12]
    3224:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    3228:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_RCCR_DIVCORE_SHIFT);
    322a:	9b01      	ldr	r3, [sp, #4]
    322c:	685b      	ldr	r3, [r3, #4]
    322e:	3b01      	subs	r3, #1
    3230:	041b      	lsls	r3, r3, #16
    3232:	9a03      	ldr	r2, [sp, #12]
    3234:	4313      	orrs	r3, r2
    3236:	9303      	str	r3, [sp, #12]
    IP_SCG->RCCR = RegValue;
    3238:	4a02      	ldr	r2, [pc, #8]	; (3244 <Clock_Ip_SetScgRunDivcore_TrustedCall+0x2c>)
    323a:	9b03      	ldr	r3, [sp, #12]
    323c:	6153      	str	r3, [r2, #20]
}
    323e:	bf00      	nop
    3240:	b004      	add	sp, #16
    3242:	4770      	bx	lr
    3244:	40064000 	.word	0x40064000

00003248 <Clock_Ip_SetScgRunDivbus_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_RUN
/* Set divider value of BUS_RUN_CLK to register */
void Clock_Ip_SetScgRunDivbus_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    3248:	b084      	sub	sp, #16
    324a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->RCCR;
    324c:	4b09      	ldr	r3, [pc, #36]	; (3274 <Clock_Ip_SetScgRunDivbus_TrustedCall+0x2c>)
    324e:	695b      	ldr	r3, [r3, #20]
    3250:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_RCCR_DIVBUS_MASK;
    3252:	9b03      	ldr	r3, [sp, #12]
    3254:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    3258:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_RCCR_DIVBUS_SHIFT);
    325a:	9b01      	ldr	r3, [sp, #4]
    325c:	685b      	ldr	r3, [r3, #4]
    325e:	3b01      	subs	r3, #1
    3260:	011b      	lsls	r3, r3, #4
    3262:	9a03      	ldr	r2, [sp, #12]
    3264:	4313      	orrs	r3, r2
    3266:	9303      	str	r3, [sp, #12]
    IP_SCG->RCCR = RegValue;
    3268:	4a02      	ldr	r2, [pc, #8]	; (3274 <Clock_Ip_SetScgRunDivbus_TrustedCall+0x2c>)
    326a:	9b03      	ldr	r3, [sp, #12]
    326c:	6153      	str	r3, [r2, #20]
}
    326e:	bf00      	nop
    3270:	b004      	add	sp, #16
    3272:	4770      	bx	lr
    3274:	40064000 	.word	0x40064000

00003278 <Clock_Ip_SetScgRunDivslow_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_RUN
/* Set divider value of SLOW_RUN_CLK to register */
void Clock_Ip_SetScgRunDivslow_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    3278:	b084      	sub	sp, #16
    327a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->RCCR;
    327c:	4b09      	ldr	r3, [pc, #36]	; (32a4 <Clock_Ip_SetScgRunDivslow_TrustedCall+0x2c>)
    327e:	695b      	ldr	r3, [r3, #20]
    3280:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_RCCR_DIVSLOW_MASK;
    3282:	9b03      	ldr	r3, [sp, #12]
    3284:	f023 030f 	bic.w	r3, r3, #15
    3288:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_RCCR_DIVSLOW_SHIFT);
    328a:	9b01      	ldr	r3, [sp, #4]
    328c:	685b      	ldr	r3, [r3, #4]
    328e:	3b01      	subs	r3, #1
    3290:	9a03      	ldr	r2, [sp, #12]
    3292:	4313      	orrs	r3, r2
    3294:	9303      	str	r3, [sp, #12]
    IP_SCG->RCCR = RegValue;
    3296:	4a03      	ldr	r2, [pc, #12]	; (32a4 <Clock_Ip_SetScgRunDivslow_TrustedCall+0x2c>)
    3298:	9b03      	ldr	r3, [sp, #12]
    329a:	6153      	str	r3, [r2, #20]
}
    329c:	bf00      	nop
    329e:	b004      	add	sp, #16
    32a0:	4770      	bx	lr
    32a2:	bf00      	nop
    32a4:	40064000 	.word	0x40064000

000032a8 <Clock_Ip_SetScgVlprDivcore_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_VLPR
/* Set divider value of CORE_VLPR_CLK to register */
void Clock_Ip_SetScgVlprDivcore_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    32a8:	b084      	sub	sp, #16
    32aa:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->VCCR;
    32ac:	4b09      	ldr	r3, [pc, #36]	; (32d4 <Clock_Ip_SetScgVlprDivcore_TrustedCall+0x2c>)
    32ae:	699b      	ldr	r3, [r3, #24]
    32b0:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_VCCR_DIVCORE_MASK;
    32b2:	9b03      	ldr	r3, [sp, #12]
    32b4:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    32b8:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_VCCR_DIVCORE_SHIFT);
    32ba:	9b01      	ldr	r3, [sp, #4]
    32bc:	685b      	ldr	r3, [r3, #4]
    32be:	3b01      	subs	r3, #1
    32c0:	041b      	lsls	r3, r3, #16
    32c2:	9a03      	ldr	r2, [sp, #12]
    32c4:	4313      	orrs	r3, r2
    32c6:	9303      	str	r3, [sp, #12]
    IP_SCG->VCCR = RegValue;
    32c8:	4a02      	ldr	r2, [pc, #8]	; (32d4 <Clock_Ip_SetScgVlprDivcore_TrustedCall+0x2c>)
    32ca:	9b03      	ldr	r3, [sp, #12]
    32cc:	6193      	str	r3, [r2, #24]
}
    32ce:	bf00      	nop
    32d0:	b004      	add	sp, #16
    32d2:	4770      	bx	lr
    32d4:	40064000 	.word	0x40064000

000032d8 <Clock_Ip_SetScgVlprDivbus_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_VLPR
/* Set divider value of BUS_VLPR_CLK to register */
void Clock_Ip_SetScgVlprDivbus_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    32d8:	b084      	sub	sp, #16
    32da:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->VCCR;
    32dc:	4b09      	ldr	r3, [pc, #36]	; (3304 <Clock_Ip_SetScgVlprDivbus_TrustedCall+0x2c>)
    32de:	699b      	ldr	r3, [r3, #24]
    32e0:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_VCCR_DIVBUS_MASK;
    32e2:	9b03      	ldr	r3, [sp, #12]
    32e4:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    32e8:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_VCCR_DIVBUS_SHIFT);
    32ea:	9b01      	ldr	r3, [sp, #4]
    32ec:	685b      	ldr	r3, [r3, #4]
    32ee:	3b01      	subs	r3, #1
    32f0:	011b      	lsls	r3, r3, #4
    32f2:	9a03      	ldr	r2, [sp, #12]
    32f4:	4313      	orrs	r3, r2
    32f6:	9303      	str	r3, [sp, #12]
    IP_SCG->VCCR = RegValue;
    32f8:	4a02      	ldr	r2, [pc, #8]	; (3304 <Clock_Ip_SetScgVlprDivbus_TrustedCall+0x2c>)
    32fa:	9b03      	ldr	r3, [sp, #12]
    32fc:	6193      	str	r3, [r2, #24]
}
    32fe:	bf00      	nop
    3300:	b004      	add	sp, #16
    3302:	4770      	bx	lr
    3304:	40064000 	.word	0x40064000

00003308 <Clock_Ip_SetScgVlprDivslow_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_VLPR
/* Set divider value of SLOW_VLPR_CLK to register */
void Clock_Ip_SetScgVlprDivslow_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    3308:	b084      	sub	sp, #16
    330a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->VCCR;
    330c:	4b09      	ldr	r3, [pc, #36]	; (3334 <Clock_Ip_SetScgVlprDivslow_TrustedCall+0x2c>)
    330e:	699b      	ldr	r3, [r3, #24]
    3310:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_VCCR_DIVSLOW_MASK;
    3312:	9b03      	ldr	r3, [sp, #12]
    3314:	f023 030f 	bic.w	r3, r3, #15
    3318:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_VCCR_DIVSLOW_SHIFT);
    331a:	9b01      	ldr	r3, [sp, #4]
    331c:	685b      	ldr	r3, [r3, #4]
    331e:	3b01      	subs	r3, #1
    3320:	9a03      	ldr	r2, [sp, #12]
    3322:	4313      	orrs	r3, r2
    3324:	9303      	str	r3, [sp, #12]
    IP_SCG->VCCR = RegValue;
    3326:	4a03      	ldr	r2, [pc, #12]	; (3334 <Clock_Ip_SetScgVlprDivslow_TrustedCall+0x2c>)
    3328:	9b03      	ldr	r3, [sp, #12]
    332a:	6193      	str	r3, [r2, #24]
}
    332c:	bf00      	nop
    332e:	b004      	add	sp, #16
    3330:	4770      	bx	lr
    3332:	bf00      	nop
    3334:	40064000 	.word	0x40064000

00003338 <Clock_Ip_SetScgHsrunDivcore_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_HSRUN
/* Set divider value of CORE_HSRUN_CLK to register */
void Clock_Ip_SetScgHsrunDivcore_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    3338:	b084      	sub	sp, #16
    333a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->HCCR;
    333c:	4b09      	ldr	r3, [pc, #36]	; (3364 <Clock_Ip_SetScgHsrunDivcore_TrustedCall+0x2c>)
    333e:	69db      	ldr	r3, [r3, #28]
    3340:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_HCCR_DIVCORE_MASK;
    3342:	9b03      	ldr	r3, [sp, #12]
    3344:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    3348:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_HCCR_DIVCORE_SHIFT);
    334a:	9b01      	ldr	r3, [sp, #4]
    334c:	685b      	ldr	r3, [r3, #4]
    334e:	3b01      	subs	r3, #1
    3350:	041b      	lsls	r3, r3, #16
    3352:	9a03      	ldr	r2, [sp, #12]
    3354:	4313      	orrs	r3, r2
    3356:	9303      	str	r3, [sp, #12]
    IP_SCG->HCCR = RegValue;
    3358:	4a02      	ldr	r2, [pc, #8]	; (3364 <Clock_Ip_SetScgHsrunDivcore_TrustedCall+0x2c>)
    335a:	9b03      	ldr	r3, [sp, #12]
    335c:	61d3      	str	r3, [r2, #28]
}
    335e:	bf00      	nop
    3360:	b004      	add	sp, #16
    3362:	4770      	bx	lr
    3364:	40064000 	.word	0x40064000

00003368 <Clock_Ip_SetScgHsrunDivbus_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_HSRUN
/* Set divider value of BUS_HSRUN_CLK to register */
void Clock_Ip_SetScgHsrunDivbus_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    3368:	b084      	sub	sp, #16
    336a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->HCCR;
    336c:	4b09      	ldr	r3, [pc, #36]	; (3394 <Clock_Ip_SetScgHsrunDivbus_TrustedCall+0x2c>)
    336e:	69db      	ldr	r3, [r3, #28]
    3370:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_HCCR_DIVBUS_MASK;
    3372:	9b03      	ldr	r3, [sp, #12]
    3374:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    3378:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_HCCR_DIVBUS_SHIFT);
    337a:	9b01      	ldr	r3, [sp, #4]
    337c:	685b      	ldr	r3, [r3, #4]
    337e:	3b01      	subs	r3, #1
    3380:	011b      	lsls	r3, r3, #4
    3382:	9a03      	ldr	r2, [sp, #12]
    3384:	4313      	orrs	r3, r2
    3386:	9303      	str	r3, [sp, #12]
    IP_SCG->HCCR = RegValue;
    3388:	4a02      	ldr	r2, [pc, #8]	; (3394 <Clock_Ip_SetScgHsrunDivbus_TrustedCall+0x2c>)
    338a:	9b03      	ldr	r3, [sp, #12]
    338c:	61d3      	str	r3, [r2, #28]
}
    338e:	bf00      	nop
    3390:	b004      	add	sp, #16
    3392:	4770      	bx	lr
    3394:	40064000 	.word	0x40064000

00003398 <Clock_Ip_SetScgHsrunDivslow_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_HSRUN
/* Set divider value of SLOW_HSRUN_CLK to register */
void Clock_Ip_SetScgHsrunDivslow_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    3398:	b084      	sub	sp, #16
    339a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->HCCR;
    339c:	4b09      	ldr	r3, [pc, #36]	; (33c4 <Clock_Ip_SetScgHsrunDivslow_TrustedCall+0x2c>)
    339e:	69db      	ldr	r3, [r3, #28]
    33a0:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_HCCR_DIVSLOW_MASK;
    33a2:	9b03      	ldr	r3, [sp, #12]
    33a4:	f023 030f 	bic.w	r3, r3, #15
    33a8:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_HCCR_DIVSLOW_SHIFT);
    33aa:	9b01      	ldr	r3, [sp, #4]
    33ac:	685b      	ldr	r3, [r3, #4]
    33ae:	3b01      	subs	r3, #1
    33b0:	9a03      	ldr	r2, [sp, #12]
    33b2:	4313      	orrs	r3, r2
    33b4:	9303      	str	r3, [sp, #12]
    IP_SCG->HCCR = RegValue;
    33b6:	4a03      	ldr	r2, [pc, #12]	; (33c4 <Clock_Ip_SetScgHsrunDivslow_TrustedCall+0x2c>)
    33b8:	9b03      	ldr	r3, [sp, #12]
    33ba:	61d3      	str	r3, [r2, #28]
}
    33bc:	bf00      	nop
    33be:	b004      	add	sp, #16
    33c0:	4770      	bx	lr
    33c2:	bf00      	nop
    33c4:	40064000 	.word	0x40064000

000033c8 <Clock_Ip_SetSimClkoutDiv_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_DIV
/* Set divider value of CLKOUT0_CLK to register */
void Clock_Ip_SetSimClkoutDiv_TrustedCall(Clock_Ip_DividerConfigType const *Config)
{
    33c8:	b084      	sub	sp, #16
    33ca:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->CHIPCTL;
    33cc:	4b0a      	ldr	r3, [pc, #40]	; (33f8 <Clock_Ip_SetSimClkoutDiv_TrustedCall+0x30>)
    33ce:	685b      	ldr	r3, [r3, #4]
    33d0:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_CHIPCTL_CLKOUTDIV_MASK;
    33d2:	9b03      	ldr	r3, [sp, #12]
    33d4:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    33d8:	9303      	str	r3, [sp, #12]
    RegValue |= SIM_CHIPCTL_CLKOUTDIV(Config->Value - 1U);
    33da:	9b01      	ldr	r3, [sp, #4]
    33dc:	685b      	ldr	r3, [r3, #4]
    33de:	3b01      	subs	r3, #1
    33e0:	021b      	lsls	r3, r3, #8
    33e2:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    33e6:	9a03      	ldr	r2, [sp, #12]
    33e8:	4313      	orrs	r3, r2
    33ea:	9303      	str	r3, [sp, #12]
    IP_SIM->CHIPCTL = RegValue;
    33ec:	4a02      	ldr	r2, [pc, #8]	; (33f8 <Clock_Ip_SetSimClkoutDiv_TrustedCall+0x30>)
    33ee:	9b03      	ldr	r3, [sp, #12]
    33f0:	6053      	str	r3, [r2, #4]
}
    33f2:	bf00      	nop
    33f4:	b004      	add	sp, #16
    33f6:	4770      	bx	lr
    33f8:	40048000 	.word	0x40048000

000033fc <Clock_Ip_SetPccPcdDivFrac_TrustedCall>:
#endif

#ifdef CLOCK_IP_PCC_PCD_FRAC
void Clock_Ip_SetPccPcdDivFrac_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    33fc:	b084      	sub	sp, #16
    33fe:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_DIVIDER_INDEX]];
    3400:	4919      	ldr	r1, [pc, #100]	; (3468 <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x6c>)
    3402:	9b01      	ldr	r3, [sp, #4]
    3404:	681a      	ldr	r2, [r3, #0]
    3406:	4819      	ldr	r0, [pc, #100]	; (346c <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x70>)
    3408:	4613      	mov	r3, r2
    340a:	00db      	lsls	r3, r3, #3
    340c:	4413      	add	r3, r2
    340e:	4403      	add	r3, r0
    3410:	3305      	adds	r3, #5
    3412:	781b      	ldrb	r3, [r3, #0]
    3414:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    3418:	9303      	str	r3, [sp, #12]
    RegValue &= ~(PCC_PCCn_PCD_MASK | PCC_PCCn_FRAC_MASK);
    341a:	9b03      	ldr	r3, [sp, #12]
    341c:	f023 030f 	bic.w	r3, r3, #15
    3420:	9303      	str	r3, [sp, #12]
    RegValue |= PCC_PCCn_PCD(Config->Value - 1U);                            /* Divider */
    3422:	9b01      	ldr	r3, [sp, #4]
    3424:	685b      	ldr	r3, [r3, #4]
    3426:	3b01      	subs	r3, #1
    3428:	f003 0307 	and.w	r3, r3, #7
    342c:	9a03      	ldr	r2, [sp, #12]
    342e:	4313      	orrs	r3, r2
    3430:	9303      	str	r3, [sp, #12]
    RegValue |= PCC_PCCn_FRAC((uint32)(Config->Options[0U]) - 1U);                        /* Multiplier */
    3432:	9b01      	ldr	r3, [sp, #4]
    3434:	7a1b      	ldrb	r3, [r3, #8]
    3436:	3b01      	subs	r3, #1
    3438:	00db      	lsls	r3, r3, #3
    343a:	f003 0308 	and.w	r3, r3, #8
    343e:	9a03      	ldr	r2, [sp, #12]
    3440:	4313      	orrs	r3, r2
    3442:	9303      	str	r3, [sp, #12]
    IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_DIVIDER_INDEX]] = RegValue;
    3444:	4908      	ldr	r1, [pc, #32]	; (3468 <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x6c>)
    3446:	9b01      	ldr	r3, [sp, #4]
    3448:	681a      	ldr	r2, [r3, #0]
    344a:	4808      	ldr	r0, [pc, #32]	; (346c <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x70>)
    344c:	4613      	mov	r3, r2
    344e:	00db      	lsls	r3, r3, #3
    3450:	4413      	add	r3, r2
    3452:	4403      	add	r3, r0
    3454:	3305      	adds	r3, #5
    3456:	781b      	ldrb	r3, [r3, #0]
    3458:	461a      	mov	r2, r3
    345a:	9b03      	ldr	r3, [sp, #12]
    345c:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
}
    3460:	bf00      	nop
    3462:	b004      	add	sp, #16
    3464:	4770      	bx	lr
    3466:	bf00      	nop
    3468:	40065000 	.word	0x40065000
    346c:	00017fac 	.word	0x00017fac

00003470 <Clock_Ip_SetSimTraceDivMul_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_DIV_MUL
void Clock_Ip_SetSimTraceDivMul_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    3470:	b084      	sub	sp, #16
    3472:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    /* Disable TRACEDIVEN to configure TRACEDIV */
    IP_SIM->CLKDIV4  &= ~(SIM_CLKDIV4_TRACEDIVEN_MASK);
    3474:	4b10      	ldr	r3, [pc, #64]	; (34b8 <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    3476:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    3478:	4a0f      	ldr	r2, [pc, #60]	; (34b8 <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    347a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    347e:	6693      	str	r3, [r2, #104]	; 0x68
    RegValue = IP_SIM->CLKDIV4;
    3480:	4b0d      	ldr	r3, [pc, #52]	; (34b8 <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    3482:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    3484:	9303      	str	r3, [sp, #12]
    RegValue &= ~(SIM_CLKDIV4_TRACEDIV_MASK | SIM_CLKDIV4_TRACEFRAC_MASK);
    3486:	9b03      	ldr	r3, [sp, #12]
    3488:	f023 030f 	bic.w	r3, r3, #15
    348c:	9303      	str	r3, [sp, #12]
    RegValue |= SIM_CLKDIV4_TRACEDIV((uint32)(Config->Value) - 1U)              |    /* Divider */
    348e:	9b01      	ldr	r3, [sp, #4]
    3490:	685b      	ldr	r3, [r3, #4]
    3492:	3b01      	subs	r3, #1
    3494:	005b      	lsls	r3, r3, #1
    3496:	f003 020e 	and.w	r2, r3, #14
                     SIM_CLKDIV4_TRACEFRAC((uint32)(Config->Options[0U]) - 1U);                /* Multiplier */
    349a:	9b01      	ldr	r3, [sp, #4]
    349c:	7a1b      	ldrb	r3, [r3, #8]
    349e:	3b01      	subs	r3, #1
    34a0:	f003 0301 	and.w	r3, r3, #1
    RegValue |= SIM_CLKDIV4_TRACEDIV((uint32)(Config->Value) - 1U)              |    /* Divider */
    34a4:	4313      	orrs	r3, r2
    34a6:	9a03      	ldr	r2, [sp, #12]
    34a8:	4313      	orrs	r3, r2
    34aa:	9303      	str	r3, [sp, #12]
    IP_SIM->CLKDIV4 = RegValue;
    34ac:	4a02      	ldr	r2, [pc, #8]	; (34b8 <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    34ae:	9b03      	ldr	r3, [sp, #12]
    34b0:	6693      	str	r3, [r2, #104]	; 0x68
}
    34b2:	bf00      	nop
    34b4:	b004      	add	sp, #16
    34b6:	4770      	bx	lr
    34b8:	40048000 	.word	0x40048000

000034bc <Clock_Ip_Callback_DividerTriggerEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_Callback_DividerTriggerEmpty(Clock_Ip_DividerTriggerConfigType const* Config)
{
    34bc:	b082      	sub	sp, #8
    34be:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    34c0:	bf00      	nop
    34c2:	b002      	add	sp, #8
    34c4:	4770      	bx	lr
	...

000034c8 <Clock_Ip_ExternalOscillatorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_ExternalOscillatorEmpty(Clock_Ip_XoscConfigType const* Config)
{
    34c8:	b082      	sub	sp, #8
    34ca:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    34cc:	bf00      	nop
    34ce:	b002      	add	sp, #8
    34d0:	4770      	bx	lr

000034d2 <Clock_Ip_DisableClockIpExternalOscillatorEmpty>:
static void Clock_Ip_DisableClockIpExternalOscillatorEmpty(Clock_Ip_NameType XoscName)
{
    34d2:	b082      	sub	sp, #8
    34d4:	9001      	str	r0, [sp, #4]
    (void)XoscName;
    /* No implementation */
}
    34d6:	bf00      	nop
    34d8:	b002      	add	sp, #8
    34da:	4770      	bx	lr

000034dc <Clock_Ip_ResetSOSC>:



#ifdef CLOCK_IP_SOSC_ENABLE
static void Clock_Ip_ResetSOSC(Clock_Ip_XoscConfigType const* Config)
{
    34dc:	b500      	push	{lr}
    34de:	b083      	sub	sp, #12
    34e0:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    34e2:	9b01      	ldr	r3, [sp, #4]
    34e4:	2b00      	cmp	r3, #0
    34e6:	d002      	beq.n	34ee <Clock_Ip_ResetSOSC+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSOSC_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSOSC_TrustedCall(Config);
    34e8:	9801      	ldr	r0, [sp, #4]
    34ea:	f000 f86a 	bl	35c2 <Clock_Ip_ResetSOSC_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    34ee:	bf00      	nop
    34f0:	b003      	add	sp, #12
    34f2:	f85d fb04 	ldr.w	pc, [sp], #4

000034f6 <Clock_Ip_SetSOSC>:
static void Clock_Ip_SetSOSC(Clock_Ip_XoscConfigType const* Config)
{
    34f6:	b500      	push	{lr}
    34f8:	b083      	sub	sp, #12
    34fa:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    34fc:	9b01      	ldr	r3, [sp, #4]
    34fe:	2b00      	cmp	r3, #0
    3500:	d002      	beq.n	3508 <Clock_Ip_SetSOSC+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSOSC_TrustedCall,(Config));
      #else
        Clock_Ip_SetSOSC_TrustedCall(Config);
    3502:	9801      	ldr	r0, [sp, #4]
    3504:	f000 f884 	bl	3610 <Clock_Ip_SetSOSC_TrustedCall>
    #if (CLOCK_IP_GET_FREQUENCY_API == STD_ON)
        Clock_Ip_SetExternalOscillatorFrequency(Config->Name,Config->Freq);
    #endif
    #endif
    }
}
    3508:	bf00      	nop
    350a:	b003      	add	sp, #12
    350c:	f85d fb04 	ldr.w	pc, [sp], #4

00003510 <Clock_Ip_CompleteSOSC>:
static void Clock_Ip_CompleteSOSC(Clock_Ip_XoscConfigType const* Config)
{
    3510:	b500      	push	{lr}
    3512:	b089      	sub	sp, #36	; 0x24
    3514:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    3516:	2300      	movs	r3, #0
    3518:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 SoscStatus;

    if (NULL_PTR != Config)
    351c:	9b01      	ldr	r3, [sp, #4]
    351e:	2b00      	cmp	r3, #0
    3520:	d031      	beq.n	3586 <Clock_Ip_CompleteSOSC+0x76>
    {
        /* Configure SOSC. */
        if ((IP_SCG->SOSCCSR & SCG_SOSCCSR_SOSCEN_MASK) != 0U)
    3522:	4b1b      	ldr	r3, [pc, #108]	; (3590 <Clock_Ip_CompleteSOSC+0x80>)
    3524:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    3528:	f003 0301 	and.w	r3, r3, #1
    352c:	2b00      	cmp	r3, #0
    352e:	d02a      	beq.n	3586 <Clock_Ip_CompleteSOSC+0x76>
        {
            Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    3530:	aa03      	add	r2, sp, #12
    3532:	a904      	add	r1, sp, #16
    3534:	a805      	add	r0, sp, #20
    3536:	f24c 3350 	movw	r3, #50000	; 0xc350
    353a:	f7ff fd1d 	bl	2f78 <Clock_Ip_StartTimeout>
            /* Wait until ircosc is locked */
            do
            {
                SoscStatus = (((IP_SCG->SOSCCSR & SCG_SOSCCSR_SOSCVLD_MASK) >> SCG_SOSCCSR_SOSCVLD_SHIFT));
    353e:	4b14      	ldr	r3, [pc, #80]	; (3590 <Clock_Ip_CompleteSOSC+0x80>)
    3540:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    3544:	0e1b      	lsrs	r3, r3, #24
    3546:	f003 0301 	and.w	r3, r3, #1
    354a:	9306      	str	r3, [sp, #24]
                TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    354c:	9a03      	ldr	r2, [sp, #12]
    354e:	a904      	add	r1, sp, #16
    3550:	ab05      	add	r3, sp, #20
    3552:	4618      	mov	r0, r3
    3554:	f7ff fd2a 	bl	2fac <Clock_Ip_TimeoutExpired>
    3558:	4603      	mov	r3, r0
    355a:	f88d 301f 	strb.w	r3, [sp, #31]
            }
            while ((0U == SoscStatus) && (FALSE == TimeoutOccurred));
    355e:	9b06      	ldr	r3, [sp, #24]
    3560:	2b00      	cmp	r3, #0
    3562:	d106      	bne.n	3572 <Clock_Ip_CompleteSOSC+0x62>
    3564:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3568:	f083 0301 	eor.w	r3, r3, #1
    356c:	b2db      	uxtb	r3, r3
    356e:	2b00      	cmp	r3, #0
    3570:	d1e5      	bne.n	353e <Clock_Ip_CompleteSOSC+0x2e>

            if (FALSE != TimeoutOccurred)
    3572:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3576:	2b00      	cmp	r3, #0
    3578:	d005      	beq.n	3586 <Clock_Ip_CompleteSOSC+0x76>
            {
                /* Report timeout error */
                Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    357a:	9b01      	ldr	r3, [sp, #4]
    357c:	681b      	ldr	r3, [r3, #0]
    357e:	4619      	mov	r1, r3
    3580:	2001      	movs	r0, #1
    3582:	f7ff fce9 	bl	2f58 <Clock_Ip_ReportClockErrors>
        (void)StartTime;
        (void)ElapsedTime;
        (void)TimeoutTicks;
        (void)SoscStatus;
    }
}
    3586:	bf00      	nop
    3588:	b009      	add	sp, #36	; 0x24
    358a:	f85d fb04 	ldr.w	pc, [sp], #4
    358e:	bf00      	nop
    3590:	40064000 	.word	0x40064000

00003594 <Clock_Ip_DisableSOSC>:
static void Clock_Ip_DisableSOSC(Clock_Ip_NameType XoscName)
{
    3594:	b500      	push	{lr}
    3596:	b083      	sub	sp, #12
    3598:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSOSC_TrustedCall,(XoscName));
  #else
    Clock_Ip_DisableSOSC_TrustedCall(XoscName);
    359a:	9801      	ldr	r0, [sp, #4]
    359c:	f000 f8c0 	bl	3720 <Clock_Ip_DisableSOSC_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    35a0:	bf00      	nop
    35a2:	b003      	add	sp, #12
    35a4:	f85d fb04 	ldr.w	pc, [sp], #4

000035a8 <Clock_Ip_EnableSOSC>:
static void Clock_Ip_EnableSOSC(Clock_Ip_XoscConfigType const* Config)
{
    35a8:	b500      	push	{lr}
    35aa:	b083      	sub	sp, #12
    35ac:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    35ae:	9b01      	ldr	r3, [sp, #4]
    35b0:	2b00      	cmp	r3, #0
    35b2:	d002      	beq.n	35ba <Clock_Ip_EnableSOSC+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSOSC_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSOSC_TrustedCall(Config);
    35b4:	9801      	ldr	r0, [sp, #4]
    35b6:	f000 f8c3 	bl	3740 <Clock_Ip_EnableSOSC_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    35ba:	bf00      	nop
    35bc:	b003      	add	sp, #12
    35be:	f85d fb04 	ldr.w	pc, [sp], #4

000035c2 <Clock_Ip_ResetSOSC_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SOSC_ENABLE
void Clock_Ip_ResetSOSC_TrustedCall(Clock_Ip_XoscConfigType const* Config)
{
    35c2:	b082      	sub	sp, #8
    35c4:	9001      	str	r0, [sp, #4]
    (void)Config;

    /* Clear LK bit field */
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_LK_MASK));
    35c6:	4b11      	ldr	r3, [pc, #68]	; (360c <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    35c8:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    35cc:	4a0f      	ldr	r2, [pc, #60]	; (360c <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    35ce:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    35d2:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

    /* Disable clock monitor */
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_SOSCCM_MASK));
    35d6:	4b0d      	ldr	r3, [pc, #52]	; (360c <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    35d8:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    35dc:	4a0b      	ldr	r2, [pc, #44]	; (360c <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    35de:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    35e2:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

    /* Disable clock monitor reset*/
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_SOSCCMRE_MASK));
    35e6:	4b09      	ldr	r3, [pc, #36]	; (360c <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    35e8:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    35ec:	4a07      	ldr	r2, [pc, #28]	; (360c <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    35ee:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    35f2:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

    /* Disable clock */
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_SOSCEN_MASK));
    35f6:	4b05      	ldr	r3, [pc, #20]	; (360c <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    35f8:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    35fc:	4a03      	ldr	r2, [pc, #12]	; (360c <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    35fe:	f023 0301 	bic.w	r3, r3, #1
    3602:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
}
    3606:	bf00      	nop
    3608:	b002      	add	sp, #8
    360a:	4770      	bx	lr
    360c:	40064000 	.word	0x40064000

00003610 <Clock_Ip_SetSOSC_TrustedCall>:
void Clock_Ip_SetSOSC_TrustedCall(Clock_Ip_XoscConfigType const* Config)
{
    3610:	b082      	sub	sp, #8
    3612:	9001      	str	r0, [sp, #4]
    /* Configure SOSC. */
    if (1U == Config->Enable)
    3614:	9b01      	ldr	r3, [sp, #4]
    3616:	891b      	ldrh	r3, [r3, #8]
    3618:	2b01      	cmp	r3, #1
    361a:	d174      	bne.n	3706 <Clock_Ip_SetSOSC_TrustedCall+0xf6>
#ifdef CLOCK_IP_GET_FREQUENCY_API
#if (CLOCK_IP_GET_FREQUENCY_API == STD_ON)
        Clock_Ip_SetExternalOscillatorFrequency(Config->Name,Config->Freq);
#endif
#endif
        switch(Config->Gain)
    361c:	9b01      	ldr	r3, [sp, #4]
    361e:	7bdb      	ldrb	r3, [r3, #15]
    3620:	2b00      	cmp	r3, #0
    3622:	d002      	beq.n	362a <Clock_Ip_SetSOSC_TrustedCall+0x1a>
    3624:	2b01      	cmp	r3, #1
    3626:	d009      	beq.n	363c <Clock_Ip_SetSOSC_TrustedCall+0x2c>
            default:
            {
                /* Invalid configuration element */
                CLOCK_IP_DEV_ASSERT(FALSE);
            }
            break;
    3628:	e011      	b.n	364e <Clock_Ip_SetSOSC_TrustedCall+0x3e>
                IP_SCG->SOSCCFG &= ~SCG_SOSCCFG_HGO_MASK;
    362a:	4b39      	ldr	r3, [pc, #228]	; (3710 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    362c:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    3630:	4a37      	ldr	r2, [pc, #220]	; (3710 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    3632:	f023 0308 	bic.w	r3, r3, #8
    3636:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
            break;
    363a:	e008      	b.n	364e <Clock_Ip_SetSOSC_TrustedCall+0x3e>
                IP_SCG->SOSCCFG |= SCG_SOSCCFG_HGO_MASK;
    363c:	4b34      	ldr	r3, [pc, #208]	; (3710 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    363e:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    3642:	4a33      	ldr	r2, [pc, #204]	; (3710 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    3644:	f043 0308 	orr.w	r3, r3, #8
    3648:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
            break;
    364c:	bf00      	nop
        }


        IP_SCG->SOSCCFG &= ~SCG_SOSCCFG_RANGE_MASK;
    364e:	4b30      	ldr	r3, [pc, #192]	; (3710 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    3650:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    3654:	4a2e      	ldr	r2, [pc, #184]	; (3710 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    3656:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    365a:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108

        if ((Config->Freq >= 4000000U) && (Config->Freq < 8000000U))
    365e:	9b01      	ldr	r3, [sp, #4]
    3660:	685b      	ldr	r3, [r3, #4]
    3662:	4a2c      	ldr	r2, [pc, #176]	; (3714 <Clock_Ip_SetSOSC_TrustedCall+0x104>)
    3664:	4293      	cmp	r3, r2
    3666:	d90d      	bls.n	3684 <Clock_Ip_SetSOSC_TrustedCall+0x74>
    3668:	9b01      	ldr	r3, [sp, #4]
    366a:	685b      	ldr	r3, [r3, #4]
    366c:	4a2a      	ldr	r2, [pc, #168]	; (3718 <Clock_Ip_SetSOSC_TrustedCall+0x108>)
    366e:	4293      	cmp	r3, r2
    3670:	d208      	bcs.n	3684 <Clock_Ip_SetSOSC_TrustedCall+0x74>
        {
            IP_SCG->SOSCCFG |= SCG_SOSCCFG_RANGE(2U);
    3672:	4b27      	ldr	r3, [pc, #156]	; (3710 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    3674:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    3678:	4a25      	ldr	r2, [pc, #148]	; (3710 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    367a:	f043 0320 	orr.w	r3, r3, #32
    367e:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
    3682:	e007      	b.n	3694 <Clock_Ip_SetSOSC_TrustedCall+0x84>
        }
        else
        {
            IP_SCG->SOSCCFG |= SCG_SOSCCFG_RANGE(3U);
    3684:	4b22      	ldr	r3, [pc, #136]	; (3710 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    3686:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    368a:	4a21      	ldr	r2, [pc, #132]	; (3710 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    368c:	f043 0330 	orr.w	r3, r3, #48	; 0x30
    3690:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
        }

        if (0U == Config->BypassOption)
    3694:	9b01      	ldr	r3, [sp, #4]
    3696:	7b1b      	ldrb	r3, [r3, #12]
    3698:	2b00      	cmp	r3, #0
    369a:	d108      	bne.n	36ae <Clock_Ip_SetSOSC_TrustedCall+0x9e>
        {
            IP_SCG->SOSCCFG |= SCG_SOSCCFG_EREFS_MASK;
    369c:	4b1c      	ldr	r3, [pc, #112]	; (3710 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    369e:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    36a2:	4a1b      	ldr	r2, [pc, #108]	; (3710 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    36a4:	f043 0304 	orr.w	r3, r3, #4
    36a8:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
    36ac:	e007      	b.n	36be <Clock_Ip_SetSOSC_TrustedCall+0xae>
        }
        else
        {
            IP_SCG->SOSCCFG &= ~SCG_SOSCCFG_EREFS_MASK;
    36ae:	4b18      	ldr	r3, [pc, #96]	; (3710 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    36b0:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    36b4:	4a16      	ldr	r2, [pc, #88]	; (3710 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    36b6:	f023 0304 	bic.w	r3, r3, #4
    36ba:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
        }


        /* Enable clock, configure monitor, lock register. */
        switch (Config->Monitor)
    36be:	9b01      	ldr	r3, [sp, #4]
    36c0:	7c1b      	ldrb	r3, [r3, #16]
    36c2:	2b02      	cmp	r3, #2
    36c4:	d011      	beq.n	36ea <Clock_Ip_SetSOSC_TrustedCall+0xda>
    36c6:	2b02      	cmp	r3, #2
    36c8:	dc14      	bgt.n	36f4 <Clock_Ip_SetSOSC_TrustedCall+0xe4>
    36ca:	2b00      	cmp	r3, #0
    36cc:	d002      	beq.n	36d4 <Clock_Ip_SetSOSC_TrustedCall+0xc4>
    36ce:	2b01      	cmp	r3, #1
    36d0:	d005      	beq.n	36de <Clock_Ip_SetSOSC_TrustedCall+0xce>
    36d2:	e00f      	b.n	36f4 <Clock_Ip_SetSOSC_TrustedCall+0xe4>
        {
#ifdef CLOCK_IP_HAS_MONITOR_DISABLE
            case CLOCK_IP_HAS_MONITOR_DISABLE:
            {
                IP_SCG->SOSCCSR = SCG_SOSCCSR_SOSCEN(1UL) |
    36d4:	4b0e      	ldr	r3, [pc, #56]	; (3710 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    36d6:	2201      	movs	r2, #1
    36d8:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
                               SCG_SOSCCSR_SOSCCM(0UL) |
                               SCG_SOSCCSR_SOSCCMRE(0UL);
            }
            break;
    36dc:	e014      	b.n	3708 <Clock_Ip_SetSOSC_TrustedCall+0xf8>
#endif
#ifdef CLOCK_IP_HAS_MONITOR_INT
            case CLOCK_IP_HAS_MONITOR_INT:
            {
                IP_SCG->SOSCCSR = SCG_SOSCCSR_SOSCEN(1UL) |
    36de:	4b0c      	ldr	r3, [pc, #48]	; (3710 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    36e0:	f04f 1201 	mov.w	r2, #65537	; 0x10001
    36e4:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
                               SCG_SOSCCSR_SOSCCM(1UL) |
                               SCG_SOSCCSR_SOSCCMRE(0UL);
            }
            break;
    36e8:	e00e      	b.n	3708 <Clock_Ip_SetSOSC_TrustedCall+0xf8>
#endif
#ifdef CLOCK_IP_HAS_MONITOR_RESET
            case CLOCK_IP_HAS_MONITOR_RESET:
            {
                IP_SCG->SOSCCSR = SCG_SOSCCSR_SOSCEN(1UL) |
    36ea:	4b09      	ldr	r3, [pc, #36]	; (3710 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    36ec:	4a0b      	ldr	r2, [pc, #44]	; (371c <Clock_Ip_SetSOSC_TrustedCall+0x10c>)
    36ee:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
                               SCG_SOSCCSR_SOSCCM(1UL) |
                               SCG_SOSCCSR_SOSCCMRE(1UL);
            }
            break;
    36f2:	e009      	b.n	3708 <Clock_Ip_SetSOSC_TrustedCall+0xf8>
#endif
            default:
                /* Enable SOSC. */
                IP_SCG->SOSCCSR |= SCG_SOSCCSR_SOSCEN_MASK;
    36f4:	4b06      	ldr	r3, [pc, #24]	; (3710 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    36f6:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    36fa:	4a05      	ldr	r2, [pc, #20]	; (3710 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    36fc:	f043 0301 	orr.w	r3, r3, #1
    3700:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

                /* Invalid monitor mode */
                CLOCK_IP_DEV_ASSERT(FALSE);
                break;
    3704:	e000      	b.n	3708 <Clock_Ip_SetSOSC_TrustedCall+0xf8>
        }
    }
    3706:	bf00      	nop
}
    3708:	bf00      	nop
    370a:	b002      	add	sp, #8
    370c:	4770      	bx	lr
    370e:	bf00      	nop
    3710:	40064000 	.word	0x40064000
    3714:	003d08ff 	.word	0x003d08ff
    3718:	007a1200 	.word	0x007a1200
    371c:	00030001 	.word	0x00030001

00003720 <Clock_Ip_DisableSOSC_TrustedCall>:

void Clock_Ip_DisableSOSC_TrustedCall(Clock_Ip_NameType XoscName)
{
    3720:	b082      	sub	sp, #8
    3722:	9001      	str	r0, [sp, #4]
    (void)XoscName;

    /* Disable SOSC. */
    IP_SCG->SOSCCSR &= ~SCG_SOSCCSR_SOSCEN_MASK;
    3724:	4b05      	ldr	r3, [pc, #20]	; (373c <Clock_Ip_DisableSOSC_TrustedCall+0x1c>)
    3726:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    372a:	4a04      	ldr	r2, [pc, #16]	; (373c <Clock_Ip_DisableSOSC_TrustedCall+0x1c>)
    372c:	f023 0301 	bic.w	r3, r3, #1
    3730:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
}
    3734:	bf00      	nop
    3736:	b002      	add	sp, #8
    3738:	4770      	bx	lr
    373a:	bf00      	nop
    373c:	40064000 	.word	0x40064000

00003740 <Clock_Ip_EnableSOSC_TrustedCall>:

void Clock_Ip_EnableSOSC_TrustedCall(Clock_Ip_XoscConfigType const* Config)
{
    3740:	b082      	sub	sp, #8
    3742:	9001      	str	r0, [sp, #4]
    if (1U == Config->Enable)
    3744:	9b01      	ldr	r3, [sp, #4]
    3746:	891b      	ldrh	r3, [r3, #8]
    3748:	2b01      	cmp	r3, #1
    374a:	d107      	bne.n	375c <Clock_Ip_EnableSOSC_TrustedCall+0x1c>
    {
        /* Enable SOSC. */
        IP_SCG->SOSCCSR |= SCG_SOSCCSR_SOSCEN_MASK;
    374c:	4b05      	ldr	r3, [pc, #20]	; (3764 <Clock_Ip_EnableSOSC_TrustedCall+0x24>)
    374e:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    3752:	4a04      	ldr	r2, [pc, #16]	; (3764 <Clock_Ip_EnableSOSC_TrustedCall+0x24>)
    3754:	f043 0301 	orr.w	r3, r3, #1
    3758:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
    }
}
    375c:	bf00      	nop
    375e:	b002      	add	sp, #8
    3760:	4770      	bx	lr
    3762:	bf00      	nop
    3764:	40064000 	.word	0x40064000

00003768 <Clock_Ip_CallbackFracDivEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_CallbackFracDivEmpty(Clock_Ip_FracDivConfigType const* Config)
{
    3768:	b082      	sub	sp, #8
    376a:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    376c:	bf00      	nop
    376e:	b002      	add	sp, #8
    3770:	4770      	bx	lr

00003772 <Clock_Ip_CallbackFracDivEmptyComplete>:

static Clock_Ip_DfsStatusType Clock_Ip_CallbackFracDivEmptyComplete(Clock_Ip_NameType DfsName)
{
    3772:	b082      	sub	sp, #8
    3774:	9001      	str	r0, [sp, #4]
    (void)DfsName;
    /* No implementation */
    return STATUS_DFS_NOT_ENABLED;
    3776:	2300      	movs	r3, #0
}
    3778:	4618      	mov	r0, r3
    377a:	b002      	add	sp, #8
    377c:	4770      	bx	lr

0000377e <Clock_Ip_SetExternalSignalFrequency>:
#define MCU_START_SEC_CODE
#include "Mcu_MemMap.h"

/* Set frequency value for External Signal */
void Clock_Ip_SetExternalSignalFrequency(Clock_Ip_NameType SignalName, uint32 Frequency)
{
    377e:	b082      	sub	sp, #8
    3780:	9001      	str	r0, [sp, #4]
    3782:	9100      	str	r1, [sp, #0]
    }
#else
    (void)SignalName;
    (void)Frequency;
#endif
}
    3784:	bf00      	nop
    3786:	b002      	add	sp, #8
    3788:	4770      	bx	lr
	...

0000378c <Clock_Ip_ClockSetGateEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_ClockSetGateEmpty(Clock_Ip_GateConfigType const* Config)
{
    378c:	b082      	sub	sp, #8
    378e:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    3790:	bf00      	nop
    3792:	b002      	add	sp, #8
    3794:	4770      	bx	lr

00003796 <Clock_Ip_ClockUpdateGateEmpty>:
static void Clock_Ip_ClockUpdateGateEmpty(Clock_Ip_NameType ClockName, boolean Gate)
{
    3796:	b082      	sub	sp, #8
    3798:	9001      	str	r0, [sp, #4]
    379a:	460b      	mov	r3, r1
    379c:	f88d 3003 	strb.w	r3, [sp, #3]
    (void)ClockName;
    (void)Gate;
    /* No implementation */
}
    37a0:	bf00      	nop
    37a2:	b002      	add	sp, #8
    37a4:	4770      	bx	lr

000037a6 <Clock_Ip_ClockSetSimLPO1KEnable>:

#ifdef CLOCK_IP_SIM_LPO1K_ENABLE
static void Clock_Ip_ClockSetSimLPO1KEnable(Clock_Ip_GateConfigType const* Config)
{
    37a6:	b500      	push	{lr}
    37a8:	b083      	sub	sp, #12
    37aa:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    37ac:	9b01      	ldr	r3, [sp, #4]
    37ae:	2b00      	cmp	r3, #0
    37b0:	d002      	beq.n	37b8 <Clock_Ip_ClockSetSimLPO1KEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall(Config);
    37b2:	9801      	ldr	r0, [sp, #4]
    37b4:	f000 f8e7 	bl	3986 <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    37b8:	bf00      	nop
    37ba:	b003      	add	sp, #12
    37bc:	f85d fb04 	ldr.w	pc, [sp], #4

000037c0 <Clock_Ip_ClockUpdateSimLPO1KEnable>:

static void Clock_Ip_ClockUpdateSimLPO1KEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    37c0:	b500      	push	{lr}
    37c2:	b085      	sub	sp, #20
    37c4:	9001      	str	r0, [sp, #4]
    37c6:	460b      	mov	r3, r1
    37c8:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    37cc:	9b01      	ldr	r3, [sp, #4]
    37ce:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    37d0:	f89d 3003 	ldrb.w	r3, [sp, #3]
    37d4:	2b00      	cmp	r3, #0
    37d6:	d003      	beq.n	37e0 <Clock_Ip_ClockUpdateSimLPO1KEnable+0x20>
    {
        Config.Enable = 0U;
    37d8:	2300      	movs	r3, #0
    37da:	f8ad 300c 	strh.w	r3, [sp, #12]
    37de:	e002      	b.n	37e6 <Clock_Ip_ClockUpdateSimLPO1KEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    37e0:	2301      	movs	r3, #1
    37e2:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimLPO1KEnable(&Config);
    37e6:	ab02      	add	r3, sp, #8
    37e8:	4618      	mov	r0, r3
    37ea:	f7ff ffdc 	bl	37a6 <Clock_Ip_ClockSetSimLPO1KEnable>
}
    37ee:	bf00      	nop
    37f0:	b005      	add	sp, #20
    37f2:	f85d fb04 	ldr.w	pc, [sp], #4

000037f6 <Clock_Ip_ClockSetSimLPO32KEnable>:
#endif

#ifdef CLOCK_IP_SIM_LPO32K_ENABLE
static void Clock_Ip_ClockSetSimLPO32KEnable(Clock_Ip_GateConfigType const* Config)
{
    37f6:	b500      	push	{lr}
    37f8:	b083      	sub	sp, #12
    37fa:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    37fc:	9b01      	ldr	r3, [sp, #4]
    37fe:	2b00      	cmp	r3, #0
    3800:	d002      	beq.n	3808 <Clock_Ip_ClockSetSimLPO32KEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall(Config);
    3802:	9801      	ldr	r0, [sp, #4]
    3804:	f000 f8d6 	bl	39b4 <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3808:	bf00      	nop
    380a:	b003      	add	sp, #12
    380c:	f85d fb04 	ldr.w	pc, [sp], #4

00003810 <Clock_Ip_ClockUpdateSimLPO32KEnable>:
static void Clock_Ip_ClockUpdateSimLPO32KEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    3810:	b500      	push	{lr}
    3812:	b085      	sub	sp, #20
    3814:	9001      	str	r0, [sp, #4]
    3816:	460b      	mov	r3, r1
    3818:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    381c:	9b01      	ldr	r3, [sp, #4]
    381e:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    3820:	f89d 3003 	ldrb.w	r3, [sp, #3]
    3824:	2b00      	cmp	r3, #0
    3826:	d003      	beq.n	3830 <Clock_Ip_ClockUpdateSimLPO32KEnable+0x20>
    {
        Config.Enable = 0U;
    3828:	2300      	movs	r3, #0
    382a:	f8ad 300c 	strh.w	r3, [sp, #12]
    382e:	e002      	b.n	3836 <Clock_Ip_ClockUpdateSimLPO32KEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    3830:	2301      	movs	r3, #1
    3832:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimLPO32KEnable(&Config);
    3836:	ab02      	add	r3, sp, #8
    3838:	4618      	mov	r0, r3
    383a:	f7ff ffdc 	bl	37f6 <Clock_Ip_ClockSetSimLPO32KEnable>
}
    383e:	bf00      	nop
    3840:	b005      	add	sp, #20
    3842:	f85d fb04 	ldr.w	pc, [sp], #4

00003846 <Clock_Ip_ClockSetSimClkoutEnable>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_ENABLE
static void Clock_Ip_ClockSetSimClkoutEnable(Clock_Ip_GateConfigType const* Config)
{
    3846:	b500      	push	{lr}
    3848:	b083      	sub	sp, #12
    384a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    384c:	9b01      	ldr	r3, [sp, #4]
    384e:	2b00      	cmp	r3, #0
    3850:	d002      	beq.n	3858 <Clock_Ip_ClockSetSimClkoutEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimClkoutEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimClkoutEnable_TrustedCall(Config);
    3852:	9801      	ldr	r0, [sp, #4]
    3854:	f000 f8c6 	bl	39e4 <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3858:	bf00      	nop
    385a:	b003      	add	sp, #12
    385c:	f85d fb04 	ldr.w	pc, [sp], #4

00003860 <Clock_Ip_ClockUpdateSimClkoutEnable>:
static void Clock_Ip_ClockUpdateSimClkoutEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    3860:	b500      	push	{lr}
    3862:	b085      	sub	sp, #20
    3864:	9001      	str	r0, [sp, #4]
    3866:	460b      	mov	r3, r1
    3868:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    386c:	9b01      	ldr	r3, [sp, #4]
    386e:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    3870:	f89d 3003 	ldrb.w	r3, [sp, #3]
    3874:	2b00      	cmp	r3, #0
    3876:	d003      	beq.n	3880 <Clock_Ip_ClockUpdateSimClkoutEnable+0x20>
    {
        Config.Enable = 0U;
    3878:	2300      	movs	r3, #0
    387a:	f8ad 300c 	strh.w	r3, [sp, #12]
    387e:	e002      	b.n	3886 <Clock_Ip_ClockUpdateSimClkoutEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    3880:	2301      	movs	r3, #1
    3882:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimClkoutEnable(&Config);
    3886:	ab02      	add	r3, sp, #8
    3888:	4618      	mov	r0, r3
    388a:	f7ff ffdc 	bl	3846 <Clock_Ip_ClockSetSimClkoutEnable>
}
    388e:	bf00      	nop
    3890:	b005      	add	sp, #20
    3892:	f85d fb04 	ldr.w	pc, [sp], #4

00003896 <Clock_Ip_ClockSetPccCgcEnable>:
#endif

#ifdef CLOCK_IP_PCC_CGC_ENABLE
static void Clock_Ip_ClockSetPccCgcEnable(Clock_Ip_GateConfigType const* Config)
{
    3896:	b500      	push	{lr}
    3898:	b083      	sub	sp, #12
    389a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    389c:	9b01      	ldr	r3, [sp, #4]
    389e:	2b00      	cmp	r3, #0
    38a0:	d002      	beq.n	38a8 <Clock_Ip_ClockSetPccCgcEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetPccCgcEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetPccCgcEnable_TrustedCall(Config);
    38a2:	9801      	ldr	r0, [sp, #4]
    38a4:	f000 f8b6 	bl	3a14 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    38a8:	bf00      	nop
    38aa:	b003      	add	sp, #12
    38ac:	f85d fb04 	ldr.w	pc, [sp], #4

000038b0 <Clock_Ip_ClockUpdatePccCgcEnable>:
static void Clock_Ip_ClockUpdatePccCgcEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    38b0:	b500      	push	{lr}
    38b2:	b085      	sub	sp, #20
    38b4:	9001      	str	r0, [sp, #4]
    38b6:	460b      	mov	r3, r1
    38b8:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    38bc:	9b01      	ldr	r3, [sp, #4]
    38be:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    38c0:	f89d 3003 	ldrb.w	r3, [sp, #3]
    38c4:	2b00      	cmp	r3, #0
    38c6:	d003      	beq.n	38d0 <Clock_Ip_ClockUpdatePccCgcEnable+0x20>
    {
        Config.Enable = 0U;
    38c8:	2300      	movs	r3, #0
    38ca:	f8ad 300c 	strh.w	r3, [sp, #12]
    38ce:	e002      	b.n	38d6 <Clock_Ip_ClockUpdatePccCgcEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    38d0:	2301      	movs	r3, #1
    38d2:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetPccCgcEnable(&Config);
    38d6:	ab02      	add	r3, sp, #8
    38d8:	4618      	mov	r0, r3
    38da:	f7ff ffdc 	bl	3896 <Clock_Ip_ClockSetPccCgcEnable>
}
    38de:	bf00      	nop
    38e0:	b005      	add	sp, #20
    38e2:	f85d fb04 	ldr.w	pc, [sp], #4

000038e6 <Clock_Ip_ClockSetSimGate>:

#ifdef CLOCK_IP_SIM_PLATCGC_CGC
#define SIM_PLATCGC_CGC_SHIFT(x)   (x)
#define SIM_PLATCGC_CGC_MASK(x)  ((uint32)1U << (x))
static void Clock_Ip_ClockSetSimGate(Clock_Ip_GateConfigType const* Config)
{
    38e6:	b500      	push	{lr}
    38e8:	b083      	sub	sp, #12
    38ea:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    38ec:	9b01      	ldr	r3, [sp, #4]
    38ee:	2b00      	cmp	r3, #0
    38f0:	d002      	beq.n	38f8 <Clock_Ip_ClockSetSimGate+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimGate_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimGate_TrustedCall(Config);
    38f2:	9801      	ldr	r0, [sp, #4]
    38f4:	f000 f8bc 	bl	3a70 <Clock_Ip_ClockSetSimGate_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    38f8:	bf00      	nop
    38fa:	b003      	add	sp, #12
    38fc:	f85d fb04 	ldr.w	pc, [sp], #4

00003900 <Clock_Ip_ClockUpdateSimGate>:
static void Clock_Ip_ClockUpdateSimGate(Clock_Ip_NameType ClockName, boolean Gate)
{
    3900:	b500      	push	{lr}
    3902:	b085      	sub	sp, #20
    3904:	9001      	str	r0, [sp, #4]
    3906:	460b      	mov	r3, r1
    3908:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    390c:	9b01      	ldr	r3, [sp, #4]
    390e:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    3910:	f89d 3003 	ldrb.w	r3, [sp, #3]
    3914:	2b00      	cmp	r3, #0
    3916:	d003      	beq.n	3920 <Clock_Ip_ClockUpdateSimGate+0x20>
    {
        Config.Enable = 0U;
    3918:	2300      	movs	r3, #0
    391a:	f8ad 300c 	strh.w	r3, [sp, #12]
    391e:	e002      	b.n	3926 <Clock_Ip_ClockUpdateSimGate+0x26>
    }
    else
    {
        Config.Enable = 1U;
    3920:	2301      	movs	r3, #1
    3922:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimGate(&Config);
    3926:	ab02      	add	r3, sp, #8
    3928:	4618      	mov	r0, r3
    392a:	f7ff ffdc 	bl	38e6 <Clock_Ip_ClockSetSimGate>
}
    392e:	bf00      	nop
    3930:	b005      	add	sp, #20
    3932:	f85d fb04 	ldr.w	pc, [sp], #4

00003936 <Clock_Ip_ClockSetSimTraceEnable>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_ENABLE
static void Clock_Ip_ClockSetSimTraceEnable(Clock_Ip_GateConfigType const* Config)
{
    3936:	b500      	push	{lr}
    3938:	b083      	sub	sp, #12
    393a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    393c:	9b01      	ldr	r3, [sp, #4]
    393e:	2b00      	cmp	r3, #0
    3940:	d002      	beq.n	3948 <Clock_Ip_ClockSetSimTraceEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimTraceEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimTraceEnable_TrustedCall(Config);
    3942:	9801      	ldr	r0, [sp, #4]
    3944:	f000 f8c0 	bl	3ac8 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3948:	bf00      	nop
    394a:	b003      	add	sp, #12
    394c:	f85d fb04 	ldr.w	pc, [sp], #4

00003950 <Clock_Ip_ClockUpdateSimTraceEnable>:

static void Clock_Ip_ClockUpdateSimTraceEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    3950:	b500      	push	{lr}
    3952:	b085      	sub	sp, #20
    3954:	9001      	str	r0, [sp, #4]
    3956:	460b      	mov	r3, r1
    3958:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    395c:	9b01      	ldr	r3, [sp, #4]
    395e:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    3960:	f89d 3003 	ldrb.w	r3, [sp, #3]
    3964:	2b00      	cmp	r3, #0
    3966:	d003      	beq.n	3970 <Clock_Ip_ClockUpdateSimTraceEnable+0x20>
    {
        Config.Enable = 0U;
    3968:	2300      	movs	r3, #0
    396a:	f8ad 300c 	strh.w	r3, [sp, #12]
    396e:	e002      	b.n	3976 <Clock_Ip_ClockUpdateSimTraceEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    3970:	2301      	movs	r3, #1
    3972:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimTraceEnable(&Config);
    3976:	ab02      	add	r3, sp, #8
    3978:	4618      	mov	r0, r3
    397a:	f7ff ffdc 	bl	3936 <Clock_Ip_ClockSetSimTraceEnable>
}
    397e:	bf00      	nop
    3980:	b005      	add	sp, #20
    3982:	f85d fb04 	ldr.w	pc, [sp], #4

00003986 <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall>:
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SIM_LPO1K_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    3986:	b084      	sub	sp, #16
    3988:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->LPOCLKS;
    398a:	4b09      	ldr	r3, [pc, #36]	; (39b0 <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall+0x2a>)
    398c:	691b      	ldr	r3, [r3, #16]
    398e:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_LPOCLKS_LPO1KCLKEN_MASK;
    3990:	9b03      	ldr	r3, [sp, #12]
    3992:	f023 0301 	bic.w	r3, r3, #1
    3996:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << SIM_LPOCLKS_LPO1KCLKEN_SHIFT);
    3998:	9b01      	ldr	r3, [sp, #4]
    399a:	889b      	ldrh	r3, [r3, #4]
    399c:	461a      	mov	r2, r3
    399e:	9b03      	ldr	r3, [sp, #12]
    39a0:	4313      	orrs	r3, r2
    39a2:	9303      	str	r3, [sp, #12]
    IP_SIM->LPOCLKS = RegValue;
    39a4:	4a02      	ldr	r2, [pc, #8]	; (39b0 <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall+0x2a>)
    39a6:	9b03      	ldr	r3, [sp, #12]
    39a8:	6113      	str	r3, [r2, #16]
}
    39aa:	bf00      	nop
    39ac:	b004      	add	sp, #16
    39ae:	4770      	bx	lr
    39b0:	40048000 	.word	0x40048000

000039b4 <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_LPO32K_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    39b4:	b084      	sub	sp, #16
    39b6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->LPOCLKS;
    39b8:	4b09      	ldr	r3, [pc, #36]	; (39e0 <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall+0x2c>)
    39ba:	691b      	ldr	r3, [r3, #16]
    39bc:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_LPOCLKS_LPO32KCLKEN_MASK;
    39be:	9b03      	ldr	r3, [sp, #12]
    39c0:	f023 0302 	bic.w	r3, r3, #2
    39c4:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << SIM_LPOCLKS_LPO32KCLKEN_SHIFT);
    39c6:	9b01      	ldr	r3, [sp, #4]
    39c8:	889b      	ldrh	r3, [r3, #4]
    39ca:	005b      	lsls	r3, r3, #1
    39cc:	9a03      	ldr	r2, [sp, #12]
    39ce:	4313      	orrs	r3, r2
    39d0:	9303      	str	r3, [sp, #12]
    IP_SIM->LPOCLKS = RegValue;
    39d2:	4a03      	ldr	r2, [pc, #12]	; (39e0 <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall+0x2c>)
    39d4:	9b03      	ldr	r3, [sp, #12]
    39d6:	6113      	str	r3, [r2, #16]
}
    39d8:	bf00      	nop
    39da:	b004      	add	sp, #16
    39dc:	4770      	bx	lr
    39de:	bf00      	nop
    39e0:	40048000 	.word	0x40048000

000039e4 <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimClkoutEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    39e4:	b084      	sub	sp, #16
    39e6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->CHIPCTL;
    39e8:	4b09      	ldr	r3, [pc, #36]	; (3a10 <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall+0x2c>)
    39ea:	685b      	ldr	r3, [r3, #4]
    39ec:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_CHIPCTL_CLKOUTEN_MASK;
    39ee:	9b03      	ldr	r3, [sp, #12]
    39f0:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    39f4:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << SIM_CHIPCTL_CLKOUTEN_SHIFT);
    39f6:	9b01      	ldr	r3, [sp, #4]
    39f8:	889b      	ldrh	r3, [r3, #4]
    39fa:	02db      	lsls	r3, r3, #11
    39fc:	9a03      	ldr	r2, [sp, #12]
    39fe:	4313      	orrs	r3, r2
    3a00:	9303      	str	r3, [sp, #12]
    IP_SIM->CHIPCTL = RegValue;
    3a02:	4a03      	ldr	r2, [pc, #12]	; (3a10 <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall+0x2c>)
    3a04:	9b03      	ldr	r3, [sp, #12]
    3a06:	6053      	str	r3, [r2, #4]
}
    3a08:	bf00      	nop
    3a0a:	b004      	add	sp, #16
    3a0c:	4770      	bx	lr
    3a0e:	bf00      	nop
    3a10:	40048000 	.word	0x40048000

00003a14 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_PCC_CGC_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetPccCgcEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    3a14:	b084      	sub	sp, #16
    3a16:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_GATE_INDEX]];
    3a18:	4913      	ldr	r1, [pc, #76]	; (3a68 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x54>)
    3a1a:	9b01      	ldr	r3, [sp, #4]
    3a1c:	681a      	ldr	r2, [r3, #0]
    3a1e:	4813      	ldr	r0, [pc, #76]	; (3a6c <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x58>)
    3a20:	4613      	mov	r3, r2
    3a22:	00db      	lsls	r3, r3, #3
    3a24:	4413      	add	r3, r2
    3a26:	4403      	add	r3, r0
    3a28:	3306      	adds	r3, #6
    3a2a:	781b      	ldrb	r3, [r3, #0]
    3a2c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    3a30:	9303      	str	r3, [sp, #12]
    RegValue &= ~PCC_PCCn_CGC_MASK;
    3a32:	9b03      	ldr	r3, [sp, #12]
    3a34:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
    3a38:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << PCC_PCCn_CGC_SHIFT);
    3a3a:	9b01      	ldr	r3, [sp, #4]
    3a3c:	889b      	ldrh	r3, [r3, #4]
    3a3e:	079b      	lsls	r3, r3, #30
    3a40:	9a03      	ldr	r2, [sp, #12]
    3a42:	4313      	orrs	r3, r2
    3a44:	9303      	str	r3, [sp, #12]
    IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_GATE_INDEX]] = RegValue;
    3a46:	4908      	ldr	r1, [pc, #32]	; (3a68 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x54>)
    3a48:	9b01      	ldr	r3, [sp, #4]
    3a4a:	681a      	ldr	r2, [r3, #0]
    3a4c:	4807      	ldr	r0, [pc, #28]	; (3a6c <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x58>)
    3a4e:	4613      	mov	r3, r2
    3a50:	00db      	lsls	r3, r3, #3
    3a52:	4413      	add	r3, r2
    3a54:	4403      	add	r3, r0
    3a56:	3306      	adds	r3, #6
    3a58:	781b      	ldrb	r3, [r3, #0]
    3a5a:	461a      	mov	r2, r3
    3a5c:	9b03      	ldr	r3, [sp, #12]
    3a5e:	f841 3022 	str.w	r3, [r1, r2, lsl #2]

}
    3a62:	bf00      	nop
    3a64:	b004      	add	sp, #16
    3a66:	4770      	bx	lr
    3a68:	40065000 	.word	0x40065000
    3a6c:	00017fac 	.word	0x00017fac

00003a70 <Clock_Ip_ClockSetSimGate_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_PLATCGC_CGC
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimGate_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    3a70:	b086      	sub	sp, #24
    3a72:	9001      	str	r0, [sp, #4]
    uint32 Enable = Config->Enable;
    3a74:	9b01      	ldr	r3, [sp, #4]
    3a76:	889b      	ldrh	r3, [r3, #4]
    3a78:	9305      	str	r3, [sp, #20]
    uint32 GateIndex = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_GATE_INDEX];
    3a7a:	9b01      	ldr	r3, [sp, #4]
    3a7c:	681a      	ldr	r2, [r3, #0]
    3a7e:	4910      	ldr	r1, [pc, #64]	; (3ac0 <Clock_Ip_ClockSetSimGate_TrustedCall+0x50>)
    3a80:	4613      	mov	r3, r2
    3a82:	00db      	lsls	r3, r3, #3
    3a84:	4413      	add	r3, r2
    3a86:	440b      	add	r3, r1
    3a88:	3306      	adds	r3, #6
    3a8a:	781b      	ldrb	r3, [r3, #0]
    3a8c:	9304      	str	r3, [sp, #16]

    uint32 RegValue = (uint32 )IP_SIM->PLATCGC;
    3a8e:	4b0d      	ldr	r3, [pc, #52]	; (3ac4 <Clock_Ip_ClockSetSimGate_TrustedCall+0x54>)
    3a90:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3a92:	9303      	str	r3, [sp, #12]
    RegValue &= (~((uint32 )SIM_PLATCGC_CGC_MASK(GateIndex)));
    3a94:	2201      	movs	r2, #1
    3a96:	9b04      	ldr	r3, [sp, #16]
    3a98:	fa02 f303 	lsl.w	r3, r2, r3
    3a9c:	43db      	mvns	r3, r3
    3a9e:	9a03      	ldr	r2, [sp, #12]
    3aa0:	4013      	ands	r3, r2
    3aa2:	9303      	str	r3, [sp, #12]
    RegValue |= Enable << SIM_PLATCGC_CGC_SHIFT(GateIndex);
    3aa4:	9a05      	ldr	r2, [sp, #20]
    3aa6:	9b04      	ldr	r3, [sp, #16]
    3aa8:	fa02 f303 	lsl.w	r3, r2, r3
    3aac:	9a03      	ldr	r2, [sp, #12]
    3aae:	4313      	orrs	r3, r2
    3ab0:	9303      	str	r3, [sp, #12]
    IP_SIM->PLATCGC = (uint32 )RegValue;
    3ab2:	4a04      	ldr	r2, [pc, #16]	; (3ac4 <Clock_Ip_ClockSetSimGate_TrustedCall+0x54>)
    3ab4:	9b03      	ldr	r3, [sp, #12]
    3ab6:	6413      	str	r3, [r2, #64]	; 0x40
}
    3ab8:	bf00      	nop
    3aba:	b006      	add	sp, #24
    3abc:	4770      	bx	lr
    3abe:	bf00      	nop
    3ac0:	00017fac 	.word	0x00017fac
    3ac4:	40048000 	.word	0x40048000

00003ac8 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimTraceEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    3ac8:	b084      	sub	sp, #16
    3aca:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->CLKDIV4;
    3acc:	4b0a      	ldr	r3, [pc, #40]	; (3af8 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x30>)
    3ace:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    3ad0:	9303      	str	r3, [sp, #12]
    if (1U == Config->Enable)
    3ad2:	9b01      	ldr	r3, [sp, #4]
    3ad4:	889b      	ldrh	r3, [r3, #4]
    3ad6:	2b01      	cmp	r3, #1
    3ad8:	d104      	bne.n	3ae4 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x1c>
    {
        RegValue |= (SIM_CLKDIV4_TRACEDIVEN_MASK);
    3ada:	9b03      	ldr	r3, [sp, #12]
    3adc:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    3ae0:	9303      	str	r3, [sp, #12]
    3ae2:	e003      	b.n	3aec <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x24>
    }
    else
    {
        RegValue &= ~(SIM_CLKDIV4_TRACEDIVEN_MASK);
    3ae4:	9b03      	ldr	r3, [sp, #12]
    3ae6:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    3aea:	9303      	str	r3, [sp, #12]
    }
    IP_SIM->CLKDIV4 = RegValue;
    3aec:	4a02      	ldr	r2, [pc, #8]	; (3af8 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x30>)
    3aee:	9b03      	ldr	r3, [sp, #12]
    3af0:	6693      	str	r3, [r2, #104]	; 0x68
}
    3af2:	bf00      	nop
    3af4:	b004      	add	sp, #16
    3af6:	4770      	bx	lr
    3af8:	40048000 	.word	0x40048000

00003afc <Clock_Ip_InternalOscillatorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_InternalOscillatorEmpty(Clock_Ip_IrcoscConfigType const* Config)
{
    3afc:	b082      	sub	sp, #8
    3afe:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    3b00:	bf00      	nop
    3b02:	b002      	add	sp, #8
    3b04:	4770      	bx	lr

00003b06 <Clock_Ip_InternalOscillatorEmpty_Disable>:
static void Clock_Ip_InternalOscillatorEmpty_Disable(Clock_Ip_NameType Name)
{
    3b06:	b082      	sub	sp, #8
    3b08:	9001      	str	r0, [sp, #4]
    (void)Name;
    /* No implementation */
}
    3b0a:	bf00      	nop
    3b0c:	b002      	add	sp, #8
    3b0e:	4770      	bx	lr

00003b10 <Clock_Ip_SetSirc>:
}
#endif

#ifdef CLOCK_IP_SIRC_ENABLE
static void Clock_Ip_SetSirc(Clock_Ip_IrcoscConfigType const* Config)
{
    3b10:	b500      	push	{lr}
    3b12:	b083      	sub	sp, #12
    3b14:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3b16:	9b01      	ldr	r3, [sp, #4]
    3b18:	2b00      	cmp	r3, #0
    3b1a:	d002      	beq.n	3b22 <Clock_Ip_SetSirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSirc_TrustedCall,(Config));
      #else
        Clock_Ip_SetSirc_TrustedCall(Config);
    3b1c:	9801      	ldr	r0, [sp, #4]
    3b1e:	f000 f8d1 	bl	3cc4 <Clock_Ip_SetSirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3b22:	bf00      	nop
    3b24:	b003      	add	sp, #12
    3b26:	f85d fb04 	ldr.w	pc, [sp], #4

00003b2a <Clock_Ip_EnableSirc>:
static void Clock_Ip_EnableSirc(Clock_Ip_IrcoscConfigType const* Config)
{
    3b2a:	b500      	push	{lr}
    3b2c:	b083      	sub	sp, #12
    3b2e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3b30:	9b01      	ldr	r3, [sp, #4]
    3b32:	2b00      	cmp	r3, #0
    3b34:	d002      	beq.n	3b3c <Clock_Ip_EnableSirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSirc_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSirc_TrustedCall(Config);
    3b36:	9801      	ldr	r0, [sp, #4]
    3b38:	f000 f950 	bl	3ddc <Clock_Ip_EnableSirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3b3c:	bf00      	nop
    3b3e:	b003      	add	sp, #12
    3b40:	f85d fb04 	ldr.w	pc, [sp], #4

00003b44 <Clock_Ip_DisableSirc>:
static void Clock_Ip_DisableSirc(Clock_Ip_NameType Name)
{
    3b44:	b500      	push	{lr}
    3b46:	b083      	sub	sp, #12
    3b48:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSirc_TrustedCall,(Name));
  #else
    Clock_Ip_DisableSirc_TrustedCall(Name);
    3b4a:	9801      	ldr	r0, [sp, #4]
    3b4c:	f000 f98e 	bl	3e6c <Clock_Ip_DisableSirc_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    3b50:	bf00      	nop
    3b52:	b003      	add	sp, #12
    3b54:	f85d fb04 	ldr.w	pc, [sp], #4

00003b58 <Clock_Ip_SetSircVlp>:
#endif

#ifdef CLOCK_IP_SIRC_VLP_ENABLE
static void Clock_Ip_SetSircVlp(Clock_Ip_IrcoscConfigType const* Config)
{
    3b58:	b500      	push	{lr}
    3b5a:	b083      	sub	sp, #12
    3b5c:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3b5e:	9b01      	ldr	r3, [sp, #4]
    3b60:	2b00      	cmp	r3, #0
    3b62:	d002      	beq.n	3b6a <Clock_Ip_SetSircVlp+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSircVlp_TrustedCall,(Config));
      #else
        Clock_Ip_SetSircVlp_TrustedCall(Config);
    3b64:	9801      	ldr	r0, [sp, #4]
    3b66:	f000 f999 	bl	3e9c <Clock_Ip_SetSircVlp_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3b6a:	bf00      	nop
    3b6c:	b003      	add	sp, #12
    3b6e:	f85d fb04 	ldr.w	pc, [sp], #4

00003b72 <Clock_Ip_EnableSircVlp>:
static void Clock_Ip_EnableSircVlp(Clock_Ip_IrcoscConfigType const* Config)
{
    3b72:	b500      	push	{lr}
    3b74:	b083      	sub	sp, #12
    3b76:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3b78:	9b01      	ldr	r3, [sp, #4]
    3b7a:	2b00      	cmp	r3, #0
    3b7c:	d002      	beq.n	3b84 <Clock_Ip_EnableSircVlp+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSircVlp_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSircVlp_TrustedCall(Config);
    3b7e:	9801      	ldr	r0, [sp, #4]
    3b80:	f000 f9b0 	bl	3ee4 <Clock_Ip_EnableSircVlp_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3b84:	bf00      	nop
    3b86:	b003      	add	sp, #12
    3b88:	f85d fb04 	ldr.w	pc, [sp], #4

00003b8c <Clock_Ip_DisableSircVlp>:
static void Clock_Ip_DisableSircVlp(Clock_Ip_NameType Name)
{
    3b8c:	b500      	push	{lr}
    3b8e:	b083      	sub	sp, #12
    3b90:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSircVlp_TrustedCall,(Name));
  #else
    Clock_Ip_DisableSircVlp_TrustedCall(Name);
    3b92:	9801      	ldr	r0, [sp, #4]
    3b94:	f000 f9ba 	bl	3f0c <Clock_Ip_DisableSircVlp_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    3b98:	bf00      	nop
    3b9a:	b003      	add	sp, #12
    3b9c:	f85d fb04 	ldr.w	pc, [sp], #4

00003ba0 <Clock_Ip_SetSircStop>:
#endif

#ifdef CLOCK_IP_SIRC_STOP_ENABLE
static void Clock_Ip_SetSircStop(Clock_Ip_IrcoscConfigType const* Config)
{
    3ba0:	b500      	push	{lr}
    3ba2:	b083      	sub	sp, #12
    3ba4:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3ba6:	9b01      	ldr	r3, [sp, #4]
    3ba8:	2b00      	cmp	r3, #0
    3baa:	d002      	beq.n	3bb2 <Clock_Ip_SetSircStop+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSircStop_TrustedCall,(Config));
      #else
        Clock_Ip_SetSircStop_TrustedCall(Config);
    3bac:	9801      	ldr	r0, [sp, #4]
    3bae:	f000 f9bd 	bl	3f2c <Clock_Ip_SetSircStop_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3bb2:	bf00      	nop
    3bb4:	b003      	add	sp, #12
    3bb6:	f85d fb04 	ldr.w	pc, [sp], #4

00003bba <Clock_Ip_EnableSircStop>:
static void Clock_Ip_EnableSircStop(Clock_Ip_IrcoscConfigType const* Config)
{
    3bba:	b500      	push	{lr}
    3bbc:	b083      	sub	sp, #12
    3bbe:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3bc0:	9b01      	ldr	r3, [sp, #4]
    3bc2:	2b00      	cmp	r3, #0
    3bc4:	d002      	beq.n	3bcc <Clock_Ip_EnableSircStop+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSircStop_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSircStop_TrustedCall(Config);
    3bc6:	9801      	ldr	r0, [sp, #4]
    3bc8:	f000 f9d4 	bl	3f74 <Clock_Ip_EnableSircStop_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3bcc:	bf00      	nop
    3bce:	b003      	add	sp, #12
    3bd0:	f85d fb04 	ldr.w	pc, [sp], #4

00003bd4 <Clock_Ip_DisableSircStop>:
static void Clock_Ip_DisableSircStop(Clock_Ip_NameType Name)
{
    3bd4:	b500      	push	{lr}
    3bd6:	b083      	sub	sp, #12
    3bd8:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSircStop_TrustedCall,(Name));
  #else
    Clock_Ip_DisableSircStop_TrustedCall(Name);
    3bda:	9801      	ldr	r0, [sp, #4]
    3bdc:	f000 f9de 	bl	3f9c <Clock_Ip_DisableSircStop_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    3be0:	bf00      	nop
    3be2:	b003      	add	sp, #12
    3be4:	f85d fb04 	ldr.w	pc, [sp], #4

00003be8 <SetInputSouceSytemClock>:

#ifdef CLOCK_IP_FIRC_ENABLE
#define CLOCK_IP_SIRC_CLK_SOURCE 2U
#define CLOCK_IP_FIRC_CLK_SOURCE 3U
static void SetInputSouceSytemClock(uint32 SourceClock)
{
    3be8:	b500      	push	{lr}
    3bea:	b089      	sub	sp, #36	; 0x24
    3bec:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    boolean TimeoutOccurred = FALSE;
    3bee:	2300      	movs	r3, #0
    3bf0:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 ScsStatus;

    RegValue = IP_SCG->RCCR;
    3bf4:	4b20      	ldr	r3, [pc, #128]	; (3c78 <SetInputSouceSytemClock+0x90>)
    3bf6:	695b      	ldr	r3, [r3, #20]
    3bf8:	9306      	str	r3, [sp, #24]
    RegValue &= ~SCG_RCCR_SCS_MASK;
    3bfa:	9b06      	ldr	r3, [sp, #24]
    3bfc:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    3c00:	9306      	str	r3, [sp, #24]
    RegValue |= (SourceClock << SCG_RCCR_SCS_SHIFT);
    3c02:	9b01      	ldr	r3, [sp, #4]
    3c04:	061b      	lsls	r3, r3, #24
    3c06:	9a06      	ldr	r2, [sp, #24]
    3c08:	4313      	orrs	r3, r2
    3c0a:	9306      	str	r3, [sp, #24]
    IP_SCG->RCCR = RegValue;
    3c0c:	4a1a      	ldr	r2, [pc, #104]	; (3c78 <SetInputSouceSytemClock+0x90>)
    3c0e:	9b06      	ldr	r3, [sp, #24]
    3c10:	6153      	str	r3, [r2, #20]

    Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    3c12:	aa02      	add	r2, sp, #8
    3c14:	a903      	add	r1, sp, #12
    3c16:	a804      	add	r0, sp, #16
    3c18:	f24c 3350 	movw	r3, #50000	; 0xc350
    3c1c:	f7ff f9ac 	bl	2f78 <Clock_Ip_StartTimeout>
    do
    {
        ScsStatus = (((IP_SCG->CSR & SCG_CSR_SCS_MASK) >> SCG_CSR_SCS_SHIFT) != (SourceClock))?0U:1U;
    3c20:	4b15      	ldr	r3, [pc, #84]	; (3c78 <SetInputSouceSytemClock+0x90>)
    3c22:	691b      	ldr	r3, [r3, #16]
    3c24:	0e1b      	lsrs	r3, r3, #24
    3c26:	f003 030f 	and.w	r3, r3, #15
    3c2a:	9a01      	ldr	r2, [sp, #4]
    3c2c:	429a      	cmp	r2, r3
    3c2e:	bf0c      	ite	eq
    3c30:	2301      	moveq	r3, #1
    3c32:	2300      	movne	r3, #0
    3c34:	b2db      	uxtb	r3, r3
    3c36:	9305      	str	r3, [sp, #20]
        TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    3c38:	9a02      	ldr	r2, [sp, #8]
    3c3a:	a903      	add	r1, sp, #12
    3c3c:	ab04      	add	r3, sp, #16
    3c3e:	4618      	mov	r0, r3
    3c40:	f7ff f9b4 	bl	2fac <Clock_Ip_TimeoutExpired>
    3c44:	4603      	mov	r3, r0
    3c46:	f88d 301f 	strb.w	r3, [sp, #31]
    }
    while ((0U == ScsStatus) && (FALSE == TimeoutOccurred));
    3c4a:	9b05      	ldr	r3, [sp, #20]
    3c4c:	2b00      	cmp	r3, #0
    3c4e:	d106      	bne.n	3c5e <SetInputSouceSytemClock+0x76>
    3c50:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3c54:	f083 0301 	eor.w	r3, r3, #1
    3c58:	b2db      	uxtb	r3, r3
    3c5a:	2b00      	cmp	r3, #0
    3c5c:	d1e0      	bne.n	3c20 <SetInputSouceSytemClock+0x38>

    if (FALSE != TimeoutOccurred)
    3c5e:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3c62:	2b00      	cmp	r3, #0
    3c64:	d003      	beq.n	3c6e <SetInputSouceSytemClock+0x86>
    {
        /* Report timeout error */
        Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, FIRC_CLK);
    3c66:	2105      	movs	r1, #5
    3c68:	2001      	movs	r0, #1
    3c6a:	f7ff f975 	bl	2f58 <Clock_Ip_ReportClockErrors>
    }
}
    3c6e:	bf00      	nop
    3c70:	b009      	add	sp, #36	; 0x24
    3c72:	f85d fb04 	ldr.w	pc, [sp], #4
    3c76:	bf00      	nop
    3c78:	40064000 	.word	0x40064000

00003c7c <Clock_Ip_SetFirc>:
static void Clock_Ip_SetFirc(Clock_Ip_IrcoscConfigType const* Config)
{
    3c7c:	b500      	push	{lr}
    3c7e:	b083      	sub	sp, #12
    3c80:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3c82:	9b01      	ldr	r3, [sp, #4]
    3c84:	2b00      	cmp	r3, #0
    3c86:	d002      	beq.n	3c8e <Clock_Ip_SetFirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetFirc_TrustedCall,(Config));
      #else
        Clock_Ip_SetFirc_TrustedCall(Config);
    3c88:	9801      	ldr	r0, [sp, #4]
    3c8a:	f000 f997 	bl	3fbc <Clock_Ip_SetFirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3c8e:	bf00      	nop
    3c90:	b003      	add	sp, #12
    3c92:	f85d fb04 	ldr.w	pc, [sp], #4

00003c96 <Clock_Ip_EnableFirc>:
static void Clock_Ip_EnableFirc(Clock_Ip_IrcoscConfigType const* Config)
{
    3c96:	b500      	push	{lr}
    3c98:	b083      	sub	sp, #12
    3c9a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3c9c:	9b01      	ldr	r3, [sp, #4]
    3c9e:	2b00      	cmp	r3, #0
    3ca0:	d002      	beq.n	3ca8 <Clock_Ip_EnableFirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableFirc_TrustedCall,(Config));
      #else
        Clock_Ip_EnableFirc_TrustedCall(Config);
    3ca2:	9801      	ldr	r0, [sp, #4]
    3ca4:	f000 fa7e 	bl	41a4 <Clock_Ip_EnableFirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3ca8:	bf00      	nop
    3caa:	b003      	add	sp, #12
    3cac:	f85d fb04 	ldr.w	pc, [sp], #4

00003cb0 <Clock_Ip_DisableFirc>:
static void Clock_Ip_DisableFirc(Clock_Ip_NameType Name)
{
    3cb0:	b500      	push	{lr}
    3cb2:	b083      	sub	sp, #12
    3cb4:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableFirc_TrustedCall,(Name));
  #else
    Clock_Ip_DisableFirc_TrustedCall(Name);
    3cb6:	9801      	ldr	r0, [sp, #4]
    3cb8:	f000 fab8 	bl	422c <Clock_Ip_DisableFirc_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    3cbc:	bf00      	nop
    3cbe:	b003      	add	sp, #12
    3cc0:	f85d fb04 	ldr.w	pc, [sp], #4

00003cc4 <Clock_Ip_SetSirc_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SIRC_ENABLE
void Clock_Ip_SetSirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    3cc4:	b500      	push	{lr}
    3cc6:	b08b      	sub	sp, #44	; 0x2c
    3cc8:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    3cca:	2300      	movs	r3, #0
    3ccc:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;
    Clock_Ip_IrcoscConfigType SircConfig;

    if (NULL_PTR == Config)
    3cd0:	9b01      	ldr	r3, [sp, #4]
    3cd2:	2b00      	cmp	r3, #0
    3cd4:	d10b      	bne.n	3cee <Clock_Ip_SetSirc_TrustedCall+0x2a>
    {
        SircConfig.Name   = FIRC_CLK;
    3cd6:	2305      	movs	r3, #5
    3cd8:	9302      	str	r3, [sp, #8]
        SircConfig.Range  = 1U;   /* 8MHz */
    3cda:	2301      	movs	r3, #1
    3cdc:	f88d 300f 	strb.w	r3, [sp, #15]
        SircConfig.Enable = 1U;   /* enabled */
    3ce0:	2301      	movs	r3, #1
    3ce2:	f8ad 300c 	strh.w	r3, [sp, #12]
        SircConfig.LowPowerModeEnable =1U;
    3ce6:	2301      	movs	r3, #1
    3ce8:	f88d 3010 	strb.w	r3, [sp, #16]
    3cec:	e00e      	b.n	3d0c <Clock_Ip_SetSirc_TrustedCall+0x48>
    }
    else
    {
        SircConfig.Name   = Config->Name;
    3cee:	9b01      	ldr	r3, [sp, #4]
    3cf0:	681b      	ldr	r3, [r3, #0]
    3cf2:	9302      	str	r3, [sp, #8]
        SircConfig.Range  = Config->Range;
    3cf4:	9b01      	ldr	r3, [sp, #4]
    3cf6:	79db      	ldrb	r3, [r3, #7]
    3cf8:	f88d 300f 	strb.w	r3, [sp, #15]
        SircConfig.Enable = Config->Enable;
    3cfc:	9b01      	ldr	r3, [sp, #4]
    3cfe:	889b      	ldrh	r3, [r3, #4]
    3d00:	f8ad 300c 	strh.w	r3, [sp, #12]
        SircConfig.LowPowerModeEnable = Config->LowPowerModeEnable;
    3d04:	9b01      	ldr	r3, [sp, #4]
    3d06:	7a1b      	ldrb	r3, [r3, #8]
    3d08:	f88d 3010 	strb.w	r3, [sp, #16]
    }

    /* Clear LK bit field */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_LK_MASK));
    3d0c:	4b32      	ldr	r3, [pc, #200]	; (3dd8 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3d0e:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3d12:	4a31      	ldr	r2, [pc, #196]	; (3dd8 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3d14:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    3d18:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Disable clock */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCEN_MASK));
    3d1c:	4b2e      	ldr	r3, [pc, #184]	; (3dd8 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3d1e:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3d22:	4a2d      	ldr	r2, [pc, #180]	; (3dd8 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3d24:	f023 0301 	bic.w	r3, r3, #1
    3d28:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Disable SIRC Low Power */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    3d2c:	4b2a      	ldr	r3, [pc, #168]	; (3dd8 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3d2e:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3d32:	4a29      	ldr	r2, [pc, #164]	; (3dd8 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3d34:	f023 0304 	bic.w	r3, r3, #4
    3d38:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Configure SIRC. */
    if (1U == SircConfig.Enable)
    3d3c:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    3d40:	2b01      	cmp	r3, #1
    3d42:	d144      	bne.n	3dce <Clock_Ip_SetSirc_TrustedCall+0x10a>
    {
        /* Step frequency range. */
        IP_SCG->SIRCCFG = SCG_SIRCCFG_RANGE(SircConfig.Range);
    3d44:	f89d 300f 	ldrb.w	r3, [sp, #15]
    3d48:	4a23      	ldr	r2, [pc, #140]	; (3dd8 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3d4a:	f003 0301 	and.w	r3, r3, #1
    3d4e:	f8c2 3208 	str.w	r3, [r2, #520]	; 0x208

        /* Enable clock. */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCEN(1U);
    3d52:	4b21      	ldr	r3, [pc, #132]	; (3dd8 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3d54:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3d58:	4a1f      	ldr	r2, [pc, #124]	; (3dd8 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3d5a:	f043 0301 	orr.w	r3, r3, #1
    3d5e:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

        /* Set SIRC in VLP modes */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(SircConfig.LowPowerModeEnable);
    3d62:	4b1d      	ldr	r3, [pc, #116]	; (3dd8 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3d64:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    3d68:	f89d 3010 	ldrb.w	r3, [sp, #16]
    3d6c:	009b      	lsls	r3, r3, #2
    3d6e:	f003 0304 	and.w	r3, r3, #4
    3d72:	4919      	ldr	r1, [pc, #100]	; (3dd8 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3d74:	4313      	orrs	r3, r2
    3d76:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200

        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    3d7a:	aa05      	add	r2, sp, #20
    3d7c:	a906      	add	r1, sp, #24
    3d7e:	a807      	add	r0, sp, #28
    3d80:	f24c 3350 	movw	r3, #50000	; 0xc350
    3d84:	f7ff f8f8 	bl	2f78 <Clock_Ip_StartTimeout>
        /* Wait until ircosc is locked */
        do
        {
            IrcoscStatus = (((IP_SCG->SIRCCSR & SCG_SIRCCSR_SIRCVLD_MASK) >> SCG_SIRCCSR_SIRCVLD_SHIFT));
    3d88:	4b13      	ldr	r3, [pc, #76]	; (3dd8 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3d8a:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3d8e:	0e1b      	lsrs	r3, r3, #24
    3d90:	f003 0301 	and.w	r3, r3, #1
    3d94:	9308      	str	r3, [sp, #32]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    3d96:	9a05      	ldr	r2, [sp, #20]
    3d98:	a906      	add	r1, sp, #24
    3d9a:	ab07      	add	r3, sp, #28
    3d9c:	4618      	mov	r0, r3
    3d9e:	f7ff f905 	bl	2fac <Clock_Ip_TimeoutExpired>
    3da2:	4603      	mov	r3, r0
    3da4:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
        }
        while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    3da8:	9b08      	ldr	r3, [sp, #32]
    3daa:	2b00      	cmp	r3, #0
    3dac:	d106      	bne.n	3dbc <Clock_Ip_SetSirc_TrustedCall+0xf8>
    3dae:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    3db2:	f083 0301 	eor.w	r3, r3, #1
    3db6:	b2db      	uxtb	r3, r3
    3db8:	2b00      	cmp	r3, #0
    3dba:	d1e5      	bne.n	3d88 <Clock_Ip_SetSirc_TrustedCall+0xc4>

        if (FALSE != TimeoutOccurred)
    3dbc:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    3dc0:	2b00      	cmp	r3, #0
    3dc2:	d004      	beq.n	3dce <Clock_Ip_SetSirc_TrustedCall+0x10a>
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, SircConfig.Name);
    3dc4:	9b02      	ldr	r3, [sp, #8]
    3dc6:	4619      	mov	r1, r3
    3dc8:	2001      	movs	r0, #1
    3dca:	f7ff f8c5 	bl	2f58 <Clock_Ip_ReportClockErrors>
        }
    }
}
    3dce:	bf00      	nop
    3dd0:	b00b      	add	sp, #44	; 0x2c
    3dd2:	f85d fb04 	ldr.w	pc, [sp], #4
    3dd6:	bf00      	nop
    3dd8:	40064000 	.word	0x40064000

00003ddc <Clock_Ip_EnableSirc_TrustedCall>:
void Clock_Ip_EnableSirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    3ddc:	b500      	push	{lr}
    3dde:	b089      	sub	sp, #36	; 0x24
    3de0:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    3de2:	2300      	movs	r3, #0
    3de4:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;

    /* Enable clock. */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCEN(1U);
    3de8:	4b1f      	ldr	r3, [pc, #124]	; (3e68 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    3dea:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3dee:	4a1e      	ldr	r2, [pc, #120]	; (3e68 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    3df0:	f043 0301 	orr.w	r3, r3, #1
    3df4:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Enable SIRC Low Power */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(1UL);
    3df8:	4b1b      	ldr	r3, [pc, #108]	; (3e68 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    3dfa:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3dfe:	4a1a      	ldr	r2, [pc, #104]	; (3e68 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    3e00:	f043 0304 	orr.w	r3, r3, #4
    3e04:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    3e08:	aa03      	add	r2, sp, #12
    3e0a:	a904      	add	r1, sp, #16
    3e0c:	a805      	add	r0, sp, #20
    3e0e:	f24c 3350 	movw	r3, #50000	; 0xc350
    3e12:	f7ff f8b1 	bl	2f78 <Clock_Ip_StartTimeout>
    /* Wait until ircosc is locked */
    do
    {
        IrcoscStatus = (((IP_SCG->SIRCCSR & SCG_SIRCCSR_SIRCVLD_MASK) >> SCG_SIRCCSR_SIRCVLD_SHIFT));
    3e16:	4b14      	ldr	r3, [pc, #80]	; (3e68 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    3e18:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3e1c:	0e1b      	lsrs	r3, r3, #24
    3e1e:	f003 0301 	and.w	r3, r3, #1
    3e22:	9306      	str	r3, [sp, #24]
        TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    3e24:	9a03      	ldr	r2, [sp, #12]
    3e26:	a904      	add	r1, sp, #16
    3e28:	ab05      	add	r3, sp, #20
    3e2a:	4618      	mov	r0, r3
    3e2c:	f7ff f8be 	bl	2fac <Clock_Ip_TimeoutExpired>
    3e30:	4603      	mov	r3, r0
    3e32:	f88d 301f 	strb.w	r3, [sp, #31]
    }
    while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    3e36:	9b06      	ldr	r3, [sp, #24]
    3e38:	2b00      	cmp	r3, #0
    3e3a:	d106      	bne.n	3e4a <Clock_Ip_EnableSirc_TrustedCall+0x6e>
    3e3c:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3e40:	f083 0301 	eor.w	r3, r3, #1
    3e44:	b2db      	uxtb	r3, r3
    3e46:	2b00      	cmp	r3, #0
    3e48:	d1e5      	bne.n	3e16 <Clock_Ip_EnableSirc_TrustedCall+0x3a>

    if (FALSE != TimeoutOccurred)
    3e4a:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3e4e:	2b00      	cmp	r3, #0
    3e50:	d005      	beq.n	3e5e <Clock_Ip_EnableSirc_TrustedCall+0x82>
    {
        /* Report timeout error */
        Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    3e52:	9b01      	ldr	r3, [sp, #4]
    3e54:	681b      	ldr	r3, [r3, #0]
    3e56:	4619      	mov	r1, r3
    3e58:	2001      	movs	r0, #1
    3e5a:	f7ff f87d 	bl	2f58 <Clock_Ip_ReportClockErrors>
    }
}
    3e5e:	bf00      	nop
    3e60:	b009      	add	sp, #36	; 0x24
    3e62:	f85d fb04 	ldr.w	pc, [sp], #4
    3e66:	bf00      	nop
    3e68:	40064000 	.word	0x40064000

00003e6c <Clock_Ip_DisableSirc_TrustedCall>:
void Clock_Ip_DisableSirc_TrustedCall(Clock_Ip_NameType Name)
{
    3e6c:	b082      	sub	sp, #8
    3e6e:	9001      	str	r0, [sp, #4]
    (void)Name;

    /* Disable clock. */
    IP_SCG->SIRCCSR &= ~SCG_SIRCCSR_SIRCEN_MASK;
    3e70:	4b09      	ldr	r3, [pc, #36]	; (3e98 <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    3e72:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3e76:	4a08      	ldr	r2, [pc, #32]	; (3e98 <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    3e78:	f023 0301 	bic.w	r3, r3, #1
    3e7c:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Disable SIRC Low Power */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    3e80:	4b05      	ldr	r3, [pc, #20]	; (3e98 <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    3e82:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3e86:	4a04      	ldr	r2, [pc, #16]	; (3e98 <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    3e88:	f023 0304 	bic.w	r3, r3, #4
    3e8c:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
    3e90:	bf00      	nop
    3e92:	b002      	add	sp, #8
    3e94:	4770      	bx	lr
    3e96:	bf00      	nop
    3e98:	40064000 	.word	0x40064000

00003e9c <Clock_Ip_SetSircVlp_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIRC_VLP_ENABLE
void Clock_Ip_SetSircVlp_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    3e9c:	b082      	sub	sp, #8
    3e9e:	9001      	str	r0, [sp, #4]
    /* Clear LK bit field */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_LK_MASK));
    3ea0:	4b0f      	ldr	r3, [pc, #60]	; (3ee0 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    3ea2:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3ea6:	4a0e      	ldr	r2, [pc, #56]	; (3ee0 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    3ea8:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    3eac:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    3eb0:	4b0b      	ldr	r3, [pc, #44]	; (3ee0 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    3eb2:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3eb6:	4a0a      	ldr	r2, [pc, #40]	; (3ee0 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    3eb8:	f023 0304 	bic.w	r3, r3, #4
    3ebc:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Configure SIRC in VLP mode */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(Config->LowPowerModeEnable);
    3ec0:	4b07      	ldr	r3, [pc, #28]	; (3ee0 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    3ec2:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    3ec6:	9b01      	ldr	r3, [sp, #4]
    3ec8:	7a1b      	ldrb	r3, [r3, #8]
    3eca:	009b      	lsls	r3, r3, #2
    3ecc:	f003 0304 	and.w	r3, r3, #4
    3ed0:	4903      	ldr	r1, [pc, #12]	; (3ee0 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    3ed2:	4313      	orrs	r3, r2
    3ed4:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200
}
    3ed8:	bf00      	nop
    3eda:	b002      	add	sp, #8
    3edc:	4770      	bx	lr
    3ede:	bf00      	nop
    3ee0:	40064000 	.word	0x40064000

00003ee4 <Clock_Ip_EnableSircVlp_TrustedCall>:
void Clock_Ip_EnableSircVlp_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    3ee4:	b082      	sub	sp, #8
    3ee6:	9001      	str	r0, [sp, #4]
    if (1U == Config->Enable)
    3ee8:	9b01      	ldr	r3, [sp, #4]
    3eea:	889b      	ldrh	r3, [r3, #4]
    3eec:	2b01      	cmp	r3, #1
    3eee:	d107      	bne.n	3f00 <Clock_Ip_EnableSircVlp_TrustedCall+0x1c>
    {
        /* Enable clock in VLP mode */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(1U);
    3ef0:	4b05      	ldr	r3, [pc, #20]	; (3f08 <Clock_Ip_EnableSircVlp_TrustedCall+0x24>)
    3ef2:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3ef6:	4a04      	ldr	r2, [pc, #16]	; (3f08 <Clock_Ip_EnableSircVlp_TrustedCall+0x24>)
    3ef8:	f043 0304 	orr.w	r3, r3, #4
    3efc:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
    }
}
    3f00:	bf00      	nop
    3f02:	b002      	add	sp, #8
    3f04:	4770      	bx	lr
    3f06:	bf00      	nop
    3f08:	40064000 	.word	0x40064000

00003f0c <Clock_Ip_DisableSircVlp_TrustedCall>:
void Clock_Ip_DisableSircVlp_TrustedCall(Clock_Ip_NameType Name)
{
    3f0c:	b082      	sub	sp, #8
    3f0e:	9001      	str	r0, [sp, #4]
    (void)Name;

    /* Disable clock */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    3f10:	4b05      	ldr	r3, [pc, #20]	; (3f28 <Clock_Ip_DisableSircVlp_TrustedCall+0x1c>)
    3f12:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3f16:	4a04      	ldr	r2, [pc, #16]	; (3f28 <Clock_Ip_DisableSircVlp_TrustedCall+0x1c>)
    3f18:	f023 0304 	bic.w	r3, r3, #4
    3f1c:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
    3f20:	bf00      	nop
    3f22:	b002      	add	sp, #8
    3f24:	4770      	bx	lr
    3f26:	bf00      	nop
    3f28:	40064000 	.word	0x40064000

00003f2c <Clock_Ip_SetSircStop_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIRC_STOP_ENABLE
void Clock_Ip_SetSircStop_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    3f2c:	b082      	sub	sp, #8
    3f2e:	9001      	str	r0, [sp, #4]
    (void)Config;

    /* Clear LK bit field */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_LK_MASK));
    3f30:	4b0f      	ldr	r3, [pc, #60]	; (3f70 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    3f32:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3f36:	4a0e      	ldr	r2, [pc, #56]	; (3f70 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    3f38:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    3f3c:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCSTEN_MASK));
    3f40:	4b0b      	ldr	r3, [pc, #44]	; (3f70 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    3f42:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3f46:	4a0a      	ldr	r2, [pc, #40]	; (3f70 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    3f48:	f023 0302 	bic.w	r3, r3, #2
    3f4c:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Configure SIRC in STOP mode */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCSTEN(Config->StopModeEnable);
    3f50:	4b07      	ldr	r3, [pc, #28]	; (3f70 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    3f52:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    3f56:	9b01      	ldr	r3, [sp, #4]
    3f58:	7a5b      	ldrb	r3, [r3, #9]
    3f5a:	005b      	lsls	r3, r3, #1
    3f5c:	f003 0302 	and.w	r3, r3, #2
    3f60:	4903      	ldr	r1, [pc, #12]	; (3f70 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    3f62:	4313      	orrs	r3, r2
    3f64:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200
}
    3f68:	bf00      	nop
    3f6a:	b002      	add	sp, #8
    3f6c:	4770      	bx	lr
    3f6e:	bf00      	nop
    3f70:	40064000 	.word	0x40064000

00003f74 <Clock_Ip_EnableSircStop_TrustedCall>:
void Clock_Ip_EnableSircStop_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    3f74:	b082      	sub	sp, #8
    3f76:	9001      	str	r0, [sp, #4]
    if (1U == Config->Enable)
    3f78:	9b01      	ldr	r3, [sp, #4]
    3f7a:	889b      	ldrh	r3, [r3, #4]
    3f7c:	2b01      	cmp	r3, #1
    3f7e:	d107      	bne.n	3f90 <Clock_Ip_EnableSircStop_TrustedCall+0x1c>
    {
        /* Enable clock in VLP mode */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCSTEN(1U);
    3f80:	4b05      	ldr	r3, [pc, #20]	; (3f98 <Clock_Ip_EnableSircStop_TrustedCall+0x24>)
    3f82:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3f86:	4a04      	ldr	r2, [pc, #16]	; (3f98 <Clock_Ip_EnableSircStop_TrustedCall+0x24>)
    3f88:	f043 0302 	orr.w	r3, r3, #2
    3f8c:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
    }
}
    3f90:	bf00      	nop
    3f92:	b002      	add	sp, #8
    3f94:	4770      	bx	lr
    3f96:	bf00      	nop
    3f98:	40064000 	.word	0x40064000

00003f9c <Clock_Ip_DisableSircStop_TrustedCall>:
void Clock_Ip_DisableSircStop_TrustedCall(Clock_Ip_NameType Name)
{
    3f9c:	b082      	sub	sp, #8
    3f9e:	9001      	str	r0, [sp, #4]
    (void)Name;

    /* Disable clock */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCSTEN_MASK));
    3fa0:	4b05      	ldr	r3, [pc, #20]	; (3fb8 <Clock_Ip_DisableSircStop_TrustedCall+0x1c>)
    3fa2:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3fa6:	4a04      	ldr	r2, [pc, #16]	; (3fb8 <Clock_Ip_DisableSircStop_TrustedCall+0x1c>)
    3fa8:	f023 0302 	bic.w	r3, r3, #2
    3fac:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
    3fb0:	bf00      	nop
    3fb2:	b002      	add	sp, #8
    3fb4:	4770      	bx	lr
    3fb6:	bf00      	nop
    3fb8:	40064000 	.word	0x40064000

00003fbc <Clock_Ip_SetFirc_TrustedCall>:
#endif

#ifdef CLOCK_IP_FIRC_ENABLE
void Clock_Ip_SetFirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    3fbc:	b500      	push	{lr}
    3fbe:	b08b      	sub	sp, #44	; 0x2c
    3fc0:	9001      	str	r0, [sp, #4]
    uint32 Instance = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    3fc2:	9b01      	ldr	r3, [sp, #4]
    3fc4:	681a      	ldr	r2, [r3, #0]
    3fc6:	4975      	ldr	r1, [pc, #468]	; (419c <Clock_Ip_SetFirc_TrustedCall+0x1e0>)
    3fc8:	4613      	mov	r3, r2
    3fca:	00db      	lsls	r3, r3, #3
    3fcc:	4413      	add	r3, r2
    3fce:	440b      	add	r3, r1
    3fd0:	781b      	ldrb	r3, [r3, #0]
    3fd2:	9308      	str	r3, [sp, #32]
    boolean TimeoutOccurred = FALSE;
    3fd4:	2300      	movs	r3, #0
    3fd6:	f88d 301f 	strb.w	r3, [sp, #31]
    boolean SircWasDisabled = FALSE;
    3fda:	2300      	movs	r3, #0
    3fdc:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    uint32 IrcoscStatus;

    (void)Instance;

    /* Clear LK bit field */
    IP_SCG->FIRCCSR &= (uint32)(~(SCG_FIRCCSR_LK_MASK));
    3fe0:	4b6f      	ldr	r3, [pc, #444]	; (41a0 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3fe2:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3fe6:	4a6e      	ldr	r2, [pc, #440]	; (41a0 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3fe8:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    3fec:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

    /* Check that FIRC is used by system clock) */
    if ((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCSEL_MASK) != 0U)
    3ff0:	4b6b      	ldr	r3, [pc, #428]	; (41a0 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3ff2:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3ff6:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
    3ffa:	2b00      	cmp	r3, #0
    3ffc:	d07d      	beq.n	40fa <Clock_Ip_SetFirc_TrustedCall+0x13e>
    {
        /* Check whether FIRC is already configured as required */
        if ( (Config->Range != ((IP_SCG->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT)) ||
    3ffe:	9b01      	ldr	r3, [sp, #4]
    4000:	79db      	ldrb	r3, [r3, #7]
    4002:	461a      	mov	r2, r3
    4004:	4b66      	ldr	r3, [pc, #408]	; (41a0 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    4006:	f8d3 3308 	ldr.w	r3, [r3, #776]	; 0x308
    400a:	f003 0303 	and.w	r3, r3, #3
    400e:	429a      	cmp	r2, r3
    4010:	d10b      	bne.n	402a <Clock_Ip_SetFirc_TrustedCall+0x6e>
            (Config->Regulator != ((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCREGOFF_MASK) >> SCG_FIRCCSR_FIRCREGOFF_SHIFT)) )
    4012:	9b01      	ldr	r3, [sp, #4]
    4014:	799b      	ldrb	r3, [r3, #6]
    4016:	461a      	mov	r2, r3
    4018:	4b61      	ldr	r3, [pc, #388]	; (41a0 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    401a:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    401e:	08db      	lsrs	r3, r3, #3
    4020:	f003 0301 	and.w	r3, r3, #1
        if ( (Config->Range != ((IP_SCG->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT)) ||
    4024:	429a      	cmp	r2, r3
    4026:	f000 80b4 	beq.w	4192 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
        {
            /* Enable SIRC if it is disabled. */
            if (0U == (IP_SCG->SIRCCSR & SCG_SIRCCSR_SIRCEN_MASK))
    402a:	4b5d      	ldr	r3, [pc, #372]	; (41a0 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    402c:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    4030:	f003 0301 	and.w	r3, r3, #1
    4034:	2b00      	cmp	r3, #0
    4036:	d105      	bne.n	4044 <Clock_Ip_SetFirc_TrustedCall+0x88>
            {
                SircWasDisabled = TRUE;
    4038:	2301      	movs	r3, #1
    403a:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
                Clock_Ip_SetSirc(NULL_PTR);
    403e:	2000      	movs	r0, #0
    4040:	f7ff fd66 	bl	3b10 <Clock_Ip_SetSirc>
            }

            /* Switch to SIRC */
            SetInputSouceSytemClock(CLOCK_IP_SIRC_CLK_SOURCE);
    4044:	2002      	movs	r0, #2
    4046:	f7ff fdcf 	bl	3be8 <SetInputSouceSytemClock>

            /* Disable clock */
            IP_SCG->FIRCCSR &= (~((uint32)SCG_FIRCCSR_FIRCEN_MASK));
    404a:	4b55      	ldr	r3, [pc, #340]	; (41a0 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    404c:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4050:	4a53      	ldr	r2, [pc, #332]	; (41a0 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    4052:	f023 0301 	bic.w	r3, r3, #1
    4056:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

            /* Configure FIRC. */
            if (1U == Config->Enable)
    405a:	9b01      	ldr	r3, [sp, #4]
    405c:	889b      	ldrh	r3, [r3, #4]
    405e:	2b01      	cmp	r3, #1
    4060:	f040 8097 	bne.w	4192 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
            {
                /* Step frequency range. */
                IP_SCG->FIRCCFG = SCG_FIRCCFG_RANGE(Config->Range);
    4064:	9b01      	ldr	r3, [sp, #4]
    4066:	79db      	ldrb	r3, [r3, #7]
    4068:	4a4d      	ldr	r2, [pc, #308]	; (41a0 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    406a:	f003 0303 	and.w	r3, r3, #3
    406e:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308

                /* Enable clock. */
                IP_SCG->FIRCCSR |= (SCG_FIRCCSR_FIRCEN(1U) | SCG_FIRCCSR_FIRCREGOFF(Config->Regulator));
    4072:	4b4b      	ldr	r3, [pc, #300]	; (41a0 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    4074:	f8d3 2300 	ldr.w	r2, [r3, #768]	; 0x300
    4078:	9b01      	ldr	r3, [sp, #4]
    407a:	799b      	ldrb	r3, [r3, #6]
    407c:	00db      	lsls	r3, r3, #3
    407e:	f003 0308 	and.w	r3, r3, #8
    4082:	4313      	orrs	r3, r2
    4084:	4a46      	ldr	r2, [pc, #280]	; (41a0 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    4086:	f043 0301 	orr.w	r3, r3, #1
    408a:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

                Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    408e:	aa03      	add	r2, sp, #12
    4090:	a904      	add	r1, sp, #16
    4092:	a805      	add	r0, sp, #20
    4094:	f24c 3350 	movw	r3, #50000	; 0xc350
    4098:	f7fe ff6e 	bl	2f78 <Clock_Ip_StartTimeout>
                /* Wait until ircosc is locked */
                do
                {
                    IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    409c:	4b40      	ldr	r3, [pc, #256]	; (41a0 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    409e:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    40a2:	0e1b      	lsrs	r3, r3, #24
    40a4:	f003 0301 	and.w	r3, r3, #1
    40a8:	9306      	str	r3, [sp, #24]
                    TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    40aa:	9a03      	ldr	r2, [sp, #12]
    40ac:	a904      	add	r1, sp, #16
    40ae:	ab05      	add	r3, sp, #20
    40b0:	4618      	mov	r0, r3
    40b2:	f7fe ff7b 	bl	2fac <Clock_Ip_TimeoutExpired>
    40b6:	4603      	mov	r3, r0
    40b8:	f88d 301f 	strb.w	r3, [sp, #31]
                }
                while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    40bc:	9b06      	ldr	r3, [sp, #24]
    40be:	2b00      	cmp	r3, #0
    40c0:	d106      	bne.n	40d0 <Clock_Ip_SetFirc_TrustedCall+0x114>
    40c2:	f89d 301f 	ldrb.w	r3, [sp, #31]
    40c6:	f083 0301 	eor.w	r3, r3, #1
    40ca:	b2db      	uxtb	r3, r3
    40cc:	2b00      	cmp	r3, #0
    40ce:	d1e5      	bne.n	409c <Clock_Ip_SetFirc_TrustedCall+0xe0>

                if (FALSE != TimeoutOccurred)
    40d0:	f89d 301f 	ldrb.w	r3, [sp, #31]
    40d4:	2b00      	cmp	r3, #0
    40d6:	d005      	beq.n	40e4 <Clock_Ip_SetFirc_TrustedCall+0x128>
                {
                    /* Report timeout error */
                    Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    40d8:	9b01      	ldr	r3, [sp, #4]
    40da:	681b      	ldr	r3, [r3, #0]
    40dc:	4619      	mov	r1, r3
    40de:	2001      	movs	r0, #1
    40e0:	f7fe ff3a 	bl	2f58 <Clock_Ip_ReportClockErrors>
                }

                /* Switch back to FIRC */
                SetInputSouceSytemClock(CLOCK_IP_FIRC_CLK_SOURCE);
    40e4:	2003      	movs	r0, #3
    40e6:	f7ff fd7f 	bl	3be8 <SetInputSouceSytemClock>

                if (SircWasDisabled)
    40ea:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    40ee:	2b00      	cmp	r3, #0
    40f0:	d04f      	beq.n	4192 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
                {
                    Clock_Ip_DisableSirc(SIRC_CLK);
    40f2:	2002      	movs	r0, #2
    40f4:	f7ff fd26 	bl	3b44 <Clock_Ip_DisableSirc>
                /* Report timeout error */
                Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
            }
        }
    }
}
    40f8:	e04b      	b.n	4192 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
        IP_SCG->FIRCCSR &= (~((uint32)SCG_FIRCCSR_FIRCEN_MASK));
    40fa:	4b29      	ldr	r3, [pc, #164]	; (41a0 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    40fc:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4100:	4a27      	ldr	r2, [pc, #156]	; (41a0 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    4102:	f023 0301 	bic.w	r3, r3, #1
    4106:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
        if (1U == Config->Enable)
    410a:	9b01      	ldr	r3, [sp, #4]
    410c:	889b      	ldrh	r3, [r3, #4]
    410e:	2b01      	cmp	r3, #1
    4110:	d13f      	bne.n	4192 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
            IP_SCG->FIRCCFG = SCG_FIRCCFG_RANGE(Config->Range);
    4112:	9b01      	ldr	r3, [sp, #4]
    4114:	79db      	ldrb	r3, [r3, #7]
    4116:	4a22      	ldr	r2, [pc, #136]	; (41a0 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    4118:	f003 0303 	and.w	r3, r3, #3
    411c:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
            IP_SCG->FIRCCSR |= (SCG_FIRCCSR_FIRCEN(1U) | SCG_FIRCCSR_FIRCREGOFF(Config->Regulator));
    4120:	4b1f      	ldr	r3, [pc, #124]	; (41a0 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    4122:	f8d3 2300 	ldr.w	r2, [r3, #768]	; 0x300
    4126:	9b01      	ldr	r3, [sp, #4]
    4128:	799b      	ldrb	r3, [r3, #6]
    412a:	00db      	lsls	r3, r3, #3
    412c:	f003 0308 	and.w	r3, r3, #8
    4130:	4313      	orrs	r3, r2
    4132:	4a1b      	ldr	r2, [pc, #108]	; (41a0 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    4134:	f043 0301 	orr.w	r3, r3, #1
    4138:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
            Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    413c:	aa03      	add	r2, sp, #12
    413e:	a904      	add	r1, sp, #16
    4140:	a805      	add	r0, sp, #20
    4142:	f24c 3350 	movw	r3, #50000	; 0xc350
    4146:	f7fe ff17 	bl	2f78 <Clock_Ip_StartTimeout>
                IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    414a:	4b15      	ldr	r3, [pc, #84]	; (41a0 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    414c:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4150:	0e1b      	lsrs	r3, r3, #24
    4152:	f003 0301 	and.w	r3, r3, #1
    4156:	9306      	str	r3, [sp, #24]
                TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    4158:	9a03      	ldr	r2, [sp, #12]
    415a:	a904      	add	r1, sp, #16
    415c:	ab05      	add	r3, sp, #20
    415e:	4618      	mov	r0, r3
    4160:	f7fe ff24 	bl	2fac <Clock_Ip_TimeoutExpired>
    4164:	4603      	mov	r3, r0
    4166:	f88d 301f 	strb.w	r3, [sp, #31]
            while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    416a:	9b06      	ldr	r3, [sp, #24]
    416c:	2b00      	cmp	r3, #0
    416e:	d106      	bne.n	417e <Clock_Ip_SetFirc_TrustedCall+0x1c2>
    4170:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4174:	f083 0301 	eor.w	r3, r3, #1
    4178:	b2db      	uxtb	r3, r3
    417a:	2b00      	cmp	r3, #0
    417c:	d1e5      	bne.n	414a <Clock_Ip_SetFirc_TrustedCall+0x18e>
            if (FALSE != TimeoutOccurred)
    417e:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4182:	2b00      	cmp	r3, #0
    4184:	d005      	beq.n	4192 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
                Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    4186:	9b01      	ldr	r3, [sp, #4]
    4188:	681b      	ldr	r3, [r3, #0]
    418a:	4619      	mov	r1, r3
    418c:	2001      	movs	r0, #1
    418e:	f7fe fee3 	bl	2f58 <Clock_Ip_ReportClockErrors>
}
    4192:	bf00      	nop
    4194:	b00b      	add	sp, #44	; 0x2c
    4196:	f85d fb04 	ldr.w	pc, [sp], #4
    419a:	bf00      	nop
    419c:	00017fac 	.word	0x00017fac
    41a0:	40064000 	.word	0x40064000

000041a4 <Clock_Ip_EnableFirc_TrustedCall>:
void Clock_Ip_EnableFirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    41a4:	b500      	push	{lr}
    41a6:	b089      	sub	sp, #36	; 0x24
    41a8:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    41aa:	2300      	movs	r3, #0
    41ac:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;

    if (1U == Config->Enable)
    41b0:	9b01      	ldr	r3, [sp, #4]
    41b2:	889b      	ldrh	r3, [r3, #4]
    41b4:	2b01      	cmp	r3, #1
    41b6:	d132      	bne.n	421e <Clock_Ip_EnableFirc_TrustedCall+0x7a>
    {
        /* Enable clock. */
        IP_SCG->FIRCCSR |= SCG_FIRCCSR_FIRCEN(1U);
    41b8:	4b1b      	ldr	r3, [pc, #108]	; (4228 <Clock_Ip_EnableFirc_TrustedCall+0x84>)
    41ba:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    41be:	4a1a      	ldr	r2, [pc, #104]	; (4228 <Clock_Ip_EnableFirc_TrustedCall+0x84>)
    41c0:	f043 0301 	orr.w	r3, r3, #1
    41c4:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    41c8:	aa03      	add	r2, sp, #12
    41ca:	a904      	add	r1, sp, #16
    41cc:	a805      	add	r0, sp, #20
    41ce:	f24c 3350 	movw	r3, #50000	; 0xc350
    41d2:	f7fe fed1 	bl	2f78 <Clock_Ip_StartTimeout>
        /* Wait until ircosc is locked */
        do
        {
            IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    41d6:	4b14      	ldr	r3, [pc, #80]	; (4228 <Clock_Ip_EnableFirc_TrustedCall+0x84>)
    41d8:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    41dc:	0e1b      	lsrs	r3, r3, #24
    41de:	f003 0301 	and.w	r3, r3, #1
    41e2:	9306      	str	r3, [sp, #24]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    41e4:	9a03      	ldr	r2, [sp, #12]
    41e6:	a904      	add	r1, sp, #16
    41e8:	ab05      	add	r3, sp, #20
    41ea:	4618      	mov	r0, r3
    41ec:	f7fe fede 	bl	2fac <Clock_Ip_TimeoutExpired>
    41f0:	4603      	mov	r3, r0
    41f2:	f88d 301f 	strb.w	r3, [sp, #31]
        }
        while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    41f6:	9b06      	ldr	r3, [sp, #24]
    41f8:	2b00      	cmp	r3, #0
    41fa:	d106      	bne.n	420a <Clock_Ip_EnableFirc_TrustedCall+0x66>
    41fc:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4200:	f083 0301 	eor.w	r3, r3, #1
    4204:	b2db      	uxtb	r3, r3
    4206:	2b00      	cmp	r3, #0
    4208:	d1e5      	bne.n	41d6 <Clock_Ip_EnableFirc_TrustedCall+0x32>

        if (FALSE != TimeoutOccurred)
    420a:	f89d 301f 	ldrb.w	r3, [sp, #31]
    420e:	2b00      	cmp	r3, #0
    4210:	d005      	beq.n	421e <Clock_Ip_EnableFirc_TrustedCall+0x7a>
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    4212:	9b01      	ldr	r3, [sp, #4]
    4214:	681b      	ldr	r3, [r3, #0]
    4216:	4619      	mov	r1, r3
    4218:	2001      	movs	r0, #1
    421a:	f7fe fe9d 	bl	2f58 <Clock_Ip_ReportClockErrors>
        }
    }
}
    421e:	bf00      	nop
    4220:	b009      	add	sp, #36	; 0x24
    4222:	f85d fb04 	ldr.w	pc, [sp], #4
    4226:	bf00      	nop
    4228:	40064000 	.word	0x40064000

0000422c <Clock_Ip_DisableFirc_TrustedCall>:
void Clock_Ip_DisableFirc_TrustedCall(Clock_Ip_NameType Name)
{
    422c:	b082      	sub	sp, #8
    422e:	9001      	str	r0, [sp, #4]
    (void) Name;

    /* Disable clock. */
    IP_SCG->FIRCCSR &= ~SCG_FIRCCSR_FIRCEN_MASK;
    4230:	4b05      	ldr	r3, [pc, #20]	; (4248 <Clock_Ip_DisableFirc_TrustedCall+0x1c>)
    4232:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4236:	4a04      	ldr	r2, [pc, #16]	; (4248 <Clock_Ip_DisableFirc_TrustedCall+0x1c>)
    4238:	f023 0301 	bic.w	r3, r3, #1
    423c:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
}
    4240:	bf00      	nop
    4242:	b002      	add	sp, #8
    4244:	4770      	bx	lr
    4246:	bf00      	nop
    4248:	40064000 	.word	0x40064000

0000424c <Clock_Ip_ClockMonitorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_ClockMonitorEmpty(Clock_Ip_CmuConfigType const* Config)
{
    424c:	b082      	sub	sp, #8
    424e:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    4250:	bf00      	nop
    4252:	b002      	add	sp, #8
    4254:	4770      	bx	lr

00004256 <Clock_Ip_ClockMonitorEmpty_Set>:

static void Clock_Ip_ClockMonitorEmpty_Set( Clock_Ip_CmuConfigType const* Config,
                                            uint32 Index
                                           )
{
    4256:	b082      	sub	sp, #8
    4258:	9001      	str	r0, [sp, #4]
    425a:	9100      	str	r1, [sp, #0]
    (void)Config;
    (void)Index;
    /* No implementation */
}
    425c:	bf00      	nop
    425e:	b002      	add	sp, #8
    4260:	4770      	bx	lr

00004262 <Clock_Ip_ClockMonitorEmpty_Disable>:

static void Clock_Ip_ClockMonitorEmpty_Disable(Clock_Ip_NameType Name)
{
    4262:	b082      	sub	sp, #8
    4264:	9001      	str	r0, [sp, #4]
    (void)Name;
    /* No implementation */
}
    4266:	bf00      	nop
    4268:	b002      	add	sp, #8
    426a:	4770      	bx	lr

0000426c <Clock_Ip_CallbackPllEmpty>:

#include "Mcu_MemMap.h"


static void Clock_Ip_CallbackPllEmpty(Clock_Ip_PllConfigType const* Config)
{
    426c:	b082      	sub	sp, #8
    426e:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    4270:	bf00      	nop
    4272:	b002      	add	sp, #8
    4274:	4770      	bx	lr

00004276 <Clock_Ip_CallbackPllEmptyComplete>:
static Clock_Ip_PllStatusReturnType Clock_Ip_CallbackPllEmptyComplete(Clock_Ip_NameType PllName)
{
    4276:	b082      	sub	sp, #8
    4278:	9001      	str	r0, [sp, #4]
    (void)PllName;
    /* No implementation */
    return STATUS_PLL_LOCKED;
    427a:	2302      	movs	r3, #2
}
    427c:	4618      	mov	r0, r3
    427e:	b002      	add	sp, #8
    4280:	4770      	bx	lr

00004282 <Clock_Ip_CallbackPllEmptyDisable>:
static void Clock_Ip_CallbackPllEmptyDisable(Clock_Ip_NameType PllName)
{
    4282:	b082      	sub	sp, #8
    4284:	9001      	str	r0, [sp, #4]
    (void)PllName;
    /* No implementation */
}
    4286:	bf00      	nop
    4288:	b002      	add	sp, #8
    428a:	4770      	bx	lr

0000428c <Clock_Ip_ResetSpll>:


#ifdef CLOCK_IP_SPLL_ENABLE
static void Clock_Ip_ResetSpll(Clock_Ip_PllConfigType const* Config)
{
    428c:	b500      	push	{lr}
    428e:	b083      	sub	sp, #12
    4290:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4292:	9b01      	ldr	r3, [sp, #4]
    4294:	2b00      	cmp	r3, #0
    4296:	d002      	beq.n	429e <Clock_Ip_ResetSpll+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSpll_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSpll_TrustedCall(Config);
    4298:	9801      	ldr	r0, [sp, #4]
    429a:	f000 f870 	bl	437e <Clock_Ip_ResetSpll_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    429e:	bf00      	nop
    42a0:	b003      	add	sp, #12
    42a2:	f85d fb04 	ldr.w	pc, [sp], #4

000042a6 <Clock_Ip_SetSpll>:
static void Clock_Ip_SetSpll(Clock_Ip_PllConfigType const* Config)
{
    42a6:	b500      	push	{lr}
    42a8:	b083      	sub	sp, #12
    42aa:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    42ac:	9b01      	ldr	r3, [sp, #4]
    42ae:	2b00      	cmp	r3, #0
    42b0:	d002      	beq.n	42b8 <Clock_Ip_SetSpll+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSpll_TrustedCall,(Config));
      #else
        Clock_Ip_SetSpll_TrustedCall(Config);
    42b2:	9801      	ldr	r0, [sp, #4]
    42b4:	f000 f89a 	bl	43ec <Clock_Ip_SetSpll_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    42b8:	bf00      	nop
    42ba:	b003      	add	sp, #12
    42bc:	f85d fb04 	ldr.w	pc, [sp], #4

000042c0 <Clock_Ip_CompleteSpll>:
static Clock_Ip_PllStatusReturnType Clock_Ip_CompleteSpll(Clock_Ip_NameType PllName)
{
    42c0:	b500      	push	{lr}
    42c2:	b089      	sub	sp, #36	; 0x24
    42c4:	9001      	str	r0, [sp, #4]
    Clock_Ip_PllStatusReturnType PllStatus = STATUS_PLL_UNLOCKED;
    42c6:	2301      	movs	r3, #1
    42c8:	9307      	str	r3, [sp, #28]
    boolean TimeoutOccurred = FALSE;
    42ca:	2300      	movs	r3, #0
    42cc:	f88d 301b 	strb.w	r3, [sp, #27]
    uint32 TimeoutTicks;
    uint32 SpllStatus;


    /* Configure SPLL. */
    if ((IP_SCG->SPLLCSR & SCG_SPLLCSR_SPLLEN_MASK) != 0U)
    42d0:	4b1e      	ldr	r3, [pc, #120]	; (434c <Clock_Ip_CompleteSpll+0x8c>)
    42d2:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    42d6:	f003 0301 	and.w	r3, r3, #1
    42da:	2b00      	cmp	r3, #0
    42dc:	d02f      	beq.n	433e <Clock_Ip_CompleteSpll+0x7e>
    {
        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    42de:	aa02      	add	r2, sp, #8
    42e0:	a903      	add	r1, sp, #12
    42e2:	a804      	add	r0, sp, #16
    42e4:	f24c 3350 	movw	r3, #50000	; 0xc350
    42e8:	f7fe fe46 	bl	2f78 <Clock_Ip_StartTimeout>
        /* Wait until pll is locked */
        do
        {
            SpllStatus = (((IP_SCG->SPLLCSR & SCG_SPLLCSR_SPLLVLD_MASK) >> SCG_SPLLCSR_SPLLVLD_SHIFT));
    42ec:	4b17      	ldr	r3, [pc, #92]	; (434c <Clock_Ip_CompleteSpll+0x8c>)
    42ee:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    42f2:	0e1b      	lsrs	r3, r3, #24
    42f4:	f003 0301 	and.w	r3, r3, #1
    42f8:	9305      	str	r3, [sp, #20]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    42fa:	9a02      	ldr	r2, [sp, #8]
    42fc:	a903      	add	r1, sp, #12
    42fe:	ab04      	add	r3, sp, #16
    4300:	4618      	mov	r0, r3
    4302:	f7fe fe53 	bl	2fac <Clock_Ip_TimeoutExpired>
    4306:	4603      	mov	r3, r0
    4308:	f88d 301b 	strb.w	r3, [sp, #27]
        }
        while ((0U == SpllStatus) && (FALSE == TimeoutOccurred));
    430c:	9b05      	ldr	r3, [sp, #20]
    430e:	2b00      	cmp	r3, #0
    4310:	d106      	bne.n	4320 <Clock_Ip_CompleteSpll+0x60>
    4312:	f89d 301b 	ldrb.w	r3, [sp, #27]
    4316:	f083 0301 	eor.w	r3, r3, #1
    431a:	b2db      	uxtb	r3, r3
    431c:	2b00      	cmp	r3, #0
    431e:	d1e5      	bne.n	42ec <Clock_Ip_CompleteSpll+0x2c>

        if (FALSE == TimeoutOccurred)
    4320:	f89d 301b 	ldrb.w	r3, [sp, #27]
    4324:	f083 0301 	eor.w	r3, r3, #1
    4328:	b2db      	uxtb	r3, r3
    432a:	2b00      	cmp	r3, #0
    432c:	d002      	beq.n	4334 <Clock_Ip_CompleteSpll+0x74>
        {
            PllStatus = STATUS_PLL_LOCKED;
    432e:	2302      	movs	r3, #2
    4330:	9307      	str	r3, [sp, #28]
    4332:	e006      	b.n	4342 <Clock_Ip_CompleteSpll+0x82>
        }
        else
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, PllName);
    4334:	9901      	ldr	r1, [sp, #4]
    4336:	2001      	movs	r0, #1
    4338:	f7fe fe0e 	bl	2f58 <Clock_Ip_ReportClockErrors>
    433c:	e001      	b.n	4342 <Clock_Ip_CompleteSpll+0x82>
        }
    }
    else
    {
        PllStatus = STATUS_PLL_NOT_ENABLED;
    433e:	2300      	movs	r3, #0
    4340:	9307      	str	r3, [sp, #28]
    }
    
    return PllStatus;
    4342:	9b07      	ldr	r3, [sp, #28]
}
    4344:	4618      	mov	r0, r3
    4346:	b009      	add	sp, #36	; 0x24
    4348:	f85d fb04 	ldr.w	pc, [sp], #4
    434c:	40064000 	.word	0x40064000

00004350 <Clock_Ip_DisableSpll>:
static void Clock_Ip_DisableSpll(Clock_Ip_NameType PllName)
{
    4350:	b500      	push	{lr}
    4352:	b083      	sub	sp, #12
    4354:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSpll_TrustedCall,(PllName));
  #else
    Clock_Ip_DisableSpll_TrustedCall(PllName);
    4356:	9801      	ldr	r0, [sp, #4]
    4358:	f000 f886 	bl	4468 <Clock_Ip_DisableSpll_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    435c:	bf00      	nop
    435e:	b003      	add	sp, #12
    4360:	f85d fb04 	ldr.w	pc, [sp], #4

00004364 <Clock_Ip_EnableSpll>:
static void Clock_Ip_EnableSpll(Clock_Ip_PllConfigType const* Config)
{
    4364:	b500      	push	{lr}
    4366:	b083      	sub	sp, #12
    4368:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    436a:	9b01      	ldr	r3, [sp, #4]
    436c:	2b00      	cmp	r3, #0
    436e:	d002      	beq.n	4376 <Clock_Ip_EnableSpll+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSpll_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSpll_TrustedCall(Config);
    4370:	9801      	ldr	r0, [sp, #4]
    4372:	f000 f891 	bl	4498 <Clock_Ip_EnableSpll_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4376:	bf00      	nop
    4378:	b003      	add	sp, #12
    437a:	f85d fb04 	ldr.w	pc, [sp], #4

0000437e <Clock_Ip_ResetSpll_TrustedCall>:
*                                        GLOBAL FUNCTIONS
==================================================================================================*/

#ifdef CLOCK_IP_SPLL_ENABLE
void Clock_Ip_ResetSpll_TrustedCall(Clock_Ip_PllConfigType const* Config)
{
    437e:	b082      	sub	sp, #8
    4380:	9001      	str	r0, [sp, #4]
    (void)Config;

    /* Power down PLL */

    /* Clear LK bit field */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_LK_MASK));
    4382:	4b19      	ldr	r3, [pc, #100]	; (43e8 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    4384:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    4388:	4a17      	ldr	r2, [pc, #92]	; (43e8 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    438a:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    438e:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock monitor */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLCM_MASK));
    4392:	4b15      	ldr	r3, [pc, #84]	; (43e8 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    4394:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    4398:	4a13      	ldr	r2, [pc, #76]	; (43e8 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    439a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    439e:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock monitor reset*/
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLCMRE_MASK));
    43a2:	4b11      	ldr	r3, [pc, #68]	; (43e8 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    43a4:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    43a8:	4a0f      	ldr	r2, [pc, #60]	; (43e8 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    43aa:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    43ae:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLEN_MASK));
    43b2:	4b0d      	ldr	r3, [pc, #52]	; (43e8 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    43b4:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    43b8:	4a0b      	ldr	r2, [pc, #44]	; (43e8 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    43ba:	f023 0301 	bic.w	r3, r3, #1
    43be:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Reset PLL configuration. */
    #if (defined (CLOCK_IP_S32K142W) || defined(CLOCK_IP_S32K144W) || defined(CLOCK_IP_S32M244))
    IP_SCG->SPLLCFG &= (~((uint32)SCG_SPLLCFG_SOURCE_MASK));
    #endif
    IP_SCG->SPLLCFG &= (~((uint32)SCG_SPLLCFG_PREDIV_MASK));
    43c2:	4b09      	ldr	r3, [pc, #36]	; (43e8 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    43c4:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    43c8:	4a07      	ldr	r2, [pc, #28]	; (43e8 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    43ca:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    43ce:	f8c2 3608 	str.w	r3, [r2, #1544]	; 0x608
    IP_SCG->SPLLCFG &= (~((uint32)SCG_SPLLCFG_MULT_MASK));
    43d2:	4b05      	ldr	r3, [pc, #20]	; (43e8 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    43d4:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    43d8:	4a03      	ldr	r2, [pc, #12]	; (43e8 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    43da:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
    43de:	f8c2 3608 	str.w	r3, [r2, #1544]	; 0x608
}
    43e2:	bf00      	nop
    43e4:	b002      	add	sp, #8
    43e6:	4770      	bx	lr
    43e8:	40064000 	.word	0x40064000

000043ec <Clock_Ip_SetSpll_TrustedCall>:
void Clock_Ip_SetSpll_TrustedCall(Clock_Ip_PllConfigType const* Config)
{
    43ec:	b082      	sub	sp, #8
    43ee:	9001      	str	r0, [sp, #4]
    /* Configure SPLL. */
    if (1U == Config->Enable)
    43f0:	9b01      	ldr	r3, [sp, #4]
    43f2:	889b      	ldrh	r3, [r3, #4]
    43f4:	2b01      	cmp	r3, #1
    43f6:	d12f      	bne.n	4458 <Clock_Ip_SetSpll_TrustedCall+0x6c>
            IP_SCG->SPLLCFG |= SCG_SPLLCFG_SOURCE(1UL);
        }
        #endif

        /* Set PLL configuration. */
        IP_SCG->SPLLCFG |= SCG_SPLLCFG_PREDIV((uint32)(Config->Predivider) - 1U)  |
    43f8:	4b1a      	ldr	r3, [pc, #104]	; (4464 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    43fa:	f8d3 2608 	ldr.w	r2, [r3, #1544]	; 0x608
    43fe:	9b01      	ldr	r3, [sp, #4]
    4400:	7b5b      	ldrb	r3, [r3, #13]
    4402:	3b01      	subs	r3, #1
    4404:	021b      	lsls	r3, r3, #8
    4406:	f403 61e0 	and.w	r1, r3, #1792	; 0x700
                        SCG_SPLLCFG_MULT((uint32)(Config->MulFactorDiv) - 16U);
    440a:	9b01      	ldr	r3, [sp, #4]
    440c:	7d1b      	ldrb	r3, [r3, #20]
    440e:	3b10      	subs	r3, #16
    4410:	041b      	lsls	r3, r3, #16
    4412:	f403 13f8 	and.w	r3, r3, #2031616	; 0x1f0000
        IP_SCG->SPLLCFG |= SCG_SPLLCFG_PREDIV((uint32)(Config->Predivider) - 1U)  |
    4416:	430b      	orrs	r3, r1
    4418:	4912      	ldr	r1, [pc, #72]	; (4464 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    441a:	4313      	orrs	r3, r2
    441c:	f8c1 3608 	str.w	r3, [r1, #1544]	; 0x608

        /* Enable clock, configure monitor, lock register. */
        switch (Config->Monitor)
    4420:	9b01      	ldr	r3, [sp, #4]
    4422:	7fdb      	ldrb	r3, [r3, #31]
    4424:	2b02      	cmp	r3, #2
    4426:	d011      	beq.n	444c <Clock_Ip_SetSpll_TrustedCall+0x60>
    4428:	2b02      	cmp	r3, #2
    442a:	dc17      	bgt.n	445c <Clock_Ip_SetSpll_TrustedCall+0x70>
    442c:	2b00      	cmp	r3, #0
    442e:	d002      	beq.n	4436 <Clock_Ip_SetSpll_TrustedCall+0x4a>
    4430:	2b01      	cmp	r3, #1
    4432:	d005      	beq.n	4440 <Clock_Ip_SetSpll_TrustedCall+0x54>
            break;
#endif
            default:
                /* Invalid monitor mode */
                CLOCK_IP_DEV_ASSERT(FALSE);
                break;
    4434:	e012      	b.n	445c <Clock_Ip_SetSpll_TrustedCall+0x70>
                IP_SCG->SPLLCSR = SCG_SPLLCSR_SPLLCM(0UL) |
    4436:	4b0b      	ldr	r3, [pc, #44]	; (4464 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    4438:	2200      	movs	r2, #0
    443a:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
            break;
    443e:	e00e      	b.n	445e <Clock_Ip_SetSpll_TrustedCall+0x72>
                IP_SCG->SPLLCSR = SCG_SPLLCSR_SPLLCM(1UL) |
    4440:	4b08      	ldr	r3, [pc, #32]	; (4464 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    4442:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    4446:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
            break;
    444a:	e008      	b.n	445e <Clock_Ip_SetSpll_TrustedCall+0x72>
                IP_SCG->SPLLCSR = SCG_SPLLCSR_SPLLCM(1UL) |
    444c:	4b05      	ldr	r3, [pc, #20]	; (4464 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    444e:	f44f 3240 	mov.w	r2, #196608	; 0x30000
    4452:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
            break;
    4456:	e002      	b.n	445e <Clock_Ip_SetSpll_TrustedCall+0x72>
        }
    }
    4458:	bf00      	nop
    445a:	e000      	b.n	445e <Clock_Ip_SetSpll_TrustedCall+0x72>
                break;
    445c:	bf00      	nop
}
    445e:	bf00      	nop
    4460:	b002      	add	sp, #8
    4462:	4770      	bx	lr
    4464:	40064000 	.word	0x40064000

00004468 <Clock_Ip_DisableSpll_TrustedCall>:
void Clock_Ip_DisableSpll_TrustedCall(Clock_Ip_NameType PllName)
{
    4468:	b082      	sub	sp, #8
    446a:	9001      	str	r0, [sp, #4]
    (void)PllName;

    /* Power down PLL */

    /* Clear LK bit field */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_LK_MASK));
    446c:	4b09      	ldr	r3, [pc, #36]	; (4494 <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    446e:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    4472:	4a08      	ldr	r2, [pc, #32]	; (4494 <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    4474:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    4478:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLEN_MASK));
    447c:	4b05      	ldr	r3, [pc, #20]	; (4494 <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    447e:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    4482:	4a04      	ldr	r2, [pc, #16]	; (4494 <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    4484:	f023 0301 	bic.w	r3, r3, #1
    4488:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600
}
    448c:	bf00      	nop
    448e:	b002      	add	sp, #8
    4490:	4770      	bx	lr
    4492:	bf00      	nop
    4494:	40064000 	.word	0x40064000

00004498 <Clock_Ip_EnableSpll_TrustedCall>:
void Clock_Ip_EnableSpll_TrustedCall(Clock_Ip_PllConfigType const* Config)
{
    4498:	b082      	sub	sp, #8
    449a:	9001      	str	r0, [sp, #4]
    /* Configure SPLL. */
    if (1U == Config->Enable)
    449c:	9b01      	ldr	r3, [sp, #4]
    449e:	889b      	ldrh	r3, [r3, #4]
    44a0:	2b01      	cmp	r3, #1
    44a2:	d107      	bne.n	44b4 <Clock_Ip_EnableSpll_TrustedCall+0x1c>
    {
        /* Enable SPLL */
        IP_SCG->SPLLCSR |= SCG_SPLLCSR_SPLLEN(1UL);
    44a4:	4b05      	ldr	r3, [pc, #20]	; (44bc <Clock_Ip_EnableSpll_TrustedCall+0x24>)
    44a6:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    44aa:	4a04      	ldr	r2, [pc, #16]	; (44bc <Clock_Ip_EnableSpll_TrustedCall+0x24>)
    44ac:	f043 0301 	orr.w	r3, r3, #1
    44b0:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600
    }
}
    44b4:	bf00      	nop
    44b6:	b002      	add	sp, #8
    44b8:	4770      	bx	lr
    44ba:	bf00      	nop
    44bc:	40064000 	.word	0x40064000

000044c0 <Clock_Ip_ProgressiveFrequencyClockSwitchEmpty>:
#include "Mcu_MemMap.h"

static void Clock_Ip_ProgressiveFrequencyClockSwitchEmpty(  Clock_Ip_PcfsConfigType const* Config,
                                                            uint32 Index
                                                          )
{
    44c0:	b082      	sub	sp, #8
    44c2:	9001      	str	r0, [sp, #4]
    44c4:	9100      	str	r1, [sp, #0]
    (void)Config;
    (void)Index;
    /* No implementation */
}
    44c6:	bf00      	nop
    44c8:	b002      	add	sp, #8
    44ca:	4770      	bx	lr

000044cc <Clock_Ip_CallbackSelectorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_CallbackSelectorEmpty(Clock_Ip_SelectorConfigType const* Config)
{
    44cc:	b082      	sub	sp, #8
    44ce:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    44d0:	bf00      	nop
    44d2:	b002      	add	sp, #8
    44d4:	4770      	bx	lr

000044d6 <Clock_Ip_ResetScgRunSel>:

#ifdef CLOCK_IP_SCG_SCS_RUN_SEL
static void Clock_Ip_ResetScgRunSel(Clock_Ip_SelectorConfigType const *Config)
{
    44d6:	b500      	push	{lr}
    44d8:	b083      	sub	sp, #12
    44da:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    44dc:	9b01      	ldr	r3, [sp, #4]
    44de:	2b00      	cmp	r3, #0
    44e0:	d002      	beq.n	44e8 <Clock_Ip_ResetScgRunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetScgRunSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetScgRunSel_TrustedCall(Config);
    44e2:	9801      	ldr	r0, [sp, #4]
    44e4:	f000 f8ee 	bl	46c4 <Clock_Ip_ResetScgRunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    44e8:	bf00      	nop
    44ea:	b003      	add	sp, #12
    44ec:	f85d fb04 	ldr.w	pc, [sp], #4

000044f0 <Clock_Ip_SetScgRunSel>:

static void Clock_Ip_SetScgRunSel(Clock_Ip_SelectorConfigType const *Config)
{
    44f0:	b500      	push	{lr}
    44f2:	b083      	sub	sp, #12
    44f4:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    44f6:	9b01      	ldr	r3, [sp, #4]
    44f8:	2b00      	cmp	r3, #0
    44fa:	d002      	beq.n	4502 <Clock_Ip_SetScgRunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunSel_TrustedCall(Config);
    44fc:	9801      	ldr	r0, [sp, #4]
    44fe:	f000 f8ff 	bl	4700 <Clock_Ip_SetScgRunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4502:	bf00      	nop
    4504:	b003      	add	sp, #12
    4506:	f85d fb04 	ldr.w	pc, [sp], #4

0000450a <Clock_Ip_SetScgVlprSel>:

#endif

#ifdef CLOCK_IP_SCG_SCS_VLPR_SEL
static void Clock_Ip_SetScgVlprSel(Clock_Ip_SelectorConfigType const *Config)
{
    450a:	b500      	push	{lr}
    450c:	b083      	sub	sp, #12
    450e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4510:	9b01      	ldr	r3, [sp, #4]
    4512:	2b00      	cmp	r3, #0
    4514:	d002      	beq.n	451c <Clock_Ip_SetScgVlprSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprSel_TrustedCall(Config);
    4516:	9801      	ldr	r0, [sp, #4]
    4518:	f000 f912 	bl	4740 <Clock_Ip_SetScgVlprSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    451c:	bf00      	nop
    451e:	b003      	add	sp, #12
    4520:	f85d fb04 	ldr.w	pc, [sp], #4

00004524 <Clock_Ip_ResetScgHsrunSel>:

#endif

#ifdef CLOCK_IP_SCG_SCS_HSRUN_SEL
static void Clock_Ip_ResetScgHsrunSel(Clock_Ip_SelectorConfigType const *Config)
{
    4524:	b500      	push	{lr}
    4526:	b083      	sub	sp, #12
    4528:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    452a:	9b01      	ldr	r3, [sp, #4]
    452c:	2b00      	cmp	r3, #0
    452e:	d002      	beq.n	4536 <Clock_Ip_ResetScgHsrunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetScgHsrunSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetScgHsrunSel_TrustedCall(Config);
    4530:	9801      	ldr	r0, [sp, #4]
    4532:	f000 f925 	bl	4780 <Clock_Ip_ResetScgHsrunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4536:	bf00      	nop
    4538:	b003      	add	sp, #12
    453a:	f85d fb04 	ldr.w	pc, [sp], #4

0000453e <Clock_Ip_SetScgHsrunSel>:
static void Clock_Ip_SetScgHsrunSel(Clock_Ip_SelectorConfigType const *Config)
{
    453e:	b500      	push	{lr}
    4540:	b083      	sub	sp, #12
    4542:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4544:	9b01      	ldr	r3, [sp, #4]
    4546:	2b00      	cmp	r3, #0
    4548:	d002      	beq.n	4550 <Clock_Ip_SetScgHsrunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunSel_TrustedCall(Config);
    454a:	9801      	ldr	r0, [sp, #4]
    454c:	f000 f936 	bl	47bc <Clock_Ip_SetScgHsrunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4550:	bf00      	nop
    4552:	b003      	add	sp, #12
    4554:	f85d fb04 	ldr.w	pc, [sp], #4

00004558 <Clock_Ip_ResetSimRtcSel>:
#endif

#ifdef CLOCK_IP_SIM_RTC_SEL
static void Clock_Ip_ResetSimRtcSel(Clock_Ip_SelectorConfigType const *Config)
{
    4558:	b500      	push	{lr}
    455a:	b083      	sub	sp, #12
    455c:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    455e:	9b01      	ldr	r3, [sp, #4]
    4560:	2b00      	cmp	r3, #0
    4562:	d002      	beq.n	456a <Clock_Ip_ResetSimRtcSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimRtcSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimRtcSel_TrustedCall(Config);
    4564:	9801      	ldr	r0, [sp, #4]
    4566:	f000 f949 	bl	47fc <Clock_Ip_ResetSimRtcSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    456a:	bf00      	nop
    456c:	b003      	add	sp, #12
    456e:	f85d fb04 	ldr.w	pc, [sp], #4

00004572 <Clock_Ip_SetSimRtcSel>:
static void Clock_Ip_SetSimRtcSel(Clock_Ip_SelectorConfigType const *Config)
{
    4572:	b500      	push	{lr}
    4574:	b083      	sub	sp, #12
    4576:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4578:	9b01      	ldr	r3, [sp, #4]
    457a:	2b00      	cmp	r3, #0
    457c:	d002      	beq.n	4584 <Clock_Ip_SetSimRtcSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimRtcSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimRtcSel_TrustedCall(Config);
    457e:	9801      	ldr	r0, [sp, #4]
    4580:	f000 f958 	bl	4834 <Clock_Ip_SetSimRtcSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4584:	bf00      	nop
    4586:	b003      	add	sp, #12
    4588:	f85d fb04 	ldr.w	pc, [sp], #4

0000458c <Clock_Ip_ResetSimLpoSel>:
#endif

#ifdef CLOCK_IP_SIM_LPO_SEL
static void Clock_Ip_ResetSimLpoSel(Clock_Ip_SelectorConfigType const *Config)
{
    458c:	b500      	push	{lr}
    458e:	b083      	sub	sp, #12
    4590:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4592:	9b01      	ldr	r3, [sp, #4]
    4594:	2b00      	cmp	r3, #0
    4596:	d002      	beq.n	459e <Clock_Ip_ResetSimLpoSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimLpoSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimLpoSel_TrustedCall(Config);
    4598:	9801      	ldr	r0, [sp, #4]
    459a:	f000 f969 	bl	4870 <Clock_Ip_ResetSimLpoSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    459e:	bf00      	nop
    45a0:	b003      	add	sp, #12
    45a2:	f85d fb04 	ldr.w	pc, [sp], #4

000045a6 <Clock_Ip_SetSimLpoSel>:
static void Clock_Ip_SetSimLpoSel(Clock_Ip_SelectorConfigType const *Config)
{
    45a6:	b500      	push	{lr}
    45a8:	b083      	sub	sp, #12
    45aa:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    45ac:	9b01      	ldr	r3, [sp, #4]
    45ae:	2b00      	cmp	r3, #0
    45b0:	d002      	beq.n	45b8 <Clock_Ip_SetSimLpoSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimLpoSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimLpoSel_TrustedCall(Config);
    45b2:	9801      	ldr	r0, [sp, #4]
    45b4:	f000 f978 	bl	48a8 <Clock_Ip_SetSimLpoSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    45b8:	bf00      	nop
    45ba:	b003      	add	sp, #12
    45bc:	f85d fb04 	ldr.w	pc, [sp], #4

000045c0 <Clock_Ip_ResetScgClkoutSel>:
#endif

#ifdef CLOCK_IP_SCG_CLKOUT_SEL
static void Clock_Ip_ResetScgClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    45c0:	b500      	push	{lr}
    45c2:	b083      	sub	sp, #12
    45c4:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    45c6:	9b01      	ldr	r3, [sp, #4]
    45c8:	2b00      	cmp	r3, #0
    45ca:	d002      	beq.n	45d2 <Clock_Ip_ResetScgClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetScgClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetScgClkoutSel_TrustedCall(Config);
    45cc:	9801      	ldr	r0, [sp, #4]
    45ce:	f000 f989 	bl	48e4 <Clock_Ip_ResetScgClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    45d2:	bf00      	nop
    45d4:	b003      	add	sp, #12
    45d6:	f85d fb04 	ldr.w	pc, [sp], #4

000045da <Clock_Ip_SetScgClkoutSel>:
static void Clock_Ip_SetScgClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    45da:	b500      	push	{lr}
    45dc:	b083      	sub	sp, #12
    45de:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    45e0:	9b01      	ldr	r3, [sp, #4]
    45e2:	2b00      	cmp	r3, #0
    45e4:	d002      	beq.n	45ec <Clock_Ip_SetScgClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgClkoutSel_TrustedCall(Config);
    45e6:	9801      	ldr	r0, [sp, #4]
    45e8:	f000 f998 	bl	491c <Clock_Ip_SetScgClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    45ec:	bf00      	nop
    45ee:	b003      	add	sp, #12
    45f0:	f85d fb04 	ldr.w	pc, [sp], #4

000045f4 <Clock_Ip_ResetSimFtmoptSel>:
#endif

#ifdef CLOCK_IP_SIM_FTMOPT_SEL
static void Clock_Ip_ResetSimFtmoptSel(Clock_Ip_SelectorConfigType const *Config)
{
    45f4:	b500      	push	{lr}
    45f6:	b083      	sub	sp, #12
    45f8:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    45fa:	9b01      	ldr	r3, [sp, #4]
    45fc:	2b00      	cmp	r3, #0
    45fe:	d002      	beq.n	4606 <Clock_Ip_ResetSimFtmoptSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimFtmoptSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimFtmoptSel_TrustedCall(Config);
    4600:	9801      	ldr	r0, [sp, #4]
    4602:	f000 f9a9 	bl	4958 <Clock_Ip_ResetSimFtmoptSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4606:	bf00      	nop
    4608:	b003      	add	sp, #12
    460a:	f85d fb04 	ldr.w	pc, [sp], #4

0000460e <Clock_Ip_SetSimFtmoptSel>:
static void Clock_Ip_SetSimFtmoptSel(Clock_Ip_SelectorConfigType const *Config)
{
    460e:	b500      	push	{lr}
    4610:	b083      	sub	sp, #12
    4612:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4614:	9b01      	ldr	r3, [sp, #4]
    4616:	2b00      	cmp	r3, #0
    4618:	d002      	beq.n	4620 <Clock_Ip_SetSimFtmoptSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimFtmoptSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimFtmoptSel_TrustedCall(Config);
    461a:	9801      	ldr	r0, [sp, #4]
    461c:	f000 f9e6 	bl	49ec <Clock_Ip_SetSimFtmoptSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4620:	bf00      	nop
    4622:	b003      	add	sp, #12
    4624:	f85d fb04 	ldr.w	pc, [sp], #4

00004628 <Clock_Ip_ResetSimClkoutSel>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_SEL
static void Clock_Ip_ResetSimClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    4628:	b500      	push	{lr}
    462a:	b083      	sub	sp, #12
    462c:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    462e:	9b01      	ldr	r3, [sp, #4]
    4630:	2b00      	cmp	r3, #0
    4632:	d002      	beq.n	463a <Clock_Ip_ResetSimClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimClkoutSel_TrustedCall(Config);
    4634:	9801      	ldr	r0, [sp, #4]
    4636:	f000 fa25 	bl	4a84 <Clock_Ip_ResetSimClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    463a:	bf00      	nop
    463c:	b003      	add	sp, #12
    463e:	f85d fb04 	ldr.w	pc, [sp], #4

00004642 <Clock_Ip_SetSimClkoutSel>:
static void Clock_Ip_SetSimClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    4642:	b500      	push	{lr}
    4644:	b083      	sub	sp, #12
    4646:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4648:	9b01      	ldr	r3, [sp, #4]
    464a:	2b00      	cmp	r3, #0
    464c:	d002      	beq.n	4654 <Clock_Ip_SetSimClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimClkoutSel_TrustedCall(Config);
    464e:	9801      	ldr	r0, [sp, #4]
    4650:	f000 fa2a 	bl	4aa8 <Clock_Ip_SetSimClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4654:	bf00      	nop
    4656:	b003      	add	sp, #12
    4658:	f85d fb04 	ldr.w	pc, [sp], #4

0000465c <Clock_Ip_ResetPccPcsSelect>:
#endif

#ifdef CLOCK_IP_PCC_PCS_SELECT
static void Clock_Ip_ResetPccPcsSelect(Clock_Ip_SelectorConfigType const *Config)
{
    465c:	b500      	push	{lr}
    465e:	b083      	sub	sp, #12
    4660:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4662:	9b01      	ldr	r3, [sp, #4]
    4664:	2b00      	cmp	r3, #0
    4666:	d002      	beq.n	466e <Clock_Ip_ResetPccPcsSelect+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetPccPcsSelect_TrustedCall,(Config));
      #else
        Clock_Ip_ResetPccPcsSelect_TrustedCall(Config);
    4668:	9801      	ldr	r0, [sp, #4]
    466a:	f000 fa3b 	bl	4ae4 <Clock_Ip_ResetPccPcsSelect_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    466e:	bf00      	nop
    4670:	b003      	add	sp, #12
    4672:	f85d fb04 	ldr.w	pc, [sp], #4

00004676 <Clock_Ip_SetPccPcsSelect>:
static void Clock_Ip_SetPccPcsSelect(Clock_Ip_SelectorConfigType const *Config)
{
    4676:	b500      	push	{lr}
    4678:	b083      	sub	sp, #12
    467a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    467c:	9b01      	ldr	r3, [sp, #4]
    467e:	2b00      	cmp	r3, #0
    4680:	d002      	beq.n	4688 <Clock_Ip_SetPccPcsSelect+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetPccPcsSelect_TrustedCall,(Config));
      #else
        Clock_Ip_SetPccPcsSelect_TrustedCall(Config);
    4682:	9801      	ldr	r0, [sp, #4]
    4684:	f000 fa56 	bl	4b34 <Clock_Ip_SetPccPcsSelect_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4688:	bf00      	nop
    468a:	b003      	add	sp, #12
    468c:	f85d fb04 	ldr.w	pc, [sp], #4

00004690 <Clock_Ip_ResetSimTraceSel>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_SEL
static void Clock_Ip_ResetSimTraceSel(Clock_Ip_SelectorConfigType const *Config)
{
    4690:	b500      	push	{lr}
    4692:	b083      	sub	sp, #12
    4694:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4696:	9b01      	ldr	r3, [sp, #4]
    4698:	2b00      	cmp	r3, #0
    469a:	d002      	beq.n	46a2 <Clock_Ip_ResetSimTraceSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimTraceSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimTraceSel_TrustedCall(Config);
    469c:	9801      	ldr	r0, [sp, #4]
    469e:	f000 fa79 	bl	4b94 <Clock_Ip_ResetSimTraceSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    46a2:	bf00      	nop
    46a4:	b003      	add	sp, #12
    46a6:	f85d fb04 	ldr.w	pc, [sp], #4

000046aa <Clock_Ip_SetSimTraceSel>:
static void Clock_Ip_SetSimTraceSel(Clock_Ip_SelectorConfigType const *Config)
{
    46aa:	b500      	push	{lr}
    46ac:	b083      	sub	sp, #12
    46ae:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    46b0:	9b01      	ldr	r3, [sp, #4]
    46b2:	2b00      	cmp	r3, #0
    46b4:	d002      	beq.n	46bc <Clock_Ip_SetSimTraceSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimTraceSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimTraceSel_TrustedCall(Config);
    46b6:	9801      	ldr	r0, [sp, #4]
    46b8:	f000 fa8a 	bl	4bd0 <Clock_Ip_SetSimTraceSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    46bc:	bf00      	nop
    46be:	b003      	add	sp, #12
    46c0:	f85d fb04 	ldr.w	pc, [sp], #4

000046c4 <Clock_Ip_ResetScgRunSel_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SCG_SCS_RUN_SEL
void Clock_Ip_ResetScgRunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    46c4:	b084      	sub	sp, #16
    46c6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    46c8:	4b0b      	ldr	r3, [pc, #44]	; (46f8 <Clock_Ip_ResetScgRunSel_TrustedCall+0x34>)
    46ca:	795b      	ldrb	r3, [r3, #5]
    46cc:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SCG->RCCR;
    46ce:	4b0b      	ldr	r3, [pc, #44]	; (46fc <Clock_Ip_ResetScgRunSel_TrustedCall+0x38>)
    46d0:	695b      	ldr	r3, [r3, #20]
    46d2:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_RCCR_SCS_MASK;
    46d4:	9b02      	ldr	r3, [sp, #8]
    46d6:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    46da:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_RCCR_SCS(SelectorValue);
    46dc:	9b03      	ldr	r3, [sp, #12]
    46de:	061b      	lsls	r3, r3, #24
    46e0:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    46e4:	9a02      	ldr	r2, [sp, #8]
    46e6:	4313      	orrs	r3, r2
    46e8:	9302      	str	r3, [sp, #8]
    IP_SCG->RCCR = RegValue;
    46ea:	4a04      	ldr	r2, [pc, #16]	; (46fc <Clock_Ip_ResetScgRunSel_TrustedCall+0x38>)
    46ec:	9b02      	ldr	r3, [sp, #8]
    46ee:	6153      	str	r3, [r2, #20]
}
    46f0:	bf00      	nop
    46f2:	b004      	add	sp, #16
    46f4:	4770      	bx	lr
    46f6:	bf00      	nop
    46f8:	00018314 	.word	0x00018314
    46fc:	40064000 	.word	0x40064000

00004700 <Clock_Ip_SetScgRunSel_TrustedCall>:

void Clock_Ip_SetScgRunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4700:	b084      	sub	sp, #16
    4702:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4704:	9b01      	ldr	r3, [sp, #4]
    4706:	685b      	ldr	r3, [r3, #4]
    4708:	4a0b      	ldr	r2, [pc, #44]	; (4738 <Clock_Ip_SetScgRunSel_TrustedCall+0x38>)
    470a:	5cd3      	ldrb	r3, [r2, r3]
    470c:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->RCCR;
    470e:	4b0b      	ldr	r3, [pc, #44]	; (473c <Clock_Ip_SetScgRunSel_TrustedCall+0x3c>)
    4710:	695b      	ldr	r3, [r3, #20]
    4712:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_RCCR_SCS_MASK;
    4714:	9b02      	ldr	r3, [sp, #8]
    4716:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    471a:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_RCCR_SCS(SelectorValue);
    471c:	9b03      	ldr	r3, [sp, #12]
    471e:	061b      	lsls	r3, r3, #24
    4720:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    4724:	9a02      	ldr	r2, [sp, #8]
    4726:	4313      	orrs	r3, r2
    4728:	9302      	str	r3, [sp, #8]
    IP_SCG->RCCR = RegValue;
    472a:	4a04      	ldr	r2, [pc, #16]	; (473c <Clock_Ip_SetScgRunSel_TrustedCall+0x3c>)
    472c:	9b02      	ldr	r3, [sp, #8]
    472e:	6153      	str	r3, [r2, #20]
}
    4730:	bf00      	nop
    4732:	b004      	add	sp, #16
    4734:	4770      	bx	lr
    4736:	bf00      	nop
    4738:	00018314 	.word	0x00018314
    473c:	40064000 	.word	0x40064000

00004740 <Clock_Ip_SetScgVlprSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_SCS_VLPR_SEL

void Clock_Ip_SetScgVlprSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4740:	b084      	sub	sp, #16
    4742:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4744:	9b01      	ldr	r3, [sp, #4]
    4746:	685b      	ldr	r3, [r3, #4]
    4748:	4a0b      	ldr	r2, [pc, #44]	; (4778 <Clock_Ip_SetScgVlprSel_TrustedCall+0x38>)
    474a:	5cd3      	ldrb	r3, [r2, r3]
    474c:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->VCCR;
    474e:	4b0b      	ldr	r3, [pc, #44]	; (477c <Clock_Ip_SetScgVlprSel_TrustedCall+0x3c>)
    4750:	699b      	ldr	r3, [r3, #24]
    4752:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_VCCR_SCS_MASK;
    4754:	9b02      	ldr	r3, [sp, #8]
    4756:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    475a:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_VCCR_SCS(SelectorValue);
    475c:	9b03      	ldr	r3, [sp, #12]
    475e:	061b      	lsls	r3, r3, #24
    4760:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    4764:	9a02      	ldr	r2, [sp, #8]
    4766:	4313      	orrs	r3, r2
    4768:	9302      	str	r3, [sp, #8]
    IP_SCG->VCCR = RegValue;
    476a:	4a04      	ldr	r2, [pc, #16]	; (477c <Clock_Ip_SetScgVlprSel_TrustedCall+0x3c>)
    476c:	9b02      	ldr	r3, [sp, #8]
    476e:	6193      	str	r3, [r2, #24]
}
    4770:	bf00      	nop
    4772:	b004      	add	sp, #16
    4774:	4770      	bx	lr
    4776:	bf00      	nop
    4778:	00018314 	.word	0x00018314
    477c:	40064000 	.word	0x40064000

00004780 <Clock_Ip_ResetScgHsrunSel_TrustedCall>:

#endif

#ifdef CLOCK_IP_SCG_SCS_HSRUN_SEL
void Clock_Ip_ResetScgHsrunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4780:	b084      	sub	sp, #16
    4782:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4784:	4b0b      	ldr	r3, [pc, #44]	; (47b4 <Clock_Ip_ResetScgHsrunSel_TrustedCall+0x34>)
    4786:	795b      	ldrb	r3, [r3, #5]
    4788:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SCG->HCCR;
    478a:	4b0b      	ldr	r3, [pc, #44]	; (47b8 <Clock_Ip_ResetScgHsrunSel_TrustedCall+0x38>)
    478c:	69db      	ldr	r3, [r3, #28]
    478e:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_HCCR_SCS_MASK;
    4790:	9b02      	ldr	r3, [sp, #8]
    4792:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    4796:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_HCCR_SCS(SelectorValue);
    4798:	9b03      	ldr	r3, [sp, #12]
    479a:	061b      	lsls	r3, r3, #24
    479c:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    47a0:	9a02      	ldr	r2, [sp, #8]
    47a2:	4313      	orrs	r3, r2
    47a4:	9302      	str	r3, [sp, #8]
    IP_SCG->HCCR = RegValue;
    47a6:	4a04      	ldr	r2, [pc, #16]	; (47b8 <Clock_Ip_ResetScgHsrunSel_TrustedCall+0x38>)
    47a8:	9b02      	ldr	r3, [sp, #8]
    47aa:	61d3      	str	r3, [r2, #28]
}
    47ac:	bf00      	nop
    47ae:	b004      	add	sp, #16
    47b0:	4770      	bx	lr
    47b2:	bf00      	nop
    47b4:	00018314 	.word	0x00018314
    47b8:	40064000 	.word	0x40064000

000047bc <Clock_Ip_SetScgHsrunSel_TrustedCall>:
void Clock_Ip_SetScgHsrunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    47bc:	b084      	sub	sp, #16
    47be:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    47c0:	9b01      	ldr	r3, [sp, #4]
    47c2:	685b      	ldr	r3, [r3, #4]
    47c4:	4a0b      	ldr	r2, [pc, #44]	; (47f4 <Clock_Ip_SetScgHsrunSel_TrustedCall+0x38>)
    47c6:	5cd3      	ldrb	r3, [r2, r3]
    47c8:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->HCCR;
    47ca:	4b0b      	ldr	r3, [pc, #44]	; (47f8 <Clock_Ip_SetScgHsrunSel_TrustedCall+0x3c>)
    47cc:	69db      	ldr	r3, [r3, #28]
    47ce:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_HCCR_SCS_MASK;
    47d0:	9b02      	ldr	r3, [sp, #8]
    47d2:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    47d6:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_HCCR_SCS(SelectorValue);
    47d8:	9b03      	ldr	r3, [sp, #12]
    47da:	061b      	lsls	r3, r3, #24
    47dc:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    47e0:	9a02      	ldr	r2, [sp, #8]
    47e2:	4313      	orrs	r3, r2
    47e4:	9302      	str	r3, [sp, #8]
    IP_SCG->HCCR = RegValue;
    47e6:	4a04      	ldr	r2, [pc, #16]	; (47f8 <Clock_Ip_SetScgHsrunSel_TrustedCall+0x3c>)
    47e8:	9b02      	ldr	r3, [sp, #8]
    47ea:	61d3      	str	r3, [r2, #28]
}
    47ec:	bf00      	nop
    47ee:	b004      	add	sp, #16
    47f0:	4770      	bx	lr
    47f2:	bf00      	nop
    47f4:	00018314 	.word	0x00018314
    47f8:	40064000 	.word	0x40064000

000047fc <Clock_Ip_ResetSimRtcSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_RTC_SEL
void Clock_Ip_ResetSimRtcSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    47fc:	b084      	sub	sp, #16
    47fe:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[SOSCDIV1_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4800:	4b0a      	ldr	r3, [pc, #40]	; (482c <Clock_Ip_ResetSimRtcSel_TrustedCall+0x30>)
    4802:	7b9b      	ldrb	r3, [r3, #14]
    4804:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SIM->LPOCLKS;
    4806:	4b0a      	ldr	r3, [pc, #40]	; (4830 <Clock_Ip_ResetSimRtcSel_TrustedCall+0x34>)
    4808:	691b      	ldr	r3, [r3, #16]
    480a:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_RTCCLKSEL_MASK;
    480c:	9b02      	ldr	r3, [sp, #8]
    480e:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    4812:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_RTCCLKSEL_SHIFT);
    4814:	9b03      	ldr	r3, [sp, #12]
    4816:	011b      	lsls	r3, r3, #4
    4818:	9a02      	ldr	r2, [sp, #8]
    481a:	4313      	orrs	r3, r2
    481c:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    481e:	4a04      	ldr	r2, [pc, #16]	; (4830 <Clock_Ip_ResetSimRtcSel_TrustedCall+0x34>)
    4820:	9b02      	ldr	r3, [sp, #8]
    4822:	6113      	str	r3, [r2, #16]
}
    4824:	bf00      	nop
    4826:	b004      	add	sp, #16
    4828:	4770      	bx	lr
    482a:	bf00      	nop
    482c:	000182bc 	.word	0x000182bc
    4830:	40048000 	.word	0x40048000

00004834 <Clock_Ip_SetSimRtcSel_TrustedCall>:

void Clock_Ip_SetSimRtcSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4834:	b084      	sub	sp, #16
    4836:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4838:	9b01      	ldr	r3, [sp, #4]
    483a:	685b      	ldr	r3, [r3, #4]
    483c:	4a0a      	ldr	r2, [pc, #40]	; (4868 <Clock_Ip_SetSimRtcSel_TrustedCall+0x34>)
    483e:	5cd3      	ldrb	r3, [r2, r3]
    4840:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->LPOCLKS;
    4842:	4b0a      	ldr	r3, [pc, #40]	; (486c <Clock_Ip_SetSimRtcSel_TrustedCall+0x38>)
    4844:	691b      	ldr	r3, [r3, #16]
    4846:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_RTCCLKSEL_MASK;
    4848:	9b02      	ldr	r3, [sp, #8]
    484a:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    484e:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_RTCCLKSEL_SHIFT);
    4850:	9b03      	ldr	r3, [sp, #12]
    4852:	011b      	lsls	r3, r3, #4
    4854:	9a02      	ldr	r2, [sp, #8]
    4856:	4313      	orrs	r3, r2
    4858:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    485a:	4a04      	ldr	r2, [pc, #16]	; (486c <Clock_Ip_SetSimRtcSel_TrustedCall+0x38>)
    485c:	9b02      	ldr	r3, [sp, #8]
    485e:	6113      	str	r3, [r2, #16]
}
    4860:	bf00      	nop
    4862:	b004      	add	sp, #16
    4864:	4770      	bx	lr
    4866:	bf00      	nop
    4868:	000182bc 	.word	0x000182bc
    486c:	40048000 	.word	0x40048000

00004870 <Clock_Ip_ResetSimLpoSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_LPO_SEL
void Clock_Ip_ResetSimLpoSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4870:	b084      	sub	sp, #16
    4872:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntrySIMHardwareValue[LPO_128K_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4874:	4b0a      	ldr	r3, [pc, #40]	; (48a0 <Clock_Ip_ResetSimLpoSel_TrustedCall+0x30>)
    4876:	785b      	ldrb	r3, [r3, #1]
    4878:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SIM->LPOCLKS;
    487a:	4b0a      	ldr	r3, [pc, #40]	; (48a4 <Clock_Ip_ResetSimLpoSel_TrustedCall+0x34>)
    487c:	691b      	ldr	r3, [r3, #16]
    487e:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_LPOCLKSEL_MASK;
    4880:	9b02      	ldr	r3, [sp, #8]
    4882:	f023 030c 	bic.w	r3, r3, #12
    4886:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_LPOCLKSEL_SHIFT);
    4888:	9b03      	ldr	r3, [sp, #12]
    488a:	009b      	lsls	r3, r3, #2
    488c:	9a02      	ldr	r2, [sp, #8]
    488e:	4313      	orrs	r3, r2
    4890:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    4892:	4a04      	ldr	r2, [pc, #16]	; (48a4 <Clock_Ip_ResetSimLpoSel_TrustedCall+0x34>)
    4894:	9b02      	ldr	r3, [sp, #8]
    4896:	6113      	str	r3, [r2, #16]
}
    4898:	bf00      	nop
    489a:	b004      	add	sp, #16
    489c:	4770      	bx	lr
    489e:	bf00      	nop
    48a0:	00018374 	.word	0x00018374
    48a4:	40048000 	.word	0x40048000

000048a8 <Clock_Ip_SetSimLpoSel_TrustedCall>:
void Clock_Ip_SetSimLpoSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    48a8:	b084      	sub	sp, #16
    48aa:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* LPO_CLK selector mapped to Clock_Ip_au8SelectorEntrySIMHardwareValue */
    uint32 SelectorValue = Clock_Ip_au8SelectorEntrySIMHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    48ac:	9b01      	ldr	r3, [sp, #4]
    48ae:	685b      	ldr	r3, [r3, #4]
    48b0:	4a0a      	ldr	r2, [pc, #40]	; (48dc <Clock_Ip_SetSimLpoSel_TrustedCall+0x34>)
    48b2:	5cd3      	ldrb	r3, [r2, r3]
    48b4:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SIM->LPOCLKS;
    48b6:	4b0a      	ldr	r3, [pc, #40]	; (48e0 <Clock_Ip_SetSimLpoSel_TrustedCall+0x38>)
    48b8:	691b      	ldr	r3, [r3, #16]
    48ba:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_LPOCLKSEL_MASK;
    48bc:	9b02      	ldr	r3, [sp, #8]
    48be:	f023 030c 	bic.w	r3, r3, #12
    48c2:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_LPOCLKSEL_SHIFT);
    48c4:	9b03      	ldr	r3, [sp, #12]
    48c6:	009b      	lsls	r3, r3, #2
    48c8:	9a02      	ldr	r2, [sp, #8]
    48ca:	4313      	orrs	r3, r2
    48cc:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    48ce:	4a04      	ldr	r2, [pc, #16]	; (48e0 <Clock_Ip_SetSimLpoSel_TrustedCall+0x38>)
    48d0:	9b02      	ldr	r3, [sp, #8]
    48d2:	6113      	str	r3, [r2, #16]
}
    48d4:	bf00      	nop
    48d6:	b004      	add	sp, #16
    48d8:	4770      	bx	lr
    48da:	bf00      	nop
    48dc:	00018374 	.word	0x00018374
    48e0:	40048000 	.word	0x40048000

000048e4 <Clock_Ip_ResetScgClkoutSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_CLKOUT_SEL
void Clock_Ip_ResetScgClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    48e4:	b084      	sub	sp, #16
    48e6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* LPO_CLK selector mapped to Clock_Ip_au8SelectorEntryScsHardwareValue */
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    48e8:	4b0a      	ldr	r3, [pc, #40]	; (4914 <Clock_Ip_ResetScgClkoutSel_TrustedCall+0x30>)
    48ea:	795b      	ldrb	r3, [r3, #5]
    48ec:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SCG->CLKOUTCNFG;
    48ee:	4b0a      	ldr	r3, [pc, #40]	; (4918 <Clock_Ip_ResetScgClkoutSel_TrustedCall+0x34>)
    48f0:	6a1b      	ldr	r3, [r3, #32]
    48f2:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_CLKOUTCNFG_CLKOUTSEL_MASK;
    48f4:	9b02      	ldr	r3, [sp, #8]
    48f6:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    48fa:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SCG_CLKOUTCNFG_CLKOUTSEL_SHIFT);
    48fc:	9b03      	ldr	r3, [sp, #12]
    48fe:	061b      	lsls	r3, r3, #24
    4900:	9a02      	ldr	r2, [sp, #8]
    4902:	4313      	orrs	r3, r2
    4904:	9302      	str	r3, [sp, #8]
    IP_SCG->CLKOUTCNFG = RegValue;
    4906:	4a04      	ldr	r2, [pc, #16]	; (4918 <Clock_Ip_ResetScgClkoutSel_TrustedCall+0x34>)
    4908:	9b02      	ldr	r3, [sp, #8]
    490a:	6213      	str	r3, [r2, #32]
}
    490c:	bf00      	nop
    490e:	b004      	add	sp, #16
    4910:	4770      	bx	lr
    4912:	bf00      	nop
    4914:	00018314 	.word	0x00018314
    4918:	40064000 	.word	0x40064000

0000491c <Clock_Ip_SetScgClkoutSel_TrustedCall>:
void Clock_Ip_SetScgClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    491c:	b084      	sub	sp, #16
    491e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4920:	9b01      	ldr	r3, [sp, #4]
    4922:	685b      	ldr	r3, [r3, #4]
    4924:	4a0a      	ldr	r2, [pc, #40]	; (4950 <Clock_Ip_SetScgClkoutSel_TrustedCall+0x34>)
    4926:	5cd3      	ldrb	r3, [r2, r3]
    4928:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->CLKOUTCNFG;
    492a:	4b0a      	ldr	r3, [pc, #40]	; (4954 <Clock_Ip_SetScgClkoutSel_TrustedCall+0x38>)
    492c:	6a1b      	ldr	r3, [r3, #32]
    492e:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_CLKOUTCNFG_CLKOUTSEL_MASK;
    4930:	9b02      	ldr	r3, [sp, #8]
    4932:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    4936:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SCG_CLKOUTCNFG_CLKOUTSEL_SHIFT);
    4938:	9b03      	ldr	r3, [sp, #12]
    493a:	061b      	lsls	r3, r3, #24
    493c:	9a02      	ldr	r2, [sp, #8]
    493e:	4313      	orrs	r3, r2
    4940:	9302      	str	r3, [sp, #8]
    IP_SCG->CLKOUTCNFG = RegValue;
    4942:	4a04      	ldr	r2, [pc, #16]	; (4954 <Clock_Ip_SetScgClkoutSel_TrustedCall+0x38>)
    4944:	9b02      	ldr	r3, [sp, #8]
    4946:	6213      	str	r3, [r2, #32]
}
    4948:	bf00      	nop
    494a:	b004      	add	sp, #16
    494c:	4770      	bx	lr
    494e:	bf00      	nop
    4950:	00018314 	.word	0x00018314
    4954:	40064000 	.word	0x40064000

00004958 <Clock_Ip_ResetSimFtmoptSel_TrustedCall>:
#define SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(x)  (24U + ((x) << 1U))
#define SIM_FTMOPT0_FTM_0_3_CLKSEL_MASK(x)   ((uint32)3U << SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(x))
#define SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(x)  (16U + (((x) - 4U) << 1U))
#define SIM_FTMOPT0_FTM_4_7_CLKSEL_MASK(x)   ((uint32)3U << SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(x))
void Clock_Ip_ResetSimFtmoptSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4958:	b086      	sub	sp, #24
    495a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    495c:	4b20      	ldr	r3, [pc, #128]	; (49e0 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x88>)
    495e:	795b      	ldrb	r3, [r3, #5]
    4960:	9304      	str	r3, [sp, #16]
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    4962:	9b01      	ldr	r3, [sp, #4]
    4964:	681a      	ldr	r2, [r3, #0]
    4966:	491f      	ldr	r1, [pc, #124]	; (49e4 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x8c>)
    4968:	4613      	mov	r3, r2
    496a:	00db      	lsls	r3, r3, #3
    496c:	4413      	add	r3, r2
    496e:	440b      	add	r3, r1
    4970:	781b      	ldrb	r3, [r3, #0]
    4972:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->FTMOPT0;
    4974:	4b1c      	ldr	r3, [pc, #112]	; (49e8 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x90>)
    4976:	68db      	ldr	r3, [r3, #12]
    4978:	9305      	str	r3, [sp, #20]
    if(Instance < 4U)
    497a:	9b03      	ldr	r3, [sp, #12]
    497c:	2b03      	cmp	r3, #3
    497e:	d813      	bhi.n	49a8 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x50>
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_0_3_CLKSEL_MASK(Instance));
    4980:	9b03      	ldr	r3, [sp, #12]
    4982:	005b      	lsls	r3, r3, #1
    4984:	3318      	adds	r3, #24
    4986:	2203      	movs	r2, #3
    4988:	fa02 f303 	lsl.w	r3, r2, r3
    498c:	43db      	mvns	r3, r3
    498e:	9a05      	ldr	r2, [sp, #20]
    4990:	4013      	ands	r3, r2
    4992:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(Instance));
    4994:	9b03      	ldr	r3, [sp, #12]
    4996:	005b      	lsls	r3, r3, #1
    4998:	3318      	adds	r3, #24
    499a:	9a04      	ldr	r2, [sp, #16]
    499c:	fa02 f303 	lsl.w	r3, r2, r3
    49a0:	9a05      	ldr	r2, [sp, #20]
    49a2:	4313      	orrs	r3, r2
    49a4:	9305      	str	r3, [sp, #20]
    49a6:	e014      	b.n	49d2 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x7a>
    }
    else
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_4_7_CLKSEL_MASK(Instance));
    49a8:	9b03      	ldr	r3, [sp, #12]
    49aa:	3b04      	subs	r3, #4
    49ac:	005b      	lsls	r3, r3, #1
    49ae:	3310      	adds	r3, #16
    49b0:	2203      	movs	r2, #3
    49b2:	fa02 f303 	lsl.w	r3, r2, r3
    49b6:	43db      	mvns	r3, r3
    49b8:	9a05      	ldr	r2, [sp, #20]
    49ba:	4013      	ands	r3, r2
    49bc:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(Instance));
    49be:	9b03      	ldr	r3, [sp, #12]
    49c0:	3b04      	subs	r3, #4
    49c2:	005b      	lsls	r3, r3, #1
    49c4:	3310      	adds	r3, #16
    49c6:	9a04      	ldr	r2, [sp, #16]
    49c8:	fa02 f303 	lsl.w	r3, r2, r3
    49cc:	9a05      	ldr	r2, [sp, #20]
    49ce:	4313      	orrs	r3, r2
    49d0:	9305      	str	r3, [sp, #20]
    }

    IP_SIM->FTMOPT0 = RegValue;
    49d2:	4a05      	ldr	r2, [pc, #20]	; (49e8 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x90>)
    49d4:	9b05      	ldr	r3, [sp, #20]
    49d6:	60d3      	str	r3, [r2, #12]
}
    49d8:	bf00      	nop
    49da:	b006      	add	sp, #24
    49dc:	4770      	bx	lr
    49de:	bf00      	nop
    49e0:	000182bc 	.word	0x000182bc
    49e4:	00017fac 	.word	0x00017fac
    49e8:	40048000 	.word	0x40048000

000049ec <Clock_Ip_SetSimFtmoptSel_TrustedCall>:
void Clock_Ip_SetSimFtmoptSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    49ec:	b086      	sub	sp, #24
    49ee:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    49f0:	9b01      	ldr	r3, [sp, #4]
    49f2:	685b      	ldr	r3, [r3, #4]
    49f4:	4a20      	ldr	r2, [pc, #128]	; (4a78 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x8c>)
    49f6:	5cd3      	ldrb	r3, [r2, r3]
    49f8:	9304      	str	r3, [sp, #16]
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    49fa:	9b01      	ldr	r3, [sp, #4]
    49fc:	681a      	ldr	r2, [r3, #0]
    49fe:	491f      	ldr	r1, [pc, #124]	; (4a7c <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x90>)
    4a00:	4613      	mov	r3, r2
    4a02:	00db      	lsls	r3, r3, #3
    4a04:	4413      	add	r3, r2
    4a06:	440b      	add	r3, r1
    4a08:	781b      	ldrb	r3, [r3, #0]
    4a0a:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->FTMOPT0;
    4a0c:	4b1c      	ldr	r3, [pc, #112]	; (4a80 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x94>)
    4a0e:	68db      	ldr	r3, [r3, #12]
    4a10:	9305      	str	r3, [sp, #20]
    if(Instance < 4U)
    4a12:	9b03      	ldr	r3, [sp, #12]
    4a14:	2b03      	cmp	r3, #3
    4a16:	d813      	bhi.n	4a40 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x54>
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_0_3_CLKSEL_MASK(Instance));
    4a18:	9b03      	ldr	r3, [sp, #12]
    4a1a:	005b      	lsls	r3, r3, #1
    4a1c:	3318      	adds	r3, #24
    4a1e:	2203      	movs	r2, #3
    4a20:	fa02 f303 	lsl.w	r3, r2, r3
    4a24:	43db      	mvns	r3, r3
    4a26:	9a05      	ldr	r2, [sp, #20]
    4a28:	4013      	ands	r3, r2
    4a2a:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(Instance));
    4a2c:	9b03      	ldr	r3, [sp, #12]
    4a2e:	005b      	lsls	r3, r3, #1
    4a30:	3318      	adds	r3, #24
    4a32:	9a04      	ldr	r2, [sp, #16]
    4a34:	fa02 f303 	lsl.w	r3, r2, r3
    4a38:	9a05      	ldr	r2, [sp, #20]
    4a3a:	4313      	orrs	r3, r2
    4a3c:	9305      	str	r3, [sp, #20]
    4a3e:	e014      	b.n	4a6a <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x7e>
    }
    else
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_4_7_CLKSEL_MASK(Instance));
    4a40:	9b03      	ldr	r3, [sp, #12]
    4a42:	3b04      	subs	r3, #4
    4a44:	005b      	lsls	r3, r3, #1
    4a46:	3310      	adds	r3, #16
    4a48:	2203      	movs	r2, #3
    4a4a:	fa02 f303 	lsl.w	r3, r2, r3
    4a4e:	43db      	mvns	r3, r3
    4a50:	9a05      	ldr	r2, [sp, #20]
    4a52:	4013      	ands	r3, r2
    4a54:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(Instance));
    4a56:	9b03      	ldr	r3, [sp, #12]
    4a58:	3b04      	subs	r3, #4
    4a5a:	005b      	lsls	r3, r3, #1
    4a5c:	3310      	adds	r3, #16
    4a5e:	9a04      	ldr	r2, [sp, #16]
    4a60:	fa02 f303 	lsl.w	r3, r2, r3
    4a64:	9a05      	ldr	r2, [sp, #20]
    4a66:	4313      	orrs	r3, r2
    4a68:	9305      	str	r3, [sp, #20]
    }

    IP_SIM->FTMOPT0 = RegValue;
    4a6a:	4a05      	ldr	r2, [pc, #20]	; (4a80 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x94>)
    4a6c:	9b05      	ldr	r3, [sp, #20]
    4a6e:	60d3      	str	r3, [r2, #12]
}
    4a70:	bf00      	nop
    4a72:	b006      	add	sp, #24
    4a74:	4770      	bx	lr
    4a76:	bf00      	nop
    4a78:	000182bc 	.word	0x000182bc
    4a7c:	00017fac 	.word	0x00017fac
    4a80:	40048000 	.word	0x40048000

00004a84 <Clock_Ip_ResetSimClkoutSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_SEL
/* Clear CLKOUTSEL and CLKOUTEN bit field in SIM_CHIPCTL register  */
void Clock_Ip_ResetSimClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4a84:	b084      	sub	sp, #16
    4a86:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    (void)Config;

    RegValue = IP_SIM->CHIPCTL;
    4a88:	4b06      	ldr	r3, [pc, #24]	; (4aa4 <Clock_Ip_ResetSimClkoutSel_TrustedCall+0x20>)
    4a8a:	685b      	ldr	r3, [r3, #4]
    4a8c:	9303      	str	r3, [sp, #12]
    RegValue &= ~(SIM_CHIPCTL_CLKOUTSEL_MASK | SIM_CHIPCTL_CLKOUTEN_MASK);
    4a8e:	9b03      	ldr	r3, [sp, #12]
    4a90:	f423 630f 	bic.w	r3, r3, #2288	; 0x8f0
    4a94:	9303      	str	r3, [sp, #12]
    IP_SIM->CHIPCTL = RegValue;
    4a96:	4a03      	ldr	r2, [pc, #12]	; (4aa4 <Clock_Ip_ResetSimClkoutSel_TrustedCall+0x20>)
    4a98:	9b03      	ldr	r3, [sp, #12]
    4a9a:	6053      	str	r3, [r2, #4]
}
    4a9c:	bf00      	nop
    4a9e:	b004      	add	sp, #16
    4aa0:	4770      	bx	lr
    4aa2:	bf00      	nop
    4aa4:	40048000 	.word	0x40048000

00004aa8 <Clock_Ip_SetSimClkoutSel_TrustedCall>:
void Clock_Ip_SetSimClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4aa8:	b084      	sub	sp, #16
    4aaa:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4aac:	9b01      	ldr	r3, [sp, #4]
    4aae:	685b      	ldr	r3, [r3, #4]
    4ab0:	4a0a      	ldr	r2, [pc, #40]	; (4adc <Clock_Ip_SetSimClkoutSel_TrustedCall+0x34>)
    4ab2:	5cd3      	ldrb	r3, [r2, r3]
    4ab4:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->CHIPCTL;
    4ab6:	4b0a      	ldr	r3, [pc, #40]	; (4ae0 <Clock_Ip_SetSimClkoutSel_TrustedCall+0x38>)
    4ab8:	685b      	ldr	r3, [r3, #4]
    4aba:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_CHIPCTL_CLKOUTSEL_MASK;
    4abc:	9b02      	ldr	r3, [sp, #8]
    4abe:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    4ac2:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_CHIPCTL_CLKOUTSEL_SHIFT);
    4ac4:	9b03      	ldr	r3, [sp, #12]
    4ac6:	011b      	lsls	r3, r3, #4
    4ac8:	9a02      	ldr	r2, [sp, #8]
    4aca:	4313      	orrs	r3, r2
    4acc:	9302      	str	r3, [sp, #8]
    IP_SIM->CHIPCTL = RegValue;
    4ace:	4a04      	ldr	r2, [pc, #16]	; (4ae0 <Clock_Ip_SetSimClkoutSel_TrustedCall+0x38>)
    4ad0:	9b02      	ldr	r3, [sp, #8]
    4ad2:	6053      	str	r3, [r2, #4]
}
    4ad4:	bf00      	nop
    4ad6:	b004      	add	sp, #16
    4ad8:	4770      	bx	lr
    4ada:	bf00      	nop
    4adc:	000182bc 	.word	0x000182bc
    4ae0:	40048000 	.word	0x40048000

00004ae4 <Clock_Ip_ResetPccPcsSelect_TrustedCall>:
#ifdef CLOCK_IP_PCC_PCS_SELECT
/**
* @brief            This function will reset writable bit fields of PCC register
*/
void Clock_Ip_ResetPccPcsSelect_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4ae4:	b084      	sub	sp, #16
    4ae6:	9001      	str	r0, [sp, #4]
    uint32 PccIndex = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_SELECTOR_INDEX];
    4ae8:	9b01      	ldr	r3, [sp, #4]
    4aea:	681a      	ldr	r2, [r3, #0]
    4aec:	490f      	ldr	r1, [pc, #60]	; (4b2c <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x48>)
    4aee:	4613      	mov	r3, r2
    4af0:	00db      	lsls	r3, r3, #3
    4af2:	4413      	add	r3, r2
    4af4:	440b      	add	r3, r1
    4af6:	3304      	adds	r3, #4
    4af8:	781b      	ldrb	r3, [r3, #0]
    4afa:	9303      	str	r3, [sp, #12]

    /* Disable CGC before set PCS */
    IP_PCC->PCCn[PccIndex] &= ~(PCC_PCCn_CGC_MASK);
    4afc:	4a0c      	ldr	r2, [pc, #48]	; (4b30 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    4afe:	9b03      	ldr	r3, [sp, #12]
    4b00:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    4b04:	490a      	ldr	r1, [pc, #40]	; (4b30 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    4b06:	f023 4280 	bic.w	r2, r3, #1073741824	; 0x40000000
    4b0a:	9b03      	ldr	r3, [sp, #12]
    4b0c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    IP_PCC->PCCn[PccIndex] &= ~(PCC_PCCn_PCS_MASK);
    4b10:	4a07      	ldr	r2, [pc, #28]	; (4b30 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    4b12:	9b03      	ldr	r3, [sp, #12]
    4b14:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    4b18:	4905      	ldr	r1, [pc, #20]	; (4b30 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    4b1a:	f023 62e0 	bic.w	r2, r3, #117440512	; 0x7000000
    4b1e:	9b03      	ldr	r3, [sp, #12]
    4b20:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    4b24:	bf00      	nop
    4b26:	b004      	add	sp, #16
    4b28:	4770      	bx	lr
    4b2a:	bf00      	nop
    4b2c:	00017fac 	.word	0x00017fac
    4b30:	40065000 	.word	0x40065000

00004b34 <Clock_Ip_SetPccPcsSelect_TrustedCall>:
void Clock_Ip_SetPccPcsSelect_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4b34:	b086      	sub	sp, #24
    4b36:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 PccIndex = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_SELECTOR_INDEX];
    4b38:	9b01      	ldr	r3, [sp, #4]
    4b3a:	681a      	ldr	r2, [r3, #0]
    4b3c:	4912      	ldr	r1, [pc, #72]	; (4b88 <Clock_Ip_SetPccPcsSelect_TrustedCall+0x54>)
    4b3e:	4613      	mov	r3, r2
    4b40:	00db      	lsls	r3, r3, #3
    4b42:	4413      	add	r3, r2
    4b44:	440b      	add	r3, r1
    4b46:	3304      	adds	r3, #4
    4b48:	781b      	ldrb	r3, [r3, #0]
    4b4a:	9305      	str	r3, [sp, #20]
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryPcsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4b4c:	9b01      	ldr	r3, [sp, #4]
    4b4e:	685b      	ldr	r3, [r3, #4]
    4b50:	4a0e      	ldr	r2, [pc, #56]	; (4b8c <Clock_Ip_SetPccPcsSelect_TrustedCall+0x58>)
    4b52:	5cd3      	ldrb	r3, [r2, r3]
    4b54:	9304      	str	r3, [sp, #16]

    RegValue = IP_PCC->PCCn[PccIndex];
    4b56:	4a0e      	ldr	r2, [pc, #56]	; (4b90 <Clock_Ip_SetPccPcsSelect_TrustedCall+0x5c>)
    4b58:	9b05      	ldr	r3, [sp, #20]
    4b5a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    4b5e:	9303      	str	r3, [sp, #12]
    RegValue &= ~PCC_PCCn_PCS_MASK;
    4b60:	9b03      	ldr	r3, [sp, #12]
    4b62:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
    4b66:	9303      	str	r3, [sp, #12]
    RegValue |= PCC_PCCn_PCS(SelectorValue);
    4b68:	9b04      	ldr	r3, [sp, #16]
    4b6a:	061b      	lsls	r3, r3, #24
    4b6c:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
    4b70:	9a03      	ldr	r2, [sp, #12]
    4b72:	4313      	orrs	r3, r2
    4b74:	9303      	str	r3, [sp, #12]
    IP_PCC->PCCn[PccIndex] = RegValue;
    4b76:	4906      	ldr	r1, [pc, #24]	; (4b90 <Clock_Ip_SetPccPcsSelect_TrustedCall+0x5c>)
    4b78:	9b05      	ldr	r3, [sp, #20]
    4b7a:	9a03      	ldr	r2, [sp, #12]
    4b7c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    4b80:	bf00      	nop
    4b82:	b006      	add	sp, #24
    4b84:	4770      	bx	lr
    4b86:	bf00      	nop
    4b88:	00017fac 	.word	0x00017fac
    4b8c:	00018344 	.word	0x00018344
    4b90:	40065000 	.word	0x40065000

00004b94 <Clock_Ip_ResetSimTraceSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_SEL
void Clock_Ip_ResetSimTraceSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4b94:	b084      	sub	sp, #16
    4b96:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* TRACE_CLK selector mapped to Clock_Ip_au16SelectorEntryHardwareValue */
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[CORE_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4b98:	4b0b      	ldr	r3, [pc, #44]	; (4bc8 <Clock_Ip_ResetSimTraceSel_TrustedCall+0x34>)
    4b9a:	7f1b      	ldrb	r3, [r3, #28]
    4b9c:	9303      	str	r3, [sp, #12]

    (void) Config;
    RegValue = (uint32)IP_SIM->CHIPCTL;
    4b9e:	4b0b      	ldr	r3, [pc, #44]	; (4bcc <Clock_Ip_ResetSimTraceSel_TrustedCall+0x38>)
    4ba0:	685b      	ldr	r3, [r3, #4]
    4ba2:	9302      	str	r3, [sp, #8]
    RegValue &= (~((uint32)SIM_CHIPCTL_TRACECLK_SEL_MASK));
    4ba4:	9b02      	ldr	r3, [sp, #8]
    4ba6:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    4baa:	9302      	str	r3, [sp, #8]
    RegValue |= SIM_CHIPCTL_TRACECLK_SEL(SelectorValue);
    4bac:	9b03      	ldr	r3, [sp, #12]
    4bae:	031b      	lsls	r3, r3, #12
    4bb0:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    4bb4:	9a02      	ldr	r2, [sp, #8]
    4bb6:	4313      	orrs	r3, r2
    4bb8:	9302      	str	r3, [sp, #8]
    IP_SIM->CHIPCTL = (uint32)RegValue;
    4bba:	4a04      	ldr	r2, [pc, #16]	; (4bcc <Clock_Ip_ResetSimTraceSel_TrustedCall+0x38>)
    4bbc:	9b02      	ldr	r3, [sp, #8]
    4bbe:	6053      	str	r3, [r2, #4]
}
    4bc0:	bf00      	nop
    4bc2:	b004      	add	sp, #16
    4bc4:	4770      	bx	lr
    4bc6:	bf00      	nop
    4bc8:	000182bc 	.word	0x000182bc
    4bcc:	40048000 	.word	0x40048000

00004bd0 <Clock_Ip_SetSimTraceSel_TrustedCall>:
void Clock_Ip_SetSimTraceSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4bd0:	b084      	sub	sp, #16
    4bd2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* TRACE_CLK selector mapped to Clock_Ip_au16SelectorEntryHardwareValue */
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4bd4:	9b01      	ldr	r3, [sp, #4]
    4bd6:	685b      	ldr	r3, [r3, #4]
    4bd8:	4a0b      	ldr	r2, [pc, #44]	; (4c08 <Clock_Ip_SetSimTraceSel_TrustedCall+0x38>)
    4bda:	5cd3      	ldrb	r3, [r2, r3]
    4bdc:	9303      	str	r3, [sp, #12]

    RegValue = (uint32)IP_SIM->CHIPCTL;
    4bde:	4b0b      	ldr	r3, [pc, #44]	; (4c0c <Clock_Ip_SetSimTraceSel_TrustedCall+0x3c>)
    4be0:	685b      	ldr	r3, [r3, #4]
    4be2:	9302      	str	r3, [sp, #8]
    RegValue &= (~((uint32)SIM_CHIPCTL_TRACECLK_SEL_MASK));
    4be4:	9b02      	ldr	r3, [sp, #8]
    4be6:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    4bea:	9302      	str	r3, [sp, #8]
    RegValue |= SIM_CHIPCTL_TRACECLK_SEL(SelectorValue);
    4bec:	9b03      	ldr	r3, [sp, #12]
    4bee:	031b      	lsls	r3, r3, #12
    4bf0:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    4bf4:	9a02      	ldr	r2, [sp, #8]
    4bf6:	4313      	orrs	r3, r2
    4bf8:	9302      	str	r3, [sp, #8]
    IP_SIM->CHIPCTL = (uint32)RegValue;
    4bfa:	4a04      	ldr	r2, [pc, #16]	; (4c0c <Clock_Ip_SetSimTraceSel_TrustedCall+0x3c>)
    4bfc:	9b02      	ldr	r3, [sp, #8]
    4bfe:	6053      	str	r3, [r2, #4]
}
    4c00:	bf00      	nop
    4c02:	b004      	add	sp, #16
    4c04:	4770      	bx	lr
    4c06:	bf00      	nop
    4c08:	000182bc 	.word	0x000182bc
    4c0c:	40048000 	.word	0x40048000

00004c10 <DisableSafeClock>:

#define MCU_START_SEC_CODE
#include "Mcu_MemMap.h"

static void DisableSafeClock(Clock_Ip_ClockConfigType const * Config)
{
    4c10:	b500      	push	{lr}
    4c12:	b085      	sub	sp, #20
    4c14:	9001      	str	r0, [sp, #4]
    uint32 Index;
    boolean FircConfigFound = FALSE;
    4c16:	2300      	movs	r3, #0
    4c18:	f88d 300b 	strb.w	r3, [sp, #11]

    if (Config != NULL_PTR)
    4c1c:	9b01      	ldr	r3, [sp, #4]
    4c1e:	2b00      	cmp	r3, #0
    4c20:	d037      	beq.n	4c92 <DisableSafeClock+0x82>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    4c22:	2300      	movs	r3, #0
    4c24:	9303      	str	r3, [sp, #12]
    4c26:	e02b      	b.n	4c80 <DisableSafeClock+0x70>
        {
            if (Clock_Ip_apConfig->Ircoscs[Index].Name == FIRC_CLK)
    4c28:	4b29      	ldr	r3, [pc, #164]	; (4cd0 <DisableSafeClock+0xc0>)
    4c2a:	6819      	ldr	r1, [r3, #0]
    4c2c:	9a03      	ldr	r2, [sp, #12]
    4c2e:	4613      	mov	r3, r2
    4c30:	005b      	lsls	r3, r3, #1
    4c32:	4413      	add	r3, r2
    4c34:	009b      	lsls	r3, r3, #2
    4c36:	440b      	add	r3, r1
    4c38:	3314      	adds	r3, #20
    4c3a:	681b      	ldr	r3, [r3, #0]
    4c3c:	2b05      	cmp	r3, #5
    4c3e:	d11c      	bne.n	4c7a <DisableSafeClock+0x6a>
            {
                FircConfigFound = TRUE;
    4c40:	2301      	movs	r3, #1
    4c42:	f88d 300b 	strb.w	r3, [sp, #11]
                if (Clock_Ip_apConfig->Ircoscs[Index].Enable == FALSE)
    4c46:	4b22      	ldr	r3, [pc, #136]	; (4cd0 <DisableSafeClock+0xc0>)
    4c48:	6819      	ldr	r1, [r3, #0]
    4c4a:	9a03      	ldr	r2, [sp, #12]
    4c4c:	4613      	mov	r3, r2
    4c4e:	005b      	lsls	r3, r3, #1
    4c50:	4413      	add	r3, r2
    4c52:	009b      	lsls	r3, r3, #2
    4c54:	440b      	add	r3, r1
    4c56:	3318      	adds	r3, #24
    4c58:	881b      	ldrh	r3, [r3, #0]
    4c5a:	2b00      	cmp	r3, #0
    4c5c:	d118      	bne.n	4c90 <DisableSafeClock+0x80>
                {
                    /* Disable FIRC according to configuration */
                    Clock_Ip_axIntOscCallbacks[Clock_Ip_au8IrcoscCallbackIndex[CLOCK_IP_FIRCOSC]].Disable(FIRC_CLK);
    4c5e:	4b1d      	ldr	r3, [pc, #116]	; (4cd4 <DisableSafeClock+0xc4>)
    4c60:	791b      	ldrb	r3, [r3, #4]
    4c62:	4619      	mov	r1, r3
    4c64:	4a1c      	ldr	r2, [pc, #112]	; (4cd8 <DisableSafeClock+0xc8>)
    4c66:	460b      	mov	r3, r1
    4c68:	005b      	lsls	r3, r3, #1
    4c6a:	440b      	add	r3, r1
    4c6c:	009b      	lsls	r3, r3, #2
    4c6e:	4413      	add	r3, r2
    4c70:	3308      	adds	r3, #8
    4c72:	681b      	ldr	r3, [r3, #0]
    4c74:	2005      	movs	r0, #5
    4c76:	4798      	blx	r3
                }
                break;
    4c78:	e00a      	b.n	4c90 <DisableSafeClock+0x80>
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    4c7a:	9b03      	ldr	r3, [sp, #12]
    4c7c:	3301      	adds	r3, #1
    4c7e:	9303      	str	r3, [sp, #12]
    4c80:	4b13      	ldr	r3, [pc, #76]	; (4cd0 <DisableSafeClock+0xc0>)
    4c82:	681b      	ldr	r3, [r3, #0]
    4c84:	7a1b      	ldrb	r3, [r3, #8]
    4c86:	461a      	mov	r2, r3
    4c88:	9b03      	ldr	r3, [sp, #12]
    4c8a:	4293      	cmp	r3, r2
    4c8c:	d3cc      	bcc.n	4c28 <DisableSafeClock+0x18>
    4c8e:	e000      	b.n	4c92 <DisableSafeClock+0x82>
                break;
    4c90:	bf00      	nop
            }
        }
    }

    if ((FircConfigFound == FALSE) && (Clock_Ip_bFircWasEnabledBeforeMcuInit == FALSE))
    4c92:	f89d 300b 	ldrb.w	r3, [sp, #11]
    4c96:	f083 0301 	eor.w	r3, r3, #1
    4c9a:	b2db      	uxtb	r3, r3
    4c9c:	2b00      	cmp	r3, #0
    4c9e:	d013      	beq.n	4cc8 <DisableSafeClock+0xb8>
    4ca0:	4b0e      	ldr	r3, [pc, #56]	; (4cdc <DisableSafeClock+0xcc>)
    4ca2:	781b      	ldrb	r3, [r3, #0]
    4ca4:	f083 0301 	eor.w	r3, r3, #1
    4ca8:	b2db      	uxtb	r3, r3
    4caa:	2b00      	cmp	r3, #0
    4cac:	d00c      	beq.n	4cc8 <DisableSafeClock+0xb8>
    {
        /* Disable FIRC according to configuration */
        Clock_Ip_axIntOscCallbacks[Clock_Ip_au8IrcoscCallbackIndex[CLOCK_IP_FIRCOSC]].Disable(FIRC_CLK);
    4cae:	4b09      	ldr	r3, [pc, #36]	; (4cd4 <DisableSafeClock+0xc4>)
    4cb0:	791b      	ldrb	r3, [r3, #4]
    4cb2:	4619      	mov	r1, r3
    4cb4:	4a08      	ldr	r2, [pc, #32]	; (4cd8 <DisableSafeClock+0xc8>)
    4cb6:	460b      	mov	r3, r1
    4cb8:	005b      	lsls	r3, r3, #1
    4cba:	440b      	add	r3, r1
    4cbc:	009b      	lsls	r3, r3, #2
    4cbe:	4413      	add	r3, r2
    4cc0:	3308      	adds	r3, #8
    4cc2:	681b      	ldr	r3, [r3, #0]
    4cc4:	2005      	movs	r0, #5
    4cc6:	4798      	blx	r3
    }
}
    4cc8:	bf00      	nop
    4cca:	b005      	add	sp, #20
    4ccc:	f85d fb04 	ldr.w	pc, [sp], #4
    4cd0:	1fff8ba0 	.word	0x1fff8ba0
    4cd4:	00017f3c 	.word	0x00017f3c
    4cd8:	0001856c 	.word	0x0001856c
    4cdc:	1fff8b18 	.word	0x1fff8b18

00004ce0 <SetFircToResetValue_TrustedCall>:

void SetFircToResetValue_TrustedCall(void)
{
        /* Range is 48Mhz. */
        IP_SCG->FIRCCFG = SCG_FIRCCFG_RANGE(0U);
    4ce0:	4b06      	ldr	r3, [pc, #24]	; (4cfc <SetFircToResetValue_TrustedCall+0x1c>)
    4ce2:	2200      	movs	r2, #0
    4ce4:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308

        /* Enable clock, Regulator is enabled. */
        IP_SCG->FIRCCSR |= (SCG_FIRCCSR_FIRCEN(1U) | SCG_FIRCCSR_FIRCREGOFF(0U));
    4ce8:	4b04      	ldr	r3, [pc, #16]	; (4cfc <SetFircToResetValue_TrustedCall+0x1c>)
    4cea:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4cee:	4a03      	ldr	r2, [pc, #12]	; (4cfc <SetFircToResetValue_TrustedCall+0x1c>)
    4cf0:	f043 0301 	orr.w	r3, r3, #1
    4cf4:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
}
    4cf8:	bf00      	nop
    4cfa:	4770      	bx	lr
    4cfc:	40064000 	.word	0x40064000

00004d00 <SetSimLpoclksRegister_TrustedCall>:

void SetSimLpoclksRegister_TrustedCall(Clock_Ip_ClockConfigType const *Config)
{
    4d00:	b084      	sub	sp, #16
    4d02:	9001      	str	r0, [sp, #4]
    uint32 SimLpoValue = 3U; /* Reset value of SIM_LPOCLKS register */
    4d04:	2303      	movs	r3, #3
    4d06:	9303      	str	r3, [sp, #12]
    uint32 Index;

    /* The LPOCLKS register is a write-once register so configuration will be written here*/

    for (Index = 0U; Index < Config->SelectorsCount; Index++)
    4d08:	2300      	movs	r3, #0
    4d0a:	9302      	str	r3, [sp, #8]
    4d0c:	e028      	b.n	4d60 <SetSimLpoclksRegister_TrustedCall+0x60>
    {
        /* Selector for RTC_CLK */
        if (RTC_CLK == Config->Selectors[Index].Name)
    4d0e:	9b01      	ldr	r3, [sp, #4]
    4d10:	9a02      	ldr	r2, [sp, #8]
    4d12:	320d      	adds	r2, #13
    4d14:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    4d18:	2b28      	cmp	r3, #40	; 0x28
    4d1a:	d10b      	bne.n	4d34 <SetSimLpoclksRegister_TrustedCall+0x34>
        {
            SimLpoValue |= ((uint32)(Clock_Ip_au16SelectorEntryHardwareValue[Config->Selectors[Index].Value]) << SIM_LPOCLKS_RTCCLKSEL_SHIFT);
    4d1c:	9a01      	ldr	r2, [sp, #4]
    4d1e:	9b02      	ldr	r3, [sp, #8]
    4d20:	330d      	adds	r3, #13
    4d22:	00db      	lsls	r3, r3, #3
    4d24:	4413      	add	r3, r2
    4d26:	685b      	ldr	r3, [r3, #4]
    4d28:	4a2b      	ldr	r2, [pc, #172]	; (4dd8 <SetSimLpoclksRegister_TrustedCall+0xd8>)
    4d2a:	5cd3      	ldrb	r3, [r2, r3]
    4d2c:	011b      	lsls	r3, r3, #4
    4d2e:	9a03      	ldr	r2, [sp, #12]
    4d30:	4313      	orrs	r3, r2
    4d32:	9303      	str	r3, [sp, #12]
        }

         /* Selector for LPO_CLK */
        if (LPO_CLK == Config->Selectors[Index].Name)
    4d34:	9b01      	ldr	r3, [sp, #4]
    4d36:	9a02      	ldr	r2, [sp, #8]
    4d38:	320d      	adds	r2, #13
    4d3a:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    4d3e:	2b29      	cmp	r3, #41	; 0x29
    4d40:	d10b      	bne.n	4d5a <SetSimLpoclksRegister_TrustedCall+0x5a>
        {
            SimLpoValue |= ((uint32)(Clock_Ip_au8SelectorEntrySIMHardwareValue[Config->Selectors[Index].Value]) << SIM_LPOCLKS_LPOCLKSEL_SHIFT);
    4d42:	9a01      	ldr	r2, [sp, #4]
    4d44:	9b02      	ldr	r3, [sp, #8]
    4d46:	330d      	adds	r3, #13
    4d48:	00db      	lsls	r3, r3, #3
    4d4a:	4413      	add	r3, r2
    4d4c:	685b      	ldr	r3, [r3, #4]
    4d4e:	4a23      	ldr	r2, [pc, #140]	; (4ddc <SetSimLpoclksRegister_TrustedCall+0xdc>)
    4d50:	5cd3      	ldrb	r3, [r2, r3]
    4d52:	009b      	lsls	r3, r3, #2
    4d54:	9a03      	ldr	r2, [sp, #12]
    4d56:	4313      	orrs	r3, r2
    4d58:	9303      	str	r3, [sp, #12]
    for (Index = 0U; Index < Config->SelectorsCount; Index++)
    4d5a:	9b02      	ldr	r3, [sp, #8]
    4d5c:	3301      	adds	r3, #1
    4d5e:	9302      	str	r3, [sp, #8]
    4d60:	9b01      	ldr	r3, [sp, #4]
    4d62:	7adb      	ldrb	r3, [r3, #11]
    4d64:	461a      	mov	r2, r3
    4d66:	9b02      	ldr	r3, [sp, #8]
    4d68:	4293      	cmp	r3, r2
    4d6a:	d3d0      	bcc.n	4d0e <SetSimLpoclksRegister_TrustedCall+0xe>
        }
    }

    for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    4d6c:	2300      	movs	r3, #0
    4d6e:	9302      	str	r3, [sp, #8]
    4d70:	e026      	b.n	4dc0 <SetSimLpoclksRegister_TrustedCall+0xc0>
    {
        /* Gate for LPO_32K_CLK */
        if (LPO_32K_CLK == Config->Gates[Index].Name)
    4d72:	9a01      	ldr	r2, [sp, #4]
    4d74:	9b02      	ldr	r3, [sp, #8]
    4d76:	334e      	adds	r3, #78	; 0x4e
    4d78:	00db      	lsls	r3, r3, #3
    4d7a:	4413      	add	r3, r2
    4d7c:	685b      	ldr	r3, [r3, #4]
    4d7e:	2b12      	cmp	r3, #18
    4d80:	d109      	bne.n	4d96 <SetSimLpoclksRegister_TrustedCall+0x96>
        {
             SimLpoValue |= ((uint32)(Config->Gates[Index].Enable) << SIM_LPOCLKS_LPO32KCLKEN_SHIFT);
    4d82:	9a01      	ldr	r2, [sp, #4]
    4d84:	9b02      	ldr	r3, [sp, #8]
    4d86:	334e      	adds	r3, #78	; 0x4e
    4d88:	00db      	lsls	r3, r3, #3
    4d8a:	4413      	add	r3, r2
    4d8c:	891b      	ldrh	r3, [r3, #8]
    4d8e:	005b      	lsls	r3, r3, #1
    4d90:	9a03      	ldr	r2, [sp, #12]
    4d92:	4313      	orrs	r3, r2
    4d94:	9303      	str	r3, [sp, #12]
        }

         /* Gate for LPO_1K_CLK */
        if (LPO_1K_CLK == Config->Gates[Index].Name)
    4d96:	9a01      	ldr	r2, [sp, #4]
    4d98:	9b02      	ldr	r3, [sp, #8]
    4d9a:	334e      	adds	r3, #78	; 0x4e
    4d9c:	00db      	lsls	r3, r3, #3
    4d9e:	4413      	add	r3, r2
    4da0:	685b      	ldr	r3, [r3, #4]
    4da2:	2b13      	cmp	r3, #19
    4da4:	d109      	bne.n	4dba <SetSimLpoclksRegister_TrustedCall+0xba>
        {
            SimLpoValue |= ((uint32)(Config->Gates[Index].Enable) << SIM_LPOCLKS_LPO1KCLKEN_SHIFT);
    4da6:	9a01      	ldr	r2, [sp, #4]
    4da8:	9b02      	ldr	r3, [sp, #8]
    4daa:	334e      	adds	r3, #78	; 0x4e
    4dac:	00db      	lsls	r3, r3, #3
    4dae:	4413      	add	r3, r2
    4db0:	891b      	ldrh	r3, [r3, #8]
    4db2:	461a      	mov	r2, r3
    4db4:	9b03      	ldr	r3, [sp, #12]
    4db6:	4313      	orrs	r3, r2
    4db8:	9303      	str	r3, [sp, #12]
    for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    4dba:	9b02      	ldr	r3, [sp, #8]
    4dbc:	3301      	adds	r3, #1
    4dbe:	9302      	str	r3, [sp, #8]
    4dc0:	9b01      	ldr	r3, [sp, #4]
    4dc2:	7c1b      	ldrb	r3, [r3, #16]
    4dc4:	461a      	mov	r2, r3
    4dc6:	9b02      	ldr	r3, [sp, #8]
    4dc8:	4293      	cmp	r3, r2
    4dca:	d3d2      	bcc.n	4d72 <SetSimLpoclksRegister_TrustedCall+0x72>
        }
    }

    IP_SIM->LPOCLKS = SimLpoValue;
    4dcc:	4a04      	ldr	r2, [pc, #16]	; (4de0 <SetSimLpoclksRegister_TrustedCall+0xe0>)
    4dce:	9b03      	ldr	r3, [sp, #12]
    4dd0:	6113      	str	r3, [r2, #16]
}
    4dd2:	bf00      	nop
    4dd4:	b004      	add	sp, #16
    4dd6:	4770      	bx	lr
    4dd8:	000182bc 	.word	0x000182bc
    4ddc:	00018374 	.word	0x00018374
    4de0:	40048000 	.word	0x40048000

00004de4 <Clock_Ip_SpecificPlatformInitClock>:
}
#endif


static void Clock_Ip_SpecificPlatformInitClock(Clock_Ip_ClockConfigType const * Config)
{
    4de4:	b500      	push	{lr}
    4de6:	b089      	sub	sp, #36	; 0x24
    4de8:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    4dea:	2300      	movs	r3, #0
    4dec:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;

    (void)Clock_Ip_FreqIds;
    Clock_Ip_apConfig = Config;
    4df0:	4a21      	ldr	r2, [pc, #132]	; (4e78 <Clock_Ip_SpecificPlatformInitClock+0x94>)
    4df2:	9b01      	ldr	r3, [sp, #4]
    4df4:	6013      	str	r3, [r2, #0]

    /* Clocks cannot be configured while the chip is in other mode than RUN_MODE */
    CLOCK_IP_DEV_ASSERT(CLOCK_IP_RUN_POWER_MODE_STATUS == ((IP_SMC->PMSTAT & SMC_PMSTAT_PMSTAT_MASK) >> SMC_PMSTAT_PMSTAT_SHIFT));

    /* Check whether FIRC is disabled, enable it in this case. */
    if ((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCEN_MASK) == 0U)
    4df6:	4b21      	ldr	r3, [pc, #132]	; (4e7c <Clock_Ip_SpecificPlatformInitClock+0x98>)
    4df8:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4dfc:	f003 0301 	and.w	r3, r3, #1
    4e00:	2b00      	cmp	r3, #0
    4e02:	d12e      	bne.n	4e62 <Clock_Ip_SpecificPlatformInitClock+0x7e>
    {
        Clock_Ip_bFircWasEnabledBeforeMcuInit = FALSE;
    4e04:	4b1e      	ldr	r3, [pc, #120]	; (4e80 <Clock_Ip_SpecificPlatformInitClock+0x9c>)
    4e06:	2200      	movs	r2, #0
    4e08:	701a      	strb	r2, [r3, #0]

    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call(SetFircToResetValue_TrustedCall);
      #else
        SetFircToResetValue_TrustedCall();
    4e0a:	f7ff ff69 	bl	4ce0 <SetFircToResetValue_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */

        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    4e0e:	aa03      	add	r2, sp, #12
    4e10:	a904      	add	r1, sp, #16
    4e12:	a805      	add	r0, sp, #20
    4e14:	f24c 3350 	movw	r3, #50000	; 0xc350
    4e18:	f7fe f8ae 	bl	2f78 <Clock_Ip_StartTimeout>
        /* Wait until ircosc is locked */
        do
        {
            IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    4e1c:	4b17      	ldr	r3, [pc, #92]	; (4e7c <Clock_Ip_SpecificPlatformInitClock+0x98>)
    4e1e:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4e22:	0e1b      	lsrs	r3, r3, #24
    4e24:	f003 0301 	and.w	r3, r3, #1
    4e28:	9306      	str	r3, [sp, #24]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    4e2a:	9a03      	ldr	r2, [sp, #12]
    4e2c:	a904      	add	r1, sp, #16
    4e2e:	ab05      	add	r3, sp, #20
    4e30:	4618      	mov	r0, r3
    4e32:	f7fe f8bb 	bl	2fac <Clock_Ip_TimeoutExpired>
    4e36:	4603      	mov	r3, r0
    4e38:	f88d 301f 	strb.w	r3, [sp, #31]
        }
        while ((IrcoscStatus == 0U) && (FALSE == TimeoutOccurred));
    4e3c:	9b06      	ldr	r3, [sp, #24]
    4e3e:	2b00      	cmp	r3, #0
    4e40:	d106      	bne.n	4e50 <Clock_Ip_SpecificPlatformInitClock+0x6c>
    4e42:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4e46:	f083 0301 	eor.w	r3, r3, #1
    4e4a:	b2db      	uxtb	r3, r3
    4e4c:	2b00      	cmp	r3, #0
    4e4e:	d1e5      	bne.n	4e1c <Clock_Ip_SpecificPlatformInitClock+0x38>

        if (FALSE != TimeoutOccurred)
    4e50:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4e54:	2b00      	cmp	r3, #0
    4e56:	d007      	beq.n	4e68 <Clock_Ip_SpecificPlatformInitClock+0x84>
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, FIRC_CLK);
    4e58:	2105      	movs	r1, #5
    4e5a:	2001      	movs	r0, #1
    4e5c:	f7fe f87c 	bl	2f58 <Clock_Ip_ReportClockErrors>
    4e60:	e002      	b.n	4e68 <Clock_Ip_SpecificPlatformInitClock+0x84>
        }
    }
    else
    {
        Clock_Ip_bFircWasEnabledBeforeMcuInit = TRUE;
    4e62:	4b07      	ldr	r3, [pc, #28]	; (4e80 <Clock_Ip_SpecificPlatformInitClock+0x9c>)
    4e64:	2201      	movs	r2, #1
    4e66:	701a      	strb	r2, [r3, #0]

    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
        #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(SetSimLpoclksRegister_TrustedCall,(Config));
        #else
    SetSimLpoclksRegister_TrustedCall(Config);
    4e68:	9801      	ldr	r0, [sp, #4]
    4e6a:	f7ff ff49 	bl	4d00 <SetSimLpoclksRegister_TrustedCall>
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */

    #if defined(CLOCK_IP_HAS_FIRC_MON1_CLK) || defined(CLOCK_IP_HAS_FIRC_MON2_CLK)
    Clock_Ip_PllPowerClockIp();
    #endif
}
    4e6e:	bf00      	nop
    4e70:	b009      	add	sp, #36	; 0x24
    4e72:	f85d fb04 	ldr.w	pc, [sp], #4
    4e76:	bf00      	nop
    4e78:	1fff8ba0 	.word	0x1fff8ba0
    4e7c:	40064000 	.word	0x40064000
    4e80:	1fff8b18 	.word	0x1fff8b18

00004e84 <getFircConfig>:

/**
* @brief            This function will get current configuration of FIRC.
*/
static const Clock_Ip_IrcoscConfigType *getFircConfig(void)
{
    4e84:	b082      	sub	sp, #8
    uint32 Index;

    const Clock_Ip_IrcoscConfigType *ReturnValue = NULL_PTR;
    4e86:	2300      	movs	r3, #0
    4e88:	9300      	str	r3, [sp, #0]

    if (Clock_Ip_apConfig != NULL_PTR)
    4e8a:	4b29      	ldr	r3, [pc, #164]	; (4f30 <getFircConfig+0xac>)
    4e8c:	681b      	ldr	r3, [r3, #0]
    4e8e:	2b00      	cmp	r3, #0
    4e90:	d024      	beq.n	4edc <getFircConfig+0x58>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    4e92:	2300      	movs	r3, #0
    4e94:	9301      	str	r3, [sp, #4]
    4e96:	e01a      	b.n	4ece <getFircConfig+0x4a>
        {
            if (Clock_Ip_apConfig->Ircoscs[Index].Name == FIRC_CLK)
    4e98:	4b25      	ldr	r3, [pc, #148]	; (4f30 <getFircConfig+0xac>)
    4e9a:	6819      	ldr	r1, [r3, #0]
    4e9c:	9a01      	ldr	r2, [sp, #4]
    4e9e:	4613      	mov	r3, r2
    4ea0:	005b      	lsls	r3, r3, #1
    4ea2:	4413      	add	r3, r2
    4ea4:	009b      	lsls	r3, r3, #2
    4ea6:	440b      	add	r3, r1
    4ea8:	3314      	adds	r3, #20
    4eaa:	681b      	ldr	r3, [r3, #0]
    4eac:	2b05      	cmp	r3, #5
    4eae:	d10b      	bne.n	4ec8 <getFircConfig+0x44>
            {
                ReturnValue = &Clock_Ip_apConfig->Ircoscs[Index];
    4eb0:	4b1f      	ldr	r3, [pc, #124]	; (4f30 <getFircConfig+0xac>)
    4eb2:	6819      	ldr	r1, [r3, #0]
    4eb4:	9a01      	ldr	r2, [sp, #4]
    4eb6:	4613      	mov	r3, r2
    4eb8:	005b      	lsls	r3, r3, #1
    4eba:	4413      	add	r3, r2
    4ebc:	009b      	lsls	r3, r3, #2
    4ebe:	3310      	adds	r3, #16
    4ec0:	440b      	add	r3, r1
    4ec2:	3304      	adds	r3, #4
    4ec4:	9300      	str	r3, [sp, #0]
                break;
    4ec6:	e009      	b.n	4edc <getFircConfig+0x58>
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    4ec8:	9b01      	ldr	r3, [sp, #4]
    4eca:	3301      	adds	r3, #1
    4ecc:	9301      	str	r3, [sp, #4]
    4ece:	4b18      	ldr	r3, [pc, #96]	; (4f30 <getFircConfig+0xac>)
    4ed0:	681b      	ldr	r3, [r3, #0]
    4ed2:	7a1b      	ldrb	r3, [r3, #8]
    4ed4:	461a      	mov	r2, r3
    4ed6:	9b01      	ldr	r3, [sp, #4]
    4ed8:	4293      	cmp	r3, r2
    4eda:	d3dd      	bcc.n	4e98 <getFircConfig+0x14>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    4edc:	9b00      	ldr	r3, [sp, #0]
    4ede:	2b00      	cmp	r3, #0
    4ee0:	d121      	bne.n	4f26 <getFircConfig+0xa2>
    {
        ReturnValue = &FircConfiguration;
    4ee2:	4b14      	ldr	r3, [pc, #80]	; (4f34 <getFircConfig+0xb0>)
    4ee4:	9300      	str	r3, [sp, #0]
        FircConfiguration.Name = FIRC_CLK;
    4ee6:	4b13      	ldr	r3, [pc, #76]	; (4f34 <getFircConfig+0xb0>)
    4ee8:	2205      	movs	r2, #5
    4eea:	601a      	str	r2, [r3, #0]
        FircConfiguration.Enable = (uint16)(IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCEN_MASK) >> SCG_FIRCCSR_FIRCEN_SHIFT;
    4eec:	4b12      	ldr	r3, [pc, #72]	; (4f38 <getFircConfig+0xb4>)
    4eee:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4ef2:	b29b      	uxth	r3, r3
    4ef4:	f003 0301 	and.w	r3, r3, #1
    4ef8:	b29a      	uxth	r2, r3
    4efa:	4b0e      	ldr	r3, [pc, #56]	; (4f34 <getFircConfig+0xb0>)
    4efc:	809a      	strh	r2, [r3, #4]
        FircConfiguration.Range = (uint8)(IP_SCG->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT;
    4efe:	4b0e      	ldr	r3, [pc, #56]	; (4f38 <getFircConfig+0xb4>)
    4f00:	f8d3 3308 	ldr.w	r3, [r3, #776]	; 0x308
    4f04:	b2db      	uxtb	r3, r3
    4f06:	f003 0303 	and.w	r3, r3, #3
    4f0a:	b2da      	uxtb	r2, r3
    4f0c:	4b09      	ldr	r3, [pc, #36]	; (4f34 <getFircConfig+0xb0>)
    4f0e:	71da      	strb	r2, [r3, #7]
        FircConfiguration.Regulator = (uint8)(IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCREGOFF_MASK) >> SCG_FIRCCSR_FIRCREGOFF_SHIFT;
    4f10:	4b09      	ldr	r3, [pc, #36]	; (4f38 <getFircConfig+0xb4>)
    4f12:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4f16:	b2db      	uxtb	r3, r3
    4f18:	10db      	asrs	r3, r3, #3
    4f1a:	b2db      	uxtb	r3, r3
    4f1c:	f003 0301 	and.w	r3, r3, #1
    4f20:	b2da      	uxtb	r2, r3
    4f22:	4b04      	ldr	r3, [pc, #16]	; (4f34 <getFircConfig+0xb0>)
    4f24:	719a      	strb	r2, [r3, #6]
    }

    return ReturnValue;
    4f26:	9b00      	ldr	r3, [sp, #0]
}
    4f28:	4618      	mov	r0, r3
    4f2a:	b002      	add	sp, #8
    4f2c:	4770      	bx	lr
    4f2e:	bf00      	nop
    4f30:	1fff8ba0 	.word	0x1fff8ba0
    4f34:	1fff8c0c 	.word	0x1fff8c0c
    4f38:	40064000 	.word	0x40064000

00004f3c <getSoscConfig>:

/**
* @brief            This function will get current configuration of SOSC.
*/
static const Clock_Ip_XoscConfigType *getSoscConfig(void)
{
    4f3c:	b082      	sub	sp, #8
    uint32 Index;

    const Clock_Ip_XoscConfigType *ReturnValue = NULL_PTR;
    4f3e:	2300      	movs	r3, #0
    4f40:	9300      	str	r3, [sp, #0]

    if (Clock_Ip_apConfig != NULL_PTR)
    4f42:	4b20      	ldr	r3, [pc, #128]	; (4fc4 <getSoscConfig+0x88>)
    4f44:	681b      	ldr	r3, [r3, #0]
    4f46:	2b00      	cmp	r3, #0
    4f48:	d024      	beq.n	4f94 <getSoscConfig+0x58>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->XoscsCount; Index++)
    4f4a:	2300      	movs	r3, #0
    4f4c:	9301      	str	r3, [sp, #4]
    4f4e:	e01a      	b.n	4f86 <getSoscConfig+0x4a>
        {
            if (Clock_Ip_apConfig->Xoscs[Index].Name == SOSC_CLK)
    4f50:	4b1c      	ldr	r3, [pc, #112]	; (4fc4 <getSoscConfig+0x88>)
    4f52:	6819      	ldr	r1, [r3, #0]
    4f54:	9a01      	ldr	r2, [sp, #4]
    4f56:	4613      	mov	r3, r2
    4f58:	009b      	lsls	r3, r3, #2
    4f5a:	4413      	add	r3, r2
    4f5c:	009b      	lsls	r3, r3, #2
    4f5e:	440b      	add	r3, r1
    4f60:	332c      	adds	r3, #44	; 0x2c
    4f62:	681b      	ldr	r3, [r3, #0]
    4f64:	2b08      	cmp	r3, #8
    4f66:	d10b      	bne.n	4f80 <getSoscConfig+0x44>
            {
                ReturnValue = &Clock_Ip_apConfig->Xoscs[Index];
    4f68:	4b16      	ldr	r3, [pc, #88]	; (4fc4 <getSoscConfig+0x88>)
    4f6a:	6819      	ldr	r1, [r3, #0]
    4f6c:	9a01      	ldr	r2, [sp, #4]
    4f6e:	4613      	mov	r3, r2
    4f70:	009b      	lsls	r3, r3, #2
    4f72:	4413      	add	r3, r2
    4f74:	009b      	lsls	r3, r3, #2
    4f76:	3328      	adds	r3, #40	; 0x28
    4f78:	440b      	add	r3, r1
    4f7a:	3304      	adds	r3, #4
    4f7c:	9300      	str	r3, [sp, #0]
                break;
    4f7e:	e009      	b.n	4f94 <getSoscConfig+0x58>
        for (Index = 0U; Index < Clock_Ip_apConfig->XoscsCount; Index++)
    4f80:	9b01      	ldr	r3, [sp, #4]
    4f82:	3301      	adds	r3, #1
    4f84:	9301      	str	r3, [sp, #4]
    4f86:	4b0f      	ldr	r3, [pc, #60]	; (4fc4 <getSoscConfig+0x88>)
    4f88:	681b      	ldr	r3, [r3, #0]
    4f8a:	7a5b      	ldrb	r3, [r3, #9]
    4f8c:	461a      	mov	r2, r3
    4f8e:	9b01      	ldr	r3, [sp, #4]
    4f90:	4293      	cmp	r3, r2
    4f92:	d3dd      	bcc.n	4f50 <getSoscConfig+0x14>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    4f94:	9b00      	ldr	r3, [sp, #0]
    4f96:	2b00      	cmp	r3, #0
    4f98:	d110      	bne.n	4fbc <getSoscConfig+0x80>
    {
        ReturnValue = &SoscConfiguration;
    4f9a:	4b0b      	ldr	r3, [pc, #44]	; (4fc8 <getSoscConfig+0x8c>)
    4f9c:	9300      	str	r3, [sp, #0]
        SoscConfiguration.Name = SOSC_CLK;
    4f9e:	4b0a      	ldr	r3, [pc, #40]	; (4fc8 <getSoscConfig+0x8c>)
    4fa0:	2208      	movs	r2, #8
    4fa2:	601a      	str	r2, [r3, #0]
        SoscConfiguration.Enable = (uint16)(IP_SCG->SOSCCSR & SCG_SOSCCSR_SOSCEN_MASK) >> SCG_SOSCCSR_SOSCEN_SHIFT;
    4fa4:	4b09      	ldr	r3, [pc, #36]	; (4fcc <getSoscConfig+0x90>)
    4fa6:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    4faa:	b29b      	uxth	r3, r3
    4fac:	f003 0301 	and.w	r3, r3, #1
    4fb0:	b29a      	uxth	r2, r3
    4fb2:	4b05      	ldr	r3, [pc, #20]	; (4fc8 <getSoscConfig+0x8c>)
    4fb4:	811a      	strh	r2, [r3, #8]
        SoscConfiguration.Freq = CLOCK_IP_DEFAULT_SOSC_FREQUENCY;
    4fb6:	4b04      	ldr	r3, [pc, #16]	; (4fc8 <getSoscConfig+0x8c>)
    4fb8:	4a05      	ldr	r2, [pc, #20]	; (4fd0 <getSoscConfig+0x94>)
    4fba:	605a      	str	r2, [r3, #4]
    }

    return ReturnValue;
    4fbc:	9b00      	ldr	r3, [sp, #0]
}
    4fbe:	4618      	mov	r0, r3
    4fc0:	b002      	add	sp, #8
    4fc2:	4770      	bx	lr
    4fc4:	1fff8ba0 	.word	0x1fff8ba0
    4fc8:	1fff8c18 	.word	0x1fff8c18
    4fcc:	40064000 	.word	0x40064000
    4fd0:	02625a00 	.word	0x02625a00

00004fd4 <getSpllConfig>:
#if defined(CLOCK_IP_HAS_SPLL_CLK)
/**
* @brief            This function will get current configuration of SPLL.
*/
static const Clock_Ip_PllConfigType *getSpllConfig(void)
{
    4fd4:	b082      	sub	sp, #8
    uint32 Index;
    const Clock_Ip_PllConfigType *ReturnValue = NULL_PTR;
    4fd6:	2300      	movs	r3, #0
    4fd8:	9300      	str	r3, [sp, #0]

    if (Clock_Ip_apConfig != NULL_PTR)
    4fda:	4b28      	ldr	r3, [pc, #160]	; (507c <getSpllConfig+0xa8>)
    4fdc:	681b      	ldr	r3, [r3, #0]
    4fde:	2b00      	cmp	r3, #0
    4fe0:	d023      	beq.n	502a <getSpllConfig+0x56>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->PllsCount; Index++)
    4fe2:	2300      	movs	r3, #0
    4fe4:	9301      	str	r3, [sp, #4]
    4fe6:	e019      	b.n	501c <getSpllConfig+0x48>
        {
            if (Clock_Ip_apConfig->Plls[Index].Name == SPLL_CLK)
    4fe8:	4b24      	ldr	r3, [pc, #144]	; (507c <getSpllConfig+0xa8>)
    4fea:	6819      	ldr	r1, [r3, #0]
    4fec:	9a01      	ldr	r2, [sp, #4]
    4fee:	4613      	mov	r3, r2
    4ff0:	009b      	lsls	r3, r3, #2
    4ff2:	4413      	add	r3, r2
    4ff4:	00db      	lsls	r3, r3, #3
    4ff6:	440b      	add	r3, r1
    4ff8:	3340      	adds	r3, #64	; 0x40
    4ffa:	681b      	ldr	r3, [r3, #0]
    4ffc:	2b09      	cmp	r3, #9
    4ffe:	d10a      	bne.n	5016 <getSpllConfig+0x42>
            {
                ReturnValue = &Clock_Ip_apConfig->Plls[Index];
    5000:	4b1e      	ldr	r3, [pc, #120]	; (507c <getSpllConfig+0xa8>)
    5002:	6819      	ldr	r1, [r3, #0]
    5004:	9a01      	ldr	r2, [sp, #4]
    5006:	4613      	mov	r3, r2
    5008:	009b      	lsls	r3, r3, #2
    500a:	4413      	add	r3, r2
    500c:	00db      	lsls	r3, r3, #3
    500e:	3340      	adds	r3, #64	; 0x40
    5010:	440b      	add	r3, r1
    5012:	9300      	str	r3, [sp, #0]
                break;
    5014:	e009      	b.n	502a <getSpllConfig+0x56>
        for (Index = 0U; Index < Clock_Ip_apConfig->PllsCount; Index++)
    5016:	9b01      	ldr	r3, [sp, #4]
    5018:	3301      	adds	r3, #1
    501a:	9301      	str	r3, [sp, #4]
    501c:	4b17      	ldr	r3, [pc, #92]	; (507c <getSpllConfig+0xa8>)
    501e:	681b      	ldr	r3, [r3, #0]
    5020:	7a9b      	ldrb	r3, [r3, #10]
    5022:	461a      	mov	r2, r3
    5024:	9b01      	ldr	r3, [sp, #4]
    5026:	4293      	cmp	r3, r2
    5028:	d3de      	bcc.n	4fe8 <getSpllConfig+0x14>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    502a:	9b00      	ldr	r3, [sp, #0]
    502c:	2b00      	cmp	r3, #0
    502e:	d121      	bne.n	5074 <getSpllConfig+0xa0>
    {
        ReturnValue = &SpllConfiguration;
    5030:	4b13      	ldr	r3, [pc, #76]	; (5080 <getSpllConfig+0xac>)
    5032:	9300      	str	r3, [sp, #0]
        SpllConfiguration.Name = SPLL_CLK;
    5034:	4b12      	ldr	r3, [pc, #72]	; (5080 <getSpllConfig+0xac>)
    5036:	2209      	movs	r2, #9
    5038:	601a      	str	r2, [r3, #0]
        SpllConfiguration.Enable = (uint16)(IP_SCG->SPLLCSR & SCG_SPLLCSR_SPLLEN_MASK) >> SCG_SPLLCSR_SPLLEN_SHIFT;
    503a:	4b12      	ldr	r3, [pc, #72]	; (5084 <getSpllConfig+0xb0>)
    503c:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    5040:	b29b      	uxth	r3, r3
    5042:	f003 0301 	and.w	r3, r3, #1
    5046:	b29a      	uxth	r2, r3
    5048:	4b0d      	ldr	r3, [pc, #52]	; (5080 <getSpllConfig+0xac>)
    504a:	809a      	strh	r2, [r3, #4]
        SpllConfiguration.Predivider = (uint8)((IP_SCG->SPLLCFG & SCG_SPLLCFG_PREDIV_MASK) >> SCG_SPLLCFG_PREDIV_SHIFT);
    504c:	4b0d      	ldr	r3, [pc, #52]	; (5084 <getSpllConfig+0xb0>)
    504e:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    5052:	0a1b      	lsrs	r3, r3, #8
    5054:	b2db      	uxtb	r3, r3
    5056:	f003 0307 	and.w	r3, r3, #7
    505a:	b2da      	uxtb	r2, r3
    505c:	4b08      	ldr	r3, [pc, #32]	; (5080 <getSpllConfig+0xac>)
    505e:	735a      	strb	r2, [r3, #13]
        SpllConfiguration.MulFactorDiv = (uint8)((IP_SCG->SPLLCFG & SCG_SPLLCFG_MULT_MASK) >> SCG_SPLLCFG_MULT_SHIFT);
    5060:	4b08      	ldr	r3, [pc, #32]	; (5084 <getSpllConfig+0xb0>)
    5062:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    5066:	0c1b      	lsrs	r3, r3, #16
    5068:	b2db      	uxtb	r3, r3
    506a:	f003 031f 	and.w	r3, r3, #31
    506e:	b2da      	uxtb	r2, r3
    5070:	4b03      	ldr	r3, [pc, #12]	; (5080 <getSpllConfig+0xac>)
    5072:	751a      	strb	r2, [r3, #20]
    }

    return ReturnValue;
    5074:	9b00      	ldr	r3, [sp, #0]
}
    5076:	4618      	mov	r0, r3
    5078:	b002      	add	sp, #8
    507a:	4770      	bx	lr
    507c:	1fff8ba0 	.word	0x1fff8ba0
    5080:	1fff8c2c 	.word	0x1fff8c2c
    5084:	40064000 	.word	0x40064000

00005088 <getSelectorConfig>:
    return ReturnValue;
}
#endif

static const Clock_Ip_SelectorConfigType *getSelectorConfig(Clock_Ip_NameType Name)
{
    5088:	b086      	sub	sp, #24
    508a:	9001      	str	r0, [sp, #4]
    const Clock_Ip_SelectorConfigType *ReturnValue = NULL_PTR;
    508c:	2300      	movs	r3, #0
    508e:	9305      	str	r3, [sp, #20]
    uint32 SelectorConfigIndex;
    uint32 Index;

    switch(Name)
    5090:	9b01      	ldr	r3, [sp, #4]
    5092:	2b1b      	cmp	r3, #27
    5094:	d00f      	beq.n	50b6 <getSelectorConfig+0x2e>
    5096:	9b01      	ldr	r3, [sp, #4]
    5098:	2b1b      	cmp	r3, #27
    509a:	d80f      	bhi.n	50bc <getSelectorConfig+0x34>
    509c:	9b01      	ldr	r3, [sp, #4]
    509e:	2b19      	cmp	r3, #25
    50a0:	d003      	beq.n	50aa <getSelectorConfig+0x22>
    50a2:	9b01      	ldr	r3, [sp, #4]
    50a4:	2b1a      	cmp	r3, #26
    50a6:	d003      	beq.n	50b0 <getSelectorConfig+0x28>
    50a8:	e008      	b.n	50bc <getSelectorConfig+0x34>
    {
        case SCS_RUN_CLK:
            SelectorConfigIndex = 0U;
    50aa:	2300      	movs	r3, #0
    50ac:	9304      	str	r3, [sp, #16]
            break;
    50ae:	e008      	b.n	50c2 <getSelectorConfig+0x3a>
        case SCS_VLPR_CLK:
            SelectorConfigIndex = 1U;
    50b0:	2301      	movs	r3, #1
    50b2:	9304      	str	r3, [sp, #16]
            break;
    50b4:	e005      	b.n	50c2 <getSelectorConfig+0x3a>
#if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
        case SCS_HSRUN_CLK:
            SelectorConfigIndex = 2U;
    50b6:	2302      	movs	r3, #2
    50b8:	9304      	str	r3, [sp, #16]
            break;
    50ba:	e002      	b.n	50c2 <getSelectorConfig+0x3a>
#endif
        default:
            SelectorConfigIndex = 0U;
    50bc:	2300      	movs	r3, #0
    50be:	9304      	str	r3, [sp, #16]
            break;
    50c0:	bf00      	nop
    }


    if (Clock_Ip_apConfig != NULL_PTR)
    50c2:	4b36      	ldr	r3, [pc, #216]	; (519c <getSelectorConfig+0x114>)
    50c4:	681b      	ldr	r3, [r3, #0]
    50c6:	2b00      	cmp	r3, #0
    50c8:	d01d      	beq.n	5106 <getSelectorConfig+0x7e>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->SelectorsCount; Index++)
    50ca:	2300      	movs	r3, #0
    50cc:	9303      	str	r3, [sp, #12]
    50ce:	e013      	b.n	50f8 <getSelectorConfig+0x70>
        {
            if (Clock_Ip_apConfig->Selectors[Index].Name == Name)
    50d0:	4b32      	ldr	r3, [pc, #200]	; (519c <getSelectorConfig+0x114>)
    50d2:	681b      	ldr	r3, [r3, #0]
    50d4:	9a03      	ldr	r2, [sp, #12]
    50d6:	320d      	adds	r2, #13
    50d8:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    50dc:	9a01      	ldr	r2, [sp, #4]
    50de:	429a      	cmp	r2, r3
    50e0:	d107      	bne.n	50f2 <getSelectorConfig+0x6a>
            {
                ReturnValue = &Clock_Ip_apConfig->Selectors[Index];
    50e2:	4b2e      	ldr	r3, [pc, #184]	; (519c <getSelectorConfig+0x114>)
    50e4:	681a      	ldr	r2, [r3, #0]
    50e6:	9b03      	ldr	r3, [sp, #12]
    50e8:	330d      	adds	r3, #13
    50ea:	00db      	lsls	r3, r3, #3
    50ec:	4413      	add	r3, r2
    50ee:	9305      	str	r3, [sp, #20]
                break;
    50f0:	e009      	b.n	5106 <getSelectorConfig+0x7e>
        for (Index = 0U; Index < Clock_Ip_apConfig->SelectorsCount; Index++)
    50f2:	9b03      	ldr	r3, [sp, #12]
    50f4:	3301      	adds	r3, #1
    50f6:	9303      	str	r3, [sp, #12]
    50f8:	4b28      	ldr	r3, [pc, #160]	; (519c <getSelectorConfig+0x114>)
    50fa:	681b      	ldr	r3, [r3, #0]
    50fc:	7adb      	ldrb	r3, [r3, #11]
    50fe:	461a      	mov	r2, r3
    5100:	9b03      	ldr	r3, [sp, #12]
    5102:	4293      	cmp	r3, r2
    5104:	d3e4      	bcc.n	50d0 <getSelectorConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    5106:	9b05      	ldr	r3, [sp, #20]
    5108:	2b00      	cmp	r3, #0
    510a:	d140      	bne.n	518e <getSelectorConfig+0x106>
    {
        ReturnValue = &SelectorConfigurations[SelectorConfigIndex];
    510c:	9b04      	ldr	r3, [sp, #16]
    510e:	00db      	lsls	r3, r3, #3
    5110:	4a23      	ldr	r2, [pc, #140]	; (51a0 <getSelectorConfig+0x118>)
    5112:	4413      	add	r3, r2
    5114:	9305      	str	r3, [sp, #20]
        SelectorConfigurations[SelectorConfigIndex].Name = Name;
    5116:	4922      	ldr	r1, [pc, #136]	; (51a0 <getSelectorConfig+0x118>)
    5118:	9b04      	ldr	r3, [sp, #16]
    511a:	9a01      	ldr	r2, [sp, #4]
    511c:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
        switch(Name)
    5120:	9b01      	ldr	r3, [sp, #4]
    5122:	2b1b      	cmp	r3, #27
    5124:	d025      	beq.n	5172 <getSelectorConfig+0xea>
    5126:	9b01      	ldr	r3, [sp, #4]
    5128:	2b1b      	cmp	r3, #27
    512a:	d832      	bhi.n	5192 <getSelectorConfig+0x10a>
    512c:	9b01      	ldr	r3, [sp, #4]
    512e:	2b19      	cmp	r3, #25
    5130:	d003      	beq.n	513a <getSelectorConfig+0xb2>
    5132:	9b01      	ldr	r3, [sp, #4]
    5134:	2b1a      	cmp	r3, #26
    5136:	d00e      	beq.n	5156 <getSelectorConfig+0xce>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->HCCR & SCG_HCCR_SCS_MASK) >> SCG_HCCR_SCS_SHIFT];
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    5138:	e02b      	b.n	5192 <getSelectorConfig+0x10a>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->RCCR & SCG_RCCR_SCS_MASK) >> SCG_RCCR_SCS_SHIFT];
    513a:	4b1a      	ldr	r3, [pc, #104]	; (51a4 <getSelectorConfig+0x11c>)
    513c:	695b      	ldr	r3, [r3, #20]
    513e:	0e1b      	lsrs	r3, r3, #24
    5140:	f003 030f 	and.w	r3, r3, #15
    5144:	4a18      	ldr	r2, [pc, #96]	; (51a8 <getSelectorConfig+0x120>)
    5146:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    514a:	4915      	ldr	r1, [pc, #84]	; (51a0 <getSelectorConfig+0x118>)
    514c:	9b04      	ldr	r3, [sp, #16]
    514e:	00db      	lsls	r3, r3, #3
    5150:	440b      	add	r3, r1
    5152:	605a      	str	r2, [r3, #4]
                break;
    5154:	e01e      	b.n	5194 <getSelectorConfig+0x10c>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->VCCR & SCG_VCCR_SCS_MASK) >> SCG_VCCR_SCS_SHIFT];
    5156:	4b13      	ldr	r3, [pc, #76]	; (51a4 <getSelectorConfig+0x11c>)
    5158:	699b      	ldr	r3, [r3, #24]
    515a:	0e1b      	lsrs	r3, r3, #24
    515c:	f003 030f 	and.w	r3, r3, #15
    5160:	4a11      	ldr	r2, [pc, #68]	; (51a8 <getSelectorConfig+0x120>)
    5162:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    5166:	490e      	ldr	r1, [pc, #56]	; (51a0 <getSelectorConfig+0x118>)
    5168:	9b04      	ldr	r3, [sp, #16]
    516a:	00db      	lsls	r3, r3, #3
    516c:	440b      	add	r3, r1
    516e:	605a      	str	r2, [r3, #4]
                break;
    5170:	e010      	b.n	5194 <getSelectorConfig+0x10c>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->HCCR & SCG_HCCR_SCS_MASK) >> SCG_HCCR_SCS_SHIFT];
    5172:	4b0c      	ldr	r3, [pc, #48]	; (51a4 <getSelectorConfig+0x11c>)
    5174:	69db      	ldr	r3, [r3, #28]
    5176:	0e1b      	lsrs	r3, r3, #24
    5178:	f003 030f 	and.w	r3, r3, #15
    517c:	4a0a      	ldr	r2, [pc, #40]	; (51a8 <getSelectorConfig+0x120>)
    517e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    5182:	4907      	ldr	r1, [pc, #28]	; (51a0 <getSelectorConfig+0x118>)
    5184:	9b04      	ldr	r3, [sp, #16]
    5186:	00db      	lsls	r3, r3, #3
    5188:	440b      	add	r3, r1
    518a:	605a      	str	r2, [r3, #4]
                break;
    518c:	e002      	b.n	5194 <getSelectorConfig+0x10c>
        }
    }
    518e:	bf00      	nop
    5190:	e000      	b.n	5194 <getSelectorConfig+0x10c>
                break;
    5192:	bf00      	nop

    return ReturnValue;
    5194:	9b05      	ldr	r3, [sp, #20]
}
    5196:	4618      	mov	r0, r3
    5198:	b006      	add	sp, #24
    519a:	4770      	bx	lr
    519c:	1fff8ba0 	.word	0x1fff8ba0
    51a0:	1fff8c54 	.word	0x1fff8c54
    51a4:	40064000 	.word	0x40064000
    51a8:	0001863c 	.word	0x0001863c

000051ac <getCoreDividerConfig>:

static const Clock_Ip_DividerConfigType *getCoreDividerConfig(Clock_Ip_NameType Name)
{
    51ac:	b086      	sub	sp, #24
    51ae:	9001      	str	r0, [sp, #4]
    const Clock_Ip_DividerConfigType *ReturnValue = NULL_PTR;
    51b0:	2300      	movs	r3, #0
    51b2:	9305      	str	r3, [sp, #20]
    uint32 DividerConfigIndex = 0U;
    51b4:	2300      	movs	r3, #0
    51b6:	9304      	str	r3, [sp, #16]
    uint32 Index;

    switch(Name)
    51b8:	9b01      	ldr	r3, [sp, #4]
    51ba:	2b1f      	cmp	r3, #31
    51bc:	d00f      	beq.n	51de <getCoreDividerConfig+0x32>
    51be:	9b01      	ldr	r3, [sp, #4]
    51c0:	2b1f      	cmp	r3, #31
    51c2:	d80f      	bhi.n	51e4 <getCoreDividerConfig+0x38>
    51c4:	9b01      	ldr	r3, [sp, #4]
    51c6:	2b1d      	cmp	r3, #29
    51c8:	d003      	beq.n	51d2 <getCoreDividerConfig+0x26>
    51ca:	9b01      	ldr	r3, [sp, #4]
    51cc:	2b1e      	cmp	r3, #30
    51ce:	d003      	beq.n	51d8 <getCoreDividerConfig+0x2c>
            DividerConfigIndex = 2U;
            break;
#endif
            default:
                /* Invalid clock name */
                break;
    51d0:	e008      	b.n	51e4 <getCoreDividerConfig+0x38>
            DividerConfigIndex = 0U;
    51d2:	2300      	movs	r3, #0
    51d4:	9304      	str	r3, [sp, #16]
            break;
    51d6:	e006      	b.n	51e6 <getCoreDividerConfig+0x3a>
            DividerConfigIndex = 1U;
    51d8:	2301      	movs	r3, #1
    51da:	9304      	str	r3, [sp, #16]
            break;
    51dc:	e003      	b.n	51e6 <getCoreDividerConfig+0x3a>
            DividerConfigIndex = 2U;
    51de:	2302      	movs	r3, #2
    51e0:	9304      	str	r3, [sp, #16]
            break;
    51e2:	e000      	b.n	51e6 <getCoreDividerConfig+0x3a>
                break;
    51e4:	bf00      	nop
    }


    if (Clock_Ip_apConfig != NULL_PTR)
    51e6:	4b41      	ldr	r3, [pc, #260]	; (52ec <getCoreDividerConfig+0x140>)
    51e8:	681b      	ldr	r3, [r3, #0]
    51ea:	2b00      	cmp	r3, #0
    51ec:	d026      	beq.n	523c <getCoreDividerConfig+0x90>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    51ee:	2300      	movs	r3, #0
    51f0:	9303      	str	r3, [sp, #12]
    51f2:	e01c      	b.n	522e <getCoreDividerConfig+0x82>
        {
            if (Clock_Ip_apConfig->Dividers[Index].Name == Name)
    51f4:	4b3d      	ldr	r3, [pc, #244]	; (52ec <getCoreDividerConfig+0x140>)
    51f6:	6819      	ldr	r1, [r3, #0]
    51f8:	9a03      	ldr	r2, [sp, #12]
    51fa:	4613      	mov	r3, r2
    51fc:	005b      	lsls	r3, r3, #1
    51fe:	4413      	add	r3, r2
    5200:	009b      	lsls	r3, r3, #2
    5202:	440b      	add	r3, r1
    5204:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    5208:	681b      	ldr	r3, [r3, #0]
    520a:	9a01      	ldr	r2, [sp, #4]
    520c:	429a      	cmp	r2, r3
    520e:	d10b      	bne.n	5228 <getCoreDividerConfig+0x7c>
            {
                ReturnValue = &Clock_Ip_apConfig->Dividers[Index];
    5210:	4b36      	ldr	r3, [pc, #216]	; (52ec <getCoreDividerConfig+0x140>)
    5212:	6819      	ldr	r1, [r3, #0]
    5214:	9a03      	ldr	r2, [sp, #12]
    5216:	4613      	mov	r3, r2
    5218:	005b      	lsls	r3, r3, #1
    521a:	4413      	add	r3, r2
    521c:	009b      	lsls	r3, r3, #2
    521e:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    5222:	440b      	add	r3, r1
    5224:	9305      	str	r3, [sp, #20]
                break;
    5226:	e009      	b.n	523c <getCoreDividerConfig+0x90>
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    5228:	9b03      	ldr	r3, [sp, #12]
    522a:	3301      	adds	r3, #1
    522c:	9303      	str	r3, [sp, #12]
    522e:	4b2f      	ldr	r3, [pc, #188]	; (52ec <getCoreDividerConfig+0x140>)
    5230:	681b      	ldr	r3, [r3, #0]
    5232:	7b1b      	ldrb	r3, [r3, #12]
    5234:	461a      	mov	r2, r3
    5236:	9b03      	ldr	r3, [sp, #12]
    5238:	4293      	cmp	r3, r2
    523a:	d3db      	bcc.n	51f4 <getCoreDividerConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    523c:	9b05      	ldr	r3, [sp, #20]
    523e:	2b00      	cmp	r3, #0
    5240:	d14d      	bne.n	52de <getCoreDividerConfig+0x132>
    {
        ReturnValue = &CoreDividerConfigurations[DividerConfigIndex];
    5242:	9a04      	ldr	r2, [sp, #16]
    5244:	4613      	mov	r3, r2
    5246:	005b      	lsls	r3, r3, #1
    5248:	4413      	add	r3, r2
    524a:	009b      	lsls	r3, r3, #2
    524c:	4a28      	ldr	r2, [pc, #160]	; (52f0 <getCoreDividerConfig+0x144>)
    524e:	4413      	add	r3, r2
    5250:	9305      	str	r3, [sp, #20]
        CoreDividerConfigurations[DividerConfigIndex].Name = Name;
    5252:	4927      	ldr	r1, [pc, #156]	; (52f0 <getCoreDividerConfig+0x144>)
    5254:	9a04      	ldr	r2, [sp, #16]
    5256:	4613      	mov	r3, r2
    5258:	005b      	lsls	r3, r3, #1
    525a:	4413      	add	r3, r2
    525c:	009b      	lsls	r3, r3, #2
    525e:	440b      	add	r3, r1
    5260:	9a01      	ldr	r2, [sp, #4]
    5262:	601a      	str	r2, [r3, #0]
        switch(Name)
    5264:	9b01      	ldr	r3, [sp, #4]
    5266:	2b1f      	cmp	r3, #31
    5268:	d029      	beq.n	52be <getCoreDividerConfig+0x112>
    526a:	9b01      	ldr	r3, [sp, #4]
    526c:	2b1f      	cmp	r3, #31
    526e:	d838      	bhi.n	52e2 <getCoreDividerConfig+0x136>
    5270:	9b01      	ldr	r3, [sp, #4]
    5272:	2b1d      	cmp	r3, #29
    5274:	d003      	beq.n	527e <getCoreDividerConfig+0xd2>
    5276:	9b01      	ldr	r3, [sp, #4]
    5278:	2b1e      	cmp	r3, #30
    527a:	d010      	beq.n	529e <getCoreDividerConfig+0xf2>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVCORE_MASK) >> SCG_HCCR_DIVCORE_SHIFT) + 1U;
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    527c:	e031      	b.n	52e2 <getCoreDividerConfig+0x136>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->RCCR & SCG_RCCR_DIVCORE_MASK) >> SCG_RCCR_DIVCORE_SHIFT) + 1U;
    527e:	4b1d      	ldr	r3, [pc, #116]	; (52f4 <getCoreDividerConfig+0x148>)
    5280:	695b      	ldr	r3, [r3, #20]
    5282:	0c1b      	lsrs	r3, r3, #16
    5284:	f003 030f 	and.w	r3, r3, #15
    5288:	1c59      	adds	r1, r3, #1
    528a:	4819      	ldr	r0, [pc, #100]	; (52f0 <getCoreDividerConfig+0x144>)
    528c:	9a04      	ldr	r2, [sp, #16]
    528e:	4613      	mov	r3, r2
    5290:	005b      	lsls	r3, r3, #1
    5292:	4413      	add	r3, r2
    5294:	009b      	lsls	r3, r3, #2
    5296:	4403      	add	r3, r0
    5298:	3304      	adds	r3, #4
    529a:	6019      	str	r1, [r3, #0]
                break;
    529c:	e022      	b.n	52e4 <getCoreDividerConfig+0x138>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->VCCR & SCG_VCCR_DIVCORE_MASK) >> SCG_VCCR_DIVCORE_SHIFT) + 1U;
    529e:	4b15      	ldr	r3, [pc, #84]	; (52f4 <getCoreDividerConfig+0x148>)
    52a0:	699b      	ldr	r3, [r3, #24]
    52a2:	0c1b      	lsrs	r3, r3, #16
    52a4:	f003 030f 	and.w	r3, r3, #15
    52a8:	1c59      	adds	r1, r3, #1
    52aa:	4811      	ldr	r0, [pc, #68]	; (52f0 <getCoreDividerConfig+0x144>)
    52ac:	9a04      	ldr	r2, [sp, #16]
    52ae:	4613      	mov	r3, r2
    52b0:	005b      	lsls	r3, r3, #1
    52b2:	4413      	add	r3, r2
    52b4:	009b      	lsls	r3, r3, #2
    52b6:	4403      	add	r3, r0
    52b8:	3304      	adds	r3, #4
    52ba:	6019      	str	r1, [r3, #0]
                break;
    52bc:	e012      	b.n	52e4 <getCoreDividerConfig+0x138>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVCORE_MASK) >> SCG_HCCR_DIVCORE_SHIFT) + 1U;
    52be:	4b0d      	ldr	r3, [pc, #52]	; (52f4 <getCoreDividerConfig+0x148>)
    52c0:	69db      	ldr	r3, [r3, #28]
    52c2:	0c1b      	lsrs	r3, r3, #16
    52c4:	f003 030f 	and.w	r3, r3, #15
    52c8:	1c59      	adds	r1, r3, #1
    52ca:	4809      	ldr	r0, [pc, #36]	; (52f0 <getCoreDividerConfig+0x144>)
    52cc:	9a04      	ldr	r2, [sp, #16]
    52ce:	4613      	mov	r3, r2
    52d0:	005b      	lsls	r3, r3, #1
    52d2:	4413      	add	r3, r2
    52d4:	009b      	lsls	r3, r3, #2
    52d6:	4403      	add	r3, r0
    52d8:	3304      	adds	r3, #4
    52da:	6019      	str	r1, [r3, #0]
                break;
    52dc:	e002      	b.n	52e4 <getCoreDividerConfig+0x138>
        }
    }
    52de:	bf00      	nop
    52e0:	e000      	b.n	52e4 <getCoreDividerConfig+0x138>
                break;
    52e2:	bf00      	nop

    return ReturnValue;
    52e4:	9b05      	ldr	r3, [sp, #20]
}
    52e6:	4618      	mov	r0, r3
    52e8:	b006      	add	sp, #24
    52ea:	4770      	bx	lr
    52ec:	1fff8ba0 	.word	0x1fff8ba0
    52f0:	1fff8c6c 	.word	0x1fff8c6c
    52f4:	40064000 	.word	0x40064000

000052f8 <getBusDividerConfig>:


static const Clock_Ip_DividerConfigType *getBusDividerConfig(Clock_Ip_NameType Name)
{
    52f8:	b086      	sub	sp, #24
    52fa:	9001      	str	r0, [sp, #4]
    const Clock_Ip_DividerConfigType *ReturnValue = NULL_PTR;
    52fc:	2300      	movs	r3, #0
    52fe:	9305      	str	r3, [sp, #20]
    uint32 DividerConfigIndex = 0U;
    5300:	2300      	movs	r3, #0
    5302:	9304      	str	r3, [sp, #16]
    uint32 Index;

    switch(Name)
    5304:	9b01      	ldr	r3, [sp, #4]
    5306:	2b23      	cmp	r3, #35	; 0x23
    5308:	d00f      	beq.n	532a <getBusDividerConfig+0x32>
    530a:	9b01      	ldr	r3, [sp, #4]
    530c:	2b23      	cmp	r3, #35	; 0x23
    530e:	d80f      	bhi.n	5330 <getBusDividerConfig+0x38>
    5310:	9b01      	ldr	r3, [sp, #4]
    5312:	2b21      	cmp	r3, #33	; 0x21
    5314:	d003      	beq.n	531e <getBusDividerConfig+0x26>
    5316:	9b01      	ldr	r3, [sp, #4]
    5318:	2b22      	cmp	r3, #34	; 0x22
    531a:	d003      	beq.n	5324 <getBusDividerConfig+0x2c>
            DividerConfigIndex = 2U;
            break;
#endif
            default:
                /* Invalid clock name */
                break;
    531c:	e008      	b.n	5330 <getBusDividerConfig+0x38>
            DividerConfigIndex = 0U;
    531e:	2300      	movs	r3, #0
    5320:	9304      	str	r3, [sp, #16]
            break;
    5322:	e006      	b.n	5332 <getBusDividerConfig+0x3a>
            DividerConfigIndex = 1U;
    5324:	2301      	movs	r3, #1
    5326:	9304      	str	r3, [sp, #16]
            break;
    5328:	e003      	b.n	5332 <getBusDividerConfig+0x3a>
            DividerConfigIndex = 2U;
    532a:	2302      	movs	r3, #2
    532c:	9304      	str	r3, [sp, #16]
            break;
    532e:	e000      	b.n	5332 <getBusDividerConfig+0x3a>
                break;
    5330:	bf00      	nop

    }


    if (Clock_Ip_apConfig != NULL_PTR)
    5332:	4b41      	ldr	r3, [pc, #260]	; (5438 <getBusDividerConfig+0x140>)
    5334:	681b      	ldr	r3, [r3, #0]
    5336:	2b00      	cmp	r3, #0
    5338:	d026      	beq.n	5388 <getBusDividerConfig+0x90>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    533a:	2300      	movs	r3, #0
    533c:	9303      	str	r3, [sp, #12]
    533e:	e01c      	b.n	537a <getBusDividerConfig+0x82>
        {
            if (Clock_Ip_apConfig->Dividers[Index].Name == Name)
    5340:	4b3d      	ldr	r3, [pc, #244]	; (5438 <getBusDividerConfig+0x140>)
    5342:	6819      	ldr	r1, [r3, #0]
    5344:	9a03      	ldr	r2, [sp, #12]
    5346:	4613      	mov	r3, r2
    5348:	005b      	lsls	r3, r3, #1
    534a:	4413      	add	r3, r2
    534c:	009b      	lsls	r3, r3, #2
    534e:	440b      	add	r3, r1
    5350:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    5354:	681b      	ldr	r3, [r3, #0]
    5356:	9a01      	ldr	r2, [sp, #4]
    5358:	429a      	cmp	r2, r3
    535a:	d10b      	bne.n	5374 <getBusDividerConfig+0x7c>
            {
                ReturnValue = &Clock_Ip_apConfig->Dividers[Index];
    535c:	4b36      	ldr	r3, [pc, #216]	; (5438 <getBusDividerConfig+0x140>)
    535e:	6819      	ldr	r1, [r3, #0]
    5360:	9a03      	ldr	r2, [sp, #12]
    5362:	4613      	mov	r3, r2
    5364:	005b      	lsls	r3, r3, #1
    5366:	4413      	add	r3, r2
    5368:	009b      	lsls	r3, r3, #2
    536a:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    536e:	440b      	add	r3, r1
    5370:	9305      	str	r3, [sp, #20]
                break;
    5372:	e009      	b.n	5388 <getBusDividerConfig+0x90>
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    5374:	9b03      	ldr	r3, [sp, #12]
    5376:	3301      	adds	r3, #1
    5378:	9303      	str	r3, [sp, #12]
    537a:	4b2f      	ldr	r3, [pc, #188]	; (5438 <getBusDividerConfig+0x140>)
    537c:	681b      	ldr	r3, [r3, #0]
    537e:	7b1b      	ldrb	r3, [r3, #12]
    5380:	461a      	mov	r2, r3
    5382:	9b03      	ldr	r3, [sp, #12]
    5384:	4293      	cmp	r3, r2
    5386:	d3db      	bcc.n	5340 <getBusDividerConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    5388:	9b05      	ldr	r3, [sp, #20]
    538a:	2b00      	cmp	r3, #0
    538c:	d14d      	bne.n	542a <getBusDividerConfig+0x132>
    {
        ReturnValue = &BusDividerConfigurations[DividerConfigIndex];
    538e:	9a04      	ldr	r2, [sp, #16]
    5390:	4613      	mov	r3, r2
    5392:	005b      	lsls	r3, r3, #1
    5394:	4413      	add	r3, r2
    5396:	009b      	lsls	r3, r3, #2
    5398:	4a28      	ldr	r2, [pc, #160]	; (543c <getBusDividerConfig+0x144>)
    539a:	4413      	add	r3, r2
    539c:	9305      	str	r3, [sp, #20]
        BusDividerConfigurations[DividerConfigIndex].Name = Name;
    539e:	4927      	ldr	r1, [pc, #156]	; (543c <getBusDividerConfig+0x144>)
    53a0:	9a04      	ldr	r2, [sp, #16]
    53a2:	4613      	mov	r3, r2
    53a4:	005b      	lsls	r3, r3, #1
    53a6:	4413      	add	r3, r2
    53a8:	009b      	lsls	r3, r3, #2
    53aa:	440b      	add	r3, r1
    53ac:	9a01      	ldr	r2, [sp, #4]
    53ae:	601a      	str	r2, [r3, #0]
        switch(Name)
    53b0:	9b01      	ldr	r3, [sp, #4]
    53b2:	2b23      	cmp	r3, #35	; 0x23
    53b4:	d029      	beq.n	540a <getBusDividerConfig+0x112>
    53b6:	9b01      	ldr	r3, [sp, #4]
    53b8:	2b23      	cmp	r3, #35	; 0x23
    53ba:	d838      	bhi.n	542e <getBusDividerConfig+0x136>
    53bc:	9b01      	ldr	r3, [sp, #4]
    53be:	2b21      	cmp	r3, #33	; 0x21
    53c0:	d003      	beq.n	53ca <getBusDividerConfig+0xd2>
    53c2:	9b01      	ldr	r3, [sp, #4]
    53c4:	2b22      	cmp	r3, #34	; 0x22
    53c6:	d010      	beq.n	53ea <getBusDividerConfig+0xf2>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVBUS_MASK) >> SCG_HCCR_DIVBUS_SHIFT) + 1U;
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    53c8:	e031      	b.n	542e <getBusDividerConfig+0x136>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->RCCR & SCG_RCCR_DIVBUS_MASK) >> SCG_RCCR_DIVBUS_SHIFT) + 1U;
    53ca:	4b1d      	ldr	r3, [pc, #116]	; (5440 <getBusDividerConfig+0x148>)
    53cc:	695b      	ldr	r3, [r3, #20]
    53ce:	091b      	lsrs	r3, r3, #4
    53d0:	f003 030f 	and.w	r3, r3, #15
    53d4:	1c59      	adds	r1, r3, #1
    53d6:	4819      	ldr	r0, [pc, #100]	; (543c <getBusDividerConfig+0x144>)
    53d8:	9a04      	ldr	r2, [sp, #16]
    53da:	4613      	mov	r3, r2
    53dc:	005b      	lsls	r3, r3, #1
    53de:	4413      	add	r3, r2
    53e0:	009b      	lsls	r3, r3, #2
    53e2:	4403      	add	r3, r0
    53e4:	3304      	adds	r3, #4
    53e6:	6019      	str	r1, [r3, #0]
                break;
    53e8:	e022      	b.n	5430 <getBusDividerConfig+0x138>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->VCCR & SCG_VCCR_DIVBUS_MASK) >> SCG_VCCR_DIVBUS_SHIFT) + 1U;
    53ea:	4b15      	ldr	r3, [pc, #84]	; (5440 <getBusDividerConfig+0x148>)
    53ec:	699b      	ldr	r3, [r3, #24]
    53ee:	091b      	lsrs	r3, r3, #4
    53f0:	f003 030f 	and.w	r3, r3, #15
    53f4:	1c59      	adds	r1, r3, #1
    53f6:	4811      	ldr	r0, [pc, #68]	; (543c <getBusDividerConfig+0x144>)
    53f8:	9a04      	ldr	r2, [sp, #16]
    53fa:	4613      	mov	r3, r2
    53fc:	005b      	lsls	r3, r3, #1
    53fe:	4413      	add	r3, r2
    5400:	009b      	lsls	r3, r3, #2
    5402:	4403      	add	r3, r0
    5404:	3304      	adds	r3, #4
    5406:	6019      	str	r1, [r3, #0]
                break;
    5408:	e012      	b.n	5430 <getBusDividerConfig+0x138>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVBUS_MASK) >> SCG_HCCR_DIVBUS_SHIFT) + 1U;
    540a:	4b0d      	ldr	r3, [pc, #52]	; (5440 <getBusDividerConfig+0x148>)
    540c:	69db      	ldr	r3, [r3, #28]
    540e:	091b      	lsrs	r3, r3, #4
    5410:	f003 030f 	and.w	r3, r3, #15
    5414:	1c59      	adds	r1, r3, #1
    5416:	4809      	ldr	r0, [pc, #36]	; (543c <getBusDividerConfig+0x144>)
    5418:	9a04      	ldr	r2, [sp, #16]
    541a:	4613      	mov	r3, r2
    541c:	005b      	lsls	r3, r3, #1
    541e:	4413      	add	r3, r2
    5420:	009b      	lsls	r3, r3, #2
    5422:	4403      	add	r3, r0
    5424:	3304      	adds	r3, #4
    5426:	6019      	str	r1, [r3, #0]
                break;
    5428:	e002      	b.n	5430 <getBusDividerConfig+0x138>
        }
    }
    542a:	bf00      	nop
    542c:	e000      	b.n	5430 <getBusDividerConfig+0x138>
                break;
    542e:	bf00      	nop

    return ReturnValue;
    5430:	9b05      	ldr	r3, [sp, #20]
}
    5432:	4618      	mov	r0, r3
    5434:	b006      	add	sp, #24
    5436:	4770      	bx	lr
    5438:	1fff8ba0 	.word	0x1fff8ba0
    543c:	1fff8c90 	.word	0x1fff8c90
    5440:	40064000 	.word	0x40064000

00005444 <getSlowDividerConfig>:

static const Clock_Ip_DividerConfigType *getSlowDividerConfig(Clock_Ip_NameType Name)
{
    5444:	b086      	sub	sp, #24
    5446:	9001      	str	r0, [sp, #4]
    const Clock_Ip_DividerConfigType *ReturnValue = NULL_PTR;
    5448:	2300      	movs	r3, #0
    544a:	9305      	str	r3, [sp, #20]
    uint32 DividerConfigIndex = 0U;
    544c:	2300      	movs	r3, #0
    544e:	9304      	str	r3, [sp, #16]
    uint32 Index;

    switch(Name)
    5450:	9b01      	ldr	r3, [sp, #4]
    5452:	2b27      	cmp	r3, #39	; 0x27
    5454:	d00f      	beq.n	5476 <getSlowDividerConfig+0x32>
    5456:	9b01      	ldr	r3, [sp, #4]
    5458:	2b27      	cmp	r3, #39	; 0x27
    545a:	d80f      	bhi.n	547c <getSlowDividerConfig+0x38>
    545c:	9b01      	ldr	r3, [sp, #4]
    545e:	2b25      	cmp	r3, #37	; 0x25
    5460:	d003      	beq.n	546a <getSlowDividerConfig+0x26>
    5462:	9b01      	ldr	r3, [sp, #4]
    5464:	2b26      	cmp	r3, #38	; 0x26
    5466:	d003      	beq.n	5470 <getSlowDividerConfig+0x2c>
            DividerConfigIndex = 2U;
            break;
#endif
            default:
                /* Invalid clock name */
                break;
    5468:	e008      	b.n	547c <getSlowDividerConfig+0x38>
            DividerConfigIndex = 0U;
    546a:	2300      	movs	r3, #0
    546c:	9304      	str	r3, [sp, #16]
            break;
    546e:	e006      	b.n	547e <getSlowDividerConfig+0x3a>
            DividerConfigIndex = 1U;
    5470:	2301      	movs	r3, #1
    5472:	9304      	str	r3, [sp, #16]
            break;
    5474:	e003      	b.n	547e <getSlowDividerConfig+0x3a>
            DividerConfigIndex = 2U;
    5476:	2302      	movs	r3, #2
    5478:	9304      	str	r3, [sp, #16]
            break;
    547a:	e000      	b.n	547e <getSlowDividerConfig+0x3a>
                break;
    547c:	bf00      	nop

    }


    if (Clock_Ip_apConfig != NULL_PTR)
    547e:	4b40      	ldr	r3, [pc, #256]	; (5580 <getSlowDividerConfig+0x13c>)
    5480:	681b      	ldr	r3, [r3, #0]
    5482:	2b00      	cmp	r3, #0
    5484:	d026      	beq.n	54d4 <getSlowDividerConfig+0x90>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    5486:	2300      	movs	r3, #0
    5488:	9303      	str	r3, [sp, #12]
    548a:	e01c      	b.n	54c6 <getSlowDividerConfig+0x82>
        {
            if (Clock_Ip_apConfig->Dividers[Index].Name == Name)
    548c:	4b3c      	ldr	r3, [pc, #240]	; (5580 <getSlowDividerConfig+0x13c>)
    548e:	6819      	ldr	r1, [r3, #0]
    5490:	9a03      	ldr	r2, [sp, #12]
    5492:	4613      	mov	r3, r2
    5494:	005b      	lsls	r3, r3, #1
    5496:	4413      	add	r3, r2
    5498:	009b      	lsls	r3, r3, #2
    549a:	440b      	add	r3, r1
    549c:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    54a0:	681b      	ldr	r3, [r3, #0]
    54a2:	9a01      	ldr	r2, [sp, #4]
    54a4:	429a      	cmp	r2, r3
    54a6:	d10b      	bne.n	54c0 <getSlowDividerConfig+0x7c>
            {
                ReturnValue = &Clock_Ip_apConfig->Dividers[Index];
    54a8:	4b35      	ldr	r3, [pc, #212]	; (5580 <getSlowDividerConfig+0x13c>)
    54aa:	6819      	ldr	r1, [r3, #0]
    54ac:	9a03      	ldr	r2, [sp, #12]
    54ae:	4613      	mov	r3, r2
    54b0:	005b      	lsls	r3, r3, #1
    54b2:	4413      	add	r3, r2
    54b4:	009b      	lsls	r3, r3, #2
    54b6:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    54ba:	440b      	add	r3, r1
    54bc:	9305      	str	r3, [sp, #20]
                break;
    54be:	e009      	b.n	54d4 <getSlowDividerConfig+0x90>
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    54c0:	9b03      	ldr	r3, [sp, #12]
    54c2:	3301      	adds	r3, #1
    54c4:	9303      	str	r3, [sp, #12]
    54c6:	4b2e      	ldr	r3, [pc, #184]	; (5580 <getSlowDividerConfig+0x13c>)
    54c8:	681b      	ldr	r3, [r3, #0]
    54ca:	7b1b      	ldrb	r3, [r3, #12]
    54cc:	461a      	mov	r2, r3
    54ce:	9b03      	ldr	r3, [sp, #12]
    54d0:	4293      	cmp	r3, r2
    54d2:	d3db      	bcc.n	548c <getSlowDividerConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    54d4:	9b05      	ldr	r3, [sp, #20]
    54d6:	2b00      	cmp	r3, #0
    54d8:	d14a      	bne.n	5570 <getSlowDividerConfig+0x12c>
    {
        ReturnValue = &SlowDividerConfigurations[DividerConfigIndex];
    54da:	9a04      	ldr	r2, [sp, #16]
    54dc:	4613      	mov	r3, r2
    54de:	005b      	lsls	r3, r3, #1
    54e0:	4413      	add	r3, r2
    54e2:	009b      	lsls	r3, r3, #2
    54e4:	4a27      	ldr	r2, [pc, #156]	; (5584 <getSlowDividerConfig+0x140>)
    54e6:	4413      	add	r3, r2
    54e8:	9305      	str	r3, [sp, #20]
        SlowDividerConfigurations[DividerConfigIndex].Name = Name;
    54ea:	4926      	ldr	r1, [pc, #152]	; (5584 <getSlowDividerConfig+0x140>)
    54ec:	9a04      	ldr	r2, [sp, #16]
    54ee:	4613      	mov	r3, r2
    54f0:	005b      	lsls	r3, r3, #1
    54f2:	4413      	add	r3, r2
    54f4:	009b      	lsls	r3, r3, #2
    54f6:	440b      	add	r3, r1
    54f8:	9a01      	ldr	r2, [sp, #4]
    54fa:	601a      	str	r2, [r3, #0]
        switch(Name)
    54fc:	9b01      	ldr	r3, [sp, #4]
    54fe:	2b27      	cmp	r3, #39	; 0x27
    5500:	d027      	beq.n	5552 <getSlowDividerConfig+0x10e>
    5502:	9b01      	ldr	r3, [sp, #4]
    5504:	2b27      	cmp	r3, #39	; 0x27
    5506:	d835      	bhi.n	5574 <getSlowDividerConfig+0x130>
    5508:	9b01      	ldr	r3, [sp, #4]
    550a:	2b25      	cmp	r3, #37	; 0x25
    550c:	d003      	beq.n	5516 <getSlowDividerConfig+0xd2>
    550e:	9b01      	ldr	r3, [sp, #4]
    5510:	2b26      	cmp	r3, #38	; 0x26
    5512:	d00f      	beq.n	5534 <getSlowDividerConfig+0xf0>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVSLOW_MASK) >> SCG_HCCR_DIVSLOW_SHIFT) + 1U;
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    5514:	e02e      	b.n	5574 <getSlowDividerConfig+0x130>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->RCCR & SCG_RCCR_DIVSLOW_MASK) >> SCG_RCCR_DIVSLOW_SHIFT) + 1U;
    5516:	4b1c      	ldr	r3, [pc, #112]	; (5588 <getSlowDividerConfig+0x144>)
    5518:	695b      	ldr	r3, [r3, #20]
    551a:	f003 030f 	and.w	r3, r3, #15
    551e:	1c59      	adds	r1, r3, #1
    5520:	4818      	ldr	r0, [pc, #96]	; (5584 <getSlowDividerConfig+0x140>)
    5522:	9a04      	ldr	r2, [sp, #16]
    5524:	4613      	mov	r3, r2
    5526:	005b      	lsls	r3, r3, #1
    5528:	4413      	add	r3, r2
    552a:	009b      	lsls	r3, r3, #2
    552c:	4403      	add	r3, r0
    552e:	3304      	adds	r3, #4
    5530:	6019      	str	r1, [r3, #0]
                break;
    5532:	e020      	b.n	5576 <getSlowDividerConfig+0x132>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->VCCR & SCG_VCCR_DIVSLOW_MASK) >> SCG_VCCR_DIVSLOW_SHIFT) + 1U;
    5534:	4b14      	ldr	r3, [pc, #80]	; (5588 <getSlowDividerConfig+0x144>)
    5536:	699b      	ldr	r3, [r3, #24]
    5538:	f003 030f 	and.w	r3, r3, #15
    553c:	1c59      	adds	r1, r3, #1
    553e:	4811      	ldr	r0, [pc, #68]	; (5584 <getSlowDividerConfig+0x140>)
    5540:	9a04      	ldr	r2, [sp, #16]
    5542:	4613      	mov	r3, r2
    5544:	005b      	lsls	r3, r3, #1
    5546:	4413      	add	r3, r2
    5548:	009b      	lsls	r3, r3, #2
    554a:	4403      	add	r3, r0
    554c:	3304      	adds	r3, #4
    554e:	6019      	str	r1, [r3, #0]
                break;
    5550:	e011      	b.n	5576 <getSlowDividerConfig+0x132>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVSLOW_MASK) >> SCG_HCCR_DIVSLOW_SHIFT) + 1U;
    5552:	4b0d      	ldr	r3, [pc, #52]	; (5588 <getSlowDividerConfig+0x144>)
    5554:	69db      	ldr	r3, [r3, #28]
    5556:	f003 030f 	and.w	r3, r3, #15
    555a:	1c59      	adds	r1, r3, #1
    555c:	4809      	ldr	r0, [pc, #36]	; (5584 <getSlowDividerConfig+0x140>)
    555e:	9a04      	ldr	r2, [sp, #16]
    5560:	4613      	mov	r3, r2
    5562:	005b      	lsls	r3, r3, #1
    5564:	4413      	add	r3, r2
    5566:	009b      	lsls	r3, r3, #2
    5568:	4403      	add	r3, r0
    556a:	3304      	adds	r3, #4
    556c:	6019      	str	r1, [r3, #0]
                break;
    556e:	e002      	b.n	5576 <getSlowDividerConfig+0x132>
        }
    }
    5570:	bf00      	nop
    5572:	e000      	b.n	5576 <getSlowDividerConfig+0x132>
                break;
    5574:	bf00      	nop

    return ReturnValue;
    5576:	9b05      	ldr	r3, [sp, #20]
}
    5578:	4618      	mov	r0, r3
    557a:	b006      	add	sp, #24
    557c:	4770      	bx	lr
    557e:	bf00      	nop
    5580:	1fff8ba0 	.word	0x1fff8ba0
    5584:	1fff8cb4 	.word	0x1fff8cb4
    5588:	40064000 	.word	0x40064000

0000558c <Clock_Ip_ClockInitializeObjects>:

/* Initialize objects for clock */
static void Clock_Ip_ClockInitializeObjects(Clock_Ip_ClockConfigType const * Config)
{
    558c:	b500      	push	{lr}
    558e:	b083      	sub	sp, #12
    5590:	9001      	str	r0, [sp, #4]
    if (FALSE == Clock_Ip_bObjsAreInitialized)
    5592:	4b64      	ldr	r3, [pc, #400]	; (5724 <Clock_Ip_ClockInitializeObjects+0x198>)
    5594:	781b      	ldrb	r3, [r3, #0]
    5596:	f083 0301 	eor.w	r3, r3, #1
    559a:	b2db      	uxtb	r3, r3
    559c:	2b00      	cmp	r3, #0
    559e:	d05b      	beq.n	5658 <Clock_Ip_ClockInitializeObjects+0xcc>
    {
        Clock_Ip_bObjsAreInitialized = TRUE;
    55a0:	4b60      	ldr	r3, [pc, #384]	; (5724 <Clock_Ip_ClockInitializeObjects+0x198>)
    55a2:	2201      	movs	r2, #1
    55a4:	701a      	strb	r2, [r3, #0]

    #if defined(CLOCK_IP_HAS_SPLL_CLK)
        Clock_Ip_pxSpllClock = &Clock_Ip_axPllCallbacks[Clock_Ip_au8PllCallbackIndex[CLOCK_IP_SYS_PLL]];
    55a6:	4b60      	ldr	r3, [pc, #384]	; (5728 <Clock_Ip_ClockInitializeObjects+0x19c>)
    55a8:	785b      	ldrb	r3, [r3, #1]
    55aa:	461a      	mov	r2, r3
    55ac:	4613      	mov	r3, r2
    55ae:	009b      	lsls	r3, r3, #2
    55b0:	4413      	add	r3, r2
    55b2:	009b      	lsls	r3, r3, #2
    55b4:	4a5d      	ldr	r2, [pc, #372]	; (572c <Clock_Ip_ClockInitializeObjects+0x1a0>)
    55b6:	4413      	add	r3, r2
    55b8:	4a5d      	ldr	r2, [pc, #372]	; (5730 <Clock_Ip_ClockInitializeObjects+0x1a4>)
    55ba:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxSoscClock = &Clock_Ip_axExtOscCallbacks[Clock_Ip_au8XoscCallbackIndex[CLOCK_IP_SYS_OSC]];
    55bc:	4b5d      	ldr	r3, [pc, #372]	; (5734 <Clock_Ip_ClockInitializeObjects+0x1a8>)
    55be:	785b      	ldrb	r3, [r3, #1]
    55c0:	461a      	mov	r2, r3
    55c2:	4613      	mov	r3, r2
    55c4:	009b      	lsls	r3, r3, #2
    55c6:	4413      	add	r3, r2
    55c8:	009b      	lsls	r3, r3, #2
    55ca:	4a5b      	ldr	r2, [pc, #364]	; (5738 <Clock_Ip_ClockInitializeObjects+0x1ac>)
    55cc:	4413      	add	r3, r2
    55ce:	4a5b      	ldr	r2, [pc, #364]	; (573c <Clock_Ip_ClockInitializeObjects+0x1b0>)
    55d0:	6013      	str	r3, [r2, #0]

        Clock_Ip_pxFircClock = &Clock_Ip_axIntOscCallbacks[Clock_Ip_au8IrcoscCallbackIndex[CLOCK_IP_FIRCOSC]];
    55d2:	4b5b      	ldr	r3, [pc, #364]	; (5740 <Clock_Ip_ClockInitializeObjects+0x1b4>)
    55d4:	791b      	ldrb	r3, [r3, #4]
    55d6:	461a      	mov	r2, r3
    55d8:	4613      	mov	r3, r2
    55da:	005b      	lsls	r3, r3, #1
    55dc:	4413      	add	r3, r2
    55de:	009b      	lsls	r3, r3, #2
    55e0:	4a58      	ldr	r2, [pc, #352]	; (5744 <Clock_Ip_ClockInitializeObjects+0x1b8>)
    55e2:	4413      	add	r3, r2
    55e4:	4a58      	ldr	r2, [pc, #352]	; (5748 <Clock_Ip_ClockInitializeObjects+0x1bc>)
    55e6:	6013      	str	r3, [r2, #0]

    #if defined(CLOCK_IP_HAS_FIRC_MON1_CLK) || defined(CLOCK_IP_HAS_FIRC_MON2_CLK)
        Clock_Ip_pxCmuFircMonitor = &Clock_Ip_axCmuCallbacks[Clock_Ip_au8CmuCallbackIndex[CLOCK_IP_CMU]];
    #endif

        Clock_Ip_pxScsRunClockSelector   = &Clock_Ip_axSelectorCallbacks[Clock_Ip_au8SelectorCallbackIndex[CLOCK_IP_SCS_RUN]];
    55e8:	4b58      	ldr	r3, [pc, #352]	; (574c <Clock_Ip_ClockInitializeObjects+0x1c0>)
    55ea:	795b      	ldrb	r3, [r3, #5]
    55ec:	00db      	lsls	r3, r3, #3
    55ee:	4a58      	ldr	r2, [pc, #352]	; (5750 <Clock_Ip_ClockInitializeObjects+0x1c4>)
    55f0:	4413      	add	r3, r2
    55f2:	4a58      	ldr	r2, [pc, #352]	; (5754 <Clock_Ip_ClockInitializeObjects+0x1c8>)
    55f4:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
        Clock_Ip_pxScsHsrunClockSelector = &Clock_Ip_axSelectorCallbacks[Clock_Ip_au8SelectorCallbackIndex[CLOCK_IP_SCS_HSRUN]];
    55f6:	4b55      	ldr	r3, [pc, #340]	; (574c <Clock_Ip_ClockInitializeObjects+0x1c0>)
    55f8:	79db      	ldrb	r3, [r3, #7]
    55fa:	00db      	lsls	r3, r3, #3
    55fc:	4a54      	ldr	r2, [pc, #336]	; (5750 <Clock_Ip_ClockInitializeObjects+0x1c4>)
    55fe:	4413      	add	r3, r2
    5600:	4a55      	ldr	r2, [pc, #340]	; (5758 <Clock_Ip_ClockInitializeObjects+0x1cc>)
    5602:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxCoreRunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVCORE_RUN]];
    5604:	4b55      	ldr	r3, [pc, #340]	; (575c <Clock_Ip_ClockInitializeObjects+0x1d0>)
    5606:	799b      	ldrb	r3, [r3, #6]
    5608:	009b      	lsls	r3, r3, #2
    560a:	4a55      	ldr	r2, [pc, #340]	; (5760 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    560c:	4413      	add	r3, r2
    560e:	4a55      	ldr	r2, [pc, #340]	; (5764 <Clock_Ip_ClockInitializeObjects+0x1d8>)
    5610:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_CORE_HSRUN_CLK)
        Clock_Ip_pxCoreHsrunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVCORE_HSRUN]];
    5612:	4b52      	ldr	r3, [pc, #328]	; (575c <Clock_Ip_ClockInitializeObjects+0x1d0>)
    5614:	7a1b      	ldrb	r3, [r3, #8]
    5616:	009b      	lsls	r3, r3, #2
    5618:	4a51      	ldr	r2, [pc, #324]	; (5760 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    561a:	4413      	add	r3, r2
    561c:	4a52      	ldr	r2, [pc, #328]	; (5768 <Clock_Ip_ClockInitializeObjects+0x1dc>)
    561e:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxBusRunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVBUS_RUN]];
    5620:	4b4e      	ldr	r3, [pc, #312]	; (575c <Clock_Ip_ClockInitializeObjects+0x1d0>)
    5622:	7a5b      	ldrb	r3, [r3, #9]
    5624:	009b      	lsls	r3, r3, #2
    5626:	4a4e      	ldr	r2, [pc, #312]	; (5760 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    5628:	4413      	add	r3, r2
    562a:	4a50      	ldr	r2, [pc, #320]	; (576c <Clock_Ip_ClockInitializeObjects+0x1e0>)
    562c:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_BUS_HSRUN_CLK)
        Clock_Ip_pxBusHsrunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVBUS_HSRUN]];
    562e:	4b4b      	ldr	r3, [pc, #300]	; (575c <Clock_Ip_ClockInitializeObjects+0x1d0>)
    5630:	7adb      	ldrb	r3, [r3, #11]
    5632:	009b      	lsls	r3, r3, #2
    5634:	4a4a      	ldr	r2, [pc, #296]	; (5760 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    5636:	4413      	add	r3, r2
    5638:	4a4d      	ldr	r2, [pc, #308]	; (5770 <Clock_Ip_ClockInitializeObjects+0x1e4>)
    563a:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxSlowRunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVSLOW_RUN]];
    563c:	4b47      	ldr	r3, [pc, #284]	; (575c <Clock_Ip_ClockInitializeObjects+0x1d0>)
    563e:	7b1b      	ldrb	r3, [r3, #12]
    5640:	009b      	lsls	r3, r3, #2
    5642:	4a47      	ldr	r2, [pc, #284]	; (5760 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    5644:	4413      	add	r3, r2
    5646:	4a4b      	ldr	r2, [pc, #300]	; (5774 <Clock_Ip_ClockInitializeObjects+0x1e8>)
    5648:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SLOW_HSRUN_CLK)
        Clock_Ip_pxSlowHsrunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVSLOW_HSRUN]];
    564a:	4b44      	ldr	r3, [pc, #272]	; (575c <Clock_Ip_ClockInitializeObjects+0x1d0>)
    564c:	7b9b      	ldrb	r3, [r3, #14]
    564e:	009b      	lsls	r3, r3, #2
    5650:	4a43      	ldr	r2, [pc, #268]	; (5760 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    5652:	4413      	add	r3, r2
    5654:	4a48      	ldr	r2, [pc, #288]	; (5778 <Clock_Ip_ClockInitializeObjects+0x1ec>)
    5656:	6013      	str	r3, [r2, #0]
    #endif
    }

    if( ((TRUE == Clock_Ip_bAcceptedCopyClockConfiguration) && (Config == NULL_PTR)) || (Clock_Ip_bSentFromUpdateDriverContext ==TRUE) )
    5658:	4b48      	ldr	r3, [pc, #288]	; (577c <Clock_Ip_ClockInitializeObjects+0x1f0>)
    565a:	781b      	ldrb	r3, [r3, #0]
    565c:	2b00      	cmp	r3, #0
    565e:	d002      	beq.n	5666 <Clock_Ip_ClockInitializeObjects+0xda>
    5660:	9b01      	ldr	r3, [sp, #4]
    5662:	2b00      	cmp	r3, #0
    5664:	d003      	beq.n	566e <Clock_Ip_ClockInitializeObjects+0xe2>
    5666:	4b46      	ldr	r3, [pc, #280]	; (5780 <Clock_Ip_ClockInitializeObjects+0x1f4>)
    5668:	781b      	ldrb	r3, [r3, #0]
    566a:	2b00      	cmp	r3, #0
    566c:	d056      	beq.n	571c <Clock_Ip_ClockInitializeObjects+0x190>
    {
        Clock_Ip_pxFircConfig = getFircConfig();
    566e:	f7ff fc09 	bl	4e84 <getFircConfig>
    5672:	4603      	mov	r3, r0
    5674:	4a43      	ldr	r2, [pc, #268]	; (5784 <Clock_Ip_ClockInitializeObjects+0x1f8>)
    5676:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxSoscConfig = getSoscConfig();
    5678:	f7ff fc60 	bl	4f3c <getSoscConfig>
    567c:	4603      	mov	r3, r0
    567e:	4a42      	ldr	r2, [pc, #264]	; (5788 <Clock_Ip_ClockInitializeObjects+0x1fc>)
    5680:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SPLL_CLK)
        Clock_Ip_pxSpllConfig = getSpllConfig();
    5682:	f7ff fca7 	bl	4fd4 <getSpllConfig>
    5686:	4603      	mov	r3, r0
    5688:	4a40      	ldr	r2, [pc, #256]	; (578c <Clock_Ip_ClockInitializeObjects+0x200>)
    568a:	6013      	str	r3, [r2, #0]
    #endif
    #if defined(CLOCK_IP_HAS_FIRC_MON2_CLK)
        Clock_Ip_pxCmuFircMon2Config = getCmuFircConfig(FIRC_MON2_CLK);
    #endif

        Clock_Ip_pxScsConfigRunMode = getSelectorConfig(SCS_RUN_CLK);
    568c:	2019      	movs	r0, #25
    568e:	f7ff fcfb 	bl	5088 <getSelectorConfig>
    5692:	4603      	mov	r3, r0
    5694:	4a3e      	ldr	r2, [pc, #248]	; (5790 <Clock_Ip_ClockInitializeObjects+0x204>)
    5696:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxScsConfigVlprMode = getSelectorConfig(SCS_VLPR_CLK);
    5698:	201a      	movs	r0, #26
    569a:	f7ff fcf5 	bl	5088 <getSelectorConfig>
    569e:	4603      	mov	r3, r0
    56a0:	4a3c      	ldr	r2, [pc, #240]	; (5794 <Clock_Ip_ClockInitializeObjects+0x208>)
    56a2:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
        Clock_Ip_pxScsConfigHsrunMode = getSelectorConfig(SCS_HSRUN_CLK);
    56a4:	201b      	movs	r0, #27
    56a6:	f7ff fcef 	bl	5088 <getSelectorConfig>
    56aa:	4603      	mov	r3, r0
    56ac:	4a3a      	ldr	r2, [pc, #232]	; (5798 <Clock_Ip_ClockInitializeObjects+0x20c>)
    56ae:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxCoreConfigRunMode = getCoreDividerConfig(CORE_RUN_CLK);
    56b0:	201d      	movs	r0, #29
    56b2:	f7ff fd7b 	bl	51ac <getCoreDividerConfig>
    56b6:	4603      	mov	r3, r0
    56b8:	4a38      	ldr	r2, [pc, #224]	; (579c <Clock_Ip_ClockInitializeObjects+0x210>)
    56ba:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxCoreConfigVlprMode = getCoreDividerConfig(CORE_VLPR_CLK);
    56bc:	201e      	movs	r0, #30
    56be:	f7ff fd75 	bl	51ac <getCoreDividerConfig>
    56c2:	4603      	mov	r3, r0
    56c4:	4a36      	ldr	r2, [pc, #216]	; (57a0 <Clock_Ip_ClockInitializeObjects+0x214>)
    56c6:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_CORE_HSRUN_CLK)
        Clock_Ip_pxCoreConfigHsrunMode = getCoreDividerConfig(CORE_HSRUN_CLK);
    56c8:	201f      	movs	r0, #31
    56ca:	f7ff fd6f 	bl	51ac <getCoreDividerConfig>
    56ce:	4603      	mov	r3, r0
    56d0:	4a34      	ldr	r2, [pc, #208]	; (57a4 <Clock_Ip_ClockInitializeObjects+0x218>)
    56d2:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxBusConfigRunMode = getBusDividerConfig(BUS_RUN_CLK);
    56d4:	2021      	movs	r0, #33	; 0x21
    56d6:	f7ff fe0f 	bl	52f8 <getBusDividerConfig>
    56da:	4603      	mov	r3, r0
    56dc:	4a32      	ldr	r2, [pc, #200]	; (57a8 <Clock_Ip_ClockInitializeObjects+0x21c>)
    56de:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxBusConfigVlprMode = getBusDividerConfig(BUS_VLPR_CLK);
    56e0:	2022      	movs	r0, #34	; 0x22
    56e2:	f7ff fe09 	bl	52f8 <getBusDividerConfig>
    56e6:	4603      	mov	r3, r0
    56e8:	4a30      	ldr	r2, [pc, #192]	; (57ac <Clock_Ip_ClockInitializeObjects+0x220>)
    56ea:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_BUS_HSRUN_CLK)
        Clock_Ip_pxBusConfigHsrunMode = getBusDividerConfig(BUS_HSRUN_CLK);
    56ec:	2023      	movs	r0, #35	; 0x23
    56ee:	f7ff fe03 	bl	52f8 <getBusDividerConfig>
    56f2:	4603      	mov	r3, r0
    56f4:	4a2e      	ldr	r2, [pc, #184]	; (57b0 <Clock_Ip_ClockInitializeObjects+0x224>)
    56f6:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxSlowConfigRunMode = getSlowDividerConfig(SLOW_RUN_CLK);
    56f8:	2025      	movs	r0, #37	; 0x25
    56fa:	f7ff fea3 	bl	5444 <getSlowDividerConfig>
    56fe:	4603      	mov	r3, r0
    5700:	4a2c      	ldr	r2, [pc, #176]	; (57b4 <Clock_Ip_ClockInitializeObjects+0x228>)
    5702:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxSlowConfigVlprMode = getSlowDividerConfig(SLOW_VLPR_CLK);
    5704:	2026      	movs	r0, #38	; 0x26
    5706:	f7ff fe9d 	bl	5444 <getSlowDividerConfig>
    570a:	4603      	mov	r3, r0
    570c:	4a2a      	ldr	r2, [pc, #168]	; (57b8 <Clock_Ip_ClockInitializeObjects+0x22c>)
    570e:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SLOW_HSRUN_CLK)
        Clock_Ip_pxSlowConfigHsrunMode = getSlowDividerConfig(SLOW_HSRUN_CLK);
    5710:	2027      	movs	r0, #39	; 0x27
    5712:	f7ff fe97 	bl	5444 <getSlowDividerConfig>
    5716:	4603      	mov	r3, r0
    5718:	4a28      	ldr	r2, [pc, #160]	; (57bc <Clock_Ip_ClockInitializeObjects+0x230>)
    571a:	6013      	str	r3, [r2, #0]
    #endif
    }

}
    571c:	bf00      	nop
    571e:	b003      	add	sp, #12
    5720:	f85d fb04 	ldr.w	pc, [sp], #4
    5724:	1fff8cd8 	.word	0x1fff8cd8
    5728:	00017f6c 	.word	0x00017f6c
    572c:	000185b8 	.word	0x000185b8
    5730:	1fff8ba4 	.word	0x1fff8ba4
    5734:	00017f2c 	.word	0x00017f2c
    5738:	00018500 	.word	0x00018500
    573c:	1fff8ba8 	.word	0x1fff8ba8
    5740:	00017f3c 	.word	0x00017f3c
    5744:	0001856c 	.word	0x0001856c
    5748:	1fff8bac 	.word	0x1fff8bac
    574c:	00017f7c 	.word	0x00017f7c
    5750:	000185e4 	.word	0x000185e4
    5754:	1fff8bb0 	.word	0x1fff8bb0
    5758:	1fff8bec 	.word	0x1fff8bec
    575c:	00017f0c 	.word	0x00017f0c
    5760:	000184bc 	.word	0x000184bc
    5764:	1fff8bb4 	.word	0x1fff8bb4
    5768:	1fff8bf0 	.word	0x1fff8bf0
    576c:	1fff8bb8 	.word	0x1fff8bb8
    5770:	1fff8bf4 	.word	0x1fff8bf4
    5774:	1fff8bbc 	.word	0x1fff8bbc
    5778:	1fff8bf8 	.word	0x1fff8bf8
    577c:	1fff8b19 	.word	0x1fff8b19
    5780:	1fff8b10 	.word	0x1fff8b10
    5784:	1fff8bc0 	.word	0x1fff8bc0
    5788:	1fff8bc4 	.word	0x1fff8bc4
    578c:	1fff8bc8 	.word	0x1fff8bc8
    5790:	1fff8bcc 	.word	0x1fff8bcc
    5794:	1fff8bd0 	.word	0x1fff8bd0
    5798:	1fff8bfc 	.word	0x1fff8bfc
    579c:	1fff8bd4 	.word	0x1fff8bd4
    57a0:	1fff8bd8 	.word	0x1fff8bd8
    57a4:	1fff8c00 	.word	0x1fff8c00
    57a8:	1fff8bdc 	.word	0x1fff8bdc
    57ac:	1fff8be0 	.word	0x1fff8be0
    57b0:	1fff8c04 	.word	0x1fff8c04
    57b4:	1fff8be4 	.word	0x1fff8be4
    57b8:	1fff8be8 	.word	0x1fff8be8
    57bc:	1fff8c08 	.word	0x1fff8c08

000057c0 <Clock_Ip_ClockPowerModeChangeNotification>:


void Clock_Ip_ClockPowerModeChangeNotification(Clock_Ip_PowerModesType PowerMode, Clock_Ip_PowerNotificationType Notification)
{
    57c0:	b500      	push	{lr}
    57c2:	b083      	sub	sp, #12
    57c4:	9001      	str	r0, [sp, #4]
    57c6:	9100      	str	r1, [sp, #0]
    switch(PowerMode)
    57c8:	9b01      	ldr	r3, [sp, #4]
    57ca:	2b03      	cmp	r3, #3
    57cc:	f000 8090 	beq.w	58f0 <Clock_Ip_ClockPowerModeChangeNotification+0x130>
    57d0:	9b01      	ldr	r3, [sp, #4]
    57d2:	2b03      	cmp	r3, #3
    57d4:	f200 80d3 	bhi.w	597e <Clock_Ip_ClockPowerModeChangeNotification+0x1be>
    57d8:	9b01      	ldr	r3, [sp, #4]
    57da:	2b00      	cmp	r3, #0
    57dc:	d040      	beq.n	5860 <Clock_Ip_ClockPowerModeChangeNotification+0xa0>
    57de:	9b01      	ldr	r3, [sp, #4]
    57e0:	3b01      	subs	r3, #1
    57e2:	2b01      	cmp	r3, #1
    57e4:	f200 80cb 	bhi.w	597e <Clock_Ip_ClockPowerModeChangeNotification+0x1be>
    {
        case VLPR_MODE:
        case VLPS_MODE:
        {
            if(BEFORE_POWER_MODE_CHANGE == Notification)
    57e8:	9b00      	ldr	r3, [sp, #0]
    57ea:	2b00      	cmp	r3, #0
    57ec:	f040 80c9 	bne.w	5982 <Clock_Ip_ClockPowerModeChangeNotification+0x1c2>
            {
                Clock_Ip_bAcceptedCopyClockConfiguration = FALSE;
    57f0:	4b68      	ldr	r3, [pc, #416]	; (5994 <Clock_Ip_ClockPowerModeChangeNotification+0x1d4>)
    57f2:	2200      	movs	r2, #0
    57f4:	701a      	strb	r2, [r3, #0]
                    Clock_Ip_pxCmuFircMonitor->Disable(FIRC_MON2_CLK);
                }
#endif

                /* Load system clock settings for VLPR mode */
                Clock_Ip_pxScsRunClockSelector->Set(Clock_Ip_pxScsConfigVlprMode);
    57f6:	4b68      	ldr	r3, [pc, #416]	; (5998 <Clock_Ip_ClockPowerModeChangeNotification+0x1d8>)
    57f8:	681b      	ldr	r3, [r3, #0]
    57fa:	685b      	ldr	r3, [r3, #4]
    57fc:	4a67      	ldr	r2, [pc, #412]	; (599c <Clock_Ip_ClockPowerModeChangeNotification+0x1dc>)
    57fe:	6812      	ldr	r2, [r2, #0]
    5800:	4610      	mov	r0, r2
    5802:	4798      	blx	r3
                Clock_Ip_pxCoreRunClockDivider->Set(Clock_Ip_pxCoreConfigVlprMode);
    5804:	4b66      	ldr	r3, [pc, #408]	; (59a0 <Clock_Ip_ClockPowerModeChangeNotification+0x1e0>)
    5806:	681b      	ldr	r3, [r3, #0]
    5808:	681b      	ldr	r3, [r3, #0]
    580a:	4a66      	ldr	r2, [pc, #408]	; (59a4 <Clock_Ip_ClockPowerModeChangeNotification+0x1e4>)
    580c:	6812      	ldr	r2, [r2, #0]
    580e:	4610      	mov	r0, r2
    5810:	4798      	blx	r3
                Clock_Ip_pxBusRunClockDivider->Set(Clock_Ip_pxBusConfigVlprMode);
    5812:	4b65      	ldr	r3, [pc, #404]	; (59a8 <Clock_Ip_ClockPowerModeChangeNotification+0x1e8>)
    5814:	681b      	ldr	r3, [r3, #0]
    5816:	681b      	ldr	r3, [r3, #0]
    5818:	4a64      	ldr	r2, [pc, #400]	; (59ac <Clock_Ip_ClockPowerModeChangeNotification+0x1ec>)
    581a:	6812      	ldr	r2, [r2, #0]
    581c:	4610      	mov	r0, r2
    581e:	4798      	blx	r3
                Clock_Ip_pxSlowRunClockDivider->Set(Clock_Ip_pxSlowConfigVlprMode);
    5820:	4b63      	ldr	r3, [pc, #396]	; (59b0 <Clock_Ip_ClockPowerModeChangeNotification+0x1f0>)
    5822:	681b      	ldr	r3, [r3, #0]
    5824:	681b      	ldr	r3, [r3, #0]
    5826:	4a63      	ldr	r2, [pc, #396]	; (59b4 <Clock_Ip_ClockPowerModeChangeNotification+0x1f4>)
    5828:	6812      	ldr	r2, [r2, #0]
    582a:	4610      	mov	r0, r2
    582c:	4798      	blx	r3

                /* Disable all clock sources except SIRC */
#if defined(CLOCK_IP_HAS_SPLL_CLK)
                Clock_Ip_pxSpllClock->Disable(Clock_Ip_pxSpllConfig->Name);
    582e:	4b62      	ldr	r3, [pc, #392]	; (59b8 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    5830:	681b      	ldr	r3, [r3, #0]
    5832:	691b      	ldr	r3, [r3, #16]
    5834:	4a61      	ldr	r2, [pc, #388]	; (59bc <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    5836:	6812      	ldr	r2, [r2, #0]
    5838:	6812      	ldr	r2, [r2, #0]
    583a:	4610      	mov	r0, r2
    583c:	4798      	blx	r3
#endif
                Clock_Ip_pxSoscClock->Disable(Clock_Ip_pxSoscConfig->Name);
    583e:	4b60      	ldr	r3, [pc, #384]	; (59c0 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    5840:	681b      	ldr	r3, [r3, #0]
    5842:	68db      	ldr	r3, [r3, #12]
    5844:	4a5f      	ldr	r2, [pc, #380]	; (59c4 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    5846:	6812      	ldr	r2, [r2, #0]
    5848:	6812      	ldr	r2, [r2, #0]
    584a:	4610      	mov	r0, r2
    584c:	4798      	blx	r3
                Clock_Ip_pxFircClock->Disable(Clock_Ip_pxFircConfig->Name);
    584e:	4b5e      	ldr	r3, [pc, #376]	; (59c8 <Clock_Ip_ClockPowerModeChangeNotification+0x208>)
    5850:	681b      	ldr	r3, [r3, #0]
    5852:	689b      	ldr	r3, [r3, #8]
    5854:	4a5d      	ldr	r2, [pc, #372]	; (59cc <Clock_Ip_ClockPowerModeChangeNotification+0x20c>)
    5856:	6812      	ldr	r2, [r2, #0]
    5858:	6812      	ldr	r2, [r2, #0]
    585a:	4610      	mov	r0, r2
    585c:	4798      	blx	r3
            }
        }
        break;
    585e:	e090      	b.n	5982 <Clock_Ip_ClockPowerModeChangeNotification+0x1c2>

        case RUN_MODE:
        {
            if(POWER_MODE_CHANGED == Notification)
    5860:	9b00      	ldr	r3, [sp, #0]
    5862:	2b02      	cmp	r3, #2
    5864:	f040 808f 	bne.w	5986 <Clock_Ip_ClockPowerModeChangeNotification+0x1c6>
            {
                Clock_Ip_bAcceptedCopyClockConfiguration = TRUE;
    5868:	4b4a      	ldr	r3, [pc, #296]	; (5994 <Clock_Ip_ClockPowerModeChangeNotification+0x1d4>)
    586a:	2201      	movs	r2, #1
    586c:	701a      	strb	r2, [r3, #0]
                /* Restore clock source settings */
                Clock_Ip_pxFircClock->Enable(Clock_Ip_pxFircConfig);
    586e:	4b56      	ldr	r3, [pc, #344]	; (59c8 <Clock_Ip_ClockPowerModeChangeNotification+0x208>)
    5870:	681b      	ldr	r3, [r3, #0]
    5872:	685b      	ldr	r3, [r3, #4]
    5874:	4a55      	ldr	r2, [pc, #340]	; (59cc <Clock_Ip_ClockPowerModeChangeNotification+0x20c>)
    5876:	6812      	ldr	r2, [r2, #0]
    5878:	4610      	mov	r0, r2
    587a:	4798      	blx	r3

                Clock_Ip_pxSoscClock->Enable(Clock_Ip_pxSoscConfig);                 /* Enable */
    587c:	4b50      	ldr	r3, [pc, #320]	; (59c0 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    587e:	681b      	ldr	r3, [r3, #0]
    5880:	691b      	ldr	r3, [r3, #16]
    5882:	4a50      	ldr	r2, [pc, #320]	; (59c4 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    5884:	6812      	ldr	r2, [r2, #0]
    5886:	4610      	mov	r0, r2
    5888:	4798      	blx	r3
                Clock_Ip_pxSoscClock->Complete(Clock_Ip_pxSoscConfig);               /* Wait to lock */
    588a:	4b4d      	ldr	r3, [pc, #308]	; (59c0 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    588c:	681b      	ldr	r3, [r3, #0]
    588e:	689b      	ldr	r3, [r3, #8]
    5890:	4a4c      	ldr	r2, [pc, #304]	; (59c4 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    5892:	6812      	ldr	r2, [r2, #0]
    5894:	4610      	mov	r0, r2
    5896:	4798      	blx	r3

#if defined(CLOCK_IP_HAS_SPLL_CLK)
                Clock_Ip_pxSpllClock->Enable(Clock_Ip_pxSpllConfig);                 /* Enable */
    5898:	4b47      	ldr	r3, [pc, #284]	; (59b8 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    589a:	681b      	ldr	r3, [r3, #0]
    589c:	68db      	ldr	r3, [r3, #12]
    589e:	4a47      	ldr	r2, [pc, #284]	; (59bc <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    58a0:	6812      	ldr	r2, [r2, #0]
    58a2:	4610      	mov	r0, r2
    58a4:	4798      	blx	r3
                (void)(Clock_Ip_pxSpllClock->Complete(Clock_Ip_pxSpllConfig->Name));         /* Wait to lock */
    58a6:	4b44      	ldr	r3, [pc, #272]	; (59b8 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    58a8:	681b      	ldr	r3, [r3, #0]
    58aa:	689b      	ldr	r3, [r3, #8]
    58ac:	4a43      	ldr	r2, [pc, #268]	; (59bc <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    58ae:	6812      	ldr	r2, [r2, #0]
    58b0:	6812      	ldr	r2, [r2, #0]
    58b2:	4610      	mov	r0, r2
    58b4:	4798      	blx	r3
#endif

                /* Restore system clock settings */
                Clock_Ip_pxScsRunClockSelector->Set(Clock_Ip_pxScsConfigRunMode);
    58b6:	4b38      	ldr	r3, [pc, #224]	; (5998 <Clock_Ip_ClockPowerModeChangeNotification+0x1d8>)
    58b8:	681b      	ldr	r3, [r3, #0]
    58ba:	685b      	ldr	r3, [r3, #4]
    58bc:	4a44      	ldr	r2, [pc, #272]	; (59d0 <Clock_Ip_ClockPowerModeChangeNotification+0x210>)
    58be:	6812      	ldr	r2, [r2, #0]
    58c0:	4610      	mov	r0, r2
    58c2:	4798      	blx	r3
                Clock_Ip_pxCoreRunClockDivider->Set(Clock_Ip_pxCoreConfigRunMode);
    58c4:	4b36      	ldr	r3, [pc, #216]	; (59a0 <Clock_Ip_ClockPowerModeChangeNotification+0x1e0>)
    58c6:	681b      	ldr	r3, [r3, #0]
    58c8:	681b      	ldr	r3, [r3, #0]
    58ca:	4a42      	ldr	r2, [pc, #264]	; (59d4 <Clock_Ip_ClockPowerModeChangeNotification+0x214>)
    58cc:	6812      	ldr	r2, [r2, #0]
    58ce:	4610      	mov	r0, r2
    58d0:	4798      	blx	r3
                Clock_Ip_pxBusRunClockDivider->Set(Clock_Ip_pxBusConfigRunMode);
    58d2:	4b35      	ldr	r3, [pc, #212]	; (59a8 <Clock_Ip_ClockPowerModeChangeNotification+0x1e8>)
    58d4:	681b      	ldr	r3, [r3, #0]
    58d6:	681b      	ldr	r3, [r3, #0]
    58d8:	4a3f      	ldr	r2, [pc, #252]	; (59d8 <Clock_Ip_ClockPowerModeChangeNotification+0x218>)
    58da:	6812      	ldr	r2, [r2, #0]
    58dc:	4610      	mov	r0, r2
    58de:	4798      	blx	r3
                Clock_Ip_pxSlowRunClockDivider->Set(Clock_Ip_pxSlowConfigRunMode);
    58e0:	4b33      	ldr	r3, [pc, #204]	; (59b0 <Clock_Ip_ClockPowerModeChangeNotification+0x1f0>)
    58e2:	681b      	ldr	r3, [r3, #0]
    58e4:	681b      	ldr	r3, [r3, #0]
    58e6:	4a3d      	ldr	r2, [pc, #244]	; (59dc <Clock_Ip_ClockPowerModeChangeNotification+0x21c>)
    58e8:	6812      	ldr	r2, [r2, #0]
    58ea:	4610      	mov	r0, r2
    58ec:	4798      	blx	r3
                    Clock_Ip_pxCmuFircMonitor->Enable(Clock_Ip_pxCmuFircMon2Config);
                }
#endif
            }
        }
        break;
    58ee:	e04a      	b.n	5986 <Clock_Ip_ClockPowerModeChangeNotification+0x1c6>

        case HSRUN_MODE:
        {
            if(POWER_MODE_CHANGED == Notification)
    58f0:	9b00      	ldr	r3, [sp, #0]
    58f2:	2b02      	cmp	r3, #2
    58f4:	d149      	bne.n	598a <Clock_Ip_ClockPowerModeChangeNotification+0x1ca>
            {
                Clock_Ip_bAcceptedCopyClockConfiguration = TRUE;
    58f6:	4b27      	ldr	r3, [pc, #156]	; (5994 <Clock_Ip_ClockPowerModeChangeNotification+0x1d4>)
    58f8:	2201      	movs	r2, #1
    58fa:	701a      	strb	r2, [r3, #0]
                /* Restore clock source settings */
                Clock_Ip_pxFircClock->Enable(Clock_Ip_pxFircConfig);
    58fc:	4b32      	ldr	r3, [pc, #200]	; (59c8 <Clock_Ip_ClockPowerModeChangeNotification+0x208>)
    58fe:	681b      	ldr	r3, [r3, #0]
    5900:	685b      	ldr	r3, [r3, #4]
    5902:	4a32      	ldr	r2, [pc, #200]	; (59cc <Clock_Ip_ClockPowerModeChangeNotification+0x20c>)
    5904:	6812      	ldr	r2, [r2, #0]
    5906:	4610      	mov	r0, r2
    5908:	4798      	blx	r3

                Clock_Ip_pxSoscClock->Enable(Clock_Ip_pxSoscConfig);                 /* Enable */
    590a:	4b2d      	ldr	r3, [pc, #180]	; (59c0 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    590c:	681b      	ldr	r3, [r3, #0]
    590e:	691b      	ldr	r3, [r3, #16]
    5910:	4a2c      	ldr	r2, [pc, #176]	; (59c4 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    5912:	6812      	ldr	r2, [r2, #0]
    5914:	4610      	mov	r0, r2
    5916:	4798      	blx	r3
                Clock_Ip_pxSoscClock->Complete(Clock_Ip_pxSoscConfig);               /* Wait to lock */
    5918:	4b29      	ldr	r3, [pc, #164]	; (59c0 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    591a:	681b      	ldr	r3, [r3, #0]
    591c:	689b      	ldr	r3, [r3, #8]
    591e:	4a29      	ldr	r2, [pc, #164]	; (59c4 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    5920:	6812      	ldr	r2, [r2, #0]
    5922:	4610      	mov	r0, r2
    5924:	4798      	blx	r3

#if defined(CLOCK_IP_HAS_SPLL_CLK)
                Clock_Ip_pxSpllClock->Enable(Clock_Ip_pxSpllConfig);                 /* Enable */
    5926:	4b24      	ldr	r3, [pc, #144]	; (59b8 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    5928:	681b      	ldr	r3, [r3, #0]
    592a:	68db      	ldr	r3, [r3, #12]
    592c:	4a23      	ldr	r2, [pc, #140]	; (59bc <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    592e:	6812      	ldr	r2, [r2, #0]
    5930:	4610      	mov	r0, r2
    5932:	4798      	blx	r3
                (void)(Clock_Ip_pxSpllClock->Complete(Clock_Ip_pxSpllConfig->Name));         /* Wait to lock */
    5934:	4b20      	ldr	r3, [pc, #128]	; (59b8 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    5936:	681b      	ldr	r3, [r3, #0]
    5938:	689b      	ldr	r3, [r3, #8]
    593a:	4a20      	ldr	r2, [pc, #128]	; (59bc <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    593c:	6812      	ldr	r2, [r2, #0]
    593e:	6812      	ldr	r2, [r2, #0]
    5940:	4610      	mov	r0, r2
    5942:	4798      	blx	r3
#endif

                /* Restore system clock settings */
#if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
                Clock_Ip_pxScsHsrunClockSelector->Set(Clock_Ip_pxScsConfigHsrunMode);
    5944:	4b26      	ldr	r3, [pc, #152]	; (59e0 <Clock_Ip_ClockPowerModeChangeNotification+0x220>)
    5946:	681b      	ldr	r3, [r3, #0]
    5948:	685b      	ldr	r3, [r3, #4]
    594a:	4a26      	ldr	r2, [pc, #152]	; (59e4 <Clock_Ip_ClockPowerModeChangeNotification+0x224>)
    594c:	6812      	ldr	r2, [r2, #0]
    594e:	4610      	mov	r0, r2
    5950:	4798      	blx	r3
#endif
#if defined(CLOCK_IP_HAS_CORE_HSRUN_CLK)
                Clock_Ip_pxCoreHsrunClockDivider->Set(Clock_Ip_pxCoreConfigHsrunMode);
    5952:	4b25      	ldr	r3, [pc, #148]	; (59e8 <Clock_Ip_ClockPowerModeChangeNotification+0x228>)
    5954:	681b      	ldr	r3, [r3, #0]
    5956:	681b      	ldr	r3, [r3, #0]
    5958:	4a24      	ldr	r2, [pc, #144]	; (59ec <Clock_Ip_ClockPowerModeChangeNotification+0x22c>)
    595a:	6812      	ldr	r2, [r2, #0]
    595c:	4610      	mov	r0, r2
    595e:	4798      	blx	r3
#endif
#if defined(CLOCK_IP_HAS_BUS_HSRUN_CLK)
                Clock_Ip_pxBusHsrunClockDivider->Set(Clock_Ip_pxBusConfigHsrunMode);
    5960:	4b23      	ldr	r3, [pc, #140]	; (59f0 <Clock_Ip_ClockPowerModeChangeNotification+0x230>)
    5962:	681b      	ldr	r3, [r3, #0]
    5964:	681b      	ldr	r3, [r3, #0]
    5966:	4a23      	ldr	r2, [pc, #140]	; (59f4 <Clock_Ip_ClockPowerModeChangeNotification+0x234>)
    5968:	6812      	ldr	r2, [r2, #0]
    596a:	4610      	mov	r0, r2
    596c:	4798      	blx	r3
#endif
#if defined(CLOCK_IP_HAS_SLOW_HSRUN_CLK)
                Clock_Ip_pxSlowHsrunClockDivider->Set(Clock_Ip_pxSlowConfigHsrunMode);
    596e:	4b22      	ldr	r3, [pc, #136]	; (59f8 <Clock_Ip_ClockPowerModeChangeNotification+0x238>)
    5970:	681b      	ldr	r3, [r3, #0]
    5972:	681b      	ldr	r3, [r3, #0]
    5974:	4a21      	ldr	r2, [pc, #132]	; (59fc <Clock_Ip_ClockPowerModeChangeNotification+0x23c>)
    5976:	6812      	ldr	r2, [r2, #0]
    5978:	4610      	mov	r0, r2
    597a:	4798      	blx	r3
                    Clock_Ip_pxCmuFircMonitor->Enable(Clock_Ip_pxCmuFircMon2Config);
                }
#endif
            }
        }
        break;
    597c:	e005      	b.n	598a <Clock_Ip_ClockPowerModeChangeNotification+0x1ca>

        default:
        {
            /* Invalid power mode */
        }
        break;
    597e:	bf00      	nop
    5980:	e004      	b.n	598c <Clock_Ip_ClockPowerModeChangeNotification+0x1cc>
        break;
    5982:	bf00      	nop
    5984:	e002      	b.n	598c <Clock_Ip_ClockPowerModeChangeNotification+0x1cc>
        break;
    5986:	bf00      	nop
    5988:	e000      	b.n	598c <Clock_Ip_ClockPowerModeChangeNotification+0x1cc>
        break;
    598a:	bf00      	nop
    }

}
    598c:	bf00      	nop
    598e:	b003      	add	sp, #12
    5990:	f85d fb04 	ldr.w	pc, [sp], #4
    5994:	1fff8b19 	.word	0x1fff8b19
    5998:	1fff8bb0 	.word	0x1fff8bb0
    599c:	1fff8bd0 	.word	0x1fff8bd0
    59a0:	1fff8bb4 	.word	0x1fff8bb4
    59a4:	1fff8bd8 	.word	0x1fff8bd8
    59a8:	1fff8bb8 	.word	0x1fff8bb8
    59ac:	1fff8be0 	.word	0x1fff8be0
    59b0:	1fff8bbc 	.word	0x1fff8bbc
    59b4:	1fff8be8 	.word	0x1fff8be8
    59b8:	1fff8ba4 	.word	0x1fff8ba4
    59bc:	1fff8bc8 	.word	0x1fff8bc8
    59c0:	1fff8ba8 	.word	0x1fff8ba8
    59c4:	1fff8bc4 	.word	0x1fff8bc4
    59c8:	1fff8bac 	.word	0x1fff8bac
    59cc:	1fff8bc0 	.word	0x1fff8bc0
    59d0:	1fff8bcc 	.word	0x1fff8bcc
    59d4:	1fff8bd4 	.word	0x1fff8bd4
    59d8:	1fff8bdc 	.word	0x1fff8bdc
    59dc:	1fff8be4 	.word	0x1fff8be4
    59e0:	1fff8bec 	.word	0x1fff8bec
    59e4:	1fff8bfc 	.word	0x1fff8bfc
    59e8:	1fff8bf0 	.word	0x1fff8bf0
    59ec:	1fff8c00 	.word	0x1fff8c00
    59f0:	1fff8bf4 	.word	0x1fff8bf4
    59f4:	1fff8c04 	.word	0x1fff8c04
    59f8:	1fff8bf8 	.word	0x1fff8bf8
    59fc:	1fff8c08 	.word	0x1fff8c08

00005a00 <Clock_Ip_Command>:


void Clock_Ip_Command(Clock_Ip_ClockConfigType const * Config, Clock_Ip_CommandType Command)
{
    5a00:	b500      	push	{lr}
    5a02:	b083      	sub	sp, #12
    5a04:	9001      	str	r0, [sp, #4]
    5a06:	9100      	str	r1, [sp, #0]
    switch(Command)
    5a08:	9b00      	ldr	r3, [sp, #0]
    5a0a:	2b04      	cmp	r3, #4
    5a0c:	d010      	beq.n	5a30 <Clock_Ip_Command+0x30>
    5a0e:	9b00      	ldr	r3, [sp, #0]
    5a10:	2b04      	cmp	r3, #4
    5a12:	d811      	bhi.n	5a38 <Clock_Ip_Command+0x38>
    5a14:	9b00      	ldr	r3, [sp, #0]
    5a16:	2b01      	cmp	r3, #1
    5a18:	d006      	beq.n	5a28 <Clock_Ip_Command+0x28>
    5a1a:	9b00      	ldr	r3, [sp, #0]
    5a1c:	2b02      	cmp	r3, #2
    5a1e:	d10b      	bne.n	5a38 <Clock_Ip_Command+0x38>
    {
        case CLOCK_IP_INITIALIZE_CLOCK_OBJECTS_COMMAND:
            Clock_Ip_ClockInitializeObjects(Config);
    5a20:	9801      	ldr	r0, [sp, #4]
    5a22:	f7ff fdb3 	bl	558c <Clock_Ip_ClockInitializeObjects>
            break;
    5a26:	e008      	b.n	5a3a <Clock_Ip_Command+0x3a>
        case CLOCK_IP_INITIALIZE_PLATFORM_COMMAND:
            Clock_Ip_SpecificPlatformInitClock(Config);
    5a28:	9801      	ldr	r0, [sp, #4]
    5a2a:	f7ff f9db 	bl	4de4 <Clock_Ip_SpecificPlatformInitClock>
            break;
    5a2e:	e004      	b.n	5a3a <Clock_Ip_Command+0x3a>
        case CLOCK_IP_DISABLE_SAFE_CLOCK_COMMAND:
            DisableSafeClock(Config);
    5a30:	9801      	ldr	r0, [sp, #4]
    5a32:	f7ff f8ed 	bl	4c10 <DisableSafeClock>
            break;
    5a36:	e000      	b.n	5a3a <Clock_Ip_Command+0x3a>
        default:
            /* Command is not implemented on this platform */
            break;
    5a38:	bf00      	nop
    }
}
    5a3a:	bf00      	nop
    5a3c:	b003      	add	sp, #12
    5a3e:	f85d fb04 	ldr.w	pc, [sp], #4
    5a42:	bf00      	nop

00005a44 <Mcu_CheckInit>:
/**
* @brief Mcu_CheckInit - checks for Mcu_Init
* @implements Mcu_CheckInit_Activity
*/
static Std_ReturnType Mcu_CheckInit(const Mcu_ConfigType * ConfigPtr)
{
    5a44:	b500      	push	{lr}
    5a46:	b085      	sub	sp, #20
    5a48:	9001      	str	r0, [sp, #4]
    Std_ReturnType CheckStatus = (Std_ReturnType)E_OK;
    5a4a:	2300      	movs	r3, #0
    5a4c:	f88d 300f 	strb.w	r3, [sp, #15]

#if (MCU_PRECOMPILE_SUPPORT == STD_OFF)
    if (NULL_PTR == ConfigPtr)
    5a50:	9b01      	ldr	r3, [sp, #4]
    5a52:	2b00      	cmp	r3, #0
    5a54:	d108      	bne.n	5a68 <Mcu_CheckInit+0x24>
    {
        CheckStatus = (Std_ReturnType)E_NOT_OK;
    5a56:	2301      	movs	r3, #1
    5a58:	f88d 300f 	strb.w	r3, [sp, #15]

        (void) Det_ReportError((uint16)MCU_MODULE_ID, MCU_INSTANCE_ID, MCU_INIT_ID, MCU_E_INIT_FAILED);
    5a5c:	2311      	movs	r3, #17
    5a5e:	2200      	movs	r2, #0
    5a60:	2100      	movs	r1, #0
    5a62:	2065      	movs	r0, #101	; 0x65
    5a64:	f011 f996 	bl	16d94 <Det_ReportError>

        (void) Det_ReportError((uint16)MCU_MODULE_ID, MCU_INSTANCE_ID, MCU_INIT_ID, MCU_E_INIT_FAILED);
    }
#endif /* (MCU_PRECOMPILE_SUPPORT == STD_ON) */

    return CheckStatus;
    5a68:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    5a6c:	4618      	mov	r0, r3
    5a6e:	b005      	add	sp, #20
    5a70:	f85d fb04 	ldr.w	pc, [sp], #4

00005a74 <Mcu_CheckInitClock>:
/**
* @brief Mcu_CheckInitClock - checks for Mcu_InitClock
* @implements Mcu_CheckInitClock_Activity
*/
static Std_ReturnType Mcu_CheckInitClock(Mcu_ClockType ClockSetting)
{
    5a74:	b500      	push	{lr}
    5a76:	b085      	sub	sp, #20
    5a78:	9001      	str	r0, [sp, #4]
    Std_ReturnType CheckStatus = (Std_ReturnType)E_OK;
    5a7a:	2300      	movs	r3, #0
    5a7c:	f88d 300f 	strb.w	r3, [sp, #15]

    if (ClockSetting >= Mcu_pConfigPtr->NoClkConfigs)
    5a80:	4b0a      	ldr	r3, [pc, #40]	; (5aac <Mcu_CheckInitClock+0x38>)
    5a82:	681b      	ldr	r3, [r3, #0]
    5a84:	68db      	ldr	r3, [r3, #12]
    5a86:	9a01      	ldr	r2, [sp, #4]
    5a88:	429a      	cmp	r2, r3
    5a8a:	d308      	bcc.n	5a9e <Mcu_CheckInitClock+0x2a>
    {
        CheckStatus = (Std_ReturnType)E_NOT_OK;
    5a8c:	2301      	movs	r3, #1
    5a8e:	f88d 300f 	strb.w	r3, [sp, #15]

        (void) Det_ReportError((uint16)MCU_MODULE_ID, MCU_INSTANCE_ID, MCU_INITCLOCK_ID, MCU_E_PARAM_CLOCK);
    5a92:	230b      	movs	r3, #11
    5a94:	2202      	movs	r2, #2
    5a96:	2100      	movs	r1, #0
    5a98:	2065      	movs	r0, #101	; 0x65
    5a9a:	f011 f97b 	bl	16d94 <Det_ReportError>
    }

    return CheckStatus;
    5a9e:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    5aa2:	4618      	mov	r0, r3
    5aa4:	b005      	add	sp, #20
    5aa6:	f85d fb04 	ldr.w	pc, [sp], #4
    5aaa:	bf00      	nop
    5aac:	1fff8ce4 	.word	0x1fff8ce4

00005ab0 <Mcu_CheckSetMode>:
/**
* @brief Mcu_CheckSetMode - checks for Mcu_SetMode
* @implements Mcu_CheckSetMode_Activity
*/
static Std_ReturnType Mcu_CheckSetMode(Power_Ip_ModeType McuMode)
{
    5ab0:	b500      	push	{lr}
    5ab2:	b085      	sub	sp, #20
    5ab4:	9001      	str	r0, [sp, #4]
    Std_ReturnType CheckStatus = (Std_ReturnType)E_OK;
    5ab6:	2300      	movs	r3, #0
    5ab8:	f88d 300f 	strb.w	r3, [sp, #15]

    if (McuMode >= Mcu_pConfigPtr->NoModeConfigs)
    5abc:	4b0a      	ldr	r3, [pc, #40]	; (5ae8 <Mcu_CheckSetMode+0x38>)
    5abe:	681b      	ldr	r3, [r3, #0]
    5ac0:	689b      	ldr	r3, [r3, #8]
    5ac2:	9a01      	ldr	r2, [sp, #4]
    5ac4:	429a      	cmp	r2, r3
    5ac6:	d308      	bcc.n	5ada <Mcu_CheckSetMode+0x2a>
    {
        CheckStatus = (Std_ReturnType)E_NOT_OK;
    5ac8:	2301      	movs	r3, #1
    5aca:	f88d 300f 	strb.w	r3, [sp, #15]

        (void) Det_ReportError((uint16)MCU_MODULE_ID, MCU_INSTANCE_ID, MCU_SETMODE_ID, MCU_E_PARAM_MODE);
    5ace:	230c      	movs	r3, #12
    5ad0:	2208      	movs	r2, #8
    5ad2:	2100      	movs	r1, #0
    5ad4:	2065      	movs	r0, #101	; 0x65
    5ad6:	f011 f95d 	bl	16d94 <Det_ReportError>
    }

    return CheckStatus;
    5ada:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    5ade:	4618      	mov	r0, r3
    5ae0:	b005      	add	sp, #20
    5ae2:	f85d fb04 	ldr.w	pc, [sp], #4
    5ae6:	bf00      	nop
    5ae8:	1fff8ce4 	.word	0x1fff8ce4

00005aec <Mcu_CheckGetVersionInfo>:
/**
* @brief Mcu_CheckGetVersionInfo - checks for Mcu_GetVersionInfo
* @implements Mcu_CheckGetVersionInfo_Activity
*/
static Std_ReturnType Mcu_CheckGetVersionInfo(const Std_VersionInfoType * VersionInfo)
{
    5aec:	b500      	push	{lr}
    5aee:	b085      	sub	sp, #20
    5af0:	9001      	str	r0, [sp, #4]
    Std_ReturnType CheckStatus = (Std_ReturnType)E_OK;
    5af2:	2300      	movs	r3, #0
    5af4:	f88d 300f 	strb.w	r3, [sp, #15]

    if (NULL_PTR == VersionInfo)
    5af8:	9b01      	ldr	r3, [sp, #4]
    5afa:	2b00      	cmp	r3, #0
    5afc:	d108      	bne.n	5b10 <Mcu_CheckGetVersionInfo+0x24>
    {
        CheckStatus = (Std_ReturnType)E_NOT_OK;
    5afe:	2301      	movs	r3, #1
    5b00:	f88d 300f 	strb.w	r3, [sp, #15]

        (void)Det_ReportError((uint16)MCU_MODULE_ID, MCU_INSTANCE_ID, MCU_GETVERSIONINFO_ID, MCU_E_PARAM_POINTER);
    5b04:	2310      	movs	r3, #16
    5b06:	2209      	movs	r2, #9
    5b08:	2100      	movs	r1, #0
    5b0a:	2065      	movs	r0, #101	; 0x65
    5b0c:	f011 f942 	bl	16d94 <Det_ReportError>
    }

    return CheckStatus;
    5b10:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    5b14:	4618      	mov	r0, r3
    5b16:	b005      	add	sp, #20
    5b18:	f85d fb04 	ldr.w	pc, [sp], #4

00005b1c <Mcu_HLDChecksEntry>:
/**
* @brief Mcu_HLDChecksEntry - checks for invalid mode transitions.
* @implements Mcu_HLDChecksEntry_Activity
*/
static Std_ReturnType Mcu_HLDChecksEntry(uint8 McuServiceID)
{
    5b1c:	b500      	push	{lr}
    5b1e:	b085      	sub	sp, #20
    5b20:	4603      	mov	r3, r0
    5b22:	f88d 3007 	strb.w	r3, [sp, #7]
    Std_ReturnType CheckStatus = (Std_ReturnType)E_OK;
    5b26:	2300      	movs	r3, #0
    5b28:	f88d 300f 	strb.w	r3, [sp, #15]

    if (MCU_INIT_ID == McuServiceID)
    5b2c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5b30:	2b00      	cmp	r3, #0
    5b32:	d10e      	bne.n	5b52 <Mcu_HLDChecksEntry+0x36>
    {
        if (MCU_UNINIT != Mcu_eStatus) /* If "Mcu_Init" was already called (i.e. driver is initialized). */
    5b34:	4b13      	ldr	r3, [pc, #76]	; (5b84 <Mcu_HLDChecksEntry+0x68>)
    5b36:	681b      	ldr	r3, [r3, #0]
    5b38:	2b03      	cmp	r3, #3
    5b3a:	d01c      	beq.n	5b76 <Mcu_HLDChecksEntry+0x5a>
        {
            CheckStatus = (Std_ReturnType)E_NOT_OK;
    5b3c:	2301      	movs	r3, #1
    5b3e:	f88d 300f 	strb.w	r3, [sp, #15]
            (void) Det_ReportError((uint16)MCU_MODULE_ID, MCU_INSTANCE_ID, McuServiceID, MCU_E_ALREADY_INITIALIZED);
    5b42:	f89d 2007 	ldrb.w	r2, [sp, #7]
    5b46:	2313      	movs	r3, #19
    5b48:	2100      	movs	r1, #0
    5b4a:	2065      	movs	r0, #101	; 0x65
    5b4c:	f011 f922 	bl	16d94 <Det_ReportError>
    5b50:	e011      	b.n	5b76 <Mcu_HLDChecksEntry+0x5a>
        }
    }
    else
    {
        if (MCU_UNINIT == Mcu_eStatus) /* If "Mcu_Init" was not called (i.e driver is uninitialized). */
    5b52:	4b0c      	ldr	r3, [pc, #48]	; (5b84 <Mcu_HLDChecksEntry+0x68>)
    5b54:	681b      	ldr	r3, [r3, #0]
    5b56:	2b03      	cmp	r3, #3
    5b58:	d10a      	bne.n	5b70 <Mcu_HLDChecksEntry+0x54>
        {
            CheckStatus = (Std_ReturnType)E_NOT_OK;
    5b5a:	2301      	movs	r3, #1
    5b5c:	f88d 300f 	strb.w	r3, [sp, #15]
            (void) Det_ReportError((uint16)MCU_MODULE_ID, MCU_INSTANCE_ID, McuServiceID, MCU_E_UNINIT);
    5b60:	f89d 2007 	ldrb.w	r2, [sp, #7]
    5b64:	230f      	movs	r3, #15
    5b66:	2100      	movs	r1, #0
    5b68:	2065      	movs	r0, #101	; 0x65
    5b6a:	f011 f913 	bl	16d94 <Det_ReportError>
    5b6e:	e002      	b.n	5b76 <Mcu_HLDChecksEntry+0x5a>
        }
        else
        {
            Mcu_eStatus = MCU_BUSY;
    5b70:	4b04      	ldr	r3, [pc, #16]	; (5b84 <Mcu_HLDChecksEntry+0x68>)
    5b72:	220a      	movs	r2, #10
    5b74:	601a      	str	r2, [r3, #0]
        }
    }

    return CheckStatus;
    5b76:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    5b7a:	4618      	mov	r0, r3
    5b7c:	b005      	add	sp, #20
    5b7e:	f85d fb04 	ldr.w	pc, [sp], #4
    5b82:	bf00      	nop
    5b84:	1fff8b1c 	.word	0x1fff8b1c

00005b88 <Mcu_HLDChecksExit>:
* @implements Mcu_HLDChecksExit_Activity
*/
static void Mcu_HLDChecksExit(  Std_ReturnType RetStatus,
                                uint8 McuServiceID
                              )
{
    5b88:	b082      	sub	sp, #8
    5b8a:	4603      	mov	r3, r0
    5b8c:	460a      	mov	r2, r1
    5b8e:	f88d 3007 	strb.w	r3, [sp, #7]
    5b92:	4613      	mov	r3, r2
    5b94:	f88d 3006 	strb.w	r3, [sp, #6]
    if (MCU_INIT_ID == McuServiceID)
    5b98:	f89d 3006 	ldrb.w	r3, [sp, #6]
    5b9c:	2b00      	cmp	r3, #0
    5b9e:	d10b      	bne.n	5bb8 <Mcu_HLDChecksExit+0x30>
    {
        if ((Std_ReturnType)E_OK == (Std_ReturnType)RetStatus)
    5ba0:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5ba4:	2b00      	cmp	r3, #0
    5ba6:	d103      	bne.n	5bb0 <Mcu_HLDChecksExit+0x28>
        {
            Mcu_eStatus = MCU_IDLE;
    5ba8:	4b06      	ldr	r3, [pc, #24]	; (5bc4 <Mcu_HLDChecksExit+0x3c>)
    5baa:	220c      	movs	r2, #12
    5bac:	601a      	str	r2, [r3, #0]
    }
    else
    {
        Mcu_eStatus = MCU_IDLE;
    }
}
    5bae:	e006      	b.n	5bbe <Mcu_HLDChecksExit+0x36>
            Mcu_eStatus = MCU_UNINIT;
    5bb0:	4b04      	ldr	r3, [pc, #16]	; (5bc4 <Mcu_HLDChecksExit+0x3c>)
    5bb2:	2203      	movs	r2, #3
    5bb4:	601a      	str	r2, [r3, #0]
}
    5bb6:	e002      	b.n	5bbe <Mcu_HLDChecksExit+0x36>
        Mcu_eStatus = MCU_IDLE;
    5bb8:	4b02      	ldr	r3, [pc, #8]	; (5bc4 <Mcu_HLDChecksExit+0x3c>)
    5bba:	220c      	movs	r2, #12
    5bbc:	601a      	str	r2, [r3, #0]
}
    5bbe:	bf00      	nop
    5bc0:	b002      	add	sp, #8
    5bc2:	4770      	bx	lr
    5bc4:	1fff8b1c 	.word	0x1fff8b1c

00005bc8 <Mcu_Init>:
* @api
*
* @implements Mcu_Init_Activity
*/
void Mcu_Init(const Mcu_ConfigType * ConfigPtr)
{
    5bc8:	b500      	push	{lr}
    5bca:	b085      	sub	sp, #20
    5bcc:	9001      	str	r0, [sp, #4]
#if ( (MCU_VALIDATE_GLOBAL_CALL == STD_ON) || (MCU_PARAM_CHECK == STD_ON) )
    Std_ReturnType CheckStatus;
#endif /* ( (MCU_VALIDATE_GLOBAL_CALL == STD_ON) || (MCU_PARAM_CHECK == STD_ON) ) */

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    CheckStatus = (Std_ReturnType) Mcu_HLDChecksEntry(MCU_INIT_ID);
    5bce:	2000      	movs	r0, #0
    5bd0:	f7ff ffa4 	bl	5b1c <Mcu_HLDChecksEntry>
    5bd4:	4603      	mov	r3, r0
    5bd6:	f88d 300b 	strb.w	r3, [sp, #11]

    if ( (Std_ReturnType)E_OK == CheckStatus )
    5bda:	f89d 300b 	ldrb.w	r3, [sp, #11]
    5bde:	2b00      	cmp	r3, #0
    5be0:	d150      	bne.n	5c84 <Mcu_Init+0xbc>

#if (MCU_PARAM_CHECK == STD_ON)
        /* When PostBuild is used and #(Variants) > 1, the input parameter 'ConfigPtr' is mandatory
         * to be different than NULL_PTR. */
        /* Check the config. In case of error, return immediately. The "Mcu_CheckInit" function will report DET errors. */
        CheckStatus = Mcu_CheckInit(ConfigPtr);
    5be2:	9801      	ldr	r0, [sp, #4]
    5be4:	f7ff ff2e 	bl	5a44 <Mcu_CheckInit>
    5be8:	4603      	mov	r3, r0
    5bea:	f88d 300b 	strb.w	r3, [sp, #11]

        if ((Std_ReturnType)E_OK == CheckStatus)
    5bee:	f89d 300b 	ldrb.w	r3, [sp, #11]
    5bf2:	2b00      	cmp	r3, #0
    5bf4:	d13d      	bne.n	5c72 <Mcu_Init+0xaa>

#if (MCU_PRECOMPILE_SUPPORT == STD_ON)
            Mcu_pConfigPtr = &Mcu_PreCompileConfig;
            MCU_PARAM_UNUSED(ConfigPtr);
#else
            Mcu_pConfigPtr = ConfigPtr;
    5bf6:	4a25      	ldr	r2, [pc, #148]	; (5c8c <Mcu_Init+0xc4>)
    5bf8:	9b01      	ldr	r3, [sp, #4]
    5bfa:	6013      	str	r3, [r2, #0]
            /* Get a local copy of the DEM error reporting structure. */
            Mcu_pDemCfgPtr = Mcu_pConfigPtr->DemConfigPtr;
#endif /* (MCU_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF) */

            /* Save the Mcu Mode IDs configurations. */
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoModeConfigs; NoConfigs++)
    5bfc:	2300      	movs	r3, #0
    5bfe:	9303      	str	r3, [sp, #12]
    5c00:	e010      	b.n	5c24 <Mcu_Init+0x5c>
            {
                Mcu_au8ModeConfigIds[(*Mcu_pConfigPtr->ModeConfigArrayPtr)[NoConfigs].ModeConfigId] = (uint8)NoConfigs;
    5c02:	4b22      	ldr	r3, [pc, #136]	; (5c8c <Mcu_Init+0xc4>)
    5c04:	681b      	ldr	r3, [r3, #0]
    5c06:	6919      	ldr	r1, [r3, #16]
    5c08:	9a03      	ldr	r2, [sp, #12]
    5c0a:	4613      	mov	r3, r2
    5c0c:	005b      	lsls	r3, r3, #1
    5c0e:	4413      	add	r3, r2
    5c10:	009b      	lsls	r3, r3, #2
    5c12:	440b      	add	r3, r1
    5c14:	681b      	ldr	r3, [r3, #0]
    5c16:	9a03      	ldr	r2, [sp, #12]
    5c18:	b2d1      	uxtb	r1, r2
    5c1a:	4a1d      	ldr	r2, [pc, #116]	; (5c90 <Mcu_Init+0xc8>)
    5c1c:	54d1      	strb	r1, [r2, r3]
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoModeConfigs; NoConfigs++)
    5c1e:	9b03      	ldr	r3, [sp, #12]
    5c20:	3301      	adds	r3, #1
    5c22:	9303      	str	r3, [sp, #12]
    5c24:	4b19      	ldr	r3, [pc, #100]	; (5c8c <Mcu_Init+0xc4>)
    5c26:	681b      	ldr	r3, [r3, #0]
    5c28:	689b      	ldr	r3, [r3, #8]
    5c2a:	9a03      	ldr	r2, [sp, #12]
    5c2c:	429a      	cmp	r2, r3
    5c2e:	d3e8      	bcc.n	5c02 <Mcu_Init+0x3a>
            }

#if (MCU_INIT_CLOCK == STD_ON)
            /* Save the Mcu Clock IDs configurations. */
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoClkConfigs; NoConfigs++)
    5c30:	2300      	movs	r3, #0
    5c32:	9303      	str	r3, [sp, #12]
    5c34:	e010      	b.n	5c58 <Mcu_Init+0x90>
            {
                Mcu_au8ClockConfigIds[(*Mcu_pConfigPtr->ClockConfigArrayPtr)[NoConfigs].ClkConfigId] = (uint8)NoConfigs;
    5c36:	4b15      	ldr	r3, [pc, #84]	; (5c8c <Mcu_Init+0xc4>)
    5c38:	681b      	ldr	r3, [r3, #0]
    5c3a:	6959      	ldr	r1, [r3, #20]
    5c3c:	9a03      	ldr	r2, [sp, #12]
    5c3e:	4613      	mov	r3, r2
    5c40:	01db      	lsls	r3, r3, #7
    5c42:	1a9b      	subs	r3, r3, r2
    5c44:	00db      	lsls	r3, r3, #3
    5c46:	440b      	add	r3, r1
    5c48:	681b      	ldr	r3, [r3, #0]
    5c4a:	9a03      	ldr	r2, [sp, #12]
    5c4c:	b2d1      	uxtb	r1, r2
    5c4e:	4a11      	ldr	r2, [pc, #68]	; (5c94 <Mcu_Init+0xcc>)
    5c50:	54d1      	strb	r1, [r2, r3]
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoClkConfigs; NoConfigs++)
    5c52:	9b03      	ldr	r3, [sp, #12]
    5c54:	3301      	adds	r3, #1
    5c56:	9303      	str	r3, [sp, #12]
    5c58:	4b0c      	ldr	r3, [pc, #48]	; (5c8c <Mcu_Init+0xc4>)
    5c5a:	681b      	ldr	r3, [r3, #0]
    5c5c:	68db      	ldr	r3, [r3, #12]
    5c5e:	9a03      	ldr	r2, [sp, #12]
    5c60:	429a      	cmp	r2, r3
    5c62:	d3e8      	bcc.n	5c36 <Mcu_Init+0x6e>
            {
                Mcu_au8RamConfigIds[(*Mcu_pConfigPtr->RamConfigArrayPtr)[NoConfigs].RamSectorId] = (uint8)NoConfigs;
            }
#endif /* (0 != MCU_MAX_RAMCONFIGS) */

            Mcu_Ipw_Init(Mcu_pConfigPtr->HwIPsConfigPtr);
    5c64:	4b09      	ldr	r3, [pc, #36]	; (5c8c <Mcu_Init+0xc4>)
    5c66:	681b      	ldr	r3, [r3, #0]
    5c68:	699b      	ldr	r3, [r3, #24]
    5c6a:	4618      	mov	r0, r3
    5c6c:	f000 f90c 	bl	5e88 <Mcu_Ipw_Init>
    5c70:	e002      	b.n	5c78 <Mcu_Init+0xb0>
#if (MCU_PARAM_CHECK == STD_ON)
        }
        else
        {
            /* Clean the init pointer in case of an error. */
            Mcu_pConfigPtr = NULL_PTR;
    5c72:	4b06      	ldr	r3, [pc, #24]	; (5c8c <Mcu_Init+0xc4>)
    5c74:	2200      	movs	r2, #0
    5c76:	601a      	str	r2, [r3, #0]
#endif /* (MCU_PARAM_CHECK == STD_ON) */


#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        /* The driver is now initialized. Set the proper status. */
        Mcu_HLDChecksExit(CheckStatus, MCU_INIT_ID);
    5c78:	f89d 300b 	ldrb.w	r3, [sp, #11]
    5c7c:	2100      	movs	r1, #0
    5c7e:	4618      	mov	r0, r3
    5c80:	f7ff ff82 	bl	5b88 <Mcu_HLDChecksExit>
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
}
    5c84:	bf00      	nop
    5c86:	b005      	add	sp, #20
    5c88:	f85d fb04 	ldr.w	pc, [sp], #4
    5c8c:	1fff8ce4 	.word	0x1fff8ce4
    5c90:	1fff8ce0 	.word	0x1fff8ce0
    5c94:	1fff8cdc 	.word	0x1fff8cdc

00005c98 <Mcu_InitRamSection>:
*
* @implements Mcu_InitRamSection_Activity
*
*/
Std_ReturnType Mcu_InitRamSection(Mcu_RamSectionType RamSection)
{
    5c98:	b500      	push	{lr}
    5c9a:	b085      	sub	sp, #20
    5c9c:	9001      	str	r0, [sp, #4]
#ifndef MCU_MAX_NORAMCONFIGS
    const uint8 RamConfigId = Mcu_au8RamConfigIds[RamSection];
#endif /* #ifndef MCU_MAX_NORAMCONFIGS */
    /* Result of the operation. */
    Std_ReturnType RamStatus = (Std_ReturnType)E_NOT_OK;
    5c9e:	2301      	movs	r3, #1
    5ca0:	f88d 300f 	strb.w	r3, [sp, #15]

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    /* Check if the driver is initialized. */
    if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_HLDChecksEntry(MCU_INITRAMSECTION_ID) )
    5ca4:	2001      	movs	r0, #1
    5ca6:	f7ff ff39 	bl	5b1c <Mcu_HLDChecksEntry>
    5caa:	4603      	mov	r3, r0
    5cac:	2b00      	cmp	r3, #0
    5cae:	d103      	bne.n	5cb8 <Mcu_InitRamSection+0x20>
        /* To avoid compiler warning. */
        MCU_PARAM_UNUSED(RamSection);
#endif /* #ifndef MCU_MAX_NORAMCONFIGS */

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_INITRAMSECTION_ID);
    5cb0:	2101      	movs	r1, #1
    5cb2:	2000      	movs	r0, #0
    5cb4:	f7ff ff68 	bl	5b88 <Mcu_HLDChecksExit>
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return RamStatus;
    5cb8:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    5cbc:	4618      	mov	r0, r3
    5cbe:	b005      	add	sp, #20
    5cc0:	f85d fb04 	ldr.w	pc, [sp], #4

00005cc4 <Mcu_InitClock>:
* @api
*
* @implements Mcu_InitClock_Activity
*/
Std_ReturnType Mcu_InitClock(Mcu_ClockType ClockSetting)
{
    5cc4:	b500      	push	{lr}
    5cc6:	b085      	sub	sp, #20
    5cc8:	9001      	str	r0, [sp, #4]
    const uint8 ClockConfigId =  Mcu_au8ClockConfigIds[ClockSetting];
    5cca:	4a17      	ldr	r2, [pc, #92]	; (5d28 <Mcu_InitClock+0x64>)
    5ccc:	9b01      	ldr	r3, [sp, #4]
    5cce:	4413      	add	r3, r2
    5cd0:	781b      	ldrb	r3, [r3, #0]
    5cd2:	f88d 300e 	strb.w	r3, [sp, #14]
    /* Return the success of the clock initalization operation. */
#if ( (MCU_VALIDATE_GLOBAL_CALL == STD_ON) || (MCU_PARAM_CHECK == STD_ON) )
    Std_ReturnType ClockStatus = (Std_ReturnType)E_NOT_OK;
    5cd6:	2301      	movs	r3, #1
    5cd8:	f88d 300f 	strb.w	r3, [sp, #15]
#else
    Std_ReturnType ClockStatus;
#endif

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_HLDChecksEntry(MCU_INITCLOCK_ID) )
    5cdc:	2002      	movs	r0, #2
    5cde:	f7ff ff1d 	bl	5b1c <Mcu_HLDChecksEntry>
    5ce2:	4603      	mov	r3, r0
    5ce4:	2b00      	cmp	r3, #0
    5ce6:	d119      	bne.n	5d1c <Mcu_InitClock+0x58>
    {
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

        /* Check if Clock configuration is valid. */
#if (MCU_PARAM_CHECK == STD_ON)
        if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_CheckInitClock(ClockSetting) )
    5ce8:	9801      	ldr	r0, [sp, #4]
    5cea:	f7ff fec3 	bl	5a74 <Mcu_CheckInitClock>
    5cee:	4603      	mov	r3, r0
    5cf0:	2b00      	cmp	r3, #0
    5cf2:	d10f      	bne.n	5d14 <Mcu_InitClock+0x50>
        {
#endif /* (MCU_PARAM_CHECK == STD_ON) */
            Mcu_Ipw_InitClock(&(*Mcu_pConfigPtr->ClockConfigArrayPtr)[ClockConfigId]);
    5cf4:	4b0d      	ldr	r3, [pc, #52]	; (5d2c <Mcu_InitClock+0x68>)
    5cf6:	681b      	ldr	r3, [r3, #0]
    5cf8:	6959      	ldr	r1, [r3, #20]
    5cfa:	f89d 200e 	ldrb.w	r2, [sp, #14]
    5cfe:	4613      	mov	r3, r2
    5d00:	01db      	lsls	r3, r3, #7
    5d02:	1a9b      	subs	r3, r3, r2
    5d04:	00db      	lsls	r3, r3, #3
    5d06:	440b      	add	r3, r1
    5d08:	4618      	mov	r0, r3
    5d0a:	f000 f8c7 	bl	5e9c <Mcu_Ipw_InitClock>

            /* Command has been accepted. */
            ClockStatus = (Std_ReturnType)E_OK;
    5d0e:	2300      	movs	r3, #0
    5d10:	f88d 300f 	strb.w	r3, [sp, #15]
#if (MCU_PARAM_CHECK == STD_ON)
        }
#endif /* (MCU_PARAM_CHECK == STD_ON) */

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_INITCLOCK_ID);
    5d14:	2102      	movs	r1, #2
    5d16:	2000      	movs	r0, #0
    5d18:	f7ff ff36 	bl	5b88 <Mcu_HLDChecksExit>
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return ClockStatus;
    5d1c:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    5d20:	4618      	mov	r0, r3
    5d22:	b005      	add	sp, #20
    5d24:	f85d fb04 	ldr.w	pc, [sp], #4
    5d28:	1fff8cdc 	.word	0x1fff8cdc
    5d2c:	1fff8ce4 	.word	0x1fff8ce4

00005d30 <Mcu_SetMode>:
* @api
*
* @implements Mcu_SetMode_Activity
*/
void Mcu_SetMode(Mcu_ModeType McuMode)
{
    5d30:	b500      	push	{lr}
    5d32:	b085      	sub	sp, #20
    5d34:	9001      	str	r0, [sp, #4]
    const uint8 McuModeId = Mcu_au8ModeConfigIds[McuMode];
    5d36:	4a15      	ldr	r2, [pc, #84]	; (5d8c <Mcu_SetMode+0x5c>)
    5d38:	9b01      	ldr	r3, [sp, #4]
    5d3a:	4413      	add	r3, r2
    5d3c:	781b      	ldrb	r3, [r3, #0]
    5d3e:	f88d 300f 	strb.w	r3, [sp, #15]

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_HLDChecksEntry(MCU_SETMODE_ID) )
    5d42:	2008      	movs	r0, #8
    5d44:	f7ff feea 	bl	5b1c <Mcu_HLDChecksEntry>
    5d48:	4603      	mov	r3, r0
    5d4a:	2b00      	cmp	r3, #0
    5d4c:	d11a      	bne.n	5d84 <Mcu_SetMode+0x54>
    {
#endif /*( MCU_VALIDATE_GLOBAL_CALL == STD_ON )*/

#if (MCU_PARAM_CHECK == STD_ON)
        /* Check if Mode configuration is valid. */
        if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_CheckSetMode(McuMode) )
    5d4e:	9801      	ldr	r0, [sp, #4]
    5d50:	f7ff feae 	bl	5ab0 <Mcu_CheckSetMode>
    5d54:	4603      	mov	r3, r0
    5d56:	2b00      	cmp	r3, #0
    5d58:	d110      	bne.n	5d7c <Mcu_SetMode+0x4c>
        {
#endif /* (MCU_PARAM_CHECK == STD_ON) */
            /* ASR 4.3.1: "Mcu_SetMode" has to be "concurrency-safe" */
            SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00();
    5d5a:	f00e fed3 	bl	14b04 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00>

            Mcu_Ipw_SetMode( &(*Mcu_pConfigPtr->ModeConfigArrayPtr)[McuModeId] );
    5d5e:	4b0c      	ldr	r3, [pc, #48]	; (5d90 <Mcu_SetMode+0x60>)
    5d60:	681b      	ldr	r3, [r3, #0]
    5d62:	6919      	ldr	r1, [r3, #16]
    5d64:	f89d 200f 	ldrb.w	r2, [sp, #15]
    5d68:	4613      	mov	r3, r2
    5d6a:	005b      	lsls	r3, r3, #1
    5d6c:	4413      	add	r3, r2
    5d6e:	009b      	lsls	r3, r3, #2
    5d70:	440b      	add	r3, r1
    5d72:	4618      	mov	r0, r3
    5d74:	f000 f89c 	bl	5eb0 <Mcu_Ipw_SetMode>

            SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00();
    5d78:	f00e fef0 	bl	14b5c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00>
        }
#endif /* (MCU_PARAM_CHECK == STD_ON) */


#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_SETMODE_ID);
    5d7c:	2108      	movs	r1, #8
    5d7e:	2000      	movs	r0, #0
    5d80:	f7ff ff02 	bl	5b88 <Mcu_HLDChecksExit>
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
}
    5d84:	bf00      	nop
    5d86:	b005      	add	sp, #20
    5d88:	f85d fb04 	ldr.w	pc, [sp], #4
    5d8c:	1fff8ce0 	.word	0x1fff8ce0
    5d90:	1fff8ce4 	.word	0x1fff8ce4

00005d94 <Mcu_GetPllStatus>:
* @implements Mcu_GetPllStatus_Activity
*
*
*/
Mcu_PllStatusType Mcu_GetPllStatus(void)
{
    5d94:	b500      	push	{lr}
    5d96:	b083      	sub	sp, #12
    /* Return variable. */
#if ( (MCU_VALIDATE_GLOBAL_CALL == STD_ON) || (MCU_NO_PLL == STD_ON) )
    Mcu_PllStatusType PllStatus = MCU_PLL_STATUS_UNDEFINED;
    5d98:	2302      	movs	r3, #2
    5d9a:	9301      	str	r3, [sp, #4]
#else
    Mcu_PllStatusType PllStatus;
#endif

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_HLDChecksEntry(MCU_GETPLLSTATUS_ID) )
    5d9c:	2004      	movs	r0, #4
    5d9e:	f7ff febd 	bl	5b1c <Mcu_HLDChecksEntry>
    5da2:	4603      	mov	r3, r0
    5da4:	2b00      	cmp	r3, #0
    5da6:	d103      	bne.n	5db0 <Mcu_GetPllStatus+0x1c>
           At this point, the return value can be only MCU_PLL_LOCKED or MCU_PLL_UNLOCKED. */
        PllStatus = Mcu_Ipw_GetPllStatus();
#endif /* (MCU_NO_PLL == STD_OFF) */

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_GETPLLSTATUS_ID);
    5da8:	2104      	movs	r1, #4
    5daa:	2000      	movs	r0, #0
    5dac:	f7ff feec 	bl	5b88 <Mcu_HLDChecksExit>
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return PllStatus;
    5db0:	9b01      	ldr	r3, [sp, #4]
}
    5db2:	4618      	mov	r0, r3
    5db4:	b003      	add	sp, #12
    5db6:	f85d fb04 	ldr.w	pc, [sp], #4

00005dba <Mcu_GetResetReason>:
* @api
*
* @implements Mcu_GetResetReason_Activity
*/
Mcu_ResetType Mcu_GetResetReason(void)
{
    5dba:	b500      	push	{lr}
    5dbc:	b083      	sub	sp, #12
    /* Return value of the function. */
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    Mcu_ResetType ResetReason = MCU_RESET_UNDEFINED;
    5dbe:	230e      	movs	r3, #14
    5dc0:	9301      	str	r3, [sp, #4]
#else
    Mcu_ResetType ResetReason;
#endif

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_HLDChecksEntry(MCU_GETRESETREASON_ID) )
    5dc2:	2005      	movs	r0, #5
    5dc4:	f7ff feaa 	bl	5b1c <Mcu_HLDChecksEntry>
    5dc8:	4603      	mov	r3, r0
    5dca:	2b00      	cmp	r3, #0
    5dcc:	d106      	bne.n	5ddc <Mcu_GetResetReason+0x22>
    {
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
        /* Get the reset reason. */
        ResetReason = Mcu_Ipw_GetResetReason();
    5dce:	f000 f879 	bl	5ec4 <Mcu_Ipw_GetResetReason>
    5dd2:	9001      	str	r0, [sp, #4]

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit( (Std_ReturnType)E_OK, MCU_GETRESETREASON_ID);
    5dd4:	2105      	movs	r1, #5
    5dd6:	2000      	movs	r0, #0
    5dd8:	f7ff fed6 	bl	5b88 <Mcu_HLDChecksExit>
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return ResetReason;
    5ddc:	9b01      	ldr	r3, [sp, #4]
}
    5dde:	4618      	mov	r0, r3
    5de0:	b003      	add	sp, #12
    5de2:	f85d fb04 	ldr.w	pc, [sp], #4

00005de6 <Mcu_GetResetRawValue>:
*
* @implements Mcu_GetResetRawValue_Activity
*
*/
Mcu_RawResetType Mcu_GetResetRawValue(void)
{
    5de6:	b500      	push	{lr}
    5de8:	b083      	sub	sp, #12
    /* Return value of the function. */
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    Mcu_RawResetType RawResetValue = MCU_RAW_RESET_DEFAULT;
    5dea:	f04f 33ff 	mov.w	r3, #4294967295
    5dee:	9301      	str	r3, [sp, #4]
#else
    Mcu_RawResetType RawResetValue;
#endif

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_HLDChecksEntry(MCU_GETRESETRAWVALUE_ID) )
    5df0:	2006      	movs	r0, #6
    5df2:	f7ff fe93 	bl	5b1c <Mcu_HLDChecksEntry>
    5df6:	4603      	mov	r3, r0
    5df8:	2b00      	cmp	r3, #0
    5dfa:	d106      	bne.n	5e0a <Mcu_GetResetRawValue+0x24>
    {
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
        RawResetValue = (Mcu_RawResetType) Mcu_Ipw_GetResetRawValue();
    5dfc:	f000 f868 	bl	5ed0 <Mcu_Ipw_GetResetRawValue>
    5e00:	9001      	str	r0, [sp, #4]

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_GETRESETRAWVALUE_ID);
    5e02:	2106      	movs	r1, #6
    5e04:	2000      	movs	r0, #0
    5e06:	f7ff febf 	bl	5b88 <Mcu_HLDChecksExit>
    }
#endif /*( MCU_VALIDATE_GLOBAL_CALL == STD_ON )*/

    return RawResetValue;
    5e0a:	9b01      	ldr	r3, [sp, #4]
}
    5e0c:	4618      	mov	r0, r3
    5e0e:	b003      	add	sp, #12
    5e10:	f85d fb04 	ldr.w	pc, [sp], #4

00005e14 <Mcu_GetVersionInfo>:
* @api
*
* @implements Mcu_GetVersionInfo_Activity
*/
void Mcu_GetVersionInfo(Std_VersionInfoType * versioninfo)
{
    5e14:	b500      	push	{lr}
    5e16:	b083      	sub	sp, #12
    5e18:	9001      	str	r0, [sp, #4]
#if (MCU_PARAM_CHECK == STD_ON)
    if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_CheckGetVersionInfo(versioninfo) )
    5e1a:	9801      	ldr	r0, [sp, #4]
    5e1c:	f7ff fe66 	bl	5aec <Mcu_CheckGetVersionInfo>
    5e20:	4603      	mov	r3, r0
    5e22:	2b00      	cmp	r3, #0
    5e24:	d10e      	bne.n	5e44 <Mcu_GetVersionInfo+0x30>
    {
#endif /* (MCU_PARAM_CHECK == STD_ON) */
        (versioninfo)->vendorID = (uint16)MCU_VENDOR_ID;
    5e26:	9b01      	ldr	r3, [sp, #4]
    5e28:	222b      	movs	r2, #43	; 0x2b
    5e2a:	801a      	strh	r2, [r3, #0]
        (versioninfo)->moduleID = (uint8)MCU_MODULE_ID;
    5e2c:	9b01      	ldr	r3, [sp, #4]
    5e2e:	2265      	movs	r2, #101	; 0x65
    5e30:	805a      	strh	r2, [r3, #2]
        (versioninfo)->sw_major_version = (uint8)MCU_SW_MAJOR_VERSION;
    5e32:	9b01      	ldr	r3, [sp, #4]
    5e34:	2202      	movs	r2, #2
    5e36:	711a      	strb	r2, [r3, #4]
        (versioninfo)->sw_minor_version = (uint8)MCU_SW_MINOR_VERSION;
    5e38:	9b01      	ldr	r3, [sp, #4]
    5e3a:	2200      	movs	r2, #0
    5e3c:	715a      	strb	r2, [r3, #5]
        (versioninfo)->sw_patch_version = (uint8)MCU_SW_PATCH_VERSION;
    5e3e:	9b01      	ldr	r3, [sp, #4]
    5e40:	2200      	movs	r2, #0
    5e42:	719a      	strb	r2, [r3, #6]
#if (MCU_PARAM_CHECK == STD_ON)
    }
#endif /* (MCU_PARAM_CHECK == STD_ON) */
}
    5e44:	bf00      	nop
    5e46:	b003      	add	sp, #12
    5e48:	f85d fb04 	ldr.w	pc, [sp], #4

00005e4c <Mcu_SleepOnExit>:
*
* @implements Mcu_SleepOnExit_Activity
*
*/
void Mcu_SleepOnExit(Mcu_SleepOnExitType SleepOnExit)
{
    5e4c:	b500      	push	{lr}
    5e4e:	b083      	sub	sp, #12
    5e50:	9001      	str	r0, [sp, #4]
#if ( MCU_VALIDATE_GLOBAL_CALL == STD_ON )
    if ((Std_ReturnType)E_OK == (Std_ReturnType)Mcu_HLDChecksEntry(MCU_SLEEPONEXIT_ID))
    5e52:	201a      	movs	r0, #26
    5e54:	f7ff fe62 	bl	5b1c <Mcu_HLDChecksEntry>
    5e58:	4603      	mov	r3, r0
    5e5a:	2b00      	cmp	r3, #0
    5e5c:	d106      	bne.n	5e6c <Mcu_SleepOnExit+0x20>
    {
#endif /*( MCU_VALIDATE_GLOBAL_CALL == STD_ON )*/

            Mcu_Ipw_SleepOnExit(SleepOnExit);
    5e5e:	9801      	ldr	r0, [sp, #4]
    5e60:	f000 f83c 	bl	5edc <Mcu_Ipw_SleepOnExit>

#if ( MCU_VALIDATE_GLOBAL_CALL == STD_ON )
        Mcu_HLDChecksExit( (Std_ReturnType)E_OK ,MCU_SLEEPONEXIT_ID);
    5e64:	211a      	movs	r1, #26
    5e66:	2000      	movs	r0, #0
    5e68:	f7ff fe8e 	bl	5b88 <Mcu_HLDChecksExit>
    }
#endif /*( MCU_VALIDATE_GLOBAL_CALL == STD_ON )*/
}
    5e6c:	bf00      	nop
    5e6e:	b003      	add	sp, #12
    5e70:	f85d fb04 	ldr.w	pc, [sp], #4

00005e74 <Mcu_ClkSrcFailureNotification>:
 * @return                 void
 *
 * @api
 */
void Mcu_ClkSrcFailureNotification(Clock_Ip_NameType ClockName)
{
    5e74:	b082      	sub	sp, #8
    5e76:	9001      	str	r0, [sp, #4]
    (void)ClockName;

    if ( (NULL_PTR != Mcu_pConfigPtr) && (Mcu_pConfigPtr->ClkSrcFailureNotification == MCU_CLK_NOTIF_EN))
    5e78:	4b02      	ldr	r3, [pc, #8]	; (5e84 <Mcu_ClkSrcFailureNotification+0x10>)
    5e7a:	681b      	ldr	r3, [r3, #0]
    5e7c:	2b00      	cmp	r3, #0
        #endif
#else
        /* Nothing else to be done. */
#endif /* (MCU_CMU_ERROR_ISR_USED == STD_OFF && MCU_CGU_DETECT_ISR_USED == STD_OFF) */
    }
}
    5e7e:	bf00      	nop
    5e80:	b002      	add	sp, #8
    5e82:	4770      	bx	lr
    5e84:	1fff8ce4 	.word	0x1fff8ce4

00005e88 <Mcu_Ipw_Init>:
*
* @return           void
*
*/
void Mcu_Ipw_Init(const Mcu_HwIPsConfigType * HwIPsConfigPtr)
{
    5e88:	b500      	push	{lr}
    5e8a:	b083      	sub	sp, #12
    5e8c:	9001      	str	r0, [sp, #4]
#if (POWER_IP_ENABLE_NOTIFICATIONS == STD_ON)
    Power_Ip_InstallNotificationsCallback(ReportPowerErrorsCallback);
#endif

    /* Init Power and Reset */
    Power_Ip_Init(HwIPsConfigPtr);
    5e8e:	9801      	ldr	r0, [sp, #4]
    5e90:	f000 f882 	bl	5f98 <Power_Ip_Init>

    (void)HwIPsConfigPtr; /* Fix warning compiler: unused variable Mcu_pHwIPsConfigPtr */
}
    5e94:	bf00      	nop
    5e96:	b003      	add	sp, #12
    5e98:	f85d fb04 	ldr.w	pc, [sp], #4

00005e9c <Mcu_Ipw_InitClock>:
*
* @return           void
*
*/
void Mcu_Ipw_InitClock(const Mcu_ClockConfigType * ClockConfigPtr)
{
    5e9c:	b500      	push	{lr}
    5e9e:	b083      	sub	sp, #12
    5ea0:	9001      	str	r0, [sp, #4]
    Clock_Ip_InitClock(ClockConfigPtr);
    5ea2:	9801      	ldr	r0, [sp, #4]
    5ea4:	f7fc fb12 	bl	24cc <Clock_Ip_InitClock>
}
    5ea8:	bf00      	nop
    5eaa:	b003      	add	sp, #12
    5eac:	f85d fb04 	ldr.w	pc, [sp], #4

00005eb0 <Mcu_Ipw_SetMode>:
*
* @return           void
*
*/
void Mcu_Ipw_SetMode(const Mcu_ModeConfigType * ModeConfigPtr)
{
    5eb0:	b500      	push	{lr}
    5eb2:	b083      	sub	sp, #12
    5eb4:	9001      	str	r0, [sp, #4]
    Power_Ip_SetMode(ModeConfigPtr);
    5eb6:	9801      	ldr	r0, [sp, #4]
    5eb8:	f000 f820 	bl	5efc <Power_Ip_SetMode>
}
    5ebc:	bf00      	nop
    5ebe:	b003      	add	sp, #12
    5ec0:	f85d fb04 	ldr.w	pc, [sp], #4

00005ec4 <Mcu_Ipw_GetResetReason>:
*
* @return           void
*
*/
Mcu_ResetType Mcu_Ipw_GetResetReason(void)
{
    5ec4:	b508      	push	{r3, lr}
    return (Mcu_ResetType)Power_Ip_GetResetReason();
    5ec6:	f000 f84f 	bl	5f68 <Power_Ip_GetResetReason>
    5eca:	4603      	mov	r3, r0
}
    5ecc:	4618      	mov	r0, r3
    5ece:	bd08      	pop	{r3, pc}

00005ed0 <Mcu_Ipw_GetResetRawValue>:
*
* @return           void
*
*/
Mcu_RawResetType Mcu_Ipw_GetResetRawValue(void)
{
    5ed0:	b508      	push	{r3, lr}
    return (Mcu_RawResetType)Power_Ip_GetResetRawValue();
    5ed2:	f000 f857 	bl	5f84 <Power_Ip_GetResetRawValue>
    5ed6:	4603      	mov	r3, r0
}
    5ed8:	4618      	mov	r0, r3
    5eda:	bd08      	pop	{r3, pc}

00005edc <Mcu_Ipw_SleepOnExit>:
*
* @return           void
*
*/
void Mcu_Ipw_SleepOnExit(Mcu_SleepOnExitType SleepOnExit)
{
    5edc:	b500      	push	{lr}
    5ede:	b083      	sub	sp, #12
    5ee0:	9001      	str	r0, [sp, #4]
    if(MCU_SLEEP_ON_EXIT_DISABLED == (Mcu_SleepOnExitType)SleepOnExit)
    5ee2:	9b01      	ldr	r3, [sp, #4]
    5ee4:	2b00      	cmp	r3, #0
    5ee6:	d102      	bne.n	5eee <Mcu_Ipw_SleepOnExit+0x12>
    {
        Power_Ip_DisableSleepOnExit();
    5ee8:	f000 f86c 	bl	5fc4 <Power_Ip_DisableSleepOnExit>
    }
    else
    {
        Power_Ip_EnableSleepOnExit();
    }
}
    5eec:	e001      	b.n	5ef2 <Mcu_Ipw_SleepOnExit+0x16>
        Power_Ip_EnableSleepOnExit();
    5eee:	f000 f86e 	bl	5fce <Power_Ip_EnableSleepOnExit>
}
    5ef2:	bf00      	nop
    5ef4:	b003      	add	sp, #12
    5ef6:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00005efc <Power_Ip_SetMode>:
*
* @implements Power_Ip_SetMode_Activity
*
*/
void Power_Ip_SetMode(const Power_Ip_ModeConfigType * ModeConfigPtr)
{
    5efc:	b500      	push	{lr}
    5efe:	b085      	sub	sp, #20
    5f00:	9001      	str	r0, [sp, #4]
    uint32 PowerSwitchMode;
#if (POWER_MODE_CHANGE_NOTIFICATION == STD_ON)
    Clock_Ip_PowerModesType ModeChanged;
    Clock_Ip_PowerNotificationType ModeChangeStatus;
#endif
    Power_Ip_PowerModeType PowerMode = ModeConfigPtr->PowerMode;
    5f02:	9b01      	ldr	r3, [sp, #4]
    5f04:	685b      	ldr	r3, [r3, #4]
    5f06:	9302      	str	r3, [sp, #8]

    if (POWER_IP_MODE_OK != Power_Ip_SMC_ModeCheckEntry(PowerMode))
    5f08:	9802      	ldr	r0, [sp, #8]
    5f0a:	f000 f9f5 	bl	62f8 <Power_Ip_SMC_ModeCheckEntry>
    5f0e:	4603      	mov	r3, r0
    5f10:	2b00      	cmp	r3, #0
    5f12:	d002      	beq.n	5f1a <Power_Ip_SetMode+0x1e>
    {
        PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    5f14:	2301      	movs	r3, #1
    5f16:	9303      	str	r3, [sp, #12]
    5f18:	e003      	b.n	5f22 <Power_Ip_SetMode+0x26>
#if (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON)
        Power_Ip_PrepareLowPowerMode(PowerMode);
#endif /* (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON) */

        /* Request new mode transition to SMC. */
    PowerSwitchMode = Call_Power_Ip_SMC_ModeConfig(ModeConfigPtr);
    5f1a:	9801      	ldr	r0, [sp, #4]
    5f1c:	f000 fa1e 	bl	635c <Power_Ip_SMC_ModeConfig>
    5f20:	9003      	str	r0, [sp, #12]
            /*This will clear SLEEPDEEP bit after wake-up */
            Call_Power_Ip_CM4_DisableDeepSleep();
        }
#endif
    }
    if (POWER_IP_SWITCH_MODE_FAIL == PowerSwitchMode)
    5f22:	9b03      	ldr	r3, [sp, #12]
    5f24:	2b01      	cmp	r3, #1
    5f26:	d103      	bne.n	5f30 <Power_Ip_SetMode+0x34>
    {
        Power_Ip_ReportPowerErrors(POWER_IP_REPORT_SWITCH_MODE_ERROR, POWER_IP_ERR_CODE_RESERVED);
    5f28:	21ff      	movs	r1, #255	; 0xff
    5f2a:	2003      	movs	r0, #3
    5f2c:	f000 f8f4 	bl	6118 <Power_Ip_ReportPowerErrors>
        ModeChanged = Power_Ip_ModeConvert(PowerMode);
        /* Callback Clock Ip Notification. */
        Clock_Ip_PowerModeChangeNotification(ModeChanged,ModeChangeStatus);
#endif
    }
}
    5f30:	bf00      	nop
    5f32:	b005      	add	sp, #20
    5f34:	f85d fb04 	ldr.w	pc, [sp], #4

00005f38 <Power_Ip_ConvertIntergeToResetType>:
* @param[in]        ResetReasonIndex   Reset reason index.
*
* @return           Power_Ip_ResetType
*/
static Power_Ip_ResetType Power_Ip_ConvertIntergeToResetType(uint32 ResetReasonIndex)
{
    5f38:	b084      	sub	sp, #16
    5f3a:	9001      	str	r0, [sp, #4]
    Power_Ip_ResetType ResetReason = MCU_NO_RESET_REASON;
    5f3c:	230c      	movs	r3, #12
    5f3e:	9303      	str	r3, [sp, #12]

    if (ResetReasonArray[ResetReasonIndex] <= MCU_RESET_UNDEFINED)
    5f40:	4a08      	ldr	r2, [pc, #32]	; (5f64 <Power_Ip_ConvertIntergeToResetType+0x2c>)
    5f42:	9b01      	ldr	r3, [sp, #4]
    5f44:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5f48:	2b0e      	cmp	r3, #14
    5f4a:	d805      	bhi.n	5f58 <Power_Ip_ConvertIntergeToResetType+0x20>
    {
        ResetReason = ResetReasonArray[ResetReasonIndex];
    5f4c:	4a05      	ldr	r2, [pc, #20]	; (5f64 <Power_Ip_ConvertIntergeToResetType+0x2c>)
    5f4e:	9b01      	ldr	r3, [sp, #4]
    5f50:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5f54:	9303      	str	r3, [sp, #12]
    5f56:	e001      	b.n	5f5c <Power_Ip_ConvertIntergeToResetType+0x24>
    }
    else
    {
        ResetReason = MCU_NO_RESET_REASON;
    5f58:	230c      	movs	r3, #12
    5f5a:	9303      	str	r3, [sp, #12]
    }

    return ResetReason;
    5f5c:	9b03      	ldr	r3, [sp, #12]
}
    5f5e:	4618      	mov	r0, r3
    5f60:	b004      	add	sp, #16
    5f62:	4770      	bx	lr
    5f64:	00018658 	.word	0x00018658

00005f68 <Power_Ip_GetResetReason>:
*
* @implements Power_Ip_GetResetReason_Activity
*
*/
Power_Ip_ResetType Power_Ip_GetResetReason(void)
{
    5f68:	b500      	push	{lr}
    5f6a:	b083      	sub	sp, #12
    Power_Ip_ResetType ResetReason;
    uint32 ResetVal;

    ResetVal = Call_Power_Ip_RCM_GetResetReason();
    5f6c:	f000 f940 	bl	61f0 <Power_Ip_RCM_GetResetReason>
    5f70:	9001      	str	r0, [sp, #4]

    /* Use function Power_Ip_ConvertIntergeToResetType to avoid MISRA violation 10.5 : cast from uint32 to enum */
    ResetReason = Power_Ip_ConvertIntergeToResetType(ResetVal);
    5f72:	9801      	ldr	r0, [sp, #4]
    5f74:	f7ff ffe0 	bl	5f38 <Power_Ip_ConvertIntergeToResetType>
    5f78:	9000      	str	r0, [sp, #0]

    return (Power_Ip_ResetType) ResetReason;
    5f7a:	9b00      	ldr	r3, [sp, #0]
}
    5f7c:	4618      	mov	r0, r3
    5f7e:	b003      	add	sp, #12
    5f80:	f85d fb04 	ldr.w	pc, [sp], #4

00005f84 <Power_Ip_GetResetRawValue>:
*
* @implements Power_Ip_GetResetRawValue_Activity
*
*/
Power_Ip_RawResetType Power_Ip_GetResetRawValue(void)
{
    5f84:	b500      	push	{lr}
    5f86:	b083      	sub	sp, #12
    Power_Ip_RawResetType ResetReason;

    ResetReason = (Power_Ip_RawResetType)Call_Power_Ip_RCM_GetResetRawValue();
    5f88:	f000 f98a 	bl	62a0 <Power_Ip_RCM_GetResetRawValue>
    5f8c:	9001      	str	r0, [sp, #4]
    return (Power_Ip_RawResetType) ResetReason;
    5f8e:	9b01      	ldr	r3, [sp, #4]
}
    5f90:	4618      	mov	r0, r3
    5f92:	b003      	add	sp, #12
    5f94:	f85d fb04 	ldr.w	pc, [sp], #4

00005f98 <Power_Ip_Init>:
*
* @implements Power_Ip_Init_Activity
*
*/
void Power_Ip_Init (const Power_Ip_HwIPsConfigType * HwIPsConfigPtr)
{
    5f98:	b500      	push	{lr}
    5f9a:	b083      	sub	sp, #12
    5f9c:	9001      	str	r0, [sp, #4]
    POWER_IP_DEV_ASSERT(NULL_PTR != HwIPsConfigPtr);
    (void)(HwIPsConfigPtr);

#if (defined(POWER_IP_DISABLE_RCM_INIT) && (STD_OFF == POWER_IP_DISABLE_RCM_INIT))
    /* Init the RCM */
    Call_Power_Ip_RCM_ResetInit(HwIPsConfigPtr->RCMConfigPtr);
    5f9e:	9b01      	ldr	r3, [sp, #4]
    5fa0:	681b      	ldr	r3, [r3, #0]
    5fa2:	4618      	mov	r0, r3
    5fa4:	f000 f90e 	bl	61c4 <Power_Ip_RCM_ResetInit>
#endif

#if (defined(POWER_IP_DISABLE_PMC_INIT) && (STD_OFF == POWER_IP_DISABLE_PMC_INIT))
    Call_Power_Ip_PMC_PowerInit(HwIPsConfigPtr->PMCConfigPtr);
    5fa8:	9b01      	ldr	r3, [sp, #4]
    5faa:	685b      	ldr	r3, [r3, #4]
    5fac:	4618      	mov	r0, r3
    5fae:	f000 f86d 	bl	608c <Power_Ip_PMC_PowerInit>
#endif

#if (defined(POWER_IP_DISABLE_SMC_INIT) && (STD_OFF == POWER_IP_DISABLE_SMC_INIT))
    Call_Power_Ip_SMC_AllowedModesConfig(HwIPsConfigPtr->SMCConfigPtr);
    5fb2:	9b01      	ldr	r3, [sp, #4]
    5fb4:	689b      	ldr	r3, [r3, #8]
    5fb6:	4618      	mov	r0, r3
    5fb8:	f000 f990 	bl	62dc <Power_Ip_SMC_AllowedModesConfig>
#endif
}
    5fbc:	bf00      	nop
    5fbe:	b003      	add	sp, #12
    5fc0:	f85d fb04 	ldr.w	pc, [sp], #4

00005fc4 <Power_Ip_DisableSleepOnExit>:
* @param[in]    none
* @return void
* @implements Power_Ip_DisableSleepOnExit_Activity
*/
void Power_Ip_DisableSleepOnExit(void)
{
    5fc4:	b508      	push	{r3, lr}
    Call_Power_Ip_CM4_DisableSleepOnExit();
    5fc6:	f000 f811 	bl	5fec <Power_Ip_CM4_DisableSleepOnExit>
}
    5fca:	bf00      	nop
    5fcc:	bd08      	pop	{r3, pc}

00005fce <Power_Ip_EnableSleepOnExit>:
* @param[in]    none
* @return void
* @implements Power_Ip_EnableSleepOnExit_Activity
*/
void Power_Ip_EnableSleepOnExit(void)
{
    5fce:	b508      	push	{r3, lr}
    Call_Power_Ip_CM4_EnableSleepOnExit();
    5fd0:	f000 f820 	bl	6014 <Power_Ip_CM4_EnableSleepOnExit>
}
    5fd4:	bf00      	nop
    5fd6:	bd08      	pop	{r3, pc}

00005fd8 <Power_Ip_InstallNotificationsCallback>:
* @return           void
*
* @implements Power_Ip_InstallNotificationsCallback_Activity
*/
void Power_Ip_InstallNotificationsCallback(Power_Ip_ReportErrorsCallbackType ReportErrorsCallback)
{
    5fd8:	b082      	sub	sp, #8
    5fda:	9001      	str	r0, [sp, #4]
    POWER_IP_DEV_ASSERT(NULL_PTR != ReportErrorsCallback);

    Power_Ip_pfReportErrorsCallback = ReportErrorsCallback;
    5fdc:	4a02      	ldr	r2, [pc, #8]	; (5fe8 <Power_Ip_InstallNotificationsCallback+0x10>)
    5fde:	9b01      	ldr	r3, [sp, #4]
    5fe0:	6013      	str	r3, [r2, #0]
}
    5fe2:	bf00      	nop
    5fe4:	b002      	add	sp, #8
    5fe6:	4770      	bx	lr
    5fe8:	1fff8b20 	.word	0x1fff8b20

00005fec <Power_Ip_CM4_DisableSleepOnExit>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_DisableSleepOnExit(void)
{
    5fec:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    5fee:	2300      	movs	r3, #0
    5ff0:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    5ff2:	4b07      	ldr	r3, [pc, #28]	; (6010 <Power_Ip_CM4_DisableSleepOnExit+0x24>)
    5ff4:	681b      	ldr	r3, [r3, #0]
    5ff6:	685b      	ldr	r3, [r3, #4]
    5ff8:	9301      	str	r3, [sp, #4]
    TempValue &= ~(CM4_SCR_SLEEPONEXIT_MASK32);
    5ffa:	9b01      	ldr	r3, [sp, #4]
    5ffc:	f023 0302 	bic.w	r3, r3, #2
    6000:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    6002:	4b03      	ldr	r3, [pc, #12]	; (6010 <Power_Ip_CM4_DisableSleepOnExit+0x24>)
    6004:	681b      	ldr	r3, [r3, #0]
    6006:	9a01      	ldr	r2, [sp, #4]
    6008:	605a      	str	r2, [r3, #4]
}
    600a:	bf00      	nop
    600c:	b002      	add	sp, #8
    600e:	4770      	bx	lr
    6010:	1fff8b24 	.word	0x1fff8b24

00006014 <Power_Ip_CM4_EnableSleepOnExit>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_EnableSleepOnExit(void)
{
    6014:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    6016:	2300      	movs	r3, #0
    6018:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    601a:	4b07      	ldr	r3, [pc, #28]	; (6038 <Power_Ip_CM4_EnableSleepOnExit+0x24>)
    601c:	681b      	ldr	r3, [r3, #0]
    601e:	685b      	ldr	r3, [r3, #4]
    6020:	9301      	str	r3, [sp, #4]
    TempValue |= (CM4_SCR_SLEEPONEXIT_MASK32);
    6022:	9b01      	ldr	r3, [sp, #4]
    6024:	f043 0302 	orr.w	r3, r3, #2
    6028:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    602a:	4b03      	ldr	r3, [pc, #12]	; (6038 <Power_Ip_CM4_EnableSleepOnExit+0x24>)
    602c:	681b      	ldr	r3, [r3, #0]
    602e:	9a01      	ldr	r2, [sp, #4]
    6030:	605a      	str	r2, [r3, #4]
}
    6032:	bf00      	nop
    6034:	b002      	add	sp, #8
    6036:	4770      	bx	lr
    6038:	1fff8b24 	.word	0x1fff8b24

0000603c <Power_Ip_CM4_EnableDeepSleep>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_EnableDeepSleep(void)
{
    603c:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    603e:	2300      	movs	r3, #0
    6040:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    6042:	4b07      	ldr	r3, [pc, #28]	; (6060 <Power_Ip_CM4_EnableDeepSleep+0x24>)
    6044:	681b      	ldr	r3, [r3, #0]
    6046:	685b      	ldr	r3, [r3, #4]
    6048:	9301      	str	r3, [sp, #4]
    TempValue |= CM4_SCR_SLEEPDEEP_MASK32;
    604a:	9b01      	ldr	r3, [sp, #4]
    604c:	f043 0304 	orr.w	r3, r3, #4
    6050:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    6052:	4b03      	ldr	r3, [pc, #12]	; (6060 <Power_Ip_CM4_EnableDeepSleep+0x24>)
    6054:	681b      	ldr	r3, [r3, #0]
    6056:	9a01      	ldr	r2, [sp, #4]
    6058:	605a      	str	r2, [r3, #4]
}
    605a:	bf00      	nop
    605c:	b002      	add	sp, #8
    605e:	4770      	bx	lr
    6060:	1fff8b24 	.word	0x1fff8b24

00006064 <Power_Ip_CM4_DisableDeepSleep>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_DisableDeepSleep(void)
{
    6064:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    6066:	2300      	movs	r3, #0
    6068:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    606a:	4b07      	ldr	r3, [pc, #28]	; (6088 <Power_Ip_CM4_DisableDeepSleep+0x24>)
    606c:	681b      	ldr	r3, [r3, #0]
    606e:	685b      	ldr	r3, [r3, #4]
    6070:	9301      	str	r3, [sp, #4]
    TempValue &= ~(CM4_SCR_SLEEPDEEP_MASK32);
    6072:	9b01      	ldr	r3, [sp, #4]
    6074:	f023 0304 	bic.w	r3, r3, #4
    6078:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    607a:	4b03      	ldr	r3, [pc, #12]	; (6088 <Power_Ip_CM4_DisableDeepSleep+0x24>)
    607c:	681b      	ldr	r3, [r3, #0]
    607e:	9a01      	ldr	r2, [sp, #4]
    6080:	605a      	str	r2, [r3, #4]
}
    6082:	bf00      	nop
    6084:	b002      	add	sp, #8
    6086:	4770      	bx	lr
    6088:	1fff8b24 	.word	0x1fff8b24

0000608c <Power_Ip_PMC_PowerInit>:
*
* @return           void
*
*/
void Power_Ip_PMC_PowerInit(const Power_Ip_PMC_ConfigType * ConfigPtr)
{
    608c:	b084      	sub	sp, #16
    608e:	9001      	str	r0, [sp, #4]
    uint8 Tmp;

#if(STD_ON == POWER_IP_PMC_LVDSC1_SUPPORT)
    Tmp = (uint8)POWER_IP_PMC->LVDSC1;
    6090:	4b20      	ldr	r3, [pc, #128]	; (6114 <Power_Ip_PMC_PowerInit+0x88>)
    6092:	781b      	ldrb	r3, [r3, #0]
    6094:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp & (uint8)(~PMC_LVDSC1_RWBITS_MASK8));
    6098:	f89d 300f 	ldrb.w	r3, [sp, #15]
    609c:	f003 030f 	and.w	r3, r3, #15
    60a0:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp | (uint8)(ConfigPtr->Lvdsc1));
    60a4:	9b01      	ldr	r3, [sp, #4]
    60a6:	781a      	ldrb	r2, [r3, #0]
    60a8:	f89d 300f 	ldrb.w	r3, [sp, #15]
    60ac:	4313      	orrs	r3, r2
    60ae:	f88d 300f 	strb.w	r3, [sp, #15]
    POWER_IP_PMC->LVDSC1 = Tmp;
    60b2:	4a18      	ldr	r2, [pc, #96]	; (6114 <Power_Ip_PMC_PowerInit+0x88>)
    60b4:	f89d 300f 	ldrb.w	r3, [sp, #15]
    60b8:	7013      	strb	r3, [r2, #0]
#endif
    Tmp = (uint8)POWER_IP_PMC->LVDSC2;
    60ba:	4b16      	ldr	r3, [pc, #88]	; (6114 <Power_Ip_PMC_PowerInit+0x88>)
    60bc:	785b      	ldrb	r3, [r3, #1]
    60be:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp & (uint8)(~PMC_LVDSC2_RWBITS_MASK8));
    60c2:	f89d 300f 	ldrb.w	r3, [sp, #15]
    60c6:	f003 031f 	and.w	r3, r3, #31
    60ca:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp | (uint8)(ConfigPtr->Lvdsc2));
    60ce:	9b01      	ldr	r3, [sp, #4]
    60d0:	785a      	ldrb	r2, [r3, #1]
    60d2:	f89d 300f 	ldrb.w	r3, [sp, #15]
    60d6:	4313      	orrs	r3, r2
    60d8:	f88d 300f 	strb.w	r3, [sp, #15]
    POWER_IP_PMC->LVDSC2 = Tmp;
    60dc:	4a0d      	ldr	r2, [pc, #52]	; (6114 <Power_Ip_PMC_PowerInit+0x88>)
    60de:	f89d 300f 	ldrb.w	r3, [sp, #15]
    60e2:	7053      	strb	r3, [r2, #1]

    Tmp = (uint8)POWER_IP_PMC->REGSC;
    60e4:	4b0b      	ldr	r3, [pc, #44]	; (6114 <Power_Ip_PMC_PowerInit+0x88>)
    60e6:	789b      	ldrb	r3, [r3, #2]
    60e8:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp & (uint8)(~PMC_REGSC_RWBITS_MASK8));
    60ec:	f89d 300f 	ldrb.w	r3, [sp, #15]
    60f0:	f003 0338 	and.w	r3, r3, #56	; 0x38
    60f4:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp | (uint8)(ConfigPtr->Regsc));
    60f8:	9b01      	ldr	r3, [sp, #4]
    60fa:	789a      	ldrb	r2, [r3, #2]
    60fc:	f89d 300f 	ldrb.w	r3, [sp, #15]
    6100:	4313      	orrs	r3, r2
    6102:	f88d 300f 	strb.w	r3, [sp, #15]
    POWER_IP_PMC->REGSC = Tmp;
    6106:	4a03      	ldr	r2, [pc, #12]	; (6114 <Power_Ip_PMC_PowerInit+0x88>)
    6108:	f89d 300f 	ldrb.w	r3, [sp, #15]
    610c:	7093      	strb	r3, [r2, #2]
  #if (POWER_IP_VOLTAGE_ERROR_ISR_USED == STD_ON)
    /* make Status of PMC to initialized to check in the interrupt function */
    Power_Ip_ePmcStatus = PMC_INIT;
  #endif
#endif
}
    610e:	bf00      	nop
    6110:	b004      	add	sp, #16
    6112:	4770      	bx	lr
    6114:	4007d000 	.word	0x4007d000

00006118 <Power_Ip_ReportPowerErrors>:

/*==================================================================================================
                                       GLOBAL FUNCTIONS
==================================================================================================*/
void Power_Ip_ReportPowerErrors(Power_Ip_ReportErrorType Error, uint8 ErrorCode)
{
    6118:	b500      	push	{lr}
    611a:	b083      	sub	sp, #12
    611c:	9001      	str	r0, [sp, #4]
    611e:	460b      	mov	r3, r1
    6120:	f88d 3003 	strb.w	r3, [sp, #3]
    Power_Ip_pfReportErrorsCallback(Error, ErrorCode);
    6124:	4b05      	ldr	r3, [pc, #20]	; (613c <Power_Ip_ReportPowerErrors+0x24>)
    6126:	681b      	ldr	r3, [r3, #0]
    6128:	f89d 2003 	ldrb.w	r2, [sp, #3]
    612c:	4611      	mov	r1, r2
    612e:	9801      	ldr	r0, [sp, #4]
    6130:	4798      	blx	r3
}
    6132:	bf00      	nop
    6134:	b003      	add	sp, #12
    6136:	f85d fb04 	ldr.w	pc, [sp], #4
    613a:	bf00      	nop
    613c:	1fff8b20 	.word	0x1fff8b20

00006140 <Power_Ip_ReportPowerErrorsEmptyCallback>:

void Power_Ip_ReportPowerErrorsEmptyCallback(Power_Ip_ReportErrorType Error, uint8 ErrorCode)
{
    6140:	b082      	sub	sp, #8
    6142:	9001      	str	r0, [sp, #4]
    6144:	460b      	mov	r3, r1
    6146:	f88d 3003 	strb.w	r3, [sp, #3]
    /* No implementation */
    (void)Error;
    (void)ErrorCode;
}
    614a:	bf00      	nop
    614c:	b002      	add	sp, #8
    614e:	4770      	bx	lr

00006150 <Power_Ip_StartTimeout>:
 *END**************************************************************************/
void Power_Ip_StartTimeout(uint32 *StartTimeOut,
                       uint32 *ElapsedTimeOut,
                       uint32 *TimeoutTicksOut,
                       uint32 TimeoutUs)
{
    6150:	b500      	push	{lr}
    6152:	b085      	sub	sp, #20
    6154:	9003      	str	r0, [sp, #12]
    6156:	9102      	str	r1, [sp, #8]
    6158:	9201      	str	r2, [sp, #4]
    615a:	9300      	str	r3, [sp, #0]
    *StartTimeOut    = OsIf_GetCounter(POWER_IP_TIMEOUT_TYPE);
    615c:	2000      	movs	r0, #0
    615e:	f7fb fee5 	bl	1f2c <OsIf_GetCounter>
    6162:	4602      	mov	r2, r0
    6164:	9b03      	ldr	r3, [sp, #12]
    6166:	601a      	str	r2, [r3, #0]
    *ElapsedTimeOut  = 0U;
    6168:	9b02      	ldr	r3, [sp, #8]
    616a:	2200      	movs	r2, #0
    616c:	601a      	str	r2, [r3, #0]
    *TimeoutTicksOut = OsIf_MicrosToTicks(TimeoutUs, POWER_IP_TIMEOUT_TYPE);
    616e:	2100      	movs	r1, #0
    6170:	9800      	ldr	r0, [sp, #0]
    6172:	f7fb ff27 	bl	1fc4 <OsIf_MicrosToTicks>
    6176:	4602      	mov	r2, r0
    6178:	9b01      	ldr	r3, [sp, #4]
    617a:	601a      	str	r2, [r3, #0]
}
    617c:	bf00      	nop
    617e:	b005      	add	sp, #20
    6180:	f85d fb04 	ldr.w	pc, [sp], #4

00006184 <Power_Ip_TimeoutExpired>:
 *
 *END**************************************************************************/
boolean Power_Ip_TimeoutExpired(uint32 *StartTimeInOut,
                            uint32 *ElapsedTimeInOut,
                            uint32 TimeoutTicks)
{
    6184:	b500      	push	{lr}
    6186:	b087      	sub	sp, #28
    6188:	9003      	str	r0, [sp, #12]
    618a:	9102      	str	r1, [sp, #8]
    618c:	9201      	str	r2, [sp, #4]
    boolean RetVal = FALSE;
    618e:	2300      	movs	r3, #0
    6190:	f88d 3017 	strb.w	r3, [sp, #23]
    *ElapsedTimeInOut += OsIf_GetElapsed(StartTimeInOut, POWER_IP_TIMEOUT_TYPE);
    6194:	2100      	movs	r1, #0
    6196:	9803      	ldr	r0, [sp, #12]
    6198:	f7fb fee1 	bl	1f5e <OsIf_GetElapsed>
    619c:	4602      	mov	r2, r0
    619e:	9b02      	ldr	r3, [sp, #8]
    61a0:	681b      	ldr	r3, [r3, #0]
    61a2:	441a      	add	r2, r3
    61a4:	9b02      	ldr	r3, [sp, #8]
    61a6:	601a      	str	r2, [r3, #0]

    if (*ElapsedTimeInOut >= TimeoutTicks)
    61a8:	9b02      	ldr	r3, [sp, #8]
    61aa:	681b      	ldr	r3, [r3, #0]
    61ac:	9a01      	ldr	r2, [sp, #4]
    61ae:	429a      	cmp	r2, r3
    61b0:	d802      	bhi.n	61b8 <Power_Ip_TimeoutExpired+0x34>
    {
        RetVal = TRUE;
    61b2:	2301      	movs	r3, #1
    61b4:	f88d 3017 	strb.w	r3, [sp, #23]
    }
    return RetVal;
    61b8:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    61bc:	4618      	mov	r0, r3
    61be:	b007      	add	sp, #28
    61c0:	f85d fb04 	ldr.w	pc, [sp], #4

000061c4 <Power_Ip_RCM_ResetInit>:
*
* @return           void
*
*/
void Power_Ip_RCM_ResetInit(const Power_Ip_RCM_ConfigType * ConfigPtr)
{
    61c4:	b082      	sub	sp, #8
    61c6:	9001      	str	r0, [sp, #4]
    IP_RCM->RPC = (uint32)(ConfigPtr->ResetPinControlConfig & RCM_RPC_RWBITS_MASK32);
    61c8:	9b01      	ldr	r3, [sp, #4]
    61ca:	681a      	ldr	r2, [r3, #0]
    61cc:	4907      	ldr	r1, [pc, #28]	; (61ec <Power_Ip_RCM_ResetInit+0x28>)
    61ce:	f641 7307 	movw	r3, #7943	; 0x1f07
    61d2:	4013      	ands	r3, r2
    61d4:	60cb      	str	r3, [r1, #12]

    IP_RCM->SRIE = (uint32)(ConfigPtr->ResetInterruptEnableConfig & RCM_SRIE_RWBITS_MASK32);
    61d6:	9b01      	ldr	r3, [sp, #4]
    61d8:	685a      	ldr	r2, [r3, #4]
    61da:	4904      	ldr	r1, [pc, #16]	; (61ec <Power_Ip_RCM_ResetInit+0x28>)
    61dc:	f642 73ff 	movw	r3, #12287	; 0x2fff
    61e0:	4013      	ands	r3, r2
    61e2:	61cb      	str	r3, [r1, #28]
#if (defined(POWER_IP_RESET_ALTERNATE_ISR_USED) && (POWER_IP_RESET_ALTERNATE_ISR_USED == STD_ON))
    Power_Ip_RCM_Status = POWER_IP_RCM_INIT;
#endif
}
    61e4:	bf00      	nop
    61e6:	b002      	add	sp, #8
    61e8:	4770      	bx	lr
    61ea:	bf00      	nop
    61ec:	4007f000 	.word	0x4007f000

000061f0 <Power_Ip_RCM_GetResetReason>:
*                   out to avoid multiple reset reasons. The function Mcu_GetResetReason shall
*                   return MCU_RESET_UNDEFINED if this function is called prior to calling of the
*                   function Mcu_Init, and if supported by the hardware.
*/
uint32 Power_Ip_RCM_GetResetReason(void)
{
    61f0:	b088      	sub	sp, #32
    /* Code for the Reset event returned by this function. */
    uint32 ResetReason = (uint32)MCU_NO_RESET_REASON;
    61f2:	230c      	movs	r3, #12
    61f4:	9307      	str	r3, [sp, #28]
    /* Temporary variable for RCM_RSR register value. */
    uint32 RegValue = 0U;
    61f6:	2300      	movs	r3, #0
    61f8:	9303      	str	r3, [sp, #12]
    uint32 ActiveValue;
    uint32 Index;
    uint32 DynamicMask;
    uint32 Position = (uint32)0x00U;
    61fa:	2300      	movs	r3, #0
    61fc:	9305      	str	r3, [sp, #20]
    uint32 NumberOfFlags = 0U;
    61fe:	2300      	movs	r3, #0
    6200:	9304      	str	r3, [sp, #16]

    /* Check reset reasons from SSRS Status Register. */
    RegValue = (uint32) IP_RCM->SSRS & RCM_SSRS_RWBITS_MASK32;
    6202:	4b25      	ldr	r3, [pc, #148]	; (6298 <Power_Ip_RCM_GetResetReason+0xa8>)
    6204:	699a      	ldr	r2, [r3, #24]
    6206:	f642 73ee 	movw	r3, #12270	; 0x2fee
    620a:	4013      	ands	r3, r2
    620c:	9303      	str	r3, [sp, #12]

    /* Store the content of RSR */
    if ((uint32)0U != RegValue)
    620e:	9b03      	ldr	r3, [sp, #12]
    6210:	2b00      	cmp	r3, #0
    6212:	d008      	beq.n	6226 <Power_Ip_RCM_GetResetReason+0x36>
    {
        /* Clear the flags if any flag is set */
        IP_RCM->SSRS = (uint32)(RegValue & RCM_SSRS_RWBITS_MASK32);
    6214:	4920      	ldr	r1, [pc, #128]	; (6298 <Power_Ip_RCM_GetResetReason+0xa8>)
    6216:	9a03      	ldr	r2, [sp, #12]
    6218:	f642 73ee 	movw	r3, #12270	; 0x2fee
    621c:	4013      	ands	r3, r2
    621e:	618b      	str	r3, [r1, #24]

        Power_Ip_u32ResetStatus = RegValue;
    6220:	4a1e      	ldr	r2, [pc, #120]	; (629c <Power_Ip_RCM_GetResetReason+0xac>)
    6222:	9b03      	ldr	r3, [sp, #12]
    6224:	6013      	str	r3, [r2, #0]
    }
    ActiveValue = Power_Ip_u32ResetStatus;
    6226:	4b1d      	ldr	r3, [pc, #116]	; (629c <Power_Ip_RCM_GetResetReason+0xac>)
    6228:	681b      	ldr	r3, [r3, #0]
    622a:	9302      	str	r3, [sp, #8]

    if((RCM_SSRS_SLVD_MASK | RCM_SSRS_SPOR_MASK) == (ActiveValue & RCM_SSRS_RWBITS_MASK32))
    622c:	9a02      	ldr	r2, [sp, #8]
    622e:	f642 73ee 	movw	r3, #12270	; 0x2fee
    6232:	4013      	ands	r3, r2
    6234:	2b82      	cmp	r3, #130	; 0x82
    6236:	d102      	bne.n	623e <Power_Ip_RCM_GetResetReason+0x4e>
    {
        ResetReason = (uint32)MCU_POWER_ON_RESET;
    6238:	2305      	movs	r3, #5
    623a:	9307      	str	r3, [sp, #28]
    623c:	e027      	b.n	628e <Power_Ip_RCM_GetResetReason+0x9e>
    }
    else
    {
        for (Index = 0x00U; Index < 0x20U; Index++)
    623e:	2300      	movs	r3, #0
    6240:	9306      	str	r3, [sp, #24]
    6242:	e021      	b.n	6288 <Power_Ip_RCM_GetResetReason+0x98>
        {
            DynamicMask = ((uint32)0x80000000U >> Index);
    6244:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    6248:	9b06      	ldr	r3, [sp, #24]
    624a:	fa22 f303 	lsr.w	r3, r2, r3
    624e:	9301      	str	r3, [sp, #4]
            if ((uint32)0x00U != (DynamicMask & RCM_SSRS_RESET_SOURCES_MASK32))
    6250:	9a01      	ldr	r2, [sp, #4]
    6252:	f642 73fe 	movw	r3, #12286	; 0x2ffe
    6256:	4013      	ands	r3, r2
    6258:	2b00      	cmp	r3, #0
    625a:	d012      	beq.n	6282 <Power_Ip_RCM_GetResetReason+0x92>
            {
                if ((uint32)0x00U != (DynamicMask & ActiveValue))
    625c:	9a01      	ldr	r2, [sp, #4]
    625e:	9b02      	ldr	r3, [sp, #8]
    6260:	4013      	ands	r3, r2
    6262:	2b00      	cmp	r3, #0
    6264:	d00a      	beq.n	627c <Power_Ip_RCM_GetResetReason+0x8c>
                {
                    ResetReason = Position;
    6266:	9b05      	ldr	r3, [sp, #20]
    6268:	9307      	str	r3, [sp, #28]
                    NumberOfFlags++;
    626a:	9b04      	ldr	r3, [sp, #16]
    626c:	3301      	adds	r3, #1
    626e:	9304      	str	r3, [sp, #16]
                    /* MCU_MULTIPLE_RESET_REASON returned if more than one reset reason in this case use function Mcu_GetRawValue to determine. */
                    if (NumberOfFlags >= (uint32)2)
    6270:	9b04      	ldr	r3, [sp, #16]
    6272:	2b01      	cmp	r3, #1
    6274:	d902      	bls.n	627c <Power_Ip_RCM_GetResetReason+0x8c>
                    {
                        ResetReason = (uint32)MCU_MULTIPLE_RESET_REASON;
    6276:	230d      	movs	r3, #13
    6278:	9307      	str	r3, [sp, #28]
                        break;
    627a:	e008      	b.n	628e <Power_Ip_RCM_GetResetReason+0x9e>
                    }
                }
                Position++;
    627c:	9b05      	ldr	r3, [sp, #20]
    627e:	3301      	adds	r3, #1
    6280:	9305      	str	r3, [sp, #20]
        for (Index = 0x00U; Index < 0x20U; Index++)
    6282:	9b06      	ldr	r3, [sp, #24]
    6284:	3301      	adds	r3, #1
    6286:	9306      	str	r3, [sp, #24]
    6288:	9b06      	ldr	r3, [sp, #24]
    628a:	2b1f      	cmp	r3, #31
    628c:	d9da      	bls.n	6244 <Power_Ip_RCM_GetResetReason+0x54>
            }
        }
    }
    return ResetReason;
    628e:	9b07      	ldr	r3, [sp, #28]
}
    6290:	4618      	mov	r0, r3
    6292:	b008      	add	sp, #32
    6294:	4770      	bx	lr
    6296:	bf00      	nop
    6298:	4007f000 	.word	0x4007f000
    629c:	1fff8ce8 	.word	0x1fff8ce8

000062a0 <Power_Ip_RCM_GetResetRawValue>:
* @note             The User should ensure that the reset reason is cleared once it has been read
*                   out to avoid multiple reset reasons.
*
*/
Power_Ip_RawResetType Power_Ip_RCM_GetResetRawValue(void)
{
    62a0:	b082      	sub	sp, #8
    uint32 RawReset;
    uint32 RegValue;

    RegValue = IP_RCM->SSRS & RCM_SSRS_RWBITS_MASK32;
    62a2:	4b0c      	ldr	r3, [pc, #48]	; (62d4 <Power_Ip_RCM_GetResetRawValue+0x34>)
    62a4:	699a      	ldr	r2, [r3, #24]
    62a6:	f642 73ee 	movw	r3, #12270	; 0x2fee
    62aa:	4013      	ands	r3, r2
    62ac:	9301      	str	r3, [sp, #4]

    if ((uint32)0U != RegValue)
    62ae:	9b01      	ldr	r3, [sp, #4]
    62b0:	2b00      	cmp	r3, #0
    62b2:	d008      	beq.n	62c6 <Power_Ip_RCM_GetResetRawValue+0x26>
    {
        /* Clear the flags if any flag is set */
        IP_RCM->SSRS = (uint32)(RegValue & RCM_SSRS_RWBITS_MASK32);
    62b4:	4907      	ldr	r1, [pc, #28]	; (62d4 <Power_Ip_RCM_GetResetRawValue+0x34>)
    62b6:	9a01      	ldr	r2, [sp, #4]
    62b8:	f642 73ee 	movw	r3, #12270	; 0x2fee
    62bc:	4013      	ands	r3, r2
    62be:	618b      	str	r3, [r1, #24]

        Power_Ip_u32ResetStatus = RegValue;
    62c0:	4a05      	ldr	r2, [pc, #20]	; (62d8 <Power_Ip_RCM_GetResetRawValue+0x38>)
    62c2:	9b01      	ldr	r3, [sp, #4]
    62c4:	6013      	str	r3, [r2, #0]
    }

    RawReset = Power_Ip_u32ResetStatus;
    62c6:	4b04      	ldr	r3, [pc, #16]	; (62d8 <Power_Ip_RCM_GetResetRawValue+0x38>)
    62c8:	681b      	ldr	r3, [r3, #0]
    62ca:	9300      	str	r3, [sp, #0]

    return (Power_Ip_RawResetType)RawReset;
    62cc:	9b00      	ldr	r3, [sp, #0]
}
    62ce:	4618      	mov	r0, r3
    62d0:	b002      	add	sp, #8
    62d2:	4770      	bx	lr
    62d4:	4007f000 	.word	0x4007f000
    62d8:	1fff8ce8 	.word	0x1fff8ce8

000062dc <Power_Ip_SMC_AllowedModesConfig>:
*
* @details          This function is only called at Mcu initialization
*
*/
void Power_Ip_SMC_AllowedModesConfig(const Power_Ip_SMC_ConfigType * ConfigPtr)
{
    62dc:	b082      	sub	sp, #8
    62de:	9001      	str	r0, [sp, #4]
    IP_SMC->PMPROT = ConfigPtr->AllowedModes & SMC_PMPROT_RWBITS_MASK32;
    62e0:	9b01      	ldr	r3, [sp, #4]
    62e2:	681b      	ldr	r3, [r3, #0]
    62e4:	4a03      	ldr	r2, [pc, #12]	; (62f4 <Power_Ip_SMC_AllowedModesConfig+0x18>)
    62e6:	f003 03a0 	and.w	r3, r3, #160	; 0xa0
    62ea:	6093      	str	r3, [r2, #8]
}
    62ec:	bf00      	nop
    62ee:	b002      	add	sp, #8
    62f0:	4770      	bx	lr
    62f2:	bf00      	nop
    62f4:	4007e000 	.word	0x4007e000

000062f8 <Power_Ip_SMC_ModeCheckEntry>:
*
* @return           Power_Ip_SMC_ModeStatusType
*
*/
Power_Ip_SMC_ModeStatusType Power_Ip_SMC_ModeCheckEntry(Power_Ip_PowerModeType PowerMode)
{
    62f8:	b084      	sub	sp, #16
    62fa:	9001      	str	r0, [sp, #4]
    Power_Ip_SMC_ModeStatusType PowerModeCheck = POWER_IP_MODE_NOT_OK;
    62fc:	2301      	movs	r3, #1
    62fe:	9303      	str	r3, [sp, #12]
    /* Contains the code of the Power Mode (based PowerModeType enumeration). */
    uint32 CurrentPowerMode;

    CurrentPowerMode = IP_SMC->PMSTAT & SMC_PMSTAT_PMSTAT_MASK;
    6300:	4b15      	ldr	r3, [pc, #84]	; (6358 <Power_Ip_SMC_ModeCheckEntry+0x60>)
    6302:	695b      	ldr	r3, [r3, #20]
    6304:	b2db      	uxtb	r3, r3
    6306:	9302      	str	r3, [sp, #8]

    switch (PowerMode)
    6308:	9b01      	ldr	r3, [sp, #4]
    630a:	2b02      	cmp	r3, #2
    630c:	d012      	beq.n	6334 <Power_Ip_SMC_ModeCheckEntry+0x3c>
    630e:	9b01      	ldr	r3, [sp, #4]
    6310:	2b02      	cmp	r3, #2
    6312:	d818      	bhi.n	6346 <Power_Ip_SMC_ModeCheckEntry+0x4e>
    6314:	9b01      	ldr	r3, [sp, #4]
    6316:	2b00      	cmp	r3, #0
    6318:	d003      	beq.n	6322 <Power_Ip_SMC_ModeCheckEntry+0x2a>
    631a:	9b01      	ldr	r3, [sp, #4]
    631c:	2b01      	cmp	r3, #1
    631e:	d003      	beq.n	6328 <Power_Ip_SMC_ModeCheckEntry+0x30>
        }
#endif /* (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON) */
        default:
        {
            /* Do nothing */
            break;
    6320:	e011      	b.n	6346 <Power_Ip_SMC_ModeCheckEntry+0x4e>
            PowerModeCheck = POWER_IP_MODE_OK;
    6322:	2300      	movs	r3, #0
    6324:	9303      	str	r3, [sp, #12]
            break;
    6326:	e013      	b.n	6350 <Power_Ip_SMC_ModeCheckEntry+0x58>
            if (SMC_PMSTAT_RUN_U32 == CurrentPowerMode)
    6328:	9b02      	ldr	r3, [sp, #8]
    632a:	2b01      	cmp	r3, #1
    632c:	d10d      	bne.n	634a <Power_Ip_SMC_ModeCheckEntry+0x52>
                PowerModeCheck = POWER_IP_MODE_OK;
    632e:	2300      	movs	r3, #0
    6330:	9303      	str	r3, [sp, #12]
            break;
    6332:	e00a      	b.n	634a <Power_Ip_SMC_ModeCheckEntry+0x52>
            if ((SMC_PMSTAT_RUN_U32 == CurrentPowerMode) || (SMC_PMSTAT_VLPS_U32 == CurrentPowerMode))
    6334:	9b02      	ldr	r3, [sp, #8]
    6336:	2b01      	cmp	r3, #1
    6338:	d002      	beq.n	6340 <Power_Ip_SMC_ModeCheckEntry+0x48>
    633a:	9b02      	ldr	r3, [sp, #8]
    633c:	2b10      	cmp	r3, #16
    633e:	d106      	bne.n	634e <Power_Ip_SMC_ModeCheckEntry+0x56>
                PowerModeCheck = POWER_IP_MODE_OK;
    6340:	2300      	movs	r3, #0
    6342:	9303      	str	r3, [sp, #12]
            break;
    6344:	e003      	b.n	634e <Power_Ip_SMC_ModeCheckEntry+0x56>
            break;
    6346:	bf00      	nop
    6348:	e002      	b.n	6350 <Power_Ip_SMC_ModeCheckEntry+0x58>
            break;
    634a:	bf00      	nop
    634c:	e000      	b.n	6350 <Power_Ip_SMC_ModeCheckEntry+0x58>
            break;
    634e:	bf00      	nop
        }
    }

    return PowerModeCheck;
    6350:	9b03      	ldr	r3, [sp, #12]
}
    6352:	4618      	mov	r0, r3
    6354:	b004      	add	sp, #16
    6356:	4770      	bx	lr
    6358:	4007e000 	.word	0x4007e000

0000635c <Power_Ip_SMC_ModeConfig>:
*
* @return           uint32
*
*/
uint32 Power_Ip_SMC_ModeConfig(const Power_Ip_ModeConfigType * ModeConfigPtr)
{
    635c:	b500      	push	{lr}
    635e:	b08b      	sub	sp, #44	; 0x2c
    6360:	9001      	str	r0, [sp, #4]
    uint32 PowerSwitchMode = POWER_IP_SWITCH_MODE_SUCCESS;
    6362:	2300      	movs	r3, #0
    6364:	9309      	str	r3, [sp, #36]	; 0x24
    /* Contains the code of the Power Mode (based PowerModeType enumeration). */
    Power_Ip_PowerModeType PowerMode = POWER_IP_RUN_MODE;
    6366:	2300      	movs	r3, #0
    6368:	9308      	str	r3, [sp, #32]
    uint32 RegValue = (uint32)0U;
#endif
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    boolean TimeoutOccurred = FALSE;
    636a:	2300      	movs	r3, #0
    636c:	f88d 301f 	strb.w	r3, [sp, #31]

    PowerMode = ModeConfigPtr->PowerMode;
    6370:	9b01      	ldr	r3, [sp, #4]
    6372:	685b      	ldr	r3, [r3, #4]
    6374:	9308      	str	r3, [sp, #32]

    switch (PowerMode)
    6376:	9b08      	ldr	r3, [sp, #32]
    6378:	2b02      	cmp	r3, #2
    637a:	d076      	beq.n	646a <Power_Ip_SMC_ModeConfig+0x10e>
    637c:	9b08      	ldr	r3, [sp, #32]
    637e:	2b02      	cmp	r3, #2
    6380:	f200 80ab 	bhi.w	64da <Power_Ip_SMC_ModeConfig+0x17e>
    6384:	9b08      	ldr	r3, [sp, #32]
    6386:	2b00      	cmp	r3, #0
    6388:	d003      	beq.n	6392 <Power_Ip_SMC_ModeConfig+0x36>
    638a:	9b08      	ldr	r3, [sp, #32]
    638c:	2b01      	cmp	r3, #1
    638e:	d034      	beq.n	63fa <Power_Ip_SMC_ModeConfig+0x9e>
    6390:	e0a3      	b.n	64da <Power_Ip_SMC_ModeConfig+0x17e>
    {
        case (POWER_IP_RUN_MODE):
        {
            /* Set RUN mode */
            TempValue = IP_SMC->PMCTRL;
    6392:	4b58      	ldr	r3, [pc, #352]	; (64f4 <Power_Ip_SMC_ModeConfig+0x198>)
    6394:	68db      	ldr	r3, [r3, #12]
    6396:	9306      	str	r3, [sp, #24]
            TempValue &= ~SMC_PMCTRL_RUNM_MASK;
    6398:	9b06      	ldr	r3, [sp, #24]
    639a:	f023 0360 	bic.w	r3, r3, #96	; 0x60
    639e:	9306      	str	r3, [sp, #24]
            TempValue |= SMC_PMCTRL_RUN_MODE_U32;
            IP_SMC->PMCTRL = TempValue;
    63a0:	4a54      	ldr	r2, [pc, #336]	; (64f4 <Power_Ip_SMC_ModeConfig+0x198>)
    63a2:	9b06      	ldr	r3, [sp, #24]
    63a4:	60d3      	str	r3, [r2, #12]

            /* Read back to make sure that mode changed successfuly */
            Power_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, POWER_IP_TIMEOUT_VALUE_US);
    63a6:	aa02      	add	r2, sp, #8
    63a8:	a903      	add	r1, sp, #12
    63aa:	a804      	add	r0, sp, #16
    63ac:	f24c 3350 	movw	r3, #50000	; 0xc350
    63b0:	f7ff fece 	bl	6150 <Power_Ip_StartTimeout>
            do
            {
                TimeoutOccurred = Power_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    63b4:	9a02      	ldr	r2, [sp, #8]
    63b6:	a903      	add	r1, sp, #12
    63b8:	ab04      	add	r3, sp, #16
    63ba:	4618      	mov	r0, r3
    63bc:	f7ff fee2 	bl	6184 <Power_Ip_TimeoutExpired>
    63c0:	4603      	mov	r3, r0
    63c2:	f88d 301f 	strb.w	r3, [sp, #31]
                PowerModeStatus = (IP_SMC->PMSTAT & SMC_PMSTAT_RUN_U32);
    63c6:	4b4b      	ldr	r3, [pc, #300]	; (64f4 <Power_Ip_SMC_ModeConfig+0x198>)
    63c8:	695b      	ldr	r3, [r3, #20]
    63ca:	f003 0301 	and.w	r3, r3, #1
    63ce:	9305      	str	r3, [sp, #20]
            } while ( (SMC_PMSTAT_RUN_U32 != PowerModeStatus) && (!TimeoutOccurred) );
    63d0:	9b05      	ldr	r3, [sp, #20]
    63d2:	2b01      	cmp	r3, #1
    63d4:	d006      	beq.n	63e4 <Power_Ip_SMC_ModeConfig+0x88>
    63d6:	f89d 301f 	ldrb.w	r3, [sp, #31]
    63da:	f083 0301 	eor.w	r3, r3, #1
    63de:	b2db      	uxtb	r3, r3
    63e0:	2b00      	cmp	r3, #0
    63e2:	d1e7      	bne.n	63b4 <Power_Ip_SMC_ModeConfig+0x58>
            if(TimeoutOccurred)
    63e4:	f89d 301f 	ldrb.w	r3, [sp, #31]
    63e8:	2b00      	cmp	r3, #0
    63ea:	d079      	beq.n	64e0 <Power_Ip_SMC_ModeConfig+0x184>
            {
                PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    63ec:	2301      	movs	r3, #1
    63ee:	9309      	str	r3, [sp, #36]	; 0x24
                Power_Ip_ReportPowerErrors(POWER_IP_REPORT_TIMEOUT_ERROR, POWER_IP_ERR_CODE_RESERVED);
    63f0:	21ff      	movs	r1, #255	; 0xff
    63f2:	2000      	movs	r0, #0
    63f4:	f7ff fe90 	bl	6118 <Power_Ip_ReportPowerErrors>
            }

            break;
    63f8:	e072      	b.n	64e0 <Power_Ip_SMC_ModeConfig+0x184>
        }
        case (POWER_IP_HSRUN_MODE):
        {
            /* Set HSRUN mode. */
            TempValue = IP_SMC->PMCTRL;
    63fa:	4b3e      	ldr	r3, [pc, #248]	; (64f4 <Power_Ip_SMC_ModeConfig+0x198>)
    63fc:	68db      	ldr	r3, [r3, #12]
    63fe:	9306      	str	r3, [sp, #24]
            TempValue &= ~SMC_PMCTRL_RUNM_MASK;
    6400:	9b06      	ldr	r3, [sp, #24]
    6402:	f023 0360 	bic.w	r3, r3, #96	; 0x60
    6406:	9306      	str	r3, [sp, #24]
            TempValue |= SMC_PMCTRL_HSRUN_MODE_U32;
    6408:	9b06      	ldr	r3, [sp, #24]
    640a:	f043 0360 	orr.w	r3, r3, #96	; 0x60
    640e:	9306      	str	r3, [sp, #24]
            IP_SMC->PMCTRL = TempValue;
    6410:	4a38      	ldr	r2, [pc, #224]	; (64f4 <Power_Ip_SMC_ModeConfig+0x198>)
    6412:	9b06      	ldr	r3, [sp, #24]
    6414:	60d3      	str	r3, [r2, #12]

            /* Read back to make sure that mode changed successfuly */
            Power_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, POWER_IP_TIMEOUT_VALUE_US);
    6416:	aa02      	add	r2, sp, #8
    6418:	a903      	add	r1, sp, #12
    641a:	a804      	add	r0, sp, #16
    641c:	f24c 3350 	movw	r3, #50000	; 0xc350
    6420:	f7ff fe96 	bl	6150 <Power_Ip_StartTimeout>
            do
            {
                TimeoutOccurred = Power_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    6424:	9a02      	ldr	r2, [sp, #8]
    6426:	a903      	add	r1, sp, #12
    6428:	ab04      	add	r3, sp, #16
    642a:	4618      	mov	r0, r3
    642c:	f7ff feaa 	bl	6184 <Power_Ip_TimeoutExpired>
    6430:	4603      	mov	r3, r0
    6432:	f88d 301f 	strb.w	r3, [sp, #31]
                PowerModeStatus = (IP_SMC->PMSTAT & SMC_PMSTAT_HSRUN_U32);
    6436:	4b2f      	ldr	r3, [pc, #188]	; (64f4 <Power_Ip_SMC_ModeConfig+0x198>)
    6438:	695b      	ldr	r3, [r3, #20]
    643a:	f003 0380 	and.w	r3, r3, #128	; 0x80
    643e:	9305      	str	r3, [sp, #20]
            } while ( (SMC_PMSTAT_HSRUN_U32 != PowerModeStatus) && (!TimeoutOccurred) );
    6440:	9b05      	ldr	r3, [sp, #20]
    6442:	2b80      	cmp	r3, #128	; 0x80
    6444:	d006      	beq.n	6454 <Power_Ip_SMC_ModeConfig+0xf8>
    6446:	f89d 301f 	ldrb.w	r3, [sp, #31]
    644a:	f083 0301 	eor.w	r3, r3, #1
    644e:	b2db      	uxtb	r3, r3
    6450:	2b00      	cmp	r3, #0
    6452:	d1e7      	bne.n	6424 <Power_Ip_SMC_ModeConfig+0xc8>
            if(TimeoutOccurred)
    6454:	f89d 301f 	ldrb.w	r3, [sp, #31]
    6458:	2b00      	cmp	r3, #0
    645a:	d043      	beq.n	64e4 <Power_Ip_SMC_ModeConfig+0x188>
            {
                PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    645c:	2301      	movs	r3, #1
    645e:	9309      	str	r3, [sp, #36]	; 0x24
                Power_Ip_ReportPowerErrors(POWER_IP_REPORT_TIMEOUT_ERROR, POWER_IP_ERR_CODE_RESERVED);
    6460:	21ff      	movs	r1, #255	; 0xff
    6462:	2000      	movs	r0, #0
    6464:	f7ff fe58 	bl	6118 <Power_Ip_ReportPowerErrors>
            }

            break;
    6468:	e03c      	b.n	64e4 <Power_Ip_SMC_ModeConfig+0x188>
        }
        case (POWER_IP_VLPR_MODE):
        {
            /* Set VLPR mode. */
            TempValue = IP_SMC->PMCTRL;
    646a:	4b22      	ldr	r3, [pc, #136]	; (64f4 <Power_Ip_SMC_ModeConfig+0x198>)
    646c:	68db      	ldr	r3, [r3, #12]
    646e:	9306      	str	r3, [sp, #24]
            TempValue &= ~SMC_PMCTRL_RUNM_MASK;
    6470:	9b06      	ldr	r3, [sp, #24]
    6472:	f023 0360 	bic.w	r3, r3, #96	; 0x60
    6476:	9306      	str	r3, [sp, #24]
            TempValue |= SMC_PMCTRL_VLPR_MODE_U32;
    6478:	9b06      	ldr	r3, [sp, #24]
    647a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    647e:	9306      	str	r3, [sp, #24]
            IP_SMC->PMCTRL = TempValue;
    6480:	4a1c      	ldr	r2, [pc, #112]	; (64f4 <Power_Ip_SMC_ModeConfig+0x198>)
    6482:	9b06      	ldr	r3, [sp, #24]
    6484:	60d3      	str	r3, [r2, #12]

            /* Read back to make sure that mode changed successfuly */
            Power_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, POWER_IP_TIMEOUT_VALUE_US);
    6486:	aa02      	add	r2, sp, #8
    6488:	a903      	add	r1, sp, #12
    648a:	a804      	add	r0, sp, #16
    648c:	f24c 3350 	movw	r3, #50000	; 0xc350
    6490:	f7ff fe5e 	bl	6150 <Power_Ip_StartTimeout>
            do
            {
                TimeoutOccurred = Power_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    6494:	9a02      	ldr	r2, [sp, #8]
    6496:	a903      	add	r1, sp, #12
    6498:	ab04      	add	r3, sp, #16
    649a:	4618      	mov	r0, r3
    649c:	f7ff fe72 	bl	6184 <Power_Ip_TimeoutExpired>
    64a0:	4603      	mov	r3, r0
    64a2:	f88d 301f 	strb.w	r3, [sp, #31]
                PowerModeStatus = (IP_SMC->PMSTAT & SMC_PMSTAT_VLPR_U32);
    64a6:	4b13      	ldr	r3, [pc, #76]	; (64f4 <Power_Ip_SMC_ModeConfig+0x198>)
    64a8:	695b      	ldr	r3, [r3, #20]
    64aa:	f003 0304 	and.w	r3, r3, #4
    64ae:	9305      	str	r3, [sp, #20]
            } while ( (SMC_PMSTAT_VLPR_U32 != PowerModeStatus) && (!TimeoutOccurred) );
    64b0:	9b05      	ldr	r3, [sp, #20]
    64b2:	2b04      	cmp	r3, #4
    64b4:	d006      	beq.n	64c4 <Power_Ip_SMC_ModeConfig+0x168>
    64b6:	f89d 301f 	ldrb.w	r3, [sp, #31]
    64ba:	f083 0301 	eor.w	r3, r3, #1
    64be:	b2db      	uxtb	r3, r3
    64c0:	2b00      	cmp	r3, #0
    64c2:	d1e7      	bne.n	6494 <Power_Ip_SMC_ModeConfig+0x138>
            if(TimeoutOccurred)
    64c4:	f89d 301f 	ldrb.w	r3, [sp, #31]
    64c8:	2b00      	cmp	r3, #0
    64ca:	d00d      	beq.n	64e8 <Power_Ip_SMC_ModeConfig+0x18c>
            {
                PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    64cc:	2301      	movs	r3, #1
    64ce:	9309      	str	r3, [sp, #36]	; 0x24
                Power_Ip_ReportPowerErrors(POWER_IP_REPORT_TIMEOUT_ERROR, POWER_IP_ERR_CODE_RESERVED);
    64d0:	21ff      	movs	r1, #255	; 0xff
    64d2:	2000      	movs	r0, #0
    64d4:	f7ff fe20 	bl	6118 <Power_Ip_ReportPowerErrors>
            }

            break;
    64d8:	e006      	b.n	64e8 <Power_Ip_SMC_ModeConfig+0x18c>
        }
#endif /* (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON) */
        default:
        {
            /*Only the above modes are allowed when this function is called*/
            PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    64da:	2301      	movs	r3, #1
    64dc:	9309      	str	r3, [sp, #36]	; 0x24
            break;
    64de:	e004      	b.n	64ea <Power_Ip_SMC_ModeConfig+0x18e>
            break;
    64e0:	bf00      	nop
    64e2:	e002      	b.n	64ea <Power_Ip_SMC_ModeConfig+0x18e>
            break;
    64e4:	bf00      	nop
    64e6:	e000      	b.n	64ea <Power_Ip_SMC_ModeConfig+0x18e>
            break;
    64e8:	bf00      	nop
#if (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON)
    /* Avoid compiler warning */
    (void)RegValue;
#endif

    return PowerSwitchMode;
    64ea:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    64ec:	4618      	mov	r0, r3
    64ee:	b00b      	add	sp, #44	; 0x2c
    64f0:	f85d fb04 	ldr.w	pc, [sp], #4
    64f4:	4007e000 	.word	0x4007e000

000064f8 <Port_Init>:
*/
void Port_Init
(
    const Port_ConfigType * ConfigPtr
)
{
    64f8:	b500      	push	{lr}
    64fa:	b085      	sub	sp, #20
    64fc:	9001      	str	r0, [sp, #4]
#if (STD_ON == PORT_PRECOMPILE_SUPPORT)
    const Port_ConfigType * pLocalConfigPtr = &Port_Config;
    /* Cast ConfigPtr to avoid the compiler warning when configuring with PORT_PRECOMPILE_SUPPORT == STD_ON and PORT_DEV_ERROR_DETECT == STD_OFF */
    (void)ConfigPtr;
#else
    const Port_ConfigType * pLocalConfigPtr = ConfigPtr;
    64fe:	9b01      	ldr	r3, [sp, #4]
    6500:	9303      	str	r3, [sp, #12]
#endif /* (STD_ON == PORT_PRECOMPILE_SUPPORT) */

#if (STD_ON == PORT_DEV_ERROR_DETECT)
    uint8 CoreId;

    CoreId = (uint8)Port_GetCoreID();
    6502:	2300      	movs	r3, #0
    6504:	f88d 300b 	strb.w	r3, [sp, #11]
#if (STD_OFF == PORT_PRECOMPILE_SUPPORT)
    if (NULL_PTR == ConfigPtr)
    6508:	9b01      	ldr	r3, [sp, #4]
    650a:	2b00      	cmp	r3, #0
    650c:	d106      	bne.n	651c <Port_Init+0x24>
#else /*(STD_OFF == PORT_PRECOMPILE_SUPPORT) */
    if (NULL_PTR != ConfigPtr)
#endif /* (STD_OFF == PORT_PRECOMPILE_SUPPORT) */
    {
        (void)Det_ReportError((uint16)PORT_MODULE_ID, PORT_INSTANCE_ID, (uint8)PORT_INIT_ID, (uint8)PORT_E_INIT_FAILED);
    650e:	230c      	movs	r3, #12
    6510:	2200      	movs	r2, #0
    6512:	2100      	movs	r1, #0
    6514:	207c      	movs	r0, #124	; 0x7c
    6516:	f010 fc3d 	bl	16d94 <Det_ReportError>

            /*  Save configuration pointer in global variable */
            Port_pConfigPtr = pLocalConfigPtr;
        }
    }
}
    651a:	e014      	b.n	6546 <Port_Init+0x4e>
        if ((uint32)1 != pLocalConfigPtr->pau8Port_PartitionList[CoreId])
    651c:	9b03      	ldr	r3, [sp, #12]
    651e:	69da      	ldr	r2, [r3, #28]
    6520:	f89d 300b 	ldrb.w	r3, [sp, #11]
    6524:	4413      	add	r3, r2
    6526:	781b      	ldrb	r3, [r3, #0]
    6528:	2b01      	cmp	r3, #1
    652a:	d006      	beq.n	653a <Port_Init+0x42>
            (void)Det_ReportError((uint16)PORT_MODULE_ID, PORT_INSTANCE_ID, (uint8)PORT_INIT_ID, (uint8)PORT_E_PARAM_CONFIG);
    652c:	23f0      	movs	r3, #240	; 0xf0
    652e:	2200      	movs	r2, #0
    6530:	2100      	movs	r1, #0
    6532:	207c      	movs	r0, #124	; 0x7c
    6534:	f010 fc2e 	bl	16d94 <Det_ReportError>
}
    6538:	e005      	b.n	6546 <Port_Init+0x4e>
            Port_Ipw_Init(pLocalConfigPtr);
    653a:	9803      	ldr	r0, [sp, #12]
    653c:	f000 fc64 	bl	6e08 <Port_Ipw_Init>
            Port_pConfigPtr = pLocalConfigPtr;
    6540:	4a03      	ldr	r2, [pc, #12]	; (6550 <Port_Init+0x58>)
    6542:	9b03      	ldr	r3, [sp, #12]
    6544:	6013      	str	r3, [r2, #0]
}
    6546:	bf00      	nop
    6548:	b005      	add	sp, #20
    654a:	f85d fb04 	ldr.w	pc, [sp], #4
    654e:	bf00      	nop
    6550:	1fff8cec 	.word	0x1fff8cec

00006554 <Port_SetPinDirection>:
void Port_SetPinDirection
(
    Port_PinType Pin,
    Port_PinDirectionType Direction
)
{
    6554:	b500      	push	{lr}
    6556:	b085      	sub	sp, #20
    6558:	9001      	str	r0, [sp, #4]
    655a:	9100      	str	r1, [sp, #0]
#if (STD_ON == PORT_DEV_ERROR_DETECT)
    /* Variable used to store current error status */
    Std_ReturnType ErrStatus;

    /* Check if Port module is initialized */
    if (NULL_PTR == Port_pConfigPtr)
    655c:	4b11      	ldr	r3, [pc, #68]	; (65a4 <Port_SetPinDirection+0x50>)
    655e:	681b      	ldr	r3, [r3, #0]
    6560:	2b00      	cmp	r3, #0
    6562:	d106      	bne.n	6572 <Port_SetPinDirection+0x1e>
    {
        (void)Det_ReportError((uint16)PORT_MODULE_ID, (uint8)PORT_INSTANCE_ID, (uint8)PORT_SETPINDIRECTION_ID, (uint8)PORT_E_UNINIT);
    6564:	230f      	movs	r3, #15
    6566:	2201      	movs	r2, #1
    6568:	2100      	movs	r1, #0
    656a:	207c      	movs	r0, #124	; 0x7c
    656c:	f010 fc12 	bl	16d94 <Det_ReportError>
        {
            (void)Det_ReportError((uint16)PORT_MODULE_ID, (uint8)PORT_INSTANCE_ID, (uint8)PORT_SETPINDIRECTION_ID, (uint8)PORT_E_DIRECTION_UNCHANGEABLE);
        }
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */
    }
}
    6570:	e013      	b.n	659a <Port_SetPinDirection+0x46>
        ErrStatus = Port_Ipw_SetPinDirection(Pin, Direction, Port_pConfigPtr);
    6572:	4b0c      	ldr	r3, [pc, #48]	; (65a4 <Port_SetPinDirection+0x50>)
    6574:	681b      	ldr	r3, [r3, #0]
    6576:	461a      	mov	r2, r3
    6578:	9900      	ldr	r1, [sp, #0]
    657a:	9801      	ldr	r0, [sp, #4]
    657c:	f000 fcb2 	bl	6ee4 <Port_Ipw_SetPinDirection>
    6580:	4603      	mov	r3, r0
    6582:	f88d 300f 	strb.w	r3, [sp, #15]
        if ((Std_ReturnType)E_NOT_OK == ErrStatus)
    6586:	f89d 300f 	ldrb.w	r3, [sp, #15]
    658a:	2b01      	cmp	r3, #1
    658c:	d105      	bne.n	659a <Port_SetPinDirection+0x46>
            (void)Det_ReportError((uint16)PORT_MODULE_ID, (uint8)PORT_INSTANCE_ID, (uint8)PORT_SETPINDIRECTION_ID, (uint8)PORT_E_DIRECTION_UNCHANGEABLE);
    658e:	230b      	movs	r3, #11
    6590:	2201      	movs	r2, #1
    6592:	2100      	movs	r1, #0
    6594:	207c      	movs	r0, #124	; 0x7c
    6596:	f010 fbfd 	bl	16d94 <Det_ReportError>
}
    659a:	bf00      	nop
    659c:	b005      	add	sp, #20
    659e:	f85d fb04 	ldr.w	pc, [sp], #4
    65a2:	bf00      	nop
    65a4:	1fff8cec 	.word	0x1fff8cec

000065a8 <Port_SetPinMode>:
void Port_SetPinMode
(
    Port_PinType Pin,
    Port_PinModeType Mode
)
{
    65a8:	b500      	push	{lr}
    65aa:	b085      	sub	sp, #20
    65ac:	9001      	str	r0, [sp, #4]
    65ae:	460b      	mov	r3, r1
    65b0:	f88d 3003 	strb.w	r3, [sp, #3]
#if (STD_ON == PORT_DEV_ERROR_DETECT)
    uint8 u8PinModeError = (uint8)0U;
    65b4:	2300      	movs	r3, #0
    65b6:	f88d 300f 	strb.w	r3, [sp, #15]

    /* Check if port is initialized */
    if (NULL_PTR == Port_pConfigPtr)
    65ba:	4b12      	ldr	r3, [pc, #72]	; (6604 <Port_SetPinMode+0x5c>)
    65bc:	681b      	ldr	r3, [r3, #0]
    65be:	2b00      	cmp	r3, #0
    65c0:	d106      	bne.n	65d0 <Port_SetPinMode+0x28>
    {
        (void)Det_ReportError((uint16)PORT_MODULE_ID, (uint8)PORT_INSTANCE_ID, (uint8)PORT_SETPINMODE_ID, (uint8)PORT_E_UNINIT);
    65c2:	230f      	movs	r3, #15
    65c4:	2204      	movs	r2, #4
    65c6:	2100      	movs	r1, #0
    65c8:	207c      	movs	r0, #124	; 0x7c
    65ca:	f010 fbe3 	bl	16d94 <Det_ReportError>
        {
            (void)Det_ReportError((uint16)PORT_MODULE_ID, (uint8)PORT_INSTANCE_ID, (uint8)PORT_SETPINMODE_ID, (uint8)PORT_E_PARAM_INVALID_MODE);
        }
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */
    }
}
    65ce:	e014      	b.n	65fa <Port_SetPinMode+0x52>
        u8PinModeError = (uint8)Port_Ipw_SetPinMode(Pin, Mode, Port_pConfigPtr);
    65d0:	4b0c      	ldr	r3, [pc, #48]	; (6604 <Port_SetPinMode+0x5c>)
    65d2:	681a      	ldr	r2, [r3, #0]
    65d4:	f89d 3003 	ldrb.w	r3, [sp, #3]
    65d8:	4619      	mov	r1, r3
    65da:	9801      	ldr	r0, [sp, #4]
    65dc:	f000 fd7a 	bl	70d4 <Port_Ipw_SetPinMode>
    65e0:	4603      	mov	r3, r0
    65e2:	f88d 300f 	strb.w	r3, [sp, #15]
        if (PORT_E_PARAM_INVALID_MODE == u8PinModeError)
    65e6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    65ea:	2b0d      	cmp	r3, #13
    65ec:	d105      	bne.n	65fa <Port_SetPinMode+0x52>
            (void)Det_ReportError((uint16)PORT_MODULE_ID, (uint8)PORT_INSTANCE_ID, (uint8)PORT_SETPINMODE_ID, (uint8)PORT_E_PARAM_INVALID_MODE);
    65ee:	230d      	movs	r3, #13
    65f0:	2204      	movs	r2, #4
    65f2:	2100      	movs	r1, #0
    65f4:	207c      	movs	r0, #124	; 0x7c
    65f6:	f010 fbcd 	bl	16d94 <Det_ReportError>
}
    65fa:	bf00      	nop
    65fc:	b005      	add	sp, #20
    65fe:	f85d fb04 	ldr.w	pc, [sp], #4
    6602:	bf00      	nop
    6604:	1fff8cec 	.word	0x1fff8cec

00006608 <Port_RefreshPortDirection>:
*          are configured as "pin direction changeable during runtime".
* @pre     @p Port_Init() must have been called first.
*
*/
void Port_RefreshPortDirection( void )
{
    6608:	b500      	push	{lr}
    660a:	b083      	sub	sp, #12
#if (STD_ON == PORT_DEV_ERROR_DETECT)
    uint8 CoreId;

    CoreId = (uint8)Port_GetCoreID();
    660c:	2300      	movs	r3, #0
    660e:	f88d 3007 	strb.w	r3, [sp, #7]
    /* Check if Port module is initialized */
    if (NULL_PTR == Port_pConfigPtr)
    6612:	4b12      	ldr	r3, [pc, #72]	; (665c <Port_RefreshPortDirection+0x54>)
    6614:	681b      	ldr	r3, [r3, #0]
    6616:	2b00      	cmp	r3, #0
    6618:	d106      	bne.n	6628 <Port_RefreshPortDirection+0x20>
    {
        (void)Det_ReportError((uint16)PORT_MODULE_ID, (uint8)PORT_INSTANCE_ID, (uint8)PORT_REFRESHPINDIRECTION_ID, (uint8)PORT_E_UNINIT);
    661a:	230f      	movs	r3, #15
    661c:	2202      	movs	r2, #2
    661e:	2100      	movs	r1, #0
    6620:	207c      	movs	r0, #124	; 0x7c
    6622:	f010 fbb7 	bl	16d94 <Det_ReportError>
    else
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */
    {
        Port_Ipw_RefreshPortDirection(Port_pConfigPtr);
    }
}
    6626:	e014      	b.n	6652 <Port_RefreshPortDirection+0x4a>
    else if ((uint32)1 != Port_pConfigPtr->pau8Port_PartitionList[CoreId])
    6628:	4b0c      	ldr	r3, [pc, #48]	; (665c <Port_RefreshPortDirection+0x54>)
    662a:	681b      	ldr	r3, [r3, #0]
    662c:	69da      	ldr	r2, [r3, #28]
    662e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    6632:	4413      	add	r3, r2
    6634:	781b      	ldrb	r3, [r3, #0]
    6636:	2b01      	cmp	r3, #1
    6638:	d006      	beq.n	6648 <Port_RefreshPortDirection+0x40>
        (void)Det_ReportError((uint16)PORT_MODULE_ID, PORT_INSTANCE_ID, (uint8)PORT_REFRESHPINDIRECTION_ID, (uint8)PORT_E_PARAM_CONFIG);
    663a:	23f0      	movs	r3, #240	; 0xf0
    663c:	2202      	movs	r2, #2
    663e:	2100      	movs	r1, #0
    6640:	207c      	movs	r0, #124	; 0x7c
    6642:	f010 fba7 	bl	16d94 <Det_ReportError>
}
    6646:	e004      	b.n	6652 <Port_RefreshPortDirection+0x4a>
        Port_Ipw_RefreshPortDirection(Port_pConfigPtr);
    6648:	4b04      	ldr	r3, [pc, #16]	; (665c <Port_RefreshPortDirection+0x54>)
    664a:	681b      	ldr	r3, [r3, #0]
    664c:	4618      	mov	r0, r3
    664e:	f000 febf 	bl	73d0 <Port_Ipw_RefreshPortDirection>
}
    6652:	bf00      	nop
    6654:	b003      	add	sp, #12
    6656:	f85d fb04 	ldr.w	pc, [sp], #4
    665a:	bf00      	nop
    665c:	1fff8cec 	.word	0x1fff8cec

00006660 <Port_GetVersionInfo>:
*/
void Port_GetVersionInfo
(
    Std_VersionInfoType * versioninfo
)
{
    6660:	b500      	push	{lr}
    6662:	b083      	sub	sp, #12
    6664:	9001      	str	r0, [sp, #4]
#if (STD_ON == PORT_DEV_ERROR_DETECT)
    if (NULL_PTR == versioninfo)
    6666:	9b01      	ldr	r3, [sp, #4]
    6668:	2b00      	cmp	r3, #0
    666a:	d106      	bne.n	667a <Port_GetVersionInfo+0x1a>
    {
        (void)Det_ReportError((uint16)PORT_MODULE_ID, (uint8)PORT_INSTANCE_ID, (uint8)PORT_GETVERSIONINFO_ID, (uint8)PORT_E_PARAM_POINTER);
    666c:	2310      	movs	r3, #16
    666e:	2203      	movs	r2, #3
    6670:	2100      	movs	r1, #0
    6672:	207c      	movs	r0, #124	; 0x7c
    6674:	f010 fb8e 	bl	16d94 <Det_ReportError>
        (versioninfo)->moduleID         = (uint16)PORT_MODULE_ID;
        (versioninfo)->sw_major_version = (uint8)PORT_SW_MAJOR_VERSION;
        (versioninfo)->sw_minor_version = (uint8)PORT_SW_MINOR_VERSION;
        (versioninfo)->sw_patch_version = (uint8)PORT_SW_PATCH_VERSION;
    }
}
    6678:	e00e      	b.n	6698 <Port_GetVersionInfo+0x38>
        (versioninfo)->vendorID         = (uint16)PORT_VENDOR_ID;
    667a:	9b01      	ldr	r3, [sp, #4]
    667c:	222b      	movs	r2, #43	; 0x2b
    667e:	801a      	strh	r2, [r3, #0]
        (versioninfo)->moduleID         = (uint16)PORT_MODULE_ID;
    6680:	9b01      	ldr	r3, [sp, #4]
    6682:	227c      	movs	r2, #124	; 0x7c
    6684:	805a      	strh	r2, [r3, #2]
        (versioninfo)->sw_major_version = (uint8)PORT_SW_MAJOR_VERSION;
    6686:	9b01      	ldr	r3, [sp, #4]
    6688:	2202      	movs	r2, #2
    668a:	711a      	strb	r2, [r3, #4]
        (versioninfo)->sw_minor_version = (uint8)PORT_SW_MINOR_VERSION;
    668c:	9b01      	ldr	r3, [sp, #4]
    668e:	2200      	movs	r2, #0
    6690:	715a      	strb	r2, [r3, #5]
        (versioninfo)->sw_patch_version = (uint8)PORT_SW_PATCH_VERSION;
    6692:	9b01      	ldr	r3, [sp, #4]
    6694:	2200      	movs	r2, #0
    6696:	719a      	strb	r2, [r3, #6]
}
    6698:	bf00      	nop
    669a:	b003      	add	sp, #12
    669c:	f85d fb04 	ldr.w	pc, [sp], #4

000066a0 <Port_Ci_Port_Ip_GetAdcInterleaveVal>:
(
    const PORT_Type * base,
    const uint32 pinPortIdx,
    const uint32 currentVal
)
{
    66a0:	b086      	sub	sp, #24
    66a2:	9003      	str	r0, [sp, #12]
    66a4:	9102      	str	r1, [sp, #8]
    66a6:	9201      	str	r2, [sp, #4]
    uint32 adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_INVALID;
    66a8:	23ff      	movs	r3, #255	; 0xff
    66aa:	9305      	str	r3, [sp, #20]
    /* calculate appropriate value to enable or disable in SIM_CHIPCTL[ADC_INTERLEAVE_EN] */
    if ((uint32)base == (uint32)IP_PORTB)
    66ac:	9b03      	ldr	r3, [sp, #12]
    66ae:	4a39      	ldr	r2, [pc, #228]	; (6794 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xf4>)
    66b0:	4293      	cmp	r3, r2
    66b2:	d151      	bne.n	6758 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xb8>
    66b4:	9b02      	ldr	r3, [sp, #8]
    66b6:	2b10      	cmp	r3, #16
    66b8:	d867      	bhi.n	678a <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xea>
    66ba:	a201      	add	r2, pc, #4	; (adr r2, 66c0 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0x20>)
    66bc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    66c0:	00006705 	.word	0x00006705
    66c4:	00006713 	.word	0x00006713
    66c8:	0000678b 	.word	0x0000678b
    66cc:	0000678b 	.word	0x0000678b
    66d0:	0000678b 	.word	0x0000678b
    66d4:	0000678b 	.word	0x0000678b
    66d8:	0000678b 	.word	0x0000678b
    66dc:	0000678b 	.word	0x0000678b
    66e0:	0000678b 	.word	0x0000678b
    66e4:	0000678b 	.word	0x0000678b
    66e8:	0000678b 	.word	0x0000678b
    66ec:	0000678b 	.word	0x0000678b
    66f0:	0000678b 	.word	0x0000678b
    66f4:	00006721 	.word	0x00006721
    66f8:	0000672f 	.word	0x0000672f
    66fc:	0000673d 	.word	0x0000673d
    6700:	0000674b 	.word	0x0000674b
    {
        switch (pinPortIdx)
        {
            case 0:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE0;
    6704:	2301      	movs	r3, #1
    6706:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    6708:	9a05      	ldr	r2, [sp, #20]
    670a:	9b01      	ldr	r3, [sp, #4]
    670c:	4313      	orrs	r3, r2
    670e:	9305      	str	r3, [sp, #20]
                break;
    6710:	e03c      	b.n	678c <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 1:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE1;
    6712:	2302      	movs	r3, #2
    6714:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    6716:	9a05      	ldr	r2, [sp, #20]
    6718:	9b01      	ldr	r3, [sp, #4]
    671a:	4313      	orrs	r3, r2
    671c:	9305      	str	r3, [sp, #20]
                break;
    671e:	e035      	b.n	678c <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 13:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE2;
    6720:	2304      	movs	r3, #4
    6722:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    6724:	9a05      	ldr	r2, [sp, #20]
    6726:	9b01      	ldr	r3, [sp, #4]
    6728:	4313      	orrs	r3, r2
    672a:	9305      	str	r3, [sp, #20]
                break;
    672c:	e02e      	b.n	678c <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 14:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE3;
    672e:	2308      	movs	r3, #8
    6730:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    6732:	9a05      	ldr	r2, [sp, #20]
    6734:	9b01      	ldr	r3, [sp, #4]
    6736:	4313      	orrs	r3, r2
    6738:	9305      	str	r3, [sp, #20]
                break;
    673a:	e027      	b.n	678c <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 15:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE0;
    673c:	230e      	movs	r3, #14
    673e:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    6740:	9a05      	ldr	r2, [sp, #20]
    6742:	9b01      	ldr	r3, [sp, #4]
    6744:	4013      	ands	r3, r2
    6746:	9305      	str	r3, [sp, #20]
                break;
    6748:	e020      	b.n	678c <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 16:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE1;
    674a:	230d      	movs	r3, #13
    674c:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    674e:	9a05      	ldr	r2, [sp, #20]
    6750:	9b01      	ldr	r3, [sp, #4]
    6752:	4013      	ands	r3, r2
    6754:	9305      	str	r3, [sp, #20]
                break;
    6756:	e019      	b.n	678c <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            default:
                /* invalid command */
                break;
        }
    }
    else if ((uint32)base == (uint32)IP_PORTC)
    6758:	9b03      	ldr	r3, [sp, #12]
    675a:	4a0f      	ldr	r2, [pc, #60]	; (6798 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xf8>)
    675c:	4293      	cmp	r3, r2
    675e:	d115      	bne.n	678c <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
    {
        switch (pinPortIdx)
    6760:	9b02      	ldr	r3, [sp, #8]
    6762:	2b00      	cmp	r3, #0
    6764:	d003      	beq.n	676e <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xce>
    6766:	9b02      	ldr	r3, [sp, #8]
    6768:	2b01      	cmp	r3, #1
    676a:	d007      	beq.n	677c <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xdc>
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE3;
                adcInterleaveVal &= currentVal;
                break;
            default:
                /* invalid command */
                break;
    676c:	e00e      	b.n	678c <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE2;
    676e:	230b      	movs	r3, #11
    6770:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    6772:	9a05      	ldr	r2, [sp, #20]
    6774:	9b01      	ldr	r3, [sp, #4]
    6776:	4013      	ands	r3, r2
    6778:	9305      	str	r3, [sp, #20]
                break;
    677a:	e007      	b.n	678c <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE3;
    677c:	2307      	movs	r3, #7
    677e:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    6780:	9a05      	ldr	r2, [sp, #20]
    6782:	9b01      	ldr	r3, [sp, #4]
    6784:	4013      	ands	r3, r2
    6786:	9305      	str	r3, [sp, #20]
                break;
    6788:	e000      	b.n	678c <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
                break;
    678a:	bf00      	nop
    }
    else
    {
        /* invalid command */
    }
    return adcInterleaveVal;
    678c:	9b05      	ldr	r3, [sp, #20]
}
    678e:	4618      	mov	r0, r3
    6790:	b006      	add	sp, #24
    6792:	4770      	bx	lr
    6794:	4004a000 	.word	0x4004a000
    6798:	4004b000 	.word	0x4004b000

0000679c <Port_Ci_Port_Ip_ConfigureInterleave>:
(
    const PORT_Type * const base,
    uint32 pin,
    Port_Ci_Port_Ip_PortMux muxing
)
{
    679c:	b500      	push	{lr}
    679e:	b089      	sub	sp, #36	; 0x24
    67a0:	9003      	str	r0, [sp, #12]
    67a2:	9102      	str	r1, [sp, #8]
    67a4:	9201      	str	r2, [sp, #4]
    Port_Ci_Port_Ip_PortMux retMuxing = muxing;
    67a6:	9b01      	ldr	r3, [sp, #4]
    67a8:	9307      	str	r3, [sp, #28]
    if (muxing == PORT_MUX_ADC_INTERLEAVE)
    67aa:	9b01      	ldr	r3, [sp, #4]
    67ac:	2b08      	cmp	r3, #8
    67ae:	d121      	bne.n	67f4 <Port_Ci_Port_Ip_ConfigureInterleave+0x58>
    {
        /* Get ADC Interleave from SIM and enable/disable desired bit */
        uint32 chipCtlReg = (IP_SIM->CHIPCTL & SIM_CHIPCTL_ADC_INTERLEAVE_EN_MASK) >> SIM_CHIPCTL_ADC_INTERLEAVE_EN_SHIFT;
    67b0:	4b13      	ldr	r3, [pc, #76]	; (6800 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    67b2:	685b      	ldr	r3, [r3, #4]
    67b4:	f003 030f 	and.w	r3, r3, #15
    67b8:	9306      	str	r3, [sp, #24]
        Port_Ci_Port_Ip_InterleaveMux interleaveVal = (Port_Ci_Port_Ip_InterleaveMux)Port_Ci_Port_Ip_GetAdcInterleaveVal(base, pin, chipCtlReg);
    67ba:	9a06      	ldr	r2, [sp, #24]
    67bc:	9902      	ldr	r1, [sp, #8]
    67be:	9803      	ldr	r0, [sp, #12]
    67c0:	f7ff ff6e 	bl	66a0 <Port_Ci_Port_Ip_GetAdcInterleaveVal>
    67c4:	9005      	str	r0, [sp, #20]
        if (interleaveVal != PIN_ADC_INTERLEAVE_INVALID)
    67c6:	9b05      	ldr	r3, [sp, #20]
    67c8:	2bff      	cmp	r3, #255	; 0xff
    67ca:	d011      	beq.n	67f0 <Port_Ci_Port_Ip_ConfigureInterleave+0x54>
        {
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05();
    67cc:	f00e fc2a 	bl	15024 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05>
            IP_SIM->CHIPCTL &= ~(SIM_CHIPCTL_ADC_INTERLEAVE_EN_MASK);
    67d0:	4b0b      	ldr	r3, [pc, #44]	; (6800 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    67d2:	685b      	ldr	r3, [r3, #4]
    67d4:	4a0a      	ldr	r2, [pc, #40]	; (6800 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    67d6:	f023 030f 	bic.w	r3, r3, #15
    67da:	6053      	str	r3, [r2, #4]
            IP_SIM->CHIPCTL |= SIM_CHIPCTL_ADC_INTERLEAVE_EN(interleaveVal);
    67dc:	4b08      	ldr	r3, [pc, #32]	; (6800 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    67de:	685a      	ldr	r2, [r3, #4]
    67e0:	9b05      	ldr	r3, [sp, #20]
    67e2:	f003 030f 	and.w	r3, r3, #15
    67e6:	4906      	ldr	r1, [pc, #24]	; (6800 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    67e8:	4313      	orrs	r3, r2
    67ea:	604b      	str	r3, [r1, #4]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05();
    67ec:	f00e fc46 	bl	1507c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05>
        }
        /* return real muxing for pin */
        retMuxing = PORT_MUX_ALT0;
    67f0:	2300      	movs	r3, #0
    67f2:	9307      	str	r3, [sp, #28]
    }
    return retMuxing;
    67f4:	9b07      	ldr	r3, [sp, #28]
}
    67f6:	4618      	mov	r0, r3
    67f8:	b009      	add	sp, #36	; 0x24
    67fa:	f85d fb04 	ldr.w	pc, [sp], #4
    67fe:	bf00      	nop
    6800:	40048000 	.word	0x40048000

00006804 <Port_Ci_Port_Ip_PinInit>:
 * Description   : This function configures the pin feature with the options
 * provided in the given structure.
 *
 ******************************************************************************/
static void Port_Ci_Port_Ip_PinInit(const Port_Ci_Port_Ip_PinSettingsConfig * config)
{
    6804:	b500      	push	{lr}
    6806:	b087      	sub	sp, #28
    6808:	9001      	str	r0, [sp, #4]
    uint32 pinsValues = 0U;
    680a:	2300      	movs	r3, #0
    680c:	9305      	str	r3, [sp, #20]
    uint32 digitalFilters;
    Port_Ci_Port_Ip_PortMux muxing = PORT_MUX_ALT0;
    680e:	2300      	movs	r3, #0
    6810:	9304      	str	r3, [sp, #16]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
    Port_Ci_Port_Ip_PortMux retMuxing = PORT_MUX_ALT0;
    6812:	2300      	movs	r3, #0
    6814:	9303      	str	r3, [sp, #12]
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */
    PORT_CI_PORT_DEV_ASSERT((boolean)(config != NULL_PTR));
    PORT_CI_PORT_DEV_ASSERT((boolean)(config->pinPortIdx < 32));
    PORT_CI_PORT_DEV_ASSERT((boolean)((config->portBase->PCR[config->pinPortIdx]) & PORT_PCR_LK_MASK) == 0);

    if (config->pullConfig != PORT_INTERNAL_PULL_NOT_ENABLED)
    6816:	9b01      	ldr	r3, [sp, #4]
    6818:	68db      	ldr	r3, [r3, #12]
    681a:	2b02      	cmp	r3, #2
    681c:	d00a      	beq.n	6834 <Port_Ci_Port_Ip_PinInit+0x30>
    {
        pinsValues |= PORT_PCR_PE(1);
    681e:	9b05      	ldr	r3, [sp, #20]
    6820:	f043 0302 	orr.w	r3, r3, #2
    6824:	9305      	str	r3, [sp, #20]
        pinsValues |= PORT_PCR_PS(config->pullConfig);
    6826:	9b01      	ldr	r3, [sp, #4]
    6828:	68db      	ldr	r3, [r3, #12]
    682a:	f003 0301 	and.w	r3, r3, #1
    682e:	9a05      	ldr	r2, [sp, #20]
    6830:	4313      	orrs	r3, r2
    6832:	9305      	str	r3, [sp, #20]
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE)
    pinsValues |= PORT_PCR_SRE(config->slewRateCtrlSel);
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_DRIVE_STRENGTH
    pinsValues |= PORT_PCR_DSE(config->driveStrength);
    6834:	9b01      	ldr	r3, [sp, #4]
    6836:	699b      	ldr	r3, [r3, #24]
    6838:	019b      	lsls	r3, r3, #6
    683a:	f003 0340 	and.w	r3, r3, #64	; 0x40
    683e:	9a05      	ldr	r2, [sp, #20]
    6840:	4313      	orrs	r3, r2
    6842:	9305      	str	r3, [sp, #20]
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_DRIVE_STRENGTH */
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_LOCK_REGISTER
    pinsValues |= PORT_PCR_LK(config->lockRegister);
    6844:	9b01      	ldr	r3, [sp, #4]
    6846:	6a1b      	ldr	r3, [r3, #32]
    6848:	03db      	lsls	r3, r3, #15
    684a:	b29b      	uxth	r3, r3
    684c:	9a05      	ldr	r2, [sp, #20]
    684e:	4313      	orrs	r3, r2
    6850:	9305      	str	r3, [sp, #20]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN)
    pinsValues |= PORT_PCR_ODE(config->openDrain);
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
    pinsValues |= PORT_PCR_PFE(config->passiveFilter?1U:0U);
    6852:	9b01      	ldr	r3, [sp, #4]
    6854:	7f1b      	ldrb	r3, [r3, #28]
    6856:	2b00      	cmp	r3, #0
    6858:	d001      	beq.n	685e <Port_Ci_Port_Ip_PinInit+0x5a>
    685a:	2310      	movs	r3, #16
    685c:	e000      	b.n	6860 <Port_Ci_Port_Ip_PinInit+0x5c>
    685e:	2300      	movs	r3, #0
    6860:	9a05      	ldr	r2, [sp, #20]
    6862:	4313      	orrs	r3, r2
    6864:	9305      	str	r3, [sp, #20]

    muxing = config->mux;
    6866:	9b01      	ldr	r3, [sp, #4]
    6868:	691b      	ldr	r3, [r3, #16]
    686a:	9304      	str	r3, [sp, #16]

#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
#if (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT))
    retMuxing = (Port_Ci_Port_Ip_PortMux)OsIf_Trusted_Call_Return3param(Port_Ci_Port_Ip_ConfigureInterleave,(config->portBase),(config->pinPortIdx),(muxing));
#else
    retMuxing = Port_Ci_Port_Ip_ConfigureInterleave(config->portBase, config->pinPortIdx, muxing);
    686c:	9b01      	ldr	r3, [sp, #4]
    686e:	6818      	ldr	r0, [r3, #0]
    6870:	9b01      	ldr	r3, [sp, #4]
    6872:	689b      	ldr	r3, [r3, #8]
    6874:	9a04      	ldr	r2, [sp, #16]
    6876:	4619      	mov	r1, r3
    6878:	f7ff ff90 	bl	679c <Port_Ci_Port_Ip_ConfigureInterleave>
    687c:	9003      	str	r0, [sp, #12]
#endif /* (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT)) */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
    muxing = retMuxing;
    687e:	9b03      	ldr	r3, [sp, #12]
    6880:	9304      	str	r3, [sp, #16]
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */
    pinsValues |= PORT_PCR_MUX(muxing);
    6882:	9b04      	ldr	r3, [sp, #16]
    6884:	021b      	lsls	r3, r3, #8
    6886:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    688a:	9a05      	ldr	r2, [sp, #20]
    688c:	4313      	orrs	r3, r2
    688e:	9305      	str	r3, [sp, #20]

    /* Enter critical region */
    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00();
    6890:	f00e fa2e 	bl	14cf0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00>
    /* Read current digital filter of port */
    digitalFilters = (uint32)(config->portBase->DFER);
    6894:	9b01      	ldr	r3, [sp, #4]
    6896:	681b      	ldr	r3, [r3, #0]
    6898:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
    689c:	9302      	str	r3, [sp, #8]
    digitalFilters &= ~(1UL << (config->pinPortIdx));
    689e:	9b01      	ldr	r3, [sp, #4]
    68a0:	689b      	ldr	r3, [r3, #8]
    68a2:	2201      	movs	r2, #1
    68a4:	fa02 f303 	lsl.w	r3, r2, r3
    68a8:	43db      	mvns	r3, r3
    68aa:	9a02      	ldr	r2, [sp, #8]
    68ac:	4013      	ands	r3, r2
    68ae:	9302      	str	r3, [sp, #8]
    digitalFilters |= (((uint32)(config->digitalFilter?1U:0U)) << (config->pinPortIdx));
    68b0:	9b01      	ldr	r3, [sp, #4]
    68b2:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
    68b6:	2b00      	cmp	r3, #0
    68b8:	d001      	beq.n	68be <Port_Ci_Port_Ip_PinInit+0xba>
    68ba:	2201      	movs	r2, #1
    68bc:	e000      	b.n	68c0 <Port_Ci_Port_Ip_PinInit+0xbc>
    68be:	2200      	movs	r2, #0
    68c0:	9b01      	ldr	r3, [sp, #4]
    68c2:	689b      	ldr	r3, [r3, #8]
    68c4:	fa02 f303 	lsl.w	r3, r2, r3
    68c8:	9a02      	ldr	r2, [sp, #8]
    68ca:	4313      	orrs	r3, r2
    68cc:	9302      	str	r3, [sp, #8]
    /* Write to digital filter enable register */
    config->portBase->DFER = digitalFilters;
    68ce:	9b01      	ldr	r3, [sp, #4]
    68d0:	681b      	ldr	r3, [r3, #0]
    68d2:	9a02      	ldr	r2, [sp, #8]
    68d4:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00();
    68d8:	f00e fa36 	bl	14d48 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00>

    /* Configure initial value for GPIO pin in GPIO mux */
    if (PORT_MUX_AS_GPIO == muxing)
    68dc:	9b04      	ldr	r3, [sp, #16]
    68de:	2b01      	cmp	r3, #1
    68e0:	d16d      	bne.n	69be <Port_Ci_Port_Ip_PinInit+0x1ba>
    {
        /* Check if the direction of the pin is OUTPUT. In this case the driver needs to set the output level too */
        if (PORT_CI_PORT_PIN_OUT == config->direction)
    68e2:	9b01      	ldr	r3, [sp, #4]
    68e4:	695b      	ldr	r3, [r3, #20]
    68e6:	2b02      	cmp	r3, #2
    68e8:	d138      	bne.n	695c <Port_Ci_Port_Ip_PinInit+0x158>
        {
            if ((uint8)1 == config->initValue)
    68ea:	9b01      	ldr	r3, [sp, #4]
    68ec:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
    68f0:	2b01      	cmp	r3, #1
    68f2:	d10f      	bne.n	6914 <Port_Ci_Port_Ip_PinInit+0x110>
            {
                SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01();
    68f4:	f00e fa4e 	bl	14d94 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01>
                config->gpioBase->PSOR |= ((uint32)1 << (config->pinPortIdx));
    68f8:	9b01      	ldr	r3, [sp, #4]
    68fa:	685b      	ldr	r3, [r3, #4]
    68fc:	6859      	ldr	r1, [r3, #4]
    68fe:	9b01      	ldr	r3, [sp, #4]
    6900:	689b      	ldr	r3, [r3, #8]
    6902:	2201      	movs	r2, #1
    6904:	409a      	lsls	r2, r3
    6906:	9b01      	ldr	r3, [sp, #4]
    6908:	685b      	ldr	r3, [r3, #4]
    690a:	430a      	orrs	r2, r1
    690c:	605a      	str	r2, [r3, #4]
                SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01();
    690e:	f00e fa6d 	bl	14dec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01>
    6912:	e013      	b.n	693c <Port_Ci_Port_Ip_PinInit+0x138>
            }
            else if ((uint8)0 == config->initValue)
    6914:	9b01      	ldr	r3, [sp, #4]
    6916:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
    691a:	2b00      	cmp	r3, #0
    691c:	d10e      	bne.n	693c <Port_Ci_Port_Ip_PinInit+0x138>
            {
                SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02();
    691e:	f00e fa8b 	bl	14e38 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02>
                config->gpioBase->PCOR |= ((uint32)1 << (config->pinPortIdx));
    6922:	9b01      	ldr	r3, [sp, #4]
    6924:	685b      	ldr	r3, [r3, #4]
    6926:	6899      	ldr	r1, [r3, #8]
    6928:	9b01      	ldr	r3, [sp, #4]
    692a:	689b      	ldr	r3, [r3, #8]
    692c:	2201      	movs	r2, #1
    692e:	409a      	lsls	r2, r3
    6930:	9b01      	ldr	r3, [sp, #4]
    6932:	685b      	ldr	r3, [r3, #4]
    6934:	430a      	orrs	r2, r1
    6936:	609a      	str	r2, [r3, #8]
                SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02();
    6938:	f00e faaa 	bl	14e90 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02>
            else
            {
                /* No action to be done */
            }
            /* Set the pin direction as output in the PDDR register of GPIO IP */
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03();
    693c:	f00e face 	bl	14edc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03>
            config->gpioBase->PDDR |= (uint32)1 << (config->pinPortIdx);
    6940:	9b01      	ldr	r3, [sp, #4]
    6942:	685b      	ldr	r3, [r3, #4]
    6944:	6959      	ldr	r1, [r3, #20]
    6946:	9b01      	ldr	r3, [sp, #4]
    6948:	689b      	ldr	r3, [r3, #8]
    694a:	2201      	movs	r2, #1
    694c:	409a      	lsls	r2, r3
    694e:	9b01      	ldr	r3, [sp, #4]
    6950:	685b      	ldr	r3, [r3, #4]
    6952:	430a      	orrs	r2, r1
    6954:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03();
    6956:	f00e faed 	bl	14f34 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03>
    695a:	e030      	b.n	69be <Port_Ci_Port_Ip_PinInit+0x1ba>
        }
        /* The direction of pin is INPUT or HIGH Z */
        else
        {
            /* Clear the pin direction as input in the PDDR register of GPIO IP */
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03();
    695c:	f00e fabe 	bl	14edc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03>
            config->gpioBase->PDDR &= ~((uint32)1 << (config->pinPortIdx));
    6960:	9b01      	ldr	r3, [sp, #4]
    6962:	685b      	ldr	r3, [r3, #4]
    6964:	6959      	ldr	r1, [r3, #20]
    6966:	9b01      	ldr	r3, [sp, #4]
    6968:	689b      	ldr	r3, [r3, #8]
    696a:	2201      	movs	r2, #1
    696c:	fa02 f303 	lsl.w	r3, r2, r3
    6970:	43da      	mvns	r2, r3
    6972:	9b01      	ldr	r3, [sp, #4]
    6974:	685b      	ldr	r3, [r3, #4]
    6976:	400a      	ands	r2, r1
    6978:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03();
    697a:	f00e fadb 	bl	14f34 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03>

#ifdef FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04();
    697e:	f00e faff 	bl	14f80 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04>
            config->gpioBase->PIDR &= ~((uint32)1 << (config->pinPortIdx));
    6982:	9b01      	ldr	r3, [sp, #4]
    6984:	685b      	ldr	r3, [r3, #4]
    6986:	6999      	ldr	r1, [r3, #24]
    6988:	9b01      	ldr	r3, [sp, #4]
    698a:	689b      	ldr	r3, [r3, #8]
    698c:	2201      	movs	r2, #1
    698e:	fa02 f303 	lsl.w	r3, r2, r3
    6992:	43da      	mvns	r2, r3
    6994:	9b01      	ldr	r3, [sp, #4]
    6996:	685b      	ldr	r3, [r3, #4]
    6998:	400a      	ands	r2, r1
    699a:	619a      	str	r2, [r3, #24]

            /* Check if the pin is HIGH_Z. In this case the driver needs to disable port input in PIDR register of GPIO IP*/
            if (PORT_CI_PORT_PIN_HIGH_Z == config->direction)
    699c:	9b01      	ldr	r3, [sp, #4]
    699e:	695b      	ldr	r3, [r3, #20]
    69a0:	2b03      	cmp	r3, #3
    69a2:	d10a      	bne.n	69ba <Port_Ci_Port_Ip_PinInit+0x1b6>
            {
                config->gpioBase->PIDR |= ((uint32)1 << (config->pinPortIdx));
    69a4:	9b01      	ldr	r3, [sp, #4]
    69a6:	685b      	ldr	r3, [r3, #4]
    69a8:	6999      	ldr	r1, [r3, #24]
    69aa:	9b01      	ldr	r3, [sp, #4]
    69ac:	689b      	ldr	r3, [r3, #8]
    69ae:	2201      	movs	r2, #1
    69b0:	409a      	lsls	r2, r3
    69b2:	9b01      	ldr	r3, [sp, #4]
    69b4:	685b      	ldr	r3, [r3, #4]
    69b6:	430a      	orrs	r2, r1
    69b8:	619a      	str	r2, [r3, #24]
            }
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04();
    69ba:	f00e fb0d 	bl	14fd8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04>
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER */
        }
    }

    /* Write to Multiplexed Signal Configuration Register */
    config->portBase->PCR[config->pinPortIdx] = pinsValues;
    69be:	9b01      	ldr	r3, [sp, #4]
    69c0:	681b      	ldr	r3, [r3, #0]
    69c2:	9a01      	ldr	r2, [sp, #4]
    69c4:	6892      	ldr	r2, [r2, #8]
    69c6:	9905      	ldr	r1, [sp, #20]
    69c8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    69cc:	bf00      	nop
    69ce:	b007      	add	sp, #28
    69d0:	f85d fb04 	ldr.w	pc, [sp], #4

000069d4 <Port_Ci_Port_Ip_Init>:
Port_Ci_Port_Ip_PortStatusType Port_Ci_Port_Ip_Init
(
    uint32 pinCount,
    const Port_Ci_Port_Ip_PinSettingsConfig config[]
)
{
    69d4:	b500      	push	{lr}
    69d6:	b085      	sub	sp, #20
    69d8:	9001      	str	r0, [sp, #4]
    69da:	9100      	str	r1, [sp, #0]
    uint32 i;

    for (i = 0U; i < pinCount; i++)
    69dc:	2300      	movs	r3, #0
    69de:	9303      	str	r3, [sp, #12]
    69e0:	e00d      	b.n	69fe <Port_Ci_Port_Ip_Init+0x2a>
    {
        Port_Ci_Port_Ip_PinInit(&config[i]);
    69e2:	9a03      	ldr	r2, [sp, #12]
    69e4:	4613      	mov	r3, r2
    69e6:	009b      	lsls	r3, r3, #2
    69e8:	4413      	add	r3, r2
    69ea:	00db      	lsls	r3, r3, #3
    69ec:	461a      	mov	r2, r3
    69ee:	9b00      	ldr	r3, [sp, #0]
    69f0:	4413      	add	r3, r2
    69f2:	4618      	mov	r0, r3
    69f4:	f7ff ff06 	bl	6804 <Port_Ci_Port_Ip_PinInit>
    for (i = 0U; i < pinCount; i++)
    69f8:	9b03      	ldr	r3, [sp, #12]
    69fa:	3301      	adds	r3, #1
    69fc:	9303      	str	r3, [sp, #12]
    69fe:	9a03      	ldr	r2, [sp, #12]
    6a00:	9b01      	ldr	r3, [sp, #4]
    6a02:	429a      	cmp	r2, r3
    6a04:	d3ed      	bcc.n	69e2 <Port_Ci_Port_Ip_Init+0xe>
    }

    return PORT_CI_PORT_SUCCESS;
    6a06:	2300      	movs	r3, #0
}
    6a08:	4618      	mov	r0, r3
    6a0a:	b005      	add	sp, #20
    6a0c:	f85d fb04 	ldr.w	pc, [sp], #4

00006a10 <Port_Ci_Port_Ip_SetMuxModeSel>:
(
    PORT_Type * const base,
    uint32 pin,
    Port_Ci_Port_Ip_PortMux mux
)
{
    6a10:	b500      	push	{lr}
    6a12:	b087      	sub	sp, #28
    6a14:	9003      	str	r0, [sp, #12]
    6a16:	9102      	str	r1, [sp, #8]
    6a18:	9201      	str	r2, [sp, #4]

#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
#if (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT))
    Port_Ci_Port_Ip_PortMux muxing = (Port_Ci_Port_Ip_PortMux)OsIf_Trusted_Call_Return3param(Port_Ci_Port_Ip_ConfigureInterleave,(base),(pin),(mux));
#else
    Port_Ci_Port_Ip_PortMux muxing = Port_Ci_Port_Ip_ConfigureInterleave(base, pin, mux);
    6a1a:	9a01      	ldr	r2, [sp, #4]
    6a1c:	9902      	ldr	r1, [sp, #8]
    6a1e:	9803      	ldr	r0, [sp, #12]
    6a20:	f7ff febc 	bl	679c <Port_Ci_Port_Ip_ConfigureInterleave>
    6a24:	9005      	str	r0, [sp, #20]
#endif /* (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT)) */
#else
    Port_Ci_Port_Ip_PortMux muxing = mux;
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */

    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06();
    6a26:	f00e fb4f 	bl	150c8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06>
    regValue = base->PCR[pin];
    6a2a:	9b03      	ldr	r3, [sp, #12]
    6a2c:	9a02      	ldr	r2, [sp, #8]
    6a2e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6a32:	9304      	str	r3, [sp, #16]
    regValue &= ~(PORT_PCR_MUX_MASK);
    6a34:	9b04      	ldr	r3, [sp, #16]
    6a36:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    6a3a:	9304      	str	r3, [sp, #16]
    regValue |= PORT_PCR_MUX(muxing);
    6a3c:	9b05      	ldr	r3, [sp, #20]
    6a3e:	021b      	lsls	r3, r3, #8
    6a40:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    6a44:	9a04      	ldr	r2, [sp, #16]
    6a46:	4313      	orrs	r3, r2
    6a48:	9304      	str	r3, [sp, #16]
    base->PCR[pin] = regValue;
    6a4a:	9b03      	ldr	r3, [sp, #12]
    6a4c:	9a02      	ldr	r2, [sp, #8]
    6a4e:	9904      	ldr	r1, [sp, #16]
    6a50:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06();
    6a54:	f00e fb64 	bl	15120 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06>
}
    6a58:	bf00      	nop
    6a5a:	b007      	add	sp, #28
    6a5c:	f85d fb04 	ldr.w	pc, [sp], #4

00006a60 <Port_Ci_Port_Ip_EnableDigitalFilter>:
void Port_Ci_Port_Ip_EnableDigitalFilter
(
    PORT_Type * const base,
    uint32 pin
)
{
    6a60:	b500      	push	{lr}
    6a62:	b083      	sub	sp, #12
    6a64:	9001      	str	r0, [sp, #4]
    6a66:	9100      	str	r1, [sp, #0]
    PORT_CI_PORT_DEV_ASSERT((boolean)(pin < PORT_PCR_COUNT));
    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07();
    6a68:	f00e fb80 	bl	1516c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07>
    base->DFER |= ((uint32)1U << pin);
    6a6c:	9b01      	ldr	r3, [sp, #4]
    6a6e:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
    6a72:	2101      	movs	r1, #1
    6a74:	9b00      	ldr	r3, [sp, #0]
    6a76:	fa01 f303 	lsl.w	r3, r1, r3
    6a7a:	431a      	orrs	r2, r3
    6a7c:	9b01      	ldr	r3, [sp, #4]
    6a7e:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07();
    6a82:	f00e fb9f 	bl	151c4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07>
}
    6a86:	bf00      	nop
    6a88:	b003      	add	sp, #12
    6a8a:	f85d fb04 	ldr.w	pc, [sp], #4

00006a8e <Port_Ci_Port_Ip_DisableDigitalFilter>:
void Port_Ci_Port_Ip_DisableDigitalFilter
(
    PORT_Type * const base,
    uint32 pin
)
{
    6a8e:	b500      	push	{lr}
    6a90:	b083      	sub	sp, #12
    6a92:	9001      	str	r0, [sp, #4]
    6a94:	9100      	str	r1, [sp, #0]
    PORT_CI_PORT_DEV_ASSERT((boolean)(pin < PORT_PCR_COUNT));
    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08();
    6a96:	f00e fbbb 	bl	15210 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08>
    base->DFER &= ~((uint32)1U << pin);
    6a9a:	9b01      	ldr	r3, [sp, #4]
    6a9c:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
    6aa0:	2101      	movs	r1, #1
    6aa2:	9b00      	ldr	r3, [sp, #0]
    6aa4:	fa01 f303 	lsl.w	r3, r1, r3
    6aa8:	43db      	mvns	r3, r3
    6aaa:	401a      	ands	r2, r3
    6aac:	9b01      	ldr	r3, [sp, #4]
    6aae:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08();
    6ab2:	f00e fbd9 	bl	15268 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08>
}
    6ab6:	bf00      	nop
    6ab8:	b003      	add	sp, #12
    6aba:	f85d fb04 	ldr.w	pc, [sp], #4

00006abe <Port_Ci_Port_Ip_ConfigDigitalFilter>:
void Port_Ci_Port_Ip_ConfigDigitalFilter
(
    PORT_Type * const base,
    const Port_Ci_Port_Ip_DigitalFilterConfigType * config
)
{
    6abe:	b082      	sub	sp, #8
    6ac0:	9001      	str	r0, [sp, #4]
    6ac2:	9100      	str	r1, [sp, #0]
    PORT_CI_PORT_DEV_ASSERT((boolean)(config->u8Width <= PORT_DFWR_FILT_MASK));
    base->DFCR = PORT_DFCR_CS(config->u8Clock);
    6ac4:	9b00      	ldr	r3, [sp, #0]
    6ac6:	785b      	ldrb	r3, [r3, #1]
    6ac8:	f003 0201 	and.w	r2, r3, #1
    6acc:	9b01      	ldr	r3, [sp, #4]
    6ace:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
    base->DFWR = PORT_DFWR_FILT(config->u8Width);
    6ad2:	9b00      	ldr	r3, [sp, #0]
    6ad4:	789b      	ldrb	r3, [r3, #2]
    6ad6:	f003 021f 	and.w	r2, r3, #31
    6ada:	9b01      	ldr	r3, [sp, #4]
    6adc:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
}
    6ae0:	bf00      	nop
    6ae2:	b002      	add	sp, #8
    6ae4:	4770      	bx	lr

00006ae6 <Port_Ci_Port_Ip_SetGlobalPinControl>:
    PORT_Type * const base,
    uint16 pins,
    uint16 value,
    Port_Ci_Port_Ip_PortGlobalControlPins halfPort
)
{
    6ae6:	b086      	sub	sp, #24
    6ae8:	9003      	str	r0, [sp, #12]
    6aea:	9301      	str	r3, [sp, #4]
    6aec:	460b      	mov	r3, r1
    6aee:	f8ad 300a 	strh.w	r3, [sp, #10]
    6af2:	4613      	mov	r3, r2
    6af4:	f8ad 3008 	strh.w	r3, [sp, #8]
    uint16 mask = 0;
    6af8:	2300      	movs	r3, #0
    6afa:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_PS_MASK;
    6afe:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6b02:	f043 0301 	orr.w	r3, r3, #1
    6b06:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_PE_MASK;
    6b0a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6b0e:	f043 0302 	orr.w	r3, r3, #2
    6b12:	f8ad 3016 	strh.w	r3, [sp, #22]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE)
    mask |= PORT_PCR_SRE_MASK;
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
    mask |= PORT_PCR_PFE_MASK;
    6b16:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6b1a:	f043 0310 	orr.w	r3, r3, #16
    6b1e:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_DSE_MASK;
    6b22:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6b26:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    6b2a:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_MUX_MASK;
    6b2e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6b32:	f443 63e0 	orr.w	r3, r3, #1792	; 0x700
    6b36:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_LK_MASK;
    6b3a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6b3e:	ea6f 4343 	mvn.w	r3, r3, lsl #17
    6b42:	ea6f 4353 	mvn.w	r3, r3, lsr #17
    6b46:	f8ad 3016 	strh.w	r3, [sp, #22]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN)
    mask |= PORT_PCR_ODE_MASK;
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
    mask &= value;
    6b4a:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    6b4e:	f8bd 3008 	ldrh.w	r3, [sp, #8]
    6b52:	4013      	ands	r3, r2
    6b54:	f8ad 3016 	strh.w	r3, [sp, #22]

    switch (halfPort)
    6b58:	9b01      	ldr	r3, [sp, #4]
    6b5a:	2b00      	cmp	r3, #0
    6b5c:	d003      	beq.n	6b66 <Port_Ci_Port_Ip_SetGlobalPinControl+0x80>
    6b5e:	9b01      	ldr	r3, [sp, #4]
    6b60:	2b01      	cmp	r3, #1
    6b62:	d00a      	beq.n	6b7a <Port_Ci_Port_Ip_SetGlobalPinControl+0x94>
            base->GPCHR = (((uint32)pins) << PORT_GPCHR_GPWE_SHIFT) | (uint32)mask;
            break;
        default:
            /* nothing to configure */
            PORT_CI_PORT_DEV_ASSERT((boolean)FALSE);
            break;
    6b64:	e013      	b.n	6b8e <Port_Ci_Port_Ip_SetGlobalPinControl+0xa8>
            base->GPCLR = (((uint32)pins) << PORT_GPCLR_GPWE_SHIFT) | (uint32)mask;
    6b66:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    6b6a:	041a      	lsls	r2, r3, #16
    6b6c:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6b70:	431a      	orrs	r2, r3
    6b72:	9b03      	ldr	r3, [sp, #12]
    6b74:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
            break;
    6b78:	e009      	b.n	6b8e <Port_Ci_Port_Ip_SetGlobalPinControl+0xa8>
            base->GPCHR = (((uint32)pins) << PORT_GPCHR_GPWE_SHIFT) | (uint32)mask;
    6b7a:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    6b7e:	041a      	lsls	r2, r3, #16
    6b80:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6b84:	431a      	orrs	r2, r3
    6b86:	9b03      	ldr	r3, [sp, #12]
    6b88:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
            break;
    6b8c:	bf00      	nop
    }
}
    6b8e:	bf00      	nop
    6b90:	b006      	add	sp, #24
    6b92:	4770      	bx	lr

00006b94 <Port_Ipw_Init_UnusedPins>:
*/
static inline void Port_Ipw_Init_UnusedPins
(
    const Port_ConfigType * pConfigPtr
)
{
    6b94:	b500      	push	{lr}
    6b96:	b087      	sub	sp, #28
    6b98:	9001      	str	r0, [sp, #4]
    uint16 u16PinIndex;
    uint16 u16NumUnusedPins             = (uint16)(pConfigPtr->u16NumUnusedPins);
    6b9a:	9b01      	ldr	r3, [sp, #4]
    6b9c:	885b      	ldrh	r3, [r3, #2]
    6b9e:	f8ad 3014 	strh.w	r3, [sp, #20]
    uint8  u8LocalPDO                   = pConfigPtr->pUnusedPadConfig->u8PDO;
    6ba2:	9b01      	ldr	r3, [sp, #4]
    6ba4:	689b      	ldr	r3, [r3, #8]
    6ba6:	7a1b      	ldrb	r3, [r3, #8]
    6ba8:	f88d 3013 	strb.w	r3, [sp, #19]
    uint32 u32LocalPCR                  = pConfigPtr->pUnusedPadConfig->u32PCR;
    6bac:	9b01      	ldr	r3, [sp, #4]
    6bae:	689b      	ldr	r3, [r3, #8]
    6bb0:	681b      	ldr	r3, [r3, #0]
    6bb2:	9303      	str	r3, [sp, #12]
    Port_PinDirectionType eLocalPDDIR   = pConfigPtr->pUnusedPadConfig->ePadDir;
    6bb4:	9b01      	ldr	r3, [sp, #4]
    6bb6:	689b      	ldr	r3, [r3, #8]
    6bb8:	685b      	ldr	r3, [r3, #4]
    6bba:	9302      	str	r3, [sp, #8]

    /* Initialize All UnUsed pins */
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumUnusedPins; u16PinIndex++)
    6bbc:	2300      	movs	r3, #0
    6bbe:	f8ad 3016 	strh.w	r3, [sp, #22]
    6bc2:	e111      	b.n	6de8 <Port_Ipw_Init_UnusedPins+0x254>
    {
        /* Check if the direction of the pin is OUTPUT. In this case the driver needs to set the output level too */
        if (PORT_PIN_OUT == eLocalPDDIR)
    6bc4:	9b02      	ldr	r3, [sp, #8]
    6bc6:	2b02      	cmp	r3, #2
    6bc8:	d169      	bne.n	6c9e <Port_Ipw_Init_UnusedPins+0x10a>
        {
            /* Set pin to High value */
            if (PORT_PIN_LEVEL_HIGH_U8 == u8LocalPDO)
    6bca:	f89d 3013 	ldrb.w	r3, [sp, #19]
    6bce:	2b01      	cmp	r3, #1
    6bd0:	d11a      	bne.n	6c08 <Port_Ipw_Init_UnusedPins+0x74>
            {
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PSOR = ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    6bd2:	9b01      	ldr	r3, [sp, #4]
    6bd4:	685a      	ldr	r2, [r3, #4]
    6bd6:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6bda:	005b      	lsls	r3, r3, #1
    6bdc:	4413      	add	r3, r2
    6bde:	881b      	ldrh	r3, [r3, #0]
    6be0:	f003 021f 	and.w	r2, r3, #31
    6be4:	9b01      	ldr	r3, [sp, #4]
    6be6:	6859      	ldr	r1, [r3, #4]
    6be8:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6bec:	005b      	lsls	r3, r3, #1
    6bee:	440b      	add	r3, r1
    6bf0:	881b      	ldrh	r3, [r3, #0]
    6bf2:	095b      	lsrs	r3, r3, #5
    6bf4:	b29b      	uxth	r3, r3
    6bf6:	4619      	mov	r1, r3
    6bf8:	4b81      	ldr	r3, [pc, #516]	; (6e00 <Port_Ipw_Init_UnusedPins+0x26c>)
    6bfa:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    6bfe:	2101      	movs	r1, #1
    6c00:	fa01 f202 	lsl.w	r2, r1, r2
    6c04:	605a      	str	r2, [r3, #4]
    6c06:	e01d      	b.n	6c44 <Port_Ipw_Init_UnusedPins+0xb0>
            }
            else if (PORT_PIN_LEVEL_LOW_U8 == u8LocalPDO)
    6c08:	f89d 3013 	ldrb.w	r3, [sp, #19]
    6c0c:	2b00      	cmp	r3, #0
    6c0e:	d119      	bne.n	6c44 <Port_Ipw_Init_UnusedPins+0xb0>
            {
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PCOR = ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    6c10:	9b01      	ldr	r3, [sp, #4]
    6c12:	685a      	ldr	r2, [r3, #4]
    6c14:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6c18:	005b      	lsls	r3, r3, #1
    6c1a:	4413      	add	r3, r2
    6c1c:	881b      	ldrh	r3, [r3, #0]
    6c1e:	f003 021f 	and.w	r2, r3, #31
    6c22:	9b01      	ldr	r3, [sp, #4]
    6c24:	6859      	ldr	r1, [r3, #4]
    6c26:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6c2a:	005b      	lsls	r3, r3, #1
    6c2c:	440b      	add	r3, r1
    6c2e:	881b      	ldrh	r3, [r3, #0]
    6c30:	095b      	lsrs	r3, r3, #5
    6c32:	b29b      	uxth	r3, r3
    6c34:	4619      	mov	r1, r3
    6c36:	4b72      	ldr	r3, [pc, #456]	; (6e00 <Port_Ipw_Init_UnusedPins+0x26c>)
    6c38:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    6c3c:	2101      	movs	r1, #1
    6c3e:	fa01 f202 	lsl.w	r2, r1, r2
    6c42:	609a      	str	r2, [r3, #8]
            }
            else
            {
                /* No action to be done */
            }
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09();
    6c44:	f00e fb36 	bl	152b4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09>
            (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PDDR |= ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    6c48:	9b01      	ldr	r3, [sp, #4]
    6c4a:	685a      	ldr	r2, [r3, #4]
    6c4c:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6c50:	005b      	lsls	r3, r3, #1
    6c52:	4413      	add	r3, r2
    6c54:	881b      	ldrh	r3, [r3, #0]
    6c56:	095b      	lsrs	r3, r3, #5
    6c58:	b29b      	uxth	r3, r3
    6c5a:	461a      	mov	r2, r3
    6c5c:	4b68      	ldr	r3, [pc, #416]	; (6e00 <Port_Ipw_Init_UnusedPins+0x26c>)
    6c5e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6c62:	6959      	ldr	r1, [r3, #20]
    6c64:	9b01      	ldr	r3, [sp, #4]
    6c66:	685a      	ldr	r2, [r3, #4]
    6c68:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6c6c:	005b      	lsls	r3, r3, #1
    6c6e:	4413      	add	r3, r2
    6c70:	881b      	ldrh	r3, [r3, #0]
    6c72:	f003 031f 	and.w	r3, r3, #31
    6c76:	2201      	movs	r2, #1
    6c78:	409a      	lsls	r2, r3
    6c7a:	9b01      	ldr	r3, [sp, #4]
    6c7c:	6858      	ldr	r0, [r3, #4]
    6c7e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6c82:	005b      	lsls	r3, r3, #1
    6c84:	4403      	add	r3, r0
    6c86:	881b      	ldrh	r3, [r3, #0]
    6c88:	095b      	lsrs	r3, r3, #5
    6c8a:	b29b      	uxth	r3, r3
    6c8c:	4618      	mov	r0, r3
    6c8e:	4b5c      	ldr	r3, [pc, #368]	; (6e00 <Port_Ipw_Init_UnusedPins+0x26c>)
    6c90:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    6c94:	430a      	orrs	r2, r1
    6c96:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09();
    6c98:	f00e fb38 	bl	1530c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09>
    6c9c:	e086      	b.n	6dac <Port_Ipw_Init_UnusedPins+0x218>
        }
        /* The direction of pin is INPUT or HIGH Z */
        else
        {
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09();
    6c9e:	f00e fb09 	bl	152b4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09>
            (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PDDR &= ~(((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex])));
    6ca2:	9b01      	ldr	r3, [sp, #4]
    6ca4:	685a      	ldr	r2, [r3, #4]
    6ca6:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6caa:	005b      	lsls	r3, r3, #1
    6cac:	4413      	add	r3, r2
    6cae:	881b      	ldrh	r3, [r3, #0]
    6cb0:	095b      	lsrs	r3, r3, #5
    6cb2:	b29b      	uxth	r3, r3
    6cb4:	461a      	mov	r2, r3
    6cb6:	4b52      	ldr	r3, [pc, #328]	; (6e00 <Port_Ipw_Init_UnusedPins+0x26c>)
    6cb8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6cbc:	6959      	ldr	r1, [r3, #20]
    6cbe:	9b01      	ldr	r3, [sp, #4]
    6cc0:	685a      	ldr	r2, [r3, #4]
    6cc2:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6cc6:	005b      	lsls	r3, r3, #1
    6cc8:	4413      	add	r3, r2
    6cca:	881b      	ldrh	r3, [r3, #0]
    6ccc:	f003 031f 	and.w	r3, r3, #31
    6cd0:	2201      	movs	r2, #1
    6cd2:	fa02 f303 	lsl.w	r3, r2, r3
    6cd6:	43da      	mvns	r2, r3
    6cd8:	9b01      	ldr	r3, [sp, #4]
    6cda:	6858      	ldr	r0, [r3, #4]
    6cdc:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6ce0:	005b      	lsls	r3, r3, #1
    6ce2:	4403      	add	r3, r0
    6ce4:	881b      	ldrh	r3, [r3, #0]
    6ce6:	095b      	lsrs	r3, r3, #5
    6ce8:	b29b      	uxth	r3, r3
    6cea:	4618      	mov	r0, r3
    6cec:	4b44      	ldr	r3, [pc, #272]	; (6e00 <Port_Ipw_Init_UnusedPins+0x26c>)
    6cee:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    6cf2:	400a      	ands	r2, r1
    6cf4:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09();
    6cf6:	f00e fb09 	bl	1530c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09>
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10();
    6cfa:	f00e fb2d 	bl	15358 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10>
            (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PIDR &= ~((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    6cfe:	9b01      	ldr	r3, [sp, #4]
    6d00:	685a      	ldr	r2, [r3, #4]
    6d02:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6d06:	005b      	lsls	r3, r3, #1
    6d08:	4413      	add	r3, r2
    6d0a:	881b      	ldrh	r3, [r3, #0]
    6d0c:	095b      	lsrs	r3, r3, #5
    6d0e:	b29b      	uxth	r3, r3
    6d10:	461a      	mov	r2, r3
    6d12:	4b3b      	ldr	r3, [pc, #236]	; (6e00 <Port_Ipw_Init_UnusedPins+0x26c>)
    6d14:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6d18:	6999      	ldr	r1, [r3, #24]
    6d1a:	9b01      	ldr	r3, [sp, #4]
    6d1c:	685a      	ldr	r2, [r3, #4]
    6d1e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6d22:	005b      	lsls	r3, r3, #1
    6d24:	4413      	add	r3, r2
    6d26:	881b      	ldrh	r3, [r3, #0]
    6d28:	f003 031f 	and.w	r3, r3, #31
    6d2c:	2201      	movs	r2, #1
    6d2e:	fa02 f303 	lsl.w	r3, r2, r3
    6d32:	43da      	mvns	r2, r3
    6d34:	9b01      	ldr	r3, [sp, #4]
    6d36:	6858      	ldr	r0, [r3, #4]
    6d38:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6d3c:	005b      	lsls	r3, r3, #1
    6d3e:	4403      	add	r3, r0
    6d40:	881b      	ldrh	r3, [r3, #0]
    6d42:	095b      	lsrs	r3, r3, #5
    6d44:	b29b      	uxth	r3, r3
    6d46:	4618      	mov	r0, r3
    6d48:	4b2d      	ldr	r3, [pc, #180]	; (6e00 <Port_Ipw_Init_UnusedPins+0x26c>)
    6d4a:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    6d4e:	400a      	ands	r2, r1
    6d50:	619a      	str	r2, [r3, #24]

            /* Check if the pin is HIGH-Z. In this case the driver needs to disable port input in PIDR register of GPIO IP */
            if (PORT_PIN_HIGH_Z == eLocalPDDIR)
    6d52:	9b02      	ldr	r3, [sp, #8]
    6d54:	2b03      	cmp	r3, #3
    6d56:	d127      	bne.n	6da8 <Port_Ipw_Init_UnusedPins+0x214>
            {
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PIDR |= ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    6d58:	9b01      	ldr	r3, [sp, #4]
    6d5a:	685a      	ldr	r2, [r3, #4]
    6d5c:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6d60:	005b      	lsls	r3, r3, #1
    6d62:	4413      	add	r3, r2
    6d64:	881b      	ldrh	r3, [r3, #0]
    6d66:	095b      	lsrs	r3, r3, #5
    6d68:	b29b      	uxth	r3, r3
    6d6a:	461a      	mov	r2, r3
    6d6c:	4b24      	ldr	r3, [pc, #144]	; (6e00 <Port_Ipw_Init_UnusedPins+0x26c>)
    6d6e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6d72:	6999      	ldr	r1, [r3, #24]
    6d74:	9b01      	ldr	r3, [sp, #4]
    6d76:	685a      	ldr	r2, [r3, #4]
    6d78:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6d7c:	005b      	lsls	r3, r3, #1
    6d7e:	4413      	add	r3, r2
    6d80:	881b      	ldrh	r3, [r3, #0]
    6d82:	f003 031f 	and.w	r3, r3, #31
    6d86:	2201      	movs	r2, #1
    6d88:	409a      	lsls	r2, r3
    6d8a:	9b01      	ldr	r3, [sp, #4]
    6d8c:	6858      	ldr	r0, [r3, #4]
    6d8e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6d92:	005b      	lsls	r3, r3, #1
    6d94:	4403      	add	r3, r0
    6d96:	881b      	ldrh	r3, [r3, #0]
    6d98:	095b      	lsrs	r3, r3, #5
    6d9a:	b29b      	uxth	r3, r3
    6d9c:	4618      	mov	r0, r3
    6d9e:	4b18      	ldr	r3, [pc, #96]	; (6e00 <Port_Ipw_Init_UnusedPins+0x26c>)
    6da0:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    6da4:	430a      	orrs	r2, r1
    6da6:	619a      	str	r2, [r3, #24]
            }
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10();
    6da8:	f00e fb02 	bl	153b0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10>
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER */
        }
        /* Write PCR configuration from Configuration tool */
        (Port_au32PortCiPortBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PCR[GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex])] = u32LocalPCR;
    6dac:	9b01      	ldr	r3, [sp, #4]
    6dae:	685a      	ldr	r2, [r3, #4]
    6db0:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6db4:	005b      	lsls	r3, r3, #1
    6db6:	4413      	add	r3, r2
    6db8:	881b      	ldrh	r3, [r3, #0]
    6dba:	095b      	lsrs	r3, r3, #5
    6dbc:	b29b      	uxth	r3, r3
    6dbe:	461a      	mov	r2, r3
    6dc0:	4b10      	ldr	r3, [pc, #64]	; (6e04 <Port_Ipw_Init_UnusedPins+0x270>)
    6dc2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6dc6:	9a01      	ldr	r2, [sp, #4]
    6dc8:	6851      	ldr	r1, [r2, #4]
    6dca:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    6dce:	0052      	lsls	r2, r2, #1
    6dd0:	440a      	add	r2, r1
    6dd2:	8812      	ldrh	r2, [r2, #0]
    6dd4:	f002 021f 	and.w	r2, r2, #31
    6dd8:	9903      	ldr	r1, [sp, #12]
    6dda:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumUnusedPins; u16PinIndex++)
    6dde:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6de2:	3301      	adds	r3, #1
    6de4:	f8ad 3016 	strh.w	r3, [sp, #22]
    6de8:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    6dec:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    6df0:	429a      	cmp	r2, r3
    6df2:	f4ff aee7 	bcc.w	6bc4 <Port_Ipw_Init_UnusedPins+0x30>
    }
}
    6df6:	bf00      	nop
    6df8:	bf00      	nop
    6dfa:	b007      	add	sp, #28
    6dfc:	f85d fb04 	ldr.w	pc, [sp], #4
    6e00:	000186a8 	.word	0x000186a8
    6e04:	00018694 	.word	0x00018694

00006e08 <Port_Ipw_Init>:
*/
void Port_Ipw_Init
(
    const Port_ConfigType * pConfigPtr
)
{
    6e08:	b500      	push	{lr}
    6e0a:	b085      	sub	sp, #20
    6e0c:	9001      	str	r0, [sp, #4]
    uint16 u16PinIndex;

    uint8 u8NumDigFilterPorts          = (uint8)(pConfigPtr->u8NumDigitalFilterPorts);
    6e0e:	9b01      	ldr	r3, [sp, #4]
    6e10:	7c1b      	ldrb	r3, [r3, #16]
    6e12:	f88d 300d 	strb.w	r3, [sp, #13]
    uint8 u8Port;

    /* Initialize all configured digital filter ports. Use u16PinIndex variable as counter, even if we loop on a uint8 variable */
    for (u16PinIndex = (uint16)0U; u16PinIndex < (uint16)u8NumDigFilterPorts; u16PinIndex++)
    6e16:	2300      	movs	r3, #0
    6e18:	f8ad 300e 	strh.w	r3, [sp, #14]
    6e1c:	e035      	b.n	6e8a <Port_Ipw_Init+0x82>
    {
        u8Port = pConfigPtr->pDigitalFilterConfig[u16PinIndex].u8Port;
    6e1e:	9b01      	ldr	r3, [sp, #4]
    6e20:	695a      	ldr	r2, [r3, #20]
    6e22:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    6e26:	00db      	lsls	r3, r3, #3
    6e28:	4413      	add	r3, r2
    6e2a:	781b      	ldrb	r3, [r3, #0]
    6e2c:	f88d 300c 	strb.w	r3, [sp, #12]

        /* Set digital filter clock and width for the current port */
        Port_Ci_Port_Ip_ConfigDigitalFilter(Port_au32PortCiPortBaseAddr[u8Port], &(pConfigPtr->pDigitalFilterConfig[u16PinIndex]));
    6e30:	f89d 300c 	ldrb.w	r3, [sp, #12]
    6e34:	4a29      	ldr	r2, [pc, #164]	; (6edc <Port_Ipw_Init+0xd4>)
    6e36:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    6e3a:	9b01      	ldr	r3, [sp, #4]
    6e3c:	695a      	ldr	r2, [r3, #20]
    6e3e:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    6e42:	00db      	lsls	r3, r3, #3
    6e44:	4413      	add	r3, r2
    6e46:	4619      	mov	r1, r3
    6e48:	f7ff fe39 	bl	6abe <Port_Ci_Port_Ip_ConfigDigitalFilter>
        /* Enable digital filter for the pins selected by the user for the current port */
        SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15();
    6e4c:	f00e fc1e 	bl	1568c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15>
        (Port_au32PortCiPortBaseAddr[u8Port])->DFER |= (uint32)(pConfigPtr->pDigitalFilterConfig[u16PinIndex].u32PinMask);
    6e50:	f89d 300c 	ldrb.w	r3, [sp, #12]
    6e54:	4a21      	ldr	r2, [pc, #132]	; (6edc <Port_Ipw_Init+0xd4>)
    6e56:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6e5a:	f8d3 10c0 	ldr.w	r1, [r3, #192]	; 0xc0
    6e5e:	9b01      	ldr	r3, [sp, #4]
    6e60:	695a      	ldr	r2, [r3, #20]
    6e62:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    6e66:	00db      	lsls	r3, r3, #3
    6e68:	4413      	add	r3, r2
    6e6a:	685a      	ldr	r2, [r3, #4]
    6e6c:	f89d 300c 	ldrb.w	r3, [sp, #12]
    6e70:	481a      	ldr	r0, [pc, #104]	; (6edc <Port_Ipw_Init+0xd4>)
    6e72:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    6e76:	430a      	orrs	r2, r1
    6e78:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
        SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15();
    6e7c:	f00e fc32 	bl	156e4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15>
    for (u16PinIndex = (uint16)0U; u16PinIndex < (uint16)u8NumDigFilterPorts; u16PinIndex++)
    6e80:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    6e84:	3301      	adds	r3, #1
    6e86:	f8ad 300e 	strh.w	r3, [sp, #14]
    6e8a:	f89d 300d 	ldrb.w	r3, [sp, #13]
    6e8e:	b29b      	uxth	r3, r3
    6e90:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    6e94:	429a      	cmp	r2, r3
    6e96:	d3c2      	bcc.n	6e1e <Port_Ipw_Init+0x16>
    }

    (void)Port_Ci_Port_Ip_Init(NUM_OF_CONFIGURED_PINS, pConfigPtr->IpConfigPtr);
    6e98:	9b01      	ldr	r3, [sp, #4]
    6e9a:	6a1b      	ldr	r3, [r3, #32]
    6e9c:	4619      	mov	r1, r3
    6e9e:	2014      	movs	r0, #20
    6ea0:	f7ff fd98 	bl	69d4 <Port_Ci_Port_Ip_Init>

    /* Initialize All Unused Port Pins */
    Port_Ipw_Init_UnusedPins(pConfigPtr);
    6ea4:	9801      	ldr	r0, [sp, #4]
    6ea6:	f7ff fe75 	bl	6b94 <Port_Ipw_Init_UnusedPins>
     (defined(PORT_SET_2_PINS_DIRECTION_API) && (STD_ON == PORT_SET_2_PINS_DIRECTION_API))  \
    )
    /* Port_Ipw_au16GpioDirChangeability is only used by Port_Ci_Port_Ip_SetPinDirection, Port_Ci_Port_Ip_Set2PinsDirection
       and Port_Ci_Port_Ip_SetPinMode functions */
    /* Initialize the Array with Change Direction Flags for GPIO */
    for (u16PinIndex = (uint16)0U; u16PinIndex < PAD_16BLOCK_NO_U8; u16PinIndex++)
    6eaa:	2300      	movs	r3, #0
    6eac:	f8ad 300e 	strh.w	r3, [sp, #14]
    6eb0:	e00a      	b.n	6ec8 <Port_Ipw_Init+0xc0>
    {
        Port_Ipw_au16GpioDirChangeability[u16PinIndex] = (uint16)0UL;
    6eb2:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    6eb6:	4a0a      	ldr	r2, [pc, #40]	; (6ee0 <Port_Ipw_Init+0xd8>)
    6eb8:	2100      	movs	r1, #0
    6eba:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
    for (u16PinIndex = (uint16)0U; u16PinIndex < PAD_16BLOCK_NO_U8; u16PinIndex++)
    6ebe:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    6ec2:	3301      	adds	r3, #1
    6ec4:	f8ad 300e 	strh.w	r3, [sp, #14]
    6ec8:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    6ecc:	2b09      	cmp	r3, #9
    6ece:	d9f0      	bls.n	6eb2 <Port_Ipw_Init+0xaa>
#endif /* ((STD_ON == PORT_SET_PIN_DIRECTION_API) || (STD_ON == PORT_SET_PIN_MODE_API) ||         \
           (defined(PORT_SET_2_PINS_DIRECTION_API) && (STD_ON == PORT_SET_2_PINS_DIRECTION_API))  \
          ) */
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */

}
    6ed0:	bf00      	nop
    6ed2:	bf00      	nop
    6ed4:	b005      	add	sp, #20
    6ed6:	f85d fb04 	ldr.w	pc, [sp], #4
    6eda:	bf00      	nop
    6edc:	00018694 	.word	0x00018694
    6ee0:	1fff8cf0 	.word	0x1fff8cf0

00006ee4 <Port_Ipw_SetPinDirection>:
(
    Port_PinType            PinIndex,
    Port_PinDirectionType   eDirection,
    const Port_ConfigType * pConfigPtr
)
{
    6ee4:	b500      	push	{lr}
    6ee6:	b087      	sub	sp, #28
    6ee8:	9003      	str	r0, [sp, #12]
    6eea:	9102      	str	r1, [sp, #8]
    6eec:	9201      	str	r2, [sp, #4]
    /* Point to the Port Pin PCR register address */
    uint16 Pin = pConfigPtr->pUsedPadConfig[PinIndex].Pin;
    6eee:	9b01      	ldr	r3, [sp, #4]
    6ef0:	68d9      	ldr	r1, [r3, #12]
    6ef2:	9a03      	ldr	r2, [sp, #12]
    6ef4:	4613      	mov	r3, r2
    6ef6:	009b      	lsls	r3, r3, #2
    6ef8:	4413      	add	r3, r2
    6efa:	009b      	lsls	r3, r3, #2
    6efc:	440b      	add	r3, r1
    6efe:	881b      	ldrh	r3, [r3, #0]
    6f00:	f8ad 3014 	strh.w	r3, [sp, #20]
    /* Return value */
    Std_ReturnType PinDirError             = (Std_ReturnType)E_OK;
    6f04:	2300      	movs	r3, #0
    6f06:	f88d 3017 	strb.w	r3, [sp, #23]

#if (STD_ON == PORT_DEV_ERROR_DETECT)
    uint8 CoreId;
    CoreId = (uint8)Port_GetCoreID();
    6f0a:	2300      	movs	r3, #0
    6f0c:	f88d 3013 	strb.w	r3, [sp, #19]

    if ((PinIndex >= (Port_PinType)pConfigPtr->u16NumPins))
    6f10:	9b01      	ldr	r3, [sp, #4]
    6f12:	881b      	ldrh	r3, [r3, #0]
    6f14:	461a      	mov	r2, r3
    6f16:	9b03      	ldr	r3, [sp, #12]
    6f18:	4293      	cmp	r3, r2
    6f1a:	d306      	bcc.n	6f2a <Port_Ipw_SetPinDirection+0x46>
    {
        (void)Det_ReportError((uint16)PORT_MODULE_ID, (uint8)PORT_INSTANCE_ID, (uint8)PORT_SETPINDIRECTION_ID, (uint8)PORT_E_PARAM_PIN);
    6f1c:	230a      	movs	r3, #10
    6f1e:	2201      	movs	r2, #1
    6f20:	2100      	movs	r1, #0
    6f22:	207c      	movs	r0, #124	; 0x7c
    6f24:	f00f ff36 	bl	16d94 <Det_ReportError>
    6f28:	e0c9      	b.n	70be <Port_Ipw_SetPinDirection+0x1da>
    }
    /* Check port pin validity */
    else if ((uint32)1 != (((pConfigPtr->pau32Port_PinToPartitionMap[PinIndex]) & ((uint32)1 << CoreId)) >> CoreId))
    6f2a:	9b01      	ldr	r3, [sp, #4]
    6f2c:	699a      	ldr	r2, [r3, #24]
    6f2e:	9b03      	ldr	r3, [sp, #12]
    6f30:	009b      	lsls	r3, r3, #2
    6f32:	4413      	add	r3, r2
    6f34:	681a      	ldr	r2, [r3, #0]
    6f36:	f89d 3013 	ldrb.w	r3, [sp, #19]
    6f3a:	2101      	movs	r1, #1
    6f3c:	fa01 f303 	lsl.w	r3, r1, r3
    6f40:	401a      	ands	r2, r3
    6f42:	f89d 3013 	ldrb.w	r3, [sp, #19]
    6f46:	fa22 f303 	lsr.w	r3, r2, r3
    6f4a:	2b01      	cmp	r3, #1
    6f4c:	d006      	beq.n	6f5c <Port_Ipw_SetPinDirection+0x78>
    {
        (void)Det_ReportError((uint16)PORT_MODULE_ID, (uint8)PORT_INSTANCE_ID, (uint8)PORT_SETPINDIRECTION_ID, (uint8)PORT_E_PARAM_CONFIG);
    6f4e:	23f0      	movs	r3, #240	; 0xf0
    6f50:	2201      	movs	r2, #1
    6f52:	2100      	movs	r1, #0
    6f54:	207c      	movs	r0, #124	; 0x7c
    6f56:	f00f ff1d 	bl	16d94 <Det_ReportError>
    6f5a:	e0b0      	b.n	70be <Port_Ipw_SetPinDirection+0x1da>
    }
    else
    {
        /* Bit Offset and Table value for change direction flag word */
        uint8 u8PinDescBitOffset       = (uint8)(Pin & PORT_CI_BIT_OFFSET_MASK_U8);
    6f5c:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    6f60:	b2db      	uxtb	r3, r3
    6f62:	f003 030f 	and.w	r3, r3, #15
    6f66:	f88d 3012 	strb.w	r3, [sp, #18]
        /* Number of block 16 */
        uint16 u16PinChangeDirFlagWord  = Port_Ipw_au16GpioDirChangeability[(uint8)(Pin >> 4)];
    6f6a:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    6f6e:	091b      	lsrs	r3, r3, #4
    6f70:	b29b      	uxth	r3, r3
    6f72:	b2db      	uxtb	r3, r3
    6f74:	461a      	mov	r2, r3
    6f76:	4b55      	ldr	r3, [pc, #340]	; (70cc <Port_Ipw_SetPinDirection+0x1e8>)
    6f78:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    6f7c:	f8ad 3010 	strh.w	r3, [sp, #16]

        /* Check the Direction changeability option */
        if ((TRUE == pConfigPtr->pUsedPadConfig[PinIndex].bDC) || ((uint16)0 != (u16PinChangeDirFlagWord & (uint16)(1UL << u8PinDescBitOffset))))
    6f80:	9b01      	ldr	r3, [sp, #4]
    6f82:	68d9      	ldr	r1, [r3, #12]
    6f84:	9a03      	ldr	r2, [sp, #12]
    6f86:	4613      	mov	r3, r2
    6f88:	009b      	lsls	r3, r3, #2
    6f8a:	4413      	add	r3, r2
    6f8c:	009b      	lsls	r3, r3, #2
    6f8e:	440b      	add	r3, r1
    6f90:	7c5b      	ldrb	r3, [r3, #17]
    6f92:	2b00      	cmp	r3, #0
    6f94:	d10c      	bne.n	6fb0 <Port_Ipw_SetPinDirection+0xcc>
    6f96:	f89d 3012 	ldrb.w	r3, [sp, #18]
    6f9a:	2201      	movs	r2, #1
    6f9c:	fa02 f303 	lsl.w	r3, r2, r3
    6fa0:	b29a      	uxth	r2, r3
    6fa2:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    6fa6:	4013      	ands	r3, r2
    6fa8:	b29b      	uxth	r3, r3
    6faa:	2b00      	cmp	r3, #0
    6fac:	f000 8082 	beq.w	70b4 <Port_Ipw_SetPinDirection+0x1d0>
        {
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */
            /* Configures Port Pin as Output */
            if (PORT_PIN_OUT == eDirection)
    6fb0:	9b02      	ldr	r3, [sp, #8]
    6fb2:	2b02      	cmp	r3, #2
    6fb4:	d11d      	bne.n	6ff2 <Port_Ipw_SetPinDirection+0x10e>
            {
                SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16();
    6fb6:	f00e fbbb 	bl	15730 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16>
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(Pin)])->PDDR |= (uint32)(1UL << GPIO_CHANNEL_U32(Pin));
    6fba:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    6fbe:	095b      	lsrs	r3, r3, #5
    6fc0:	b29b      	uxth	r3, r3
    6fc2:	461a      	mov	r2, r3
    6fc4:	4b42      	ldr	r3, [pc, #264]	; (70d0 <Port_Ipw_SetPinDirection+0x1ec>)
    6fc6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6fca:	6959      	ldr	r1, [r3, #20]
    6fcc:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    6fd0:	f003 031f 	and.w	r3, r3, #31
    6fd4:	2201      	movs	r2, #1
    6fd6:	409a      	lsls	r2, r3
    6fd8:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    6fdc:	095b      	lsrs	r3, r3, #5
    6fde:	b29b      	uxth	r3, r3
    6fe0:	4618      	mov	r0, r3
    6fe2:	4b3b      	ldr	r3, [pc, #236]	; (70d0 <Port_Ipw_SetPinDirection+0x1ec>)
    6fe4:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    6fe8:	430a      	orrs	r2, r1
    6fea:	615a      	str	r2, [r3, #20]
                SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16();
    6fec:	f00e fbcc 	bl	15788 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16>
            if (PORT_PIN_OUT == eDirection)
    6ff0:	e064      	b.n	70bc <Port_Ipw_SetPinDirection+0x1d8>
            }
            /* Configures Port Pin as Input or High-Z*/
            else if ((PORT_PIN_IN == eDirection) || (PORT_PIN_HIGH_Z == eDirection))
    6ff2:	9b02      	ldr	r3, [sp, #8]
    6ff4:	2b01      	cmp	r3, #1
    6ff6:	d002      	beq.n	6ffe <Port_Ipw_SetPinDirection+0x11a>
    6ff8:	9b02      	ldr	r3, [sp, #8]
    6ffa:	2b03      	cmp	r3, #3
    6ffc:	d15e      	bne.n	70bc <Port_Ipw_SetPinDirection+0x1d8>
            {
                SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16();
    6ffe:	f00e fb97 	bl	15730 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16>
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(Pin)])->PDDR &= ~((uint32)(1UL << GPIO_CHANNEL_U32(Pin)));
    7002:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    7006:	095b      	lsrs	r3, r3, #5
    7008:	b29b      	uxth	r3, r3
    700a:	461a      	mov	r2, r3
    700c:	4b30      	ldr	r3, [pc, #192]	; (70d0 <Port_Ipw_SetPinDirection+0x1ec>)
    700e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    7012:	6959      	ldr	r1, [r3, #20]
    7014:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    7018:	f003 031f 	and.w	r3, r3, #31
    701c:	2201      	movs	r2, #1
    701e:	fa02 f303 	lsl.w	r3, r2, r3
    7022:	43da      	mvns	r2, r3
    7024:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    7028:	095b      	lsrs	r3, r3, #5
    702a:	b29b      	uxth	r3, r3
    702c:	4618      	mov	r0, r3
    702e:	4b28      	ldr	r3, [pc, #160]	; (70d0 <Port_Ipw_SetPinDirection+0x1ec>)
    7030:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    7034:	400a      	ands	r2, r1
    7036:	615a      	str	r2, [r3, #20]
                SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16();
    7038:	f00e fba6 	bl	15788 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16>

#ifdef FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER
                SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17();
    703c:	f00e fbca 	bl	157d4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17>
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(Pin)])->PIDR &= ~((uint32)(1UL << GPIO_CHANNEL_U32(Pin)));
    7040:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    7044:	095b      	lsrs	r3, r3, #5
    7046:	b29b      	uxth	r3, r3
    7048:	461a      	mov	r2, r3
    704a:	4b21      	ldr	r3, [pc, #132]	; (70d0 <Port_Ipw_SetPinDirection+0x1ec>)
    704c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    7050:	6999      	ldr	r1, [r3, #24]
    7052:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    7056:	f003 031f 	and.w	r3, r3, #31
    705a:	2201      	movs	r2, #1
    705c:	fa02 f303 	lsl.w	r3, r2, r3
    7060:	43da      	mvns	r2, r3
    7062:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    7066:	095b      	lsrs	r3, r3, #5
    7068:	b29b      	uxth	r3, r3
    706a:	4618      	mov	r0, r3
    706c:	4b18      	ldr	r3, [pc, #96]	; (70d0 <Port_Ipw_SetPinDirection+0x1ec>)
    706e:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    7072:	400a      	ands	r2, r1
    7074:	619a      	str	r2, [r3, #24]

                /* Check if the pin is HIGH-Z. In this case the driver needs to disable port input in PIDR register of GPIO IP*/
                if (PORT_PIN_HIGH_Z == eDirection)
    7076:	9b02      	ldr	r3, [sp, #8]
    7078:	2b03      	cmp	r3, #3
    707a:	d118      	bne.n	70ae <Port_Ipw_SetPinDirection+0x1ca>
                {
                    (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(Pin)])->PIDR |= ((uint32)(1UL << GPIO_CHANNEL_U32(Pin)));
    707c:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    7080:	095b      	lsrs	r3, r3, #5
    7082:	b29b      	uxth	r3, r3
    7084:	461a      	mov	r2, r3
    7086:	4b12      	ldr	r3, [pc, #72]	; (70d0 <Port_Ipw_SetPinDirection+0x1ec>)
    7088:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    708c:	6999      	ldr	r1, [r3, #24]
    708e:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    7092:	f003 031f 	and.w	r3, r3, #31
    7096:	2201      	movs	r2, #1
    7098:	409a      	lsls	r2, r3
    709a:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    709e:	095b      	lsrs	r3, r3, #5
    70a0:	b29b      	uxth	r3, r3
    70a2:	4618      	mov	r0, r3
    70a4:	4b0a      	ldr	r3, [pc, #40]	; (70d0 <Port_Ipw_SetPinDirection+0x1ec>)
    70a6:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    70aa:	430a      	orrs	r2, r1
    70ac:	619a      	str	r2, [r3, #24]
                }
                SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17();
    70ae:	f00e fbbd 	bl	1582c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17>
            if (PORT_PIN_OUT == eDirection)
    70b2:	e003      	b.n	70bc <Port_Ipw_SetPinDirection+0x1d8>
#if (STD_ON == PORT_DEV_ERROR_DETECT)
        }
        /* Direction changeability is NOT supported */
        else
        {
            PinDirError = (Std_ReturnType)E_NOT_OK;
    70b4:	2301      	movs	r3, #1
    70b6:	f88d 3017 	strb.w	r3, [sp, #23]
    70ba:	e000      	b.n	70be <Port_Ipw_SetPinDirection+0x1da>
            if (PORT_PIN_OUT == eDirection)
    70bc:	bf00      	nop
        }
    }
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */

    return PinDirError;
    70be:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    70c2:	4618      	mov	r0, r3
    70c4:	b007      	add	sp, #28
    70c6:	f85d fb04 	ldr.w	pc, [sp], #4
    70ca:	bf00      	nop
    70cc:	1fff8cf0 	.word	0x1fff8cf0
    70d0:	000186a8 	.word	0x000186a8

000070d4 <Port_Ipw_SetPinMode>:
(
    Port_PinType PinIndex,
    Port_PinModeType PinMode,
    const Port_ConfigType * pConfigPtr
)
{
    70d4:	b500      	push	{lr}
    70d6:	b08b      	sub	sp, #44	; 0x2c
    70d8:	9003      	str	r0, [sp, #12]
    70da:	460b      	mov	r3, r1
    70dc:	9201      	str	r2, [sp, #4]
    70de:	f88d 300b 	strb.w	r3, [sp, #11]
    Std_ReturnType PinModeError             = (Std_ReturnType)0UL;
    70e2:	2300      	movs	r3, #0
    70e4:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    uint16 PinPad                           = pConfigPtr->pUsedPadConfig[PinIndex].Pin;
    70e8:	9b01      	ldr	r3, [sp, #4]
    70ea:	68d9      	ldr	r1, [r3, #12]
    70ec:	9a03      	ldr	r2, [sp, #12]
    70ee:	4613      	mov	r3, r2
    70f0:	009b      	lsls	r3, r3, #2
    70f2:	4413      	add	r3, r2
    70f4:	009b      	lsls	r3, r3, #2
    70f6:	440b      	add	r3, r1
    70f8:	881b      	ldrh	r3, [r3, #0]
    70fa:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    Port_PinModeType PinCfgRegValue         = (Port_PinModeType)PinMode;
    70fe:	f89d 300b 	ldrb.w	r3, [sp, #11]
    7102:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    uint16 u16PinDescBitOffset;
    /* Variable used to clear and updated PCR register */
    uint32 u32LocalPCR;
#if (STD_ON == PORT_DEV_ERROR_DETECT)
    uint8 CoreId;
    CoreId = (uint8)Port_GetCoreID();
    7106:	2300      	movs	r3, #0
    7108:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22

    if ((PinIndex >= (Port_PinType)pConfigPtr->u16NumPins))
    710c:	9b01      	ldr	r3, [sp, #4]
    710e:	881b      	ldrh	r3, [r3, #0]
    7110:	461a      	mov	r2, r3
    7112:	9b03      	ldr	r3, [sp, #12]
    7114:	4293      	cmp	r3, r2
    7116:	d306      	bcc.n	7126 <Port_Ipw_SetPinMode+0x52>
    {
        (void)Det_ReportError((uint16)PORT_MODULE_ID, (uint8)PORT_INSTANCE_ID, (uint8)PORT_SETPINMODE_ID, (uint8)PORT_E_PARAM_PIN);
    7118:	230a      	movs	r3, #10
    711a:	2204      	movs	r2, #4
    711c:	2100      	movs	r1, #0
    711e:	207c      	movs	r0, #124	; 0x7c
    7120:	f00f fe38 	bl	16d94 <Det_ReportError>
    7124:	e0b3      	b.n	728e <Port_Ipw_SetPinMode+0x1ba>
    }
    /* Check if this function was called with wrong core */
    else if ((uint32)1 != (((pConfigPtr->pau32Port_PinToPartitionMap[PinIndex]) & ((uint32)1 << CoreId)) >> CoreId))
    7126:	9b01      	ldr	r3, [sp, #4]
    7128:	699a      	ldr	r2, [r3, #24]
    712a:	9b03      	ldr	r3, [sp, #12]
    712c:	009b      	lsls	r3, r3, #2
    712e:	4413      	add	r3, r2
    7130:	681a      	ldr	r2, [r3, #0]
    7132:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
    7136:	2101      	movs	r1, #1
    7138:	fa01 f303 	lsl.w	r3, r1, r3
    713c:	401a      	ands	r2, r3
    713e:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
    7142:	fa22 f303 	lsr.w	r3, r2, r3
    7146:	2b01      	cmp	r3, #1
    7148:	d006      	beq.n	7158 <Port_Ipw_SetPinMode+0x84>
    {
        (void)Det_ReportError((uint16)PORT_MODULE_ID, (uint8)PORT_INSTANCE_ID, (uint8)PORT_SETPINMODE_ID, (uint8)PORT_E_PARAM_CONFIG);
    714a:	23f0      	movs	r3, #240	; 0xf0
    714c:	2204      	movs	r2, #4
    714e:	2100      	movs	r1, #0
    7150:	207c      	movs	r0, #124	; 0x7c
    7152:	f00f fe1f 	bl	16d94 <Det_ReportError>
    7156:	e09a      	b.n	728e <Port_Ipw_SetPinMode+0x1ba>
    }
    /* Check port pin mode Unchangeable */
    else if (FALSE ==  pConfigPtr->pUsedPadConfig[PinIndex].bMC)
    7158:	9b01      	ldr	r3, [sp, #4]
    715a:	68d9      	ldr	r1, [r3, #12]
    715c:	9a03      	ldr	r2, [sp, #12]
    715e:	4613      	mov	r3, r2
    7160:	009b      	lsls	r3, r3, #2
    7162:	4413      	add	r3, r2
    7164:	009b      	lsls	r3, r3, #2
    7166:	440b      	add	r3, r1
    7168:	7c9b      	ldrb	r3, [r3, #18]
    716a:	f083 0301 	eor.w	r3, r3, #1
    716e:	b2db      	uxtb	r3, r3
    7170:	2b00      	cmp	r3, #0
    7172:	d006      	beq.n	7182 <Port_Ipw_SetPinMode+0xae>
    {
        (void)Det_ReportError((uint16)PORT_MODULE_ID, (uint8)PORT_INSTANCE_ID, (uint8)PORT_SETPINMODE_ID, (uint8)PORT_E_MODE_UNCHANGEABLE);
    7174:	230e      	movs	r3, #14
    7176:	2204      	movs	r2, #4
    7178:	2100      	movs	r1, #0
    717a:	207c      	movs	r0, #124	; 0x7c
    717c:	f00f fe0a 	bl	16d94 <Det_ReportError>
    7180:	e085      	b.n	728e <Port_Ipw_SetPinMode+0x1ba>
    }
    else
    {
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */

        if (PAD_MODE_OPTIONS_U8 <= PinMode)
    7182:	f89d 300b 	ldrb.w	r3, [sp, #11]
    7186:	2b07      	cmp	r3, #7
    7188:	d903      	bls.n	7192 <Port_Ipw_SetPinMode+0xbe>
        {
            PinModeError = PORT_E_PARAM_INVALID_MODE;
    718a:	230d      	movs	r3, #13
    718c:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    7190:	e07d      	b.n	728e <Port_Ipw_SetPinMode+0x1ba>
        }
        else
        {
            Port_PinDirectionType ePadDirection = PORT_PIN_DISABLED;
    7192:	2300      	movs	r3, #0
    7194:	9307      	str	r3, [sp, #28]

            /* Bit offset of Pin index inside the pin description matrix */
            u16PinDescBitOffset = PinPad & PORT_MODE_BIT_OFFSET_MASK_U8;
    7196:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    719a:	f003 030f 	and.w	r3, r3, #15
    719e:	f8ad 301a 	strh.w	r3, [sp, #26]
            /* Selected word inside the pin description matrix */
            u16PinDescWord = (uint16)Port_au16PinDescription[(uint8)PinMode][PinPad >> 4U];
    71a2:	f89d 200b 	ldrb.w	r2, [sp, #11]
    71a6:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    71aa:	091b      	lsrs	r3, r3, #4
    71ac:	b29b      	uxth	r3, r3
    71ae:	4618      	mov	r0, r3
    71b0:	493a      	ldr	r1, [pc, #232]	; (729c <Port_Ipw_SetPinMode+0x1c8>)
    71b2:	4613      	mov	r3, r2
    71b4:	009b      	lsls	r3, r3, #2
    71b6:	4413      	add	r3, r2
    71b8:	005b      	lsls	r3, r3, #1
    71ba:	4403      	add	r3, r0
    71bc:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
    71c0:	f8ad 3018 	strh.w	r3, [sp, #24]

            /* Check if desired mode is valid for selected pin */
            if ((u16PinDescWord & ((uint16)1UL<<u16PinDescBitOffset)) != (uint16)0U)
    71c4:	f8bd 2018 	ldrh.w	r2, [sp, #24]
    71c8:	f8bd 301a 	ldrh.w	r3, [sp, #26]
    71cc:	fa42 f303 	asr.w	r3, r2, r3
    71d0:	f003 0301 	and.w	r3, r3, #1
    71d4:	2b00      	cmp	r3, #0
    71d6:	d057      	beq.n	7288 <Port_Ipw_SetPinMode+0x1b4>
            {
                switch(PinMode)
    71d8:	f89d 300b 	ldrb.w	r3, [sp, #11]
    71dc:	2b01      	cmp	r3, #1
    71de:	d11f      	bne.n	7220 <Port_Ipw_SetPinMode+0x14c>
                {
                    case PORT_GPIO_MODE:
#if (STD_ON == PORT_DEV_ERROR_DETECT)
                        Port_Ipw_SetGpioDirChangeability(PinPad, TRUE);
    71e0:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    71e4:	2101      	movs	r1, #1
    71e6:	4618      	mov	r0, r3
    71e8:	f000 f85c 	bl	72a4 <Port_Ipw_SetGpioDirChangeability>
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */
                        ePadDirection = pConfigPtr->pUsedPadConfig[PinIndex].ePadDir;
    71ec:	9b01      	ldr	r3, [sp, #4]
    71ee:	68d9      	ldr	r1, [r3, #12]
    71f0:	9a03      	ldr	r2, [sp, #12]
    71f2:	4613      	mov	r3, r2
    71f4:	009b      	lsls	r3, r3, #2
    71f6:	4413      	add	r3, r2
    71f8:	009b      	lsls	r3, r3, #2
    71fa:	440b      	add	r3, r1
    71fc:	68db      	ldr	r3, [r3, #12]
    71fe:	9307      	str	r3, [sp, #28]
#if (STD_OFF == PORT_SETPINMODE_DOES_NOT_TOUCH_GPIO_LEVEL)
                        if ((PORT_PIN_IN != ePadDirection) && (PORT_PIN_HIGH_Z != ePadDirection))
    7200:	9b07      	ldr	r3, [sp, #28]
    7202:	2b01      	cmp	r3, #1
    7204:	d006      	beq.n	7214 <Port_Ipw_SetPinMode+0x140>
    7206:	9b07      	ldr	r3, [sp, #28]
    7208:	2b03      	cmp	r3, #3
    720a:	d003      	beq.n	7214 <Port_Ipw_SetPinMode+0x140>
                        {
                            Port_Ipw_SetGpioPadOutput(PinIndex, pConfigPtr);
    720c:	9901      	ldr	r1, [sp, #4]
    720e:	9803      	ldr	r0, [sp, #12]
    7210:	f000 f896 	bl	7340 <Port_Ipw_SetGpioPadOutput>
                        }
#endif /* (STD_OFF == PORT_SETPINMODE_DOES_NOT_TOUCH_GPIO_LEVEL) */
                        (void)Port_Ipw_SetPinDirection(PinIndex, ePadDirection, pConfigPtr);
    7214:	9a01      	ldr	r2, [sp, #4]
    7216:	9907      	ldr	r1, [sp, #28]
    7218:	9803      	ldr	r0, [sp, #12]
    721a:	f7ff fe63 	bl	6ee4 <Port_Ipw_SetPinDirection>
                        break;
    721e:	e006      	b.n	722e <Port_Ipw_SetPinMode+0x15a>

                    default:
#if (STD_ON == PORT_DEV_ERROR_DETECT)
                    /* All the ALT modes except GPIO*/
                        Port_Ipw_SetGpioDirChangeability(PinPad,FALSE);
    7220:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    7224:	2100      	movs	r1, #0
    7226:	4618      	mov	r0, r3
    7228:	f000 f83c 	bl	72a4 <Port_Ipw_SetGpioDirChangeability>
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */
                        break;
    722c:	bf00      	nop
                }
                /* Sets the port pin mode */
                SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27();
    722e:	f00e fe05 	bl	15e3c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27>
                u32LocalPCR  = (Port_au32PortCiPortBaseAddr[GPIO_PORT_U32(PinPad)])->PCR[GPIO_CHANNEL_U32(PinPad)];
    7232:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    7236:	095b      	lsrs	r3, r3, #5
    7238:	b29b      	uxth	r3, r3
    723a:	461a      	mov	r2, r3
    723c:	4b18      	ldr	r3, [pc, #96]	; (72a0 <Port_Ipw_SetPinMode+0x1cc>)
    723e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    7242:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
    7246:	f002 021f 	and.w	r2, r2, #31
    724a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    724e:	9305      	str	r3, [sp, #20]

                u32LocalPCR &= ~(PORT_CI_PCR_ALT_MODE_U32);
    7250:	9b05      	ldr	r3, [sp, #20]
    7252:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    7256:	9305      	str	r3, [sp, #20]
                u32LocalPCR |= ((uint32)PinCfgRegValue << PORT_CI_PCR_ALT_MODE_OFFSET_U32);
    7258:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    725c:	021b      	lsls	r3, r3, #8
    725e:	9a05      	ldr	r2, [sp, #20]
    7260:	4313      	orrs	r3, r2
    7262:	9305      	str	r3, [sp, #20]

                (Port_au32PortCiPortBaseAddr[GPIO_PORT_U32(PinPad)])->PCR[GPIO_CHANNEL_U32(PinPad)] = u32LocalPCR;
    7264:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    7268:	095b      	lsrs	r3, r3, #5
    726a:	b29b      	uxth	r3, r3
    726c:	461a      	mov	r2, r3
    726e:	4b0c      	ldr	r3, [pc, #48]	; (72a0 <Port_Ipw_SetPinMode+0x1cc>)
    7270:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    7274:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
    7278:	f002 021f 	and.w	r2, r2, #31
    727c:	9905      	ldr	r1, [sp, #20]
    727e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
                SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27();
    7282:	f00e fe07 	bl	15e94 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27>
    7286:	e002      	b.n	728e <Port_Ipw_SetPinMode+0x1ba>
            }
            else
            {
                PinModeError = PORT_E_PARAM_INVALID_MODE;
    7288:	230d      	movs	r3, #13
    728a:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
        }
#if (STD_ON == PORT_DEV_ERROR_DETECT)
    }
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */

    return PinModeError;
    728e:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
}
    7292:	4618      	mov	r0, r3
    7294:	b00b      	add	sp, #44	; 0x2c
    7296:	f85d fb04 	ldr.w	pc, [sp], #4
    729a:	bf00      	nop
    729c:	00019478 	.word	0x00019478
    72a0:	00018694 	.word	0x00018694

000072a4 <Port_Ipw_SetGpioDirChangeability>:
void Port_Ipw_SetGpioDirChangeability
(
    uint16 PadID,
    boolean bStatus
)
{
    72a4:	b500      	push	{lr}
    72a6:	b085      	sub	sp, #20
    72a8:	4603      	mov	r3, r0
    72aa:	460a      	mov	r2, r1
    72ac:	f8ad 3006 	strh.w	r3, [sp, #6]
    72b0:	4613      	mov	r3, r2
    72b2:	f88d 3005 	strb.w	r3, [sp, #5]
    /* Pin description variables */
    uint8 u8PinBitOffset;
    uint16 u16PinDirFlagWord;

    /* Enter critical region */
    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18();
    72b6:	f00e fadf 	bl	15878 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18>
    /* Bit offset of Pin index inside the pin description matrix */
    u8PinBitOffset      = (uint8)((uint8)PadID & PORT_CI_BIT_OFFSET_MASK_U8);
    72ba:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    72be:	b2db      	uxtb	r3, r3
    72c0:	f003 030f 	and.w	r3, r3, #15
    72c4:	f88d 300d 	strb.w	r3, [sp, #13]
    u16PinDirFlagWord   = Port_Ipw_au16GpioDirChangeability[(uint8)((uint8)PadID >> 4)];
    72c8:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    72cc:	b2db      	uxtb	r3, r3
    72ce:	091b      	lsrs	r3, r3, #4
    72d0:	b2db      	uxtb	r3, r3
    72d2:	461a      	mov	r2, r3
    72d4:	4b19      	ldr	r3, [pc, #100]	; (733c <Port_Ipw_SetGpioDirChangeability+0x98>)
    72d6:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    72da:	f8ad 300e 	strh.w	r3, [sp, #14]

    if (TRUE == bStatus)
    72de:	f89d 3005 	ldrb.w	r3, [sp, #5]
    72e2:	2b00      	cmp	r3, #0
    72e4:	d00b      	beq.n	72fe <Port_Ipw_SetGpioDirChangeability+0x5a>
    {
        /* Set the change direction flag */
        u16PinDirFlagWord |= (uint16)(1UL<<u8PinBitOffset);
    72e6:	f89d 300d 	ldrb.w	r3, [sp, #13]
    72ea:	2201      	movs	r2, #1
    72ec:	fa02 f303 	lsl.w	r3, r2, r3
    72f0:	b29a      	uxth	r2, r3
    72f2:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    72f6:	4313      	orrs	r3, r2
    72f8:	f8ad 300e 	strh.w	r3, [sp, #14]
    72fc:	e00c      	b.n	7318 <Port_Ipw_SetGpioDirChangeability+0x74>
    }
    else
    {
        /* Reset the change direction flag */
        u16PinDirFlagWord &= (uint16)(~((uint16)(1UL<<u8PinBitOffset)));
    72fe:	f89d 300d 	ldrb.w	r3, [sp, #13]
    7302:	2201      	movs	r2, #1
    7304:	fa02 f303 	lsl.w	r3, r2, r3
    7308:	b29b      	uxth	r3, r3
    730a:	43db      	mvns	r3, r3
    730c:	b29a      	uxth	r2, r3
    730e:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    7312:	4013      	ands	r3, r2
    7314:	f8ad 300e 	strh.w	r3, [sp, #14]
    }
    Port_Ipw_au16GpioDirChangeability[(uint8)((uint8)PadID >> 4)] = u16PinDirFlagWord;
    7318:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    731c:	b2db      	uxtb	r3, r3
    731e:	091b      	lsrs	r3, r3, #4
    7320:	b2db      	uxtb	r3, r3
    7322:	4619      	mov	r1, r3
    7324:	4a05      	ldr	r2, [pc, #20]	; (733c <Port_Ipw_SetGpioDirChangeability+0x98>)
    7326:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    732a:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
    /* Exit critical region */
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18();
    732e:	f00e facf 	bl	158d0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18>
}
    7332:	bf00      	nop
    7334:	b005      	add	sp, #20
    7336:	f85d fb04 	ldr.w	pc, [sp], #4
    733a:	bf00      	nop
    733c:	1fff8cf0 	.word	0x1fff8cf0

00007340 <Port_Ipw_SetGpioPadOutput>:
void Port_Ipw_SetGpioPadOutput
(
    Port_PinType            PinIndex,
    const Port_ConfigType * pConfigPtr
)
{
    7340:	b084      	sub	sp, #16
    7342:	9001      	str	r0, [sp, #4]
    7344:	9100      	str	r1, [sp, #0]
    uint16 Pin = pConfigPtr->pUsedPadConfig[PinIndex].Pin;
    7346:	9b00      	ldr	r3, [sp, #0]
    7348:	68d9      	ldr	r1, [r3, #12]
    734a:	9a01      	ldr	r2, [sp, #4]
    734c:	4613      	mov	r3, r2
    734e:	009b      	lsls	r3, r3, #2
    7350:	4413      	add	r3, r2
    7352:	009b      	lsls	r3, r3, #2
    7354:	440b      	add	r3, r1
    7356:	881b      	ldrh	r3, [r3, #0]
    7358:	f8ad 300e 	strh.w	r3, [sp, #14]
    uint8 u8LocalPDO = pConfigPtr->pUsedPadConfig[PinIndex].u8PDO;
    735c:	9b00      	ldr	r3, [sp, #0]
    735e:	68d9      	ldr	r1, [r3, #12]
    7360:	9a01      	ldr	r2, [sp, #4]
    7362:	4613      	mov	r3, r2
    7364:	009b      	lsls	r3, r3, #2
    7366:	4413      	add	r3, r2
    7368:	009b      	lsls	r3, r3, #2
    736a:	440b      	add	r3, r1
    736c:	7a1b      	ldrb	r3, [r3, #8]
    736e:	f88d 300d 	strb.w	r3, [sp, #13]

    /* Set pin to High value */
    if (PORT_PIN_LEVEL_HIGH_U8 == u8LocalPDO)
    7372:	f89d 300d 	ldrb.w	r3, [sp, #13]
    7376:	2b01      	cmp	r3, #1
    7378:	d110      	bne.n	739c <Port_Ipw_SetGpioPadOutput+0x5c>
    {
        (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(Pin)])->PSOR = ((uint32)1U << GPIO_CHANNEL_U32(Pin));
    737a:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    737e:	f003 021f 	and.w	r2, r3, #31
    7382:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    7386:	095b      	lsrs	r3, r3, #5
    7388:	b29b      	uxth	r3, r3
    738a:	4619      	mov	r1, r3
    738c:	4b0f      	ldr	r3, [pc, #60]	; (73cc <Port_Ipw_SetGpioPadOutput+0x8c>)
    738e:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    7392:	2101      	movs	r1, #1
    7394:	fa01 f202 	lsl.w	r2, r1, r2
    7398:	605a      	str	r2, [r3, #4]
    }
    else
    {
        /* No action to be done */
    }
}
    739a:	e013      	b.n	73c4 <Port_Ipw_SetGpioPadOutput+0x84>
    else if (PORT_PIN_LEVEL_LOW_U8 == u8LocalPDO)
    739c:	f89d 300d 	ldrb.w	r3, [sp, #13]
    73a0:	2b00      	cmp	r3, #0
    73a2:	d10f      	bne.n	73c4 <Port_Ipw_SetGpioPadOutput+0x84>
        (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(Pin)])->PCOR = ((uint32)1U << GPIO_CHANNEL_U32(Pin));
    73a4:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    73a8:	f003 021f 	and.w	r2, r3, #31
    73ac:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    73b0:	095b      	lsrs	r3, r3, #5
    73b2:	b29b      	uxth	r3, r3
    73b4:	4619      	mov	r1, r3
    73b6:	4b05      	ldr	r3, [pc, #20]	; (73cc <Port_Ipw_SetGpioPadOutput+0x8c>)
    73b8:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    73bc:	2101      	movs	r1, #1
    73be:	fa01 f202 	lsl.w	r2, r1, r2
    73c2:	609a      	str	r2, [r3, #8]
}
    73c4:	bf00      	nop
    73c6:	b004      	add	sp, #16
    73c8:	4770      	bx	lr
    73ca:	bf00      	nop
    73cc:	000186a8 	.word	0x000186a8

000073d0 <Port_Ipw_RefreshPortDirection>:
*/
void Port_Ipw_RefreshPortDirection
(
    const Port_ConfigType * pConfigPtr
)
{
    73d0:	b500      	push	{lr}
    73d2:	b085      	sub	sp, #20
    73d4:	9001      	str	r0, [sp, #4]
    uint16 u16NumPins = pConfigPtr->u16NumPins;
    73d6:	9b01      	ldr	r3, [sp, #4]
    73d8:	881b      	ldrh	r3, [r3, #0]
    73da:	f8ad 300c 	strh.w	r3, [sp, #12]
    /* Index of the port table */
    uint16 u16PinIndex;
    uint16 PinPad;

    /* Initialize All Configured Port Pins that aren't direction changable */
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumPins; u16PinIndex++)
    73de:	2300      	movs	r3, #0
    73e0:	f8ad 300e 	strh.w	r3, [sp, #14]
    73e4:	e0d2      	b.n	758c <Port_Ipw_RefreshPortDirection+0x1bc>
    {
        if (FALSE == pConfigPtr->pUsedPadConfig[u16PinIndex].bDC)
    73e6:	9b01      	ldr	r3, [sp, #4]
    73e8:	68d9      	ldr	r1, [r3, #12]
    73ea:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    73ee:	4613      	mov	r3, r2
    73f0:	009b      	lsls	r3, r3, #2
    73f2:	4413      	add	r3, r2
    73f4:	009b      	lsls	r3, r3, #2
    73f6:	440b      	add	r3, r1
    73f8:	7c5b      	ldrb	r3, [r3, #17]
    73fa:	f083 0301 	eor.w	r3, r3, #1
    73fe:	b2db      	uxtb	r3, r3
    7400:	2b00      	cmp	r3, #0
    7402:	f000 80be 	beq.w	7582 <Port_Ipw_RefreshPortDirection+0x1b2>
        {
            /* On this platform we can only determine direction for the pins initialy configured as GPIOs */
            if (TRUE == pConfigPtr->pUsedPadConfig[u16PinIndex].bGPIO)
    7406:	9b01      	ldr	r3, [sp, #4]
    7408:	68d9      	ldr	r1, [r3, #12]
    740a:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    740e:	4613      	mov	r3, r2
    7410:	009b      	lsls	r3, r3, #2
    7412:	4413      	add	r3, r2
    7414:	009b      	lsls	r3, r3, #2
    7416:	440b      	add	r3, r1
    7418:	7c1b      	ldrb	r3, [r3, #16]
    741a:	2b00      	cmp	r3, #0
    741c:	f000 80b1 	beq.w	7582 <Port_Ipw_RefreshPortDirection+0x1b2>
            {
                /* Point to the Port Pin MSCR register address*/
                PinPad = pConfigPtr->pUsedPadConfig[u16PinIndex].Pin;
    7420:	9b01      	ldr	r3, [sp, #4]
    7422:	68d9      	ldr	r1, [r3, #12]
    7424:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    7428:	4613      	mov	r3, r2
    742a:	009b      	lsls	r3, r3, #2
    742c:	4413      	add	r3, r2
    742e:	009b      	lsls	r3, r3, #2
    7430:	440b      	add	r3, r1
    7432:	881b      	ldrh	r3, [r3, #0]
    7434:	f8ad 300a 	strh.w	r3, [sp, #10]

                /* Configures Port Pin as Output */
                if (PORT_PIN_OUT == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir)
    7438:	9b01      	ldr	r3, [sp, #4]
    743a:	68d9      	ldr	r1, [r3, #12]
    743c:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    7440:	4613      	mov	r3, r2
    7442:	009b      	lsls	r3, r3, #2
    7444:	4413      	add	r3, r2
    7446:	009b      	lsls	r3, r3, #2
    7448:	440b      	add	r3, r1
    744a:	68db      	ldr	r3, [r3, #12]
    744c:	2b02      	cmp	r3, #2
    744e:	d11d      	bne.n	748c <Port_Ipw_RefreshPortDirection+0xbc>
                {
                    /* Configure the pin direction as output in the PDDR register of GPIO IP */
                    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19();
    7450:	f00e fa64 	bl	1591c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19>
                    (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PDDR |= ((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    7454:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    7458:	095b      	lsrs	r3, r3, #5
    745a:	b29b      	uxth	r3, r3
    745c:	461a      	mov	r2, r3
    745e:	4b51      	ldr	r3, [pc, #324]	; (75a4 <Port_Ipw_RefreshPortDirection+0x1d4>)
    7460:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    7464:	6959      	ldr	r1, [r3, #20]
    7466:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    746a:	f003 031f 	and.w	r3, r3, #31
    746e:	2201      	movs	r2, #1
    7470:	409a      	lsls	r2, r3
    7472:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    7476:	095b      	lsrs	r3, r3, #5
    7478:	b29b      	uxth	r3, r3
    747a:	4618      	mov	r0, r3
    747c:	4b49      	ldr	r3, [pc, #292]	; (75a4 <Port_Ipw_RefreshPortDirection+0x1d4>)
    747e:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    7482:	430a      	orrs	r2, r1
    7484:	615a      	str	r2, [r3, #20]
                    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19();
    7486:	f00e fa75 	bl	15974 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19>
    748a:	e07a      	b.n	7582 <Port_Ipw_RefreshPortDirection+0x1b2>
                }
                /* Configures Port Pin as Input or High-Z*/
                else if ((PORT_PIN_IN == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir) || (PORT_PIN_HIGH_Z == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir))
    748c:	9b01      	ldr	r3, [sp, #4]
    748e:	68d9      	ldr	r1, [r3, #12]
    7490:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    7494:	4613      	mov	r3, r2
    7496:	009b      	lsls	r3, r3, #2
    7498:	4413      	add	r3, r2
    749a:	009b      	lsls	r3, r3, #2
    749c:	440b      	add	r3, r1
    749e:	68db      	ldr	r3, [r3, #12]
    74a0:	2b01      	cmp	r3, #1
    74a2:	d00b      	beq.n	74bc <Port_Ipw_RefreshPortDirection+0xec>
    74a4:	9b01      	ldr	r3, [sp, #4]
    74a6:	68d9      	ldr	r1, [r3, #12]
    74a8:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    74ac:	4613      	mov	r3, r2
    74ae:	009b      	lsls	r3, r3, #2
    74b0:	4413      	add	r3, r2
    74b2:	009b      	lsls	r3, r3, #2
    74b4:	440b      	add	r3, r1
    74b6:	68db      	ldr	r3, [r3, #12]
    74b8:	2b03      	cmp	r3, #3
    74ba:	d162      	bne.n	7582 <Port_Ipw_RefreshPortDirection+0x1b2>
                {
                    /* Configure the pin direction as input in the PDDR register of GPIO IP */
                    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19();
    74bc:	f00e fa2e 	bl	1591c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19>
                    (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PDDR &= ~((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    74c0:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    74c4:	095b      	lsrs	r3, r3, #5
    74c6:	b29b      	uxth	r3, r3
    74c8:	461a      	mov	r2, r3
    74ca:	4b36      	ldr	r3, [pc, #216]	; (75a4 <Port_Ipw_RefreshPortDirection+0x1d4>)
    74cc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    74d0:	6959      	ldr	r1, [r3, #20]
    74d2:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    74d6:	f003 031f 	and.w	r3, r3, #31
    74da:	2201      	movs	r2, #1
    74dc:	fa02 f303 	lsl.w	r3, r2, r3
    74e0:	43da      	mvns	r2, r3
    74e2:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    74e6:	095b      	lsrs	r3, r3, #5
    74e8:	b29b      	uxth	r3, r3
    74ea:	4618      	mov	r0, r3
    74ec:	4b2d      	ldr	r3, [pc, #180]	; (75a4 <Port_Ipw_RefreshPortDirection+0x1d4>)
    74ee:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    74f2:	400a      	ands	r2, r1
    74f4:	615a      	str	r2, [r3, #20]
                    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19();
    74f6:	f00e fa3d 	bl	15974 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19>
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER
                    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20();
    74fa:	f00e fa61 	bl	159c0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20>
                    (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PIDR &= ~((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    74fe:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    7502:	095b      	lsrs	r3, r3, #5
    7504:	b29b      	uxth	r3, r3
    7506:	461a      	mov	r2, r3
    7508:	4b26      	ldr	r3, [pc, #152]	; (75a4 <Port_Ipw_RefreshPortDirection+0x1d4>)
    750a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    750e:	6999      	ldr	r1, [r3, #24]
    7510:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    7514:	f003 031f 	and.w	r3, r3, #31
    7518:	2201      	movs	r2, #1
    751a:	fa02 f303 	lsl.w	r3, r2, r3
    751e:	43da      	mvns	r2, r3
    7520:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    7524:	095b      	lsrs	r3, r3, #5
    7526:	b29b      	uxth	r3, r3
    7528:	4618      	mov	r0, r3
    752a:	4b1e      	ldr	r3, [pc, #120]	; (75a4 <Port_Ipw_RefreshPortDirection+0x1d4>)
    752c:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    7530:	400a      	ands	r2, r1
    7532:	619a      	str	r2, [r3, #24]

                    /* Check if the pin is HIGH-Z. In this case the driver needs to disable port input in PIDR register of GPIO IP*/
                    if (PORT_PIN_HIGH_Z == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir)
    7534:	9b01      	ldr	r3, [sp, #4]
    7536:	68d9      	ldr	r1, [r3, #12]
    7538:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    753c:	4613      	mov	r3, r2
    753e:	009b      	lsls	r3, r3, #2
    7540:	4413      	add	r3, r2
    7542:	009b      	lsls	r3, r3, #2
    7544:	440b      	add	r3, r1
    7546:	68db      	ldr	r3, [r3, #12]
    7548:	2b03      	cmp	r3, #3
    754a:	d118      	bne.n	757e <Port_Ipw_RefreshPortDirection+0x1ae>
                    {
                        (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PIDR |= ((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    754c:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    7550:	095b      	lsrs	r3, r3, #5
    7552:	b29b      	uxth	r3, r3
    7554:	461a      	mov	r2, r3
    7556:	4b13      	ldr	r3, [pc, #76]	; (75a4 <Port_Ipw_RefreshPortDirection+0x1d4>)
    7558:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    755c:	6999      	ldr	r1, [r3, #24]
    755e:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    7562:	f003 031f 	and.w	r3, r3, #31
    7566:	2201      	movs	r2, #1
    7568:	409a      	lsls	r2, r3
    756a:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    756e:	095b      	lsrs	r3, r3, #5
    7570:	b29b      	uxth	r3, r3
    7572:	4618      	mov	r0, r3
    7574:	4b0b      	ldr	r3, [pc, #44]	; (75a4 <Port_Ipw_RefreshPortDirection+0x1d4>)
    7576:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    757a:	430a      	orrs	r2, r1
    757c:	619a      	str	r2, [r3, #24]
                    }
                    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20();
    757e:	f00e fa4b 	bl	15a18 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20>
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumPins; u16PinIndex++)
    7582:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    7586:	3301      	adds	r3, #1
    7588:	f8ad 300e 	strh.w	r3, [sp, #14]
    758c:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    7590:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    7594:	429a      	cmp	r2, r3
    7596:	f4ff af26 	bcc.w	73e6 <Port_Ipw_RefreshPortDirection+0x16>
                    /* Do nothing. Else branch present in order to avoid MISRA's violations */
                }
            }
        }
    }
}
    759a:	bf00      	nop
    759c:	bf00      	nop
    759e:	b005      	add	sp, #20
    75a0:	f85d fb04 	ldr.w	pc, [sp], #4
    75a4:	000186a8 	.word	0x000186a8

000075a8 <Adc_HwAcc_SetSC2Reg>:
#include "Adc_MemMap.h"

static inline void Adc_HwAcc_SetSC2Reg(ADC_Type * const Base,
                                       const uint32 ClearMask,
                                       const uint32 Value)
{
    75a8:	b086      	sub	sp, #24
    75aa:	9003      	str	r0, [sp, #12]
    75ac:	9102      	str	r1, [sp, #8]
    75ae:	9201      	str	r2, [sp, #4]
    /* Clear and set SC2 register based on ClearMask and Value */
    uint32 Sc2Reg = Base->SC2;
    75b0:	9b03      	ldr	r3, [sp, #12]
    75b2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
    75b6:	9305      	str	r3, [sp, #20]
    Sc2Reg &= ~(ClearMask);
    75b8:	9b02      	ldr	r3, [sp, #8]
    75ba:	43db      	mvns	r3, r3
    75bc:	9a05      	ldr	r2, [sp, #20]
    75be:	4013      	ands	r3, r2
    75c0:	9305      	str	r3, [sp, #20]
    Sc2Reg |= Value;
    75c2:	9a05      	ldr	r2, [sp, #20]
    75c4:	9b01      	ldr	r3, [sp, #4]
    75c6:	4313      	orrs	r3, r2
    75c8:	9305      	str	r3, [sp, #20]
    Base->SC2 = Sc2Reg;
    75ca:	9b03      	ldr	r3, [sp, #12]
    75cc:	9a05      	ldr	r2, [sp, #20]
    75ce:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
}
    75d2:	bf00      	nop
    75d4:	b006      	add	sp, #24
    75d6:	4770      	bx	lr

000075d8 <Adc_HwAcc_SetClock>:

static inline void Adc_HwAcc_SetClock(ADC_Type * const Base,
                                      const Adc_Ip_ClockSelType ClockDivide,
                                      const Adc_Ip_ClkSourceType InputClock)
{
    75d8:	b086      	sub	sp, #24
    75da:	9003      	str	r0, [sp, #12]
    75dc:	9102      	str	r1, [sp, #8]
    75de:	9201      	str	r2, [sp, #4]
    /* Update ClockDivide and InputClock values found in CFG1 register */
    uint32 Cfg1Reg = Base->CFG1;
    75e0:	9b03      	ldr	r3, [sp, #12]
    75e2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    75e4:	9305      	str	r3, [sp, #20]
    Cfg1Reg &= ~(ADC_CFG1_ADIV_MASK | ADC_CFG1_ADICLK_MASK);
    75e6:	9b05      	ldr	r3, [sp, #20]
    75e8:	f023 0363 	bic.w	r3, r3, #99	; 0x63
    75ec:	9305      	str	r3, [sp, #20]
    Cfg1Reg |= ADC_CFG1_ADIV(ClockDivide);
    75ee:	9b02      	ldr	r3, [sp, #8]
    75f0:	015b      	lsls	r3, r3, #5
    75f2:	f003 0360 	and.w	r3, r3, #96	; 0x60
    75f6:	9a05      	ldr	r2, [sp, #20]
    75f8:	4313      	orrs	r3, r2
    75fa:	9305      	str	r3, [sp, #20]
    Cfg1Reg |= ADC_CFG1_ADICLK(InputClock);
    75fc:	9b01      	ldr	r3, [sp, #4]
    75fe:	f003 0303 	and.w	r3, r3, #3
    7602:	9a05      	ldr	r2, [sp, #20]
    7604:	4313      	orrs	r3, r2
    7606:	9305      	str	r3, [sp, #20]
    Base->CFG1 = Cfg1Reg;
    7608:	9b03      	ldr	r3, [sp, #12]
    760a:	9a05      	ldr	r2, [sp, #20]
    760c:	641a      	str	r2, [r3, #64]	; 0x40
}
    760e:	bf00      	nop
    7610:	b006      	add	sp, #24
    7612:	4770      	bx	lr

00007614 <Adc_HwAcc_GetClockDivide>:

static inline Adc_Ip_ClockSelType Adc_HwAcc_GetClockDivide(const uint32 Reg)
{
    7614:	b084      	sub	sp, #16
    7616:	9001      	str	r0, [sp, #4]
    /*
     * Retrieve ClockDivide value found in CFG1 register
     * Note: Reg should be the value of CFG1 register
     */
    Adc_Ip_ClockSelType ReturnValue = ADC_IP_CLK_FULL_BUS;
    7618:	2300      	movs	r3, #0
    761a:	9303      	str	r3, [sp, #12]
    switch ((Reg & ADC_CFG1_ADIV_MASK) >> ADC_CFG1_ADIV_SHIFT)
    761c:	9b01      	ldr	r3, [sp, #4]
    761e:	095b      	lsrs	r3, r3, #5
    7620:	f003 0303 	and.w	r3, r3, #3
    7624:	2b03      	cmp	r3, #3
    7626:	d00c      	beq.n	7642 <Adc_HwAcc_GetClockDivide+0x2e>
    7628:	2b03      	cmp	r3, #3
    762a:	d80d      	bhi.n	7648 <Adc_HwAcc_GetClockDivide+0x34>
    762c:	2b01      	cmp	r3, #1
    762e:	d002      	beq.n	7636 <Adc_HwAcc_GetClockDivide+0x22>
    7630:	2b02      	cmp	r3, #2
    7632:	d003      	beq.n	763c <Adc_HwAcc_GetClockDivide+0x28>
        case 3u:
            ReturnValue = ADC_IP_CLK_EIGHTH_BUS;
            break;
        default:
            ; /* no-op */
            break;
    7634:	e008      	b.n	7648 <Adc_HwAcc_GetClockDivide+0x34>
            ReturnValue = ADC_IP_CLK_HALF_BUS;
    7636:	2301      	movs	r3, #1
    7638:	9303      	str	r3, [sp, #12]
            break;
    763a:	e006      	b.n	764a <Adc_HwAcc_GetClockDivide+0x36>
            ReturnValue = ADC_IP_CLK_QUARTER_BUS;
    763c:	2302      	movs	r3, #2
    763e:	9303      	str	r3, [sp, #12]
            break;
    7640:	e003      	b.n	764a <Adc_HwAcc_GetClockDivide+0x36>
            ReturnValue = ADC_IP_CLK_EIGHTH_BUS;
    7642:	2303      	movs	r3, #3
    7644:	9303      	str	r3, [sp, #12]
            break;
    7646:	e000      	b.n	764a <Adc_HwAcc_GetClockDivide+0x36>
            break;
    7648:	bf00      	nop
    }
    return ReturnValue;
    764a:	9b03      	ldr	r3, [sp, #12]
}
    764c:	4618      	mov	r0, r3
    764e:	b004      	add	sp, #16
    7650:	4770      	bx	lr

00007652 <Adc_HwAcc_GetInputClock>:

static inline Adc_Ip_ClkSourceType Adc_HwAcc_GetInputClock(const uint32 Reg)
{
    7652:	b084      	sub	sp, #16
    7654:	9001      	str	r0, [sp, #4]
    /*
     * Retrieve InputClock value found in CFG1 register
     * Note: Reg should be the value of CFG1 register
     */
    Adc_Ip_ClkSourceType ReturnValue = ADC_IP_CLK_ALT_1;
    7656:	2300      	movs	r3, #0
    7658:	9303      	str	r3, [sp, #12]
    switch ((Reg & ADC_CFG1_ADICLK_MASK) >> ADC_CFG1_ADICLK_SHIFT)
    765a:	9b01      	ldr	r3, [sp, #4]
    765c:	f003 0303 	and.w	r3, r3, #3
    7660:	2b03      	cmp	r3, #3
    7662:	d00c      	beq.n	767e <Adc_HwAcc_GetInputClock+0x2c>
    7664:	2b03      	cmp	r3, #3
    7666:	d80d      	bhi.n	7684 <Adc_HwAcc_GetInputClock+0x32>
    7668:	2b01      	cmp	r3, #1
    766a:	d002      	beq.n	7672 <Adc_HwAcc_GetInputClock+0x20>
    766c:	2b02      	cmp	r3, #2
    766e:	d003      	beq.n	7678 <Adc_HwAcc_GetInputClock+0x26>
        case 3u:
            ReturnValue = ADC_IP_CLK_ALT_4;
            break;
        default:
            ; /* no-op */
            break;
    7670:	e008      	b.n	7684 <Adc_HwAcc_GetInputClock+0x32>
            ReturnValue = ADC_IP_CLK_ALT_2;
    7672:	2301      	movs	r3, #1
    7674:	9303      	str	r3, [sp, #12]
            break;
    7676:	e006      	b.n	7686 <Adc_HwAcc_GetInputClock+0x34>
            ReturnValue = ADC_IP_CLK_ALT_3;
    7678:	2302      	movs	r3, #2
    767a:	9303      	str	r3, [sp, #12]
            break;
    767c:	e003      	b.n	7686 <Adc_HwAcc_GetInputClock+0x34>
            ReturnValue = ADC_IP_CLK_ALT_4;
    767e:	2303      	movs	r3, #3
    7680:	9303      	str	r3, [sp, #12]
            break;
    7682:	e000      	b.n	7686 <Adc_HwAcc_GetInputClock+0x34>
            break;
    7684:	bf00      	nop
    }
    return ReturnValue;
    7686:	9b03      	ldr	r3, [sp, #12]
}
    7688:	4618      	mov	r0, r3
    768a:	b004      	add	sp, #16
    768c:	4770      	bx	lr

0000768e <Adc_HwAcc_SetSampleTime>:

static inline void Adc_HwAcc_SetSampleTime(ADC_Type * const Base,
                                           const uint8 SampleTime)
{
    768e:	b084      	sub	sp, #16
    7690:	9001      	str	r0, [sp, #4]
    7692:	460b      	mov	r3, r1
    7694:	f88d 3003 	strb.w	r3, [sp, #3]
    /* Clip sample time to minimum value */
    uint8 ClippedSampleTime = (uint8)((SampleTime > 0U) ? SampleTime : 1U);
    7698:	f89d 3003 	ldrb.w	r3, [sp, #3]
    769c:	2b00      	cmp	r3, #0
    769e:	d002      	beq.n	76a6 <Adc_HwAcc_SetSampleTime+0x18>
    76a0:	f89d 3003 	ldrb.w	r3, [sp, #3]
    76a4:	e000      	b.n	76a8 <Adc_HwAcc_SetSampleTime+0x1a>
    76a6:	2301      	movs	r3, #1
    76a8:	f88d 300f 	strb.w	r3, [sp, #15]
    /* Update SampleTime values found in SC3 register */
    uint32 Cfg2Reg = Base->CFG2;
    76ac:	9b01      	ldr	r3, [sp, #4]
    76ae:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    76b0:	9302      	str	r3, [sp, #8]
    Cfg2Reg &= ~(ADC_CFG2_SMPLTS_MASK);
    76b2:	9b02      	ldr	r3, [sp, #8]
    76b4:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
    76b8:	9302      	str	r3, [sp, #8]
    Cfg2Reg |= ADC_CFG2_SMPLTS(ClippedSampleTime);
    76ba:	f89d 300f 	ldrb.w	r3, [sp, #15]
    76be:	9a02      	ldr	r2, [sp, #8]
    76c0:	4313      	orrs	r3, r2
    76c2:	9302      	str	r3, [sp, #8]
    Base->CFG2 = Cfg2Reg;
    76c4:	9b01      	ldr	r3, [sp, #4]
    76c6:	9a02      	ldr	r2, [sp, #8]
    76c8:	645a      	str	r2, [r3, #68]	; 0x44
}
    76ca:	bf00      	nop
    76cc:	b004      	add	sp, #16
    76ce:	4770      	bx	lr

000076d0 <Adc_HwAcc_SetAveraging>:

static inline void Adc_HwAcc_SetAveraging(ADC_Type * const Base,
                                          const boolean AvgEn,
                                          const Adc_Ip_AvgSelectType AvgSel)
{
    76d0:	b086      	sub	sp, #24
    76d2:	9003      	str	r0, [sp, #12]
    76d4:	460b      	mov	r3, r1
    76d6:	9201      	str	r2, [sp, #4]
    76d8:	f88d 300b 	strb.w	r3, [sp, #11]
    /* Update AvgEn and AvgSel values found in SC3 register */
    uint32 Sc3Reg = Base->SC3;
    76dc:	9b03      	ldr	r3, [sp, #12]
    76de:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
    76e2:	9305      	str	r3, [sp, #20]
    Sc3Reg &= ~(ADC_SC3_AVGE_MASK | ADC_SC3_AVGS_MASK);
    76e4:	9b05      	ldr	r3, [sp, #20]
    76e6:	f023 0307 	bic.w	r3, r3, #7
    76ea:	9305      	str	r3, [sp, #20]
    Sc3Reg |= ADC_SC3_AVGE(AvgEn ? 1u : 0u);
    76ec:	f89d 300b 	ldrb.w	r3, [sp, #11]
    76f0:	2b00      	cmp	r3, #0
    76f2:	d001      	beq.n	76f8 <Adc_HwAcc_SetAveraging+0x28>
    76f4:	2304      	movs	r3, #4
    76f6:	e000      	b.n	76fa <Adc_HwAcc_SetAveraging+0x2a>
    76f8:	2300      	movs	r3, #0
    76fa:	9a05      	ldr	r2, [sp, #20]
    76fc:	4313      	orrs	r3, r2
    76fe:	9305      	str	r3, [sp, #20]
    Sc3Reg |= ADC_SC3_AVGS(AvgSel);
    7700:	9b01      	ldr	r3, [sp, #4]
    7702:	f003 0303 	and.w	r3, r3, #3
    7706:	9a05      	ldr	r2, [sp, #20]
    7708:	4313      	orrs	r3, r2
    770a:	9305      	str	r3, [sp, #20]
    Base->SC3 = Sc3Reg;
    770c:	9b03      	ldr	r3, [sp, #12]
    770e:	9a05      	ldr	r2, [sp, #20]
    7710:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
}
    7714:	bf00      	nop
    7716:	b006      	add	sp, #24
    7718:	4770      	bx	lr

0000771a <Adc_HwAcc_GetAverageSelect>:

static inline Adc_Ip_AvgSelectType Adc_HwAcc_GetAverageSelect(const uint32 Reg)
{
    771a:	b084      	sub	sp, #16
    771c:	9001      	str	r0, [sp, #4]
    /*
     * Retrieve AvgSelect value found in SC3 register
     * Note: Reg should be the value of SC3 register
     */
    Adc_Ip_AvgSelectType ReturnValue = ADC_IP_AVG_4_CONV;
    771e:	2300      	movs	r3, #0
    7720:	9303      	str	r3, [sp, #12]
    switch ((Reg & ADC_SC3_AVGS_MASK) >> ADC_SC3_AVGS_SHIFT)
    7722:	9b01      	ldr	r3, [sp, #4]
    7724:	f003 0303 	and.w	r3, r3, #3
    7728:	2b03      	cmp	r3, #3
    772a:	d00c      	beq.n	7746 <Adc_HwAcc_GetAverageSelect+0x2c>
    772c:	2b03      	cmp	r3, #3
    772e:	d80d      	bhi.n	774c <Adc_HwAcc_GetAverageSelect+0x32>
    7730:	2b01      	cmp	r3, #1
    7732:	d002      	beq.n	773a <Adc_HwAcc_GetAverageSelect+0x20>
    7734:	2b02      	cmp	r3, #2
    7736:	d003      	beq.n	7740 <Adc_HwAcc_GetAverageSelect+0x26>
        case 3u:
            ReturnValue = ADC_IP_AVG_32_CONV;
            break;
        default:
            ; /* no-op */
            break;
    7738:	e008      	b.n	774c <Adc_HwAcc_GetAverageSelect+0x32>
            ReturnValue = ADC_IP_AVG_8_CONV;
    773a:	2301      	movs	r3, #1
    773c:	9303      	str	r3, [sp, #12]
            break;
    773e:	e006      	b.n	774e <Adc_HwAcc_GetAverageSelect+0x34>
            ReturnValue = ADC_IP_AVG_16_CONV;
    7740:	2302      	movs	r3, #2
    7742:	9303      	str	r3, [sp, #12]
            break;
    7744:	e003      	b.n	774e <Adc_HwAcc_GetAverageSelect+0x34>
            ReturnValue = ADC_IP_AVG_32_CONV;
    7746:	2303      	movs	r3, #3
    7748:	9303      	str	r3, [sp, #12]
            break;
    774a:	e000      	b.n	774e <Adc_HwAcc_GetAverageSelect+0x34>
            break;
    774c:	bf00      	nop
    }
    return ReturnValue;
    774e:	9b03      	ldr	r3, [sp, #12]
}
    7750:	4618      	mov	r0, r3
    7752:	b004      	add	sp, #16
    7754:	4770      	bx	lr

00007756 <Adc_HwAcc_SetTriggerMode>:

static inline void Adc_HwAcc_SetTriggerMode(ADC_Type * const Base,
                                            const Adc_Ip_TrigType TriggerMode)
{
    7756:	b084      	sub	sp, #16
    7758:	9001      	str	r0, [sp, #4]
    775a:	9100      	str	r1, [sp, #0]
    /* Update TriggerMode value found in SC2 register */
    uint32 Sc2Reg = Base->SC2;
    775c:	9b01      	ldr	r3, [sp, #4]
    775e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
    7762:	9303      	str	r3, [sp, #12]
    Sc2Reg &= ~(ADC_SC2_ADTRG_MASK);
    7764:	9b03      	ldr	r3, [sp, #12]
    7766:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    776a:	9303      	str	r3, [sp, #12]
    Sc2Reg |= ADC_SC2_ADTRG(TriggerMode);
    776c:	9b00      	ldr	r3, [sp, #0]
    776e:	019b      	lsls	r3, r3, #6
    7770:	f003 0340 	and.w	r3, r3, #64	; 0x40
    7774:	9a03      	ldr	r2, [sp, #12]
    7776:	4313      	orrs	r3, r2
    7778:	9303      	str	r3, [sp, #12]
    Base->SC2 = Sc2Reg;
    777a:	9b01      	ldr	r3, [sp, #4]
    777c:	9a03      	ldr	r2, [sp, #12]
    777e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
}
    7782:	bf00      	nop
    7784:	b004      	add	sp, #16
    7786:	4770      	bx	lr

00007788 <Adc_HwAcc_GetTriggerMode>:

static inline Adc_Ip_TrigType Adc_HwAcc_GetTriggerMode(const uint32 Reg)
{
    7788:	b084      	sub	sp, #16
    778a:	9001      	str	r0, [sp, #4]
    /* Retrieve TriggerMode value found in SC2 register */
    Adc_Ip_TrigType ReturnValue = ADC_IP_TRIGGER_SOFTWARE;
    778c:	2300      	movs	r3, #0
    778e:	9303      	str	r3, [sp, #12]
    if (((Reg & ADC_SC2_ADTRG_MASK) >> ADC_SC2_ADTRG_SHIFT) == 1u)
    7790:	9b01      	ldr	r3, [sp, #4]
    7792:	f003 0340 	and.w	r3, r3, #64	; 0x40
    7796:	2b00      	cmp	r3, #0
    7798:	d001      	beq.n	779e <Adc_HwAcc_GetTriggerMode+0x16>
    {
        ReturnValue = ADC_IP_TRIGGER_HARDWARE;
    779a:	2301      	movs	r3, #1
    779c:	9303      	str	r3, [sp, #12]
    }
    return ReturnValue;
    779e:	9b03      	ldr	r3, [sp, #12]
}
    77a0:	4618      	mov	r0, r3
    77a2:	b004      	add	sp, #16
    77a4:	4770      	bx	lr

000077a6 <Adc_HwAcc_SetChannel>:

static inline void Adc_HwAcc_SetChannel(ADC_Type * const Base,
                                        const uint8 ChnIdx,
                                        const Adc_Ip_InputChannelType InputChannel,
                                        const boolean InterruptEnable)
{
    77a6:	b086      	sub	sp, #24
    77a8:	9003      	str	r0, [sp, #12]
    77aa:	9201      	str	r2, [sp, #4]
    77ac:	461a      	mov	r2, r3
    77ae:	460b      	mov	r3, r1
    77b0:	f88d 300b 	strb.w	r3, [sp, #11]
    77b4:	4613      	mov	r3, r2
    77b6:	f88d 300a 	strb.w	r3, [sp, #10]
    /* Configure channel by writing all SC1n register fields */
    uint32 Sc1Reg = SC1(Base, ChnIdx);
    77ba:	f89d 200b 	ldrb.w	r2, [sp, #11]
    77be:	9b03      	ldr	r3, [sp, #12]
    77c0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    77c4:	9305      	str	r3, [sp, #20]
    Sc1Reg &= ~(ADC_SC1_ADCH_MASK | ADC_SC1_AIEN_MASK);
    77c6:	9b05      	ldr	r3, [sp, #20]
    77c8:	f023 035f 	bic.w	r3, r3, #95	; 0x5f
    77cc:	9305      	str	r3, [sp, #20]
    Sc1Reg |= ADC_SC1_ADCH(InputChannel);
    77ce:	9b01      	ldr	r3, [sp, #4]
    77d0:	f003 031f 	and.w	r3, r3, #31
    77d4:	9a05      	ldr	r2, [sp, #20]
    77d6:	4313      	orrs	r3, r2
    77d8:	9305      	str	r3, [sp, #20]
    Sc1Reg |= ADC_SC1_AIEN(InterruptEnable ? 1u : 0u);
    77da:	f89d 300a 	ldrb.w	r3, [sp, #10]
    77de:	2b00      	cmp	r3, #0
    77e0:	d001      	beq.n	77e6 <Adc_HwAcc_SetChannel+0x40>
    77e2:	2340      	movs	r3, #64	; 0x40
    77e4:	e000      	b.n	77e8 <Adc_HwAcc_SetChannel+0x42>
    77e6:	2300      	movs	r3, #0
    77e8:	9a05      	ldr	r2, [sp, #20]
    77ea:	4313      	orrs	r3, r2
    77ec:	9305      	str	r3, [sp, #20]
    SC1(Base, ChnIdx) = Sc1Reg;
    77ee:	f89d 200b 	ldrb.w	r2, [sp, #11]
    77f2:	9b03      	ldr	r3, [sp, #12]
    77f4:	9905      	ldr	r1, [sp, #20]
    77f6:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    77fa:	bf00      	nop
    77fc:	b006      	add	sp, #24
    77fe:	4770      	bx	lr

00007800 <Adc_HwAcc_SetUserGainAndOffset>:

static inline void Adc_HwAcc_SetUserGainAndOffset(ADC_Type * const Base,
                                                  const uint16 UsrGain,
                                                  const uint16 UsrOffset)
{
    7800:	b082      	sub	sp, #8
    7802:	9001      	str	r0, [sp, #4]
    7804:	460b      	mov	r3, r1
    7806:	f8ad 3002 	strh.w	r3, [sp, #2]
    780a:	4613      	mov	r3, r2
    780c:	f8ad 3000 	strh.w	r3, [sp]
     * 2. RegVal <- Sum & 0xF800U
     * 3. if RegVal != 0x0000U then RegVal <- 0xFFFFU
     * 4. Base->G <- RegVal
     */

    Base->USR_OFS = ADC_USR_OFS_USR_OFS(UsrOffset);
    7810:	f8bd 3000 	ldrh.w	r3, [sp]
    7814:	b2da      	uxtb	r2, r3
    7816:	9b01      	ldr	r3, [sp, #4]
    7818:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
    Base->UG = ADC_UG_UG(UsrGain);
    781c:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    7820:	f3c3 0209 	ubfx	r2, r3, #0, #10
    7824:	9b01      	ldr	r3, [sp, #4]
    7826:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
}
    782a:	bf00      	nop
    782c:	b002      	add	sp, #8
    782e:	4770      	bx	lr

00007830 <Adc_HwAcc_GetAIEN>:

#if (ADC_IP_AIEN_INTERRUPT_ENABLE == STD_ON)
static inline boolean Adc_HwAcc_GetAIEN(const uint32 Reg)
{
    7830:	b082      	sub	sp, #8
    7832:	9001      	str	r0, [sp, #4]
    /* Retrive AIEN flag from given SC1 register */
    return (((Reg & ADC_SC1_AIEN_MASK) >> ADC_SC1_AIEN_SHIFT) != 0u) ? TRUE : FALSE;
    7834:	9b01      	ldr	r3, [sp, #4]
    7836:	099b      	lsrs	r3, r3, #6
    7838:	f003 0301 	and.w	r3, r3, #1
    783c:	2b00      	cmp	r3, #0
    783e:	bf14      	ite	ne
    7840:	2301      	movne	r3, #1
    7842:	2300      	moveq	r3, #0
    7844:	b2db      	uxtb	r3, r3
}
    7846:	4618      	mov	r0, r3
    7848:	b002      	add	sp, #8
    784a:	4770      	bx	lr

0000784c <Adc_HwAcc_GetCOCO>:
#endif /* (ADC_IP_AIEN_INTERRUPT_ENABLE == STD_ON) */

static inline boolean Adc_HwAcc_GetCOCO(const uint32 Reg)
{
    784c:	b082      	sub	sp, #8
    784e:	9001      	str	r0, [sp, #4]
    /* Retrive COCO flag from given SC1 register */
    return (((Reg & ADC_SC1_COCO_MASK) >> ADC_SC1_COCO_SHIFT) != 0u) ? TRUE : FALSE;
    7850:	9b01      	ldr	r3, [sp, #4]
    7852:	09db      	lsrs	r3, r3, #7
    7854:	f003 0301 	and.w	r3, r3, #1
    7858:	2b00      	cmp	r3, #0
    785a:	bf14      	ite	ne
    785c:	2301      	movne	r3, #1
    785e:	2300      	moveq	r3, #0
    7860:	b2db      	uxtb	r3, r3
}
    7862:	4618      	mov	r0, r3
    7864:	b002      	add	sp, #8
    7866:	4770      	bx	lr

00007868 <Adc_HwAcc_GetData>:

static inline uint16 Adc_HwAcc_GetData(const ADC_Type * const Base,
                                       const uint8 ChnIdx)
{
    7868:	b084      	sub	sp, #16
    786a:	9001      	str	r0, [sp, #4]
    786c:	460b      	mov	r3, r1
    786e:	f88d 3003 	strb.w	r3, [sp, #3]
    /* Retrieve the conversion result of a given channel */
    uint16 Result = (uint16) R(Base, ChnIdx);
    7872:	f89d 2003 	ldrb.w	r2, [sp, #3]
    7876:	9b01      	ldr	r3, [sp, #4]
    7878:	3212      	adds	r2, #18
    787a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    787e:	f8ad 300e 	strh.w	r3, [sp, #14]
    Result = (uint16) ((Result & ADC_R_D_MASK) >> ADC_R_D_SHIFT);
    7882:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    7886:	f3c3 030b 	ubfx	r3, r3, #0, #12
    788a:	f8ad 300e 	strh.w	r3, [sp, #14]
    return Result;
    788e:	f8bd 300e 	ldrh.w	r3, [sp, #14]
}
    7892:	4618      	mov	r0, r3
    7894:	b004      	add	sp, #16
    7896:	4770      	bx	lr

00007898 <ADC_DoCalibration_SetParams>:
*
* END**************************************************************************/
static inline void ADC_DoCalibration_SetParams(ADC_Type * const Base,
                                               const Adc_Ip_ClockConfigType * const Config,
                                               const Adc_Ip_TrigType TriggerMode)
{
    7898:	b500      	push	{lr}
    789a:	b085      	sub	sp, #20
    789c:	9003      	str	r0, [sp, #12]
    789e:	9102      	str	r1, [sp, #8]
    78a0:	9201      	str	r2, [sp, #4]
    /* Configure averaging */
    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_29();
    78a2:	f009 fc5b 	bl	1115c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_29>
    Adc_HwAcc_SetAveraging(Base, Config->AvgEn, Config->AvgSel);
    78a6:	9b02      	ldr	r3, [sp, #8]
    78a8:	7a59      	ldrb	r1, [r3, #9]
    78aa:	9b02      	ldr	r3, [sp, #8]
    78ac:	68db      	ldr	r3, [r3, #12]
    78ae:	461a      	mov	r2, r3
    78b0:	9803      	ldr	r0, [sp, #12]
    78b2:	f7ff ff0d 	bl	76d0 <Adc_HwAcc_SetAveraging>
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_29();
    78b6:	f009 fc7d 	bl	111b4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_29>

    /* Configure trigger mode */
    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_24();
    78ba:	f009 fab5 	bl	10e28 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_24>
    Adc_HwAcc_SetTriggerMode(Base, TriggerMode);
    78be:	9901      	ldr	r1, [sp, #4]
    78c0:	9803      	ldr	r0, [sp, #12]
    78c2:	f7ff ff48 	bl	7756 <Adc_HwAcc_SetTriggerMode>
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_24();
    78c6:	f009 fadb 	bl	10e80 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_24>

    /* Configure sample time */
    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_15();
    78ca:	f008 ffcb 	bl	10864 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_15>
    Adc_HwAcc_SetSampleTime(Base, Config->SampleTime);
    78ce:	9b02      	ldr	r3, [sp, #8]
    78d0:	7a1b      	ldrb	r3, [r3, #8]
    78d2:	4619      	mov	r1, r3
    78d4:	9803      	ldr	r0, [sp, #12]
    78d6:	f7ff feda 	bl	768e <Adc_HwAcc_SetSampleTime>
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_15();
    78da:	f008 ffef 	bl	108bc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_15>

    /* Configure input clock */
    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_13();
    78de:	f008 ff1d 	bl	1071c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_13>
    Adc_HwAcc_SetClock(Base, Config->ClockDivide, Config->InputClock);
    78e2:	9b02      	ldr	r3, [sp, #8]
    78e4:	6819      	ldr	r1, [r3, #0]
    78e6:	9b02      	ldr	r3, [sp, #8]
    78e8:	685b      	ldr	r3, [r3, #4]
    78ea:	461a      	mov	r2, r3
    78ec:	9803      	ldr	r0, [sp, #12]
    78ee:	f7ff fe73 	bl	75d8 <Adc_HwAcc_SetClock>
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_13();
    78f2:	f008 ff3f 	bl	10774 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_13>
}
    78f6:	bf00      	nop
    78f8:	b005      	add	sp, #20
    78fa:	f85d fb04 	ldr.w	pc, [sp], #4

000078fe <Adc_Ip_Init>:
*
* @implements     Adc_Ip_Init_Activity
* END**************************************************************************/
void Adc_Ip_Init(const uint32 Instance,
                 const Adc_Ip_ConfigType * const Config)
{
    78fe:	b500      	push	{lr}
    7900:	b087      	sub	sp, #28
    7902:	9001      	str	r0, [sp, #4]
    7904:	9100      	str	r1, [sp, #0]
    DevAssert(Instance < ADC_INSTANCE_COUNT);
    DevAssert(Config != NULL_PTR);
    DevAssert(Config->NumChannels <= ADC_MAX_CHAN_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7906:	4a67      	ldr	r2, [pc, #412]	; (7aa4 <Adc_Ip_Init+0x1a6>)
    7908:	9b01      	ldr	r3, [sp, #4]
    790a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    790e:	9302      	str	r3, [sp, #8]
    uint32 SC2Reg = 0u;
    7910:	2300      	movs	r3, #0
    7912:	9305      	str	r3, [sp, #20]
    uint32 SC2ClearMask = 0u;
    7914:	2300      	movs	r3, #0
    7916:	9304      	str	r3, [sp, #16]
    uint8 Index;

    Adc_HwAcc_SetClock(Base, Config->ClockDivide, Config->InputClock);
    7918:	9b00      	ldr	r3, [sp, #0]
    791a:	6819      	ldr	r1, [r3, #0]
    791c:	9b00      	ldr	r3, [sp, #0]
    791e:	689b      	ldr	r3, [r3, #8]
    7920:	461a      	mov	r2, r3
    7922:	9802      	ldr	r0, [sp, #8]
    7924:	f7ff fe58 	bl	75d8 <Adc_HwAcc_SetClock>
    Adc_HwAcc_SetSampleTime(Base, Config->SampleTime);
    7928:	9b00      	ldr	r3, [sp, #0]
    792a:	7b1b      	ldrb	r3, [r3, #12]
    792c:	4619      	mov	r1, r3
    792e:	9802      	ldr	r0, [sp, #8]
    7930:	f7ff fead 	bl	768e <Adc_HwAcc_SetSampleTime>
    Adc_HwAcc_SetAveraging(Base, Config->AvgEn, Config->AvgSel);
    7934:	9b00      	ldr	r3, [sp, #0]
    7936:	7b59      	ldrb	r1, [r3, #13]
    7938:	9b00      	ldr	r3, [sp, #0]
    793a:	691b      	ldr	r3, [r3, #16]
    793c:	461a      	mov	r2, r3
    793e:	9802      	ldr	r0, [sp, #8]
    7940:	f7ff fec6 	bl	76d0 <Adc_HwAcc_SetAveraging>

    Adc_Ip_SetResolution(Instance, Config->Resolution);
    7944:	9b00      	ldr	r3, [sp, #0]
    7946:	695b      	ldr	r3, [r3, #20]
    7948:	4619      	mov	r1, r3
    794a:	9801      	ldr	r0, [sp, #4]
    794c:	f000 f9ea 	bl	7d24 <Adc_Ip_SetResolution>
        ADC_SetSupplyMonitoringEnable(Config->SupplyMonitoringEnable);
    }
#endif /* (ADC_IP_SUPPLY_MONITORING_ENABLED == STD_ON) */

    /* Configure trigger mode */
    SC2ClearMask |= ADC_SC2_ADTRG_MASK;
    7950:	9b04      	ldr	r3, [sp, #16]
    7952:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    7956:	9304      	str	r3, [sp, #16]
    SC2Reg |= ADC_SC2_ADTRG(Config->TriggerMode);
    7958:	9b00      	ldr	r3, [sp, #0]
    795a:	699b      	ldr	r3, [r3, #24]
    795c:	019b      	lsls	r3, r3, #6
    795e:	f003 0340 	and.w	r3, r3, #64	; 0x40
    7962:	9a05      	ldr	r2, [sp, #20]
    7964:	4313      	orrs	r3, r2
    7966:	9305      	str	r3, [sp, #20]

    /* Configure DMA enable */
    if (Config->DmaEnable)
    7968:	9b00      	ldr	r3, [sp, #0]
    796a:	7f1b      	ldrb	r3, [r3, #28]
    796c:	2b00      	cmp	r3, #0
    796e:	d004      	beq.n	797a <Adc_Ip_Init+0x7c>
    {
        SC2Reg |= ADC_SC2_DMAEN_MASK;
    7970:	9b05      	ldr	r3, [sp, #20]
    7972:	f043 0304 	orr.w	r3, r3, #4
    7976:	9305      	str	r3, [sp, #20]
    7978:	e003      	b.n	7982 <Adc_Ip_Init+0x84>
    }
    else
    {
        SC2ClearMask |= ADC_SC2_DMAEN_MASK;
    797a:	9b04      	ldr	r3, [sp, #16]
    797c:	f043 0304 	orr.w	r3, r3, #4
    7980:	9304      	str	r3, [sp, #16]
    }

    /* Configure voltage reference selector */
    SC2ClearMask |= ADC_SC2_REFSEL_MASK;
    7982:	9b04      	ldr	r3, [sp, #16]
    7984:	f043 0303 	orr.w	r3, r3, #3
    7988:	9304      	str	r3, [sp, #16]
    SC2Reg |= ADC_SC2_REFSEL(Config->VoltageRef);
    798a:	9b00      	ldr	r3, [sp, #0]
    798c:	6a1b      	ldr	r3, [r3, #32]
    798e:	f003 0303 	and.w	r3, r3, #3
    7992:	9a05      	ldr	r2, [sp, #20]
    7994:	4313      	orrs	r3, r2
    7996:	9305      	str	r3, [sp, #20]

    /* Configure compare enables and values */
    SC2ClearMask |= ADC_SC2_ACFE_MASK | ADC_SC2_ACFGT_MASK | ADC_SC2_ACREN_MASK;
    7998:	9b04      	ldr	r3, [sp, #16]
    799a:	f043 0338 	orr.w	r3, r3, #56	; 0x38
    799e:	9304      	str	r3, [sp, #16]
    SC2Reg |= ADC_SC2_ACFE(Config->CompareEnable ? 1u : 0u);
    79a0:	9b00      	ldr	r3, [sp, #0]
    79a2:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
    79a6:	2b00      	cmp	r3, #0
    79a8:	d001      	beq.n	79ae <Adc_Ip_Init+0xb0>
    79aa:	2320      	movs	r3, #32
    79ac:	e000      	b.n	79b0 <Adc_Ip_Init+0xb2>
    79ae:	2300      	movs	r3, #0
    79b0:	9a05      	ldr	r2, [sp, #20]
    79b2:	4313      	orrs	r3, r2
    79b4:	9305      	str	r3, [sp, #20]
    SC2Reg |= ADC_SC2_ACFGT(Config->CompareGreaterThanEnable ? 1u : 0u);
    79b6:	9b00      	ldr	r3, [sp, #0]
    79b8:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
    79bc:	2b00      	cmp	r3, #0
    79be:	d001      	beq.n	79c4 <Adc_Ip_Init+0xc6>
    79c0:	2310      	movs	r3, #16
    79c2:	e000      	b.n	79c6 <Adc_Ip_Init+0xc8>
    79c4:	2300      	movs	r3, #0
    79c6:	9a05      	ldr	r2, [sp, #20]
    79c8:	4313      	orrs	r3, r2
    79ca:	9305      	str	r3, [sp, #20]
    SC2Reg |= ADC_SC2_ACREN(Config->CompareRangeFuncEnable ? 1u : 0u);
    79cc:	9b00      	ldr	r3, [sp, #0]
    79ce:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
    79d2:	2b00      	cmp	r3, #0
    79d4:	d001      	beq.n	79da <Adc_Ip_Init+0xdc>
    79d6:	2308      	movs	r3, #8
    79d8:	e000      	b.n	79dc <Adc_Ip_Init+0xde>
    79da:	2300      	movs	r3, #0
    79dc:	9a05      	ldr	r2, [sp, #20]
    79de:	4313      	orrs	r3, r2
    79e0:	9305      	str	r3, [sp, #20]
    Base->CV[0u] = ADC_CV_CV(Config->CompVal1);
    79e2:	9b00      	ldr	r3, [sp, #0]
    79e4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    79e6:	461a      	mov	r2, r3
    79e8:	9b02      	ldr	r3, [sp, #8]
    79ea:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    Base->CV[1u] = ADC_CV_CV(Config->CompVal2);
    79ee:	9b00      	ldr	r3, [sp, #0]
    79f0:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
    79f2:	461a      	mov	r2, r3
    79f4:	9b02      	ldr	r3, [sp, #8]
    79f6:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

    Adc_HwAcc_SetSC2Reg(Base, SC2ClearMask, SC2Reg);
    79fa:	9a05      	ldr	r2, [sp, #20]
    79fc:	9904      	ldr	r1, [sp, #16]
    79fe:	9802      	ldr	r0, [sp, #8]
    7a00:	f7ff fdd2 	bl	75a8 <Adc_HwAcc_SetSC2Reg>

    Adc_HwAcc_SetUserGainAndOffset(Base, Config->UsrGain, Config->UsrOffset);
    7a04:	9b00      	ldr	r3, [sp, #0]
    7a06:	8d99      	ldrh	r1, [r3, #44]	; 0x2c
    7a08:	9b00      	ldr	r3, [sp, #0]
    7a0a:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
    7a0c:	461a      	mov	r2, r3
    7a0e:	9802      	ldr	r0, [sp, #8]
    7a10:	f7ff fef6 	bl	7800 <Adc_HwAcc_SetUserGainAndOffset>

    Adc_Ip_SetContinuousMode(Instance, Config->ContinuousConvEnable);
    7a14:	9b00      	ldr	r3, [sp, #0]
    7a16:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
    7a1a:	4619      	mov	r1, r3
    7a1c:	9801      	ldr	r0, [sp, #4]
    7a1e:	f000 f955 	bl	7ccc <Adc_Ip_SetContinuousMode>

    if (Config->ChannelConfigs != NULL_PTR)
    7a22:	9b00      	ldr	r3, [sp, #0]
    7a24:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    7a26:	2b00      	cmp	r3, #0
    7a28:	d01c      	beq.n	7a64 <Adc_Ip_Init+0x166>
    {
        for (Index = 0u; Index < Config->NumChannels; Index++)
    7a2a:	2300      	movs	r3, #0
    7a2c:	f88d 300f 	strb.w	r3, [sp, #15]
    7a30:	e011      	b.n	7a56 <Adc_Ip_Init+0x158>
        {
            Adc_Ip_ConfigChannel(Instance, &(Config->ChannelConfigs[Index]));
    7a32:	9b00      	ldr	r3, [sp, #0]
    7a34:	6b59      	ldr	r1, [r3, #52]	; 0x34
    7a36:	f89d 200f 	ldrb.w	r2, [sp, #15]
    7a3a:	4613      	mov	r3, r2
    7a3c:	005b      	lsls	r3, r3, #1
    7a3e:	4413      	add	r3, r2
    7a40:	009b      	lsls	r3, r3, #2
    7a42:	440b      	add	r3, r1
    7a44:	4619      	mov	r1, r3
    7a46:	9801      	ldr	r0, [sp, #4]
    7a48:	f000 f9c2 	bl	7dd0 <Adc_Ip_ConfigChannel>
        for (Index = 0u; Index < Config->NumChannels; Index++)
    7a4c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    7a50:	3301      	adds	r3, #1
    7a52:	f88d 300f 	strb.w	r3, [sp, #15]
    7a56:	9b00      	ldr	r3, [sp, #0]
    7a58:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
    7a5c:	f89d 200f 	ldrb.w	r2, [sp, #15]
    7a60:	429a      	cmp	r2, r3
    7a62:	d3e6      	bcc.n	7a32 <Adc_Ip_Init+0x134>
        }
    }

#if (ADC_IP_AIEN_INTERRUPT_ENABLE == STD_ON)
    Adc_Ip_axState[Instance].ConversionCompleteNotification = Config->ConversionCompleteNotification;
    7a64:	9b00      	ldr	r3, [sp, #0]
    7a66:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    7a68:	490f      	ldr	r1, [pc, #60]	; (7aa8 <Adc_Ip_Init+0x1aa>)
    7a6a:	9b01      	ldr	r3, [sp, #4]
    7a6c:	204c      	movs	r0, #76	; 0x4c
    7a6e:	fb00 f303 	mul.w	r3, r0, r3
    7a72:	440b      	add	r3, r1
    7a74:	3308      	adds	r3, #8
    7a76:	601a      	str	r2, [r3, #0]
#endif /* (ADC_IP_AIEN_INTERRUPT_ENABLE == STD_ON) */
    Adc_Ip_axState[Instance].CalibrationClockDivide = Config->CalibrationClockDivide;
    7a78:	9b00      	ldr	r3, [sp, #0]
    7a7a:	685a      	ldr	r2, [r3, #4]
    7a7c:	490a      	ldr	r1, [pc, #40]	; (7aa8 <Adc_Ip_Init+0x1aa>)
    7a7e:	9b01      	ldr	r3, [sp, #4]
    7a80:	204c      	movs	r0, #76	; 0x4c
    7a82:	fb00 f303 	mul.w	r3, r0, r3
    7a86:	440b      	add	r3, r1
    7a88:	3304      	adds	r3, #4
    7a8a:	601a      	str	r2, [r3, #0]
    Adc_Ip_axState[Instance].Init = TRUE;
    7a8c:	4a06      	ldr	r2, [pc, #24]	; (7aa8 <Adc_Ip_Init+0x1aa>)
    7a8e:	9b01      	ldr	r3, [sp, #4]
    7a90:	214c      	movs	r1, #76	; 0x4c
    7a92:	fb01 f303 	mul.w	r3, r1, r3
    7a96:	4413      	add	r3, r2
    7a98:	2201      	movs	r2, #1
    7a9a:	701a      	strb	r2, [r3, #0]
#if (ADC_IP_ENABLE_SIM_SOURCE_SELECTION == STD_ON)
    Adc_Ip_axState[Instance].PretriggerSel = Config->PretriggerSel;
#endif /* (ADC_IP_ENABLE_SIM_SOURCE_SELECTION == STD_ON) */
}
    7a9c:	bf00      	nop
    7a9e:	b007      	add	sp, #28
    7aa0:	f85d fb04 	ldr.w	pc, [sp], #4
    7aa4:	000186bc 	.word	0x000186bc
    7aa8:	1fff8d04 	.word	0x1fff8d04

00007aac <Adc_Ip_DeInit>:
* Description   : This function resets the ADC internal registers to default values.
*
* @implements     Adc_Ip_Deinit_Activity
* END**************************************************************************/
void Adc_Ip_DeInit(const uint32 Instance)
{
    7aac:	b500      	push	{lr}
    7aae:	b0c3      	sub	sp, #268	; 0x10c
    7ab0:	ab42      	add	r3, sp, #264	; 0x108
    7ab2:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
    7ab6:	6018      	str	r0, [r3, #0]

    Adc_Ip_ConfigType DefaultConfig;
    Adc_Ip_ChanConfigType ChannelConfigs[ADC_MAX_CHAN_COUNT];
    uint8 Index;

    DefaultConfig.ClockDivide = ADC_IP_CLK_FULL_BUS;
    7ab8:	2300      	movs	r3, #0
    7aba:	9332      	str	r3, [sp, #200]	; 0xc8
    DefaultConfig.CalibrationClockDivide = ADC_IP_CLK_EIGHTH_BUS;
    7abc:	2303      	movs	r3, #3
    7abe:	9333      	str	r3, [sp, #204]	; 0xcc
    DefaultConfig.InputClock = ADC_IP_CLK_ALT_1;
    7ac0:	2300      	movs	r3, #0
    7ac2:	9334      	str	r3, [sp, #208]	; 0xd0
    DefaultConfig.SampleTime = ADC_IP_DEFAULT_SAMPLE_TIME;
    7ac4:	230c      	movs	r3, #12
    7ac6:	f88d 30d4 	strb.w	r3, [sp, #212]	; 0xd4
    DefaultConfig.AvgEn = FALSE;
    7aca:	2300      	movs	r3, #0
    7acc:	f88d 30d5 	strb.w	r3, [sp, #213]	; 0xd5
    DefaultConfig.AvgSel = ADC_IP_AVG_4_CONV;
    7ad0:	2300      	movs	r3, #0
    7ad2:	9336      	str	r3, [sp, #216]	; 0xd8
    DefaultConfig.Resolution = ADC_IP_RESOLUTION_8BIT;
    7ad4:	2300      	movs	r3, #0
    7ad6:	9337      	str	r3, [sp, #220]	; 0xdc
    DefaultConfig.TriggerMode = ADC_IP_TRIGGER_SOFTWARE;
    7ad8:	2300      	movs	r3, #0
    7ada:	9338      	str	r3, [sp, #224]	; 0xe0
#if (ADC_IP_ENABLE_SIM_SOURCE_SELECTION == STD_ON)
    DefaultConfig.PretriggerSel = ADC_IP_PRETRIGGER_SEL_PDB;
    DefaultConfig.TriggerSel = ADC_IP_TRIGGER_SEL_PDB;
#endif /* (ADC_IP_ENABLE_SIM_SOURCE_SELECTION == STD_ON) */
    DefaultConfig.DmaEnable = FALSE;
    7adc:	2300      	movs	r3, #0
    7ade:	f88d 30e4 	strb.w	r3, [sp, #228]	; 0xe4
    DefaultConfig.VoltageRef = ADC_IP_VOLTAGEREF_VREF;
    7ae2:	2300      	movs	r3, #0
    7ae4:	933a      	str	r3, [sp, #232]	; 0xe8
    DefaultConfig.ContinuousConvEnable = FALSE;
    7ae6:	2300      	movs	r3, #0
    7ae8:	f88d 30ec 	strb.w	r3, [sp, #236]	; 0xec
#if (ADC_IP_SUPPLY_MONITORING_ENABLED == STD_ON)
    DefaultConfig.SupplyMonitoringEnable = FALSE;
#endif /* (ADC_IP_SUPPLY_MONITORING_ENABLED == STD_ON) */
    DefaultConfig.CompareEnable = FALSE;
    7aec:	2300      	movs	r3, #0
    7aee:	f88d 30ed 	strb.w	r3, [sp, #237]	; 0xed
    DefaultConfig.CompareGreaterThanEnable = FALSE;
    7af2:	2300      	movs	r3, #0
    7af4:	f88d 30ee 	strb.w	r3, [sp, #238]	; 0xee
    DefaultConfig.CompareRangeFuncEnable = FALSE;
    7af8:	2300      	movs	r3, #0
    7afa:	f88d 30ef 	strb.w	r3, [sp, #239]	; 0xef
    DefaultConfig.CompVal1 = 0u;
    7afe:	2300      	movs	r3, #0
    7b00:	f8ad 30f0 	strh.w	r3, [sp, #240]	; 0xf0
    DefaultConfig.CompVal2 = 0u;
    7b04:	2300      	movs	r3, #0
    7b06:	f8ad 30f2 	strh.w	r3, [sp, #242]	; 0xf2
    DefaultConfig.UsrGain = ADC_IP_DEFAULT_USER_GAIN;
    7b0a:	2304      	movs	r3, #4
    7b0c:	f8ad 30f4 	strh.w	r3, [sp, #244]	; 0xf4
    DefaultConfig.UsrOffset = 0u;
    7b10:	2300      	movs	r3, #0
    7b12:	f8ad 30f6 	strh.w	r3, [sp, #246]	; 0xf6
    DefaultConfig.NumChannels = ADC_MAX_CHAN_COUNT;
    7b16:	2310      	movs	r3, #16
    7b18:	f88d 30f8 	strb.w	r3, [sp, #248]	; 0xf8
    for (Index = 0u; Index < ADC_MAX_CHAN_COUNT; Index++)
    7b1c:	2300      	movs	r3, #0
    7b1e:	f88d 3107 	strb.w	r3, [sp, #263]	; 0x107
    7b22:	e02b      	b.n	7b7c <Adc_Ip_DeInit+0xd0>
    {
        ChannelConfigs[Index].ChnIdx = Index;
    7b24:	f89d 2107 	ldrb.w	r2, [sp, #263]	; 0x107
    7b28:	ab42      	add	r3, sp, #264	; 0x108
    7b2a:	f5a3 7180 	sub.w	r1, r3, #256	; 0x100
    7b2e:	4613      	mov	r3, r2
    7b30:	005b      	lsls	r3, r3, #1
    7b32:	4413      	add	r3, r2
    7b34:	009b      	lsls	r3, r3, #2
    7b36:	440b      	add	r3, r1
    7b38:	f89d 2107 	ldrb.w	r2, [sp, #263]	; 0x107
    7b3c:	701a      	strb	r2, [r3, #0]
        ChannelConfigs[Index].Channel = ADC_IP_INPUTCHAN_DISABLED;
    7b3e:	f89d 2107 	ldrb.w	r2, [sp, #263]	; 0x107
    7b42:	ab42      	add	r3, sp, #264	; 0x108
    7b44:	f5a3 7180 	sub.w	r1, r3, #256	; 0x100
    7b48:	4613      	mov	r3, r2
    7b4a:	005b      	lsls	r3, r3, #1
    7b4c:	4413      	add	r3, r2
    7b4e:	009b      	lsls	r3, r3, #2
    7b50:	440b      	add	r3, r1
    7b52:	3304      	adds	r3, #4
    7b54:	221f      	movs	r2, #31
    7b56:	601a      	str	r2, [r3, #0]
#if (ADC_IP_AIEN_INTERRUPT_ENABLE == STD_ON)
        ChannelConfigs[Index].InterruptEnable = FALSE;
    7b58:	f89d 2107 	ldrb.w	r2, [sp, #263]	; 0x107
    7b5c:	ab42      	add	r3, sp, #264	; 0x108
    7b5e:	f5a3 7180 	sub.w	r1, r3, #256	; 0x100
    7b62:	4613      	mov	r3, r2
    7b64:	005b      	lsls	r3, r3, #1
    7b66:	4413      	add	r3, r2
    7b68:	009b      	lsls	r3, r3, #2
    7b6a:	440b      	add	r3, r1
    7b6c:	3308      	adds	r3, #8
    7b6e:	2200      	movs	r2, #0
    7b70:	701a      	strb	r2, [r3, #0]
    for (Index = 0u; Index < ADC_MAX_CHAN_COUNT; Index++)
    7b72:	f89d 3107 	ldrb.w	r3, [sp, #263]	; 0x107
    7b76:	3301      	adds	r3, #1
    7b78:	f88d 3107 	strb.w	r3, [sp, #263]	; 0x107
    7b7c:	f89d 3107 	ldrb.w	r3, [sp, #263]	; 0x107
    7b80:	2b0f      	cmp	r3, #15
    7b82:	d9cf      	bls.n	7b24 <Adc_Ip_DeInit+0x78>
#endif /* (ADC_IP_AIEN_INTERRUPT_ENABLE == STD_ON) */
    }
    DefaultConfig.ChannelConfigs = ChannelConfigs;
    7b84:	ab02      	add	r3, sp, #8
    7b86:	933f      	str	r3, [sp, #252]	; 0xfc
#if (ADC_IP_AIEN_INTERRUPT_ENABLE == STD_ON)
    DefaultConfig.ConversionCompleteNotification = NULL_PTR;
    7b88:	2300      	movs	r3, #0
    7b8a:	9340      	str	r3, [sp, #256]	; 0x100
#endif /* (ADC_IP_AIEN_INTERRUPT_ENABLE == STD_ON) */

    Adc_Ip_Init(Instance, &DefaultConfig);
    7b8c:	aa32      	add	r2, sp, #200	; 0xc8
    7b8e:	ab42      	add	r3, sp, #264	; 0x108
    7b90:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
    7b94:	4611      	mov	r1, r2
    7b96:	6818      	ldr	r0, [r3, #0]
    7b98:	f7ff feb1 	bl	78fe <Adc_Ip_Init>
    {
        ADC_ResetSupplyMonitoringChannel();
    }
#endif /* (ADC_IP_SUPPLY_MONITORING_ENABLED == STD_ON) */

    Adc_Ip_axState[Instance].Init = FALSE;
    7b9c:	4a07      	ldr	r2, [pc, #28]	; (7bbc <Adc_Ip_DeInit+0x110>)
    7b9e:	ab42      	add	r3, sp, #264	; 0x108
    7ba0:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
    7ba4:	681b      	ldr	r3, [r3, #0]
    7ba6:	214c      	movs	r1, #76	; 0x4c
    7ba8:	fb01 f303 	mul.w	r3, r1, r3
    7bac:	4413      	add	r3, r2
    7bae:	2200      	movs	r2, #0
    7bb0:	701a      	strb	r2, [r3, #0]
}
    7bb2:	bf00      	nop
    7bb4:	b043      	add	sp, #268	; 0x10c
    7bb6:	f85d fb04 	ldr.w	pc, [sp], #4
    7bba:	bf00      	nop
    7bbc:	1fff8d04 	.word	0x1fff8d04

00007bc0 <Adc_Ip_SetAveraging>:
* @implements     Adc_Ip_SetAveraging_Activity
* END**************************************************************************/
void Adc_Ip_SetAveraging(const uint32 Instance,
                         const boolean AvgEn,
                         const Adc_Ip_AvgSelectType AvgSel)
{
    7bc0:	b500      	push	{lr}
    7bc2:	b087      	sub	sp, #28
    7bc4:	9003      	str	r0, [sp, #12]
    7bc6:	460b      	mov	r3, r1
    7bc8:	9201      	str	r2, [sp, #4]
    7bca:	f88d 300b 	strb.w	r3, [sp, #11]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7bce:	4a0a      	ldr	r2, [pc, #40]	; (7bf8 <Adc_Ip_SetAveraging+0x38>)
    7bd0:	9b03      	ldr	r3, [sp, #12]
    7bd2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7bd6:	9305      	str	r3, [sp, #20]

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_27();
    7bd8:	f009 fa1c 	bl	11014 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_27>
    Adc_HwAcc_SetAveraging(Base, AvgEn, AvgSel);
    7bdc:	f89d 300b 	ldrb.w	r3, [sp, #11]
    7be0:	9a01      	ldr	r2, [sp, #4]
    7be2:	4619      	mov	r1, r3
    7be4:	9805      	ldr	r0, [sp, #20]
    7be6:	f7ff fd73 	bl	76d0 <Adc_HwAcc_SetAveraging>
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_27();
    7bea:	f009 fa3f 	bl	1106c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_27>
}
    7bee:	bf00      	nop
    7bf0:	b007      	add	sp, #28
    7bf2:	f85d fb04 	ldr.w	pc, [sp], #4
    7bf6:	bf00      	nop
    7bf8:	000186bc 	.word	0x000186bc

00007bfc <Adc_Ip_SetSampleTime>:
*
* @implements     Adc_Ip_SetSampleTime_Activity
* END**************************************************************************/
void Adc_Ip_SetSampleTime(const uint32 Instance,
                          const uint8 SampleTime)
{
    7bfc:	b500      	push	{lr}
    7bfe:	b085      	sub	sp, #20
    7c00:	9001      	str	r0, [sp, #4]
    7c02:	460b      	mov	r3, r1
    7c04:	f88d 3003 	strb.w	r3, [sp, #3]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7c08:	4a09      	ldr	r2, [pc, #36]	; (7c30 <Adc_Ip_SetSampleTime+0x34>)
    7c0a:	9b01      	ldr	r3, [sp, #4]
    7c0c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7c10:	9303      	str	r3, [sp, #12]

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_16();
    7c12:	f008 fe79 	bl	10908 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_16>
    Adc_HwAcc_SetSampleTime(Base, SampleTime);
    7c16:	f89d 3003 	ldrb.w	r3, [sp, #3]
    7c1a:	4619      	mov	r1, r3
    7c1c:	9803      	ldr	r0, [sp, #12]
    7c1e:	f7ff fd36 	bl	768e <Adc_HwAcc_SetSampleTime>
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_16();
    7c22:	f008 fe9d 	bl	10960 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_16>
}
    7c26:	bf00      	nop
    7c28:	b005      	add	sp, #20
    7c2a:	f85d fb04 	ldr.w	pc, [sp], #4
    7c2e:	bf00      	nop
    7c30:	000186bc 	.word	0x000186bc

00007c34 <Adc_Ip_EnableDma>:
* Description   : This function enables DMA.
*
* @implements     Adc_Ip_EnableDma_Activity
* END**************************************************************************/
void Adc_Ip_EnableDma(const uint32 Instance)
{
    7c34:	b500      	push	{lr}
    7c36:	b085      	sub	sp, #20
    7c38:	9001      	str	r0, [sp, #4]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7c3a:	4a0a      	ldr	r2, [pc, #40]	; (7c64 <Adc_Ip_EnableDma+0x30>)
    7c3c:	9b01      	ldr	r3, [sp, #4]
    7c3e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7c42:	9303      	str	r3, [sp, #12]

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_26();
    7c44:	f009 f994 	bl	10f70 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_26>
    Base->SC2 |= ADC_SC2_DMAEN_MASK;
    7c48:	9b03      	ldr	r3, [sp, #12]
    7c4a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
    7c4e:	f043 0204 	orr.w	r2, r3, #4
    7c52:	9b03      	ldr	r3, [sp, #12]
    7c54:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_26();
    7c58:	f009 f9b6 	bl	10fc8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_26>
}
    7c5c:	bf00      	nop
    7c5e:	b005      	add	sp, #20
    7c60:	f85d fb04 	ldr.w	pc, [sp], #4
    7c64:	000186bc 	.word	0x000186bc

00007c68 <Adc_Ip_DisableDma>:
* Description   : This function disables DMA.
*
* @implements     Adc_Ip_DisableDma_Activity
* END**************************************************************************/
void Adc_Ip_DisableDma(const uint32 Instance)
{
    7c68:	b500      	push	{lr}
    7c6a:	b085      	sub	sp, #20
    7c6c:	9001      	str	r0, [sp, #4]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7c6e:	4a0a      	ldr	r2, [pc, #40]	; (7c98 <Adc_Ip_DisableDma+0x30>)
    7c70:	9b01      	ldr	r3, [sp, #4]
    7c72:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7c76:	9303      	str	r3, [sp, #12]

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_22();
    7c78:	f009 f832 	bl	10ce0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_22>
    Base->SC2 &= ~(ADC_SC2_DMAEN_MASK);
    7c7c:	9b03      	ldr	r3, [sp, #12]
    7c7e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
    7c82:	f023 0204 	bic.w	r2, r3, #4
    7c86:	9b03      	ldr	r3, [sp, #12]
    7c88:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_22();
    7c8c:	f009 f854 	bl	10d38 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_22>
}
    7c90:	bf00      	nop
    7c92:	b005      	add	sp, #20
    7c94:	f85d fb04 	ldr.w	pc, [sp], #4
    7c98:	000186bc 	.word	0x000186bc

00007c9c <Adc_Ip_SetTriggerMode>:
*
* @implements     Adc_Ip_SetTriggerMode_Activity
* END**************************************************************************/
void Adc_Ip_SetTriggerMode(const uint32 Instance,
                           const Adc_Ip_TrigType TriggerMode)
{
    7c9c:	b500      	push	{lr}
    7c9e:	b085      	sub	sp, #20
    7ca0:	9001      	str	r0, [sp, #4]
    7ca2:	9100      	str	r1, [sp, #0]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7ca4:	4a08      	ldr	r2, [pc, #32]	; (7cc8 <Adc_Ip_SetTriggerMode+0x2c>)
    7ca6:	9b01      	ldr	r3, [sp, #4]
    7ca8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7cac:	9303      	str	r3, [sp, #12]

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_23();
    7cae:	f009 f869 	bl	10d84 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_23>
    Adc_HwAcc_SetTriggerMode(Base, TriggerMode);
    7cb2:	9900      	ldr	r1, [sp, #0]
    7cb4:	9803      	ldr	r0, [sp, #12]
    7cb6:	f7ff fd4e 	bl	7756 <Adc_HwAcc_SetTriggerMode>
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_23();
    7cba:	f009 f88f 	bl	10ddc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_23>
}
    7cbe:	bf00      	nop
    7cc0:	b005      	add	sp, #20
    7cc2:	f85d fb04 	ldr.w	pc, [sp], #4
    7cc6:	bf00      	nop
    7cc8:	000186bc 	.word	0x000186bc

00007ccc <Adc_Ip_SetContinuousMode>:
*
* @implements     Adc_Ip_SetContinuousMode_Activity
* END**************************************************************************/
void Adc_Ip_SetContinuousMode(const uint32 Instance,
                              const boolean ContinuousModeEnable)
{
    7ccc:	b500      	push	{lr}
    7cce:	b085      	sub	sp, #20
    7cd0:	9001      	str	r0, [sp, #4]
    7cd2:	460b      	mov	r3, r1
    7cd4:	f88d 3003 	strb.w	r3, [sp, #3]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7cd8:	4a11      	ldr	r2, [pc, #68]	; (7d20 <Adc_Ip_SetContinuousMode+0x54>)
    7cda:	9b01      	ldr	r3, [sp, #4]
    7cdc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7ce0:	9303      	str	r3, [sp, #12]

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_30();
    7ce2:	f009 fa8d 	bl	11200 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_30>
    uint32 Sc3Reg = Base->SC3;
    7ce6:	9b03      	ldr	r3, [sp, #12]
    7ce8:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
    7cec:	9302      	str	r3, [sp, #8]
    Sc3Reg &= ~(ADC_SC3_ADCO_MASK);
    7cee:	9b02      	ldr	r3, [sp, #8]
    7cf0:	f023 0308 	bic.w	r3, r3, #8
    7cf4:	9302      	str	r3, [sp, #8]
    Sc3Reg |= ADC_SC3_ADCO(ContinuousModeEnable ? 1u : 0u);
    7cf6:	f89d 3003 	ldrb.w	r3, [sp, #3]
    7cfa:	2b00      	cmp	r3, #0
    7cfc:	d001      	beq.n	7d02 <Adc_Ip_SetContinuousMode+0x36>
    7cfe:	2308      	movs	r3, #8
    7d00:	e000      	b.n	7d04 <Adc_Ip_SetContinuousMode+0x38>
    7d02:	2300      	movs	r3, #0
    7d04:	9a02      	ldr	r2, [sp, #8]
    7d06:	4313      	orrs	r3, r2
    7d08:	9302      	str	r3, [sp, #8]
    Base->SC3 = Sc3Reg;
    7d0a:	9b03      	ldr	r3, [sp, #12]
    7d0c:	9a02      	ldr	r2, [sp, #8]
    7d0e:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_30();
    7d12:	f009 faa1 	bl	11258 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_30>
}
    7d16:	bf00      	nop
    7d18:	b005      	add	sp, #20
    7d1a:	f85d fb04 	ldr.w	pc, [sp], #4
    7d1e:	bf00      	nop
    7d20:	000186bc 	.word	0x000186bc

00007d24 <Adc_Ip_SetResolution>:
*
* @implements     Adc_Ip_SetResolution_Activity
* END**************************************************************************/
void Adc_Ip_SetResolution(const uint32 Instance,
                          const Adc_Ip_ResolutionType Resolution)
{
    7d24:	b500      	push	{lr}
    7d26:	b085      	sub	sp, #20
    7d28:	9001      	str	r0, [sp, #4]
    7d2a:	9100      	str	r1, [sp, #0]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7d2c:	4a0e      	ldr	r2, [pc, #56]	; (7d68 <Adc_Ip_SetResolution+0x44>)
    7d2e:	9b01      	ldr	r3, [sp, #4]
    7d30:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7d34:	9303      	str	r3, [sp, #12]

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_10();
    7d36:	f008 fab3 	bl	102a0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_10>
    uint32 Cfg1Reg = Base->CFG1;
    7d3a:	9b03      	ldr	r3, [sp, #12]
    7d3c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    7d3e:	9302      	str	r3, [sp, #8]
    Cfg1Reg &= ~(ADC_CFG1_MODE_MASK);
    7d40:	9b02      	ldr	r3, [sp, #8]
    7d42:	f023 030c 	bic.w	r3, r3, #12
    7d46:	9302      	str	r3, [sp, #8]
    Cfg1Reg |= ADC_CFG1_MODE(Resolution);
    7d48:	9b00      	ldr	r3, [sp, #0]
    7d4a:	009b      	lsls	r3, r3, #2
    7d4c:	f003 030c 	and.w	r3, r3, #12
    7d50:	9a02      	ldr	r2, [sp, #8]
    7d52:	4313      	orrs	r3, r2
    7d54:	9302      	str	r3, [sp, #8]
    Base->CFG1 = Cfg1Reg;
    7d56:	9b03      	ldr	r3, [sp, #12]
    7d58:	9a02      	ldr	r2, [sp, #8]
    7d5a:	641a      	str	r2, [r3, #64]	; 0x40
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_10();
    7d5c:	f008 facc 	bl	102f8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_10>
}
    7d60:	bf00      	nop
    7d62:	b005      	add	sp, #20
    7d64:	f85d fb04 	ldr.w	pc, [sp], #4
    7d68:	000186bc 	.word	0x000186bc

00007d6c <Adc_Ip_SetClockMode>:
*
* @implements     Adc_Ip_SetClockMode_Activity
* END**************************************************************************/
void Adc_Ip_SetClockMode(const uint32 Instance,
                         const Adc_Ip_ClockConfigType * const Config)
{
    7d6c:	b500      	push	{lr}
    7d6e:	b085      	sub	sp, #20
    7d70:	9001      	str	r0, [sp, #4]
    7d72:	9100      	str	r1, [sp, #0]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
    DevAssert(Config != NULL_PTR);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7d74:	4a15      	ldr	r2, [pc, #84]	; (7dcc <Adc_Ip_SetClockMode+0x60>)
    7d76:	9b01      	ldr	r3, [sp, #4]
    7d78:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7d7c:	9303      	str	r3, [sp, #12]

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_11();
    7d7e:	f008 fc29 	bl	105d4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_11>
    Adc_HwAcc_SetClock(Base, Config->ClockDivide, Config->InputClock);
    7d82:	9b00      	ldr	r3, [sp, #0]
    7d84:	6819      	ldr	r1, [r3, #0]
    7d86:	9b00      	ldr	r3, [sp, #0]
    7d88:	685b      	ldr	r3, [r3, #4]
    7d8a:	461a      	mov	r2, r3
    7d8c:	9803      	ldr	r0, [sp, #12]
    7d8e:	f7ff fc23 	bl	75d8 <Adc_HwAcc_SetClock>
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_11();
    7d92:	f008 fc4b 	bl	1062c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_11>

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_14();
    7d96:	f008 fd13 	bl	107c0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_14>
    Adc_HwAcc_SetSampleTime(Base, Config->SampleTime);
    7d9a:	9b00      	ldr	r3, [sp, #0]
    7d9c:	7a1b      	ldrb	r3, [r3, #8]
    7d9e:	4619      	mov	r1, r3
    7da0:	9803      	ldr	r0, [sp, #12]
    7da2:	f7ff fc74 	bl	768e <Adc_HwAcc_SetSampleTime>
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_14();
    7da6:	f008 fd37 	bl	10818 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_14>

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_28();
    7daa:	f009 f985 	bl	110b8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_28>
    Adc_HwAcc_SetAveraging(Base, Config->AvgEn, Config->AvgSel);
    7dae:	9b00      	ldr	r3, [sp, #0]
    7db0:	7a59      	ldrb	r1, [r3, #9]
    7db2:	9b00      	ldr	r3, [sp, #0]
    7db4:	68db      	ldr	r3, [r3, #12]
    7db6:	461a      	mov	r2, r3
    7db8:	9803      	ldr	r0, [sp, #12]
    7dba:	f7ff fc89 	bl	76d0 <Adc_HwAcc_SetAveraging>
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_28();
    7dbe:	f009 f9a7 	bl	11110 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_28>
}
    7dc2:	bf00      	nop
    7dc4:	b005      	add	sp, #20
    7dc6:	f85d fb04 	ldr.w	pc, [sp], #4
    7dca:	bf00      	nop
    7dcc:	000186bc 	.word	0x000186bc

00007dd0 <Adc_Ip_ConfigChannel>:
*
* @implements     Adc_Ip_ConfigChannel_Activity
* END**************************************************************************/
void Adc_Ip_ConfigChannel(const uint32 Instance,
                          const Adc_Ip_ChanConfigType * const ChanConfig)
{
    7dd0:	b510      	push	{r4, lr}
    7dd2:	b084      	sub	sp, #16
    7dd4:	9001      	str	r0, [sp, #4]
    7dd6:	9100      	str	r1, [sp, #0]
#if (ADC_IP_SUPPLY_MONITORING_ENABLED == STD_ON)
    DevAssert((Instance == 0u) || ((uint32)ChanConfig->Channel < (uint32)ADC_IP_INPUTCHAN_SUPPLY_VDD));
#endif /* (ADC_IP_SUPPLY_MONITORING_ENABLED == STD_ON) */
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7dd8:	4a13      	ldr	r2, [pc, #76]	; (7e28 <Adc_Ip_ConfigChannel+0x58>)
    7dda:	9b01      	ldr	r3, [sp, #4]
    7ddc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7de0:	9303      	str	r3, [sp, #12]
        InputChanDemapped = ADC_IP_INPUTCHAN_INT0;
    }
    else
#endif /* (ADC_IP_SUPPLY_MONITORING_ENABLED == STD_ON) */
    {
        InputChanDemapped = ChanConfig->Channel;
    7de2:	9b00      	ldr	r3, [sp, #0]
    7de4:	685b      	ldr	r3, [r3, #4]
    7de6:	9302      	str	r3, [sp, #8]
    }

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_21();
    7de8:	f008 ff28 	bl	10c3c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_21>
#if (ADC_IP_AIEN_INTERRUPT_ENABLE == STD_ON)
    Adc_HwAcc_SetChannel(Base, ChanConfig->ChnIdx, InputChanDemapped, ChanConfig->InterruptEnable);
    7dec:	9b00      	ldr	r3, [sp, #0]
    7dee:	7819      	ldrb	r1, [r3, #0]
    7df0:	9b00      	ldr	r3, [sp, #0]
    7df2:	7a1b      	ldrb	r3, [r3, #8]
    7df4:	9a02      	ldr	r2, [sp, #8]
    7df6:	9803      	ldr	r0, [sp, #12]
    7df8:	f7ff fcd5 	bl	77a6 <Adc_HwAcc_SetChannel>
#else
    Adc_HwAcc_SetChannel(Base, ChanConfig->ChnIdx, InputChanDemapped, FALSE);
#endif /* (ADC_IP_AIEN_INTERRUPT_ENABLE == STD_ON) */
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_21();
    7dfc:	f008 ff4a 	bl	10c94 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_21>

    /* Also update in state structure */
    Adc_Ip_axState[Instance].ChannelConfig[ChanConfig->ChnIdx] = ChanConfig->Channel;
    7e00:	9b00      	ldr	r3, [sp, #0]
    7e02:	781b      	ldrb	r3, [r3, #0]
    7e04:	461c      	mov	r4, r3
    7e06:	9b00      	ldr	r3, [sp, #0]
    7e08:	6859      	ldr	r1, [r3, #4]
    7e0a:	4808      	ldr	r0, [pc, #32]	; (7e2c <Adc_Ip_ConfigChannel+0x5c>)
    7e0c:	9a01      	ldr	r2, [sp, #4]
    7e0e:	4613      	mov	r3, r2
    7e10:	00db      	lsls	r3, r3, #3
    7e12:	4413      	add	r3, r2
    7e14:	005b      	lsls	r3, r3, #1
    7e16:	4413      	add	r3, r2
    7e18:	4423      	add	r3, r4
    7e1a:	3302      	adds	r3, #2
    7e1c:	009b      	lsls	r3, r3, #2
    7e1e:	4403      	add	r3, r0
    7e20:	6059      	str	r1, [r3, #4]
}
    7e22:	bf00      	nop
    7e24:	b004      	add	sp, #16
    7e26:	bd10      	pop	{r4, pc}
    7e28:	000186bc 	.word	0x000186bc
    7e2c:	1fff8d04 	.word	0x1fff8d04

00007e30 <Adc_Ip_SetDisabledChannel>:
* @implements     Adc_Ip_SetDisabledChannel_Activity
* END**************************************************************************/
Adc_Ip_StatusType Adc_Ip_SetDisabledChannel(const uint32 Instance,
                                            const uint8 ControlChanIdx,
                                            const boolean WithTimeout)
{
    7e30:	b500      	push	{lr}
    7e32:	b089      	sub	sp, #36	; 0x24
    7e34:	9001      	str	r0, [sp, #4]
    7e36:	460b      	mov	r3, r1
    7e38:	f88d 3003 	strb.w	r3, [sp, #3]
    7e3c:	4613      	mov	r3, r2
    7e3e:	f88d 3002 	strb.w	r3, [sp, #2]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
    DevAssert(ControlChanIdx < ADC_MAX_CHAN_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7e42:	4a24      	ldr	r2, [pc, #144]	; (7ed4 <Adc_Ip_SetDisabledChannel+0xa4>)
    7e44:	9b01      	ldr	r3, [sp, #4]
    7e46:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7e4a:	9305      	str	r3, [sp, #20]
    Adc_Ip_StatusType Status = ADC_IP_STATUS_SUCCESS;
    7e4c:	2300      	movs	r3, #0
    7e4e:	9307      	str	r3, [sp, #28]
    uint32 TimeoutTicks = OsIf_MicrosToTicks(ADC_IP_TIMEOUT_VAL, ADC_IP_TIMEOUT_TYPE);
    7e50:	2100      	movs	r1, #0
    7e52:	4821      	ldr	r0, [pc, #132]	; (7ed8 <Adc_Ip_SetDisabledChannel+0xa8>)
    7e54:	f7fa f8b6 	bl	1fc4 <OsIf_MicrosToTicks>
    7e58:	9004      	str	r0, [sp, #16]
    uint32 CurrentTicks = OsIf_GetCounter(ADC_IP_TIMEOUT_TYPE);
    7e5a:	2000      	movs	r0, #0
    7e5c:	f7fa f866 	bl	1f2c <OsIf_GetCounter>
    7e60:	4603      	mov	r3, r0
    7e62:	9303      	str	r3, [sp, #12]
    uint32 ElapsedTicks = 0u;
    7e64:	2300      	movs	r3, #0
    7e66:	9306      	str	r3, [sp, #24]

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_17();
    7e68:	f008 fda0 	bl	109ac <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_17>
    /* Set input channel select to disabled */
    SC1(Base, ControlChanIdx) |= ADC_SC1_ADCH_MASK;
    7e6c:	f89d 2003 	ldrb.w	r2, [sp, #3]
    7e70:	9b05      	ldr	r3, [sp, #20]
    7e72:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    7e76:	f89d 2003 	ldrb.w	r2, [sp, #3]
    7e7a:	f043 011f 	orr.w	r1, r3, #31
    7e7e:	9b05      	ldr	r3, [sp, #20]
    7e80:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_17();
    7e84:	f008 fdbe 	bl	10a04 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_17>

    if (WithTimeout == TRUE)
    7e88:	f89d 3002 	ldrb.w	r3, [sp, #2]
    7e8c:	2b00      	cmp	r3, #0
    7e8e:	d01c      	beq.n	7eca <Adc_Ip_SetDisabledChannel+0x9a>
    {
        while (((SC1(Base, ControlChanIdx) & ADC_SC1_ADCH_MASK) != ADC_SC1_ADCH_MASK) && (ElapsedTicks < TimeoutTicks))
    7e90:	e008      	b.n	7ea4 <Adc_Ip_SetDisabledChannel+0x74>
        {
            ElapsedTicks += OsIf_GetElapsed(&CurrentTicks, ADC_IP_TIMEOUT_TYPE);
    7e92:	ab03      	add	r3, sp, #12
    7e94:	2100      	movs	r1, #0
    7e96:	4618      	mov	r0, r3
    7e98:	f7fa f861 	bl	1f5e <OsIf_GetElapsed>
    7e9c:	4602      	mov	r2, r0
    7e9e:	9b06      	ldr	r3, [sp, #24]
    7ea0:	4413      	add	r3, r2
    7ea2:	9306      	str	r3, [sp, #24]
        while (((SC1(Base, ControlChanIdx) & ADC_SC1_ADCH_MASK) != ADC_SC1_ADCH_MASK) && (ElapsedTicks < TimeoutTicks))
    7ea4:	f89d 2003 	ldrb.w	r2, [sp, #3]
    7ea8:	9b05      	ldr	r3, [sp, #20]
    7eaa:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    7eae:	f003 031f 	and.w	r3, r3, #31
    7eb2:	2b1f      	cmp	r3, #31
    7eb4:	d003      	beq.n	7ebe <Adc_Ip_SetDisabledChannel+0x8e>
    7eb6:	9a06      	ldr	r2, [sp, #24]
    7eb8:	9b04      	ldr	r3, [sp, #16]
    7eba:	429a      	cmp	r2, r3
    7ebc:	d3e9      	bcc.n	7e92 <Adc_Ip_SetDisabledChannel+0x62>
        }
        if (ElapsedTicks >= TimeoutTicks)
    7ebe:	9a06      	ldr	r2, [sp, #24]
    7ec0:	9b04      	ldr	r3, [sp, #16]
    7ec2:	429a      	cmp	r2, r3
    7ec4:	d301      	bcc.n	7eca <Adc_Ip_SetDisabledChannel+0x9a>
        {
            Status = ADC_IP_STATUS_TIMEOUT;
    7ec6:	2302      	movs	r3, #2
    7ec8:	9307      	str	r3, [sp, #28]
        }
    }

    return Status;
    7eca:	9b07      	ldr	r3, [sp, #28]
}
    7ecc:	4618      	mov	r0, r3
    7ece:	b009      	add	sp, #36	; 0x24
    7ed0:	f85d fb04 	ldr.w	pc, [sp], #4
    7ed4:	000186bc 	.word	0x000186bc
    7ed8:	000186a0 	.word	0x000186a0

00007edc <Adc_Ip_StartConversion>:
* @implements     Adc_Ip_StartConversion_Activity
* END**************************************************************************/
void Adc_Ip_StartConversion(const uint32 Instance,
                            Adc_Ip_InputChannelType InputChannel,
                            const boolean InterruptEnable)
{
    7edc:	b500      	push	{lr}
    7ede:	b087      	sub	sp, #28
    7ee0:	9003      	str	r0, [sp, #12]
    7ee2:	9102      	str	r1, [sp, #8]
    7ee4:	4613      	mov	r3, r2
    7ee6:	f88d 3007 	strb.w	r3, [sp, #7]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7eea:	4a0a      	ldr	r2, [pc, #40]	; (7f14 <Adc_Ip_StartConversion+0x38>)
    7eec:	9b03      	ldr	r3, [sp, #12]
    7eee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7ef2:	9305      	str	r3, [sp, #20]

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_18();
    7ef4:	f008 fdac 	bl	10a50 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_18>
    /* Configure SC1A register */
#if (ADC_IP_AIEN_INTERRUPT_ENABLE == STD_ON)
    Adc_HwAcc_SetChannel(Base, 0u, InputChannel, InterruptEnable);
    7ef8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7efc:	9a02      	ldr	r2, [sp, #8]
    7efe:	2100      	movs	r1, #0
    7f00:	9805      	ldr	r0, [sp, #20]
    7f02:	f7ff fc50 	bl	77a6 <Adc_HwAcc_SetChannel>
#else
    Adc_HwAcc_SetChannel(Base, 0u, InputChannel, FALSE);
    (void)InterruptEnable;
#endif /* (ADC_IP_AIEN_INTERRUPT_ENABLE == STD_ON) */
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_18();
    7f06:	f008 fdcf 	bl	10aa8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_18>
}
    7f0a:	bf00      	nop
    7f0c:	b007      	add	sp, #28
    7f0e:	f85d fb04 	ldr.w	pc, [sp], #4
    7f12:	bf00      	nop
    7f14:	000186bc 	.word	0x000186bc

00007f18 <Adc_Ip_GetConvActiveFlag>:
* Description   : Reads and return conversion active flag status.
*
* @implements     Adc_Ip_GetConvActiveFlag_Activity
* END**************************************************************************/
boolean Adc_Ip_GetConvActiveFlag(const uint32 Instance)
{
    7f18:	b084      	sub	sp, #16
    7f1a:	9001      	str	r0, [sp, #4]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    const ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7f1c:	4a0b      	ldr	r2, [pc, #44]	; (7f4c <Adc_Ip_GetConvActiveFlag+0x34>)
    7f1e:	9b01      	ldr	r3, [sp, #4]
    7f20:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7f24:	9303      	str	r3, [sp, #12]
    uint32 Sc2Reg = Base->SC2;
    7f26:	9b03      	ldr	r3, [sp, #12]
    7f28:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
    7f2c:	9302      	str	r3, [sp, #8]

    Sc2Reg = (Sc2Reg & ADC_SC2_ADACT_MASK) >> ADC_SC2_ADACT_SHIFT;
    7f2e:	9b02      	ldr	r3, [sp, #8]
    7f30:	09db      	lsrs	r3, r3, #7
    7f32:	f003 0301 	and.w	r3, r3, #1
    7f36:	9302      	str	r3, [sp, #8]

    return (Sc2Reg != 0u) ? TRUE : FALSE;
    7f38:	9b02      	ldr	r3, [sp, #8]
    7f3a:	2b00      	cmp	r3, #0
    7f3c:	bf14      	ite	ne
    7f3e:	2301      	movne	r3, #1
    7f40:	2300      	moveq	r3, #0
    7f42:	b2db      	uxtb	r3, r3
}
    7f44:	4618      	mov	r0, r3
    7f46:	b004      	add	sp, #16
    7f48:	4770      	bx	lr
    7f4a:	bf00      	nop
    7f4c:	000186bc 	.word	0x000186bc

00007f50 <Adc_Ip_GetChanInterrupt>:
*
* @implements     Adc_Ip_GetChanInterrupt_Activity
* END**************************************************************************/
boolean Adc_Ip_GetChanInterrupt(const uint32 Instance,
                                const uint8 ControlChanIdx)
{
    7f50:	b500      	push	{lr}
    7f52:	b085      	sub	sp, #20
    7f54:	9001      	str	r0, [sp, #4]
    7f56:	460b      	mov	r3, r1
    7f58:	f88d 3003 	strb.w	r3, [sp, #3]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
    DevAssert(ControlChanIdx < ADC_MAX_CHAN_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    const uint32 Sc1Reg = SC1(Adc_Ip_apxBase[Instance], ControlChanIdx);
    7f5c:	4a08      	ldr	r2, [pc, #32]	; (7f80 <Adc_Ip_GetChanInterrupt+0x30>)
    7f5e:	9b01      	ldr	r3, [sp, #4]
    7f60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7f64:	f89d 2003 	ldrb.w	r2, [sp, #3]
    7f68:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    7f6c:	9303      	str	r3, [sp, #12]

    return Adc_HwAcc_GetAIEN(Sc1Reg);
    7f6e:	9803      	ldr	r0, [sp, #12]
    7f70:	f7ff fc5e 	bl	7830 <Adc_HwAcc_GetAIEN>
    7f74:	4603      	mov	r3, r0
}
    7f76:	4618      	mov	r0, r3
    7f78:	b005      	add	sp, #20
    7f7a:	f85d fb04 	ldr.w	pc, [sp], #4
    7f7e:	bf00      	nop
    7f80:	000186bc 	.word	0x000186bc

00007f84 <Adc_Ip_GetConvCompleteFlag>:
*
* @implements     Adc_Ip_GetConvCompleteFlag_Activity
* END**************************************************************************/
boolean Adc_Ip_GetConvCompleteFlag(const uint32 Instance,
                                   const uint8 ControlChanIdx)
{
    7f84:	b500      	push	{lr}
    7f86:	b085      	sub	sp, #20
    7f88:	9001      	str	r0, [sp, #4]
    7f8a:	460b      	mov	r3, r1
    7f8c:	f88d 3003 	strb.w	r3, [sp, #3]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
    DevAssert(ControlChanIdx < ADC_MAX_CHAN_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    const uint32 Sc1Reg = SC1(Adc_Ip_apxBase[Instance], ControlChanIdx);
    7f90:	4a08      	ldr	r2, [pc, #32]	; (7fb4 <Adc_Ip_GetConvCompleteFlag+0x30>)
    7f92:	9b01      	ldr	r3, [sp, #4]
    7f94:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7f98:	f89d 2003 	ldrb.w	r2, [sp, #3]
    7f9c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    7fa0:	9303      	str	r3, [sp, #12]

    return Adc_HwAcc_GetCOCO(Sc1Reg);
    7fa2:	9803      	ldr	r0, [sp, #12]
    7fa4:	f7ff fc52 	bl	784c <Adc_HwAcc_GetCOCO>
    7fa8:	4603      	mov	r3, r0
}
    7faa:	4618      	mov	r0, r3
    7fac:	b005      	add	sp, #20
    7fae:	f85d fb04 	ldr.w	pc, [sp], #4
    7fb2:	bf00      	nop
    7fb4:	000186bc 	.word	0x000186bc

00007fb8 <Adc_Ip_GetConvData>:
*
* @implements     Adc_Ip_GetConvData_Activity
* END**************************************************************************/
uint16 Adc_Ip_GetConvData(const uint32 Instance,
                          const uint8 ControlChanIdx)
{
    7fb8:	b500      	push	{lr}
    7fba:	b085      	sub	sp, #20
    7fbc:	9001      	str	r0, [sp, #4]
    7fbe:	460b      	mov	r3, r1
    7fc0:	f88d 3003 	strb.w	r3, [sp, #3]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
    DevAssert(ControlChanIdx < ADC_MAX_CHAN_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    const ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7fc4:	4a07      	ldr	r2, [pc, #28]	; (7fe4 <Adc_Ip_GetConvData+0x2c>)
    7fc6:	9b01      	ldr	r3, [sp, #4]
    7fc8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7fcc:	9303      	str	r3, [sp, #12]

    return Adc_HwAcc_GetData(Base, ControlChanIdx);
    7fce:	f89d 3003 	ldrb.w	r3, [sp, #3]
    7fd2:	4619      	mov	r1, r3
    7fd4:	9803      	ldr	r0, [sp, #12]
    7fd6:	f7ff fc47 	bl	7868 <Adc_HwAcc_GetData>
    7fda:	4603      	mov	r3, r0
}
    7fdc:	4618      	mov	r0, r3
    7fde:	b005      	add	sp, #20
    7fe0:	f85d fb04 	ldr.w	pc, [sp], #4
    7fe4:	000186bc 	.word	0x000186bc

00007fe8 <Adc_Ip_DoCalibration>:
* specified frequency (50Mhz) and greater than minimum specified frequency (20Mhz).
*
* @implements     Adc_Ip_DoCalibration_Activity
* END**************************************************************************/
Adc_Ip_StatusType Adc_Ip_DoCalibration(const uint32 Instance)
{
    7fe8:	b500      	push	{lr}
    7fea:	b093      	sub	sp, #76	; 0x4c
    7fec:	9001      	str	r0, [sp, #4]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7fee:	4a59      	ldr	r2, [pc, #356]	; (8154 <Adc_Ip_DoCalibration+0x16c>)
    7ff0:	9b01      	ldr	r3, [sp, #4]
    7ff2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7ff6:	930f      	str	r3, [sp, #60]	; 0x3c
    Adc_Ip_StatusType Status = ADC_IP_STATUS_SUCCESS;
    7ff8:	2300      	movs	r3, #0
    7ffa:	9311      	str	r3, [sp, #68]	; 0x44
    Adc_Ip_TrigType TriggerMode;
    uint32 TimeoutTicks = OsIf_MicrosToTicks(ADC_IP_TIMEOUT_VAL, ADC_IP_TIMEOUT_TYPE);
    7ffc:	2100      	movs	r1, #0
    7ffe:	4856      	ldr	r0, [pc, #344]	; (8158 <Adc_Ip_DoCalibration+0x170>)
    8000:	f7f9 ffe0 	bl	1fc4 <OsIf_MicrosToTicks>
    8004:	900e      	str	r0, [sp, #56]	; 0x38
    uint32 CurrentTicks = OsIf_GetCounter(ADC_IP_TIMEOUT_TYPE);
    8006:	2000      	movs	r0, #0
    8008:	f7f9 ff90 	bl	1f2c <OsIf_GetCounter>
    800c:	4603      	mov	r3, r0
    800e:	930b      	str	r3, [sp, #44]	; 0x2c
    uint32 ElapsedTicks = 0u;
    8010:	2300      	movs	r3, #0
    8012:	9310      	str	r3, [sp, #64]	; 0x40
    uint32 Reg;
    Adc_Ip_ClockConfigType PreClockConfig;
    Adc_Ip_ClockConfigType CalClockConfig;

    /* Store settings before calibration */
    Reg = Base->SC3;
    8014:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    8016:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
    801a:	930d      	str	r3, [sp, #52]	; 0x34
    PreClockConfig.AvgEn = ((Reg & ADC_SC3_AVGE_MASK) != 0u) ? TRUE : FALSE;
    801c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    801e:	089b      	lsrs	r3, r3, #2
    8020:	f003 0301 	and.w	r3, r3, #1
    8024:	2b00      	cmp	r3, #0
    8026:	bf14      	ite	ne
    8028:	2301      	movne	r3, #1
    802a:	2300      	moveq	r3, #0
    802c:	b2db      	uxtb	r3, r3
    802e:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
    PreClockConfig.AvgSel = Adc_HwAcc_GetAverageSelect(Reg);
    8032:	980d      	ldr	r0, [sp, #52]	; 0x34
    8034:	f7ff fb71 	bl	771a <Adc_HwAcc_GetAverageSelect>
    8038:	4603      	mov	r3, r0
    803a:	930a      	str	r3, [sp, #40]	; 0x28

    Reg = Base->CFG2;
    803c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    803e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    8040:	930d      	str	r3, [sp, #52]	; 0x34
    PreClockConfig.SampleTime = (uint8) ((Reg & ADC_CFG2_SMPLTS_MASK) >> ADC_CFG2_SMPLTS_SHIFT);
    8042:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    8044:	b2db      	uxtb	r3, r3
    8046:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
    TriggerMode = Adc_HwAcc_GetTriggerMode(Base->SC2);
    804a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    804c:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
    8050:	4618      	mov	r0, r3
    8052:	f7ff fb99 	bl	7788 <Adc_HwAcc_GetTriggerMode>
    8056:	900c      	str	r0, [sp, #48]	; 0x30

    Reg = Base->CFG1;
    8058:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    805a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    805c:	930d      	str	r3, [sp, #52]	; 0x34
    PreClockConfig.ClockDivide = Adc_HwAcc_GetClockDivide(Reg);
    805e:	980d      	ldr	r0, [sp, #52]	; 0x34
    8060:	f7ff fad8 	bl	7614 <Adc_HwAcc_GetClockDivide>
    8064:	4603      	mov	r3, r0
    8066:	9307      	str	r3, [sp, #28]
    PreClockConfig.InputClock = Adc_HwAcc_GetInputClock(Reg);
    8068:	980d      	ldr	r0, [sp, #52]	; 0x34
    806a:	f7ff faf2 	bl	7652 <Adc_HwAcc_GetInputClock>
    806e:	4603      	mov	r3, r0
    8070:	9308      	str	r3, [sp, #32]

    CalClockConfig.AvgEn = TRUE;
    8072:	2301      	movs	r3, #1
    8074:	f88d 3015 	strb.w	r3, [sp, #21]
    CalClockConfig.AvgSel = ADC_IP_AVG_32_CONV;
    8078:	2303      	movs	r3, #3
    807a:	9306      	str	r3, [sp, #24]
    CalClockConfig.SampleTime = ADC_IP_DEFAULT_SAMPLE_TIME;
    807c:	230c      	movs	r3, #12
    807e:	f88d 3014 	strb.w	r3, [sp, #20]
    CalClockConfig.ClockDivide = Adc_Ip_axState[Instance].CalibrationClockDivide;
    8082:	4a36      	ldr	r2, [pc, #216]	; (815c <Adc_Ip_DoCalibration+0x174>)
    8084:	9b01      	ldr	r3, [sp, #4]
    8086:	214c      	movs	r1, #76	; 0x4c
    8088:	fb01 f303 	mul.w	r3, r1, r3
    808c:	4413      	add	r3, r2
    808e:	3304      	adds	r3, #4
    8090:	681b      	ldr	r3, [r3, #0]
    8092:	9303      	str	r3, [sp, #12]
    CalClockConfig.InputClock = PreClockConfig.InputClock;
    8094:	9b08      	ldr	r3, [sp, #32]
    8096:	9304      	str	r3, [sp, #16]

    /* Prepare required settings for calibration. */
    ADC_DoCalibration_SetParams(Base, &CalClockConfig, ADC_IP_TRIGGER_SOFTWARE);
    8098:	ab03      	add	r3, sp, #12
    809a:	2200      	movs	r2, #0
    809c:	4619      	mov	r1, r3
    809e:	980f      	ldr	r0, [sp, #60]	; 0x3c
    80a0:	f7ff fbfa 	bl	7898 <ADC_DoCalibration_SetParams>

    Base->CLPS = 0u;
    80a4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    80a6:	2200      	movs	r2, #0
    80a8:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
    Base->CLP3 = 0u;
    80ac:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    80ae:	2200      	movs	r2, #0
    80b0:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
    Base->CLP2 = 0u;
    80b4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    80b6:	2200      	movs	r2, #0
    80b8:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
    Base->CLP1 = 0u;
    80bc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    80be:	2200      	movs	r2, #0
    80c0:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    Base->CLP0 = 0u;
    80c4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    80c6:	2200      	movs	r2, #0
    80c8:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
    Base->CLPX = 0u;
    80cc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    80ce:	2200      	movs	r2, #0
    80d0:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    Base->CLP9 = 0u;
    80d4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    80d6:	2200      	movs	r2, #0
    80d8:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc

    /* Start calibration by writing to the calibration field */
    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_29();
    80dc:	f009 f83e 	bl	1115c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_29>
    Reg = Base->SC3;
    80e0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    80e2:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
    80e6:	930d      	str	r3, [sp, #52]	; 0x34
    Reg &= ~(ADC_SC3_CAL_MASK);
    80e8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    80ea:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    80ee:	930d      	str	r3, [sp, #52]	; 0x34
    Reg |= ADC_SC3_CAL(1u);
    80f0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    80f2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    80f6:	930d      	str	r3, [sp, #52]	; 0x34
    Base->SC3 = Reg;
    80f8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    80fa:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    80fc:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_29();
    8100:	f009 f858 	bl	111b4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_29>

    /* Wait for the calibration to finish */
    while (((Base->SC3 & ADC_SC3_CAL_MASK) != 0u) && (ElapsedTicks < TimeoutTicks))
    8104:	e008      	b.n	8118 <Adc_Ip_DoCalibration+0x130>
    {
        ElapsedTicks += OsIf_GetElapsed(&CurrentTicks, ADC_IP_TIMEOUT_TYPE);
    8106:	ab0b      	add	r3, sp, #44	; 0x2c
    8108:	2100      	movs	r1, #0
    810a:	4618      	mov	r0, r3
    810c:	f7f9 ff27 	bl	1f5e <OsIf_GetElapsed>
    8110:	4602      	mov	r2, r0
    8112:	9b10      	ldr	r3, [sp, #64]	; 0x40
    8114:	4413      	add	r3, r2
    8116:	9310      	str	r3, [sp, #64]	; 0x40
    while (((Base->SC3 & ADC_SC3_CAL_MASK) != 0u) && (ElapsedTicks < TimeoutTicks))
    8118:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    811a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
    811e:	f003 0380 	and.w	r3, r3, #128	; 0x80
    8122:	2b00      	cmp	r3, #0
    8124:	d003      	beq.n	812e <Adc_Ip_DoCalibration+0x146>
    8126:	9a10      	ldr	r2, [sp, #64]	; 0x40
    8128:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    812a:	429a      	cmp	r2, r3
    812c:	d3eb      	bcc.n	8106 <Adc_Ip_DoCalibration+0x11e>
    }
    if (ElapsedTicks >= TimeoutTicks)
    812e:	9a10      	ldr	r2, [sp, #64]	; 0x40
    8130:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    8132:	429a      	cmp	r2, r3
    8134:	d301      	bcc.n	813a <Adc_Ip_DoCalibration+0x152>
    {
        Status = ADC_IP_STATUS_TIMEOUT;
    8136:	2302      	movs	r3, #2
    8138:	9311      	str	r3, [sp, #68]	; 0x44
    }

    /* Revert settings as same as before calibration. */
    ADC_DoCalibration_SetParams(Base, &PreClockConfig, TriggerMode);
    813a:	ab07      	add	r3, sp, #28
    813c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    813e:	4619      	mov	r1, r3
    8140:	980f      	ldr	r0, [sp, #60]	; 0x3c
    8142:	f7ff fba9 	bl	7898 <ADC_DoCalibration_SetParams>

    /* Clear COCO flag */
    (void) R(Base, 0u);
    8146:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    8148:	6c9b      	ldr	r3, [r3, #72]	; 0x48

    return Status;
    814a:	9b11      	ldr	r3, [sp, #68]	; 0x44
}
    814c:	4618      	mov	r0, r3
    814e:	b013      	add	sp, #76	; 0x4c
    8150:	f85d fb04 	ldr.w	pc, [sp], #4
    8154:	000186bc 	.word	0x000186bc
    8158:	000186a0 	.word	0x000186a0
    815c:	1fff8d04 	.word	0x1fff8d04

00008160 <Adc_Ip_ClearLatchedTriggers>:
* has been deactivated.
*
* @implements     Adc_Ip_ClearLatchedTriggers_Activity
* END**************************************************************************/
Adc_Ip_StatusType Adc_Ip_ClearLatchedTriggers(const uint32 Instance)
{
    8160:	b500      	push	{lr}
    8162:	b089      	sub	sp, #36	; 0x24
    8164:	9001      	str	r0, [sp, #4]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
    DevAssert(Instance != 0u);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    8166:	4a1e      	ldr	r2, [pc, #120]	; (81e0 <Adc_Ip_ClearLatchedTriggers+0x80>)
    8168:	9b01      	ldr	r3, [sp, #4]
    816a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    816e:	9305      	str	r3, [sp, #20]
    Adc_Ip_StatusType Status = ADC_IP_STATUS_SUCCESS;
    8170:	2300      	movs	r3, #0
    8172:	9307      	str	r3, [sp, #28]
    uint32 TimeoutTicks = OsIf_MicrosToTicks(ADC_IP_TIMEOUT_VAL, ADC_IP_TIMEOUT_TYPE);
    8174:	2100      	movs	r1, #0
    8176:	481b      	ldr	r0, [pc, #108]	; (81e4 <Adc_Ip_ClearLatchedTriggers+0x84>)
    8178:	f7f9 ff24 	bl	1fc4 <OsIf_MicrosToTicks>
    817c:	9004      	str	r0, [sp, #16]
    uint32 CurrentTicks = OsIf_GetCounter(ADC_IP_TIMEOUT_TYPE);
    817e:	2000      	movs	r0, #0
    8180:	f7f9 fed4 	bl	1f2c <OsIf_GetCounter>
    8184:	4603      	mov	r3, r0
    8186:	9303      	str	r3, [sp, #12]
    uint32 ElapsedTicks = 0u;
    8188:	2300      	movs	r3, #0
    818a:	9306      	str	r3, [sp, #24]

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_12();
    818c:	f008 fa74 	bl	10678 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_12>
    /* Write bit to clear latched triggers */
    Base->CFG1 |= ADC_CFG1_CLRLTRG(0x01u);
    8190:	9b05      	ldr	r3, [sp, #20]
    8192:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    8194:	f443 7280 	orr.w	r2, r3, #256	; 0x100
    8198:	9b05      	ldr	r3, [sp, #20]
    819a:	641a      	str	r2, [r3, #64]	; 0x40
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_12();
    819c:	f008 fa98 	bl	106d0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_12>

    /* Wait for latched triggers to be cleared */
    while (((Base->SC2 & ADC_SC2_TRGSTLAT_MASK) != 0u) && (ElapsedTicks < TimeoutTicks))
    81a0:	e008      	b.n	81b4 <Adc_Ip_ClearLatchedTriggers+0x54>
    {
        ElapsedTicks += OsIf_GetElapsed(&CurrentTicks, ADC_IP_TIMEOUT_TYPE);
    81a2:	ab03      	add	r3, sp, #12
    81a4:	2100      	movs	r1, #0
    81a6:	4618      	mov	r0, r3
    81a8:	f7f9 fed9 	bl	1f5e <OsIf_GetElapsed>
    81ac:	4602      	mov	r2, r0
    81ae:	9b06      	ldr	r3, [sp, #24]
    81b0:	4413      	add	r3, r2
    81b2:	9306      	str	r3, [sp, #24]
    while (((Base->SC2 & ADC_SC2_TRGSTLAT_MASK) != 0u) && (ElapsedTicks < TimeoutTicks))
    81b4:	9b05      	ldr	r3, [sp, #20]
    81b6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
    81ba:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
    81be:	2b00      	cmp	r3, #0
    81c0:	d003      	beq.n	81ca <Adc_Ip_ClearLatchedTriggers+0x6a>
    81c2:	9a06      	ldr	r2, [sp, #24]
    81c4:	9b04      	ldr	r3, [sp, #16]
    81c6:	429a      	cmp	r2, r3
    81c8:	d3eb      	bcc.n	81a2 <Adc_Ip_ClearLatchedTriggers+0x42>
    }
    if (ElapsedTicks >= TimeoutTicks)
    81ca:	9a06      	ldr	r2, [sp, #24]
    81cc:	9b04      	ldr	r3, [sp, #16]
    81ce:	429a      	cmp	r2, r3
    81d0:	d301      	bcc.n	81d6 <Adc_Ip_ClearLatchedTriggers+0x76>
    {
        Status = ADC_IP_STATUS_TIMEOUT;
    81d2:	2302      	movs	r3, #2
    81d4:	9307      	str	r3, [sp, #28]
    }

    return Status;
    81d6:	9b07      	ldr	r3, [sp, #28]
}
    81d8:	4618      	mov	r0, r3
    81da:	b009      	add	sp, #36	; 0x24
    81dc:	f85d fb04 	ldr.w	pc, [sp], #4
    81e0:	000186bc 	.word	0x000186bc
    81e4:	000186a0 	.word	0x000186a0

000081e8 <Adc_Ip_EnableChannelNotification>:
*
* @implements     Adc_Ip_EnableChannelNotification_Activity
* END**************************************************************************/
void Adc_Ip_EnableChannelNotification(const uint32 Instance,
                                      const uint8 ControlChanIdx)
{
    81e8:	b500      	push	{lr}
    81ea:	b085      	sub	sp, #20
    81ec:	9001      	str	r0, [sp, #4]
    81ee:	460b      	mov	r3, r1
    81f0:	f88d 3003 	strb.w	r3, [sp, #3]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
    DevAssert(ControlChanIdx < ADC_MAX_CHAN_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    81f4:	4a0c      	ldr	r2, [pc, #48]	; (8228 <Adc_Ip_EnableChannelNotification+0x40>)
    81f6:	9b01      	ldr	r3, [sp, #4]
    81f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    81fc:	9303      	str	r3, [sp, #12]

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_19();
    81fe:	f008 fc79 	bl	10af4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_19>
    SC1(Base, ControlChanIdx) |= ADC_SC1_AIEN_MASK;
    8202:	f89d 2003 	ldrb.w	r2, [sp, #3]
    8206:	9b03      	ldr	r3, [sp, #12]
    8208:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    820c:	f89d 2003 	ldrb.w	r2, [sp, #3]
    8210:	f043 0140 	orr.w	r1, r3, #64	; 0x40
    8214:	9b03      	ldr	r3, [sp, #12]
    8216:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_19();
    821a:	f008 fc97 	bl	10b4c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_19>
}
    821e:	bf00      	nop
    8220:	b005      	add	sp, #20
    8222:	f85d fb04 	ldr.w	pc, [sp], #4
    8226:	bf00      	nop
    8228:	000186bc 	.word	0x000186bc

0000822c <Adc_Ip_DisableChannelNotification>:
*
* @implements     Adc_Ip_DisableChannelNotification_Activity
* END**************************************************************************/
void Adc_Ip_DisableChannelNotification(const uint32 Instance,
                                       const uint8 ControlChanIdx)
{
    822c:	b500      	push	{lr}
    822e:	b085      	sub	sp, #20
    8230:	9001      	str	r0, [sp, #4]
    8232:	460b      	mov	r3, r1
    8234:	f88d 3003 	strb.w	r3, [sp, #3]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
    DevAssert(ControlChanIdx < ADC_MAX_CHAN_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    8238:	4a0c      	ldr	r2, [pc, #48]	; (826c <Adc_Ip_DisableChannelNotification+0x40>)
    823a:	9b01      	ldr	r3, [sp, #4]
    823c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8240:	9303      	str	r3, [sp, #12]

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_20();
    8242:	f008 fca9 	bl	10b98 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_20>
    SC1(Base, ControlChanIdx) &= ~(ADC_SC1_AIEN_MASK);
    8246:	f89d 2003 	ldrb.w	r2, [sp, #3]
    824a:	9b03      	ldr	r3, [sp, #12]
    824c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    8250:	f89d 2003 	ldrb.w	r2, [sp, #3]
    8254:	f023 0140 	bic.w	r1, r3, #64	; 0x40
    8258:	9b03      	ldr	r3, [sp, #12]
    825a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_20();
    825e:	f008 fcc7 	bl	10bf0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_20>
}
    8262:	bf00      	nop
    8264:	b005      	add	sp, #20
    8266:	f85d fb04 	ldr.w	pc, [sp], #4
    826a:	bf00      	nop
    826c:	000186bc 	.word	0x000186bc

00008270 <Adc_Ip_ClearTrigErrReg>:
* Description   : This function clears all trigger error flags of the ADC instance.
*
* @implements     Adc_Ip_ClearTrigErrReg_Activity
* END**************************************************************************/
void Adc_Ip_ClearTrigErrReg(const uint32 Instance)
{
    8270:	b500      	push	{lr}
    8272:	b085      	sub	sp, #20
    8274:	9001      	str	r0, [sp, #4]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
    DevAssert(Instance != 0u);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    8276:	4a0a      	ldr	r2, [pc, #40]	; (82a0 <Adc_Ip_ClearTrigErrReg+0x30>)
    8278:	9b01      	ldr	r3, [sp, #4]
    827a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    827e:	9303      	str	r3, [sp, #12]

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_25();
    8280:	f008 fe24 	bl	10ecc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_25>
    Base->SC2 |= ADC_SC2_TRGSTERR_MASK;
    8284:	9b03      	ldr	r3, [sp, #12]
    8286:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
    828a:	f043 6270 	orr.w	r2, r3, #251658240	; 0xf000000
    828e:	9b03      	ldr	r3, [sp, #12]
    8290:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_25();
    8294:	f008 fe46 	bl	10f24 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_25>
}
    8298:	bf00      	nop
    829a:	b005      	add	sp, #20
    829c:	f85d fb04 	ldr.w	pc, [sp], #4
    82a0:	000186bc 	.word	0x000186bc

000082a4 <Adc_Ip_GetTrigErrReg>:
* Description   : This function returns all trigger error flags of the ADC instance.
*
* @implements     Adc_Ip_GetTrigErrReg_Activity
* END**************************************************************************/
uint32 Adc_Ip_GetTrigErrReg(const uint32 Instance)
{
    82a4:	b084      	sub	sp, #16
    82a6:	9001      	str	r0, [sp, #4]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
    DevAssert(Instance != 0u);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    const ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    82a8:	4a06      	ldr	r2, [pc, #24]	; (82c4 <Adc_Ip_GetTrigErrReg+0x20>)
    82aa:	9b01      	ldr	r3, [sp, #4]
    82ac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    82b0:	9303      	str	r3, [sp, #12]

    return (Base->SC2 & ADC_SC2_TRGSTERR_MASK) >> ADC_SC2_TRGSTERR_SHIFT;
    82b2:	9b03      	ldr	r3, [sp, #12]
    82b4:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
    82b8:	0e1b      	lsrs	r3, r3, #24
    82ba:	f003 030f 	and.w	r3, r3, #15
}
    82be:	4618      	mov	r0, r3
    82c0:	b004      	add	sp, #16
    82c2:	4770      	bx	lr
    82c4:	000186bc 	.word	0x000186bc

000082c8 <Adc_Ip_GetDataAddress>:
 *
 * @implements     Adc_Ip_GetDataAddress_Activity
 *END*************************************************************************/
uint32 Adc_Ip_GetDataAddress(const uint32 Instance,
                             const uint8 Index)
{
    82c8:	b082      	sub	sp, #8
    82ca:	9001      	str	r0, [sp, #4]
    82cc:	460b      	mov	r3, r1
    82ce:	f88d 3003 	strb.w	r3, [sp, #3]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */
    return (uint32)&(R(Adc_Ip_apxBase[Instance], Index));
    82d2:	4a06      	ldr	r2, [pc, #24]	; (82ec <Adc_Ip_GetDataAddress+0x24>)
    82d4:	9b01      	ldr	r3, [sp, #4]
    82d6:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    82da:	f89d 3003 	ldrb.w	r3, [sp, #3]
    82de:	3312      	adds	r3, #18
    82e0:	009b      	lsls	r3, r3, #2
    82e2:	4413      	add	r3, r2
}
    82e4:	4618      	mov	r0, r3
    82e6:	b002      	add	sp, #8
    82e8:	4770      	bx	lr
    82ea:	bf00      	nop
    82ec:	000186bc 	.word	0x000186bc

000082f0 <Adc_Ip_GetChanData>:
* @implements     Adc_Ip_GetChanData_Activity
* END**************************************************************************/
Adc_Ip_StatusType Adc_Ip_GetChanData(const uint32 Instance,
                                     const Adc_Ip_InputChannelType Channel,
                                     uint16 * const Result)
{
    82f0:	b088      	sub	sp, #32
    82f2:	9003      	str	r0, [sp, #12]
    82f4:	9102      	str	r1, [sp, #8]
    82f6:	9201      	str	r2, [sp, #4]
#if (ADC_IP_SUPPLY_MONITORING_ENABLED == STD_ON)
    DevAssert((Instance == 0u) || ((uint32)Channel < (uint32)ADC_IP_INPUTCHAN_SUPPLY_VDD));
#endif /* (ADC_IP_SUPPLY_MONITORING_ENABLED == STD_ON) */
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    const ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    82f8:	4a25      	ldr	r2, [pc, #148]	; (8390 <Adc_Ip_GetChanData+0xa0>)
    82fa:	9b03      	ldr	r3, [sp, #12]
    82fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8300:	9305      	str	r3, [sp, #20]
    Adc_Ip_StatusType Status = ADC_IP_STATUS_SUCCESS;
    8302:	2300      	movs	r3, #0
    8304:	9307      	str	r3, [sp, #28]
    uint16 Temp = 0u;
    8306:	2300      	movs	r3, #0
    8308:	f8ad 301a 	strh.w	r3, [sp, #26]
    uint8 ControlChanIdx;
    boolean Found = FALSE;
    830c:	2300      	movs	r3, #0
    830e:	f88d 3018 	strb.w	r3, [sp, #24]

    for (ControlChanIdx = 0u; ControlChanIdx < ADC_MAX_CHAN_COUNT; ControlChanIdx++)
    8312:	2300      	movs	r3, #0
    8314:	f88d 3019 	strb.w	r3, [sp, #25]
    8318:	e019      	b.n	834e <Adc_Ip_GetChanData+0x5e>
    {
        if (Adc_Ip_axState[Instance].ChannelConfig[ControlChanIdx] == Channel)
    831a:	f89d 1019 	ldrb.w	r1, [sp, #25]
    831e:	481d      	ldr	r0, [pc, #116]	; (8394 <Adc_Ip_GetChanData+0xa4>)
    8320:	9a03      	ldr	r2, [sp, #12]
    8322:	4613      	mov	r3, r2
    8324:	00db      	lsls	r3, r3, #3
    8326:	4413      	add	r3, r2
    8328:	005b      	lsls	r3, r3, #1
    832a:	4413      	add	r3, r2
    832c:	440b      	add	r3, r1
    832e:	3302      	adds	r3, #2
    8330:	009b      	lsls	r3, r3, #2
    8332:	4403      	add	r3, r0
    8334:	685b      	ldr	r3, [r3, #4]
    8336:	9a02      	ldr	r2, [sp, #8]
    8338:	429a      	cmp	r2, r3
    833a:	d103      	bne.n	8344 <Adc_Ip_GetChanData+0x54>
        {
            Found = TRUE;
    833c:	2301      	movs	r3, #1
    833e:	f88d 3018 	strb.w	r3, [sp, #24]
            break;
    8342:	e008      	b.n	8356 <Adc_Ip_GetChanData+0x66>
    for (ControlChanIdx = 0u; ControlChanIdx < ADC_MAX_CHAN_COUNT; ControlChanIdx++)
    8344:	f89d 3019 	ldrb.w	r3, [sp, #25]
    8348:	3301      	adds	r3, #1
    834a:	f88d 3019 	strb.w	r3, [sp, #25]
    834e:	f89d 3019 	ldrb.w	r3, [sp, #25]
    8352:	2b0f      	cmp	r3, #15
    8354:	d9e1      	bls.n	831a <Adc_Ip_GetChanData+0x2a>
        }
    }

    if (Found == TRUE)
    8356:	f89d 3018 	ldrb.w	r3, [sp, #24]
    835a:	2b00      	cmp	r3, #0
    835c:	d00e      	beq.n	837c <Adc_Ip_GetChanData+0x8c>
    {
        Temp = (uint16) R(Base, ControlChanIdx);
    835e:	f89d 2019 	ldrb.w	r2, [sp, #25]
    8362:	9b05      	ldr	r3, [sp, #20]
    8364:	3212      	adds	r2, #18
    8366:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    836a:	f8ad 301a 	strh.w	r3, [sp, #26]
        Temp = (uint16) ((Temp & ADC_R_D_MASK) >> ADC_R_D_SHIFT);
    836e:	f8bd 301a 	ldrh.w	r3, [sp, #26]
    8372:	f3c3 030b 	ubfx	r3, r3, #0, #12
    8376:	f8ad 301a 	strh.w	r3, [sp, #26]
    837a:	e001      	b.n	8380 <Adc_Ip_GetChanData+0x90>
    }
    else
    {
        Status = ADC_IP_STATUS_ERROR;
    837c:	2301      	movs	r3, #1
    837e:	9307      	str	r3, [sp, #28]
    }

    *Result = Temp;
    8380:	9b01      	ldr	r3, [sp, #4]
    8382:	f8bd 201a 	ldrh.w	r2, [sp, #26]
    8386:	801a      	strh	r2, [r3, #0]

    return Status;
    8388:	9b07      	ldr	r3, [sp, #28]
}
    838a:	4618      	mov	r0, r3
    838c:	b008      	add	sp, #32
    838e:	4770      	bx	lr
    8390:	000186bc 	.word	0x000186bc
    8394:	1fff8d04 	.word	0x1fff8d04

00008398 <Adc_Ip_IRQHandler>:
 * Note          : It's required to read result data in user notification in order to clear the COCO flags and avoid ISR getting invoked repeatedly
 *
 * @implements     Adc_Ip_IRQHandler_Activity
 *END*************************************************************************/
void Adc_Ip_IRQHandler(const uint32 Instance)
{
    8398:	b500      	push	{lr}
    839a:	b085      	sub	sp, #20
    839c:	9001      	str	r0, [sp, #4]
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    uint8 ControlChanIdx;
#if (ADC_IP_AIEN_INTERRUPT_ENABLE == STD_ON)
    uint32 Sc1Reg;
    boolean ChanIntFlag = FALSE;
    839e:	2300      	movs	r3, #0
    83a0:	f88d 300e 	strb.w	r3, [sp, #14]
    boolean ChanCocoFlag = FALSE;
    83a4:	2300      	movs	r3, #0
    83a6:	f88d 300d 	strb.w	r3, [sp, #13]

    /* Check whether the respective driver is initialized */
    if (TRUE == Adc_Ip_axState[Instance].Init)
    83aa:	4a32      	ldr	r2, [pc, #200]	; (8474 <Adc_Ip_IRQHandler+0xdc>)
    83ac:	9b01      	ldr	r3, [sp, #4]
    83ae:	214c      	movs	r1, #76	; 0x4c
    83b0:	fb01 f303 	mul.w	r3, r1, r3
    83b4:	4413      	add	r3, r2
    83b6:	781b      	ldrb	r3, [r3, #0]
    83b8:	2b00      	cmp	r3, #0
    83ba:	d040      	beq.n	843e <Adc_Ip_IRQHandler+0xa6>
    {
        /* Check if the callback is not NULL since all channels use the same one (to avoid checking inside the loop) */
        if (Adc_Ip_axState[Instance].ConversionCompleteNotification != NULL_PTR)
    83bc:	4a2d      	ldr	r2, [pc, #180]	; (8474 <Adc_Ip_IRQHandler+0xdc>)
    83be:	9b01      	ldr	r3, [sp, #4]
    83c0:	214c      	movs	r1, #76	; 0x4c
    83c2:	fb01 f303 	mul.w	r3, r1, r3
    83c6:	4413      	add	r3, r2
    83c8:	3308      	adds	r3, #8
    83ca:	681b      	ldr	r3, [r3, #0]
    83cc:	2b00      	cmp	r3, #0
    83ce:	d04d      	beq.n	846c <Adc_Ip_IRQHandler+0xd4>
        {
            for (ControlChanIdx = 0u; ControlChanIdx < ADC_MAX_CHAN_COUNT; ControlChanIdx++)
    83d0:	2300      	movs	r3, #0
    83d2:	f88d 300f 	strb.w	r3, [sp, #15]
    83d6:	e02d      	b.n	8434 <Adc_Ip_IRQHandler+0x9c>
            {
                Sc1Reg = SC1(Adc_Ip_apxBase[Instance], ControlChanIdx);
    83d8:	4a27      	ldr	r2, [pc, #156]	; (8478 <Adc_Ip_IRQHandler+0xe0>)
    83da:	9b01      	ldr	r3, [sp, #4]
    83dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    83e0:	f89d 200f 	ldrb.w	r2, [sp, #15]
    83e4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    83e8:	9302      	str	r3, [sp, #8]
                ChanIntFlag = Adc_HwAcc_GetAIEN(Sc1Reg);
    83ea:	9802      	ldr	r0, [sp, #8]
    83ec:	f7ff fa20 	bl	7830 <Adc_HwAcc_GetAIEN>
    83f0:	4603      	mov	r3, r0
    83f2:	f88d 300e 	strb.w	r3, [sp, #14]
                ChanCocoFlag = Adc_HwAcc_GetCOCO(Sc1Reg);
    83f6:	9802      	ldr	r0, [sp, #8]
    83f8:	f7ff fa28 	bl	784c <Adc_HwAcc_GetCOCO>
    83fc:	4603      	mov	r3, r0
    83fe:	f88d 300d 	strb.w	r3, [sp, #13]
                /* CPR_RTD_00664
                 * Check if the interrupt not spurious (the interrupt is enabled and equivalent conversion has finished)
                 * Ignore spurious ones (return immediately from ISR)
                 */
                if ((TRUE == ChanIntFlag) && (TRUE == ChanCocoFlag))
    8402:	f89d 300e 	ldrb.w	r3, [sp, #14]
    8406:	2b00      	cmp	r3, #0
    8408:	d00f      	beq.n	842a <Adc_Ip_IRQHandler+0x92>
    840a:	f89d 300d 	ldrb.w	r3, [sp, #13]
    840e:	2b00      	cmp	r3, #0
    8410:	d00b      	beq.n	842a <Adc_Ip_IRQHandler+0x92>
                {
                    /* Call the associated callback.
                     * The COCO flag will be cleared by reading the respective result data register in the callback
                     */
                    Adc_Ip_axState[Instance].ConversionCompleteNotification(ControlChanIdx);
    8412:	4a18      	ldr	r2, [pc, #96]	; (8474 <Adc_Ip_IRQHandler+0xdc>)
    8414:	9b01      	ldr	r3, [sp, #4]
    8416:	214c      	movs	r1, #76	; 0x4c
    8418:	fb01 f303 	mul.w	r3, r1, r3
    841c:	4413      	add	r3, r2
    841e:	3308      	adds	r3, #8
    8420:	681b      	ldr	r3, [r3, #0]
    8422:	f89d 200f 	ldrb.w	r2, [sp, #15]
    8426:	4610      	mov	r0, r2
    8428:	4798      	blx	r3
            for (ControlChanIdx = 0u; ControlChanIdx < ADC_MAX_CHAN_COUNT; ControlChanIdx++)
    842a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    842e:	3301      	adds	r3, #1
    8430:	f88d 300f 	strb.w	r3, [sp, #15]
    8434:	f89d 300f 	ldrb.w	r3, [sp, #15]
    8438:	2b0f      	cmp	r3, #15
    843a:	d9cd      	bls.n	83d8 <Adc_Ip_IRQHandler+0x40>
        {
            /* Do a dummy read to clear the COCO flags */
            (void)Adc_HwAcc_GetData(Adc_Ip_apxBase[Instance], ControlChanIdx);
        }
    }
}
    843c:	e016      	b.n	846c <Adc_Ip_IRQHandler+0xd4>
        for (ControlChanIdx = 0u; ControlChanIdx < ADC_MAX_CHAN_COUNT; ControlChanIdx++)
    843e:	2300      	movs	r3, #0
    8440:	f88d 300f 	strb.w	r3, [sp, #15]
    8444:	e00e      	b.n	8464 <Adc_Ip_IRQHandler+0xcc>
            (void)Adc_HwAcc_GetData(Adc_Ip_apxBase[Instance], ControlChanIdx);
    8446:	4a0c      	ldr	r2, [pc, #48]	; (8478 <Adc_Ip_IRQHandler+0xe0>)
    8448:	9b01      	ldr	r3, [sp, #4]
    844a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    844e:	f89d 200f 	ldrb.w	r2, [sp, #15]
    8452:	4611      	mov	r1, r2
    8454:	4618      	mov	r0, r3
    8456:	f7ff fa07 	bl	7868 <Adc_HwAcc_GetData>
        for (ControlChanIdx = 0u; ControlChanIdx < ADC_MAX_CHAN_COUNT; ControlChanIdx++)
    845a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    845e:	3301      	adds	r3, #1
    8460:	f88d 300f 	strb.w	r3, [sp, #15]
    8464:	f89d 300f 	ldrb.w	r3, [sp, #15]
    8468:	2b0f      	cmp	r3, #15
    846a:	d9ec      	bls.n	8446 <Adc_Ip_IRQHandler+0xae>
}
    846c:	bf00      	nop
    846e:	b005      	add	sp, #20
    8470:	f85d fb04 	ldr.w	pc, [sp], #4
    8474:	1fff8d04 	.word	0x1fff8d04
    8478:	000186bc 	.word	0x000186bc

0000847c <Adc_0_Isr>:
==================================================================================================*/
#define ADC_START_SEC_CODE
#include "Adc_MemMap.h"

ISR(Adc_0_Isr)
{
    847c:	b508      	push	{r3, lr}
    /* Call IRQ handler with the correct instance */
    Adc_Ip_IRQHandler(0UL);
    847e:	2000      	movs	r0, #0
    8480:	f7ff ff8a 	bl	8398 <Adc_Ip_IRQHandler>

    EXIT_INTERRUPT();
    8484:	f3bf 8f4f 	dsb	sy
}
    8488:	bf00      	nop
    848a:	bd08      	pop	{r3, pc}

0000848c <Adc_1_Isr>:

#if (ADC_INSTANCE_COUNT > 1)
ISR(Adc_1_Isr)
{
    848c:	b508      	push	{r3, lr}
    /* Call IRQ handler with the correct instance */
    Adc_Ip_IRQHandler(1UL);
    848e:	2001      	movs	r0, #1
    8490:	f7ff ff82 	bl	8398 <Adc_Ip_IRQHandler>

    EXIT_INTERRUPT();
    8494:	f3bf 8f4f 	dsb	sy
}
    8498:	bf00      	nop
    849a:	bd08      	pop	{r3, pc}

0000849c <Lpspi_Ip_ChannelFinished>:
* @param[in]     Instance            Index of the hardware instance.
* @param[in]     ErrorFlag           Save the status of transfer error flags
* @return void
*/
static void Lpspi_Ip_ChannelFinished(uint8 Instance, boolean ErrorFlag)
{
    849c:	b500      	push	{lr}
    849e:	b085      	sub	sp, #20
    84a0:	4603      	mov	r3, r0
    84a2:	460a      	mov	r2, r1
    84a4:	f88d 3007 	strb.w	r3, [sp, #7]
    84a8:	4613      	mov	r3, r2
    84aa:	f88d 3006 	strb.w	r3, [sp, #6]
    Lpspi_Ip_StateStructureType* State = Lpspi_Ip_apxStateStructureArray[Instance];
    84ae:	f89d 3007 	ldrb.w	r3, [sp, #7]
    84b2:	4a12      	ldr	r2, [pc, #72]	; (84fc <Lpspi_Ip_ChannelFinished+0x60>)
    84b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    84b8:	9302      	str	r3, [sp, #8]
    Lpspi_Ip_EventType EventState = LPSPI_IP_EVENT_FAULT;
    84ba:	2301      	movs	r3, #1
    84bc:	9303      	str	r3, [sp, #12]
    
    if(TRUE == ErrorFlag)
    84be:	f89d 3006 	ldrb.w	r3, [sp, #6]
    84c2:	2b00      	cmp	r3, #0
    84c4:	d005      	beq.n	84d2 <Lpspi_Ip_ChannelFinished+0x36>
    {
        State->Status = LPSPI_IP_FAULT;
    84c6:	9b02      	ldr	r3, [sp, #8]
    84c8:	2203      	movs	r2, #3
    84ca:	605a      	str	r2, [r3, #4]
        EventState = LPSPI_IP_EVENT_FAULT;
    84cc:	2301      	movs	r3, #1
    84ce:	9303      	str	r3, [sp, #12]
    84d0:	e004      	b.n	84dc <Lpspi_Ip_ChannelFinished+0x40>
    }
    else
    {
        State->Status = LPSPI_IP_IDLE;
    84d2:	9b02      	ldr	r3, [sp, #8]
    84d4:	2201      	movs	r2, #1
    84d6:	605a      	str	r2, [r3, #4]
        EventState = LPSPI_IP_EVENT_END_TRANSFER;
    84d8:	2300      	movs	r3, #0
    84da:	9303      	str	r3, [sp, #12]
    }

    if (NULL_PTR != State->Callback)
    84dc:	9b02      	ldr	r3, [sp, #8]
    84de:	691b      	ldr	r3, [r3, #16]
    84e0:	2b00      	cmp	r3, #0
    84e2:	d006      	beq.n	84f2 <Lpspi_Ip_ChannelFinished+0x56>
    {
        State->Callback(Instance, EventState);
    84e4:	9b02      	ldr	r3, [sp, #8]
    84e6:	691b      	ldr	r3, [r3, #16]
    84e8:	f89d 2007 	ldrb.w	r2, [sp, #7]
    84ec:	9903      	ldr	r1, [sp, #12]
    84ee:	4610      	mov	r0, r2
    84f0:	4798      	blx	r3
    }
}
    84f2:	bf00      	nop
    84f4:	b005      	add	sp, #20
    84f6:	f85d fb04 	ldr.w	pc, [sp], #4
    84fa:	bf00      	nop
    84fc:	1fff8ddc 	.word	0x1fff8ddc

00008500 <Lpspi_Ip_TransferProcess>:
*
* @param[in]     Instance      Index of the hardware instance.
* @return void
*/
static void Lpspi_Ip_TransferProcess(uint8 Instance)
{
    8500:	b510      	push	{r4, lr}
    8502:	b092      	sub	sp, #72	; 0x48
    8504:	4603      	mov	r3, r0
    8506:	f88d 300f 	strb.w	r3, [sp, #15]
    LPSPI_Type* Base = Lpspi_Ip_apxBases[Instance];
    850a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    850e:	4aad      	ldr	r2, [pc, #692]	; (87c4 <Lpspi_Ip_TransferProcess+0x2c4>)
    8510:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8514:	9310      	str	r3, [sp, #64]	; 0x40
    Lpspi_Ip_StateStructureType* State = Lpspi_Ip_apxStateStructureArray[Instance];
    8516:	f89d 300f 	ldrb.w	r3, [sp, #15]
    851a:	4aab      	ldr	r2, [pc, #684]	; (87c8 <Lpspi_Ip_TransferProcess+0x2c8>)
    851c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8520:	930f      	str	r3, [sp, #60]	; 0x3c
    uint32 SrStatusRegister;
    uint8 NumberOfWrites = 0u;
    8522:	2300      	movs	r3, #0
    8524:	f88d 3047 	strb.w	r3, [sp, #71]	; 0x47
    uint8 NumberOfReads = 0u;
    8528:	2300      	movs	r3, #0
    852a:	f88d 3046 	strb.w	r3, [sp, #70]	; 0x46
    boolean ErrorFlag = FALSE;
    852e:	2300      	movs	r3, #0
    8530:	f88d 3045 	strb.w	r3, [sp, #69]	; 0x45

    if (LPSPI_IP_BUSY == State->Status)
    8534:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    8536:	685b      	ldr	r3, [r3, #4]
    8538:	2b02      	cmp	r3, #2
    853a:	f040 821e 	bne.w	897a <Lpspi_Ip_TransferProcess+0x47a>
    {
        /* Read Status and clear all flags. */
        SrStatusRegister = Base->SR;
    853e:	9b10      	ldr	r3, [sp, #64]	; 0x40
    8540:	695b      	ldr	r3, [r3, #20]
    8542:	930e      	str	r3, [sp, #56]	; 0x38
        Base->SR &= LPSPI_IP_SR_W1C_MASK_U32;
    8544:	9b10      	ldr	r3, [sp, #64]	; 0x40
    8546:	695b      	ldr	r3, [r3, #20]
    8548:	f403 527c 	and.w	r2, r3, #16128	; 0x3f00
    854c:	9b10      	ldr	r3, [sp, #64]	; 0x40
    854e:	615a      	str	r2, [r3, #20]
        
        if ((SrStatusRegister & (LPSPI_SR_REF_MASK | LPSPI_SR_TEF_MASK)) != 0u)
    8550:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    8552:	f403 53c0 	and.w	r3, r3, #6144	; 0x1800
    8556:	2b00      	cmp	r3, #0
    8558:	d003      	beq.n	8562 <Lpspi_Ip_TransferProcess+0x62>
        {
            /* mark error flag */
            ErrorFlag = TRUE;
    855a:	2301      	movs	r3, #1
    855c:	f88d 3045 	strb.w	r3, [sp, #69]	; 0x45
    8560:	e1f6      	b.n	8950 <Lpspi_Ip_TransferProcess+0x450>
        }
        else
        {
            /* RECEIVE */
            /* Read all Data available in receive HW fifo. */
            NumberOfReads = (uint8)(((Base->FSR) & LPSPI_FSR_RXCOUNT_MASK) >> LPSPI_FSR_RXCOUNT_SHIFT);
    8562:	9b10      	ldr	r3, [sp, #64]	; 0x40
    8564:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    8566:	0c1b      	lsrs	r3, r3, #16
    8568:	b2db      	uxtb	r3, r3
    856a:	f003 0307 	and.w	r3, r3, #7
    856e:	f88d 3046 	strb.w	r3, [sp, #70]	; 0x46
            if (NumberOfReads != 0u)
    8572:	f89d 3046 	ldrb.w	r3, [sp, #70]	; 0x46
    8576:	2b00      	cmp	r3, #0
    8578:	f000 80cb 	beq.w	8712 <Lpspi_Ip_TransferProcess+0x212>
            {
                if (NumberOfReads > (State->ExpectedFifoReads - State->RxIndex))
    857c:	f89d 2046 	ldrb.w	r2, [sp, #70]	; 0x46
    8580:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    8582:	8b1b      	ldrh	r3, [r3, #24]
    8584:	4619      	mov	r1, r3
    8586:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    8588:	8a9b      	ldrh	r3, [r3, #20]
    858a:	1acb      	subs	r3, r1, r3
    858c:	429a      	cmp	r2, r3
    858e:	dd08      	ble.n	85a2 <Lpspi_Ip_TransferProcess+0xa2>
                {
                    NumberOfReads = (uint8)(State->ExpectedFifoReads - State->RxIndex);
    8590:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    8592:	8b1b      	ldrh	r3, [r3, #24]
    8594:	b2da      	uxtb	r2, r3
    8596:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    8598:	8a9b      	ldrh	r3, [r3, #20]
    859a:	b2db      	uxtb	r3, r3
    859c:	1ad3      	subs	r3, r2, r3
    859e:	f88d 3046 	strb.w	r3, [sp, #70]	; 0x46
                }
                /* If these are the first frames of this channel. Current TXFIFO slot must be plus 1 because the slot of CMD have moved out and
                  CurrentTxFifoSlot was minus 1 when prepare TX channel */
                if (0u == State->RxIndex)
    85a2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    85a4:	8a9b      	ldrh	r3, [r3, #20]
    85a6:	2b00      	cmp	r3, #0
    85a8:	d107      	bne.n	85ba <Lpspi_Ip_TransferProcess+0xba>
                {
                    State->CurrentTxFifoSlot += 1u;
    85aa:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    85ac:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    85b0:	3301      	adds	r3, #1
    85b2:	b2da      	uxtb	r2, r3
    85b4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    85b6:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    85ba:	f89d 300f 	ldrb.w	r3, [sp, #15]
    85be:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    85c2:	f89d 3046 	ldrb.w	r3, [sp, #70]	; 0x46
    85c6:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    const LPSPI_Type* Base = Lpspi_Ip_apxBases[Instance];
    85ca:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
    85ce:	4a7d      	ldr	r2, [pc, #500]	; (87c4 <Lpspi_Ip_TransferProcess+0x2c4>)
    85d0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    85d4:	930c      	str	r3, [sp, #48]	; 0x30
    Lpspi_Ip_StateStructureType* State = Lpspi_Ip_apxStateStructureArray[Instance];
    85d6:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
    85da:	4a7b      	ldr	r2, [pc, #492]	; (87c8 <Lpspi_Ip_TransferProcess+0x2c8>)
    85dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    85e0:	930b      	str	r3, [sp, #44]	; 0x2c
    uint32 Data = 0u;
    85e2:	2300      	movs	r3, #0
    85e4:	930a      	str	r3, [sp, #40]	; 0x28
    uint8 Index = 0u;
    85e6:	2300      	movs	r3, #0
    85e8:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    if (NULL_PTR != State->RxBuffer)
    85ec:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    85ee:	689b      	ldr	r3, [r3, #8]
    85f0:	2b00      	cmp	r3, #0
    85f2:	d069      	beq.n	86c8 <Lpspi_Ip_TransferProcess+0x1c8>
        if (State->ExternalDevice->DeviceParams->FrameSize < 9u)
    85f4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    85f6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    85f8:	68db      	ldr	r3, [r3, #12]
    85fa:	881b      	ldrh	r3, [r3, #0]
    85fc:	2b08      	cmp	r3, #8
    85fe:	d81e      	bhi.n	863e <Lpspi_Ip_TransferProcess+0x13e>
            for (Index = 0; Index < NumberOfReads; Index++)
    8600:	2300      	movs	r3, #0
    8602:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    8606:	e013      	b.n	8630 <Lpspi_Ip_TransferProcess+0x130>
                Data = Base->RDR;
    8608:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    860a:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    860c:	930a      	str	r3, [sp, #40]	; 0x28
                *((uint8*)(&State->RxBuffer[State->RxIndex + Index])) = (uint8)Data;
    860e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    8610:	689b      	ldr	r3, [r3, #8]
    8612:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    8614:	8a92      	ldrh	r2, [r2, #20]
    8616:	4611      	mov	r1, r2
    8618:	f89d 2027 	ldrb.w	r2, [sp, #39]	; 0x27
    861c:	440a      	add	r2, r1
    861e:	4413      	add	r3, r2
    8620:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    8622:	b2d2      	uxtb	r2, r2
    8624:	701a      	strb	r2, [r3, #0]
            for (Index = 0; Index < NumberOfReads; Index++)
    8626:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    862a:	3301      	adds	r3, #1
    862c:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    8630:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
    8634:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    8638:	429a      	cmp	r2, r3
    863a:	d8e5      	bhi.n	8608 <Lpspi_Ip_TransferProcess+0x108>
    863c:	e055      	b.n	86ea <Lpspi_Ip_TransferProcess+0x1ea>
        else if (State->ExternalDevice->DeviceParams->FrameSize < 17u)
    863e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    8640:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    8642:	68db      	ldr	r3, [r3, #12]
    8644:	881b      	ldrh	r3, [r3, #0]
    8646:	2b10      	cmp	r3, #16
    8648:	d81f      	bhi.n	868a <Lpspi_Ip_TransferProcess+0x18a>
            for (Index = 0; Index < NumberOfReads; Index++)
    864a:	2300      	movs	r3, #0
    864c:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    8650:	e014      	b.n	867c <Lpspi_Ip_TransferProcess+0x17c>
                Data = Base->RDR;
    8652:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    8654:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    8656:	930a      	str	r3, [sp, #40]	; 0x28
                *((uint16*)(&State->RxBuffer[2u * (State->RxIndex + Index)])) = (uint16)Data;
    8658:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    865a:	689a      	ldr	r2, [r3, #8]
    865c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    865e:	8a9b      	ldrh	r3, [r3, #20]
    8660:	4619      	mov	r1, r3
    8662:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    8666:	440b      	add	r3, r1
    8668:	005b      	lsls	r3, r3, #1
    866a:	4413      	add	r3, r2
    866c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    866e:	b292      	uxth	r2, r2
    8670:	801a      	strh	r2, [r3, #0]
            for (Index = 0; Index < NumberOfReads; Index++)
    8672:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    8676:	3301      	adds	r3, #1
    8678:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    867c:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
    8680:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    8684:	429a      	cmp	r2, r3
    8686:	d8e4      	bhi.n	8652 <Lpspi_Ip_TransferProcess+0x152>
    8688:	e02f      	b.n	86ea <Lpspi_Ip_TransferProcess+0x1ea>
            for (Index = 0; Index < NumberOfReads; Index++)
    868a:	2300      	movs	r3, #0
    868c:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    8690:	e013      	b.n	86ba <Lpspi_Ip_TransferProcess+0x1ba>
                Data = Base->RDR;
    8692:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    8694:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    8696:	930a      	str	r3, [sp, #40]	; 0x28
                *((uint32*)(&State->RxBuffer[4u * (State->RxIndex + Index)])) = (uint32)Data;
    8698:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    869a:	689a      	ldr	r2, [r3, #8]
    869c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    869e:	8a9b      	ldrh	r3, [r3, #20]
    86a0:	4619      	mov	r1, r3
    86a2:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    86a6:	440b      	add	r3, r1
    86a8:	009b      	lsls	r3, r3, #2
    86aa:	4413      	add	r3, r2
    86ac:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    86ae:	601a      	str	r2, [r3, #0]
            for (Index = 0; Index < NumberOfReads; Index++)
    86b0:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    86b4:	3301      	adds	r3, #1
    86b6:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    86ba:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
    86be:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    86c2:	429a      	cmp	r2, r3
    86c4:	d8e5      	bhi.n	8692 <Lpspi_Ip_TransferProcess+0x192>
    86c6:	e010      	b.n	86ea <Lpspi_Ip_TransferProcess+0x1ea>
        for (Index = 0; Index < NumberOfReads; Index++)
    86c8:	2300      	movs	r3, #0
    86ca:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    86ce:	e006      	b.n	86de <Lpspi_Ip_TransferProcess+0x1de>
            (void)Base->RDR;
    86d0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    86d2:	6f5b      	ldr	r3, [r3, #116]	; 0x74
        for (Index = 0; Index < NumberOfReads; Index++)
    86d4:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    86d8:	3301      	adds	r3, #1
    86da:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    86de:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
    86e2:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    86e6:	429a      	cmp	r2, r3
    86e8:	d8f2      	bhi.n	86d0 <Lpspi_Ip_TransferProcess+0x1d0>
    State->RxIndex += NumberOfReads;
    86ea:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    86ec:	8a9a      	ldrh	r2, [r3, #20]
    86ee:	f89d 3036 	ldrb.w	r3, [sp, #54]	; 0x36
    86f2:	b29b      	uxth	r3, r3
    86f4:	4413      	add	r3, r2
    86f6:	b29a      	uxth	r2, r3
    86f8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    86fa:	829a      	strh	r2, [r3, #20]
}
    86fc:	bf00      	nop
                }
                /* Read Data from RX FIFO */
                Lpspi_Ip_ReadDataFromFifo(Instance, NumberOfReads);
                /* Update current FIFO slots are available to fill .*/
                State->CurrentTxFifoSlot += NumberOfReads;
    86fe:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    8700:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
    8704:	f89d 3046 	ldrb.w	r3, [sp, #70]	; 0x46
    8708:	4413      	add	r3, r2
    870a:	b2da      	uxtb	r2, r3
    870c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    870e:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
            to fill TX FIFO. At that time, another interrupt occurred and preemptive current interrupt, and the time to process that interrupt is longer than the time to transfer all frames 
            in TX FIFO. So TX FIFO will be empty and some frames received in RX FIFO, then the program is returned from that interrupt and fill TX FIFO until full and exist SPI interrupt function. 
            And if there is a interrupt occurred with higher priority of SPI interrupt and the time to process that interrupt is longer than the time to transfer all frames in TX FIFO. 
            So, RX FIFO can be overflow due to SPI interrupt function is not serviced to read RX FIFO.
            State->CurrentTxFifoSlot variable is used to hanlde number of frames are "on bus transfer". They are always less than FIFO size */
            if((State->CurrentTxFifoSlot != 0u) && (State->TxDoneFlag != TRUE))
    8712:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    8714:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    8718:	2b00      	cmp	r3, #0
    871a:	f000 8119 	beq.w	8950 <Lpspi_Ip_TransferProcess+0x450>
    871e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    8720:	f893 303d 	ldrb.w	r3, [r3, #61]	; 0x3d
    8724:	f083 0301 	eor.w	r3, r3, #1
    8728:	b2db      	uxtb	r3, r3
    872a:	2b00      	cmp	r3, #0
    872c:	f000 8110 	beq.w	8950 <Lpspi_Ip_TransferProcess+0x450>
            {
                if(State->ExpectedFifoWrites != State->TxIndex)
    8730:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    8732:	8b5a      	ldrh	r2, [r3, #26]
    8734:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    8736:	8adb      	ldrh	r3, [r3, #22]
    8738:	429a      	cmp	r2, r3
    873a:	f000 80ca 	beq.w	88d2 <Lpspi_Ip_TransferProcess+0x3d2>
                {
                    NumberOfWrites = State->CurrentTxFifoSlot;
    873e:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    8740:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    8744:	f88d 3047 	strb.w	r3, [sp, #71]	; 0x47
                    /* Limits to remaining frames. */
                    if (NumberOfWrites > (State->ExpectedFifoWrites - State->TxIndex))
    8748:	f89d 2047 	ldrb.w	r2, [sp, #71]	; 0x47
    874c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    874e:	8b5b      	ldrh	r3, [r3, #26]
    8750:	4619      	mov	r1, r3
    8752:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    8754:	8adb      	ldrh	r3, [r3, #22]
    8756:	1acb      	subs	r3, r1, r3
    8758:	429a      	cmp	r2, r3
    875a:	dd08      	ble.n	876e <Lpspi_Ip_TransferProcess+0x26e>
                    {
                        NumberOfWrites = (uint8)(State->ExpectedFifoWrites - State->TxIndex);
    875c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    875e:	8b5b      	ldrh	r3, [r3, #26]
    8760:	b2da      	uxtb	r2, r3
    8762:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    8764:	8adb      	ldrh	r3, [r3, #22]
    8766:	b2db      	uxtb	r3, r3
    8768:	1ad3      	subs	r3, r2, r3
    876a:	f88d 3047 	strb.w	r3, [sp, #71]	; 0x47
    876e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    8772:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
    8776:	f89d 3047 	ldrb.w	r3, [sp, #71]	; 0x47
    877a:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
    LPSPI_Type* Base = Lpspi_Ip_apxBases[Instance];
    877e:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
    8782:	4a10      	ldr	r2, [pc, #64]	; (87c4 <Lpspi_Ip_TransferProcess+0x2c4>)
    8784:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8788:	9308      	str	r3, [sp, #32]
    Lpspi_Ip_StateStructureType* State = Lpspi_Ip_apxStateStructureArray[Instance];
    878a:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
    878e:	4a0e      	ldr	r2, [pc, #56]	; (87c8 <Lpspi_Ip_TransferProcess+0x2c8>)
    8790:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8794:	9307      	str	r3, [sp, #28]
    uint32 Data = 0u;
    8796:	2300      	movs	r3, #0
    8798:	9306      	str	r3, [sp, #24]
    uint8 Index = 0u;
    879a:	2300      	movs	r3, #0
    879c:	f88d 3017 	strb.w	r3, [sp, #23]
    Data = State->ExternalDevice->DeviceParams->DefaultData;
    87a0:	9b07      	ldr	r3, [sp, #28]
    87a2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    87a4:	68db      	ldr	r3, [r3, #12]
    87a6:	685b      	ldr	r3, [r3, #4]
    87a8:	9306      	str	r3, [sp, #24]
    if (NULL_PTR != State->TxBuffer)
    87aa:	9b07      	ldr	r3, [sp, #28]
    87ac:	68db      	ldr	r3, [r3, #12]
    87ae:	2b00      	cmp	r3, #0
    87b0:	d068      	beq.n	8884 <Lpspi_Ip_TransferProcess+0x384>
        if (State->TxFrameSize < 9u)
    87b2:	9b07      	ldr	r3, [sp, #28]
    87b4:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    87b6:	2b08      	cmp	r3, #8
    87b8:	d822      	bhi.n	8800 <Lpspi_Ip_TransferProcess+0x300>
            for (Index = 0; Index < NumberOfWrites; Index++)
    87ba:	2300      	movs	r3, #0
    87bc:	f88d 3017 	strb.w	r3, [sp, #23]
    87c0:	e017      	b.n	87f2 <Lpspi_Ip_TransferProcess+0x2f2>
    87c2:	bf00      	nop
    87c4:	000186c4 	.word	0x000186c4
    87c8:	1fff8ddc 	.word	0x1fff8ddc
                Data = *((const uint8*)(&State->TxBuffer[State->TxIndex + Index]));
    87cc:	9b07      	ldr	r3, [sp, #28]
    87ce:	68db      	ldr	r3, [r3, #12]
    87d0:	9a07      	ldr	r2, [sp, #28]
    87d2:	8ad2      	ldrh	r2, [r2, #22]
    87d4:	4611      	mov	r1, r2
    87d6:	f89d 2017 	ldrb.w	r2, [sp, #23]
    87da:	440a      	add	r2, r1
    87dc:	4413      	add	r3, r2
    87de:	781b      	ldrb	r3, [r3, #0]
    87e0:	9306      	str	r3, [sp, #24]
                Base->TDR = Data;
    87e2:	9b08      	ldr	r3, [sp, #32]
    87e4:	9a06      	ldr	r2, [sp, #24]
    87e6:	665a      	str	r2, [r3, #100]	; 0x64
            for (Index = 0; Index < NumberOfWrites; Index++)
    87e8:	f89d 3017 	ldrb.w	r3, [sp, #23]
    87ec:	3301      	adds	r3, #1
    87ee:	f88d 3017 	strb.w	r3, [sp, #23]
    87f2:	f89d 2025 	ldrb.w	r2, [sp, #37]	; 0x25
    87f6:	f89d 3017 	ldrb.w	r3, [sp, #23]
    87fa:	429a      	cmp	r2, r3
    87fc:	d8e6      	bhi.n	87cc <Lpspi_Ip_TransferProcess+0x2cc>
    87fe:	e053      	b.n	88a8 <Lpspi_Ip_TransferProcess+0x3a8>
        else if (State->TxFrameSize < 17u)
    8800:	9b07      	ldr	r3, [sp, #28]
    8802:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    8804:	2b10      	cmp	r3, #16
    8806:	d81e      	bhi.n	8846 <Lpspi_Ip_TransferProcess+0x346>
            for (Index = 0; Index < NumberOfWrites; Index++)
    8808:	2300      	movs	r3, #0
    880a:	f88d 3017 	strb.w	r3, [sp, #23]
    880e:	e013      	b.n	8838 <Lpspi_Ip_TransferProcess+0x338>
                Data = *((const uint16*)(&State->TxBuffer[2u * (State->TxIndex + Index)]));
    8810:	9b07      	ldr	r3, [sp, #28]
    8812:	68da      	ldr	r2, [r3, #12]
    8814:	9b07      	ldr	r3, [sp, #28]
    8816:	8adb      	ldrh	r3, [r3, #22]
    8818:	4619      	mov	r1, r3
    881a:	f89d 3017 	ldrb.w	r3, [sp, #23]
    881e:	440b      	add	r3, r1
    8820:	005b      	lsls	r3, r3, #1
    8822:	4413      	add	r3, r2
    8824:	881b      	ldrh	r3, [r3, #0]
    8826:	9306      	str	r3, [sp, #24]
                Base->TDR = Data;
    8828:	9b08      	ldr	r3, [sp, #32]
    882a:	9a06      	ldr	r2, [sp, #24]
    882c:	665a      	str	r2, [r3, #100]	; 0x64
            for (Index = 0; Index < NumberOfWrites; Index++)
    882e:	f89d 3017 	ldrb.w	r3, [sp, #23]
    8832:	3301      	adds	r3, #1
    8834:	f88d 3017 	strb.w	r3, [sp, #23]
    8838:	f89d 2025 	ldrb.w	r2, [sp, #37]	; 0x25
    883c:	f89d 3017 	ldrb.w	r3, [sp, #23]
    8840:	429a      	cmp	r2, r3
    8842:	d8e5      	bhi.n	8810 <Lpspi_Ip_TransferProcess+0x310>
    8844:	e030      	b.n	88a8 <Lpspi_Ip_TransferProcess+0x3a8>
            for (Index = 0; Index < NumberOfWrites; Index++)
    8846:	2300      	movs	r3, #0
    8848:	f88d 3017 	strb.w	r3, [sp, #23]
    884c:	e013      	b.n	8876 <Lpspi_Ip_TransferProcess+0x376>
                Data = *((const uint32*)(&State->TxBuffer[4u * (State->TxIndex + Index)]));
    884e:	9b07      	ldr	r3, [sp, #28]
    8850:	68da      	ldr	r2, [r3, #12]
    8852:	9b07      	ldr	r3, [sp, #28]
    8854:	8adb      	ldrh	r3, [r3, #22]
    8856:	4619      	mov	r1, r3
    8858:	f89d 3017 	ldrb.w	r3, [sp, #23]
    885c:	440b      	add	r3, r1
    885e:	009b      	lsls	r3, r3, #2
    8860:	4413      	add	r3, r2
    8862:	681b      	ldr	r3, [r3, #0]
    8864:	9306      	str	r3, [sp, #24]
                Base->TDR = Data;
    8866:	9b08      	ldr	r3, [sp, #32]
    8868:	9a06      	ldr	r2, [sp, #24]
    886a:	665a      	str	r2, [r3, #100]	; 0x64
            for (Index = 0; Index < NumberOfWrites; Index++)
    886c:	f89d 3017 	ldrb.w	r3, [sp, #23]
    8870:	3301      	adds	r3, #1
    8872:	f88d 3017 	strb.w	r3, [sp, #23]
    8876:	f89d 2025 	ldrb.w	r2, [sp, #37]	; 0x25
    887a:	f89d 3017 	ldrb.w	r3, [sp, #23]
    887e:	429a      	cmp	r2, r3
    8880:	d8e5      	bhi.n	884e <Lpspi_Ip_TransferProcess+0x34e>
    8882:	e011      	b.n	88a8 <Lpspi_Ip_TransferProcess+0x3a8>
        for (Index = 0; Index < NumberOfWrites; Index++)
    8884:	2300      	movs	r3, #0
    8886:	f88d 3017 	strb.w	r3, [sp, #23]
    888a:	e007      	b.n	889c <Lpspi_Ip_TransferProcess+0x39c>
            Base->TDR = Data;
    888c:	9b08      	ldr	r3, [sp, #32]
    888e:	9a06      	ldr	r2, [sp, #24]
    8890:	665a      	str	r2, [r3, #100]	; 0x64
        for (Index = 0; Index < NumberOfWrites; Index++)
    8892:	f89d 3017 	ldrb.w	r3, [sp, #23]
    8896:	3301      	adds	r3, #1
    8898:	f88d 3017 	strb.w	r3, [sp, #23]
    889c:	f89d 2025 	ldrb.w	r2, [sp, #37]	; 0x25
    88a0:	f89d 3017 	ldrb.w	r3, [sp, #23]
    88a4:	429a      	cmp	r2, r3
    88a6:	d8f1      	bhi.n	888c <Lpspi_Ip_TransferProcess+0x38c>
    State->TxIndex += NumberOfWrites;
    88a8:	9b07      	ldr	r3, [sp, #28]
    88aa:	8ada      	ldrh	r2, [r3, #22]
    88ac:	f89d 3025 	ldrb.w	r3, [sp, #37]	; 0x25
    88b0:	b29b      	uxth	r3, r3
    88b2:	4413      	add	r3, r2
    88b4:	b29a      	uxth	r2, r3
    88b6:	9b07      	ldr	r3, [sp, #28]
    88b8:	82da      	strh	r2, [r3, #22]
}
    88ba:	bf00      	nop
                    }
                    /* Push Data into TX FIFO */
                    Lpspi_Ip_PushDataToFifo(Instance, NumberOfWrites);
                    State->CurrentTxFifoSlot -= NumberOfWrites;
    88bc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    88be:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
    88c2:	f89d 3047 	ldrb.w	r3, [sp, #71]	; 0x47
    88c6:	1ad3      	subs	r3, r2, r3
    88c8:	b2da      	uxtb	r2, r3
    88ca:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    88cc:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    88d0:	e03e      	b.n	8950 <Lpspi_Ip_TransferProcess+0x450>
                }
                else
                {
                    if(TRUE == State->NextTransferConfigAvailable)
    88d2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    88d4:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
    88d8:	2b00      	cmp	r3, #0
    88da:	d01c      	beq.n	8916 <Lpspi_Ip_TransferProcess+0x416>
                    {
                        /* Initialize next transfer */
                        State->ExternalDevice->DeviceParams->DefaultData = State->DefaultDataNext;
    88dc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    88de:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    88e0:	68db      	ldr	r3, [r3, #12]
    88e2:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    88e4:	6b52      	ldr	r2, [r2, #52]	; 0x34
    88e6:	605a      	str	r2, [r3, #4]
                        State->FirstCmd = FALSE;
    88e8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    88ea:	2200      	movs	r2, #0
    88ec:	775a      	strb	r2, [r3, #29]
                        Lpspi_TransmitTxInit(Instance, State->TxBufferNext, State->FrameSizeNext, State->LsbNext, State->LengthNext);
    88ee:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    88f0:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
    88f2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    88f4:	8e1a      	ldrh	r2, [r3, #48]	; 0x30
    88f6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    88f8:	f893 4032 	ldrb.w	r4, [r3, #50]	; 0x32
    88fc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    88fe:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
    8900:	f89d 000f 	ldrb.w	r0, [sp, #15]
    8904:	9300      	str	r3, [sp, #0]
    8906:	4623      	mov	r3, r4
    8908:	f000 fb7a 	bl	9000 <Lpspi_TransmitTxInit>
                        State->NextTransferConfigAvailable = FALSE;
    890c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    890e:	2200      	movs	r2, #0
    8910:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
    8914:	e01c      	b.n	8950 <Lpspi_Ip_TransferProcess+0x450>
                    }
                    else
                    {
                        State->TxDoneFlag = TRUE;
    8916:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    8918:	2201      	movs	r2, #1
    891a:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
                        /* Disable TX interrupt */
                        Base->IER &= ~LPSPI_IER_TDIE_MASK;
    891e:	9b10      	ldr	r3, [sp, #64]	; 0x40
    8920:	699b      	ldr	r3, [r3, #24]
    8922:	f023 0201 	bic.w	r2, r3, #1
    8926:	9b10      	ldr	r3, [sp, #64]	; 0x40
    8928:	619a      	str	r2, [r3, #24]
                        if((FALSE == State->KeepCs) && (0u != (Base->TCR & LPSPI_TCR_CONT_MASK)))
    892a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    892c:	7f1b      	ldrb	r3, [r3, #28]
    892e:	f083 0301 	eor.w	r3, r3, #1
    8932:	b2db      	uxtb	r3, r3
    8934:	2b00      	cmp	r3, #0
    8936:	d00b      	beq.n	8950 <Lpspi_Ip_TransferProcess+0x450>
    8938:	9b10      	ldr	r3, [sp, #64]	; 0x40
    893a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    893c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
    8940:	2b00      	cmp	r3, #0
    8942:	d005      	beq.n	8950 <Lpspi_Ip_TransferProcess+0x450>
                        {
                            /* Clear CS */
                            Base->TCR &= ~(LPSPI_TCR_CONT_MASK | LPSPI_TCR_CONTC_MASK);
    8944:	9b10      	ldr	r3, [sp, #64]	; 0x40
    8946:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    8948:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
    894c:	9b10      	ldr	r3, [sp, #64]	; 0x40
    894e:	661a      	str	r2, [r3, #96]	; 0x60
                }
            }
        }
        
        /* End of transfer */
        if((State->RxIndex == State->ExpectedFifoReads) || (TRUE == ErrorFlag))
    8950:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    8952:	8a9a      	ldrh	r2, [r3, #20]
    8954:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    8956:	8b1b      	ldrh	r3, [r3, #24]
    8958:	429a      	cmp	r2, r3
    895a:	d003      	beq.n	8964 <Lpspi_Ip_TransferProcess+0x464>
    895c:	f89d 3045 	ldrb.w	r3, [sp, #69]	; 0x45
    8960:	2b00      	cmp	r3, #0
    8962:	d00a      	beq.n	897a <Lpspi_Ip_TransferProcess+0x47a>
                Base->TCR |= LPSPI_TCR_RXMSK(1);
                SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_12();
            }
            #endif
            /* Disable interrupts */
            Base->IER = 0u;
    8964:	9b10      	ldr	r3, [sp, #64]	; 0x40
    8966:	2200      	movs	r2, #0
    8968:	619a      	str	r2, [r3, #24]
            Lpspi_Ip_ChannelFinished(Instance, ErrorFlag);
    896a:	f89d 2045 	ldrb.w	r2, [sp, #69]	; 0x45
    896e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    8972:	4611      	mov	r1, r2
    8974:	4618      	mov	r0, r3
    8976:	f7ff fd91 	bl	849c <Lpspi_Ip_ChannelFinished>
        }
    }
}
    897a:	bf00      	nop
    897c:	b012      	add	sp, #72	; 0x48
    897e:	bd10      	pop	{r4, pc}

00008980 <Lpspi_Ip_Init>:
    OsIf_Trusted_Call1param(Lpspi_Ip_SetUserAccess, Instance);
}
#endif /* LPSPI_IP_ENABLE_USER_MODE_SUPPORT */
/*================================================================================================*/
Lpspi_Ip_StatusType Lpspi_Ip_Init(const Lpspi_Ip_ConfigType *PhyUnitConfigPtr)
{
    8980:	b500      	push	{lr}
    8982:	b087      	sub	sp, #28
    8984:	9001      	str	r0, [sp, #4]
    LPSPI_Type* Base;
    Lpspi_Ip_StateStructureType* State;
    Lpspi_Ip_StatusType Status = LPSPI_IP_STATUS_SUCCESS;
    8986:	2300      	movs	r3, #0
    8988:	9305      	str	r3, [sp, #20]
    uint8 Instance = 0u;
    898a:	2300      	movs	r3, #0
    898c:	f88d 3013 	strb.w	r3, [sp, #19]

    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(PhyUnitConfigPtr != NULL_PTR);
    #endif
    Instance = PhyUnitConfigPtr->Instance;
    8990:	9b01      	ldr	r3, [sp, #4]
    8992:	781b      	ldrb	r3, [r3, #0]
    8994:	f88d 3013 	strb.w	r3, [sp, #19]
    State = Lpspi_Ip_apxStateStructureArray[Instance];
    8998:	f89d 3013 	ldrb.w	r3, [sp, #19]
    899c:	4a23      	ldr	r2, [pc, #140]	; (8a2c <Lpspi_Ip_Init+0xac>)
    899e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    89a2:	9303      	str	r3, [sp, #12]
    Base = Lpspi_Ip_apxBases[Instance];
    89a4:	f89d 3013 	ldrb.w	r3, [sp, #19]
    89a8:	4a21      	ldr	r2, [pc, #132]	; (8a30 <Lpspi_Ip_Init+0xb0>)
    89aa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    89ae:	9302      	str	r3, [sp, #8]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(State == NULL_PTR);
    #endif
    Lpspi_Ip_apxStateStructureArray[Instance] = &Lpspi_Ip_axStateStructure[PhyUnitConfigPtr->StateIndex];
    89b0:	9b01      	ldr	r3, [sp, #4]
    89b2:	7c1b      	ldrb	r3, [r3, #16]
    89b4:	461a      	mov	r2, r3
    89b6:	f89d 3013 	ldrb.w	r3, [sp, #19]
    89ba:	0192      	lsls	r2, r2, #6
    89bc:	491d      	ldr	r1, [pc, #116]	; (8a34 <Lpspi_Ip_Init+0xb4>)
    89be:	440a      	add	r2, r1
    89c0:	491a      	ldr	r1, [pc, #104]	; (8a2c <Lpspi_Ip_Init+0xac>)
    89c2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    State = Lpspi_Ip_apxStateStructureArray[Instance];
    89c6:	f89d 3013 	ldrb.w	r3, [sp, #19]
    89ca:	4a18      	ldr	r2, [pc, #96]	; (8a2c <Lpspi_Ip_Init+0xac>)
    89cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    89d0:	9303      	str	r3, [sp, #12]
    State->PhyUnitConfig = PhyUnitConfigPtr;
    89d2:	9b03      	ldr	r3, [sp, #12]
    89d4:	9a01      	ldr	r2, [sp, #4]
    89d6:	621a      	str	r2, [r3, #32]
    /* enable in debug mode to ensure CS will be kept when CPU halts at breakpoint */
    Base->CR = PhyUnitConfigPtr->Cr | LPSPI_CR_DBGEN_MASK;
    89d8:	9b01      	ldr	r3, [sp, #4]
    89da:	685b      	ldr	r3, [r3, #4]
    89dc:	f043 0208 	orr.w	r2, r3, #8
    89e0:	9b02      	ldr	r3, [sp, #8]
    89e2:	611a      	str	r2, [r3, #16]
    Base->CFGR1 = PhyUnitConfigPtr->Cfgr1;
    89e4:	9b01      	ldr	r3, [sp, #4]
    89e6:	689a      	ldr	r2, [r3, #8]
    89e8:	9b02      	ldr	r3, [sp, #8]
    89ea:	625a      	str	r2, [r3, #36]	; 0x24
    /* Set TX WATER. it will be set again in DMA mode */
    Base->FCR = LPSPI_FCR_TXWATER((uint32)LPSPI_IP_FIFO_SIZE_U8 - (uint32)1u);
    89ec:	9b02      	ldr	r3, [sp, #8]
    89ee:	2203      	movs	r2, #3
    89f0:	659a      	str	r2, [r3, #88]	; 0x58
    #if (STD_ON == LPSPI_IP_DUAL_CLOCK_MODE)
    State->ClockMode = LPSPI_IP_NORMAL_CLOCK;
    #endif
    State->KeepCs = FALSE;
    89f2:	9b03      	ldr	r3, [sp, #12]
    89f4:	2200      	movs	r2, #0
    89f6:	771a      	strb	r2, [r3, #28]
    State->FirstCmd = TRUE;
    89f8:	9b03      	ldr	r3, [sp, #12]
    89fa:	2201      	movs	r2, #1
    89fc:	775a      	strb	r2, [r3, #29]
    #if ((STD_ON == LPSPI_IP_DMA_USED) && (STD_ON == LPSPI_IP_ENABLE_DMAFASTTRANSFER_SUPPORT))
    Lpspi_Ip_TxDmaTcdSGInit(Instance);
    Lpspi_Ip_RxDmaTcdSGInit(Instance);
    #endif
    /* set State to idle */
    State->Status = LPSPI_IP_IDLE;
    89fe:	9b03      	ldr	r3, [sp, #12]
    8a00:	2201      	movs	r2, #1
    8a02:	605a      	str	r2, [r3, #4]
    (void)Lpspi_Ip_UpdateTransferMode(Instance, PhyUnitConfigPtr->TransferMode);
    8a04:	9b01      	ldr	r3, [sp, #4]
    8a06:	68da      	ldr	r2, [r3, #12]
    8a08:	f89d 3013 	ldrb.w	r3, [sp, #19]
    8a0c:	4611      	mov	r1, r2
    8a0e:	4618      	mov	r0, r3
    8a10:	f000 fd10 	bl	9434 <Lpspi_Ip_UpdateTransferMode>
    
    /* Enable SPI module */
    Base->CR |= LPSPI_CR_MEN_MASK;
    8a14:	9b02      	ldr	r3, [sp, #8]
    8a16:	691b      	ldr	r3, [r3, #16]
    8a18:	f043 0201 	orr.w	r2, r3, #1
    8a1c:	9b02      	ldr	r3, [sp, #8]
    8a1e:	611a      	str	r2, [r3, #16]
    return Status;
    8a20:	9b05      	ldr	r3, [sp, #20]
}
    8a22:	4618      	mov	r0, r3
    8a24:	b007      	add	sp, #28
    8a26:	f85d fb04 	ldr.w	pc, [sp], #4
    8a2a:	bf00      	nop
    8a2c:	1fff8ddc 	.word	0x1fff8ddc
    8a30:	000186c4 	.word	0x000186c4
    8a34:	1fff8d9c 	.word	0x1fff8d9c

00008a38 <Lpspi_Ip_DeInit>:
/*================================================================================================*/
Lpspi_Ip_StatusType Lpspi_Ip_DeInit(uint8 Instance)
{
    8a38:	b086      	sub	sp, #24
    8a3a:	4603      	mov	r3, r0
    8a3c:	f88d 3007 	strb.w	r3, [sp, #7]
    LPSPI_Type* Base;
    const Lpspi_Ip_StateStructureType* State;
    Lpspi_Ip_StatusType Status = LPSPI_IP_STATUS_SUCCESS;
    8a40:	2300      	movs	r3, #0
    8a42:	9305      	str	r3, [sp, #20]

    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(Instance < LPSPI_INSTANCE_COUNT);
    #endif
    Base = Lpspi_Ip_apxBases[Instance];
    8a44:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8a48:	4a11      	ldr	r2, [pc, #68]	; (8a90 <Lpspi_Ip_DeInit+0x58>)
    8a4a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8a4e:	9304      	str	r3, [sp, #16]
    State = Lpspi_Ip_apxStateStructureArray[Instance];
    8a50:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8a54:	4a0f      	ldr	r2, [pc, #60]	; (8a94 <Lpspi_Ip_DeInit+0x5c>)
    8a56:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8a5a:	9303      	str	r3, [sp, #12]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != State);
    #endif
    if (LPSPI_IP_BUSY == State->Status)
    8a5c:	9b03      	ldr	r3, [sp, #12]
    8a5e:	685b      	ldr	r3, [r3, #4]
    8a60:	2b02      	cmp	r3, #2
    8a62:	d102      	bne.n	8a6a <Lpspi_Ip_DeInit+0x32>
    {
        Status = LPSPI_IP_STATUS_FAIL;
    8a64:	2301      	movs	r3, #1
    8a66:	9305      	str	r3, [sp, #20]
    8a68:	e00e      	b.n	8a88 <Lpspi_Ip_DeInit+0x50>
    }
    else
    {
        /* Use reset hardware feature. */
        Base->CR |= LPSPI_CR_RST(1u);
    8a6a:	9b04      	ldr	r3, [sp, #16]
    8a6c:	691b      	ldr	r3, [r3, #16]
    8a6e:	f043 0202 	orr.w	r2, r3, #2
    8a72:	9b04      	ldr	r3, [sp, #16]
    8a74:	611a      	str	r2, [r3, #16]
        Base->CR = 0;
    8a76:	9b04      	ldr	r3, [sp, #16]
    8a78:	2200      	movs	r2, #0
    8a7a:	611a      	str	r2, [r3, #16]

        Lpspi_Ip_apxStateStructureArray[Instance] = NULL_PTR;
    8a7c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8a80:	4a04      	ldr	r2, [pc, #16]	; (8a94 <Lpspi_Ip_DeInit+0x5c>)
    8a82:	2100      	movs	r1, #0
    8a84:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    }
    return Status;
    8a88:	9b05      	ldr	r3, [sp, #20]
}
    8a8a:	4618      	mov	r0, r3
    8a8c:	b006      	add	sp, #24
    8a8e:	4770      	bx	lr
    8a90:	000186c4 	.word	0x000186c4
    8a94:	1fff8ddc 	.word	0x1fff8ddc

00008a98 <Lpspi_Ip_SyncTransmit>:
                                            const uint8 *TxBuffer,
                                            uint8 *RxBuffer,
                                            uint16 Length,
                                            uint32 TimeOut
                                         )
{
    8a98:	b510      	push	{r4, lr}
    8a9a:	b09a      	sub	sp, #104	; 0x68
    8a9c:	9005      	str	r0, [sp, #20]
    8a9e:	9104      	str	r1, [sp, #16]
    8aa0:	9203      	str	r2, [sp, #12]
    8aa2:	f8ad 300a 	strh.w	r3, [sp, #10]
    LPSPI_Type *Base;
    Lpspi_Ip_StateStructureType *State;
    uint8 NumberOfWrites, NumberOfReads;
    Lpspi_Ip_StatusType Status = LPSPI_IP_STATUS_SUCCESS;
    8aa6:	2300      	movs	r3, #0
    8aa8:	9318      	str	r3, [sp, #96]	; 0x60
    uint32 TimeoutTicks = OsIf_MicrosToTicks(TimeOut, LPSPI_IP_TIMEOUT_METHOD);
    8aaa:	2100      	movs	r1, #0
    8aac:	981c      	ldr	r0, [sp, #112]	; 0x70
    8aae:	f7f9 fa89 	bl	1fc4 <OsIf_MicrosToTicks>
    8ab2:	9015      	str	r0, [sp, #84]	; 0x54
    uint32 CurrentTicks = 0u; /* initialize current counter */
    8ab4:	2300      	movs	r3, #0
    8ab6:	9307      	str	r3, [sp, #28]
    uint32 ElapsedTicks = 0u; /* elapsed will give timeout */
    8ab8:	2300      	movs	r3, #0
    8aba:	9317      	str	r3, [sp, #92]	; 0x5c
    uint8 Instance = 0u;
    8abc:	2300      	movs	r3, #0
    8abe:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
    uint32 Cfgr1 = 0u;
    8ac2:	2300      	movs	r3, #0
    8ac4:	9313      	str	r3, [sp, #76]	; 0x4c
    boolean TxDoneFlag = FALSE;
    8ac6:	2300      	movs	r3, #0
    8ac8:	f88d 305b 	strb.w	r3, [sp, #91]	; 0x5b
    DevAssert(ExternalDevice != NULL_PTR);
    DevAssert(0u != Length);
    DevAssert(0u != TimeOut);
    Lpspi_Ip_CheckValidParameters(ExternalDevice, Length);
    #endif
    Instance = ExternalDevice->Instance;
    8acc:	9b05      	ldr	r3, [sp, #20]
    8ace:	781b      	ldrb	r3, [r3, #0]
    8ad0:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
    State = Lpspi_Ip_apxStateStructureArray[Instance];
    8ad4:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
    8ad8:	4a92      	ldr	r2, [pc, #584]	; (8d24 <Lpspi_Ip_SyncTransmit+0x28c>)
    8ada:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8ade:	9312      	str	r3, [sp, #72]	; 0x48
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(State != NULL_PTR);
    #endif
    
    Base = Lpspi_Ip_apxBases[Instance];    
    8ae0:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
    8ae4:	4a90      	ldr	r2, [pc, #576]	; (8d28 <Lpspi_Ip_SyncTransmit+0x290>)
    8ae6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8aea:	9311      	str	r3, [sp, #68]	; 0x44
    SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08();
    8aec:	f00d fc88 	bl	16400 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08>
    if (LPSPI_IP_BUSY == State->Status)
    8af0:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8af2:	685b      	ldr	r3, [r3, #4]
    8af4:	2b02      	cmp	r3, #2
    8af6:	d104      	bne.n	8b02 <Lpspi_Ip_SyncTransmit+0x6a>
    {
        SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08();
    8af8:	f00d fcae 	bl	16458 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08>
        Status = LPSPI_IP_STATUS_FAIL;
    8afc:	2301      	movs	r3, #1
    8afe:	9318      	str	r3, [sp, #96]	; 0x60
    8b00:	e276      	b.n	8ff0 <Lpspi_Ip_SyncTransmit+0x558>
        /* Clear some bits which support for half duplex mode at previous transfer */
        Base->CFGR1 &= ~(LPSPI_CFGR1_PCSCFG_MASK | LPSPI_CFGR1_OUTCFG_MASK | LPSPI_CFGR1_PINCFG_MASK);
        #endif
        
        /* Mark the hardware as busy. */
        State->Status = LPSPI_IP_BUSY;
    8b02:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8b04:	2202      	movs	r2, #2
    8b06:	605a      	str	r2, [r3, #4]
        State->ExternalDevice = ExternalDevice;
    8b08:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8b0a:	9a05      	ldr	r2, [sp, #20]
    8b0c:	625a      	str	r2, [r3, #36]	; 0x24
        SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08();
    8b0e:	f00d fca3 	bl	16458 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08>
        
        /* Disable DMA requests and all interrupts */
        Base->DER = 0u;
    8b12:	9b11      	ldr	r3, [sp, #68]	; 0x44
    8b14:	2200      	movs	r2, #0
    8b16:	61da      	str	r2, [r3, #28]
        Base->IER = 0u;
    8b18:	9b11      	ldr	r3, [sp, #68]	; 0x44
    8b1a:	2200      	movs	r2, #0
    8b1c:	619a      	str	r2, [r3, #24]
        
        /* Update State structure. */
        State->NextTransferConfigAvailable = State->KeepCs;
    8b1e:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8b20:	7f1a      	ldrb	r2, [r3, #28]
    8b22:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8b24:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
        
        /* Set clock configuration */
        if(TRUE == State->FirstCmd)
    8b28:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8b2a:	7f5b      	ldrb	r3, [r3, #29]
    8b2c:	2b00      	cmp	r3, #0
    8b2e:	d030      	beq.n	8b92 <Lpspi_Ip_SyncTransmit+0xfa>
            /* Makes sure that FIFOs will be empty before start new transfer session. 
            There is maybe a frame in RX shifter register (previous transfer is broken and CS did not de-assert).
            So use reset FIFO do not prevent the potential issue. So reset module by software reset bit should be used here */
            /* Reset FIFOs using CR[RST] bit */
            /* store CFGR1 and restore after all registers are reset */
            Cfgr1 = Base->CFGR1;
    8b30:	9b11      	ldr	r3, [sp, #68]	; 0x44
    8b32:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    8b34:	9313      	str	r3, [sp, #76]	; 0x4c
            Base->CR |= LPSPI_CR_RST_MASK;
    8b36:	9b11      	ldr	r3, [sp, #68]	; 0x44
    8b38:	691b      	ldr	r3, [r3, #16]
    8b3a:	f043 0202 	orr.w	r2, r3, #2
    8b3e:	9b11      	ldr	r3, [sp, #68]	; 0x44
    8b40:	611a      	str	r2, [r3, #16]
            Base->CR &= ~LPSPI_CR_RST_MASK;
    8b42:	9b11      	ldr	r3, [sp, #68]	; 0x44
    8b44:	691b      	ldr	r3, [r3, #16]
    8b46:	f023 0202 	bic.w	r2, r3, #2
    8b4a:	9b11      	ldr	r3, [sp, #68]	; 0x44
    8b4c:	611a      	str	r2, [r3, #16]
            /* restore CFGR1 */
            Base->CFGR1 = Cfgr1;
    8b4e:	9b11      	ldr	r3, [sp, #68]	; 0x44
    8b50:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    8b52:	625a      	str	r2, [r3, #36]	; 0x24
            /* clear all flags */
            Base->SR &= LPSPI_IP_SR_W1C_MASK_U32;
    8b54:	9b11      	ldr	r3, [sp, #68]	; 0x44
    8b56:	695b      	ldr	r3, [r3, #20]
    8b58:	f403 527c 	and.w	r2, r3, #16128	; 0x3f00
    8b5c:	9b11      	ldr	r3, [sp, #68]	; 0x44
    8b5e:	615a      	str	r2, [r3, #20]

            #if (STD_ON == LPSPI_IP_DUAL_CLOCK_MODE)
            Base->CCR = ExternalDevice->Ccr[State->ClockMode];
            #else
            Base->CCR = ExternalDevice->Ccr;
    8b60:	9b05      	ldr	r3, [sp, #20]
    8b62:	685a      	ldr	r2, [r3, #4]
    8b64:	9b11      	ldr	r3, [sp, #68]	; 0x44
    8b66:	641a      	str	r2, [r3, #64]	; 0x40
            #endif
                /* Reset current FIFO slots are available to fill at beginning of job (HLD).*/
            State->CurrentTxFifoSlot = LPSPI_IP_FIFO_SIZE_U8;
    8b68:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8b6a:	2204      	movs	r2, #4
    8b6c:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
            Lpspi_TransmitTxInit(Instance, (const uint8*)TxBuffer, State->ExternalDevice->DeviceParams->FrameSize, State->ExternalDevice->DeviceParams->Lsb, Length);
    8b70:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8b72:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    8b74:	68db      	ldr	r3, [r3, #12]
    8b76:	881a      	ldrh	r2, [r3, #0]
    8b78:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8b7a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    8b7c:	68db      	ldr	r3, [r3, #12]
    8b7e:	7899      	ldrb	r1, [r3, #2]
    8b80:	f89d 0053 	ldrb.w	r0, [sp, #83]	; 0x53
    8b84:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    8b88:	9300      	str	r3, [sp, #0]
    8b8a:	460b      	mov	r3, r1
    8b8c:	9904      	ldr	r1, [sp, #16]
    8b8e:	f000 fa37 	bl	9000 <Lpspi_TransmitTxInit>
        }
        Lpspi_TransmitRxInit(Instance, RxBuffer, State->ExternalDevice->DeviceParams->FrameSize, Length);
    8b92:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8b94:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    8b96:	68db      	ldr	r3, [r3, #12]
    8b98:	881a      	ldrh	r2, [r3, #0]
    8b9a:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    8b9e:	f89d 0053 	ldrb.w	r0, [sp, #83]	; 0x53
    8ba2:	9903      	ldr	r1, [sp, #12]
    8ba4:	f000 facc 	bl	9140 <Lpspi_TransmitRxInit>
        /* initialize current counter */
        CurrentTicks = OsIf_GetCounter(LPSPI_IP_TIMEOUT_METHOD);
    8ba8:	2000      	movs	r0, #0
    8baa:	f7f9 f9bf 	bl	1f2c <OsIf_GetCounter>
    8bae:	4603      	mov	r3, r0
    8bb0:	9307      	str	r3, [sp, #28]
        while(State->RxIndex != State->ExpectedFifoReads)
    8bb2:	e202      	b.n	8fba <Lpspi_Ip_SyncTransmit+0x522>
        {
            /* RECEIVE DATA */
            /* The receiving should be performed first because maybe have a last frame in RX FIFO from previous channel
                , it should be read to clear RXFIFO before start a new write to TXFIFO */
            /* Read all Data available in receive HW fifo. */
            NumberOfReads = (uint8)(((Base->FSR) & LPSPI_FSR_RXCOUNT_MASK) >> LPSPI_FSR_RXCOUNT_SHIFT);
    8bb4:	9b11      	ldr	r3, [sp, #68]	; 0x44
    8bb6:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    8bb8:	0c1b      	lsrs	r3, r3, #16
    8bba:	b2db      	uxtb	r3, r3
    8bbc:	f003 0307 	and.w	r3, r3, #7
    8bc0:	f88d 3066 	strb.w	r3, [sp, #102]	; 0x66
            /* Limits to remaining frames. */
            
            if (NumberOfReads != 0u)
    8bc4:	f89d 3066 	ldrb.w	r3, [sp, #102]	; 0x66
    8bc8:	2b00      	cmp	r3, #0
    8bca:	f000 80d2 	beq.w	8d72 <Lpspi_Ip_SyncTransmit+0x2da>
            {
                if (NumberOfReads > (State->ExpectedFifoReads - State->RxIndex))
    8bce:	f89d 2066 	ldrb.w	r2, [sp, #102]	; 0x66
    8bd2:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8bd4:	8b1b      	ldrh	r3, [r3, #24]
    8bd6:	4619      	mov	r1, r3
    8bd8:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8bda:	8a9b      	ldrh	r3, [r3, #20]
    8bdc:	1acb      	subs	r3, r1, r3
    8bde:	429a      	cmp	r2, r3
    8be0:	dd08      	ble.n	8bf4 <Lpspi_Ip_SyncTransmit+0x15c>
                {
                    NumberOfReads = (uint8)(State->ExpectedFifoReads - State->RxIndex);
    8be2:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8be4:	8b1b      	ldrh	r3, [r3, #24]
    8be6:	b2da      	uxtb	r2, r3
    8be8:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8bea:	8a9b      	ldrh	r3, [r3, #20]
    8bec:	b2db      	uxtb	r3, r3
    8bee:	1ad3      	subs	r3, r2, r3
    8bf0:	f88d 3066 	strb.w	r3, [sp, #102]	; 0x66
                }
                /* If these are the first frames of this channel. Current TXFIFO slot must be plus 1 because the slot of CMD have moved out */
                if (0u == State->RxIndex)
    8bf4:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8bf6:	8a9b      	ldrh	r3, [r3, #20]
    8bf8:	2b00      	cmp	r3, #0
    8bfa:	d107      	bne.n	8c0c <Lpspi_Ip_SyncTransmit+0x174>
                {
                    State->CurrentTxFifoSlot += 1u;
    8bfc:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8bfe:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    8c02:	3301      	adds	r3, #1
    8c04:	b2da      	uxtb	r2, r3
    8c06:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8c08:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
    8c0c:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
    8c10:	f88d 3043 	strb.w	r3, [sp, #67]	; 0x43
    8c14:	f89d 3066 	ldrb.w	r3, [sp, #102]	; 0x66
    8c18:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
    const LPSPI_Type* Base = Lpspi_Ip_apxBases[Instance];
    8c1c:	f89d 3043 	ldrb.w	r3, [sp, #67]	; 0x43
    8c20:	4a41      	ldr	r2, [pc, #260]	; (8d28 <Lpspi_Ip_SyncTransmit+0x290>)
    8c22:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8c26:	930f      	str	r3, [sp, #60]	; 0x3c
    Lpspi_Ip_StateStructureType* State = Lpspi_Ip_apxStateStructureArray[Instance];
    8c28:	f89d 3043 	ldrb.w	r3, [sp, #67]	; 0x43
    8c2c:	4a3d      	ldr	r2, [pc, #244]	; (8d24 <Lpspi_Ip_SyncTransmit+0x28c>)
    8c2e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8c32:	930e      	str	r3, [sp, #56]	; 0x38
    uint32 Data = 0u;
    8c34:	2300      	movs	r3, #0
    8c36:	930d      	str	r3, [sp, #52]	; 0x34
    uint8 Index = 0u;
    8c38:	2300      	movs	r3, #0
    8c3a:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    if (NULL_PTR != State->RxBuffer)
    8c3e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    8c40:	689b      	ldr	r3, [r3, #8]
    8c42:	2b00      	cmp	r3, #0
    8c44:	d069      	beq.n	8d1a <Lpspi_Ip_SyncTransmit+0x282>
        if (State->ExternalDevice->DeviceParams->FrameSize < 9u)
    8c46:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    8c48:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    8c4a:	68db      	ldr	r3, [r3, #12]
    8c4c:	881b      	ldrh	r3, [r3, #0]
    8c4e:	2b08      	cmp	r3, #8
    8c50:	d81e      	bhi.n	8c90 <Lpspi_Ip_SyncTransmit+0x1f8>
            for (Index = 0; Index < NumberOfReads; Index++)
    8c52:	2300      	movs	r3, #0
    8c54:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    8c58:	e013      	b.n	8c82 <Lpspi_Ip_SyncTransmit+0x1ea>
                Data = Base->RDR;
    8c5a:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    8c5c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    8c5e:	930d      	str	r3, [sp, #52]	; 0x34
                *((uint8*)(&State->RxBuffer[State->RxIndex + Index])) = (uint8)Data;
    8c60:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    8c62:	689b      	ldr	r3, [r3, #8]
    8c64:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    8c66:	8a92      	ldrh	r2, [r2, #20]
    8c68:	4611      	mov	r1, r2
    8c6a:	f89d 2033 	ldrb.w	r2, [sp, #51]	; 0x33
    8c6e:	440a      	add	r2, r1
    8c70:	4413      	add	r3, r2
    8c72:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    8c74:	b2d2      	uxtb	r2, r2
    8c76:	701a      	strb	r2, [r3, #0]
            for (Index = 0; Index < NumberOfReads; Index++)
    8c78:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    8c7c:	3301      	adds	r3, #1
    8c7e:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    8c82:	f89d 2042 	ldrb.w	r2, [sp, #66]	; 0x42
    8c86:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    8c8a:	429a      	cmp	r2, r3
    8c8c:	d8e5      	bhi.n	8c5a <Lpspi_Ip_SyncTransmit+0x1c2>
    8c8e:	e05a      	b.n	8d46 <Lpspi_Ip_SyncTransmit+0x2ae>
        else if (State->ExternalDevice->DeviceParams->FrameSize < 17u)
    8c90:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    8c92:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    8c94:	68db      	ldr	r3, [r3, #12]
    8c96:	881b      	ldrh	r3, [r3, #0]
    8c98:	2b10      	cmp	r3, #16
    8c9a:	d81f      	bhi.n	8cdc <Lpspi_Ip_SyncTransmit+0x244>
            for (Index = 0; Index < NumberOfReads; Index++)
    8c9c:	2300      	movs	r3, #0
    8c9e:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    8ca2:	e014      	b.n	8cce <Lpspi_Ip_SyncTransmit+0x236>
                Data = Base->RDR;
    8ca4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    8ca6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    8ca8:	930d      	str	r3, [sp, #52]	; 0x34
                *((uint16*)(&State->RxBuffer[2u * (State->RxIndex + Index)])) = (uint16)Data;
    8caa:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    8cac:	689a      	ldr	r2, [r3, #8]
    8cae:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    8cb0:	8a9b      	ldrh	r3, [r3, #20]
    8cb2:	4619      	mov	r1, r3
    8cb4:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    8cb8:	440b      	add	r3, r1
    8cba:	005b      	lsls	r3, r3, #1
    8cbc:	4413      	add	r3, r2
    8cbe:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    8cc0:	b292      	uxth	r2, r2
    8cc2:	801a      	strh	r2, [r3, #0]
            for (Index = 0; Index < NumberOfReads; Index++)
    8cc4:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    8cc8:	3301      	adds	r3, #1
    8cca:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    8cce:	f89d 2042 	ldrb.w	r2, [sp, #66]	; 0x42
    8cd2:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    8cd6:	429a      	cmp	r2, r3
    8cd8:	d8e4      	bhi.n	8ca4 <Lpspi_Ip_SyncTransmit+0x20c>
    8cda:	e034      	b.n	8d46 <Lpspi_Ip_SyncTransmit+0x2ae>
            for (Index = 0; Index < NumberOfReads; Index++)
    8cdc:	2300      	movs	r3, #0
    8cde:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    8ce2:	e013      	b.n	8d0c <Lpspi_Ip_SyncTransmit+0x274>
                Data = Base->RDR;
    8ce4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    8ce6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
    8ce8:	930d      	str	r3, [sp, #52]	; 0x34
                *((uint32*)(&State->RxBuffer[4u * (State->RxIndex + Index)])) = (uint32)Data;
    8cea:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    8cec:	689a      	ldr	r2, [r3, #8]
    8cee:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    8cf0:	8a9b      	ldrh	r3, [r3, #20]
    8cf2:	4619      	mov	r1, r3
    8cf4:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    8cf8:	440b      	add	r3, r1
    8cfa:	009b      	lsls	r3, r3, #2
    8cfc:	4413      	add	r3, r2
    8cfe:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    8d00:	601a      	str	r2, [r3, #0]
            for (Index = 0; Index < NumberOfReads; Index++)
    8d02:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    8d06:	3301      	adds	r3, #1
    8d08:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    8d0c:	f89d 2042 	ldrb.w	r2, [sp, #66]	; 0x42
    8d10:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    8d14:	429a      	cmp	r2, r3
    8d16:	d8e5      	bhi.n	8ce4 <Lpspi_Ip_SyncTransmit+0x24c>
    8d18:	e015      	b.n	8d46 <Lpspi_Ip_SyncTransmit+0x2ae>
        for (Index = 0; Index < NumberOfReads; Index++)
    8d1a:	2300      	movs	r3, #0
    8d1c:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    8d20:	e00b      	b.n	8d3a <Lpspi_Ip_SyncTransmit+0x2a2>
    8d22:	bf00      	nop
    8d24:	1fff8ddc 	.word	0x1fff8ddc
    8d28:	000186c4 	.word	0x000186c4
            (void)Base->RDR;
    8d2c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    8d2e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
        for (Index = 0; Index < NumberOfReads; Index++)
    8d30:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    8d34:	3301      	adds	r3, #1
    8d36:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
    8d3a:	f89d 2042 	ldrb.w	r2, [sp, #66]	; 0x42
    8d3e:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
    8d42:	429a      	cmp	r2, r3
    8d44:	d8f2      	bhi.n	8d2c <Lpspi_Ip_SyncTransmit+0x294>
    State->RxIndex += NumberOfReads;
    8d46:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    8d48:	8a9a      	ldrh	r2, [r3, #20]
    8d4a:	f89d 3042 	ldrb.w	r3, [sp, #66]	; 0x42
    8d4e:	b29b      	uxth	r3, r3
    8d50:	4413      	add	r3, r2
    8d52:	b29a      	uxth	r2, r3
    8d54:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    8d56:	829a      	strh	r2, [r3, #20]
}
    8d58:	bf00      	nop
                }
                /* Read Data from RX FIFO */
                Lpspi_Ip_ReadDataFromFifo(Instance, NumberOfReads);
                /* Update current FIFO slots are available to fill .*/
                State->CurrentTxFifoSlot += NumberOfReads;
    8d5a:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8d5c:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
    8d60:	f89d 3066 	ldrb.w	r3, [sp, #102]	; 0x66
    8d64:	4413      	add	r3, r2
    8d66:	b2da      	uxtb	r2, r3
    8d68:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8d6a:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
                ElapsedTicks = 0u;
    8d6e:	2300      	movs	r3, #0
    8d70:	9317      	str	r3, [sp, #92]	; 0x5c
            /* After driver code read all frames in RX FIFO, if there are still some frames in TX FIFO, at the time before driver code check number of frames available in TX FIFO 
            to prepare to fill TX FIFO. At that time, interrupt occurred, and the time to process interrupt is longer than the time to transfer all frames in TX FIFO. 
            So TX FIFO will be empty and some frames received in RX FIFO, then the program is returned from interrupt and fill TX FIFO until full. 
            And there is a interrupt occurred after that before read all frames in RX FIFO, and the time to process interrupt is longer than the time to transfer all frames in TX FIFO.
            State->CurrentTxFifoSlot variable is used to hanlde number of frames are "on bus transfer". They are always less than FIFO size */
            if((State->CurrentTxFifoSlot != 0u) && (TxDoneFlag != TRUE))
    8d72:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8d74:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    8d78:	2b00      	cmp	r3, #0
    8d7a:	f000 810e 	beq.w	8f9a <Lpspi_Ip_SyncTransmit+0x502>
    8d7e:	f89d 305b 	ldrb.w	r3, [sp, #91]	; 0x5b
    8d82:	f083 0301 	eor.w	r3, r3, #1
    8d86:	b2db      	uxtb	r3, r3
    8d88:	2b00      	cmp	r3, #0
    8d8a:	f000 8106 	beq.w	8f9a <Lpspi_Ip_SyncTransmit+0x502>
            {
                if(State->ExpectedFifoWrites != State->TxIndex)
    8d8e:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8d90:	8b5a      	ldrh	r2, [r3, #26]
    8d92:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8d94:	8adb      	ldrh	r3, [r3, #22]
    8d96:	429a      	cmp	r2, r3
    8d98:	f000 80c7 	beq.w	8f2a <Lpspi_Ip_SyncTransmit+0x492>
                {
                    NumberOfWrites = State->CurrentTxFifoSlot;
    8d9c:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8d9e:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    8da2:	f88d 3067 	strb.w	r3, [sp, #103]	; 0x67
                    /* Limits to remaining frames. */
                    if (NumberOfWrites > (State->ExpectedFifoWrites - State->TxIndex))
    8da6:	f89d 2067 	ldrb.w	r2, [sp, #103]	; 0x67
    8daa:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8dac:	8b5b      	ldrh	r3, [r3, #26]
    8dae:	4619      	mov	r1, r3
    8db0:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8db2:	8adb      	ldrh	r3, [r3, #22]
    8db4:	1acb      	subs	r3, r1, r3
    8db6:	429a      	cmp	r2, r3
    8db8:	dd08      	ble.n	8dcc <Lpspi_Ip_SyncTransmit+0x334>
                    {
                        NumberOfWrites = (uint8)(State->ExpectedFifoWrites - State->TxIndex);
    8dba:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8dbc:	8b5b      	ldrh	r3, [r3, #26]
    8dbe:	b2da      	uxtb	r2, r3
    8dc0:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8dc2:	8adb      	ldrh	r3, [r3, #22]
    8dc4:	b2db      	uxtb	r3, r3
    8dc6:	1ad3      	subs	r3, r2, r3
    8dc8:	f88d 3067 	strb.w	r3, [sp, #103]	; 0x67
    8dcc:	f89d 3053 	ldrb.w	r3, [sp, #83]	; 0x53
    8dd0:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
    8dd4:	f89d 3067 	ldrb.w	r3, [sp, #103]	; 0x67
    8dd8:	f88d 3031 	strb.w	r3, [sp, #49]	; 0x31
    LPSPI_Type* Base = Lpspi_Ip_apxBases[Instance];
    8ddc:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
    8de0:	4a85      	ldr	r2, [pc, #532]	; (8ff8 <Lpspi_Ip_SyncTransmit+0x560>)
    8de2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8de6:	930b      	str	r3, [sp, #44]	; 0x2c
    Lpspi_Ip_StateStructureType* State = Lpspi_Ip_apxStateStructureArray[Instance];
    8de8:	f89d 3032 	ldrb.w	r3, [sp, #50]	; 0x32
    8dec:	4a83      	ldr	r2, [pc, #524]	; (8ffc <Lpspi_Ip_SyncTransmit+0x564>)
    8dee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8df2:	930a      	str	r3, [sp, #40]	; 0x28
    uint32 Data = 0u;
    8df4:	2300      	movs	r3, #0
    8df6:	9309      	str	r3, [sp, #36]	; 0x24
    uint8 Index = 0u;
    8df8:	2300      	movs	r3, #0
    8dfa:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    Data = State->ExternalDevice->DeviceParams->DefaultData;
    8dfe:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    8e00:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    8e02:	68db      	ldr	r3, [r3, #12]
    8e04:	685b      	ldr	r3, [r3, #4]
    8e06:	9309      	str	r3, [sp, #36]	; 0x24
    if (NULL_PTR != State->TxBuffer)
    8e08:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    8e0a:	68db      	ldr	r3, [r3, #12]
    8e0c:	2b00      	cmp	r3, #0
    8e0e:	d063      	beq.n	8ed8 <Lpspi_Ip_SyncTransmit+0x440>
        if (State->TxFrameSize < 9u)
    8e10:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    8e12:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    8e14:	2b08      	cmp	r3, #8
    8e16:	d81d      	bhi.n	8e54 <Lpspi_Ip_SyncTransmit+0x3bc>
            for (Index = 0; Index < NumberOfWrites; Index++)
    8e18:	2300      	movs	r3, #0
    8e1a:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    8e1e:	e012      	b.n	8e46 <Lpspi_Ip_SyncTransmit+0x3ae>
                Data = *((const uint8*)(&State->TxBuffer[State->TxIndex + Index]));
    8e20:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    8e22:	68db      	ldr	r3, [r3, #12]
    8e24:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    8e26:	8ad2      	ldrh	r2, [r2, #22]
    8e28:	4611      	mov	r1, r2
    8e2a:	f89d 2023 	ldrb.w	r2, [sp, #35]	; 0x23
    8e2e:	440a      	add	r2, r1
    8e30:	4413      	add	r3, r2
    8e32:	781b      	ldrb	r3, [r3, #0]
    8e34:	9309      	str	r3, [sp, #36]	; 0x24
                Base->TDR = Data;
    8e36:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    8e38:	9a09      	ldr	r2, [sp, #36]	; 0x24
    8e3a:	665a      	str	r2, [r3, #100]	; 0x64
            for (Index = 0; Index < NumberOfWrites; Index++)
    8e3c:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    8e40:	3301      	adds	r3, #1
    8e42:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    8e46:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    8e4a:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    8e4e:	429a      	cmp	r2, r3
    8e50:	d8e6      	bhi.n	8e20 <Lpspi_Ip_SyncTransmit+0x388>
    8e52:	e053      	b.n	8efc <Lpspi_Ip_SyncTransmit+0x464>
        else if (State->TxFrameSize < 17u)
    8e54:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    8e56:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    8e58:	2b10      	cmp	r3, #16
    8e5a:	d81e      	bhi.n	8e9a <Lpspi_Ip_SyncTransmit+0x402>
            for (Index = 0; Index < NumberOfWrites; Index++)
    8e5c:	2300      	movs	r3, #0
    8e5e:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    8e62:	e013      	b.n	8e8c <Lpspi_Ip_SyncTransmit+0x3f4>
                Data = *((const uint16*)(&State->TxBuffer[2u * (State->TxIndex + Index)]));
    8e64:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    8e66:	68da      	ldr	r2, [r3, #12]
    8e68:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    8e6a:	8adb      	ldrh	r3, [r3, #22]
    8e6c:	4619      	mov	r1, r3
    8e6e:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    8e72:	440b      	add	r3, r1
    8e74:	005b      	lsls	r3, r3, #1
    8e76:	4413      	add	r3, r2
    8e78:	881b      	ldrh	r3, [r3, #0]
    8e7a:	9309      	str	r3, [sp, #36]	; 0x24
                Base->TDR = Data;
    8e7c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    8e7e:	9a09      	ldr	r2, [sp, #36]	; 0x24
    8e80:	665a      	str	r2, [r3, #100]	; 0x64
            for (Index = 0; Index < NumberOfWrites; Index++)
    8e82:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    8e86:	3301      	adds	r3, #1
    8e88:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    8e8c:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    8e90:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    8e94:	429a      	cmp	r2, r3
    8e96:	d8e5      	bhi.n	8e64 <Lpspi_Ip_SyncTransmit+0x3cc>
    8e98:	e030      	b.n	8efc <Lpspi_Ip_SyncTransmit+0x464>
            for (Index = 0; Index < NumberOfWrites; Index++)
    8e9a:	2300      	movs	r3, #0
    8e9c:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    8ea0:	e013      	b.n	8eca <Lpspi_Ip_SyncTransmit+0x432>
                Data = *((const uint32*)(&State->TxBuffer[4u * (State->TxIndex + Index)]));
    8ea2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    8ea4:	68da      	ldr	r2, [r3, #12]
    8ea6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    8ea8:	8adb      	ldrh	r3, [r3, #22]
    8eaa:	4619      	mov	r1, r3
    8eac:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    8eb0:	440b      	add	r3, r1
    8eb2:	009b      	lsls	r3, r3, #2
    8eb4:	4413      	add	r3, r2
    8eb6:	681b      	ldr	r3, [r3, #0]
    8eb8:	9309      	str	r3, [sp, #36]	; 0x24
                Base->TDR = Data;
    8eba:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    8ebc:	9a09      	ldr	r2, [sp, #36]	; 0x24
    8ebe:	665a      	str	r2, [r3, #100]	; 0x64
            for (Index = 0; Index < NumberOfWrites; Index++)
    8ec0:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    8ec4:	3301      	adds	r3, #1
    8ec6:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    8eca:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    8ece:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    8ed2:	429a      	cmp	r2, r3
    8ed4:	d8e5      	bhi.n	8ea2 <Lpspi_Ip_SyncTransmit+0x40a>
    8ed6:	e011      	b.n	8efc <Lpspi_Ip_SyncTransmit+0x464>
        for (Index = 0; Index < NumberOfWrites; Index++)
    8ed8:	2300      	movs	r3, #0
    8eda:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    8ede:	e007      	b.n	8ef0 <Lpspi_Ip_SyncTransmit+0x458>
            Base->TDR = Data;
    8ee0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    8ee2:	9a09      	ldr	r2, [sp, #36]	; 0x24
    8ee4:	665a      	str	r2, [r3, #100]	; 0x64
        for (Index = 0; Index < NumberOfWrites; Index++)
    8ee6:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    8eea:	3301      	adds	r3, #1
    8eec:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    8ef0:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
    8ef4:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    8ef8:	429a      	cmp	r2, r3
    8efa:	d8f1      	bhi.n	8ee0 <Lpspi_Ip_SyncTransmit+0x448>
    State->TxIndex += NumberOfWrites;
    8efc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    8efe:	8ada      	ldrh	r2, [r3, #22]
    8f00:	f89d 3031 	ldrb.w	r3, [sp, #49]	; 0x31
    8f04:	b29b      	uxth	r3, r3
    8f06:	4413      	add	r3, r2
    8f08:	b29a      	uxth	r2, r3
    8f0a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    8f0c:	82da      	strh	r2, [r3, #22]
}
    8f0e:	bf00      	nop
                    }
                    /* Push Data into TX FIFO */
                    Lpspi_Ip_PushDataToFifo(Instance, NumberOfWrites);
                    State->CurrentTxFifoSlot -= NumberOfWrites;
    8f10:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8f12:	f893 203c 	ldrb.w	r2, [r3, #60]	; 0x3c
    8f16:	f89d 3067 	ldrb.w	r3, [sp, #103]	; 0x67
    8f1a:	1ad3      	subs	r3, r2, r3
    8f1c:	b2da      	uxtb	r2, r3
    8f1e:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8f20:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
                    ElapsedTicks = 0u;
    8f24:	2300      	movs	r3, #0
    8f26:	9317      	str	r3, [sp, #92]	; 0x5c
    8f28:	e037      	b.n	8f9a <Lpspi_Ip_SyncTransmit+0x502>
                }
                else
                {
                    if(TRUE == State->NextTransferConfigAvailable)
    8f2a:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8f2c:	f893 303a 	ldrb.w	r3, [r3, #58]	; 0x3a
    8f30:	2b00      	cmp	r3, #0
    8f32:	d01c      	beq.n	8f6e <Lpspi_Ip_SyncTransmit+0x4d6>
                    {
                        /* Initialize next transfer */
                        State->ExternalDevice->DeviceParams->DefaultData = State->DefaultDataNext;
    8f34:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8f36:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    8f38:	68db      	ldr	r3, [r3, #12]
    8f3a:	9a12      	ldr	r2, [sp, #72]	; 0x48
    8f3c:	6b52      	ldr	r2, [r2, #52]	; 0x34
    8f3e:	605a      	str	r2, [r3, #4]
                        State->FirstCmd = FALSE;
    8f40:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8f42:	2200      	movs	r2, #0
    8f44:	775a      	strb	r2, [r3, #29]
                        Lpspi_TransmitTxInit(Instance, State->TxBufferNext, State->FrameSizeNext, State->LsbNext, State->LengthNext);
    8f46:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8f48:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
    8f4a:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8f4c:	8e1a      	ldrh	r2, [r3, #48]	; 0x30
    8f4e:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8f50:	f893 4032 	ldrb.w	r4, [r3, #50]	; 0x32
    8f54:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8f56:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
    8f58:	f89d 0053 	ldrb.w	r0, [sp, #83]	; 0x53
    8f5c:	9300      	str	r3, [sp, #0]
    8f5e:	4623      	mov	r3, r4
    8f60:	f000 f84e 	bl	9000 <Lpspi_TransmitTxInit>
                        State->NextTransferConfigAvailable = FALSE;
    8f64:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8f66:	2200      	movs	r2, #0
    8f68:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
    8f6c:	e015      	b.n	8f9a <Lpspi_Ip_SyncTransmit+0x502>
                    }
                    else
                    {
                        TxDoneFlag = TRUE;
    8f6e:	2301      	movs	r3, #1
    8f70:	f88d 305b 	strb.w	r3, [sp, #91]	; 0x5b
                        if((FALSE == State->KeepCs) && (0u != (Base->TCR & LPSPI_TCR_CONT_MASK)))
    8f74:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8f76:	7f1b      	ldrb	r3, [r3, #28]
    8f78:	f083 0301 	eor.w	r3, r3, #1
    8f7c:	b2db      	uxtb	r3, r3
    8f7e:	2b00      	cmp	r3, #0
    8f80:	d00b      	beq.n	8f9a <Lpspi_Ip_SyncTransmit+0x502>
    8f82:	9b11      	ldr	r3, [sp, #68]	; 0x44
    8f84:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    8f86:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
    8f8a:	2b00      	cmp	r3, #0
    8f8c:	d005      	beq.n	8f9a <Lpspi_Ip_SyncTransmit+0x502>
                        {
                            /* Clear CS */
                            Base->TCR &= ~(LPSPI_TCR_CONT_MASK | LPSPI_TCR_CONTC_MASK);
    8f8e:	9b11      	ldr	r3, [sp, #68]	; 0x44
    8f90:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    8f92:	f423 1240 	bic.w	r2, r3, #3145728	; 0x300000
    8f96:	9b11      	ldr	r3, [sp, #68]	; 0x44
    8f98:	661a      	str	r2, [r3, #96]	; 0x60
                        }
                    }
                }
            }
            ElapsedTicks += OsIf_GetElapsed(&CurrentTicks, LPSPI_IP_TIMEOUT_METHOD);
    8f9a:	ab07      	add	r3, sp, #28
    8f9c:	2100      	movs	r1, #0
    8f9e:	4618      	mov	r0, r3
    8fa0:	f7f8 ffdd 	bl	1f5e <OsIf_GetElapsed>
    8fa4:	4602      	mov	r2, r0
    8fa6:	9b17      	ldr	r3, [sp, #92]	; 0x5c
    8fa8:	4413      	add	r3, r2
    8faa:	9317      	str	r3, [sp, #92]	; 0x5c
            if (ElapsedTicks >= TimeoutTicks)
    8fac:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    8fae:	9b15      	ldr	r3, [sp, #84]	; 0x54
    8fb0:	429a      	cmp	r2, r3
    8fb2:	d302      	bcc.n	8fba <Lpspi_Ip_SyncTransmit+0x522>
            {
                Status = LPSPI_IP_TIMEOUT;
    8fb4:	2303      	movs	r3, #3
    8fb6:	9318      	str	r3, [sp, #96]	; 0x60
                break;
    8fb8:	e006      	b.n	8fc8 <Lpspi_Ip_SyncTransmit+0x530>
        while(State->RxIndex != State->ExpectedFifoReads)
    8fba:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8fbc:	8a9a      	ldrh	r2, [r3, #20]
    8fbe:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8fc0:	8b1b      	ldrh	r3, [r3, #24]
    8fc2:	429a      	cmp	r2, r3
    8fc4:	f47f adf6 	bne.w	8bb4 <Lpspi_Ip_SyncTransmit+0x11c>
            }
        }
        if ((LPSPI_IP_STATUS_SUCCESS != Status) || (0u == Length))
    8fc8:	9b18      	ldr	r3, [sp, #96]	; 0x60
    8fca:	2b00      	cmp	r3, #0
    8fcc:	d103      	bne.n	8fd6 <Lpspi_Ip_SyncTransmit+0x53e>
    8fce:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    8fd2:	2b00      	cmp	r3, #0
    8fd4:	d109      	bne.n	8fea <Lpspi_Ip_SyncTransmit+0x552>
        {
#if (STD_OFF == LPSPI_IP_DEV_ERROR_DETECT)
            /* Return Fail status if length is 0. Error Detect is enabled, nothing need to be done here */
            if (0u == Length)
    8fd6:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    8fda:	2b00      	cmp	r3, #0
    8fdc:	d101      	bne.n	8fe2 <Lpspi_Ip_SyncTransmit+0x54a>
            {
                Status = LPSPI_IP_STATUS_FAIL;
    8fde:	2301      	movs	r3, #1
    8fe0:	9318      	str	r3, [sp, #96]	; 0x60
            }
#endif
            State->Status = LPSPI_IP_FAULT;
    8fe2:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8fe4:	2203      	movs	r2, #3
    8fe6:	605a      	str	r2, [r3, #4]
    8fe8:	e002      	b.n	8ff0 <Lpspi_Ip_SyncTransmit+0x558>
        }
        else
        {
            State->Status = LPSPI_IP_IDLE;
    8fea:	9b12      	ldr	r3, [sp, #72]	; 0x48
    8fec:	2201      	movs	r2, #1
    8fee:	605a      	str	r2, [r3, #4]
        }
    }
    return Status;
    8ff0:	9b18      	ldr	r3, [sp, #96]	; 0x60
}
    8ff2:	4618      	mov	r0, r3
    8ff4:	b01a      	add	sp, #104	; 0x68
    8ff6:	bd10      	pop	{r4, pc}
    8ff8:	000186c4 	.word	0x000186c4
    8ffc:	1fff8ddc 	.word	0x1fff8ddc

00009000 <Lpspi_TransmitTxInit>:
                                 const uint8* TxBuffer,
                                 uint16 TxFrameSize,
                                 boolean TxLsb,
                                 uint16 BufLen
                                )
{
    9000:	b088      	sub	sp, #32
    9002:	9100      	str	r1, [sp, #0]
    9004:	4611      	mov	r1, r2
    9006:	461a      	mov	r2, r3
    9008:	4603      	mov	r3, r0
    900a:	f88d 3007 	strb.w	r3, [sp, #7]
    900e:	460b      	mov	r3, r1
    9010:	f8ad 3004 	strh.w	r3, [sp, #4]
    9014:	4613      	mov	r3, r2
    9016:	f88d 3006 	strb.w	r3, [sp, #6]
    LPSPI_Type* Base = Lpspi_Ip_apxBases[Instance];
    901a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    901e:	4a46      	ldr	r2, [pc, #280]	; (9138 <Lpspi_TransmitTxInit+0x138>)
    9020:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9024:	9307      	str	r3, [sp, #28]
    Lpspi_Ip_StateStructureType* State = Lpspi_Ip_apxStateStructureArray[Instance];
    9026:	f89d 3007 	ldrb.w	r3, [sp, #7]
    902a:	4a44      	ldr	r2, [pc, #272]	; (913c <Lpspi_TransmitTxInit+0x13c>)
    902c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9030:	9306      	str	r3, [sp, #24]
    uint32 TransferCommand = 0u;
    9032:	2300      	movs	r3, #0
    9034:	9305      	str	r3, [sp, #20]
    uint8 LsbWriteValue = TxLsb ? 1U : 0U;
    9036:	f89d 3006 	ldrb.w	r3, [sp, #6]
    903a:	2b00      	cmp	r3, #0
    903c:	d001      	beq.n	9042 <Lpspi_TransmitTxInit+0x42>
    903e:	2301      	movs	r3, #1
    9040:	e000      	b.n	9044 <Lpspi_TransmitTxInit+0x44>
    9042:	2300      	movs	r3, #0
    9044:	f88d 3013 	strb.w	r3, [sp, #19]

    State->TxFrameSize = TxFrameSize;
    9048:	9b06      	ldr	r3, [sp, #24]
    904a:	f8bd 2004 	ldrh.w	r2, [sp, #4]
    904e:	851a      	strh	r2, [r3, #40]	; 0x28
    State->TxLsb = TxLsb;
    9050:	9b06      	ldr	r3, [sp, #24]
    9052:	f89d 2006 	ldrb.w	r2, [sp, #6]
    9056:	f883 202a 	strb.w	r2, [r3, #42]	; 0x2a
    /* Get transfer command */
#if (STD_ON == LPSPI_IP_DUAL_CLOCK_MODE)
    TransferCommand = State->ExternalDevice->Tcr[State->ClockMode] | LPSPI_TCR_FRAMESZ((uint32)TxFrameSize - 1u) | LPSPI_TCR_LSBF(LsbWriteValue);
#else
    TransferCommand = State->ExternalDevice->Tcr | LPSPI_TCR_FRAMESZ((uint32)TxFrameSize - 1u) | LPSPI_TCR_LSBF(LsbWriteValue);
    905a:	9b06      	ldr	r3, [sp, #24]
    905c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    905e:	689a      	ldr	r2, [r3, #8]
    9060:	f8bd 3004 	ldrh.w	r3, [sp, #4]
    9064:	3b01      	subs	r3, #1
    9066:	f3c3 030b 	ubfx	r3, r3, #0, #12
    906a:	431a      	orrs	r2, r3
    906c:	f89d 3013 	ldrb.w	r3, [sp, #19]
    9070:	05db      	lsls	r3, r3, #23
    9072:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
    9076:	4313      	orrs	r3, r2
    9078:	9305      	str	r3, [sp, #20]
        {
            TransferCommand &= ~LPSPI_TCR_CONT_MASK;
        }
        #endif
        
        if(TRUE == State->FirstCmd)
    907a:	9b06      	ldr	r3, [sp, #24]
    907c:	7f5b      	ldrb	r3, [r3, #29]
    907e:	2b00      	cmp	r3, #0
    9080:	d003      	beq.n	908a <Lpspi_TransmitTxInit+0x8a>
        {
            /* Set transfer command */
            Base->TCR = TransferCommand;
    9082:	9b07      	ldr	r3, [sp, #28]
    9084:	9a05      	ldr	r2, [sp, #20]
    9086:	661a      	str	r2, [r3, #96]	; 0x60
    9088:	e00d      	b.n	90a6 <Lpspi_TransmitTxInit+0xa6>
        }
        else
        {
            if (0u != (TransferCommand & LPSPI_TCR_CONT_MASK))
    908a:	9b05      	ldr	r3, [sp, #20]
    908c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
    9090:	2b00      	cmp	r3, #0
    9092:	d005      	beq.n	90a0 <Lpspi_TransmitTxInit+0xa0>
            {
                Base->TCR = TransferCommand | LPSPI_TCR_CONTC_MASK;
    9094:	9b05      	ldr	r3, [sp, #20]
    9096:	f443 1280 	orr.w	r2, r3, #1048576	; 0x100000
    909a:	9b07      	ldr	r3, [sp, #28]
    909c:	661a      	str	r2, [r3, #96]	; 0x60
    909e:	e002      	b.n	90a6 <Lpspi_TransmitTxInit+0xa6>
            }
            else
            {
                Base->TCR = TransferCommand;
    90a0:	9b07      	ldr	r3, [sp, #28]
    90a2:	9a05      	ldr	r2, [sp, #20]
    90a4:	661a      	str	r2, [r3, #96]	; 0x60
        #if (STD_ON == LPSPI_IP_HALF_DUPLEX_MODE_SUPPORT)
        if (LPSPI_IP_FULL_DUPLEX == State->ExternalDevice->DeviceParams->TransferType)
        #endif
        {
            /* CMD will take 1 slot in TXFIFO, update current TX FIFO slot. it will be plus 1 when the first frames of channel have recieved */
            State->CurrentTxFifoSlot -= 1u;
    90a6:	9b06      	ldr	r3, [sp, #24]
    90a8:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    90ac:	3b01      	subs	r3, #1
    90ae:	b2da      	uxtb	r2, r3
    90b0:	9b06      	ldr	r3, [sp, #24]
    90b2:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
        }
    }
    
    /* Update State structure. */
    State->TxIndex = 0u;
    90b6:	9b06      	ldr	r3, [sp, #24]
    90b8:	2200      	movs	r2, #0
    90ba:	82da      	strh	r2, [r3, #22]
        (void)TxBuffer;
    }
    else
    #endif
    {
        State->TxBuffer = TxBuffer;
    90bc:	9b06      	ldr	r3, [sp, #24]
    90be:	9a00      	ldr	r2, [sp, #0]
    90c0:	60da      	str	r2, [r3, #12]
    90c2:	f8bd 3020 	ldrh.w	r3, [sp, #32]
    90c6:	f8ad 3010 	strh.w	r3, [sp, #16]
    90ca:	f8bd 3004 	ldrh.w	r3, [sp, #4]
    90ce:	f8ad 300e 	strh.w	r3, [sp, #14]
    if (FrameSize < 9u)
    90d2:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    90d6:	2b08      	cmp	r3, #8
    90d8:	d804      	bhi.n	90e4 <Lpspi_TransmitTxInit+0xe4>
        Ret = Length;
    90da:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    90de:	f8ad 300c 	strh.w	r3, [sp, #12]
    90e2:	e022      	b.n	912a <Lpspi_TransmitTxInit+0x12a>
    else if (FrameSize < 17u)
    90e4:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    90e8:	2b10      	cmp	r3, #16
    90ea:	d80c      	bhi.n	9106 <Lpspi_TransmitTxInit+0x106>
        Ret = (uint16)(Length / 2u) + (uint16)(Length % 2U);
    90ec:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    90f0:	085b      	lsrs	r3, r3, #1
    90f2:	b29a      	uxth	r2, r3
    90f4:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    90f8:	f003 0301 	and.w	r3, r3, #1
    90fc:	b29b      	uxth	r3, r3
    90fe:	4413      	add	r3, r2
    9100:	f8ad 300c 	strh.w	r3, [sp, #12]
    9104:	e011      	b.n	912a <Lpspi_TransmitTxInit+0x12a>
        Ret = (uint16)(Length / 4u) + (uint16)(((Length % 4U) == 0U) ? 0U : 1U);
    9106:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    910a:	089b      	lsrs	r3, r3, #2
    910c:	b29a      	uxth	r2, r3
    910e:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    9112:	f003 0303 	and.w	r3, r3, #3
    9116:	b29b      	uxth	r3, r3
    9118:	2b00      	cmp	r3, #0
    911a:	bf14      	ite	ne
    911c:	2301      	movne	r3, #1
    911e:	2300      	moveq	r3, #0
    9120:	b2db      	uxtb	r3, r3
    9122:	b29b      	uxth	r3, r3
    9124:	4413      	add	r3, r2
    9126:	f8ad 300c 	strh.w	r3, [sp, #12]
    return Ret;
    912a:	f8bd 200c 	ldrh.w	r2, [sp, #12]
    }

    State->ExpectedFifoWrites = Lpspi_Ip_GetWordsFromLength(BufLen, TxFrameSize);
    912e:	9b06      	ldr	r3, [sp, #24]
    9130:	835a      	strh	r2, [r3, #26]
}
    9132:	bf00      	nop
    9134:	b008      	add	sp, #32
    9136:	4770      	bx	lr
    9138:	000186c4 	.word	0x000186c4
    913c:	1fff8ddc 	.word	0x1fff8ddc

00009140 <Lpspi_TransmitRxInit>:
static void Lpspi_TransmitRxInit(uint8 Instance,
                                      uint8* RxBuffer,
                                      uint16 RxFrameSize,
                                      uint16 BufLen
                                     )
{
    9140:	b088      	sub	sp, #32
    9142:	9102      	str	r1, [sp, #8]
    9144:	4611      	mov	r1, r2
    9146:	461a      	mov	r2, r3
    9148:	4603      	mov	r3, r0
    914a:	f88d 300f 	strb.w	r3, [sp, #15]
    914e:	460b      	mov	r3, r1
    9150:	f8ad 300c 	strh.w	r3, [sp, #12]
    9154:	4613      	mov	r3, r2
    9156:	f8ad 3006 	strh.w	r3, [sp, #6]
    Lpspi_Ip_StateStructureType* State = Lpspi_Ip_apxStateStructureArray[Instance];
    915a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    915e:	4a22      	ldr	r2, [pc, #136]	; (91e8 <Lpspi_TransmitRxInit+0xa8>)
    9160:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9164:	9307      	str	r3, [sp, #28]
    
    /* Update State structure. */
    State->RxIndex = 0u;
    9166:	9b07      	ldr	r3, [sp, #28]
    9168:	2200      	movs	r2, #0
    916a:	829a      	strh	r2, [r3, #20]
        (void)RxBuffer; 
    }
    else
    #endif        
    {
        State->RxBuffer = RxBuffer; 
    916c:	9b07      	ldr	r3, [sp, #28]
    916e:	9a02      	ldr	r2, [sp, #8]
    9170:	609a      	str	r2, [r3, #8]
    9172:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    9176:	f8ad 301a 	strh.w	r3, [sp, #26]
    917a:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    917e:	f8ad 3018 	strh.w	r3, [sp, #24]
    if (FrameSize < 9u)
    9182:	f8bd 3018 	ldrh.w	r3, [sp, #24]
    9186:	2b08      	cmp	r3, #8
    9188:	d804      	bhi.n	9194 <Lpspi_TransmitRxInit+0x54>
        Ret = Length;
    918a:	f8bd 301a 	ldrh.w	r3, [sp, #26]
    918e:	f8ad 3016 	strh.w	r3, [sp, #22]
    9192:	e022      	b.n	91da <Lpspi_TransmitRxInit+0x9a>
    else if (FrameSize < 17u)
    9194:	f8bd 3018 	ldrh.w	r3, [sp, #24]
    9198:	2b10      	cmp	r3, #16
    919a:	d80c      	bhi.n	91b6 <Lpspi_TransmitRxInit+0x76>
        Ret = (uint16)(Length / 2u) + (uint16)(Length % 2U);
    919c:	f8bd 301a 	ldrh.w	r3, [sp, #26]
    91a0:	085b      	lsrs	r3, r3, #1
    91a2:	b29a      	uxth	r2, r3
    91a4:	f8bd 301a 	ldrh.w	r3, [sp, #26]
    91a8:	f003 0301 	and.w	r3, r3, #1
    91ac:	b29b      	uxth	r3, r3
    91ae:	4413      	add	r3, r2
    91b0:	f8ad 3016 	strh.w	r3, [sp, #22]
    91b4:	e011      	b.n	91da <Lpspi_TransmitRxInit+0x9a>
        Ret = (uint16)(Length / 4u) + (uint16)(((Length % 4U) == 0U) ? 0U : 1U);
    91b6:	f8bd 301a 	ldrh.w	r3, [sp, #26]
    91ba:	089b      	lsrs	r3, r3, #2
    91bc:	b29a      	uxth	r2, r3
    91be:	f8bd 301a 	ldrh.w	r3, [sp, #26]
    91c2:	f003 0303 	and.w	r3, r3, #3
    91c6:	b29b      	uxth	r3, r3
    91c8:	2b00      	cmp	r3, #0
    91ca:	bf14      	ite	ne
    91cc:	2301      	movne	r3, #1
    91ce:	2300      	moveq	r3, #0
    91d0:	b2db      	uxtb	r3, r3
    91d2:	b29b      	uxth	r3, r3
    91d4:	4413      	add	r3, r2
    91d6:	f8ad 3016 	strh.w	r3, [sp, #22]
    return Ret;
    91da:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    }

    State->ExpectedFifoReads = Lpspi_Ip_GetWordsFromLength(BufLen, RxFrameSize);
    91de:	9b07      	ldr	r3, [sp, #28]
    91e0:	831a      	strh	r2, [r3, #24]
}
    91e2:	bf00      	nop
    91e4:	b008      	add	sp, #32
    91e6:	4770      	bx	lr
    91e8:	1fff8ddc 	.word	0x1fff8ddc

000091ec <Lpspi_Ip_AsyncTransmit>:
                                            const uint8 *TxBuffer,
                                            uint8 *RxBuffer,
                                            uint16 Length,
                                            Lpspi_Ip_CallbackType EndCallback
                                          )
{
    91ec:	b500      	push	{lr}
    91ee:	b08b      	sub	sp, #44	; 0x2c
    91f0:	9005      	str	r0, [sp, #20]
    91f2:	9104      	str	r1, [sp, #16]
    91f4:	9203      	str	r2, [sp, #12]
    91f6:	f8ad 300a 	strh.w	r3, [sp, #10]
    LPSPI_Type* Base;
    Lpspi_Ip_StateStructureType* State;
    Lpspi_Ip_StatusType Status = LPSPI_IP_STATUS_SUCCESS;
    91fa:	2300      	movs	r3, #0
    91fc:	9309      	str	r3, [sp, #36]	; 0x24
    uint8 Instance = 0u;
    91fe:	2300      	movs	r3, #0
    9200:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(ExternalDevice != NULL_PTR);
    DevAssert(0u != Length);
    Lpspi_Ip_CheckValidParameters(ExternalDevice, Length);
    #endif
    Instance = ExternalDevice->Instance;
    9204:	9b05      	ldr	r3, [sp, #20]
    9206:	781b      	ldrb	r3, [r3, #0]
    9208:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    State = Lpspi_Ip_apxStateStructureArray[Instance];
    920c:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    9210:	4a3d      	ldr	r2, [pc, #244]	; (9308 <Lpspi_Ip_AsyncTransmit+0x11c>)
    9212:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9216:	9307      	str	r3, [sp, #28]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(State != NULL_PTR);
    #endif
    
    Base = Lpspi_Ip_apxBases[Instance];
    9218:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    921c:	4a3b      	ldr	r2, [pc, #236]	; (930c <Lpspi_Ip_AsyncTransmit+0x120>)
    921e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9222:	9306      	str	r3, [sp, #24]
    SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09();
    9224:	f00d f93e 	bl	164a4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09>
    if (LPSPI_IP_BUSY == State->Status)
    9228:	9b07      	ldr	r3, [sp, #28]
    922a:	685b      	ldr	r3, [r3, #4]
    922c:	2b02      	cmp	r3, #2
    922e:	d104      	bne.n	923a <Lpspi_Ip_AsyncTransmit+0x4e>
    {
        SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09();
    9230:	f00d f964 	bl	164fc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09>
        Status = LPSPI_IP_STATUS_FAIL;
    9234:	2301      	movs	r3, #1
    9236:	9309      	str	r3, [sp, #36]	; 0x24
    9238:	e061      	b.n	92fe <Lpspi_Ip_AsyncTransmit+0x112>
        #if (STD_ON == LPSPI_IP_HALF_DUPLEX_MODE_SUPPORT)
        /* Clear some bits which support for half duplex mode at previous transfer */
        Base->CFGR1 &= ~(LPSPI_CFGR1_PCSCFG_MASK | LPSPI_CFGR1_OUTCFG_MASK | LPSPI_CFGR1_PINCFG_MASK);
        #endif
        /* Mark the hardware as busy. */
        State->Status = LPSPI_IP_BUSY;
    923a:	9b07      	ldr	r3, [sp, #28]
    923c:	2202      	movs	r2, #2
    923e:	605a      	str	r2, [r3, #4]
        State->ExternalDevice = ExternalDevice;
    9240:	9b07      	ldr	r3, [sp, #28]
    9242:	9a05      	ldr	r2, [sp, #20]
    9244:	625a      	str	r2, [r3, #36]	; 0x24
        SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09();
    9246:	f00d f959 	bl	164fc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09>
        
        /* Update State structure. */
        State->Callback = EndCallback;
    924a:	9b07      	ldr	r3, [sp, #28]
    924c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    924e:	611a      	str	r2, [r3, #16]
        State->NextTransferConfigAvailable = State->KeepCs;
    9250:	9b07      	ldr	r3, [sp, #28]
    9252:	7f1a      	ldrb	r2, [r3, #28]
    9254:	9b07      	ldr	r3, [sp, #28]
    9256:	f883 203a 	strb.w	r2, [r3, #58]	; 0x3a
        
        /* Reset TX done flag */
        State->TxDoneFlag = FALSE;
    925a:	9b07      	ldr	r3, [sp, #28]
    925c:	2200      	movs	r2, #0
    925e:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d
        
        /* Set clock configuration */
        if(TRUE == State->FirstCmd)
    9262:	9b07      	ldr	r3, [sp, #28]
    9264:	7f5b      	ldrb	r3, [r3, #29]
    9266:	2b00      	cmp	r3, #0
    9268:	d028      	beq.n	92bc <Lpspi_Ip_AsyncTransmit+0xd0>
        {
            SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11();
    926a:	f00d f9bf 	bl	165ec <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11>
            /* Make sure that FIFOs will be empty before start new transfer session */
            Base->CR |= LPSPI_CR_RTF_MASK|LPSPI_CR_RRF_MASK;
    926e:	9b06      	ldr	r3, [sp, #24]
    9270:	691b      	ldr	r3, [r3, #16]
    9272:	f443 7240 	orr.w	r2, r3, #768	; 0x300
    9276:	9b06      	ldr	r3, [sp, #24]
    9278:	611a      	str	r2, [r3, #16]
            /* clear all flags */
            Base->SR &= LPSPI_IP_SR_W1C_MASK_U32;
    927a:	9b06      	ldr	r3, [sp, #24]
    927c:	695b      	ldr	r3, [r3, #20]
    927e:	f403 527c 	and.w	r2, r3, #16128	; 0x3f00
    9282:	9b06      	ldr	r3, [sp, #24]
    9284:	615a      	str	r2, [r3, #20]
            #endif
            {
                #if (STD_ON == LPSPI_IP_DUAL_CLOCK_MODE)
                Base->CCR = ExternalDevice->Ccr[State->ClockMode];
                #else
                Base->CCR = ExternalDevice->Ccr;
    9286:	9b05      	ldr	r3, [sp, #20]
    9288:	685a      	ldr	r2, [r3, #4]
    928a:	9b06      	ldr	r3, [sp, #24]
    928c:	641a      	str	r2, [r3, #64]	; 0x40
                #endif
            }
            /* Update current FIFO slots are available to fill .*/
            State->CurrentTxFifoSlot = LPSPI_IP_FIFO_SIZE_U8;
    928e:	9b07      	ldr	r3, [sp, #28]
    9290:	2204      	movs	r2, #4
    9292:	f883 203c 	strb.w	r2, [r3, #60]	; 0x3c
            /* In setting up Transmit command register, the RXMSK is also cleared */
            Lpspi_TransmitTxInit(Instance, (const uint8*)TxBuffer, State->ExternalDevice->DeviceParams->FrameSize, State->ExternalDevice->DeviceParams->Lsb, Length);
    9296:	9b07      	ldr	r3, [sp, #28]
    9298:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    929a:	68db      	ldr	r3, [r3, #12]
    929c:	881a      	ldrh	r2, [r3, #0]
    929e:	9b07      	ldr	r3, [sp, #28]
    92a0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    92a2:	68db      	ldr	r3, [r3, #12]
    92a4:	7899      	ldrb	r1, [r3, #2]
    92a6:	f89d 0023 	ldrb.w	r0, [sp, #35]	; 0x23
    92aa:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    92ae:	9300      	str	r3, [sp, #0]
    92b0:	460b      	mov	r3, r1
    92b2:	9904      	ldr	r1, [sp, #16]
    92b4:	f7ff fea4 	bl	9000 <Lpspi_TransmitTxInit>
            SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11();
    92b8:	f00d f9c4 	bl	16644 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11>
        }
        Lpspi_TransmitRxInit(Instance, RxBuffer, State->ExternalDevice->DeviceParams->FrameSize, Length);
    92bc:	9b07      	ldr	r3, [sp, #28]
    92be:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    92c0:	68db      	ldr	r3, [r3, #12]
    92c2:	881a      	ldrh	r2, [r3, #0]
    92c4:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    92c8:	f89d 0023 	ldrb.w	r0, [sp, #35]	; 0x23
    92cc:	9903      	ldr	r1, [sp, #12]
    92ce:	f7ff ff37 	bl	9140 <Lpspi_TransmitRxInit>
            }
            else
            #endif
            {
                /* Set TX water */
                Base->FCR = LPSPI_FCR_TXWATER((uint32)LPSPI_IP_FIFO_SIZE_U8 - (uint32)1u);
    92d2:	9b06      	ldr	r3, [sp, #24]
    92d4:	2203      	movs	r2, #3
    92d6:	659a      	str	r2, [r3, #88]	; 0x58
            }
            
            /* Disable DMA requests */
            Base->DER = 0u;
    92d8:	9b06      	ldr	r3, [sp, #24]
    92da:	2200      	movs	r2, #0
    92dc:	61da      	str	r2, [r3, #28]
            switch (State->TransferMode)
    92de:	9b07      	ldr	r3, [sp, #28]
    92e0:	681b      	ldr	r3, [r3, #0]
    92e2:	2b00      	cmp	r3, #0
    92e4:	d002      	beq.n	92ec <Lpspi_Ip_AsyncTransmit+0x100>
    92e6:	2b01      	cmp	r3, #1
    92e8:	d004      	beq.n	92f4 <Lpspi_Ip_AsyncTransmit+0x108>
                case LPSPI_IP_INTERRUPT:
                    Base->IER = LPSPI_IER_RDIE_MASK | LPSPI_IER_TDIE_MASK | LPSPI_IER_REIE_MASK | LPSPI_IER_TEIE_MASK;
                    break;
                default:
                    /* Nothing to do */
                    break;
    92ea:	e008      	b.n	92fe <Lpspi_Ip_AsyncTransmit+0x112>
                    Base->IER = 0u;
    92ec:	9b06      	ldr	r3, [sp, #24]
    92ee:	2200      	movs	r2, #0
    92f0:	619a      	str	r2, [r3, #24]
                    break;
    92f2:	e004      	b.n	92fe <Lpspi_Ip_AsyncTransmit+0x112>
                    Base->IER = LPSPI_IER_RDIE_MASK | LPSPI_IER_TDIE_MASK | LPSPI_IER_REIE_MASK | LPSPI_IER_TEIE_MASK;
    92f4:	9b06      	ldr	r3, [sp, #24]
    92f6:	f641 0203 	movw	r2, #6147	; 0x1803
    92fa:	619a      	str	r2, [r3, #24]
                    break;
    92fc:	bf00      	nop
            /* Enable DMA request. */
            Base->DER = LPSPI_DER_RDDE_MASK | LPSPI_DER_TDDE_MASK;
        }
        #endif
    }
    return Status;
    92fe:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    9300:	4618      	mov	r0, r3
    9302:	b00b      	add	sp, #44	; 0x2c
    9304:	f85d fb04 	ldr.w	pc, [sp], #4
    9308:	1fff8ddc 	.word	0x1fff8ddc
    930c:	000186c4 	.word	0x000186c4

00009310 <Lpspi_Ip_ManageBuffers>:
}
#endif
#endif

void Lpspi_Ip_ManageBuffers(uint8 Instance)
{
    9310:	b500      	push	{lr}
    9312:	b085      	sub	sp, #20
    9314:	4603      	mov	r3, r0
    9316:	f88d 3007 	strb.w	r3, [sp, #7]
    #endif

    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(Instance < LPSPI_INSTANCE_COUNT);
    #endif
    Base = Lpspi_Ip_apxBases[Instance];
    931a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    931e:	4a14      	ldr	r2, [pc, #80]	; (9370 <Lpspi_Ip_ManageBuffers+0x60>)
    9320:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9324:	9303      	str	r3, [sp, #12]
    State = Lpspi_Ip_apxStateStructureArray[Instance];
    9326:	f89d 3007 	ldrb.w	r3, [sp, #7]
    932a:	4a12      	ldr	r2, [pc, #72]	; (9374 <Lpspi_Ip_ManageBuffers+0x64>)
    932c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9330:	9302      	str	r3, [sp, #8]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != State);
    #endif
    if (LPSPI_IP_POLLING == State->TransferMode)
    9332:	9b02      	ldr	r3, [sp, #8]
    9334:	681b      	ldr	r3, [r3, #0]
    9336:	2b00      	cmp	r3, #0
    9338:	d115      	bne.n	9366 <Lpspi_Ip_ManageBuffers+0x56>
                - Receive: Both TDF (push CDM) and DRF (receive data) are set.
               In half duplex Slave mode:
                - Transmit: TDF is set only, RDF will never be set by RX FIFO have masked.
                - Receive: Both TDF and RDF are set. But only process for RDF to receive data. In this case, State->CurrentTxFifoSlot will be set to 0 */
            if(
                (0u != (Base->SR & LPSPI_SR_RDF_MASK)) ||
    933a:	9b03      	ldr	r3, [sp, #12]
    933c:	695b      	ldr	r3, [r3, #20]
    933e:	f003 0302 	and.w	r3, r3, #2
            if(
    9342:	2b00      	cmp	r3, #0
    9344:	d10a      	bne.n	935c <Lpspi_Ip_ManageBuffers+0x4c>
                ((0u != (Base->SR & LPSPI_SR_TDF_MASK)) && (0u!= State->CurrentTxFifoSlot))
    9346:	9b03      	ldr	r3, [sp, #12]
    9348:	695b      	ldr	r3, [r3, #20]
    934a:	f003 0301 	and.w	r3, r3, #1
                (0u != (Base->SR & LPSPI_SR_RDF_MASK)) ||
    934e:	2b00      	cmp	r3, #0
    9350:	d009      	beq.n	9366 <Lpspi_Ip_ManageBuffers+0x56>
                ((0u != (Base->SR & LPSPI_SR_TDF_MASK)) && (0u!= State->CurrentTxFifoSlot))
    9352:	9b02      	ldr	r3, [sp, #8]
    9354:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
    9358:	2b00      	cmp	r3, #0
    935a:	d004      	beq.n	9366 <Lpspi_Ip_ManageBuffers+0x56>
                    Lpspi_Ip_TransferProcessHalfDuplex(Instance);
                }
                else
                #endif
                {
                    Lpspi_Ip_TransferProcess(Instance); 
    935c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9360:	4618      	mov	r0, r3
    9362:	f7ff f8cd 	bl	8500 <Lpspi_Ip_TransferProcess>
                Lpspi_Ip_IrqTxDmaHandler(Instance);
            }
        }
        #endif
    }
}
    9366:	bf00      	nop
    9368:	b005      	add	sp, #20
    936a:	f85d fb04 	ldr.w	pc, [sp], #4
    936e:	bf00      	nop
    9370:	000186c4 	.word	0x000186c4
    9374:	1fff8ddc 	.word	0x1fff8ddc

00009378 <Lpspi_Ip_UpdateFrameSize>:
/*================================================================================================*/
Lpspi_Ip_StatusType Lpspi_Ip_UpdateFrameSize(const Lpspi_Ip_ExternalDeviceType *ExternalDevice, uint16 FrameSize)
{
    9378:	b084      	sub	sp, #16
    937a:	9001      	str	r0, [sp, #4]
    937c:	460b      	mov	r3, r1
    937e:	f8ad 3002 	strh.w	r3, [sp, #2]
    const Lpspi_Ip_StateStructureType* State;
    Lpspi_Ip_StatusType Status = LPSPI_IP_STATUS_SUCCESS;
    9382:	2300      	movs	r3, #0
    9384:	9303      	str	r3, [sp, #12]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != ExternalDevice);
    DevAssert(LPSPI_IP_FRAMESIZE_MAX_U16 >= FrameSize);
    DevAssert(LPSPI_IP_FRAMESIZE_MIN_U16 <= FrameSize);
    #endif
    State = Lpspi_Ip_apxStateStructureArray[ExternalDevice->Instance];
    9386:	9b01      	ldr	r3, [sp, #4]
    9388:	781b      	ldrb	r3, [r3, #0]
    938a:	461a      	mov	r2, r3
    938c:	4b09      	ldr	r3, [pc, #36]	; (93b4 <Lpspi_Ip_UpdateFrameSize+0x3c>)
    938e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    9392:	9302      	str	r3, [sp, #8]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != State);
    #endif
    /* Frame size can be changed when no transfers are in progress. */
    if (State->Status != LPSPI_IP_BUSY)
    9394:	9b02      	ldr	r3, [sp, #8]
    9396:	685b      	ldr	r3, [r3, #4]
    9398:	2b02      	cmp	r3, #2
    939a:	d005      	beq.n	93a8 <Lpspi_Ip_UpdateFrameSize+0x30>
    {
        ExternalDevice->DeviceParams->FrameSize = FrameSize;
    939c:	9b01      	ldr	r3, [sp, #4]
    939e:	68db      	ldr	r3, [r3, #12]
    93a0:	f8bd 2002 	ldrh.w	r2, [sp, #2]
    93a4:	801a      	strh	r2, [r3, #0]
    93a6:	e001      	b.n	93ac <Lpspi_Ip_UpdateFrameSize+0x34>
    }
    else
    {
        Status = LPSPI_IP_STATUS_FAIL;
    93a8:	2301      	movs	r3, #1
    93aa:	9303      	str	r3, [sp, #12]
    }
    return Status;
    93ac:	9b03      	ldr	r3, [sp, #12]
}
    93ae:	4618      	mov	r0, r3
    93b0:	b004      	add	sp, #16
    93b2:	4770      	bx	lr
    93b4:	1fff8ddc 	.word	0x1fff8ddc

000093b8 <Lpspi_Ip_UpdateLsb>:

Lpspi_Ip_StatusType Lpspi_Ip_UpdateLsb(const Lpspi_Ip_ExternalDeviceType *ExternalDevice, boolean Lsb)
{
    93b8:	b084      	sub	sp, #16
    93ba:	9001      	str	r0, [sp, #4]
    93bc:	460b      	mov	r3, r1
    93be:	f88d 3003 	strb.w	r3, [sp, #3]
    const Lpspi_Ip_StateStructureType* State;
    Lpspi_Ip_StatusType Status = LPSPI_IP_STATUS_SUCCESS;
    93c2:	2300      	movs	r3, #0
    93c4:	9303      	str	r3, [sp, #12]
    
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != ExternalDevice);
    #endif
    State = Lpspi_Ip_apxStateStructureArray[ExternalDevice->Instance];
    93c6:	9b01      	ldr	r3, [sp, #4]
    93c8:	781b      	ldrb	r3, [r3, #0]
    93ca:	461a      	mov	r2, r3
    93cc:	4b09      	ldr	r3, [pc, #36]	; (93f4 <Lpspi_Ip_UpdateLsb+0x3c>)
    93ce:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    93d2:	9302      	str	r3, [sp, #8]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != State);
    #endif
    /* Bite order can be changed when no transfers are in progress. */
    if (State->Status != LPSPI_IP_BUSY)
    93d4:	9b02      	ldr	r3, [sp, #8]
    93d6:	685b      	ldr	r3, [r3, #4]
    93d8:	2b02      	cmp	r3, #2
    93da:	d005      	beq.n	93e8 <Lpspi_Ip_UpdateLsb+0x30>
    {
        ExternalDevice->DeviceParams->Lsb = Lsb;
    93dc:	9b01      	ldr	r3, [sp, #4]
    93de:	68db      	ldr	r3, [r3, #12]
    93e0:	f89d 2003 	ldrb.w	r2, [sp, #3]
    93e4:	709a      	strb	r2, [r3, #2]
    93e6:	e001      	b.n	93ec <Lpspi_Ip_UpdateLsb+0x34>
    }
    else
    {
        Status = LPSPI_IP_STATUS_FAIL;
    93e8:	2301      	movs	r3, #1
    93ea:	9303      	str	r3, [sp, #12]
    }
    return Status;
    93ec:	9b03      	ldr	r3, [sp, #12]
}
    93ee:	4618      	mov	r0, r3
    93f0:	b004      	add	sp, #16
    93f2:	4770      	bx	lr
    93f4:	1fff8ddc 	.word	0x1fff8ddc

000093f8 <Lpspi_Ip_UpdateDefaultTransmitData>:

Lpspi_Ip_StatusType Lpspi_Ip_UpdateDefaultTransmitData(const Lpspi_Ip_ExternalDeviceType *ExternalDevice, uint32 DefaultData)
{
    93f8:	b084      	sub	sp, #16
    93fa:	9001      	str	r0, [sp, #4]
    93fc:	9100      	str	r1, [sp, #0]
    const Lpspi_Ip_StateStructureType* State;
    Lpspi_Ip_StatusType Status = LPSPI_IP_STATUS_SUCCESS;
    93fe:	2300      	movs	r3, #0
    9400:	9303      	str	r3, [sp, #12]
    
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != ExternalDevice);
    #endif
    State = Lpspi_Ip_apxStateStructureArray[ExternalDevice->Instance];
    9402:	9b01      	ldr	r3, [sp, #4]
    9404:	781b      	ldrb	r3, [r3, #0]
    9406:	461a      	mov	r2, r3
    9408:	4b09      	ldr	r3, [pc, #36]	; (9430 <Lpspi_Ip_UpdateDefaultTransmitData+0x38>)
    940a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    940e:	9302      	str	r3, [sp, #8]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != State);
    #endif
    /* Bite order can be changed when no transfers are in progress. */
    if (State->Status != LPSPI_IP_BUSY)
    9410:	9b02      	ldr	r3, [sp, #8]
    9412:	685b      	ldr	r3, [r3, #4]
    9414:	2b02      	cmp	r3, #2
    9416:	d004      	beq.n	9422 <Lpspi_Ip_UpdateDefaultTransmitData+0x2a>
    {
        ExternalDevice->DeviceParams->DefaultData = DefaultData;
    9418:	9b01      	ldr	r3, [sp, #4]
    941a:	68db      	ldr	r3, [r3, #12]
    941c:	9a00      	ldr	r2, [sp, #0]
    941e:	605a      	str	r2, [r3, #4]
    9420:	e001      	b.n	9426 <Lpspi_Ip_UpdateDefaultTransmitData+0x2e>
    }
    else
    {
        Status = LPSPI_IP_STATUS_FAIL;
    9422:	2301      	movs	r3, #1
    9424:	9303      	str	r3, [sp, #12]
    }
    return Status;
    9426:	9b03      	ldr	r3, [sp, #12]
}
    9428:	4618      	mov	r0, r3
    942a:	b004      	add	sp, #16
    942c:	4770      	bx	lr
    942e:	bf00      	nop
    9430:	1fff8ddc 	.word	0x1fff8ddc

00009434 <Lpspi_Ip_UpdateTransferMode>:

Lpspi_Ip_StatusType Lpspi_Ip_UpdateTransferMode(uint8 Instance, Lpspi_Ip_ModeType Mode)
{
    9434:	b084      	sub	sp, #16
    9436:	4603      	mov	r3, r0
    9438:	9100      	str	r1, [sp, #0]
    943a:	f88d 3007 	strb.w	r3, [sp, #7]
    Lpspi_Ip_StateStructureType* State;
    Lpspi_Ip_StatusType Status = LPSPI_IP_STATUS_SUCCESS;
    943e:	2300      	movs	r3, #0
    9440:	9303      	str	r3, [sp, #12]

    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(Instance < LPSPI_INSTANCE_COUNT);
    #endif
    State = Lpspi_Ip_apxStateStructureArray[Instance];
    9442:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9446:	4a09      	ldr	r2, [pc, #36]	; (946c <Lpspi_Ip_UpdateTransferMode+0x38>)
    9448:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    944c:	9302      	str	r3, [sp, #8]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != State);
    #endif
    /* Transfer mode can be changed when no transfers are in progress. */
    if (State->Status != LPSPI_IP_BUSY)
    944e:	9b02      	ldr	r3, [sp, #8]
    9450:	685b      	ldr	r3, [r3, #4]
    9452:	2b02      	cmp	r3, #2
    9454:	d003      	beq.n	945e <Lpspi_Ip_UpdateTransferMode+0x2a>
    {
        State->TransferMode = Mode;
    9456:	9b02      	ldr	r3, [sp, #8]
    9458:	9a00      	ldr	r2, [sp, #0]
    945a:	601a      	str	r2, [r3, #0]
    945c:	e001      	b.n	9462 <Lpspi_Ip_UpdateTransferMode+0x2e>
    }
    else
    {
        Status = LPSPI_IP_STATUS_FAIL;
    945e:	2301      	movs	r3, #1
    9460:	9303      	str	r3, [sp, #12]
    }
    return Status;
    9462:	9b03      	ldr	r3, [sp, #12]
}
    9464:	4618      	mov	r0, r3
    9466:	b004      	add	sp, #16
    9468:	4770      	bx	lr
    946a:	bf00      	nop
    946c:	1fff8ddc 	.word	0x1fff8ddc

00009470 <Lpspi_Ip_Cancel>:

void Lpspi_Ip_Cancel(uint8 Instance)
{
    9470:	b500      	push	{lr}
    9472:	b087      	sub	sp, #28
    9474:	4603      	mov	r3, r0
    9476:	f88d 3007 	strb.w	r3, [sp, #7]
    LPSPI_Type* Base;
    Lpspi_Ip_StateStructureType* State;
    uint32 Cfgr1 = 0u;
    947a:	2300      	movs	r3, #0
    947c:	9305      	str	r3, [sp, #20]
    
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(Instance < LPSPI_INSTANCE_COUNT);
    #endif
    Base = Lpspi_Ip_apxBases[Instance];
    947e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9482:	4a18      	ldr	r2, [pc, #96]	; (94e4 <Lpspi_Ip_Cancel+0x74>)
    9484:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9488:	9304      	str	r3, [sp, #16]
    State = Lpspi_Ip_apxStateStructureArray[Instance];
    948a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    948e:	4a16      	ldr	r2, [pc, #88]	; (94e8 <Lpspi_Ip_Cancel+0x78>)
    9490:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9494:	9303      	str	r3, [sp, #12]
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(NULL_PTR != State);
    #endif
    SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10();
    9496:	f00d f857 	bl	16548 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10>
    if (LPSPI_IP_BUSY == State->Status)
    949a:	9b03      	ldr	r3, [sp, #12]
    949c:	685b      	ldr	r3, [r3, #4]
    949e:	2b02      	cmp	r3, #2
    94a0:	d11a      	bne.n	94d8 <Lpspi_Ip_Cancel+0x68>
    {
        /* Mask Rx to discard received data */
        Base->TCR |= LPSPI_TCR_RXMSK(1);
    94a2:	9b04      	ldr	r3, [sp, #16]
    94a4:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    94a6:	f443 2200 	orr.w	r2, r3, #524288	; 0x80000
    94aa:	9b04      	ldr	r3, [sp, #16]
    94ac:	661a      	str	r2, [r3, #96]	; 0x60
        /* store CFGR1 and restore after all registers are reset */
        Cfgr1 = Base->CFGR1;
    94ae:	9b04      	ldr	r3, [sp, #16]
    94b0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    94b2:	9305      	str	r3, [sp, #20]
        /* Disable interrupts and DMA requests. */
        /* Clear FIFO */
        /* RTF and RRF will not clear shifter, so RST must be used to ensure old Data in shifter will also be cleared. */
        Base->CR |= LPSPI_CR_RST_MASK;
    94b4:	9b04      	ldr	r3, [sp, #16]
    94b6:	691b      	ldr	r3, [r3, #16]
    94b8:	f043 0202 	orr.w	r2, r3, #2
    94bc:	9b04      	ldr	r3, [sp, #16]
    94be:	611a      	str	r2, [r3, #16]
        Base->CR &= ~LPSPI_CR_RST_MASK;
    94c0:	9b04      	ldr	r3, [sp, #16]
    94c2:	691b      	ldr	r3, [r3, #16]
    94c4:	f023 0202 	bic.w	r2, r3, #2
    94c8:	9b04      	ldr	r3, [sp, #16]
    94ca:	611a      	str	r2, [r3, #16]
        /* restore CFGR1 */
        Base->CFGR1 = Cfgr1;
    94cc:	9b04      	ldr	r3, [sp, #16]
    94ce:	9a05      	ldr	r2, [sp, #20]
    94d0:	625a      	str	r2, [r3, #36]	; 0x24
            (void)Dma_Ip_SetLogicChannelCommand(State->PhyUnitConfig->RxDmaChannel, DMA_IP_CH_CLEAR_HARDWARE_REQUEST);
            (void)Dma_Ip_SetLogicChannelCommand(State->PhyUnitConfig->TxDmaChannel, DMA_IP_CH_CLEAR_HARDWARE_REQUEST);
        }
        #endif
        /* set State to idle */
        State->Status = LPSPI_IP_IDLE;
    94d2:	9b03      	ldr	r3, [sp, #12]
    94d4:	2201      	movs	r2, #1
    94d6:	605a      	str	r2, [r3, #4]
    }
    SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10();
    94d8:	f00d f862 	bl	165a0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10>
}
    94dc:	bf00      	nop
    94de:	b007      	add	sp, #28
    94e0:	f85d fb04 	ldr.w	pc, [sp], #4
    94e4:	000186c4 	.word	0x000186c4
    94e8:	1fff8ddc 	.word	0x1fff8ddc

000094ec <Lpspi_Ip_IrqHandler>:
* @param[in]     Instance            Instance of the hardware unit.
*
* @implements Lpspi_Ip_IrqHandler_Activity
*/
void Lpspi_Ip_IrqHandler(uint8 Instance)
{
    94ec:	b500      	push	{lr}
    94ee:	b087      	sub	sp, #28
    94f0:	4603      	mov	r3, r0
    94f2:	f88d 3007 	strb.w	r3, [sp, #7]
    LPSPI_Type* Base = Lpspi_Ip_apxBases[Instance];
    94f6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    94fa:	4a18      	ldr	r2, [pc, #96]	; (955c <Lpspi_Ip_IrqHandler+0x70>)
    94fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9500:	9305      	str	r3, [sp, #20]
    const Lpspi_Ip_StateStructureType* State = Lpspi_Ip_apxStateStructureArray[Instance];
    9502:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9506:	4a16      	ldr	r2, [pc, #88]	; (9560 <Lpspi_Ip_IrqHandler+0x74>)
    9508:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    950c:	9304      	str	r3, [sp, #16]
    uint32 IrqFlags = 0u;
    950e:	2300      	movs	r3, #0
    9510:	9303      	str	r3, [sp, #12]

    if (NULL_PTR != State)
    9512:	9b04      	ldr	r3, [sp, #16]
    9514:	2b00      	cmp	r3, #0
    9516:	d016      	beq.n	9546 <Lpspi_Ip_IrqHandler+0x5a>
    {
        /* the driver has been initialized */
        IrqFlags = Base->SR & (LPSPI_SR_TDF_MASK | LPSPI_SR_RDF_MASK | LPSPI_SR_TEF_MASK | LPSPI_SR_REF_MASK);
    9518:	9b05      	ldr	r3, [sp, #20]
    951a:	695a      	ldr	r2, [r3, #20]
    951c:	f641 0303 	movw	r3, #6147	; 0x1803
    9520:	4013      	ands	r3, r2
    9522:	9303      	str	r3, [sp, #12]
        IrqFlags &= Base->IER & (LPSPI_IER_TDIE_MASK | LPSPI_IER_RDIE_MASK | LPSPI_IER_TEIE_MASK | LPSPI_IER_REIE_MASK);
    9524:	9b05      	ldr	r3, [sp, #20]
    9526:	699a      	ldr	r2, [r3, #24]
    9528:	f641 0303 	movw	r3, #6147	; 0x1803
    952c:	4013      	ands	r3, r2
    952e:	9a03      	ldr	r2, [sp, #12]
    9530:	4013      	ands	r3, r2
    9532:	9303      	str	r3, [sp, #12]
        if (0u != IrqFlags)
    9534:	9b03      	ldr	r3, [sp, #12]
    9536:	2b00      	cmp	r3, #0
    9538:	d00b      	beq.n	9552 <Lpspi_Ip_IrqHandler+0x66>
                Lpspi_Ip_TransferProcessHalfDuplex(Instance);    
            }
            else
            #endif
            {
                Lpspi_Ip_TransferProcess(Instance); 
    953a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    953e:	4618      	mov	r0, r3
    9540:	f7fe ffde 	bl	8500 <Lpspi_Ip_TransferProcess>
    {
        /* the driver has not been initialized */
        /* clear all flags */
        Base->SR &= LPSPI_IP_SR_W1C_MASK_U32;
    }
}
    9544:	e005      	b.n	9552 <Lpspi_Ip_IrqHandler+0x66>
        Base->SR &= LPSPI_IP_SR_W1C_MASK_U32;
    9546:	9b05      	ldr	r3, [sp, #20]
    9548:	695b      	ldr	r3, [r3, #20]
    954a:	f403 527c 	and.w	r2, r3, #16128	; 0x3f00
    954e:	9b05      	ldr	r3, [sp, #20]
    9550:	615a      	str	r2, [r3, #20]
}
    9552:	bf00      	nop
    9554:	b007      	add	sp, #28
    9556:	f85d fb04 	ldr.w	pc, [sp], #4
    955a:	bf00      	nop
    955c:	000186c4 	.word	0x000186c4
    9560:	1fff8ddc 	.word	0x1fff8ddc

00009564 <Lpspi_Ip_GetStatus>:
* @param[in]        Instance - SPI peripheral instance number.
*
* @return           Lpspi_Ip_HwStatusType
*/
Lpspi_Ip_HwStatusType Lpspi_Ip_GetStatus(uint8 Instance)
{
    9564:	b084      	sub	sp, #16
    9566:	4603      	mov	r3, r0
    9568:	f88d 3007 	strb.w	r3, [sp, #7]
    const Lpspi_Ip_StateStructureType* State;
    Lpspi_Ip_HwStatusType Status = LPSPI_IP_UNINIT;
    956c:	2300      	movs	r3, #0
    956e:	9303      	str	r3, [sp, #12]
    
    #if (STD_ON == LPSPI_IP_DEV_ERROR_DETECT)
    DevAssert(Instance < LPSPI_INSTANCE_COUNT);
    #endif
    State = Lpspi_Ip_apxStateStructureArray[Instance];
    9570:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9574:	4a06      	ldr	r2, [pc, #24]	; (9590 <Lpspi_Ip_GetStatus+0x2c>)
    9576:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    957a:	9302      	str	r3, [sp, #8]
    if (State != NULL_PTR)
    957c:	9b02      	ldr	r3, [sp, #8]
    957e:	2b00      	cmp	r3, #0
    9580:	d002      	beq.n	9588 <Lpspi_Ip_GetStatus+0x24>
    {
        Status = State->Status;
    9582:	9b02      	ldr	r3, [sp, #8]
    9584:	685b      	ldr	r3, [r3, #4]
    9586:	9303      	str	r3, [sp, #12]
    }
    
    return Status;
    9588:	9b03      	ldr	r3, [sp, #12]
}
    958a:	4618      	mov	r0, r3
    958c:	b004      	add	sp, #16
    958e:	4770      	bx	lr
    9590:	1fff8ddc 	.word	0x1fff8ddc

00009594 <Spi_CheckInit>:
static inline Std_ReturnType Spi_CheckInit
    ( 
        const Spi_ConfigType *ConfigPtr,
        uint32 SpiCoreID
    )
{
    9594:	b086      	sub	sp, #24
    9596:	9001      	str	r0, [sp, #4]
    9598:	9100      	str	r1, [sp, #0]
    Std_ReturnType CheckStatus = (Std_ReturnType)E_OK;
    959a:	2300      	movs	r3, #0
    959c:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32 Sequence;
#endif

#if (SPI_PRECOMPILE_SUPPORT == STD_OFF)
    /* Configuration sizes must be checked for Post Build & Link Time configurations */
    Channel  = (uint32)(ConfigPtr->SpiMaxChannel);
    95a0:	9b01      	ldr	r3, [sp, #4]
    95a2:	789b      	ldrb	r3, [r3, #2]
    95a4:	9304      	str	r3, [sp, #16]
    Job      = (uint32)(ConfigPtr->SpiMaxJob);
    95a6:	9b01      	ldr	r3, [sp, #4]
    95a8:	889b      	ldrh	r3, [r3, #4]
    95aa:	9303      	str	r3, [sp, #12]
    Sequence = (uint32)(ConfigPtr->SpiMaxSequence);
    95ac:	9b01      	ldr	r3, [sp, #4]
    95ae:	799b      	ldrb	r3, [r3, #6]
    95b0:	9302      	str	r3, [sp, #8]

    if ((Channel >= SPI_MAX_CHANNEL) || (Job >= SPI_MAX_JOB) || (Sequence >= SPI_MAX_SEQUENCE))
    95b2:	9b04      	ldr	r3, [sp, #16]
    95b4:	2b01      	cmp	r3, #1
    95b6:	d805      	bhi.n	95c4 <Spi_CheckInit+0x30>
    95b8:	9b03      	ldr	r3, [sp, #12]
    95ba:	2b00      	cmp	r3, #0
    95bc:	d102      	bne.n	95c4 <Spi_CheckInit+0x30>
    95be:	9b02      	ldr	r3, [sp, #8]
    95c0:	2b00      	cmp	r3, #0
    95c2:	d002      	beq.n	95ca <Spi_CheckInit+0x36>
    {
        CheckStatus = (Std_ReturnType)E_NOT_OK;
    95c4:	2301      	movs	r3, #1
    95c6:	f88d 3017 	strb.w	r3, [sp, #23]
#if (SPI_DEV_ERROR_DETECT == STD_ON)
        /* Call Det_ReportError */
        (void)Det_ReportError((uint16) SPI_MODULE_ID,(uint8) 0,SPI_INIT_ID,SPI_E_CONFIG_OUT_OF_RANGE);
#endif
    }
    if (SpiCoreID != ConfigPtr->SpiCoreUse)
    95ca:	9b01      	ldr	r3, [sp, #4]
    95cc:	689b      	ldr	r3, [r3, #8]
    95ce:	9a00      	ldr	r2, [sp, #0]
    95d0:	429a      	cmp	r2, r3
    95d2:	d002      	beq.n	95da <Spi_CheckInit+0x46>
    {
        CheckStatus = (Std_ReturnType)E_NOT_OK;
    95d4:	2301      	movs	r3, #1
    95d6:	f88d 3017 	strb.w	r3, [sp, #23]
        (void)Det_ReportError((uint16) SPI_MODULE_ID,(uint8) 0,SPI_INIT_ID,SPI_E_INVALID_POINTER);
#endif
    }
#endif /* (SPI_PRECOMPILE_SUPPORT == STD_OFF) */

    return CheckStatus;
    95da:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    95de:	4618      	mov	r0, r3
    95e0:	b006      	add	sp, #24
    95e2:	4770      	bx	lr

000095e4 <Spi_SyncJobsTranfer>:
static Std_ReturnType Spi_SyncJobsTranfer
    (
        const Spi_SequenceConfigType *SequenceConfig,
        uint32 SpiCoreID
    )
{
    95e4:	b500      	push	{lr}
    95e6:	b089      	sub	sp, #36	; 0x24
    95e8:	9001      	str	r0, [sp, #4]
    95ea:	9100      	str	r1, [sp, #0]
    Spi_JobType JobsCount;
    const Spi_JobType *JobIndexList;
    Spi_JobType Job;
    Spi_JobStateType *JobState;
    const Spi_JobConfigType *JobConfig;
    Std_ReturnType Status = (Std_ReturnType)E_OK;
    95ec:	2300      	movs	r3, #0
    95ee:	f88d 3017 	strb.w	r3, [sp, #23]
    
    /* Get the number of jobs in the sequence */
    JobsCount = SequenceConfig->NumJobs;
    95f2:	9b01      	ldr	r3, [sp, #4]
    95f4:	881b      	ldrh	r3, [r3, #0]
    95f6:	f8ad 301e 	strh.w	r3, [sp, #30]
    JobIndexList = SequenceConfig->JobIndexList;
    95fa:	9b01      	ldr	r3, [sp, #4]
    95fc:	689b      	ldr	r3, [r3, #8]
    95fe:	9306      	str	r3, [sp, #24]
    while (0u < JobsCount)
    9600:	e072      	b.n	96e8 <Spi_SyncJobsTranfer+0x104>
    {
        /* Get the job id */
        Job = *JobIndexList;
    9602:	9b06      	ldr	r3, [sp, #24]
    9604:	881b      	ldrh	r3, [r3, #0]
    9606:	f8ad 3014 	strh.w	r3, [sp, #20]
        /* Set the job status as pending */
        JobState = &Spi_axSpiJobState[Job];
    960a:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    960e:	009b      	lsls	r3, r3, #2
    9610:	4a3a      	ldr	r2, [pc, #232]	; (96fc <Spi_SyncJobsTranfer+0x118>)
    9612:	4413      	add	r3, r2
    9614:	9304      	str	r3, [sp, #16]
        JobState->Result = SPI_JOB_PENDING;
    9616:	9b04      	ldr	r3, [sp, #16]
    9618:	2201      	movs	r2, #1
    961a:	601a      	str	r2, [r3, #0]
        JobConfig = Spi_apxSpiConfigPtr[SpiCoreID]->JobConfig[Job].JobCfg;
    961c:	4a38      	ldr	r2, [pc, #224]	; (9700 <Spi_SyncJobsTranfer+0x11c>)
    961e:	9b00      	ldr	r3, [sp, #0]
    9620:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9624:	691a      	ldr	r2, [r3, #16]
    9626:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    962a:	009b      	lsls	r3, r3, #2
    962c:	4413      	add	r3, r2
    962e:	681b      	ldr	r3, [r3, #0]
    9630:	9303      	str	r3, [sp, #12]
        
        /* start job notification to assert the non-cs pin,
        when non-cs pin is used as chipselect*/
        if (NULL_PTR != JobConfig->StartNotification)
    9632:	9b03      	ldr	r3, [sp, #12]
    9634:	68db      	ldr	r3, [r3, #12]
    9636:	2b00      	cmp	r3, #0
    9638:	d002      	beq.n	9640 <Spi_SyncJobsTranfer+0x5c>
        {
            JobConfig->StartNotification();
    963a:	9b03      	ldr	r3, [sp, #12]
    963c:	68db      	ldr	r3, [r3, #12]
    963e:	4798      	blx	r3
        else
        {
            /* Do nothing */
        }
        /* Mark HWUnit as busy */
        Spi_axSpiHwUnitQueueArray[JobConfig->HWUnit].Status = SPI_BUSY;
    9640:	9b03      	ldr	r3, [sp, #12]
    9642:	7f1b      	ldrb	r3, [r3, #28]
    9644:	4619      	mov	r1, r3
    9646:	4b2f      	ldr	r3, [pc, #188]	; (9704 <Spi_SyncJobsTranfer+0x120>)
    9648:	2202      	movs	r2, #2
    964a:	f843 2031 	str.w	r2, [r3, r1, lsl #3]
        
        Status = Spi_Ipw_SyncTransmit(JobConfig, SpiCoreID);
    964e:	9900      	ldr	r1, [sp, #0]
    9650:	9803      	ldr	r0, [sp, #12]
    9652:	f000 fc5f 	bl	9f14 <Spi_Ipw_SyncTransmit>
    9656:	4603      	mov	r3, r0
    9658:	f88d 3017 	strb.w	r3, [sp, #23]
        
        /* release HWUnit */
        Spi_axSpiHwUnitQueueArray[JobConfig->HWUnit].Status = SPI_IDLE;
    965c:	9b03      	ldr	r3, [sp, #12]
    965e:	7f1b      	ldrb	r3, [r3, #28]
    9660:	4619      	mov	r1, r3
    9662:	4b28      	ldr	r3, [pc, #160]	; (9704 <Spi_SyncJobsTranfer+0x120>)
    9664:	2201      	movs	r2, #1
    9666:	f843 2031 	str.w	r2, [r3, r1, lsl #3]
        
        if ((Std_ReturnType)E_OK == Status)
    966a:	f89d 3017 	ldrb.w	r3, [sp, #23]
    966e:	2b00      	cmp	r3, #0
    9670:	d10a      	bne.n	9688 <Spi_SyncJobsTranfer+0xa4>
        {
            /* Job is done set the status as OK */
            JobState->Result = SPI_JOB_OK;
    9672:	9b04      	ldr	r3, [sp, #16]
    9674:	2200      	movs	r2, #0
    9676:	601a      	str	r2, [r3, #0]
            /* Perform job EndNotification (if there is one) */
            if (NULL_PTR != JobConfig->EndNotification)
    9678:	9b03      	ldr	r3, [sp, #12]
    967a:	689b      	ldr	r3, [r3, #8]
    967c:	2b00      	cmp	r3, #0
    967e:	d02b      	beq.n	96d8 <Spi_SyncJobsTranfer+0xf4>
            {
                JobConfig->EndNotification();
    9680:	9b03      	ldr	r3, [sp, #12]
    9682:	689b      	ldr	r3, [r3, #8]
    9684:	4798      	blx	r3
    9686:	e027      	b.n	96d8 <Spi_SyncJobsTranfer+0xf4>
            /* transmission failed */
            /* set the remaining job status (including the current one) as FAILED */
            do
            {
                /* Set the job status as FAILED */
                Spi_axSpiJobState[*JobIndexList].Result = SPI_JOB_FAILED;
    9688:	9b06      	ldr	r3, [sp, #24]
    968a:	881b      	ldrh	r3, [r3, #0]
    968c:	4619      	mov	r1, r3
    968e:	4b1b      	ldr	r3, [pc, #108]	; (96fc <Spi_SyncJobsTranfer+0x118>)
    9690:	2202      	movs	r2, #2
    9692:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
                /* Update pointer position for JobConfig */
                JobConfig = Spi_apxSpiConfigPtr[SpiCoreID]->JobConfig[*JobIndexList].JobCfg;
    9696:	4a1a      	ldr	r2, [pc, #104]	; (9700 <Spi_SyncJobsTranfer+0x11c>)
    9698:	9b00      	ldr	r3, [sp, #0]
    969a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    969e:	691a      	ldr	r2, [r3, #16]
    96a0:	9b06      	ldr	r3, [sp, #24]
    96a2:	881b      	ldrh	r3, [r3, #0]
    96a4:	009b      	lsls	r3, r3, #2
    96a6:	4413      	add	r3, r2
    96a8:	681b      	ldr	r3, [r3, #0]
    96aa:	9303      	str	r3, [sp, #12]
                /* Perform job EndNotification (if there is one) */
                if (NULL_PTR != JobConfig->EndNotification)
    96ac:	9b03      	ldr	r3, [sp, #12]
    96ae:	689b      	ldr	r3, [r3, #8]
    96b0:	2b00      	cmp	r3, #0
    96b2:	d002      	beq.n	96ba <Spi_SyncJobsTranfer+0xd6>
                {
                    JobConfig->EndNotification();
    96b4:	9b03      	ldr	r3, [sp, #12]
    96b6:	689b      	ldr	r3, [r3, #8]
    96b8:	4798      	blx	r3
                }
                else
                {
                    /* Do nothing */
                }
                JobIndexList++;
    96ba:	9b06      	ldr	r3, [sp, #24]
    96bc:	3302      	adds	r3, #2
    96be:	9306      	str	r3, [sp, #24]
                JobsCount--;
    96c0:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    96c4:	3b01      	subs	r3, #1
    96c6:	f8ad 301e 	strh.w	r3, [sp, #30]
            } while (0u < JobsCount);
    96ca:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    96ce:	2b00      	cmp	r3, #0
    96d0:	d1da      	bne.n	9688 <Spi_SyncJobsTranfer+0xa4>
            JobsCount = 1u;  /* needed to end correctly the outer loop */
    96d2:	2301      	movs	r3, #1
    96d4:	f8ad 301e 	strh.w	r3, [sp, #30]
        }
        /* iterate to next job in sequence */
        JobIndexList++;
    96d8:	9b06      	ldr	r3, [sp, #24]
    96da:	3302      	adds	r3, #2
    96dc:	9306      	str	r3, [sp, #24]
        JobsCount--;
    96de:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    96e2:	3b01      	subs	r3, #1
    96e4:	f8ad 301e 	strh.w	r3, [sp, #30]
    while (0u < JobsCount)
    96e8:	f8bd 301e 	ldrh.w	r3, [sp, #30]
    96ec:	2b00      	cmp	r3, #0
    96ee:	d188      	bne.n	9602 <Spi_SyncJobsTranfer+0x1e>
    } /* while (JobsCount > 0u) */
    return Status;
    96f0:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    96f4:	4618      	mov	r0, r3
    96f6:	b009      	add	sp, #36	; 0x24
    96f8:	f85d fb04 	ldr.w	pc, [sp], #4
    96fc:	1fff8df8 	.word	0x1fff8df8
    9700:	1fff8df0 	.word	0x1fff8df0
    9704:	1fff8de8 	.word	0x1fff8de8

00009708 <Spi_InitChannelsJobsSeqsState>:
*/
static void Spi_InitChannelsJobsSeqsState
    (
        uint32 SpiCoreID      
    )
{
    9708:	b088      	sub	sp, #32
    970a:	9001      	str	r0, [sp, #4]
#endif
    const Spi_ChannelConfigType *ChannelConfig;
    const Spi_JobConfigType *JobConfig;
    const Spi_SequenceConfigType *SequenceConfig;
    
    for (Channel = 0u;
    970c:	2300      	movs	r3, #0
    970e:	9307      	str	r3, [sp, #28]
    9710:	e034      	b.n	977c <Spi_InitChannelsJobsSeqsState+0x74>
        Channel <= (uint32)(Spi_apxSpiConfigPtr[SpiCoreID]->SpiMaxChannel);
        Channel++)
    {
        ChannelConfig = Spi_apxSpiConfigPtr[SpiCoreID]->ChannelConfig[Channel].ChannelCfg;
    9712:	4a4a      	ldr	r2, [pc, #296]	; (983c <Spi_InitChannelsJobsSeqsState+0x134>)
    9714:	9b01      	ldr	r3, [sp, #4]
    9716:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    971a:	68da      	ldr	r2, [r3, #12]
    971c:	9b07      	ldr	r3, [sp, #28]
    971e:	009b      	lsls	r3, r3, #2
    9720:	4413      	add	r3, r2
    9722:	681b      	ldr	r3, [r3, #0]
    9724:	9302      	str	r3, [sp, #8]
        /* Check which channel has assigned for current core */
        if((NULL_PTR != ChannelConfig) && (SpiCoreID == ChannelConfig->SpiCoreUse))
    9726:	9b02      	ldr	r3, [sp, #8]
    9728:	2b00      	cmp	r3, #0
    972a:	d024      	beq.n	9776 <Spi_InitChannelsJobsSeqsState+0x6e>
    972c:	9b02      	ldr	r3, [sp, #8]
    972e:	695b      	ldr	r3, [r3, #20]
    9730:	9a01      	ldr	r2, [sp, #4]
    9732:	429a      	cmp	r2, r3
    9734:	d11f      	bne.n	9776 <Spi_InitChannelsJobsSeqsState+0x6e>
        {
            /* Check if configured buffers are External (EB) */
            if (EB == ChannelConfig->BufferType)
    9736:	9b02      	ldr	r3, [sp, #8]
    9738:	681b      	ldr	r3, [r3, #0]
    973a:	2b01      	cmp	r3, #1
    973c:	d10e      	bne.n	975c <Spi_InitChannelsJobsSeqsState+0x54>
            {
                /* Initialize all buffers */
                ChannelConfig->BufferDescriptor->ExternalBufferTX = NULL_PTR;
    973e:	9b02      	ldr	r3, [sp, #8]
    9740:	691b      	ldr	r3, [r3, #16]
    9742:	2200      	movs	r2, #0
    9744:	601a      	str	r2, [r3, #0]
                ChannelConfig->BufferDescriptor->BufferRX = NULL_PTR;
    9746:	9b02      	ldr	r3, [sp, #8]
    9748:	691b      	ldr	r3, [r3, #16]
    974a:	2200      	movs	r2, #0
    974c:	609a      	str	r2, [r3, #8]
    
                /* Channel length is zero for unconfigured external buffers */
                Spi_axSpiChannelState[Channel].Length = (Spi_NumberOfDataType) 0;
    974e:	4a3c      	ldr	r2, [pc, #240]	; (9840 <Spi_InitChannelsJobsSeqsState+0x138>)
    9750:	9b07      	ldr	r3, [sp, #28]
    9752:	009b      	lsls	r3, r3, #2
    9754:	4413      	add	r3, r2
    9756:	2200      	movs	r2, #0
    9758:	805a      	strh	r2, [r3, #2]
    975a:	e007      	b.n	976c <Spi_InitChannelsJobsSeqsState+0x64>
            }
            else
            {
                /* Setup channel length according to configuration */
                Spi_axSpiChannelState[Channel].Length = ChannelConfig->Length;
    975c:	9b02      	ldr	r3, [sp, #8]
    975e:	8999      	ldrh	r1, [r3, #12]
    9760:	4a37      	ldr	r2, [pc, #220]	; (9840 <Spi_InitChannelsJobsSeqsState+0x138>)
    9762:	9b07      	ldr	r3, [sp, #28]
    9764:	009b      	lsls	r3, r3, #2
    9766:	4413      	add	r3, r2
    9768:	460a      	mov	r2, r1
    976a:	805a      	strh	r2, [r3, #2]
            }
            Spi_axSpiChannelState[Channel].Flags = SPI_CHANNEL_FLAG_TX_DEFAULT_U8;
    976c:	4a34      	ldr	r2, [pc, #208]	; (9840 <Spi_InitChannelsJobsSeqsState+0x138>)
    976e:	9b07      	ldr	r3, [sp, #28]
    9770:	2101      	movs	r1, #1
    9772:	f802 1023 	strb.w	r1, [r2, r3, lsl #2]
        Channel++)
    9776:	9b07      	ldr	r3, [sp, #28]
    9778:	3301      	adds	r3, #1
    977a:	9307      	str	r3, [sp, #28]
        Channel <= (uint32)(Spi_apxSpiConfigPtr[SpiCoreID]->SpiMaxChannel);
    977c:	4a2f      	ldr	r2, [pc, #188]	; (983c <Spi_InitChannelsJobsSeqsState+0x134>)
    977e:	9b01      	ldr	r3, [sp, #4]
    9780:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9784:	789b      	ldrb	r3, [r3, #2]
    9786:	461a      	mov	r2, r3
    for (Channel = 0u;
    9788:	9b07      	ldr	r3, [sp, #28]
    978a:	4293      	cmp	r3, r2
    978c:	d9c1      	bls.n	9712 <Spi_InitChannelsJobsSeqsState+0xa>
        }
    }
    
    /* initialize job results */
    for (Job = 0u;
    978e:	2300      	movs	r3, #0
    9790:	9306      	str	r3, [sp, #24]
    9792:	e019      	b.n	97c8 <Spi_InitChannelsJobsSeqsState+0xc0>
        Job <= (uint32)( Spi_apxSpiConfigPtr[SpiCoreID]->SpiMaxJob);
        Job++)
    {
        JobConfig = Spi_apxSpiConfigPtr[SpiCoreID]->JobConfig[Job].JobCfg;
    9794:	4a29      	ldr	r2, [pc, #164]	; (983c <Spi_InitChannelsJobsSeqsState+0x134>)
    9796:	9b01      	ldr	r3, [sp, #4]
    9798:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    979c:	691a      	ldr	r2, [r3, #16]
    979e:	9b06      	ldr	r3, [sp, #24]
    97a0:	009b      	lsls	r3, r3, #2
    97a2:	4413      	add	r3, r2
    97a4:	681b      	ldr	r3, [r3, #0]
    97a6:	9303      	str	r3, [sp, #12]
        if((NULL_PTR != JobConfig) && (SpiCoreID == JobConfig->SpiCoreUse))
    97a8:	9b03      	ldr	r3, [sp, #12]
    97aa:	2b00      	cmp	r3, #0
    97ac:	d009      	beq.n	97c2 <Spi_InitChannelsJobsSeqsState+0xba>
    97ae:	9b03      	ldr	r3, [sp, #12]
    97b0:	695b      	ldr	r3, [r3, #20]
    97b2:	9a01      	ldr	r2, [sp, #4]
    97b4:	429a      	cmp	r2, r3
    97b6:	d104      	bne.n	97c2 <Spi_InitChannelsJobsSeqsState+0xba>
        {
            Spi_axSpiJobState[Job].Result = SPI_JOB_OK;
    97b8:	4a22      	ldr	r2, [pc, #136]	; (9844 <Spi_InitChannelsJobsSeqsState+0x13c>)
    97ba:	9b06      	ldr	r3, [sp, #24]
    97bc:	2100      	movs	r1, #0
    97be:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        Job++)
    97c2:	9b06      	ldr	r3, [sp, #24]
    97c4:	3301      	adds	r3, #1
    97c6:	9306      	str	r3, [sp, #24]
        Job <= (uint32)( Spi_apxSpiConfigPtr[SpiCoreID]->SpiMaxJob);
    97c8:	4a1c      	ldr	r2, [pc, #112]	; (983c <Spi_InitChannelsJobsSeqsState+0x134>)
    97ca:	9b01      	ldr	r3, [sp, #4]
    97cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    97d0:	889b      	ldrh	r3, [r3, #4]
    97d2:	461a      	mov	r2, r3
    for (Job = 0u;
    97d4:	9b06      	ldr	r3, [sp, #24]
    97d6:	4293      	cmp	r3, r2
    97d8:	d9dc      	bls.n	9794 <Spi_InitChannelsJobsSeqsState+0x8c>
            Spi_axSpiJobState[Job].AsyncCrtSequenceState = NULL_PTR;
        #endif
        }
    }
    
    for (Sequence = 0u;
    97da:	2300      	movs	r3, #0
    97dc:	9305      	str	r3, [sp, #20]
    97de:	e01f      	b.n	9820 <Spi_InitChannelsJobsSeqsState+0x118>
        Sequence <= (uint32)(Spi_apxSpiConfigPtr[SpiCoreID]->SpiMaxSequence);
        Sequence++)
    {
        SequenceConfig = Spi_apxSpiConfigPtr[SpiCoreID]->SequenceConfig[Sequence].SeqConfig;
    97e0:	4a16      	ldr	r2, [pc, #88]	; (983c <Spi_InitChannelsJobsSeqsState+0x134>)
    97e2:	9b01      	ldr	r3, [sp, #4]
    97e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    97e8:	695a      	ldr	r2, [r3, #20]
    97ea:	9b05      	ldr	r3, [sp, #20]
    97ec:	009b      	lsls	r3, r3, #2
    97ee:	4413      	add	r3, r2
    97f0:	681b      	ldr	r3, [r3, #0]
    97f2:	9304      	str	r3, [sp, #16]
        if ((NULL_PTR != SequenceConfig) && (SpiCoreID == SequenceConfig->SpiCoreUse))
    97f4:	9b04      	ldr	r3, [sp, #16]
    97f6:	2b00      	cmp	r3, #0
    97f8:	d00f      	beq.n	981a <Spi_InitChannelsJobsSeqsState+0x112>
    97fa:	9b04      	ldr	r3, [sp, #16]
    97fc:	685b      	ldr	r3, [r3, #4]
    97fe:	9a01      	ldr	r2, [sp, #4]
    9800:	429a      	cmp	r2, r3
    9802:	d10a      	bne.n	981a <Spi_InitChannelsJobsSeqsState+0x112>
            SequenceConfig = Spi_apxSpiConfigPtr[SpiCoreID]->SequenceConfig[Sequence].SeqConfig;
            Spi_axSpiSequenceState[Sequence].Sequence = SequenceConfig;
            #endif
    
            /* initialize sequence results */
            Spi_axSpiSequenceState[Sequence].Result = SPI_SEQ_OK;
    9804:	4a10      	ldr	r2, [pc, #64]	; (9848 <Spi_InitChannelsJobsSeqsState+0x140>)
    9806:	9b05      	ldr	r3, [sp, #20]
    9808:	2100      	movs	r1, #0
    980a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
            /* SPI135: Spi_SyncTransmit() must fail if an other sync transmission
                    is ongoing.*/
            /* mark all HW units as used by the sync transmission, in order to
                force the mutual exclusion of Spi_SyncTransmit() calls */
    
            Spi_au32SpiSeqUsedHWUnits[Sequence] = 0xFFFFFFFFU;
    980e:	4a0f      	ldr	r2, [pc, #60]	; (984c <Spi_InitChannelsJobsSeqsState+0x144>)
    9810:	9b05      	ldr	r3, [sp, #20]
    9812:	f04f 31ff 	mov.w	r1, #4294967295
    9816:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        Sequence++)
    981a:	9b05      	ldr	r3, [sp, #20]
    981c:	3301      	adds	r3, #1
    981e:	9305      	str	r3, [sp, #20]
        Sequence <= (uint32)(Spi_apxSpiConfigPtr[SpiCoreID]->SpiMaxSequence);
    9820:	4a06      	ldr	r2, [pc, #24]	; (983c <Spi_InitChannelsJobsSeqsState+0x134>)
    9822:	9b01      	ldr	r3, [sp, #4]
    9824:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9828:	799b      	ldrb	r3, [r3, #6]
    982a:	461a      	mov	r2, r3
    for (Sequence = 0u;
    982c:	9b05      	ldr	r3, [sp, #20]
    982e:	4293      	cmp	r3, r2
    9830:	d9d6      	bls.n	97e0 <Spi_InitChannelsJobsSeqsState+0xd8>
        else
        {
            /* Do nothing */
        }
    }
}
    9832:	bf00      	nop
    9834:	bf00      	nop
    9836:	b008      	add	sp, #32
    9838:	4770      	bx	lr
    983a:	bf00      	nop
    983c:	1fff8df0 	.word	0x1fff8df0
    9840:	1fff8dfc 	.word	0x1fff8dfc
    9844:	1fff8df8 	.word	0x1fff8df8
    9848:	1fff8df4 	.word	0x1fff8df4
    984c:	1fff8e04 	.word	0x1fff8e04

00009850 <Spi_GetStatusAsyncCheckHwBusy>:
*/
static Spi_StatusType Spi_GetStatusAsyncCheckHwBusy
    (
        uint32 SpiCoreID
    )
{
    9850:	b084      	sub	sp, #16
    9852:	9001      	str	r0, [sp, #4]
    Spi_StatusType StatusFlag = SPI_IDLE;
    9854:	2301      	movs	r3, #1
    9856:	9303      	str	r3, [sp, #12]
    Spi_HWUnitType HWUnit;
    
    for (HWUnit = 0u; HWUnit < (Spi_HWUnitType)SPI_MAX_HWUNIT; HWUnit++)
    9858:	2300      	movs	r3, #0
    985a:	f88d 300b 	strb.w	r3, [sp, #11]
    985e:	e028      	b.n	98b2 <Spi_GetStatusAsyncCheckHwBusy+0x62>
    {
        if ((NULL_PTR != Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig) &&
    9860:	4a18      	ldr	r2, [pc, #96]	; (98c4 <Spi_GetStatusAsyncCheckHwBusy+0x74>)
    9862:	9b01      	ldr	r3, [sp, #4]
    9864:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9868:	69da      	ldr	r2, [r3, #28]
    986a:	f89d 300b 	ldrb.w	r3, [sp, #11]
    986e:	009b      	lsls	r3, r3, #2
    9870:	4413      	add	r3, r2
    9872:	681b      	ldr	r3, [r3, #0]
    9874:	2b00      	cmp	r3, #0
    9876:	d017      	beq.n	98a8 <Spi_GetStatusAsyncCheckHwBusy+0x58>
            (SpiCoreID == Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig->SpiCoreUse)
    9878:	4a12      	ldr	r2, [pc, #72]	; (98c4 <Spi_GetStatusAsyncCheckHwBusy+0x74>)
    987a:	9b01      	ldr	r3, [sp, #4]
    987c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9880:	69da      	ldr	r2, [r3, #28]
    9882:	f89d 300b 	ldrb.w	r3, [sp, #11]
    9886:	009b      	lsls	r3, r3, #2
    9888:	4413      	add	r3, r2
    988a:	681b      	ldr	r3, [r3, #0]
    988c:	689b      	ldr	r3, [r3, #8]
        if ((NULL_PTR != Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig) &&
    988e:	9a01      	ldr	r2, [sp, #4]
    9890:	429a      	cmp	r2, r3
    9892:	d109      	bne.n	98a8 <Spi_GetStatusAsyncCheckHwBusy+0x58>
           )
        {
            if (SPI_BUSY == Spi_axSpiHwUnitQueueArray[HWUnit].Status)
    9894:	f89d 300b 	ldrb.w	r3, [sp, #11]
    9898:	4a0b      	ldr	r2, [pc, #44]	; (98c8 <Spi_GetStatusAsyncCheckHwBusy+0x78>)
    989a:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    989e:	2b02      	cmp	r3, #2
    98a0:	d102      	bne.n	98a8 <Spi_GetStatusAsyncCheckHwBusy+0x58>
            {
                StatusFlag = SPI_BUSY;
    98a2:	2302      	movs	r3, #2
    98a4:	9303      	str	r3, [sp, #12]
                break;
    98a6:	e008      	b.n	98ba <Spi_GetStatusAsyncCheckHwBusy+0x6a>
    for (HWUnit = 0u; HWUnit < (Spi_HWUnitType)SPI_MAX_HWUNIT; HWUnit++)
    98a8:	f89d 300b 	ldrb.w	r3, [sp, #11]
    98ac:	3301      	adds	r3, #1
    98ae:	f88d 300b 	strb.w	r3, [sp, #11]
    98b2:	f89d 300b 	ldrb.w	r3, [sp, #11]
    98b6:	2b00      	cmp	r3, #0
    98b8:	d0d2      	beq.n	9860 <Spi_GetStatusAsyncCheckHwBusy+0x10>
        else
        {
            /* Do nothing */
        }
    }
    return StatusFlag;
    98ba:	9b03      	ldr	r3, [sp, #12]
}
    98bc:	4618      	mov	r0, r3
    98be:	b004      	add	sp, #16
    98c0:	4770      	bx	lr
    98c2:	bf00      	nop
    98c4:	1fff8df0 	.word	0x1fff8df0
    98c8:	1fff8de8 	.word	0x1fff8de8

000098cc <Spi_GetVersionInfo>:
/** @implements Spi_GetVersionInfo_Activity */
void Spi_GetVersionInfo 
    (
        Std_VersionInfoType *versioninfo
    )
{
    98cc:	b082      	sub	sp, #8
    98ce:	9001      	str	r0, [sp, #4]
        (void)Det_ReportError((uint16)SPI_MODULE_ID,(uint8)0,SPI_GETVERSIONINFO_ID,SPI_E_PARAM_POINTER);
    }
    else
    {
#endif /* SPI_DEV_ERROR_DETECT == STD_ON */
    versioninfo->vendorID = (uint16)SPI_VENDOR_ID;
    98d0:	9b01      	ldr	r3, [sp, #4]
    98d2:	222b      	movs	r2, #43	; 0x2b
    98d4:	801a      	strh	r2, [r3, #0]
    versioninfo->moduleID = (uint8)SPI_MODULE_ID;
    98d6:	9b01      	ldr	r3, [sp, #4]
    98d8:	2253      	movs	r2, #83	; 0x53
    98da:	805a      	strh	r2, [r3, #2]
    versioninfo->sw_major_version = (uint8)SPI_SW_MAJOR_VERSION;
    98dc:	9b01      	ldr	r3, [sp, #4]
    98de:	2202      	movs	r2, #2
    98e0:	711a      	strb	r2, [r3, #4]
    versioninfo->sw_minor_version = (uint8)SPI_SW_MINOR_VERSION;
    98e2:	9b01      	ldr	r3, [sp, #4]
    98e4:	2200      	movs	r2, #0
    98e6:	715a      	strb	r2, [r3, #5]
    versioninfo->sw_patch_version = (uint8)SPI_SW_PATCH_VERSION;
    98e8:	9b01      	ldr	r3, [sp, #4]
    98ea:	2200      	movs	r2, #0
    98ec:	719a      	strb	r2, [r3, #6]
#if(SPI_DEV_ERROR_DETECT == STD_ON)
    }
#endif /* SPI_DEV_ERROR_DETECT == STD_ON */
}
    98ee:	bf00      	nop
    98f0:	b002      	add	sp, #8
    98f2:	4770      	bx	lr

000098f4 <Spi_Init>:
/** @implements Spi_Init_Activity */
void Spi_Init
    (
        const Spi_ConfigType *ConfigPtr
    )
{
    98f4:	b500      	push	{lr}
    98f6:	b085      	sub	sp, #20
    98f8:	9001      	str	r0, [sp, #4]
    Spi_HWUnitType HWUnit;
    uint32 SpiCoreID;
    Std_ReturnType CheckStatus = (Std_ReturnType)E_OK;
    98fa:	2300      	movs	r3, #0
    98fc:	f88d 300e 	strb.w	r3, [sp, #14]

    SpiCoreID = Spi_GetCoreID;
    9900:	2300      	movs	r3, #0
    9902:	9302      	str	r3, [sp, #8]
    CheckStatus = Spi_InitCheckDemError(SpiCoreID, ConfigPtr);
    if ((Std_ReturnType)E_OK == CheckStatus) 
    {
#endif /*(SPI_DEV_ERROR_DETECT == STD_ON)*/

    CheckStatus = Spi_CheckInit(ConfigPtr, SpiCoreID);
    9904:	9902      	ldr	r1, [sp, #8]
    9906:	9801      	ldr	r0, [sp, #4]
    9908:	f7ff fe44 	bl	9594 <Spi_CheckInit>
    990c:	4603      	mov	r3, r0
    990e:	f88d 300e 	strb.w	r3, [sp, #14]

    if((Std_ReturnType)E_OK == CheckStatus )
    9912:	f89d 300e 	ldrb.w	r3, [sp, #14]
    9916:	2b00      	cmp	r3, #0
    9918:	d144      	bne.n	99a4 <Spi_Init+0xb0>
    {
    #if (SPI_PRECOMPILE_SUPPORT == STD_OFF)
        Spi_apxSpiConfigPtr[SpiCoreID] = ConfigPtr;
    991a:	4924      	ldr	r1, [pc, #144]	; (99ac <Spi_Init+0xb8>)
    991c:	9b02      	ldr	r3, [sp, #8]
    991e:	9a01      	ldr	r2, [sp, #4]
    9920:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    #else /* (SPI_CONFIG_VARIANT == SPI_VARIANT_PRECOMPILE) */
        Spi_apxSpiConfigPtr[SpiCoreID] = Spi_PBCfgVariantPredefined[SpiCoreID];
    #endif /* (SPI_PRECOMPILE_SUPPORT == STD_OFF) */
    /* Initiate Channels, Jobs, Sequences state */
    Spi_InitChannelsJobsSeqsState(SpiCoreID);
    9924:	9802      	ldr	r0, [sp, #8]
    9926:	f7ff feef 	bl	9708 <Spi_InitChannelsJobsSeqsState>
        
        /* initialize all physical HWUnits */
        for (HWUnit = (Spi_HWUnitType) 0;
    992a:	2300      	movs	r3, #0
    992c:	f88d 300f 	strb.w	r3, [sp, #15]
    9930:	e034      	b.n	999c <Spi_Init+0xa8>
            HWUnit < (Spi_HWUnitType) SPI_MAX_HWUNIT;
            HWUnit++)
        {
            if((NULL_PTR != Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig) &&
    9932:	4a1e      	ldr	r2, [pc, #120]	; (99ac <Spi_Init+0xb8>)
    9934:	9b02      	ldr	r3, [sp, #8]
    9936:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    993a:	69da      	ldr	r2, [r3, #28]
    993c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    9940:	009b      	lsls	r3, r3, #2
    9942:	4413      	add	r3, r2
    9944:	681b      	ldr	r3, [r3, #0]
    9946:	2b00      	cmp	r3, #0
    9948:	d023      	beq.n	9992 <Spi_Init+0x9e>
               (SpiCoreID == Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig->SpiCoreUse)
    994a:	4a18      	ldr	r2, [pc, #96]	; (99ac <Spi_Init+0xb8>)
    994c:	9b02      	ldr	r3, [sp, #8]
    994e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9952:	69da      	ldr	r2, [r3, #28]
    9954:	f89d 300f 	ldrb.w	r3, [sp, #15]
    9958:	009b      	lsls	r3, r3, #2
    995a:	4413      	add	r3, r2
    995c:	681b      	ldr	r3, [r3, #0]
    995e:	689b      	ldr	r3, [r3, #8]
            if((NULL_PTR != Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig) &&
    9960:	9a02      	ldr	r2, [sp, #8]
    9962:	429a      	cmp	r2, r3
    9964:	d115      	bne.n	9992 <Spi_Init+0x9e>
              )
            {
                Spi_Ipw_Init(HWUnit, Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig);
    9966:	4a11      	ldr	r2, [pc, #68]	; (99ac <Spi_Init+0xb8>)
    9968:	9b02      	ldr	r3, [sp, #8]
    996a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    996e:	69da      	ldr	r2, [r3, #28]
    9970:	f89d 300f 	ldrb.w	r3, [sp, #15]
    9974:	009b      	lsls	r3, r3, #2
    9976:	4413      	add	r3, r2
    9978:	681a      	ldr	r2, [r3, #0]
    997a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    997e:	4611      	mov	r1, r2
    9980:	4618      	mov	r0, r3
    9982:	f000 fa8c 	bl	9e9e <Spi_Ipw_Init>

#if ((SPI_LEVEL_DELIVERED == SPI_LEVEL1) || (SPI_LEVEL_DELIVERED == SPI_LEVEL2))
                /* initialize the Job lists => no scheduled job for the unit */
                Spi_InitJobsList(HWUnit);
#endif
                Spi_axSpiHwUnitQueueArray[HWUnit].Status = SPI_IDLE;
    9986:	f89d 300f 	ldrb.w	r3, [sp, #15]
    998a:	4a09      	ldr	r2, [pc, #36]	; (99b0 <Spi_Init+0xbc>)
    998c:	2101      	movs	r1, #1
    998e:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
            HWUnit++)
    9992:	f89d 300f 	ldrb.w	r3, [sp, #15]
    9996:	3301      	adds	r3, #1
    9998:	f88d 300f 	strb.w	r3, [sp, #15]
        for (HWUnit = (Spi_HWUnitType) 0;
    999c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    99a0:	2b00      	cmp	r3, #0
    99a2:	d0c6      	beq.n	9932 <Spi_Init+0x3e>
    }

#if (SPI_DEV_ERROR_DETECT == STD_ON)
    }
#endif /*(SPI_DEV_ERROR_DETECT == STD_ON)*/
}
    99a4:	bf00      	nop
    99a6:	b005      	add	sp, #20
    99a8:	f85d fb04 	ldr.w	pc, [sp], #4
    99ac:	1fff8df0 	.word	0x1fff8df0
    99b0:	1fff8de8 	.word	0x1fff8de8

000099b4 <Spi_DeInit>:
*       if SPI_DEV_ERROR_DETECT is STD_ON.
*
* @implements Spi_DeInit_Activity
*/
Std_ReturnType Spi_DeInit(void)
{
    99b4:	b500      	push	{lr}
    99b6:	b083      	sub	sp, #12
    Std_ReturnType TempExit = (Std_ReturnType)E_OK;
    99b8:	2300      	movs	r3, #0
    99ba:	f88d 3007 	strb.w	r3, [sp, #7]
    Spi_HWUnitType HWUnit;
    uint32 SpiCoreID;

    SpiCoreID = Spi_GetCoreID;
    99be:	2300      	movs	r3, #0
    99c0:	9300      	str	r3, [sp, #0]
    }
    else
    {
#endif
        /* Check if Spi Status is Busy */
        if (SPI_BUSY == Spi_GetStatus())
    99c2:	f000 f8b1 	bl	9b28 <Spi_GetStatus>
    99c6:	4603      	mov	r3, r0
    99c8:	2b02      	cmp	r3, #2
    99ca:	d103      	bne.n	99d4 <Spi_DeInit+0x20>
        {
            TempExit = E_NOT_OK;
    99cc:	2301      	movs	r3, #1
    99ce:	f88d 3007 	strb.w	r3, [sp, #7]
    99d2:	e037      	b.n	9a44 <Spi_DeInit+0x90>
        }
        else
        {
            /* De-initialize all physical HWUnits */
            for (HWUnit = (Spi_HWUnitType) 0;
    99d4:	2300      	movs	r3, #0
    99d6:	f88d 3006 	strb.w	r3, [sp, #6]
    99da:	e02a      	b.n	9a32 <Spi_DeInit+0x7e>
                 HWUnit < (Spi_HWUnitType) SPI_MAX_HWUNIT;
                 HWUnit++)
            {
                if ((NULL_PTR != Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig) &&
    99dc:	4a1c      	ldr	r2, [pc, #112]	; (9a50 <Spi_DeInit+0x9c>)
    99de:	9b00      	ldr	r3, [sp, #0]
    99e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    99e4:	69da      	ldr	r2, [r3, #28]
    99e6:	f89d 3006 	ldrb.w	r3, [sp, #6]
    99ea:	009b      	lsls	r3, r3, #2
    99ec:	4413      	add	r3, r2
    99ee:	681b      	ldr	r3, [r3, #0]
    99f0:	2b00      	cmp	r3, #0
    99f2:	d019      	beq.n	9a28 <Spi_DeInit+0x74>
                    (SpiCoreID == Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig->SpiCoreUse)
    99f4:	4a16      	ldr	r2, [pc, #88]	; (9a50 <Spi_DeInit+0x9c>)
    99f6:	9b00      	ldr	r3, [sp, #0]
    99f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    99fc:	69da      	ldr	r2, [r3, #28]
    99fe:	f89d 3006 	ldrb.w	r3, [sp, #6]
    9a02:	009b      	lsls	r3, r3, #2
    9a04:	4413      	add	r3, r2
    9a06:	681b      	ldr	r3, [r3, #0]
    9a08:	689b      	ldr	r3, [r3, #8]
                if ((NULL_PTR != Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig) &&
    9a0a:	9a00      	ldr	r2, [sp, #0]
    9a0c:	429a      	cmp	r2, r3
    9a0e:	d10b      	bne.n	9a28 <Spi_DeInit+0x74>
                   )
                {
                    Spi_Ipw_DeInit(HWUnit, SpiCoreID);
    9a10:	f89d 3006 	ldrb.w	r3, [sp, #6]
    9a14:	9900      	ldr	r1, [sp, #0]
    9a16:	4618      	mov	r0, r3
    9a18:	f000 fa54 	bl	9ec4 <Spi_Ipw_DeInit>
    
                    Spi_axSpiHwUnitQueueArray[HWUnit].Status = SPI_UNINIT;
    9a1c:	f89d 3006 	ldrb.w	r3, [sp, #6]
    9a20:	4a0c      	ldr	r2, [pc, #48]	; (9a54 <Spi_DeInit+0xa0>)
    9a22:	2100      	movs	r1, #0
    9a24:	f842 1033 	str.w	r1, [r2, r3, lsl #3]
                 HWUnit++)
    9a28:	f89d 3006 	ldrb.w	r3, [sp, #6]
    9a2c:	3301      	adds	r3, #1
    9a2e:	f88d 3006 	strb.w	r3, [sp, #6]
            for (HWUnit = (Spi_HWUnitType) 0;
    9a32:	f89d 3006 	ldrb.w	r3, [sp, #6]
    9a36:	2b00      	cmp	r3, #0
    9a38:	d0d0      	beq.n	99dc <Spi_DeInit+0x28>
                {
                    /* Do nothing */
                }
            }
            /* Reset configuration pointer */
            Spi_apxSpiConfigPtr[SpiCoreID] = NULL_PTR;
    9a3a:	4a05      	ldr	r2, [pc, #20]	; (9a50 <Spi_DeInit+0x9c>)
    9a3c:	9b00      	ldr	r3, [sp, #0]
    9a3e:	2100      	movs	r1, #0
    9a40:	f842 1023 	str.w	r1, [r2, r3, lsl #2]

#if (SPI_DEV_ERROR_DETECT == STD_ON)
    }
#endif

    return TempExit;
    9a44:	f89d 3007 	ldrb.w	r3, [sp, #7]
}
    9a48:	4618      	mov	r0, r3
    9a4a:	b003      	add	sp, #12
    9a4c:	f85d fb04 	ldr.w	pc, [sp], #4
    9a50:	1fff8df0 	.word	0x1fff8df0
    9a54:	1fff8de8 	.word	0x1fff8de8

00009a58 <Spi_SetupEB>:
        Spi_ChannelType Channel,
        const Spi_DataBufferType  *SrcDataBufferPtr,
        Spi_DataBufferType *DesDataBufferPtr,
        Spi_NumberOfDataType Length
    )
{
    9a58:	b500      	push	{lr}
    9a5a:	b089      	sub	sp, #36	; 0x24
    9a5c:	9102      	str	r1, [sp, #8]
    9a5e:	9201      	str	r2, [sp, #4]
    9a60:	461a      	mov	r2, r3
    9a62:	4603      	mov	r3, r0
    9a64:	f88d 300f 	strb.w	r3, [sp, #15]
    9a68:	4613      	mov	r3, r2
    9a6a:	f8ad 300c 	strh.w	r3, [sp, #12]
    Std_ReturnType Status = (Std_ReturnType)E_OK;
    9a6e:	2300      	movs	r3, #0
    9a70:	f88d 301f 	strb.w	r3, [sp, #31]
    Spi_ChannelStateType *ChannelState;
    const Spi_ChannelConfigType *ChannelConfig;
    uint32 SpiCoreID;

    /* get current coreID */
    SpiCoreID = Spi_GetCoreID;
    9a74:	2300      	movs	r3, #0
    9a76:	9306      	str	r3, [sp, #24]
        Status = (Std_ReturnType)E_NOT_OK;
    }
    else
    {
#endif
        ChannelState = &Spi_axSpiChannelState[Channel];
    9a78:	f89d 300f 	ldrb.w	r3, [sp, #15]
    9a7c:	009b      	lsls	r3, r3, #2
    9a7e:	4a28      	ldr	r2, [pc, #160]	; (9b20 <Spi_SetupEB+0xc8>)
    9a80:	4413      	add	r3, r2
    9a82:	9305      	str	r3, [sp, #20]
        ChannelConfig = Spi_apxSpiConfigPtr[SpiCoreID]->ChannelConfig[Channel].ChannelCfg;
    9a84:	4a27      	ldr	r2, [pc, #156]	; (9b24 <Spi_SetupEB+0xcc>)
    9a86:	9b06      	ldr	r3, [sp, #24]
    9a88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9a8c:	68da      	ldr	r2, [r3, #12]
    9a8e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    9a92:	009b      	lsls	r3, r3, #2
    9a94:	4413      	add	r3, r2
    9a96:	681b      	ldr	r3, [r3, #0]
    9a98:	9304      	str	r3, [sp, #16]
        /* exit early if this is the wrong buffer type */
        if (IB == ChannelConfig->BufferType)
    9a9a:	9b04      	ldr	r3, [sp, #16]
    9a9c:	681b      	ldr	r3, [r3, #0]
    9a9e:	2b00      	cmp	r3, #0
    9aa0:	d103      	bne.n	9aaa <Spi_SetupEB+0x52>
        {
            /* Call Det_ReportError */
#if (SPI_DEV_ERROR_DETECT == STD_ON)
            (void)Det_ReportError((uint16) SPI_MODULE_ID,(uint8) 0,SPI_SETUPEB_ID,SPI_E_PARAM_CHANNEL);
#endif
            Status = (Std_ReturnType)E_NOT_OK;
    9aa2:	2301      	movs	r3, #1
    9aa4:	f88d 301f 	strb.w	r3, [sp, #31]
    9aa8:	e033      	b.n	9b12 <Spi_SetupEB+0xba>
            /* Length and Framesize - aren't compatible */
            /* If 8 < Framesize =< 16: Length must be divisible by 2 */
            /* If 16 < Framesize =< 32: Length must be divisible by 4 */
            Status = Spi_SetupEbCheckLength(ChannelConfig, Length);
#endif
            SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05();
    9aaa:	f00c fbb3 	bl	16214 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05>
            /* save the new parameters */
            ChannelConfig->BufferDescriptor->ExternalBufferTX = SrcDataBufferPtr;
    9aae:	9b04      	ldr	r3, [sp, #16]
    9ab0:	691b      	ldr	r3, [r3, #16]
    9ab2:	9a02      	ldr	r2, [sp, #8]
    9ab4:	601a      	str	r2, [r3, #0]
            ChannelConfig->BufferDescriptor->BufferRX = DesDataBufferPtr;
    9ab6:	9b04      	ldr	r3, [sp, #16]
    9ab8:	691b      	ldr	r3, [r3, #16]
    9aba:	9a01      	ldr	r2, [sp, #4]
    9abc:	609a      	str	r2, [r3, #8]

            ChannelState->Length = Length;
    9abe:	9b05      	ldr	r3, [sp, #20]
    9ac0:	f8bd 200c 	ldrh.w	r2, [sp, #12]
    9ac4:	805a      	strh	r2, [r3, #2]

            /* if source data pointer is zero, transmit default value */
            if (NULL_PTR == SrcDataBufferPtr)
    9ac6:	9b02      	ldr	r3, [sp, #8]
    9ac8:	2b00      	cmp	r3, #0
    9aca:	d107      	bne.n	9adc <Spi_SetupEB+0x84>
            {
                ChannelState->Flags |= SPI_CHANNEL_FLAG_TX_DEFAULT_U8;
    9acc:	9b05      	ldr	r3, [sp, #20]
    9ace:	781b      	ldrb	r3, [r3, #0]
    9ad0:	f043 0301 	orr.w	r3, r3, #1
    9ad4:	b2da      	uxtb	r2, r3
    9ad6:	9b05      	ldr	r3, [sp, #20]
    9ad8:	701a      	strb	r2, [r3, #0]
    9ada:	e006      	b.n	9aea <Spi_SetupEB+0x92>
            }
            else
            {
                ChannelState->Flags &= (uint8) (~SPI_CHANNEL_FLAG_TX_DEFAULT_U8);
    9adc:	9b05      	ldr	r3, [sp, #20]
    9ade:	781b      	ldrb	r3, [r3, #0]
    9ae0:	f023 0301 	bic.w	r3, r3, #1
    9ae4:	b2da      	uxtb	r2, r3
    9ae6:	9b05      	ldr	r3, [sp, #20]
    9ae8:	701a      	strb	r2, [r3, #0]
            }

            /* if destination data pointer is zero, discard receiving data */
            if (NULL_PTR == DesDataBufferPtr)
    9aea:	9b01      	ldr	r3, [sp, #4]
    9aec:	2b00      	cmp	r3, #0
    9aee:	d107      	bne.n	9b00 <Spi_SetupEB+0xa8>
            {
                ChannelState->Flags |= SPI_CHANNEL_FLAG_RX_DISCARD_U8;
    9af0:	9b05      	ldr	r3, [sp, #20]
    9af2:	781b      	ldrb	r3, [r3, #0]
    9af4:	f043 0302 	orr.w	r3, r3, #2
    9af8:	b2da      	uxtb	r2, r3
    9afa:	9b05      	ldr	r3, [sp, #20]
    9afc:	701a      	strb	r2, [r3, #0]
    9afe:	e006      	b.n	9b0e <Spi_SetupEB+0xb6>
            }
            else
            {
                ChannelState->Flags &= (uint8) (~SPI_CHANNEL_FLAG_RX_DISCARD_U8);
    9b00:	9b05      	ldr	r3, [sp, #20]
    9b02:	781b      	ldrb	r3, [r3, #0]
    9b04:	f023 0302 	bic.w	r3, r3, #2
    9b08:	b2da      	uxtb	r2, r3
    9b0a:	9b05      	ldr	r3, [sp, #20]
    9b0c:	701a      	strb	r2, [r3, #0]
            }
            SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05();
    9b0e:	f00c fbad 	bl	1626c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05>
        }
#if (SPI_DEV_ERROR_DETECT == STD_ON)
    }
#endif

    return Status;
    9b12:	f89d 301f 	ldrb.w	r3, [sp, #31]
}
    9b16:	4618      	mov	r0, r3
    9b18:	b009      	add	sp, #36	; 0x24
    9b1a:	f85d fb04 	ldr.w	pc, [sp], #4
    9b1e:	bf00      	nop
    9b20:	1fff8dfc 	.word	0x1fff8dfc
    9b24:	1fff8df0 	.word	0x1fff8df0

00009b28 <Spi_GetStatus>:
*       if SPI_DEV_ERROR_DETECT is STD_ON.
*
* @implements Spi_GetStatus_Activity
*/
Spi_StatusType Spi_GetStatus(void)
{
    9b28:	b500      	push	{lr}
    9b2a:	b085      	sub	sp, #20
    Spi_StatusType StatusFlag = SPI_IDLE;
    9b2c:	2301      	movs	r3, #1
    9b2e:	9303      	str	r3, [sp, #12]
    Spi_HWUnitType HWUnit;
    uint32 SpiCoreID;
    
    /* Get current coreID */
    SpiCoreID = Spi_GetCoreID;
    9b30:	2300      	movs	r3, #0
    9b32:	9301      	str	r3, [sp, #4]

    if (NULL_PTR == Spi_apxSpiConfigPtr[SpiCoreID])
    9b34:	4a22      	ldr	r2, [pc, #136]	; (9bc0 <Spi_GetStatus+0x98>)
    9b36:	9b01      	ldr	r3, [sp, #4]
    9b38:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9b3c:	2b00      	cmp	r3, #0
    9b3e:	d102      	bne.n	9b46 <Spi_GetStatus+0x1e>
        /* If Development Error Detection is enabled, report error if not */
        /* initialized */
        /* Call Det_ReportError */
        (void)Det_ReportError((uint16) SPI_MODULE_ID,(uint8) 0,SPI_GETSTATUS_ID,SPI_E_UNINIT);
#endif
        StatusFlag = SPI_UNINIT;
    9b40:	2300      	movs	r3, #0
    9b42:	9303      	str	r3, [sp, #12]
    9b44:	e037      	b.n	9bb6 <Spi_GetStatus+0x8e>
    }
    else
    {
        /* The SPI Handler Driver software module shall be busy when any
           HWUnit is busy */
        for (HWUnit = 0u; HWUnit < (Spi_HWUnitType)SPI_MAX_HWUNIT; HWUnit++)
    9b46:	2300      	movs	r3, #0
    9b48:	f88d 300b 	strb.w	r3, [sp, #11]
    9b4c:	e028      	b.n	9ba0 <Spi_GetStatus+0x78>
        {
            if ((NULL_PTR != Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig) &&
    9b4e:	4a1c      	ldr	r2, [pc, #112]	; (9bc0 <Spi_GetStatus+0x98>)
    9b50:	9b01      	ldr	r3, [sp, #4]
    9b52:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9b56:	69da      	ldr	r2, [r3, #28]
    9b58:	f89d 300b 	ldrb.w	r3, [sp, #11]
    9b5c:	009b      	lsls	r3, r3, #2
    9b5e:	4413      	add	r3, r2
    9b60:	681b      	ldr	r3, [r3, #0]
    9b62:	2b00      	cmp	r3, #0
    9b64:	d017      	beq.n	9b96 <Spi_GetStatus+0x6e>
                (SpiCoreID == Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig->SpiCoreUse)
    9b66:	4a16      	ldr	r2, [pc, #88]	; (9bc0 <Spi_GetStatus+0x98>)
    9b68:	9b01      	ldr	r3, [sp, #4]
    9b6a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9b6e:	69da      	ldr	r2, [r3, #28]
    9b70:	f89d 300b 	ldrb.w	r3, [sp, #11]
    9b74:	009b      	lsls	r3, r3, #2
    9b76:	4413      	add	r3, r2
    9b78:	681b      	ldr	r3, [r3, #0]
    9b7a:	689b      	ldr	r3, [r3, #8]
            if ((NULL_PTR != Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig) &&
    9b7c:	9a01      	ldr	r2, [sp, #4]
    9b7e:	429a      	cmp	r2, r3
    9b80:	d109      	bne.n	9b96 <Spi_GetStatus+0x6e>
               )
            {
                if (1u == Spi_au32SpiBusySyncHWUnitsStatus[HWUnit])
    9b82:	f89d 300b 	ldrb.w	r3, [sp, #11]
    9b86:	4a0f      	ldr	r2, [pc, #60]	; (9bc4 <Spi_GetStatus+0x9c>)
    9b88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9b8c:	2b01      	cmp	r3, #1
    9b8e:	d102      	bne.n	9b96 <Spi_GetStatus+0x6e>
                {
                    StatusFlag = SPI_BUSY;
    9b90:	2302      	movs	r3, #2
    9b92:	9303      	str	r3, [sp, #12]
                    break;
    9b94:	e008      	b.n	9ba8 <Spi_GetStatus+0x80>
        for (HWUnit = 0u; HWUnit < (Spi_HWUnitType)SPI_MAX_HWUNIT; HWUnit++)
    9b96:	f89d 300b 	ldrb.w	r3, [sp, #11]
    9b9a:	3301      	adds	r3, #1
    9b9c:	f88d 300b 	strb.w	r3, [sp, #11]
    9ba0:	f89d 300b 	ldrb.w	r3, [sp, #11]
    9ba4:	2b00      	cmp	r3, #0
    9ba6:	d0d2      	beq.n	9b4e <Spi_GetStatus+0x26>
            {
                /* Do nothing */
            }
        }
        /* check for busy HWUnit in async transmissions */
        if (SPI_BUSY != StatusFlag)
    9ba8:	9b03      	ldr	r3, [sp, #12]
    9baa:	2b02      	cmp	r3, #2
    9bac:	d003      	beq.n	9bb6 <Spi_GetStatus+0x8e>
        {
            /* Note: Checking for IsSync attribute for HWUnit is not really needed
                 It is preferable to skip this check in order to have a more compact code
            */
            StatusFlag = Spi_GetStatusAsyncCheckHwBusy(SpiCoreID);
    9bae:	9801      	ldr	r0, [sp, #4]
    9bb0:	f7ff fe4e 	bl	9850 <Spi_GetStatusAsyncCheckHwBusy>
    9bb4:	9003      	str	r0, [sp, #12]
        else
        {
            /* Do notthing */
        }
    }
    return StatusFlag;
    9bb6:	9b03      	ldr	r3, [sp, #12]
}
    9bb8:	4618      	mov	r0, r3
    9bba:	b005      	add	sp, #20
    9bbc:	f85d fb04 	ldr.w	pc, [sp], #4
    9bc0:	1fff8df0 	.word	0x1fff8df0
    9bc4:	1fff8e08 	.word	0x1fff8e08

00009bc8 <Spi_GetJobResult>:
/** @implements Spi_GetJobResult_Activity */
Spi_JobResultType Spi_GetJobResult
    (
        Spi_JobType Job
    )
{
    9bc8:	b084      	sub	sp, #16
    9bca:	4603      	mov	r3, r0
    9bcc:	f8ad 3006 	strh.w	r3, [sp, #6]
        (void)Det_ReportError((uint16) SPI_MODULE_ID,(uint8) 0,SPI_GETJOBRESULT_ID,SPI_E_PARAM_CONFIG);
    }
    else
    {
#endif
        JobResult = Spi_axSpiJobState[Job].Result;
    9bd0:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    9bd4:	4a03      	ldr	r2, [pc, #12]	; (9be4 <Spi_GetJobResult+0x1c>)
    9bd6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9bda:	9303      	str	r3, [sp, #12]
#if (SPI_DEV_ERROR_DETECT == STD_ON)
    }
#endif

    return JobResult;
    9bdc:	9b03      	ldr	r3, [sp, #12]
}
    9bde:	4618      	mov	r0, r3
    9be0:	b004      	add	sp, #16
    9be2:	4770      	bx	lr
    9be4:	1fff8df8 	.word	0x1fff8df8

00009be8 <Spi_GetSequenceResult>:
/** @implements Spi_GetSequenceResult_Activity */
Spi_SeqResultType Spi_GetSequenceResult
    (
        Spi_SequenceType Sequence
    )
{
    9be8:	b084      	sub	sp, #16
    9bea:	4603      	mov	r3, r0
    9bec:	f88d 3007 	strb.w	r3, [sp, #7]
            (void)Det_ReportError((uint16) SPI_MODULE_ID,(uint8) 0,SPI_GETSEQUENCERESULT_ID,SPI_E_PARAM_CONFIG);
        }
        else
        {
#endif
           SequenceResult = Spi_axSpiSequenceState[Sequence].Result;
    9bf0:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9bf4:	4a03      	ldr	r2, [pc, #12]	; (9c04 <Spi_GetSequenceResult+0x1c>)
    9bf6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9bfa:	9303      	str	r3, [sp, #12]
#if (SPI_DEV_ERROR_DETECT == STD_ON)
        }
    }
#endif

    return SequenceResult;
    9bfc:	9b03      	ldr	r3, [sp, #12]
}
    9bfe:	4618      	mov	r0, r3
    9c00:	b004      	add	sp, #16
    9c02:	4770      	bx	lr
    9c04:	1fff8df4 	.word	0x1fff8df4

00009c08 <Spi_SyncTransmit>:
/** @implements Spi_SyncTransmit_Activity */
Std_ReturnType Spi_SyncTransmit
    (
        Spi_SequenceType Sequence
    )
{
    9c08:	b500      	push	{lr}
    9c0a:	b08b      	sub	sp, #44	; 0x2c
    9c0c:	4603      	mov	r3, r0
    9c0e:	f88d 3007 	strb.w	r3, [sp, #7]
    Spi_SequenceStateType *SequenceState;
    Std_ReturnType Status = (Std_ReturnType)E_OK;
    9c12:	2300      	movs	r3, #0
    9c14:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    Spi_JobType Job;
    const Spi_JobConfigType *JobConfig;
    uint32 SpiCoreID;

    /* Get current coreID */
    SpiCoreID = Spi_GetCoreID;
    9c18:	2300      	movs	r3, #0
    9c1a:	9308      	str	r3, [sp, #32]
        Status = Spi_SynctransmitCheckJobsIsValid(SequenceConfig, SpiCoreID);

        if ((Std_ReturnType)E_NOT_OK != Status)
        {
#endif /* (SPI_DEV_ERROR_DETECT == STD_ON) */
            SequenceConfig = Spi_apxSpiConfigPtr[SpiCoreID]->SequenceConfig[Sequence].SeqConfig;
    9c1c:	4a60      	ldr	r2, [pc, #384]	; (9da0 <Spi_SyncTransmit+0x198>)
    9c1e:	9b08      	ldr	r3, [sp, #32]
    9c20:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9c24:	695a      	ldr	r2, [r3, #20]
    9c26:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9c2a:	009b      	lsls	r3, r3, #2
    9c2c:	4413      	add	r3, r2
    9c2e:	681b      	ldr	r3, [r3, #0]
    9c30:	9307      	str	r3, [sp, #28]
            /* Get the number of jobs in the sequence */
            NumJobsInSequence = SequenceConfig->NumJobs;
    9c32:	9b07      	ldr	r3, [sp, #28]
    9c34:	881b      	ldrh	r3, [r3, #0]
    9c36:	f8ad 301a 	strh.w	r3, [sp, #26]

            SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06();
    9c3a:	f00c fb3d 	bl	162b8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06>
            /* check if there are HW units already running */
            for (HWUnit = 0u; HWUnit < (Spi_HWUnitType)SPI_MAX_HWUNIT; HWUnit++)
    9c3e:	2300      	movs	r3, #0
    9c40:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
    9c44:	e017      	b.n	9c76 <Spi_SyncTransmit+0x6e>
            {
                if (0u != ((Spi_au32SpiBusySyncHWUnitsStatus[HWUnit] << HWUnit) & Spi_au32SpiSeqUsedHWUnits[Sequence]))
    9c46:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
    9c4a:	4a56      	ldr	r2, [pc, #344]	; (9da4 <Spi_SyncTransmit+0x19c>)
    9c4c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    9c50:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
    9c54:	409a      	lsls	r2, r3
    9c56:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9c5a:	4953      	ldr	r1, [pc, #332]	; (9da8 <Spi_SyncTransmit+0x1a0>)
    9c5c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    9c60:	4013      	ands	r3, r2
    9c62:	2b00      	cmp	r3, #0
    9c64:	d002      	beq.n	9c6c <Spi_SyncTransmit+0x64>
                {
                    Status = (Std_ReturnType)E_NOT_OK;
    9c66:	2301      	movs	r3, #1
    9c68:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
            for (HWUnit = 0u; HWUnit < (Spi_HWUnitType)SPI_MAX_HWUNIT; HWUnit++)
    9c6c:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
    9c70:	3301      	adds	r3, #1
    9c72:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
    9c76:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
    9c7a:	2b00      	cmp	r3, #0
    9c7c:	d0e3      	beq.n	9c46 <Spi_SyncTransmit+0x3e>
                {
                    /* Do notthing */
                }
            }
            
            if ((Std_ReturnType)E_NOT_OK != Status)
    9c7e:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    9c82:	2b01      	cmp	r3, #1
    9c84:	f000 8083 	beq.w	9d8e <Spi_SyncTransmit+0x186>
            {
                /* Set the sequence as pending */
                SequenceState = &Spi_axSpiSequenceState[Sequence];
    9c88:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9c8c:	009b      	lsls	r3, r3, #2
    9c8e:	4a47      	ldr	r2, [pc, #284]	; (9dac <Spi_SyncTransmit+0x1a4>)
    9c90:	4413      	add	r3, r2
    9c92:	9305      	str	r3, [sp, #20]
                SequenceState->Result = SPI_SEQ_PENDING;
    9c94:	9b05      	ldr	r3, [sp, #20]
    9c96:	2201      	movs	r2, #1
    9c98:	601a      	str	r2, [r3, #0]
                /* set used HW units as busy */
                for (JobIndex = 0u; JobIndex < NumJobsInSequence; JobIndex++)
    9c9a:	2300      	movs	r3, #0
    9c9c:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    9ca0:	e022      	b.n	9ce8 <Spi_SyncTransmit+0xe0>
                {
                    /* Get the job id */
                    Job = SequenceConfig->JobIndexList[JobIndex];
    9ca2:	9b07      	ldr	r3, [sp, #28]
    9ca4:	689a      	ldr	r2, [r3, #8]
    9ca6:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    9caa:	005b      	lsls	r3, r3, #1
    9cac:	4413      	add	r3, r2
    9cae:	881b      	ldrh	r3, [r3, #0]
    9cb0:	f8ad 3012 	strh.w	r3, [sp, #18]
                    JobConfig = Spi_apxSpiConfigPtr[SpiCoreID]->JobConfig[Job].JobCfg;
    9cb4:	4a3a      	ldr	r2, [pc, #232]	; (9da0 <Spi_SyncTransmit+0x198>)
    9cb6:	9b08      	ldr	r3, [sp, #32]
    9cb8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9cbc:	691a      	ldr	r2, [r3, #16]
    9cbe:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    9cc2:	009b      	lsls	r3, r3, #2
    9cc4:	4413      	add	r3, r2
    9cc6:	681b      	ldr	r3, [r3, #0]
    9cc8:	9303      	str	r3, [sp, #12]
                    /* Logical Spi HWUnit */
                    HWUnit = JobConfig->HWUnit;
    9cca:	9b03      	ldr	r3, [sp, #12]
    9ccc:	7f1b      	ldrb	r3, [r3, #28]
    9cce:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
                    Spi_au32SpiBusySyncHWUnitsStatus[HWUnit] = 1u;
    9cd2:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
    9cd6:	4a33      	ldr	r2, [pc, #204]	; (9da4 <Spi_SyncTransmit+0x19c>)
    9cd8:	2101      	movs	r1, #1
    9cda:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                for (JobIndex = 0u; JobIndex < NumJobsInSequence; JobIndex++)
    9cde:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    9ce2:	3301      	adds	r3, #1
    9ce4:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    9ce8:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
    9cec:	f8bd 301a 	ldrh.w	r3, [sp, #26]
    9cf0:	429a      	cmp	r2, r3
    9cf2:	d3d6      	bcc.n	9ca2 <Spi_SyncTransmit+0x9a>
                }
                SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06();
    9cf4:	f00c fb0c 	bl	16310 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06>
                /* Transmit Jobs */
                Status = Spi_SyncJobsTranfer(SequenceConfig, SpiCoreID);
    9cf8:	9908      	ldr	r1, [sp, #32]
    9cfa:	9807      	ldr	r0, [sp, #28]
    9cfc:	f7ff fc72 	bl	95e4 <Spi_SyncJobsTranfer>
    9d00:	4603      	mov	r3, r0
    9d02:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
                
                if ((Std_ReturnType)E_OK == Status)
    9d06:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    9d0a:	2b00      	cmp	r3, #0
    9d0c:	d103      	bne.n	9d16 <Spi_SyncTransmit+0x10e>
                {
                    /* Set the sequence as OK */
                    SequenceState->Result = SPI_SEQ_OK;
    9d0e:	9b05      	ldr	r3, [sp, #20]
    9d10:	2200      	movs	r2, #0
    9d12:	601a      	str	r2, [r3, #0]
    9d14:	e002      	b.n	9d1c <Spi_SyncTransmit+0x114>
#endif
                }
                else
                {
                    /* Set the sequence as FAILED */
                    SequenceState->Result = SPI_SEQ_FAILED;
    9d16:	9b05      	ldr	r3, [sp, #20]
    9d18:	2202      	movs	r2, #2
    9d1a:	601a      	str	r2, [r3, #0]
                    /* Report to DEM */
                    Spi_DemReportStatus(SpiCoreID, DEM_EVENT_STATUS_FAILED);
#endif
                }
                
                SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07();
    9d1c:	f00c fb1e 	bl	1635c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07>
                /* set used HW units as idle */
                for (JobIndex = 0u; JobIndex < NumJobsInSequence; JobIndex++)
    9d20:	2300      	movs	r3, #0
    9d22:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    9d26:	e022      	b.n	9d6e <Spi_SyncTransmit+0x166>
                {
                    /* Get the job id */
                    Job = SequenceConfig->JobIndexList[JobIndex];
    9d28:	9b07      	ldr	r3, [sp, #28]
    9d2a:	689a      	ldr	r2, [r3, #8]
    9d2c:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    9d30:	005b      	lsls	r3, r3, #1
    9d32:	4413      	add	r3, r2
    9d34:	881b      	ldrh	r3, [r3, #0]
    9d36:	f8ad 3012 	strh.w	r3, [sp, #18]
                    JobConfig = Spi_apxSpiConfigPtr[SpiCoreID]->JobConfig[Job].JobCfg;
    9d3a:	4a19      	ldr	r2, [pc, #100]	; (9da0 <Spi_SyncTransmit+0x198>)
    9d3c:	9b08      	ldr	r3, [sp, #32]
    9d3e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9d42:	691a      	ldr	r2, [r3, #16]
    9d44:	f8bd 3012 	ldrh.w	r3, [sp, #18]
    9d48:	009b      	lsls	r3, r3, #2
    9d4a:	4413      	add	r3, r2
    9d4c:	681b      	ldr	r3, [r3, #0]
    9d4e:	9303      	str	r3, [sp, #12]
                    /* Logical Spi HWUnit */
                    HWUnit = JobConfig->HWUnit;
    9d50:	9b03      	ldr	r3, [sp, #12]
    9d52:	7f1b      	ldrb	r3, [r3, #28]
    9d54:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
                    Spi_au32SpiBusySyncHWUnitsStatus[HWUnit] = 0u;
    9d58:	f89d 3026 	ldrb.w	r3, [sp, #38]	; 0x26
    9d5c:	4a11      	ldr	r2, [pc, #68]	; (9da4 <Spi_SyncTransmit+0x19c>)
    9d5e:	2100      	movs	r1, #0
    9d60:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                for (JobIndex = 0u; JobIndex < NumJobsInSequence; JobIndex++)
    9d64:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    9d68:	3301      	adds	r3, #1
    9d6a:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    9d6e:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
    9d72:	f8bd 301a 	ldrh.w	r3, [sp, #26]
    9d76:	429a      	cmp	r2, r3
    9d78:	d3d6      	bcc.n	9d28 <Spi_SyncTransmit+0x120>
                }
                SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07();
    9d7a:	f00c fb1b 	bl	163b4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07>
                
                /* End Sequence Notification */
                if (NULL_PTR != SequenceConfig->EndNotification)
    9d7e:	9b07      	ldr	r3, [sp, #28]
    9d80:	68db      	ldr	r3, [r3, #12]
    9d82:	2b00      	cmp	r3, #0
    9d84:	d005      	beq.n	9d92 <Spi_SyncTransmit+0x18a>
                {
                    SequenceConfig->EndNotification();
    9d86:	9b07      	ldr	r3, [sp, #28]
    9d88:	68db      	ldr	r3, [r3, #12]
    9d8a:	4798      	blx	r3
    9d8c:	e001      	b.n	9d92 <Spi_SyncTransmit+0x18a>
                    /* Do nothing */
                }
            }
            else
            {
                SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06();
    9d8e:	f00c fabf 	bl	16310 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06>
            /* Do nothing */
        }
    }
#endif

    return Status;
    9d92:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
}
    9d96:	4618      	mov	r0, r3
    9d98:	b00b      	add	sp, #44	; 0x2c
    9d9a:	f85d fb04 	ldr.w	pc, [sp], #4
    9d9e:	bf00      	nop
    9da0:	1fff8df0 	.word	0x1fff8df0
    9da4:	1fff8e08 	.word	0x1fff8e08
    9da8:	1fff8e04 	.word	0x1fff8e04
    9dac:	1fff8df4 	.word	0x1fff8df4

00009db0 <Spi_GetHWUnitStatus>:
/** @implements Spi_GetHWUnitStatus_Activity */
Spi_StatusType Spi_GetHWUnitStatus
    (
        Spi_HWUnitType HWUnit
    )
{
    9db0:	b084      	sub	sp, #16
    9db2:	4603      	mov	r3, r0
    9db4:	f88d 3007 	strb.w	r3, [sp, #7]
    Spi_StatusType Status = SPI_UNINIT;
    9db8:	2300      	movs	r3, #0
    9dba:	9303      	str	r3, [sp, #12]
        /* Do nothing */
    }
    else
    {
#endif
        Status = Spi_axSpiHwUnitQueueArray[HWUnit].Status;
    9dbc:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9dc0:	4a03      	ldr	r2, [pc, #12]	; (9dd0 <Spi_GetHWUnitStatus+0x20>)
    9dc2:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    9dc6:	9303      	str	r3, [sp, #12]

#if (SPI_DEV_ERROR_DETECT == STD_ON)
    }
#endif
    return Status;
    9dc8:	9b03      	ldr	r3, [sp, #12]
}
    9dca:	4618      	mov	r0, r3
    9dcc:	b004      	add	sp, #16
    9dce:	4770      	bx	lr
    9dd0:	1fff8de8 	.word	0x1fff8de8

00009dd4 <Spi_Cancel>:
*       undefined state due to cancelling a sequence transmission.
*
*/
/**  @implements Spi_Cancel_Activity */
void Spi_Cancel(Spi_SequenceType Sequence)
{
    9dd4:	b082      	sub	sp, #8
    9dd6:	4603      	mov	r3, r0
    9dd8:	f88d 3007 	strb.w	r3, [sp, #7]
        }
        else
        {
#endif
            /* Set sequence state to Cancel */
            Spi_axSpiSequenceState[Sequence].Result = SPI_SEQ_CANCELLED;
    9ddc:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9de0:	4a03      	ldr	r2, [pc, #12]	; (9df0 <Spi_Cancel+0x1c>)
    9de2:	2103      	movs	r1, #3
    9de4:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
            #endif
#if (SPI_DEV_ERROR_DETECT == STD_ON)
        }
    }
#endif
}
    9de8:	bf00      	nop
    9dea:	b002      	add	sp, #8
    9dec:	4770      	bx	lr
    9dee:	bf00      	nop
    9df0:	1fff8df4 	.word	0x1fff8df4

00009df4 <Spi_MainFunction_Handling>:
                /*Do nothing */
            }
        }
    }
#endif /* #if ( (SPI_LEVEL_DELIVERED == SPI_LEVEL1) || (SPI_LEVEL_DELIVERED == SPI_LEVEL2) ) */
}
    9df4:	bf00      	nop
    9df6:	4770      	bx	lr

00009df8 <Spi_Ipw_SyncTransmitProcess>:
        const Spi_JobConfigType *JobConfig,
        const Spi_ChannelConfigType *ChannelConfig,
        Spi_DataBufferType *RxBuffer,
        const Spi_DataBufferType *TxBuffer
    )
{
    9df8:	b500      	push	{lr}
    9dfa:	b08d      	sub	sp, #52	; 0x34
    9dfc:	9005      	str	r0, [sp, #20]
    9dfe:	9104      	str	r1, [sp, #16]
    9e00:	9203      	str	r2, [sp, #12]
    9e02:	9302      	str	r3, [sp, #8]
    Lpspi_Ip_StatusType Lpspi_spiStatus = LPSPI_IP_STATUS_SUCCESS;
    9e04:	2300      	movs	r3, #0
    9e06:	930b      	str	r3, [sp, #44]	; 0x2c
    const Lpspi_Ip_ExternalDeviceType* LpspiExternalDevice;
#if (SPI_IPW_SPI_FLEXIO_ENABLE == STD_ON)
    Flexio_Spi_Ip_StatusType Flexio_spiStatus = FLEXIO_SPI_IP_STATUS_SUCCESS;
    const Flexio_Spi_Ip_ExternalDeviceType* Flexio_SpiExternalDevice;
#endif
    Std_ReturnType Ipw_Status = (Std_ReturnType)E_OK;
    9e08:	2300      	movs	r3, #0
    9e0a:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
    Spi_NumberOfDataType NumberOfBytes;
    Spi_Ipw_SupportedIpsType IpType = JobConfig->ExternalDeviceConfig->ExDeviceConfig->IpType;
    9e0e:	9b05      	ldr	r3, [sp, #20]
    9e10:	6a1b      	ldr	r3, [r3, #32]
    9e12:	681b      	ldr	r3, [r3, #0]
    9e14:	681b      	ldr	r3, [r3, #0]
    9e16:	9309      	str	r3, [sp, #36]	; 0x24
        HalfDuplexMode = LPSPI_IP_FULL_DUPLEX;
        HalfDuplexModeSupport = FALSE;
    }
#endif
    
    NumberOfBytes = ChannelConfig->ChannelState->Length;
    9e18:	9b04      	ldr	r3, [sp, #16]
    9e1a:	699b      	ldr	r3, [r3, #24]
    9e1c:	885b      	ldrh	r3, [r3, #2]
    9e1e:	f8ad 3022 	strh.w	r3, [sp, #34]	; 0x22
    if (SPI_OVER_LPSPI == IpType)
    9e22:	9b09      	ldr	r3, [sp, #36]	; 0x24
    9e24:	2b00      	cmp	r3, #0
    9e26:	d12e      	bne.n	9e86 <Spi_Ipw_SyncTransmitProcess+0x8e>
    {
        LpspiExternalDevice = JobConfig->ExternalDeviceConfig->ExDeviceConfig->ExternalDeviceConfig.LpspiExternalDeviceConfig;
    9e28:	9b05      	ldr	r3, [sp, #20]
    9e2a:	6a1b      	ldr	r3, [r3, #32]
    9e2c:	681b      	ldr	r3, [r3, #0]
    9e2e:	689b      	ldr	r3, [r3, #8]
    9e30:	9307      	str	r3, [sp, #28]
        Lpspi_spiStatus = Lpspi_Ip_UpdateDefaultTransmitData(LpspiExternalDevice, ChannelConfig->DefaultTransmitValue);
    9e32:	9b04      	ldr	r3, [sp, #16]
    9e34:	689b      	ldr	r3, [r3, #8]
    9e36:	4619      	mov	r1, r3
    9e38:	9807      	ldr	r0, [sp, #28]
    9e3a:	f7ff fadd 	bl	93f8 <Lpspi_Ip_UpdateDefaultTransmitData>
    9e3e:	900b      	str	r0, [sp, #44]	; 0x2c
        if (LPSPI_IP_STATUS_SUCCESS == Lpspi_spiStatus)
    9e40:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    9e42:	2b00      	cmp	r3, #0
    9e44:	d11f      	bne.n	9e86 <Spi_Ipw_SyncTransmitProcess+0x8e>
        {
            Lpspi_spiStatus = Lpspi_Ip_UpdateFrameSize(LpspiExternalDevice, ChannelConfig->FrameSize);
    9e46:	9b04      	ldr	r3, [sp, #16]
    9e48:	791b      	ldrb	r3, [r3, #4]
    9e4a:	b29b      	uxth	r3, r3
    9e4c:	4619      	mov	r1, r3
    9e4e:	9807      	ldr	r0, [sp, #28]
    9e50:	f7ff fa92 	bl	9378 <Lpspi_Ip_UpdateFrameSize>
    9e54:	900b      	str	r0, [sp, #44]	; 0x2c
            if (LPSPI_IP_STATUS_SUCCESS == Lpspi_spiStatus)
    9e56:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    9e58:	2b00      	cmp	r3, #0
    9e5a:	d114      	bne.n	9e86 <Spi_Ipw_SyncTransmitProcess+0x8e>
            {
                Lpspi_spiStatus = Lpspi_Ip_UpdateLsb(LpspiExternalDevice, ChannelConfig->Lsb);
    9e5c:	9b04      	ldr	r3, [sp, #16]
    9e5e:	795b      	ldrb	r3, [r3, #5]
    9e60:	4619      	mov	r1, r3
    9e62:	9807      	ldr	r0, [sp, #28]
    9e64:	f7ff faa8 	bl	93b8 <Lpspi_Ip_UpdateLsb>
    9e68:	900b      	str	r0, [sp, #44]	; 0x2c
                if (LPSPI_IP_STATUS_SUCCESS == Lpspi_spiStatus)
    9e6a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    9e6c:	2b00      	cmp	r3, #0
    9e6e:	d10a      	bne.n	9e86 <Spi_Ipw_SyncTransmitProcess+0x8e>
                        Lpspi_spiStatus = Lpspi_Ip_SyncTransmitHalfDuplex(LpspiExternalDevice, Buffer, NumberOfBytes, HalfDuplexMode, SPI_TIMEOUT_COUNTER_U32);
                    }
                    else
                    #endif
                    {
                        Lpspi_spiStatus = Lpspi_Ip_SyncTransmit(LpspiExternalDevice, (const uint8*)TxBuffer, RxBuffer, NumberOfBytes, SPI_TIMEOUT_COUNTER_U32);
    9e70:	f8bd 3022 	ldrh.w	r3, [sp, #34]	; 0x22
    9e74:	f24c 3250 	movw	r2, #50000	; 0xc350
    9e78:	9200      	str	r2, [sp, #0]
    9e7a:	9a03      	ldr	r2, [sp, #12]
    9e7c:	9902      	ldr	r1, [sp, #8]
    9e7e:	9807      	ldr	r0, [sp, #28]
    9e80:	f7fe fe0a 	bl	8a98 <Lpspi_Ip_SyncTransmit>
    9e84:	900b      	str	r0, [sp, #44]	; 0x2c
            }
        }
    }
    if( (LPSPI_IP_STATUS_SUCCESS != Lpspi_spiStatus) || (FLEXIO_SPI_IP_STATUS_SUCCESS != Flexio_spiStatus))
#else
    if(LPSPI_IP_STATUS_SUCCESS != Lpspi_spiStatus)
    9e86:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    9e88:	2b00      	cmp	r3, #0
    9e8a:	d002      	beq.n	9e92 <Spi_Ipw_SyncTransmitProcess+0x9a>
#endif /*(SPI_IPW_SPI_FLEXIO_ENABLE == STD_ON)*/
    {
        Ipw_Status = (Std_ReturnType)E_NOT_OK;
    9e8c:	2301      	movs	r3, #1
    9e8e:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
    }
    return Ipw_Status;
    9e92:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
}
    9e96:	4618      	mov	r0, r3
    9e98:	b00d      	add	sp, #52	; 0x34
    9e9a:	f85d fb04 	ldr.w	pc, [sp], #4

00009e9e <Spi_Ipw_Init>:
/*==================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/
/* Spi_Ipw_Init */
void Spi_Ipw_Init(const Spi_HWUnitType HWUnitId, const Spi_HWUnitConfigType *HWUnit)
{
    9e9e:	b500      	push	{lr}
    9ea0:	b083      	sub	sp, #12
    9ea2:	4603      	mov	r3, r0
    9ea4:	9100      	str	r1, [sp, #0]
    9ea6:	f88d 3007 	strb.w	r3, [sp, #7]
    if (SPI_OVER_LPSPI == HWUnit->IpType)
    9eaa:	9b00      	ldr	r3, [sp, #0]
    9eac:	681b      	ldr	r3, [r3, #0]
    9eae:	2b00      	cmp	r3, #0
    9eb0:	d104      	bne.n	9ebc <Spi_Ipw_Init+0x1e>
    #if ((SPI_LEVEL_DELIVERED == SPI_LEVEL1) || (SPI_LEVEL_DELIVERED == SPI_LEVEL2))
        Spi_Ipw_au8LpspiHWUnitMapping[HWUnit->Instance] = HWUnitId;
    #else
        (void)HWUnitId;
    #endif
        (void)Lpspi_Ip_Init(HWUnit->IpConfig.LpspiIpConfig);
    9eb2:	9b00      	ldr	r3, [sp, #0]
    9eb4:	68db      	ldr	r3, [r3, #12]
    9eb6:	4618      	mov	r0, r3
    9eb8:	f7fe fd62 	bl	8980 <Lpspi_Ip_Init>
        (void)HWUnitId;
    #endif
        (void)Flexio_Spi_Ip_Init(HWUnit->IpConfig.FlexioSpiIpConfig);
    }
#endif
}
    9ebc:	bf00      	nop
    9ebe:	b003      	add	sp, #12
    9ec0:	f85d fb04 	ldr.w	pc, [sp], #4

00009ec4 <Spi_Ipw_DeInit>:

/* Spi_Ipw_DeInit */
void Spi_Ipw_DeInit(Spi_HWUnitType HWUnit, uint32 SpiCoreID)
{
    9ec4:	b500      	push	{lr}
    9ec6:	b083      	sub	sp, #12
    9ec8:	4603      	mov	r3, r0
    9eca:	9100      	str	r1, [sp, #0]
    9ecc:	f88d 3007 	strb.w	r3, [sp, #7]
    if (SPI_OVER_LPSPI == Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig->IpType)
    9ed0:	4a0f      	ldr	r2, [pc, #60]	; (9f10 <Spi_Ipw_DeInit+0x4c>)
    9ed2:	9b00      	ldr	r3, [sp, #0]
    9ed4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9ed8:	69da      	ldr	r2, [r3, #28]
    9eda:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9ede:	009b      	lsls	r3, r3, #2
    9ee0:	4413      	add	r3, r2
    9ee2:	681b      	ldr	r3, [r3, #0]
    9ee4:	681b      	ldr	r3, [r3, #0]
    9ee6:	2b00      	cmp	r3, #0
    9ee8:	d10d      	bne.n	9f06 <Spi_Ipw_DeInit+0x42>
    {
        (void)Lpspi_Ip_DeInit(Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig->Instance);
    9eea:	4a09      	ldr	r2, [pc, #36]	; (9f10 <Spi_Ipw_DeInit+0x4c>)
    9eec:	9b00      	ldr	r3, [sp, #0]
    9eee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9ef2:	69da      	ldr	r2, [r3, #28]
    9ef4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9ef8:	009b      	lsls	r3, r3, #2
    9efa:	4413      	add	r3, r2
    9efc:	681b      	ldr	r3, [r3, #0]
    9efe:	791b      	ldrb	r3, [r3, #4]
    9f00:	4618      	mov	r0, r3
    9f02:	f7fe fd99 	bl	8a38 <Lpspi_Ip_DeInit>
    else
    {
        (void)Flexio_Spi_Ip_DeInit(Spi_apxSpiConfigPtr[SpiCoreID]->HWUnitConfig[HWUnit].PhyUnitConfig->Instance);
    }
#endif
}
    9f06:	bf00      	nop
    9f08:	b003      	add	sp, #12
    9f0a:	f85d fb04 	ldr.w	pc, [sp], #4
    9f0e:	bf00      	nop
    9f10:	1fff8df0 	.word	0x1fff8df0

00009f14 <Spi_Ipw_SyncTransmit>:

/* Spi_Ipw_SyncTransmit */
#if ( (SPI_LEVEL_DELIVERED == SPI_LEVEL2) || (SPI_LEVEL_DELIVERED == SPI_LEVEL0) )
Std_ReturnType Spi_Ipw_SyncTransmit(const Spi_JobConfigType *JobConfig, uint32 SpiCoreID)
{
    9f14:	b500      	push	{lr}
    9f16:	b08b      	sub	sp, #44	; 0x2c
    9f18:	9001      	str	r0, [sp, #4]
    9f1a:	9100      	str	r1, [sp, #0]

    Std_ReturnType Ipw_Status = (Std_ReturnType)E_OK;
    9f1c:	2300      	movs	r3, #0
    9f1e:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    const Spi_ChannelConfigType *ChannelConfig;
    const Spi_ChannelConfigType *NextChannelConfig;
    Spi_ChannelType ChannelID;
    Spi_ChannelType NumChannelsInJob;
    Spi_ChannelType ChannelIndex;
    Spi_Ipw_SupportedIpsType IpType = JobConfig->ExternalDeviceConfig->ExDeviceConfig->IpType;
    9f22:	9b01      	ldr	r3, [sp, #4]
    9f24:	6a1b      	ldr	r3, [r3, #32]
    9f26:	681b      	ldr	r3, [r3, #0]
    9f28:	681b      	ldr	r3, [r3, #0]
    9f2a:	9306      	str	r3, [sp, #24]
    
    NumChannelsInJob = JobConfig->NumChannels;
    9f2c:	9b01      	ldr	r3, [sp, #4]
    9f2e:	781b      	ldrb	r3, [r3, #0]
    9f30:	f88d 3017 	strb.w	r3, [sp, #23]
    for (ChannelIndex = (Spi_ChannelType)0; ChannelIndex < NumChannelsInJob; ChannelIndex++)
    9f34:	2300      	movs	r3, #0
    9f36:	f88d 301f 	strb.w	r3, [sp, #31]
    9f3a:	e0e6      	b.n	a10a <Spi_Ipw_SyncTransmit+0x1f6>
    {
        ChannelID = JobConfig->ChannelIndexList[ChannelIndex];
    9f3c:	9b01      	ldr	r3, [sp, #4]
    9f3e:	685a      	ldr	r2, [r3, #4]
    9f40:	f89d 301f 	ldrb.w	r3, [sp, #31]
    9f44:	4413      	add	r3, r2
    9f46:	781b      	ldrb	r3, [r3, #0]
    9f48:	f88d 3016 	strb.w	r3, [sp, #22]
        ChannelConfig = Spi_apxSpiConfigPtr[SpiCoreID]->ChannelConfig[ChannelID].ChannelCfg;
    9f4c:	4a75      	ldr	r2, [pc, #468]	; (a124 <Spi_Ipw_SyncTransmit+0x210>)
    9f4e:	9b00      	ldr	r3, [sp, #0]
    9f50:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9f54:	68da      	ldr	r2, [r3, #12]
    9f56:	f89d 3016 	ldrb.w	r3, [sp, #22]
    9f5a:	009b      	lsls	r3, r3, #2
    9f5c:	4413      	add	r3, r2
    9f5e:	681b      	ldr	r3, [r3, #0]
    9f60:	9304      	str	r3, [sp, #16]
        RxBuffer = ChannelConfig->BufferDescriptor->BufferRX;
    9f62:	9b04      	ldr	r3, [sp, #16]
    9f64:	691b      	ldr	r3, [r3, #16]
    9f66:	689b      	ldr	r3, [r3, #8]
    9f68:	9303      	str	r3, [sp, #12]
        if(0u != (ChannelConfig->ChannelState->Flags & SPI_CHANNEL_FLAG_TX_DEFAULT_U8))
    9f6a:	9b04      	ldr	r3, [sp, #16]
    9f6c:	699b      	ldr	r3, [r3, #24]
    9f6e:	781b      	ldrb	r3, [r3, #0]
    9f70:	f003 0301 	and.w	r3, r3, #1
    9f74:	2b00      	cmp	r3, #0
    9f76:	d002      	beq.n	9f7e <Spi_Ipw_SyncTransmit+0x6a>
        {
            TxBuffer = NULL_PTR;
    9f78:	2300      	movs	r3, #0
    9f7a:	9308      	str	r3, [sp, #32]
    9f7c:	e00c      	b.n	9f98 <Spi_Ipw_SyncTransmit+0x84>
        }
        else
        {
            if(EB == ChannelConfig->BufferType)
    9f7e:	9b04      	ldr	r3, [sp, #16]
    9f80:	681b      	ldr	r3, [r3, #0]
    9f82:	2b01      	cmp	r3, #1
    9f84:	d104      	bne.n	9f90 <Spi_Ipw_SyncTransmit+0x7c>
            {
                TxBuffer = ChannelConfig->BufferDescriptor->ExternalBufferTX;
    9f86:	9b04      	ldr	r3, [sp, #16]
    9f88:	691b      	ldr	r3, [r3, #16]
    9f8a:	681b      	ldr	r3, [r3, #0]
    9f8c:	9308      	str	r3, [sp, #32]
    9f8e:	e003      	b.n	9f98 <Spi_Ipw_SyncTransmit+0x84>
            }
            else
            {
                TxBuffer = (const uint8*)(ChannelConfig->BufferDescriptor->InternalBufferTX);
    9f90:	9b04      	ldr	r3, [sp, #16]
    9f92:	691b      	ldr	r3, [r3, #16]
    9f94:	685b      	ldr	r3, [r3, #4]
    9f96:	9308      	str	r3, [sp, #32]
            }
        }
        
        if (SPI_OVER_LPSPI == IpType)
    9f98:	9b06      	ldr	r3, [sp, #24]
    9f9a:	2b00      	cmp	r3, #0
    9f9c:	f040 80a7 	bne.w	a0ee <Spi_Ipw_SyncTransmit+0x1da>
        {
            if(ChannelIndex == (NumChannelsInJob - 1u))
    9fa0:	f89d 201f 	ldrb.w	r2, [sp, #31]
    9fa4:	f89d 3017 	ldrb.w	r3, [sp, #23]
    9fa8:	3b01      	subs	r3, #1
    9faa:	429a      	cmp	r2, r3
    9fac:	d10a      	bne.n	9fc4 <Spi_Ipw_SyncTransmit+0xb0>
            {
                /* Clear CS after current channel */
                Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->KeepCs = FALSE;
    9fae:	9b01      	ldr	r3, [sp, #4]
    9fb0:	6a1b      	ldr	r3, [r3, #32]
    9fb2:	681b      	ldr	r3, [r3, #0]
    9fb4:	791b      	ldrb	r3, [r3, #4]
    9fb6:	461a      	mov	r2, r3
    9fb8:	4b5b      	ldr	r3, [pc, #364]	; (a128 <Spi_Ipw_SyncTransmit+0x214>)
    9fba:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    9fbe:	2200      	movs	r2, #0
    9fc0:	771a      	strb	r2, [r3, #28]
    9fc2:	e07b      	b.n	a0bc <Spi_Ipw_SyncTransmit+0x1a8>
            }
            else
            {
                Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->KeepCs = TRUE;
    9fc4:	9b01      	ldr	r3, [sp, #4]
    9fc6:	6a1b      	ldr	r3, [r3, #32]
    9fc8:	681b      	ldr	r3, [r3, #0]
    9fca:	791b      	ldrb	r3, [r3, #4]
    9fcc:	461a      	mov	r2, r3
    9fce:	4b56      	ldr	r3, [pc, #344]	; (a128 <Spi_Ipw_SyncTransmit+0x214>)
    9fd0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    9fd4:	2201      	movs	r2, #1
    9fd6:	771a      	strb	r2, [r3, #28]
                MCAL_DATA_SYNC_BARRIER();
    9fd8:	f3bf 8f4f 	dsb	sy
                /* update data for next transfer */
                NextChannelConfig = Spi_apxSpiConfigPtr[SpiCoreID]->ChannelConfig[JobConfig->ChannelIndexList[ChannelIndex + 1u]].ChannelCfg;
    9fdc:	4a51      	ldr	r2, [pc, #324]	; (a124 <Spi_Ipw_SyncTransmit+0x210>)
    9fde:	9b00      	ldr	r3, [sp, #0]
    9fe0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    9fe4:	68da      	ldr	r2, [r3, #12]
    9fe6:	9b01      	ldr	r3, [sp, #4]
    9fe8:	6859      	ldr	r1, [r3, #4]
    9fea:	f89d 301f 	ldrb.w	r3, [sp, #31]
    9fee:	3301      	adds	r3, #1
    9ff0:	440b      	add	r3, r1
    9ff2:	781b      	ldrb	r3, [r3, #0]
    9ff4:	009b      	lsls	r3, r3, #2
    9ff6:	4413      	add	r3, r2
    9ff8:	681b      	ldr	r3, [r3, #0]
    9ffa:	9302      	str	r3, [sp, #8]
                MCAL_DATA_SYNC_BARRIER();
    9ffc:	f3bf 8f4f 	dsb	sy
                if(0u != (NextChannelConfig->ChannelState->Flags & SPI_CHANNEL_FLAG_TX_DEFAULT_U8))
    a000:	9b02      	ldr	r3, [sp, #8]
    a002:	699b      	ldr	r3, [r3, #24]
    a004:	781b      	ldrb	r3, [r3, #0]
    a006:	f003 0301 	and.w	r3, r3, #1
    a00a:	2b00      	cmp	r3, #0
    a00c:	d00a      	beq.n	a024 <Spi_Ipw_SyncTransmit+0x110>
                {
                    Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->TxBufferNext = NULL_PTR;
    a00e:	9b01      	ldr	r3, [sp, #4]
    a010:	6a1b      	ldr	r3, [r3, #32]
    a012:	681b      	ldr	r3, [r3, #0]
    a014:	791b      	ldrb	r3, [r3, #4]
    a016:	461a      	mov	r2, r3
    a018:	4b43      	ldr	r3, [pc, #268]	; (a128 <Spi_Ipw_SyncTransmit+0x214>)
    a01a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    a01e:	2200      	movs	r2, #0
    a020:	62da      	str	r2, [r3, #44]	; 0x2c
    a022:	e01c      	b.n	a05e <Spi_Ipw_SyncTransmit+0x14a>
                }
                else
                {
                    if(EB == NextChannelConfig->BufferType)
    a024:	9b02      	ldr	r3, [sp, #8]
    a026:	681b      	ldr	r3, [r3, #0]
    a028:	2b01      	cmp	r3, #1
    a02a:	d10c      	bne.n	a046 <Spi_Ipw_SyncTransmit+0x132>
                    {
                        Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->TxBufferNext = NextChannelConfig->BufferDescriptor->ExternalBufferTX;
    a02c:	9b02      	ldr	r3, [sp, #8]
    a02e:	691a      	ldr	r2, [r3, #16]
    a030:	9b01      	ldr	r3, [sp, #4]
    a032:	6a1b      	ldr	r3, [r3, #32]
    a034:	681b      	ldr	r3, [r3, #0]
    a036:	791b      	ldrb	r3, [r3, #4]
    a038:	4619      	mov	r1, r3
    a03a:	4b3b      	ldr	r3, [pc, #236]	; (a128 <Spi_Ipw_SyncTransmit+0x214>)
    a03c:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    a040:	6812      	ldr	r2, [r2, #0]
    a042:	62da      	str	r2, [r3, #44]	; 0x2c
    a044:	e00b      	b.n	a05e <Spi_Ipw_SyncTransmit+0x14a>
                    }
                    else
                    {
                        Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->TxBufferNext = NextChannelConfig->BufferDescriptor->InternalBufferTX;
    a046:	9b02      	ldr	r3, [sp, #8]
    a048:	691a      	ldr	r2, [r3, #16]
    a04a:	9b01      	ldr	r3, [sp, #4]
    a04c:	6a1b      	ldr	r3, [r3, #32]
    a04e:	681b      	ldr	r3, [r3, #0]
    a050:	791b      	ldrb	r3, [r3, #4]
    a052:	4619      	mov	r1, r3
    a054:	4b34      	ldr	r3, [pc, #208]	; (a128 <Spi_Ipw_SyncTransmit+0x214>)
    a056:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    a05a:	6852      	ldr	r2, [r2, #4]
    a05c:	62da      	str	r2, [r3, #44]	; 0x2c
                    }
                }
                Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->FrameSizeNext = NextChannelConfig->FrameSize;
    a05e:	9b02      	ldr	r3, [sp, #8]
    a060:	791a      	ldrb	r2, [r3, #4]
    a062:	9b01      	ldr	r3, [sp, #4]
    a064:	6a1b      	ldr	r3, [r3, #32]
    a066:	681b      	ldr	r3, [r3, #0]
    a068:	791b      	ldrb	r3, [r3, #4]
    a06a:	4619      	mov	r1, r3
    a06c:	4b2e      	ldr	r3, [pc, #184]	; (a128 <Spi_Ipw_SyncTransmit+0x214>)
    a06e:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    a072:	b292      	uxth	r2, r2
    a074:	861a      	strh	r2, [r3, #48]	; 0x30
                Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->LsbNext = NextChannelConfig->Lsb;
    a076:	9b01      	ldr	r3, [sp, #4]
    a078:	6a1b      	ldr	r3, [r3, #32]
    a07a:	681b      	ldr	r3, [r3, #0]
    a07c:	791b      	ldrb	r3, [r3, #4]
    a07e:	461a      	mov	r2, r3
    a080:	4b29      	ldr	r3, [pc, #164]	; (a128 <Spi_Ipw_SyncTransmit+0x214>)
    a082:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    a086:	9a02      	ldr	r2, [sp, #8]
    a088:	7952      	ldrb	r2, [r2, #5]
    a08a:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
                Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->DefaultDataNext = NextChannelConfig->DefaultTransmitValue;
    a08e:	9b01      	ldr	r3, [sp, #4]
    a090:	6a1b      	ldr	r3, [r3, #32]
    a092:	681b      	ldr	r3, [r3, #0]
    a094:	791b      	ldrb	r3, [r3, #4]
    a096:	461a      	mov	r2, r3
    a098:	4b23      	ldr	r3, [pc, #140]	; (a128 <Spi_Ipw_SyncTransmit+0x214>)
    a09a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    a09e:	9a02      	ldr	r2, [sp, #8]
    a0a0:	6892      	ldr	r2, [r2, #8]
    a0a2:	635a      	str	r2, [r3, #52]	; 0x34
                Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->LengthNext = NextChannelConfig->ChannelState->Length;
    a0a4:	9b02      	ldr	r3, [sp, #8]
    a0a6:	699a      	ldr	r2, [r3, #24]
    a0a8:	9b01      	ldr	r3, [sp, #4]
    a0aa:	6a1b      	ldr	r3, [r3, #32]
    a0ac:	681b      	ldr	r3, [r3, #0]
    a0ae:	791b      	ldrb	r3, [r3, #4]
    a0b0:	4619      	mov	r1, r3
    a0b2:	4b1d      	ldr	r3, [pc, #116]	; (a128 <Spi_Ipw_SyncTransmit+0x214>)
    a0b4:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    a0b8:	8852      	ldrh	r2, [r2, #2]
    a0ba:	871a      	strh	r2, [r3, #56]	; 0x38
                    Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->NextChannelIsRX = FALSE;
                }
                #endif
            }
            
            if(0u == ChannelIndex)
    a0bc:	f89d 301f 	ldrb.w	r3, [sp, #31]
    a0c0:	2b00      	cmp	r3, #0
    a0c2:	d10a      	bne.n	a0da <Spi_Ipw_SyncTransmit+0x1c6>
            {
                Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->FirstCmd = TRUE;
    a0c4:	9b01      	ldr	r3, [sp, #4]
    a0c6:	6a1b      	ldr	r3, [r3, #32]
    a0c8:	681b      	ldr	r3, [r3, #0]
    a0ca:	791b      	ldrb	r3, [r3, #4]
    a0cc:	461a      	mov	r2, r3
    a0ce:	4b16      	ldr	r3, [pc, #88]	; (a128 <Spi_Ipw_SyncTransmit+0x214>)
    a0d0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    a0d4:	2201      	movs	r2, #1
    a0d6:	775a      	strb	r2, [r3, #29]
    a0d8:	e009      	b.n	a0ee <Spi_Ipw_SyncTransmit+0x1da>
            }
            else
            {
                Lpspi_Ip_apxStateStructureArray[JobConfig->ExternalDeviceConfig->ExDeviceConfig->Instance]->FirstCmd = FALSE;
    a0da:	9b01      	ldr	r3, [sp, #4]
    a0dc:	6a1b      	ldr	r3, [r3, #32]
    a0de:	681b      	ldr	r3, [r3, #0]
    a0e0:	791b      	ldrb	r3, [r3, #4]
    a0e2:	461a      	mov	r2, r3
    a0e4:	4b10      	ldr	r3, [pc, #64]	; (a128 <Spi_Ipw_SyncTransmit+0x214>)
    a0e6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    a0ea:	2200      	movs	r2, #0
    a0ec:	775a      	strb	r2, [r3, #29]
            }
        }
        Ipw_Status = Spi_Ipw_SyncTransmitProcess(JobConfig, ChannelConfig, RxBuffer, (const uint8*)TxBuffer);
    a0ee:	9b08      	ldr	r3, [sp, #32]
    a0f0:	9a03      	ldr	r2, [sp, #12]
    a0f2:	9904      	ldr	r1, [sp, #16]
    a0f4:	9801      	ldr	r0, [sp, #4]
    a0f6:	f7ff fe7f 	bl	9df8 <Spi_Ipw_SyncTransmitProcess>
    a0fa:	4603      	mov	r3, r0
    a0fc:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    for (ChannelIndex = (Spi_ChannelType)0; ChannelIndex < NumChannelsInJob; ChannelIndex++)
    a100:	f89d 301f 	ldrb.w	r3, [sp, #31]
    a104:	3301      	adds	r3, #1
    a106:	f88d 301f 	strb.w	r3, [sp, #31]
    a10a:	f89d 201f 	ldrb.w	r2, [sp, #31]
    a10e:	f89d 3017 	ldrb.w	r3, [sp, #23]
    a112:	429a      	cmp	r2, r3
    a114:	f4ff af12 	bcc.w	9f3c <Spi_Ipw_SyncTransmit+0x28>
    }
    return Ipw_Status;
    a118:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
}
    a11c:	4618      	mov	r0, r3
    a11e:	b00b      	add	sp, #44	; 0x2c
    a120:	f85d fb04 	ldr.w	pc, [sp], #4
    a124:	1fff8df0 	.word	0x1fff8df0
    a128:	1fff8ddc 	.word	0x1fff8ddc

0000a12c <Can_IsControllersBusy>:
        }
    }
#endif /* CAN_43_FLEXCAN_MAINFUNCTION_MULTIPLE_READ == STD_ON */

static boolean Can_IsControllersBusy(uint32 u32CoreId)
{
    a12c:	b084      	sub	sp, #16
    a12e:	9001      	str	r0, [sp, #4]
    boolean bCtrlBusy = FALSE;
    a130:	2300      	movs	r3, #0
    a132:	f88d 300f 	strb.w	r3, [sp, #15]
    uint8 u8ControllerID = 0U;
    a136:	2300      	movs	r3, #0
    a138:	f88d 300e 	strb.w	r3, [sp, #14]

    for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    a13c:	2300      	movs	r3, #0
    a13e:	f88d 300e 	strb.w	r3, [sp, #14]
    a142:	e01b      	b.n	a17c <Can_IsControllersBusy+0x50>
    {
        if (NULL_PTR != (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID])
    a144:	4a12      	ldr	r2, [pc, #72]	; (a190 <Can_IsControllersBusy+0x64>)
    a146:	9b01      	ldr	r3, [sp, #4]
    a148:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a14c:	695a      	ldr	r2, [r3, #20]
    a14e:	f89d 300e 	ldrb.w	r3, [sp, #14]
    a152:	009b      	lsls	r3, r3, #2
    a154:	4413      	add	r3, r2
    a156:	681b      	ldr	r3, [r3, #0]
    a158:	2b00      	cmp	r3, #0
    a15a:	d00a      	beq.n	a172 <Can_IsControllersBusy+0x46>
        {
            if (CAN_CS_UNINIT != Can_eControllerState[u8ControllerID])
    a15c:	f89d 300e 	ldrb.w	r3, [sp, #14]
    a160:	4a0c      	ldr	r2, [pc, #48]	; (a194 <Can_IsControllersBusy+0x68>)
    a162:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a166:	2b00      	cmp	r3, #0
    a168:	d003      	beq.n	a172 <Can_IsControllersBusy+0x46>
                *   The function Can_Init shall raise the error CAN_E_TRANSITION if the CAN
                *   controllers are not in state UNINIT.
                */
                (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_INIT, CAN_43_FLEXCAN_E_TRANSITION);
            #endif
                bCtrlBusy = TRUE;
    a16a:	2301      	movs	r3, #1
    a16c:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    a170:	e008      	b.n	a184 <Can_IsControllersBusy+0x58>
    for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    a172:	f89d 300e 	ldrb.w	r3, [sp, #14]
    a176:	3301      	adds	r3, #1
    a178:	f88d 300e 	strb.w	r3, [sp, #14]
    a17c:	f89d 300e 	ldrb.w	r3, [sp, #14]
    a180:	2b01      	cmp	r3, #1
    a182:	d9df      	bls.n	a144 <Can_IsControllersBusy+0x18>
            }
        }
    }

    return bCtrlBusy;
    a184:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    a188:	4618      	mov	r0, r3
    a18a:	b004      	add	sp, #16
    a18c:	4770      	bx	lr
    a18e:	bf00      	nop
    a190:	1fff8e18 	.word	0x1fff8e18
    a194:	1fff8e10 	.word	0x1fff8e10

0000a198 <Can_InitControllers>:

static void Can_InitControllers(uint32 u32CoreId)
{
    a198:	b500      	push	{lr}
    a19a:	b085      	sub	sp, #20
    a19c:	9001      	str	r0, [sp, #4]
    boolean bCtrlBusy = FALSE;
    a19e:	2300      	movs	r3, #0
    a1a0:	f88d 300f 	strb.w	r3, [sp, #15]
    uint8 u8ControllerID = 0U;
    a1a4:	2300      	movs	r3, #0
    a1a6:	f88d 300e 	strb.w	r3, [sp, #14]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    a1aa:	2300      	movs	r3, #0
    a1ac:	9302      	str	r3, [sp, #8]

    /* Loop through all Can controllers configured based CanControllerId parameter. */
    for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    a1ae:	2300      	movs	r3, #0
    a1b0:	f88d 300e 	strb.w	r3, [sp, #14]
    a1b4:	e035      	b.n	a222 <Can_InitControllers+0x8a>
    {
        if (NULL_PTR != (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID])
    a1b6:	4a30      	ldr	r2, [pc, #192]	; (a278 <Can_InitControllers+0xe0>)
    a1b8:	9b01      	ldr	r3, [sp, #4]
    a1ba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a1be:	695a      	ldr	r2, [r3, #20]
    a1c0:	f89d 300e 	ldrb.w	r3, [sp, #14]
    a1c4:	009b      	lsls	r3, r3, #2
    a1c6:	4413      	add	r3, r2
    a1c8:	681b      	ldr	r3, [r3, #0]
    a1ca:	2b00      	cmp	r3, #0
    a1cc:	d024      	beq.n	a218 <Can_InitControllers+0x80>
        {
            Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID];
    a1ce:	4a2a      	ldr	r2, [pc, #168]	; (a278 <Can_InitControllers+0xe0>)
    a1d0:	9b01      	ldr	r3, [sp, #4]
    a1d2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a1d6:	695a      	ldr	r2, [r3, #20]
    a1d8:	f89d 300e 	ldrb.w	r3, [sp, #14]
    a1dc:	009b      	lsls	r3, r3, #2
    a1de:	4413      	add	r3, r2
    a1e0:	681b      	ldr	r3, [r3, #0]
    a1e2:	9302      	str	r3, [sp, #8]
            /* The initialization is skipped for the controllers that are not enabled. */
            if (TRUE == Can_pController->Can_bActivation)
    a1e4:	9b02      	ldr	r3, [sp, #8]
    a1e6:	7a1b      	ldrb	r3, [r3, #8]
    a1e8:	2b00      	cmp	r3, #0
    a1ea:	d015      	beq.n	a218 <Can_InitControllers+0x80>
                */
            #if ((CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON) || (CAN_43_FLEXCAN_DUAL_CLOCK_MODE == STD_ON))
                Can_au16BaudrateIDConfig[u8ControllerID] = Can_pController->Can_u16DefaultBaudrateID;
            #endif
                /* Reset interrupt level to default value after re-init */
                Can_au8DisableInterruptLevel[u8ControllerID] = 0U;
    a1ec:	f89d 300e 	ldrb.w	r3, [sp, #14]
    a1f0:	4a22      	ldr	r2, [pc, #136]	; (a27c <Can_InitControllers+0xe4>)
    a1f2:	2100      	movs	r1, #0
    a1f4:	54d1      	strb	r1, [r2, r3]
            #if (CAN_43_FLEXCAN_PUBLIC_ICOM_SUPPORT == STD_ON)
                Can_apxCtrlConfigIcomIndex[u8ControllerID] = NULL_PTR;
            #endif
                /* Init the controller */
                if ((Std_ReturnType)E_OK == Can_43_FLEXCAN_Ipw_Init(Can_pController))
    a1f6:	9802      	ldr	r0, [sp, #8]
    a1f8:	f000 ff82 	bl	b100 <Can_43_FLEXCAN_Ipw_Init>
    a1fc:	4603      	mov	r3, r0
    a1fe:	2b00      	cmp	r3, #0
    a200:	d106      	bne.n	a210 <Can_InitControllers+0x78>
                {
                    Can_eControllerState[u8ControllerID] = CAN_CS_STOPPED;
    a202:	f89d 300e 	ldrb.w	r3, [sp, #14]
    a206:	4a1e      	ldr	r2, [pc, #120]	; (a280 <Can_InitControllers+0xe8>)
    a208:	2102      	movs	r1, #2
    a20a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    a20e:	e003      	b.n	a218 <Can_InitControllers+0x80>
                else
                {
                    #if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
                    (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_INIT, CAN_43_FLEXCAN_E_INIT_FAILED);
                    #endif
                    bCtrlBusy = TRUE;
    a210:	2301      	movs	r3, #1
    a212:	f88d 300f 	strb.w	r3, [sp, #15]
                    break;
    a216:	e008      	b.n	a22a <Can_InitControllers+0x92>
    for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    a218:	f89d 300e 	ldrb.w	r3, [sp, #14]
    a21c:	3301      	adds	r3, #1
    a21e:	f88d 300e 	strb.w	r3, [sp, #14]
    a222:	f89d 300e 	ldrb.w	r3, [sp, #14]
    a226:	2b01      	cmp	r3, #1
    a228:	d9c5      	bls.n	a1b6 <Can_InitControllers+0x1e>
    }
    /*
    *  [SWS_Can_00246] After initializing all controllers inside the HW Unit, the function Can_Init
    *   shall change the module state to CAN_READY.
    */
    if (TRUE == bCtrlBusy)
    a22a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a22e:	2b00      	cmp	r3, #0
    a230:	d01e      	beq.n	a270 <Can_InitControllers+0xd8>
    {
        /* Init failed due to one or more controllers failed, reset status of all  core's current controllers */
        for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    a232:	2300      	movs	r3, #0
    a234:	f88d 300e 	strb.w	r3, [sp, #14]
    a238:	e016      	b.n	a268 <Can_InitControllers+0xd0>
        {
            if (NULL_PTR != (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID])
    a23a:	4a0f      	ldr	r2, [pc, #60]	; (a278 <Can_InitControllers+0xe0>)
    a23c:	9b01      	ldr	r3, [sp, #4]
    a23e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a242:	695a      	ldr	r2, [r3, #20]
    a244:	f89d 300e 	ldrb.w	r3, [sp, #14]
    a248:	009b      	lsls	r3, r3, #2
    a24a:	4413      	add	r3, r2
    a24c:	681b      	ldr	r3, [r3, #0]
    a24e:	2b00      	cmp	r3, #0
    a250:	d005      	beq.n	a25e <Can_InitControllers+0xc6>
            {
                Can_eControllerState[u8ControllerID] = CAN_CS_UNINIT;
    a252:	f89d 300e 	ldrb.w	r3, [sp, #14]
    a256:	4a0a      	ldr	r2, [pc, #40]	; (a280 <Can_InitControllers+0xe8>)
    a258:	2100      	movs	r1, #0
    a25a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    a25e:	f89d 300e 	ldrb.w	r3, [sp, #14]
    a262:	3301      	adds	r3, #1
    a264:	f88d 300e 	strb.w	r3, [sp, #14]
    a268:	f89d 300e 	ldrb.w	r3, [sp, #14]
    a26c:	2b01      	cmp	r3, #1
    a26e:	d9e4      	bls.n	a23a <Can_InitControllers+0xa2>
    else
    {
        Can_eDriverStatus[u32CoreId] = CAN_43_FLEXCAN_READY;
    }
#endif
}
    a270:	bf00      	nop
    a272:	b005      	add	sp, #20
    a274:	f85d fb04 	ldr.w	pc, [sp], #4
    a278:	1fff8e18 	.word	0x1fff8e18
    a27c:	1fff8e0c 	.word	0x1fff8e0c
    a280:	1fff8e10 	.word	0x1fff8e10

0000a284 <Can_DeInitControllers>:
    return bResult;
}
#endif

static void Can_DeInitControllers(uint32 u32CoreId)
{
    a284:	b500      	push	{lr}
    a286:	b085      	sub	sp, #20
    a288:	9001      	str	r0, [sp, #4]
    uint8 u8ControllerID = 0U;
    a28a:	2300      	movs	r3, #0
    a28c:	f88d 300f 	strb.w	r3, [sp, #15]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    a290:	2300      	movs	r3, #0
    a292:	9302      	str	r3, [sp, #8]

    /* Loop through all Can controllers configured based CanControllerId parameter. */
    for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    a294:	2300      	movs	r3, #0
    a296:	f88d 300f 	strb.w	r3, [sp, #15]
    a29a:	e028      	b.n	a2ee <Can_DeInitControllers+0x6a>
    {
        if (NULL_PTR != (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID])
    a29c:	4a18      	ldr	r2, [pc, #96]	; (a300 <Can_DeInitControllers+0x7c>)
    a29e:	9b01      	ldr	r3, [sp, #4]
    a2a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a2a4:	695a      	ldr	r2, [r3, #20]
    a2a6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a2aa:	009b      	lsls	r3, r3, #2
    a2ac:	4413      	add	r3, r2
    a2ae:	681b      	ldr	r3, [r3, #0]
    a2b0:	2b00      	cmp	r3, #0
    a2b2:	d017      	beq.n	a2e4 <Can_DeInitControllers+0x60>
        {
            Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID];
    a2b4:	4a12      	ldr	r2, [pc, #72]	; (a300 <Can_DeInitControllers+0x7c>)
    a2b6:	9b01      	ldr	r3, [sp, #4]
    a2b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a2bc:	695a      	ldr	r2, [r3, #20]
    a2be:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a2c2:	009b      	lsls	r3, r3, #2
    a2c4:	4413      	add	r3, r2
    a2c6:	681b      	ldr	r3, [r3, #0]
    a2c8:	9302      	str	r3, [sp, #8]
            /* The initialization is skipped for the controllers that are not enabled. */
            if (TRUE == Can_pController->Can_bActivation)
    a2ca:	9b02      	ldr	r3, [sp, #8]
    a2cc:	7a1b      	ldrb	r3, [r3, #8]
    a2ce:	2b00      	cmp	r3, #0
    a2d0:	d008      	beq.n	a2e4 <Can_DeInitControllers+0x60>
            {
                Can_eControllerState[u8ControllerID] = CAN_CS_UNINIT;
    a2d2:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a2d6:	4a0b      	ldr	r2, [pc, #44]	; (a304 <Can_DeInitControllers+0x80>)
    a2d8:	2100      	movs	r1, #0
    a2da:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                Can_43_FLEXCAN_Ipw_DeInit(Can_pController);
    a2de:	9802      	ldr	r0, [sp, #8]
    a2e0:	f001 f81a 	bl	b318 <Can_43_FLEXCAN_Ipw_DeInit>
    for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    a2e4:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a2e8:	3301      	adds	r3, #1
    a2ea:	f88d 300f 	strb.w	r3, [sp, #15]
    a2ee:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a2f2:	2b01      	cmp	r3, #1
    a2f4:	d9d2      	bls.n	a29c <Can_DeInitControllers+0x18>
            }
        }
    }
}
    a2f6:	bf00      	nop
    a2f8:	bf00      	nop
    a2fa:	b005      	add	sp, #20
    a2fc:	f85d fb04 	ldr.w	pc, [sp], #4
    a300:	1fff8e18 	.word	0x1fff8e18
    a304:	1fff8e10 	.word	0x1fff8e10

0000a308 <Can_43_FLEXCAN_Init>:
* @api
*/

/* implements     Can_Init_Activity */
void Can_43_FLEXCAN_Init(const Can_43_FLEXCAN_ConfigType * Config)
{
    a308:	b500      	push	{lr}
    a30a:	b085      	sub	sp, #20
    a30c:	9001      	str	r0, [sp, #4]
    uint32 u32CoreId = 0U;
    a30e:	2300      	movs	r3, #0
    a310:	9303      	str	r3, [sp, #12]
    boolean bCtrlBusy = FALSE;
    a312:	2300      	movs	r3, #0
    a314:	f88d 300b 	strb.w	r3, [sp, #11]
#if (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON)
    boolean bValidCoreID = FALSE;
#endif

    u32CoreId = Can_GetCoreID();
    a318:	2300      	movs	r3, #0
    a31a:	9303      	str	r3, [sp, #12]
        #if (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON)
            if (u32CoreId == Config->Can_u32CoreID)
            {
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
                /* Copy pointer to current Can Driver configuration. */
                Can_apxConfig[u32CoreId] = Config;
    a31c:	490c      	ldr	r1, [pc, #48]	; (a350 <Can_43_FLEXCAN_Init+0x48>)
    a31e:	9b03      	ldr	r3, [sp, #12]
    a320:	9a01      	ldr	r2, [sp, #4]
    a322:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
            if (TRUE == bValidCoreID)
            {
#endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
                /* Fault Injection point to allow to test SWS_Can_00408 */
                MCAL_FAULT_INJECTION_POINT(CAN_FIP_1_CHANGE_DRIVER_TO_UNINITIALIZED);
                bCtrlBusy = Can_IsControllersBusy(u32CoreId);
    a326:	9803      	ldr	r0, [sp, #12]
    a328:	f7ff ff00 	bl	a12c <Can_IsControllersBusy>
    a32c:	4603      	mov	r3, r0
    a32e:	f88d 300b 	strb.w	r3, [sp, #11]
                if (FALSE == bCtrlBusy)
    a332:	f89d 300b 	ldrb.w	r3, [sp, #11]
    a336:	f083 0301 	eor.w	r3, r3, #1
    a33a:	b2db      	uxtb	r3, r3
    a33c:	2b00      	cmp	r3, #0
    a33e:	d002      	beq.n	a346 <Can_43_FLEXCAN_Init+0x3e>
                {
                    Can_InitControllers(u32CoreId);
    a340:	9803      	ldr	r0, [sp, #12]
    a342:	f7ff ff29 	bl	a198 <Can_InitControllers>

#if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
        }
    }
#endif /* (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON) */
}
    a346:	bf00      	nop
    a348:	b005      	add	sp, #20
    a34a:	f85d fb04 	ldr.w	pc, [sp], #4
    a34e:	bf00      	nop
    a350:	1fff8e18 	.word	0x1fff8e18

0000a354 <Can_43_FLEXCAN_DeInit>:
* @post           Can_DeInit shall de-initialize all the controllers and set the driver in UNINIT state.
*
*/
/* implements     Can_DeInit_Activity */
void Can_43_FLEXCAN_DeInit(void)
{
    a354:	b500      	push	{lr}
    a356:	b083      	sub	sp, #12
    /* Variable for indexing the controllers. */
    uint8 u8ControllerID = 0U;
    a358:	2300      	movs	r3, #0
    a35a:	f88d 3007 	strb.w	r3, [sp, #7]
    boolean bCtrlBusy = FALSE;
    a35e:	2300      	movs	r3, #0
    a360:	f88d 3006 	strb.w	r3, [sp, #6]
    uint32 u32CoreId = 0U;
    a364:	2300      	movs	r3, #0
    a366:	9300      	str	r3, [sp, #0]

    u32CoreId = Can_GetCoreID();
    a368:	2300      	movs	r3, #0
    a36a:	9300      	str	r3, [sp, #0]
    }
    else
    {
#endif
        /* Loop through all Can controllers configured based CanControllerId parameter. */
        for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    a36c:	2300      	movs	r3, #0
    a36e:	f88d 3007 	strb.w	r3, [sp, #7]
    a372:	e01b      	b.n	a3ac <Can_43_FLEXCAN_DeInit+0x58>
        {
            if (NULL_PTR != (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID])
    a374:	4a19      	ldr	r2, [pc, #100]	; (a3dc <Can_43_FLEXCAN_DeInit+0x88>)
    a376:	9b00      	ldr	r3, [sp, #0]
    a378:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a37c:	695a      	ldr	r2, [r3, #20]
    a37e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a382:	009b      	lsls	r3, r3, #2
    a384:	4413      	add	r3, r2
    a386:	681b      	ldr	r3, [r3, #0]
    a388:	2b00      	cmp	r3, #0
    a38a:	d00a      	beq.n	a3a2 <Can_43_FLEXCAN_DeInit+0x4e>
            {
                if (CAN_CS_STARTED == Can_eControllerState[u8ControllerID])
    a38c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a390:	4a13      	ldr	r2, [pc, #76]	; (a3e0 <Can_43_FLEXCAN_DeInit+0x8c>)
    a392:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a396:	2b01      	cmp	r3, #1
    a398:	d103      	bne.n	a3a2 <Can_43_FLEXCAN_DeInit+0x4e>
                    *   if any of the CAN controllers is in state STARTED.
                    */
                    (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, (uint8)CAN_43_FLEXCAN_INSTANCE, (uint8)CAN_43_FLEXCAN_SID_DEINIT, (uint8)CAN_43_FLEXCAN_E_TRANSITION);
                #endif
                    /* Controller is busy */
                    bCtrlBusy =  TRUE;
    a39a:	2301      	movs	r3, #1
    a39c:	f88d 3006 	strb.w	r3, [sp, #6]
                    /* Skipping the loop if any of Can Controller is in state STARTED */
                    break;
    a3a0:	e008      	b.n	a3b4 <Can_43_FLEXCAN_DeInit+0x60>
        for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    a3a2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a3a6:	3301      	adds	r3, #1
    a3a8:	f88d 3007 	strb.w	r3, [sp, #7]
    a3ac:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a3b0:	2b01      	cmp	r3, #1
    a3b2:	d9df      	bls.n	a374 <Can_43_FLEXCAN_DeInit+0x20>
                }
            }
        }
        /* All Controllers are not busy */
        if (FALSE == bCtrlBusy)
    a3b4:	f89d 3006 	ldrb.w	r3, [sp, #6]
    a3b8:	f083 0301 	eor.w	r3, r3, #1
    a3bc:	b2db      	uxtb	r3, r3
    a3be:	2b00      	cmp	r3, #0
    a3c0:	d007      	beq.n	a3d2 <Can_43_FLEXCAN_DeInit+0x7e>
            *   [SWS_Can_91010] The function Can_DeInit shall change the module state to
            *   CAN_UNINIT before de-initializing all controllers inside the HW unit
            */
            Can_eDriverStatus[u32CoreId] = CAN_43_FLEXCAN_UNINIT;
        #endif
            Can_DeInitControllers(u32CoreId);
    a3c2:	9800      	ldr	r0, [sp, #0]
    a3c4:	f7ff ff5e 	bl	a284 <Can_DeInitControllers>
            Can_apxConfig[u32CoreId] = NULL_PTR;
    a3c8:	4a04      	ldr	r2, [pc, #16]	; (a3dc <Can_43_FLEXCAN_DeInit+0x88>)
    a3ca:	9b00      	ldr	r3, [sp, #0]
    a3cc:	2100      	movs	r1, #0
    a3ce:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        }
#if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
    }
#endif
}
    a3d2:	bf00      	nop
    a3d4:	b003      	add	sp, #12
    a3d6:	f85d fb04 	ldr.w	pc, [sp], #4
    a3da:	bf00      	nop
    a3dc:	1fff8e18 	.word	0x1fff8e18
    a3e0:	1fff8e10 	.word	0x1fff8e10

0000a3e4 <Can_43_FLEXCAN_SetControllerMode>:
*
* @api
*/
/* implements     Can_SetControllerMode_Activity */
Std_ReturnType Can_43_FLEXCAN_SetControllerMode(uint8 Controller, Can_ControllerStateType Transition)
{
    a3e4:	b500      	push	{lr}
    a3e6:	b087      	sub	sp, #28
    a3e8:	4603      	mov	r3, r0
    a3ea:	9100      	str	r1, [sp, #0]
    a3ec:	f88d 3007 	strb.w	r3, [sp, #7]
    Std_ReturnType eRetVal = E_NOT_OK;
    a3f0:	2301      	movs	r3, #1
    a3f2:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32 u32CoreId = 0U;
    a3f6:	2300      	movs	r3, #0
    a3f8:	9304      	str	r3, [sp, #16]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    a3fa:	2300      	movs	r3, #0
    a3fc:	9303      	str	r3, [sp, #12]

    u32CoreId = Can_GetCoreID();
    a3fe:	2300      	movs	r3, #0
    a400:	9304      	str	r3, [sp, #16]
#if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
    if (TRUE == Can_ValidateController(u32CoreId, Controller, CAN_43_FLEXCAN_SID_SET_CONTROLLER_MODE))
    {
#endif
                Can_pController = (const Can_43_FLEXCAN_ControllerConfigType *)(Can_apxConfig[u32CoreId])->Can_ppController[Controller];
    a402:	4a47      	ldr	r2, [pc, #284]	; (a520 <Can_43_FLEXCAN_SetControllerMode+0x13c>)
    a404:	9b04      	ldr	r3, [sp, #16]
    a406:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a40a:	695a      	ldr	r2, [r3, #20]
    a40c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a410:	009b      	lsls	r3, r3, #2
    a412:	4413      	add	r3, r2
    a414:	681b      	ldr	r3, [r3, #0]
    a416:	9303      	str	r3, [sp, #12]
                /*
                *   [SWS_Can_00017] The function Can_SetControllerMode shall perform software
                *   triggered state transitions of the CAN controller State machine.
                */
                switch (Transition)
    a418:	9b00      	ldr	r3, [sp, #0]
    a41a:	2b03      	cmp	r3, #3
    a41c:	d05d      	beq.n	a4da <Can_43_FLEXCAN_SetControllerMode+0xf6>
    a41e:	9b00      	ldr	r3, [sp, #0]
    a420:	2b03      	cmp	r3, #3
    a422:	d874      	bhi.n	a50e <Can_43_FLEXCAN_SetControllerMode+0x12a>
    a424:	9b00      	ldr	r3, [sp, #0]
    a426:	2b01      	cmp	r3, #1
    a428:	d003      	beq.n	a432 <Can_43_FLEXCAN_SetControllerMode+0x4e>
    a42a:	9b00      	ldr	r3, [sp, #0]
    a42c:	2b02      	cmp	r3, #2
    a42e:	d01d      	beq.n	a46c <Can_43_FLEXCAN_SetControllerMode+0x88>
                        *   has been requested, the function Can_SetControllerMode shall raise the error CAN_E_TRANSITION and
                        *   return E_NOT_OK
                        */
                        (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_SET_CONTROLLER_MODE, CAN_43_FLEXCAN_E_TRANSITION);
                    #endif
                        break;
    a430:	e06d      	b.n	a50e <Can_43_FLEXCAN_SetControllerMode+0x12a>
                        if (CAN_CS_STOPPED == Can_eControllerState[Controller])
    a432:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a436:	4a3b      	ldr	r2, [pc, #236]	; (a524 <Can_43_FLEXCAN_SetControllerMode+0x140>)
    a438:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a43c:	2b02      	cmp	r3, #2
    a43e:	d168      	bne.n	a512 <Can_43_FLEXCAN_SetControllerMode+0x12e>
                            if ((Std_ReturnType)E_OK == Can_43_FLEXCAN_Ipw_SetControllerToStartMode(Can_pController))
    a440:	9803      	ldr	r0, [sp, #12]
    a442:	f000 ffa3 	bl	b38c <Can_43_FLEXCAN_Ipw_SetControllerToStartMode>
    a446:	4603      	mov	r3, r0
    a448:	2b00      	cmp	r3, #0
    a44a:	d162      	bne.n	a512 <Can_43_FLEXCAN_SetControllerMode+0x12e>
                                Can_eControllerState[Controller] = CAN_CS_STARTED;
    a44c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a450:	4a34      	ldr	r2, [pc, #208]	; (a524 <Can_43_FLEXCAN_SetControllerMode+0x140>)
    a452:	2101      	movs	r1, #1
    a454:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                                CanIf_ControllerModeIndication(Can_pController->Can_u8AbstControllerID, CAN_CS_STARTED);
    a458:	9b03      	ldr	r3, [sp, #12]
    a45a:	781b      	ldrb	r3, [r3, #0]
    a45c:	2101      	movs	r1, #1
    a45e:	4618      	mov	r0, r3
    a460:	f00c fe94 	bl	1718c <CanIf_ControllerModeIndication>
                                eRetVal = E_OK;
    a464:	2300      	movs	r3, #0
    a466:	f88d 3017 	strb.w	r3, [sp, #23]
                        break;
    a46a:	e052      	b.n	a512 <Can_43_FLEXCAN_SetControllerMode+0x12e>
                        switch (Can_eControllerState[Controller])
    a46c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a470:	4a2c      	ldr	r2, [pc, #176]	; (a524 <Can_43_FLEXCAN_SetControllerMode+0x140>)
    a472:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a476:	2b01      	cmp	r3, #1
    a478:	d005      	beq.n	a486 <Can_43_FLEXCAN_SetControllerMode+0xa2>
    a47a:	2b00      	cmp	r3, #0
    a47c:	d029      	beq.n	a4d2 <Can_43_FLEXCAN_SetControllerMode+0xee>
    a47e:	3b02      	subs	r3, #2
    a480:	2b01      	cmp	r3, #1
    a482:	d826      	bhi.n	a4d2 <Can_43_FLEXCAN_SetControllerMode+0xee>
    a484:	e015      	b.n	a4b2 <Can_43_FLEXCAN_SetControllerMode+0xce>
                                if ((Std_ReturnType)E_OK == Can_43_FLEXCAN_Ipw_SetControllerToStopMode(Can_pController))
    a486:	9803      	ldr	r0, [sp, #12]
    a488:	f000 fff2 	bl	b470 <Can_43_FLEXCAN_Ipw_SetControllerToStopMode>
    a48c:	4603      	mov	r3, r0
    a48e:	2b00      	cmp	r3, #0
    a490:	d121      	bne.n	a4d6 <Can_43_FLEXCAN_SetControllerMode+0xf2>
                                    Can_eControllerState[Controller] = CAN_CS_STOPPED;
    a492:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a496:	4a23      	ldr	r2, [pc, #140]	; (a524 <Can_43_FLEXCAN_SetControllerMode+0x140>)
    a498:	2102      	movs	r1, #2
    a49a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                                    CanIf_ControllerModeIndication(Can_pController->Can_u8AbstControllerID, CAN_CS_STOPPED);
    a49e:	9b03      	ldr	r3, [sp, #12]
    a4a0:	781b      	ldrb	r3, [r3, #0]
    a4a2:	2102      	movs	r1, #2
    a4a4:	4618      	mov	r0, r3
    a4a6:	f00c fe71 	bl	1718c <CanIf_ControllerModeIndication>
                                    eRetVal = E_OK;
    a4aa:	2300      	movs	r3, #0
    a4ac:	f88d 3017 	strb.w	r3, [sp, #23]
                                break;
    a4b0:	e011      	b.n	a4d6 <Can_43_FLEXCAN_SetControllerMode+0xf2>
                                Can_eControllerState[Controller] = CAN_CS_STOPPED;
    a4b2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a4b6:	4a1b      	ldr	r2, [pc, #108]	; (a524 <Can_43_FLEXCAN_SetControllerMode+0x140>)
    a4b8:	2102      	movs	r1, #2
    a4ba:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                                CanIf_ControllerModeIndication(Can_pController->Can_u8AbstControllerID, CAN_CS_STOPPED);
    a4be:	9b03      	ldr	r3, [sp, #12]
    a4c0:	781b      	ldrb	r3, [r3, #0]
    a4c2:	2102      	movs	r1, #2
    a4c4:	4618      	mov	r0, r3
    a4c6:	f00c fe61 	bl	1718c <CanIf_ControllerModeIndication>
                                eRetVal = E_OK;
    a4ca:	2300      	movs	r3, #0
    a4cc:	f88d 3017 	strb.w	r3, [sp, #23]
                                break;
    a4d0:	e002      	b.n	a4d8 <Can_43_FLEXCAN_SetControllerMode+0xf4>
                                break;
    a4d2:	bf00      	nop
    a4d4:	e01e      	b.n	a514 <Can_43_FLEXCAN_SetControllerMode+0x130>
                                break;
    a4d6:	bf00      	nop
                        break;
    a4d8:	e01c      	b.n	a514 <Can_43_FLEXCAN_SetControllerMode+0x130>
                        switch (Can_eControllerState[Controller])
    a4da:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a4de:	4a11      	ldr	r2, [pc, #68]	; (a524 <Can_43_FLEXCAN_SetControllerMode+0x140>)
    a4e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a4e4:	3b02      	subs	r3, #2
    a4e6:	2b01      	cmp	r3, #1
    a4e8:	d80f      	bhi.n	a50a <Can_43_FLEXCAN_SetControllerMode+0x126>
                                Can_eControllerState[Controller] = CAN_CS_SLEEP;
    a4ea:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a4ee:	4a0d      	ldr	r2, [pc, #52]	; (a524 <Can_43_FLEXCAN_SetControllerMode+0x140>)
    a4f0:	2103      	movs	r1, #3
    a4f2:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                                CanIf_ControllerModeIndication(Can_pController->Can_u8AbstControllerID, CAN_CS_SLEEP);
    a4f6:	9b03      	ldr	r3, [sp, #12]
    a4f8:	781b      	ldrb	r3, [r3, #0]
    a4fa:	2103      	movs	r1, #3
    a4fc:	4618      	mov	r0, r3
    a4fe:	f00c fe45 	bl	1718c <CanIf_ControllerModeIndication>
                                eRetVal = E_OK;
    a502:	2300      	movs	r3, #0
    a504:	f88d 3017 	strb.w	r3, [sp, #23]
                                break;
    a508:	e000      	b.n	a50c <Can_43_FLEXCAN_SetControllerMode+0x128>
                                break;
    a50a:	bf00      	nop
                        break;
    a50c:	e002      	b.n	a514 <Can_43_FLEXCAN_SetControllerMode+0x130>
                        break;
    a50e:	bf00      	nop
    a510:	e000      	b.n	a514 <Can_43_FLEXCAN_SetControllerMode+0x130>
                        break;
    a512:	bf00      	nop
                    }
                }
#if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
    }
#endif
    return eRetVal;
    a514:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    a518:	4618      	mov	r0, r3
    a51a:	b007      	add	sp, #28
    a51c:	f85d fb04 	ldr.w	pc, [sp], #4
    a520:	1fff8e18 	.word	0x1fff8e18
    a524:	1fff8e10 	.word	0x1fff8e10

0000a528 <Can_43_FLEXCAN_DisableControllerInterrupts>:
*
* @api
*/
/* implements     Can_DisableControllerInterrupts_Activity */
void Can_43_FLEXCAN_DisableControllerInterrupts(uint8 Controller)
{
    a528:	b500      	push	{lr}
    a52a:	b085      	sub	sp, #20
    a52c:	4603      	mov	r3, r0
    a52e:	f88d 3007 	strb.w	r3, [sp, #7]
    uint32 u32CoreId = 0U;
    a532:	2300      	movs	r3, #0
    a534:	9303      	str	r3, [sp, #12]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    a536:	2300      	movs	r3, #0
    a538:	9302      	str	r3, [sp, #8]

    u32CoreId = Can_GetCoreID();
    a53a:	2300      	movs	r3, #0
    a53c:	9303      	str	r3, [sp, #12]
            }
            else
            {
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
#endif
                Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[Controller];
    a53e:	4a10      	ldr	r2, [pc, #64]	; (a580 <Can_43_FLEXCAN_DisableControllerInterrupts+0x58>)
    a540:	9b03      	ldr	r3, [sp, #12]
    a542:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a546:	695a      	ldr	r2, [r3, #20]
    a548:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a54c:	009b      	lsls	r3, r3, #2
    a54e:	4413      	add	r3, r2
    a550:	681b      	ldr	r3, [r3, #0]
    a552:	9302      	str	r3, [sp, #8]
                /* Start critical section: implementation depends on integrator */
                SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00();
    a554:	f009 fc1c 	bl	13d90 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00>
                Can_au8DisableInterruptLevel[Controller] += 1U;
    a558:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a55c:	4a09      	ldr	r2, [pc, #36]	; (a584 <Can_43_FLEXCAN_DisableControllerInterrupts+0x5c>)
    a55e:	5cd2      	ldrb	r2, [r2, r3]
    a560:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a564:	3201      	adds	r2, #1
    a566:	b2d1      	uxtb	r1, r2
    a568:	4a06      	ldr	r2, [pc, #24]	; (a584 <Can_43_FLEXCAN_DisableControllerInterrupts+0x5c>)
    a56a:	54d1      	strb	r1, [r2, r3]
                /* End critical section: implementation depends on integrator */
                SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00();
    a56c:	f009 fc3c 	bl	13de8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00>
                Can_43_FLEXCAN_Ipw_DisableControllerInterrupts(Can_pController);
    a570:	9802      	ldr	r0, [sp, #8]
    a572:	f000 fffb 	bl	b56c <Can_43_FLEXCAN_Ipw_DisableControllerInterrupts>
            }
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
        }
    }
#endif
}
    a576:	bf00      	nop
    a578:	b005      	add	sp, #20
    a57a:	f85d fb04 	ldr.w	pc, [sp], #4
    a57e:	bf00      	nop
    a580:	1fff8e18 	.word	0x1fff8e18
    a584:	1fff8e0c 	.word	0x1fff8e0c

0000a588 <Can_43_FLEXCAN_EnableControllerInterrupts>:
*
* @api
*/
/* implements     Can_EnableControllerInterrupts_Activity */
void Can_43_FLEXCAN_EnableControllerInterrupts(uint8 Controller)
{
    a588:	b500      	push	{lr}
    a58a:	b085      	sub	sp, #20
    a58c:	4603      	mov	r3, r0
    a58e:	f88d 3007 	strb.w	r3, [sp, #7]
    uint32 u32CoreId = 0U;
    a592:	2300      	movs	r3, #0
    a594:	9303      	str	r3, [sp, #12]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    a596:	2300      	movs	r3, #0
    a598:	9302      	str	r3, [sp, #8]

    u32CoreId = Can_GetCoreID();
    a59a:	2300      	movs	r3, #0
    a59c:	9303      	str	r3, [sp, #12]
            }
            else
            {
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
#endif
                Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[Controller];
    a59e:	4a16      	ldr	r2, [pc, #88]	; (a5f8 <Can_43_FLEXCAN_EnableControllerInterrupts+0x70>)
    a5a0:	9b03      	ldr	r3, [sp, #12]
    a5a2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a5a6:	695a      	ldr	r2, [r3, #20]
    a5a8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a5ac:	009b      	lsls	r3, r3, #2
    a5ae:	4413      	add	r3, r2
    a5b0:	681b      	ldr	r3, [r3, #0]
    a5b2:	9302      	str	r3, [sp, #8]
                /* Start critical section: implementation depends on integrator */
                SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01();
    a5b4:	f009 fc3e 	bl	13e34 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01>
                if (Can_au8DisableInterruptLevel[Controller] > 0U)
    a5b8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a5bc:	4a0f      	ldr	r2, [pc, #60]	; (a5fc <Can_43_FLEXCAN_EnableControllerInterrupts+0x74>)
    a5be:	5cd3      	ldrb	r3, [r2, r3]
    a5c0:	2b00      	cmp	r3, #0
    a5c2:	d009      	beq.n	a5d8 <Can_43_FLEXCAN_EnableControllerInterrupts+0x50>
                {
                    Can_au8DisableInterruptLevel[Controller] -= 1U;
    a5c4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a5c8:	4a0c      	ldr	r2, [pc, #48]	; (a5fc <Can_43_FLEXCAN_EnableControllerInterrupts+0x74>)
    a5ca:	5cd2      	ldrb	r2, [r2, r3]
    a5cc:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a5d0:	3a01      	subs	r2, #1
    a5d2:	b2d1      	uxtb	r1, r2
    a5d4:	4a09      	ldr	r2, [pc, #36]	; (a5fc <Can_43_FLEXCAN_EnableControllerInterrupts+0x74>)
    a5d6:	54d1      	strb	r1, [r2, r3]
                }
                /* End critical section: implementation depends on integrator */
                SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01();
    a5d8:	f009 fc58 	bl	13e8c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01>

                if (0U == Can_au8DisableInterruptLevel[Controller])
    a5dc:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a5e0:	4a06      	ldr	r2, [pc, #24]	; (a5fc <Can_43_FLEXCAN_EnableControllerInterrupts+0x74>)
    a5e2:	5cd3      	ldrb	r3, [r2, r3]
    a5e4:	2b00      	cmp	r3, #0
    a5e6:	d102      	bne.n	a5ee <Can_43_FLEXCAN_EnableControllerInterrupts+0x66>
                {
                    Can_43_FLEXCAN_Ipw_EnableControllerInterrupts(Can_pController);
    a5e8:	9802      	ldr	r0, [sp, #8]
    a5ea:	f000 ffe9 	bl	b5c0 <Can_43_FLEXCAN_Ipw_EnableControllerInterrupts>
            }
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
        }
    }
#endif
}
    a5ee:	bf00      	nop
    a5f0:	b005      	add	sp, #20
    a5f2:	f85d fb04 	ldr.w	pc, [sp], #4
    a5f6:	bf00      	nop
    a5f8:	1fff8e18 	.word	0x1fff8e18
    a5fc:	1fff8e0c 	.word	0x1fff8e0c

0000a600 <Can_43_FLEXCAN_GetControllerErrorState>:
Std_ReturnType Can_43_FLEXCAN_GetControllerErrorState
(
    uint8 ControllerId,
    Can_ErrorStateType * ErrorStatePtr
)
{
    a600:	b500      	push	{lr}
    a602:	b087      	sub	sp, #28
    a604:	4603      	mov	r3, r0
    a606:	9100      	str	r1, [sp, #0]
    a608:	f88d 3007 	strb.w	r3, [sp, #7]
    Std_ReturnType eRetVal = E_NOT_OK;
    a60c:	2301      	movs	r3, #1
    a60e:	f88d 3017 	strb.w	r3, [sp, #23]
    uint8 errorState = 0U;
    a612:	2300      	movs	r3, #0
    a614:	f88d 300b 	strb.w	r3, [sp, #11]
    uint32 u32CoreId = 0U;
    a618:	2300      	movs	r3, #0
    a61a:	9304      	str	r3, [sp, #16]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    a61c:	2300      	movs	r3, #0
    a61e:	9303      	str	r3, [sp, #12]

    u32CoreId = Can_GetCoreID();
    a620:	2300      	movs	r3, #0
    a622:	9304      	str	r3, [sp, #16]
                    (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_GET_CONTROLLER_ERROR_STATE, CAN_43_FLEXCAN_E_PARAM_POINTER);
                }
                else
                {
#endif
                    Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[ControllerId];
    a624:	4a18      	ldr	r2, [pc, #96]	; (a688 <Can_43_FLEXCAN_GetControllerErrorState+0x88>)
    a626:	9b04      	ldr	r3, [sp, #16]
    a628:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a62c:	695a      	ldr	r2, [r3, #20]
    a62e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a632:	009b      	lsls	r3, r3, #2
    a634:	4413      	add	r3, r2
    a636:	681b      	ldr	r3, [r3, #0]
    a638:	9303      	str	r3, [sp, #12]
                    eRetVal = Can_43_FLEXCAN_Ipw_GetControllerErrorState(Can_pController, &errorState);
    a63a:	f10d 030b 	add.w	r3, sp, #11
    a63e:	4619      	mov	r1, r3
    a640:	9803      	ldr	r0, [sp, #12]
    a642:	f000 ffe9 	bl	b618 <Can_43_FLEXCAN_Ipw_GetControllerErrorState>
    a646:	4603      	mov	r3, r0
    a648:	f88d 3017 	strb.w	r3, [sp, #23]
                    if(eRetVal == (Std_ReturnType)E_OK)
    a64c:	f89d 3017 	ldrb.w	r3, [sp, #23]
    a650:	2b00      	cmp	r3, #0
    a652:	d112      	bne.n	a67a <Can_43_FLEXCAN_GetControllerErrorState+0x7a>
                    {
                        switch (errorState)
    a654:	f89d 300b 	ldrb.w	r3, [sp, #11]
    a658:	2b00      	cmp	r3, #0
    a65a:	d002      	beq.n	a662 <Can_43_FLEXCAN_GetControllerErrorState+0x62>
    a65c:	2b01      	cmp	r3, #1
    a65e:	d004      	beq.n	a66a <Can_43_FLEXCAN_GetControllerErrorState+0x6a>
    a660:	e007      	b.n	a672 <Can_43_FLEXCAN_GetControllerErrorState+0x72>
                        {
                            case 0x00U:
                            {
                                *ErrorStatePtr = CAN_ERRORSTATE_ACTIVE;
    a662:	9b00      	ldr	r3, [sp, #0]
    a664:	2200      	movs	r2, #0
    a666:	601a      	str	r2, [r3, #0]
                                break;
    a668:	e008      	b.n	a67c <Can_43_FLEXCAN_GetControllerErrorState+0x7c>
                            }
                            case 0x01U:
                            {
                                *ErrorStatePtr = CAN_ERRORSTATE_PASSIVE;
    a66a:	9b00      	ldr	r3, [sp, #0]
    a66c:	2201      	movs	r2, #1
    a66e:	601a      	str	r2, [r3, #0]
                                break;
    a670:	e004      	b.n	a67c <Can_43_FLEXCAN_GetControllerErrorState+0x7c>
                            }
                            default:
                            {
                                *ErrorStatePtr = CAN_ERRORSTATE_BUSOFF;
    a672:	9b00      	ldr	r3, [sp, #0]
    a674:	2202      	movs	r2, #2
    a676:	601a      	str	r2, [r3, #0]
                                break;
    a678:	e000      	b.n	a67c <Can_43_FLEXCAN_GetControllerErrorState+0x7c>
                            }
                        }
                    }
    a67a:	bf00      	nop
#if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
                }
    }
#endif
    return eRetVal;
    a67c:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    a680:	4618      	mov	r0, r3
    a682:	b007      	add	sp, #28
    a684:	f85d fb04 	ldr.w	pc, [sp], #4
    a688:	1fff8e18 	.word	0x1fff8e18

0000a68c <Can_43_FLEXCAN_GetControllerMode>:
Std_ReturnType Can_43_FLEXCAN_GetControllerMode
(
    uint8 Controller,
    Can_ControllerStateType * ControllerModePtr
)
{
    a68c:	b084      	sub	sp, #16
    a68e:	4603      	mov	r3, r0
    a690:	9100      	str	r1, [sp, #0]
    a692:	f88d 3007 	strb.w	r3, [sp, #7]
    Std_ReturnType eRetVal = E_NOT_OK;
    a696:	2301      	movs	r3, #1
    a698:	f88d 300f 	strb.w	r3, [sp, #15]
                    (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_GET_CONTROLLER_MODE, CAN_43_FLEXCAN_E_PARAM_POINTER);
                }
                else
                {
#endif
                    *ControllerModePtr = Can_eControllerState[Controller];
    a69c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a6a0:	4a06      	ldr	r2, [pc, #24]	; (a6bc <Can_43_FLEXCAN_GetControllerMode+0x30>)
    a6a2:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    a6a6:	9b00      	ldr	r3, [sp, #0]
    a6a8:	601a      	str	r2, [r3, #0]
                    eRetVal = E_OK;
    a6aa:	2300      	movs	r3, #0
    a6ac:	f88d 300f 	strb.w	r3, [sp, #15]
            }
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
        }
    }
#endif
    return eRetVal;
    a6b0:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    a6b4:	4618      	mov	r0, r3
    a6b6:	b004      	add	sp, #16
    a6b8:	4770      	bx	lr
    a6ba:	bf00      	nop
    a6bc:	1fff8e10 	.word	0x1fff8e10

0000a6c0 <Can_43_FLEXCAN_GetControllerRxErrorCounter>:
Std_ReturnType Can_43_FLEXCAN_GetControllerRxErrorCounter
(
    uint8 ControllerId,
    uint8 * RxErrorCounterPtr
)
{
    a6c0:	b500      	push	{lr}
    a6c2:	b087      	sub	sp, #28
    a6c4:	4603      	mov	r3, r0
    a6c6:	9100      	str	r1, [sp, #0]
    a6c8:	f88d 3007 	strb.w	r3, [sp, #7]
    Std_ReturnType eRetVal = E_NOT_OK;
    a6cc:	2301      	movs	r3, #1
    a6ce:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32 u32CoreId = 0U;
    a6d2:	2300      	movs	r3, #0
    a6d4:	9304      	str	r3, [sp, #16]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    a6d6:	2300      	movs	r3, #0
    a6d8:	9303      	str	r3, [sp, #12]

    u32CoreId = Can_GetCoreID();
    a6da:	2300      	movs	r3, #0
    a6dc:	9304      	str	r3, [sp, #16]
                    (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_GET_CONTROLLER_RX_ERROR_COUNTER, CAN_43_FLEXCAN_E_PARAM_POINTER);
                }
                else
                {
#endif
                    Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[ControllerId];
    a6de:	4a0c      	ldr	r2, [pc, #48]	; (a710 <Can_43_FLEXCAN_GetControllerRxErrorCounter+0x50>)
    a6e0:	9b04      	ldr	r3, [sp, #16]
    a6e2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a6e6:	695a      	ldr	r2, [r3, #20]
    a6e8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a6ec:	009b      	lsls	r3, r3, #2
    a6ee:	4413      	add	r3, r2
    a6f0:	681b      	ldr	r3, [r3, #0]
    a6f2:	9303      	str	r3, [sp, #12]
                    /*
                    *   [SWS_Can_00515]: When the API Can_GetControllerRxErrorCounter is called with
                    *   Controller Id as input parameter then Can driver shall read the Rx error counter
                    *   register of Can Controller and shall return the Rx error count to upper layer.
                    */
                    eRetVal = Can_43_FLEXCAN_Ipw_GetControllerRxErrorCounter(Can_pController, RxErrorCounterPtr);
    a6f4:	9900      	ldr	r1, [sp, #0]
    a6f6:	9803      	ldr	r0, [sp, #12]
    a6f8:	f000 ffb9 	bl	b66e <Can_43_FLEXCAN_Ipw_GetControllerRxErrorCounter>
    a6fc:	4603      	mov	r3, r0
    a6fe:	f88d 3017 	strb.w	r3, [sp, #23]
            }
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
        }
    }
#endif
    return eRetVal;
    a702:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    a706:	4618      	mov	r0, r3
    a708:	b007      	add	sp, #28
    a70a:	f85d fb04 	ldr.w	pc, [sp], #4
    a70e:	bf00      	nop
    a710:	1fff8e18 	.word	0x1fff8e18

0000a714 <Can_43_FLEXCAN_GetControllerTxErrorCounter>:
Std_ReturnType Can_43_FLEXCAN_GetControllerTxErrorCounter
(
    uint8 ControllerId,
    uint8 * TxErrorCounterPtr
)
{
    a714:	b500      	push	{lr}
    a716:	b087      	sub	sp, #28
    a718:	4603      	mov	r3, r0
    a71a:	9100      	str	r1, [sp, #0]
    a71c:	f88d 3007 	strb.w	r3, [sp, #7]
    Std_ReturnType eRetVal = E_NOT_OK;
    a720:	2301      	movs	r3, #1
    a722:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32 u32CoreId = 0U;
    a726:	2300      	movs	r3, #0
    a728:	9304      	str	r3, [sp, #16]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    a72a:	2300      	movs	r3, #0
    a72c:	9303      	str	r3, [sp, #12]

    u32CoreId = Can_GetCoreID();
    a72e:	2300      	movs	r3, #0
    a730:	9304      	str	r3, [sp, #16]
                    (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_GET_CONTROLLER_TX_ERROR_COUNTER, CAN_43_FLEXCAN_E_PARAM_POINTER);
                }
                else
                {
#endif /* CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON */
                    Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[ControllerId];
    a732:	4a0c      	ldr	r2, [pc, #48]	; (a764 <Can_43_FLEXCAN_GetControllerTxErrorCounter+0x50>)
    a734:	9b04      	ldr	r3, [sp, #16]
    a736:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a73a:	695a      	ldr	r2, [r3, #20]
    a73c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a740:	009b      	lsls	r3, r3, #2
    a742:	4413      	add	r3, r2
    a744:	681b      	ldr	r3, [r3, #0]
    a746:	9303      	str	r3, [sp, #12]
                    /*
                    *   [SWS_Can_00520]: When the API Can_GetControllerTxErrorCounter is called with
                    *   Controller Id as input parameter then Can driver shall read the Tx error counter
                    *   register of Can Controller and shall return the Tx error count to upper layer.
                    */
                    eRetVal = Can_43_FLEXCAN_Ipw_GetControllerTxErrorCounter(Can_pController, TxErrorCounterPtr);
    a748:	9900      	ldr	r1, [sp, #0]
    a74a:	9803      	ldr	r0, [sp, #12]
    a74c:	f000 ff7d 	bl	b64a <Can_43_FLEXCAN_Ipw_GetControllerTxErrorCounter>
    a750:	4603      	mov	r3, r0
    a752:	f88d 3017 	strb.w	r3, [sp, #23]
            }
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
        }
    }
#endif
    return eRetVal;
    a756:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    a75a:	4618      	mov	r0, r3
    a75c:	b007      	add	sp, #28
    a75e:	f85d fb04 	ldr.w	pc, [sp], #4
    a762:	bf00      	nop
    a764:	1fff8e18 	.word	0x1fff8e18

0000a768 <Can_43_FLEXCAN_Write>:
Std_ReturnType Can_43_FLEXCAN_Write
(
    Can_HwHandleType Hth,
    const Can_PduType * PduInfo
)
{
    a768:	b500      	push	{lr}
    a76a:	b089      	sub	sp, #36	; 0x24
    a76c:	4603      	mov	r3, r0
    a76e:	9100      	str	r1, [sp, #0]
    a770:	f8ad 3006 	strh.w	r3, [sp, #6]
    Std_ReturnType eRetVal = E_NOT_OK;
    a774:	2301      	movs	r3, #1
    a776:	f88d 301f 	strb.w	r3, [sp, #31]
    uint8 u8ControllerID = 0U;
    a77a:	2300      	movs	r3, #0
    a77c:	f88d 301e 	strb.w	r3, [sp, #30]
    uint32 u32CoreId = 0U;
    a780:	2300      	movs	r3, #0
    a782:	9306      	str	r3, [sp, #24]
    Can_HwHandleType HwObjectID = 0U;
    a784:	2300      	movs	r3, #0
    a786:	f8ad 3016 	strh.w	r3, [sp, #22]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    a78a:	2300      	movs	r3, #0
    a78c:	9304      	str	r3, [sp, #16]
    const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject = NULL_PTR;
    a78e:	2300      	movs	r3, #0
    a790:	9303      	str	r3, [sp, #12]

    u32CoreId = Can_GetCoreID();
    a792:	2300      	movs	r3, #0
    a794:	9306      	str	r3, [sp, #24]
    HwObjectID = Hth;
    a796:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    a79a:	f8ad 3016 	strh.w	r3, [sp, #22]
                (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_WRITE, CAN_43_FLEXCAN_E_PARAM_POINTER);
            }
            else
            {
#endif /* CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON */
                u8ControllerID = (Can_apxConfig[u32CoreId])->Can_pHwObjIDToCtrlIDMap[HwObjectID];
    a79e:	4a1d      	ldr	r2, [pc, #116]	; (a814 <Can_43_FLEXCAN_Write+0xac>)
    a7a0:	9b06      	ldr	r3, [sp, #24]
    a7a2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a7a6:	68da      	ldr	r2, [r3, #12]
    a7a8:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    a7ac:	4413      	add	r3, r2
    a7ae:	781b      	ldrb	r3, [r3, #0]
    a7b0:	f88d 301e 	strb.w	r3, [sp, #30]
                Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID];
    a7b4:	4a17      	ldr	r2, [pc, #92]	; (a814 <Can_43_FLEXCAN_Write+0xac>)
    a7b6:	9b06      	ldr	r3, [sp, #24]
    a7b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a7bc:	695a      	ldr	r2, [r3, #20]
    a7be:	f89d 301e 	ldrb.w	r3, [sp, #30]
    a7c2:	009b      	lsls	r3, r3, #2
    a7c4:	4413      	add	r3, r2
    a7c6:	681b      	ldr	r3, [r3, #0]
    a7c8:	9304      	str	r3, [sp, #16]
                if (NULL_PTR != Can_pController)
    a7ca:	9b04      	ldr	r3, [sp, #16]
    a7cc:	2b00      	cmp	r3, #0
    a7ce:	d01b      	beq.n	a808 <Can_43_FLEXCAN_Write+0xa0>
                {
                    Can_pHwObject = &((Can_apxConfig[u32CoreId])->Can_pHwObjectConfig[HwObjectID]);
    a7d0:	4a10      	ldr	r2, [pc, #64]	; (a814 <Can_43_FLEXCAN_Write+0xac>)
    a7d2:	9b06      	ldr	r3, [sp, #24]
    a7d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a7d8:	6919      	ldr	r1, [r3, #16]
    a7da:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    a7de:	4613      	mov	r3, r2
    a7e0:	00db      	lsls	r3, r3, #3
    a7e2:	4413      	add	r3, r2
    a7e4:	009b      	lsls	r3, r3, #2
    a7e6:	440b      	add	r3, r1
    a7e8:	9303      	str	r3, [sp, #12]
                #if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
                    if ((TRUE == Can_ValidatePdu(Can_pController, Can_pHwObject, PduInfo)) && (CAN_CS_STARTED == Can_eControllerState[u8ControllerID]))
                #else
                    /* avoid unexpected behaviour when accessing to RAM */
                    if (CAN_CS_STARTED == Can_eControllerState[u8ControllerID])
    a7ea:	f89d 301e 	ldrb.w	r3, [sp, #30]
    a7ee:	4a0a      	ldr	r2, [pc, #40]	; (a818 <Can_43_FLEXCAN_Write+0xb0>)
    a7f0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a7f4:	2b01      	cmp	r3, #1
    a7f6:	d107      	bne.n	a808 <Can_43_FLEXCAN_Write+0xa0>
                            eRetVal = CAN_BUSY;
                        }
                        else
                        {
                    #endif
                            eRetVal = Can_43_FLEXCAN_Ipw_Write(Can_pController, Can_pHwObject, PduInfo);
    a7f8:	9a00      	ldr	r2, [sp, #0]
    a7fa:	9903      	ldr	r1, [sp, #12]
    a7fc:	9804      	ldr	r0, [sp, #16]
    a7fe:	f000 ff48 	bl	b692 <Can_43_FLEXCAN_Ipw_Write>
    a802:	4603      	mov	r3, r0
    a804:	f88d 301f 	strb.w	r3, [sp, #31]
                }
            #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
            }
    }
#endif
    return eRetVal;
    a808:	f89d 301f 	ldrb.w	r3, [sp, #31]
}
    a80c:	4618      	mov	r0, r3
    a80e:	b009      	add	sp, #36	; 0x24
    a810:	f85d fb04 	ldr.w	pc, [sp], #4
    a814:	1fff8e18 	.word	0x1fff8e18
    a818:	1fff8e10 	.word	0x1fff8e10

0000a81c <Can_43_FLEXCAN_MainFunction_Write>:
                HwObjectID++;
            }
#endif /* (CAN_43_FLEXCAN_USE_CANEXCEL_IP  == STD_ON) */
        }
    #endif /* CAN_43_FLEXCAN_TX_POLLING_SUPPORT == STD_ON */
    }
    a81c:	bf00      	nop
    a81e:	4770      	bx	lr

0000a820 <Can_43_FLEXCAN_MainFunction_Read>:
                HwObjectID++;
            }
#endif /* (CAN_43_FLEXCAN_USE_CANEXCEL_IP  == STD_ON) */
        }
    #endif /* CAN_43_FLEXCAN_RX_POLLING_SUPPORT == STD_ON */
    }
    a820:	bf00      	nop
    a822:	4770      	bx	lr

0000a824 <Can_43_FLEXCAN_MainFunction_BusOff>:
            }
            u8ControllerID++;
        }
    }
#endif /* CAN_43_FLEXCAN_BUSOFF_POLLING_SUPPORT == STD_ON */
}
    a824:	bf00      	nop
    a826:	4770      	bx	lr

0000a828 <Can_43_FLEXCAN_MainFunction_Mode>:
*
* @api
*/
/* implements     Can_MainFunction_Mode_Activity */
void Can_43_FLEXCAN_MainFunction_Mode(void)
{
    a828:	b500      	push	{lr}
    a82a:	b085      	sub	sp, #20
    uint8 u8ControllerID = 0U;
    a82c:	2300      	movs	r3, #0
    a82e:	f88d 300f 	strb.w	r3, [sp, #15]
    uint32 u32CoreId = 0U;
    a832:	2300      	movs	r3, #0
    a834:	9302      	str	r3, [sp, #8]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    a836:	2300      	movs	r3, #0
    a838:	9301      	str	r3, [sp, #4]

    u32CoreId = Can_GetCoreID();
    a83a:	2300      	movs	r3, #0
    a83c:	9302      	str	r3, [sp, #8]
    if (NULL_PTR != (Can_apxConfig[u32CoreId]))
    a83e:	4a17      	ldr	r2, [pc, #92]	; (a89c <Can_43_FLEXCAN_MainFunction_Mode+0x74>)
    a840:	9b02      	ldr	r3, [sp, #8]
    a842:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a846:	2b00      	cmp	r3, #0
    a848:	d024      	beq.n	a894 <Can_43_FLEXCAN_MainFunction_Mode+0x6c>
    {
        while (u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT)
    a84a:	e01f      	b.n	a88c <Can_43_FLEXCAN_MainFunction_Mode+0x64>
        {
            Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID];
    a84c:	4a13      	ldr	r2, [pc, #76]	; (a89c <Can_43_FLEXCAN_MainFunction_Mode+0x74>)
    a84e:	9b02      	ldr	r3, [sp, #8]
    a850:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a854:	695a      	ldr	r2, [r3, #20]
    a856:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a85a:	009b      	lsls	r3, r3, #2
    a85c:	4413      	add	r3, r2
    a85e:	681b      	ldr	r3, [r3, #0]
    a860:	9301      	str	r3, [sp, #4]
            if (NULL_PTR != Can_pController)
    a862:	9b01      	ldr	r3, [sp, #4]
    a864:	2b00      	cmp	r3, #0
    a866:	d00c      	beq.n	a882 <Can_43_FLEXCAN_MainFunction_Mode+0x5a>
            {
                if (TRUE == Can_pController->Can_bActivation)
    a868:	9b01      	ldr	r3, [sp, #4]
    a86a:	7a1b      	ldrb	r3, [r3, #8]
    a86c:	2b00      	cmp	r3, #0
    a86e:	d008      	beq.n	a882 <Can_43_FLEXCAN_MainFunction_Mode+0x5a>
                {
                    Can_43_FLEXCAN_Ipw_MainFunction_Mode(Can_pController, &Can_eControllerState[u8ControllerID]);
    a870:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a874:	009b      	lsls	r3, r3, #2
    a876:	4a0a      	ldr	r2, [pc, #40]	; (a8a0 <Can_43_FLEXCAN_MainFunction_Mode+0x78>)
    a878:	4413      	add	r3, r2
    a87a:	4619      	mov	r1, r3
    a87c:	9801      	ldr	r0, [sp, #4]
    a87e:	f001 f808 	bl	b892 <Can_43_FLEXCAN_Ipw_MainFunction_Mode>
                }
            }
            u8ControllerID++;
    a882:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a886:	3301      	adds	r3, #1
    a888:	f88d 300f 	strb.w	r3, [sp, #15]
        while (u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT)
    a88c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a890:	2b01      	cmp	r3, #1
    a892:	d9db      	bls.n	a84c <Can_43_FLEXCAN_MainFunction_Mode+0x24>
        }
    }
}
    a894:	bf00      	nop
    a896:	b005      	add	sp, #20
    a898:	f85d fb04 	ldr.w	pc, [sp], #4
    a89c:	1fff8e18 	.word	0x1fff8e18
    a8a0:	1fff8e10 	.word	0x1fff8e10

0000a8a4 <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt>:
(
    uint8 u8CtrlOffset,
    uint8 u8MbIdx,
    Can_43_FLEXCAN_MbType mbType
)
{
    a8a4:	b500      	push	{lr}
    a8a6:	b087      	sub	sp, #28
    a8a8:	4603      	mov	r3, r0
    a8aa:	9200      	str	r2, [sp, #0]
    a8ac:	f88d 3007 	strb.w	r3, [sp, #7]
    a8b0:	460b      	mov	r3, r1
    a8b2:	f88d 3006 	strb.w	r3, [sp, #6]
    uint8 u8ControllerID = 0U;
    a8b6:	2300      	movs	r3, #0
    a8b8:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32 u32CoreId = 0U;
    a8bc:	2300      	movs	r3, #0
    a8be:	9304      	str	r3, [sp, #16]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    a8c0:	2300      	movs	r3, #0
    a8c2:	9303      	str	r3, [sp, #12]

    MCAL_FAULT_INJECTION_POINT(CAN_FIP_2_CHANGE_DRIVER_TO_UNINITIALIZED);
    u32CoreId = Can_GetCoreID();
    a8c4:	2300      	movs	r3, #0
    a8c6:	9304      	str	r3, [sp, #16]
    if (NULL_PTR != Can_apxConfig[u32CoreId])
    a8c8:	4a16      	ldr	r2, [pc, #88]	; (a924 <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt+0x80>)
    a8ca:	9b04      	ldr	r3, [sp, #16]
    a8cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a8d0:	2b00      	cmp	r3, #0
    a8d2:	d022      	beq.n	a91a <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt+0x76>
    {
        u8ControllerID = (Can_apxConfig[u32CoreId])->Can_pCtrlOffsetToCtrlIDMap[u8CtrlOffset];
    a8d4:	4a13      	ldr	r2, [pc, #76]	; (a924 <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt+0x80>)
    a8d6:	9b04      	ldr	r3, [sp, #16]
    a8d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a8dc:	689a      	ldr	r2, [r3, #8]
    a8de:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a8e2:	4413      	add	r3, r2
    a8e4:	781b      	ldrb	r3, [r3, #0]
    a8e6:	f88d 3017 	strb.w	r3, [sp, #23]
        Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID];
    a8ea:	4a0e      	ldr	r2, [pc, #56]	; (a924 <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt+0x80>)
    a8ec:	9b04      	ldr	r3, [sp, #16]
    a8ee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a8f2:	695a      	ldr	r2, [r3, #20]
    a8f4:	f89d 3017 	ldrb.w	r3, [sp, #23]
    a8f8:	009b      	lsls	r3, r3, #2
    a8fa:	4413      	add	r3, r2
    a8fc:	681b      	ldr	r3, [r3, #0]
    a8fe:	9303      	str	r3, [sp, #12]
        if (NULL_PTR != Can_pController)
    a900:	9b03      	ldr	r3, [sp, #12]
    a902:	2b00      	cmp	r3, #0
    a904:	d009      	beq.n	a91a <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt+0x76>
        {
            Can_43_FLEXCAN_Ipw_ProcessHwObject(Can_pController, (Can_apxConfig[u32CoreId]), u8MbIdx, mbType);
    a906:	4a07      	ldr	r2, [pc, #28]	; (a924 <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt+0x80>)
    a908:	9b04      	ldr	r3, [sp, #16]
    a90a:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    a90e:	f89d 2006 	ldrb.w	r2, [sp, #6]
    a912:	9b00      	ldr	r3, [sp, #0]
    a914:	9803      	ldr	r0, [sp, #12]
    a916:	f000 fff2 	bl	b8fe <Can_43_FLEXCAN_Ipw_ProcessHwObject>
        }

    }
}
    a91a:	bf00      	nop
    a91c:	b007      	add	sp, #28
    a91e:	f85d fb04 	ldr.w	pc, [sp], #4
    a922:	bf00      	nop
    a924:	1fff8e18 	.word	0x1fff8e18

0000a928 <Can_43_FLEXCAN_ProcessBusOffInterrupt>:
*/
void Can_43_FLEXCAN_ProcessBusOffInterrupt
(
    uint8 u8CtrlOffset
)
{
    a928:	b500      	push	{lr}
    a92a:	b087      	sub	sp, #28
    a92c:	4603      	mov	r3, r0
    a92e:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 u8ControllerID = 0U;
    a932:	2300      	movs	r3, #0
    a934:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32 u32CoreId = 0U;
    a938:	2300      	movs	r3, #0
    a93a:	9304      	str	r3, [sp, #16]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    a93c:	2300      	movs	r3, #0
    a93e:	9303      	str	r3, [sp, #12]

    u32CoreId = Can_GetCoreID();
    a940:	2300      	movs	r3, #0
    a942:	9304      	str	r3, [sp, #16]
    if (NULL_PTR != Can_apxConfig[u32CoreId])
    a944:	4a19      	ldr	r2, [pc, #100]	; (a9ac <Can_43_FLEXCAN_ProcessBusOffInterrupt+0x84>)
    a946:	9b04      	ldr	r3, [sp, #16]
    a948:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a94c:	2b00      	cmp	r3, #0
    a94e:	d029      	beq.n	a9a4 <Can_43_FLEXCAN_ProcessBusOffInterrupt+0x7c>
    {
        u8ControllerID = (Can_apxConfig[u32CoreId])->Can_pCtrlOffsetToCtrlIDMap[u8CtrlOffset];
    a950:	4a16      	ldr	r2, [pc, #88]	; (a9ac <Can_43_FLEXCAN_ProcessBusOffInterrupt+0x84>)
    a952:	9b04      	ldr	r3, [sp, #16]
    a954:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a958:	689a      	ldr	r2, [r3, #8]
    a95a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a95e:	4413      	add	r3, r2
    a960:	781b      	ldrb	r3, [r3, #0]
    a962:	f88d 3017 	strb.w	r3, [sp, #23]
        Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID];
    a966:	4a11      	ldr	r2, [pc, #68]	; (a9ac <Can_43_FLEXCAN_ProcessBusOffInterrupt+0x84>)
    a968:	9b04      	ldr	r3, [sp, #16]
    a96a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a96e:	695a      	ldr	r2, [r3, #20]
    a970:	f89d 3017 	ldrb.w	r3, [sp, #23]
    a974:	009b      	lsls	r3, r3, #2
    a976:	4413      	add	r3, r2
    a978:	681b      	ldr	r3, [r3, #0]
    a97a:	9303      	str	r3, [sp, #12]
        if (NULL_PTR != Can_pController)
    a97c:	9b03      	ldr	r3, [sp, #12]
    a97e:	2b00      	cmp	r3, #0
    a980:	d010      	beq.n	a9a4 <Can_43_FLEXCAN_ProcessBusOffInterrupt+0x7c>
        {
            if ((Std_ReturnType)E_OK == Can_43_FLEXCAN_Ipw_SetControllerToStopMode(Can_pController))
    a982:	9803      	ldr	r0, [sp, #12]
    a984:	f000 fd74 	bl	b470 <Can_43_FLEXCAN_Ipw_SetControllerToStopMode>
    a988:	4603      	mov	r3, r0
    a98a:	2b00      	cmp	r3, #0
    a98c:	d10a      	bne.n	a9a4 <Can_43_FLEXCAN_ProcessBusOffInterrupt+0x7c>
            {
                Can_eControllerState[u8ControllerID] = CAN_CS_STOPPED;
    a98e:	f89d 3017 	ldrb.w	r3, [sp, #23]
    a992:	4a07      	ldr	r2, [pc, #28]	; (a9b0 <Can_43_FLEXCAN_ProcessBusOffInterrupt+0x88>)
    a994:	2102      	movs	r1, #2
    a996:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                CanIf_ControllerBusOff(Can_pController->Can_u8AbstControllerID);
    a99a:	9b03      	ldr	r3, [sp, #12]
    a99c:	781b      	ldrb	r3, [r3, #0]
    a99e:	4618      	mov	r0, r3
    a9a0:	f00c fbfc 	bl	1719c <CanIf_ControllerBusOff>
            }
        }
    }
}
    a9a4:	bf00      	nop
    a9a6:	b007      	add	sp, #28
    a9a8:	f85d fb04 	ldr.w	pc, [sp], #4
    a9ac:	1fff8e18 	.word	0x1fff8e18
    a9b0:	1fff8e10 	.word	0x1fff8e10

0000a9b4 <Can_Ipw_ParseData>:
    PduInfoType * CanIf_PduInfo,
    Flexcan_Ip_MsgBuffType * pReceivedDataBuffer,
    const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig,
    const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObjectConfig
)
{
    a9b4:	b500      	push	{lr}
    a9b6:	b085      	sub	sp, #20
    a9b8:	9003      	str	r0, [sp, #12]
    a9ba:	9102      	str	r1, [sp, #8]
    a9bc:	9201      	str	r2, [sp, #4]
    a9be:	9300      	str	r3, [sp, #0]
    CanIf_Mailbox->CanId = pReceivedDataBuffer->msgId;
    a9c0:	9b01      	ldr	r3, [sp, #4]
    a9c2:	685a      	ldr	r2, [r3, #4]
    a9c4:	9b03      	ldr	r3, [sp, #12]
    a9c6:	601a      	str	r2, [r3, #0]
    * convert the ID to a standardized format since the Upper layer (CANIF) does not know
    * whether the received CAN frame is a Standard CAN frame or Extended CAN frame.
    * In case of an Extended CAN frame, MSB of a received CAN frame ID needs to be
    * made as ‘1’ to mark the received CAN frame as Extended.⌋
    */
    if (((pReceivedDataBuffer->cs) & CAN_IPW_CS_IDE_MASK) != 0U)
    a9c8:	9b01      	ldr	r3, [sp, #4]
    a9ca:	681b      	ldr	r3, [r3, #0]
    a9cc:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
    a9d0:	2b00      	cmp	r3, #0
    a9d2:	d005      	beq.n	a9e0 <Can_Ipw_ParseData+0x2c>
    {
        CanIf_Mailbox->CanId |= (uint32)0x80000000U;
    a9d4:	9b03      	ldr	r3, [sp, #12]
    a9d6:	681b      	ldr	r3, [r3, #0]
    a9d8:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
    a9dc:	9b03      	ldr	r3, [sp, #12]
    a9de:	601a      	str	r2, [r3, #0]
    }

    if (CAN_RX_NORMAL == Can_pHwObjectConfig->Can_eReceiveType)
    a9e0:	9b06      	ldr	r3, [sp, #24]
    a9e2:	699b      	ldr	r3, [r3, #24]
    a9e4:	2b00      	cmp	r3, #0
    a9e6:	d10c      	bne.n	aa02 <Can_Ipw_ParseData+0x4e>
    {
        /* Check if Mb Overrun */
        if ((uint32)(0x06000000U) == (pReceivedDataBuffer->cs & CAN_IPW_CS_CODE_MASK))
    a9e8:	9b01      	ldr	r3, [sp, #4]
    a9ea:	681b      	ldr	r3, [r3, #0]
    a9ec:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    a9f0:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
    a9f4:	d105      	bne.n	aa02 <Can_Ipw_ParseData+0x4e>
        {
            (void)Det_ReportRuntimeError((uint16)CAN_43_FLEXCAN_IPW_MODULE_ID, (uint8)CAN_43_FLEXCAN_INSTANCE, (uint8)CAN_43_FLEXCAN_SID_MAIN_FUNCTION_READ, (uint8)CAN_43_FLEXCAN_E_DATALOST);
    a9f6:	2301      	movs	r3, #1
    a9f8:	2208      	movs	r2, #8
    a9fa:	2100      	movs	r1, #0
    a9fc:	2050      	movs	r0, #80	; 0x50
    a9fe:	f00c fa2d 	bl	16e5c <Det_ReportRuntimeError>
        }
    }

    /* when legacy fifo enabled, FD must be disabled */
    if (CAN_RX_LEGACY_FIFO != Can_pHwObjectConfig->Can_eReceiveType)
    aa02:	9b06      	ldr	r3, [sp, #24]
    aa04:	699b      	ldr	r3, [r3, #24]
    aa06:	2b01      	cmp	r3, #1
    aa08:	d009      	beq.n	aa1e <Can_Ipw_ParseData+0x6a>
    {
        /*
        * [SWS_Can_00501] ⌈ CanDrv shall indicate whether the received message is a
        * conventional CAN frame or a CAN FD frame as described in Can_IdType.⌋
        */
        if (((pReceivedDataBuffer->cs) & CAN_IPW_CS_EDL_MASK) != 0U)
    aa0a:	9b01      	ldr	r3, [sp, #4]
    aa0c:	681b      	ldr	r3, [r3, #0]
    aa0e:	2b00      	cmp	r3, #0
    aa10:	da05      	bge.n	aa1e <Can_Ipw_ParseData+0x6a>
        {
            CanIf_Mailbox->CanId |= (uint32)0x40000000U;
    aa12:	9b03      	ldr	r3, [sp, #12]
    aa14:	681b      	ldr	r3, [r3, #0]
    aa16:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
    aa1a:	9b03      	ldr	r3, [sp, #12]
    aa1c:	601a      	str	r2, [r3, #0]
        }
    }

    if (Can_pHwObjectConfig->Can_u8PayloadLength <= pReceivedDataBuffer->dataLen)
    aa1e:	9b06      	ldr	r3, [sp, #24]
    aa20:	7c1a      	ldrb	r2, [r3, #16]
    aa22:	9b01      	ldr	r3, [sp, #4]
    aa24:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
    aa28:	429a      	cmp	r2, r3
    aa2a:	d805      	bhi.n	aa38 <Can_Ipw_ParseData+0x84>
    {
        CanIf_PduInfo->SduLength = Can_pHwObjectConfig->Can_u8PayloadLength;
    aa2c:	9b06      	ldr	r3, [sp, #24]
    aa2e:	7c1b      	ldrb	r3, [r3, #16]
    aa30:	461a      	mov	r2, r3
    aa32:	9b02      	ldr	r3, [sp, #8]
    aa34:	609a      	str	r2, [r3, #8]
    aa36:	e005      	b.n	aa44 <Can_Ipw_ParseData+0x90>
    }
    else
    {
        CanIf_PduInfo->SduLength = pReceivedDataBuffer->dataLen;
    aa38:	9b01      	ldr	r3, [sp, #4]
    aa3a:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
    aa3e:	461a      	mov	r2, r3
    aa40:	9b02      	ldr	r3, [sp, #8]
    aa42:	609a      	str	r2, [r3, #8]
                                                      CanIf_PduInfo->SduLength, \
                                                      &pReceivedDataBuffer->data[0]) \
                                                     )
    {
#endif
    CanIf_Mailbox->Hoh = Can_pHwObjectConfig->Can_HwObjectID;
    aa44:	9b06      	ldr	r3, [sp, #24]
    aa46:	881a      	ldrh	r2, [r3, #0]
    aa48:	9b03      	ldr	r3, [sp, #12]
    aa4a:	809a      	strh	r2, [r3, #4]
    CanIf_Mailbox->ControllerId = Can_pControllerConfig->Can_u8AbstControllerID;
    aa4c:	9b00      	ldr	r3, [sp, #0]
    aa4e:	781a      	ldrb	r2, [r3, #0]
    aa50:	9b03      	ldr	r3, [sp, #12]
    aa52:	719a      	strb	r2, [r3, #6]
    CanIf_PduInfo->SduDataPtr = &pReceivedDataBuffer->data[0];
    aa54:	9b01      	ldr	r3, [sp, #4]
    aa56:	f103 0208 	add.w	r2, r3, #8
    aa5a:	9b02      	ldr	r3, [sp, #8]
    aa5c:	601a      	str	r2, [r3, #0]
    CanIf_RxIndication(CanIf_Mailbox, CanIf_PduInfo);
    aa5e:	9902      	ldr	r1, [sp, #8]
    aa60:	9803      	ldr	r0, [sp, #12]
    aa62:	f00c fb29 	bl	170b8 <CanIf_RxIndication>
#if (CAN_43_FLEXCAN_LPDU_CALLOUT_SUPPORT == STD_ON)
    }
#endif
}
    aa66:	bf00      	nop
    aa68:	b005      	add	sp, #20
    aa6a:	f85d fb04 	ldr.w	pc, [sp], #4

0000aa6e <Can_Ipw_InitLegacyFifoFilter>:

static void Can_Ipw_InitLegacyFifoFilter(const Can_43_FLEXCAN_ControllerConfigType * Can_pController, const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject)
{
    aa6e:	b500      	push	{lr}
    aa70:	f2ad 4d1c 	subw	sp, sp, #1052	; 0x41c
    aa74:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    aa78:	f2a3 4314 	subw	r3, r3, #1044	; 0x414
    aa7c:	6018      	str	r0, [r3, #0]
    aa7e:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    aa82:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    aa86:	6019      	str	r1, [r3, #0]
    uint8 u8FilterIdx=0U;
    aa88:	2300      	movs	r3, #0
    aa8a:	f88d 3417 	strb.w	r3, [sp, #1047]	; 0x417
    uint8 u8HwFilterCount = 0U;
    aa8e:	2300      	movs	r3, #0
    aa90:	f88d 3416 	strb.w	r3, [sp, #1046]	; 0x416
    uint32 u32HwFilterMask = (uint32)0x00000000U;
    aa94:	2300      	movs	r3, #0
    aa96:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
    /* The max FIFO id filter affected by Rx individual masks*/
    uint8 u8FiFoFilterIndvCount = 0U;
    aa9a:	2300      	movs	r3, #0
    aa9c:	f88d 340f 	strb.w	r3, [sp, #1039]	; 0x40f
    Flexcan_Ip_RxFifoIdElementFormatType eElementFormat = FLEXCAN_RX_FIFO_ID_FORMAT_A;
    aaa0:	2300      	movs	r3, #0
    aaa2:	f8cd 3408 	str.w	r3, [sp, #1032]	; 0x408
    /* Need to alocate a filter array with elemnets no as defined in HwObject */
    Flexcan_Ip_IdTableType RxFifoFilters[128];

    if (((Can_pHwObject->Can_u8HwFilterCount / 4U) + 6U) <= 32U)
    aaa6:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    aaaa:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    aaae:	681b      	ldr	r3, [r3, #0]
    aab0:	7c9b      	ldrb	r3, [r3, #18]
    aab2:	089b      	lsrs	r3, r3, #2
    aab4:	b2db      	uxtb	r3, r3
    aab6:	3306      	adds	r3, #6
    aab8:	2b20      	cmp	r3, #32
    aaba:	d80b      	bhi.n	aad4 <Can_Ipw_InitLegacyFifoFilter+0x66>
    {
        u8FiFoFilterIndvCount = (Can_pHwObject->Can_u8HwFilterCount / 4U) + 6U;
    aabc:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    aac0:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    aac4:	681b      	ldr	r3, [r3, #0]
    aac6:	7c9b      	ldrb	r3, [r3, #18]
    aac8:	089b      	lsrs	r3, r3, #2
    aaca:	b2db      	uxtb	r3, r3
    aacc:	3306      	adds	r3, #6
    aace:	f88d 340f 	strb.w	r3, [sp, #1039]	; 0x40f
    aad2:	e002      	b.n	aada <Can_Ipw_InitLegacyFifoFilter+0x6c>
    }
    else
    {
        u8FiFoFilterIndvCount = 32U;
    aad4:	2320      	movs	r3, #32
    aad6:	f88d 340f 	strb.w	r3, [sp, #1039]	; 0x40f
    }
    for (u8FilterIdx=0U; ((u8FilterIdx < u8FiFoFilterIndvCount) && (u8FilterIdx < Can_pHwObject->Can_u8HwFilterCount)); u8FilterIdx++)
    aada:	2300      	movs	r3, #0
    aadc:	f88d 3417 	strb.w	r3, [sp, #1047]	; 0x417
    aae0:	e169      	b.n	adb6 <Can_Ipw_InitLegacyFifoFilter+0x348>
    {
            if (CAN_LEGACY_FIFO_FORMAT_A == Can_pController->Can_eLegacyAcceptanceMode)
    aae2:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    aae6:	f2a3 4314 	subw	r3, r3, #1044	; 0x414
    aaea:	681b      	ldr	r3, [r3, #0]
    aaec:	691b      	ldr	r3, [r3, #16]
    aaee:	2b00      	cmp	r3, #0
    aaf0:	d13a      	bne.n	ab68 <Can_Ipw_InitLegacyFifoFilter+0xfa>
            {
                u8HwFilterCount =  Can_pHwObject->Can_u8HwFilterCount;
    aaf2:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    aaf6:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    aafa:	681b      	ldr	r3, [r3, #0]
    aafc:	7c9b      	ldrb	r3, [r3, #18]
    aafe:	f88d 3416 	strb.w	r3, [sp, #1046]	; 0x416
                u32HwFilterMask = (uint32)0xC0000000U;
    ab02:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
    ab06:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                eElementFormat = FLEXCAN_RX_FIFO_ID_FORMAT_A;
    ab0a:	2300      	movs	r3, #0
    ab0c:	f8cd 3408 	str.w	r3, [sp, #1032]	; 0x408
                if (Can_pHwObject->Can_IdMessage != CAN_STANDARD)
    ab10:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    ab14:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    ab18:	681b      	ldr	r3, [r3, #0]
    ab1a:	689b      	ldr	r3, [r3, #8]
    ab1c:	2b00      	cmp	r3, #0
    ab1e:	d011      	beq.n	ab44 <Can_Ipw_InitLegacyFifoFilter+0xd6>
                {
                    u32HwFilterMask |= Can_pHwObject->Can_pHwFilterConfig[u8FilterIdx].Can_u32HwFilterMask << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATA_EXT_SHIFT;
    ab20:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    ab24:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    ab28:	681b      	ldr	r3, [r3, #0]
    ab2a:	695a      	ldr	r2, [r3, #20]
    ab2c:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    ab30:	00db      	lsls	r3, r3, #3
    ab32:	4413      	add	r3, r2
    ab34:	685b      	ldr	r3, [r3, #4]
    ab36:	005b      	lsls	r3, r3, #1
    ab38:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    ab3c:	4313      	orrs	r3, r2
    ab3e:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
    ab42:	e126      	b.n	ad92 <Can_Ipw_InitLegacyFifoFilter+0x324>
                }
                else
                {
                    u32HwFilterMask |= Can_pHwObject->Can_pHwFilterConfig[u8FilterIdx].Can_u32HwFilterMask << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATA_STD_SHIFT;
    ab44:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    ab48:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    ab4c:	681b      	ldr	r3, [r3, #0]
    ab4e:	695a      	ldr	r2, [r3, #20]
    ab50:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    ab54:	00db      	lsls	r3, r3, #3
    ab56:	4413      	add	r3, r2
    ab58:	685b      	ldr	r3, [r3, #4]
    ab5a:	04db      	lsls	r3, r3, #19
    ab5c:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    ab60:	4313      	orrs	r3, r2
    ab62:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
    ab66:	e114      	b.n	ad92 <Can_Ipw_InitLegacyFifoFilter+0x324>
                }
            }
            else if (CAN_LEGACY_FIFO_FORMAT_B == Can_pController->Can_eLegacyAcceptanceMode)
    ab68:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    ab6c:	f2a3 4314 	subw	r3, r3, #1044	; 0x414
    ab70:	681b      	ldr	r3, [r3, #0]
    ab72:	691b      	ldr	r3, [r3, #16]
    ab74:	2b01      	cmp	r3, #1
    ab76:	d160      	bne.n	ac3a <Can_Ipw_InitLegacyFifoFilter+0x1cc>
            {
                u8HwFilterCount = Can_pHwObject->Can_u8HwFilterCount * 2U ;
    ab78:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    ab7c:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    ab80:	681b      	ldr	r3, [r3, #0]
    ab82:	7c9b      	ldrb	r3, [r3, #18]
    ab84:	005b      	lsls	r3, r3, #1
    ab86:	f88d 3416 	strb.w	r3, [sp, #1046]	; 0x416
                u32HwFilterMask = (uint32)0xC000C000U;
    ab8a:	f04f 23c0 	mov.w	r3, #3221274624	; 0xc000c000
    ab8e:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                eElementFormat = FLEXCAN_RX_FIFO_ID_FORMAT_B;
    ab92:	2301      	movs	r3, #1
    ab94:	f8cd 3408 	str.w	r3, [sp, #1032]	; 0x408
                if (Can_pHwObject->Can_IdMessage != CAN_STANDARD)
    ab98:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    ab9c:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    aba0:	681b      	ldr	r3, [r3, #0]
    aba2:	689b      	ldr	r3, [r3, #8]
    aba4:	2b00      	cmp	r3, #0
    aba6:	d024      	beq.n	abf2 <Can_Ipw_InitLegacyFifoFilter+0x184>
                {
                    u32HwFilterMask |= (Can_pHwObject->Can_pHwFilterConfig[u8FilterIdx * 2U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATB_EXT_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATB_EXT_SHIFT1;
    aba8:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    abac:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    abb0:	681b      	ldr	r3, [r3, #0]
    abb2:	695a      	ldr	r2, [r3, #20]
    abb4:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    abb8:	011b      	lsls	r3, r3, #4
    abba:	4413      	add	r3, r2
    abbc:	685b      	ldr	r3, [r3, #4]
    abbe:	0bdb      	lsrs	r3, r3, #15
    abc0:	041b      	lsls	r3, r3, #16
    abc2:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    abc6:	4313      	orrs	r3, r2
    abc8:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= (Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 2U) + 1U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATB_EXT_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATB_EXT_SHIFT2;
    abcc:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    abd0:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    abd4:	681b      	ldr	r3, [r3, #0]
    abd6:	695a      	ldr	r2, [r3, #20]
    abd8:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    abdc:	011b      	lsls	r3, r3, #4
    abde:	3308      	adds	r3, #8
    abe0:	4413      	add	r3, r2
    abe2:	685b      	ldr	r3, [r3, #4]
    abe4:	0bdb      	lsrs	r3, r3, #15
    abe6:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    abea:	4313      	orrs	r3, r2
    abec:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
    abf0:	e0cf      	b.n	ad92 <Can_Ipw_InitLegacyFifoFilter+0x324>
                }
                else
                {
                    u32HwFilterMask |= Can_pHwObject->Can_pHwFilterConfig[u8FilterIdx * 2U].Can_u32HwFilterMask << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATB_STD_SHIFT1;
    abf2:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    abf6:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    abfa:	681b      	ldr	r3, [r3, #0]
    abfc:	695a      	ldr	r2, [r3, #20]
    abfe:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    ac02:	011b      	lsls	r3, r3, #4
    ac04:	4413      	add	r3, r2
    ac06:	685b      	ldr	r3, [r3, #4]
    ac08:	04db      	lsls	r3, r3, #19
    ac0a:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    ac0e:	4313      	orrs	r3, r2
    ac10:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 2U) + 1U].Can_u32HwFilterMask << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATB_STD_SHIFT2;
    ac14:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    ac18:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    ac1c:	681b      	ldr	r3, [r3, #0]
    ac1e:	695a      	ldr	r2, [r3, #20]
    ac20:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    ac24:	011b      	lsls	r3, r3, #4
    ac26:	3308      	adds	r3, #8
    ac28:	4413      	add	r3, r2
    ac2a:	685b      	ldr	r3, [r3, #4]
    ac2c:	00db      	lsls	r3, r3, #3
    ac2e:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    ac32:	4313      	orrs	r3, r2
    ac34:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
    ac38:	e0ab      	b.n	ad92 <Can_Ipw_InitLegacyFifoFilter+0x324>
                }
            }
            else /*CAN_LEGACY_FIFO_FORMAT_C == Can_pController->Can_eLegacyAcceptanceMode */
            {
                u8HwFilterCount =  Can_pHwObject->Can_u8HwFilterCount * 4U ;
    ac3a:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    ac3e:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    ac42:	681b      	ldr	r3, [r3, #0]
    ac44:	7c9b      	ldrb	r3, [r3, #18]
    ac46:	009b      	lsls	r3, r3, #2
    ac48:	f88d 3416 	strb.w	r3, [sp, #1046]	; 0x416
                u32HwFilterMask = (uint32)0x00000000U;
    ac4c:	2300      	movs	r3, #0
    ac4e:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                eElementFormat = FLEXCAN_RX_FIFO_ID_FORMAT_C;
    ac52:	2302      	movs	r3, #2
    ac54:	f8cd 3408 	str.w	r3, [sp, #1032]	; 0x408
                if (Can_pHwObject->Can_IdMessage != CAN_STANDARD)
    ac58:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    ac5c:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    ac60:	681b      	ldr	r3, [r3, #0]
    ac62:	689b      	ldr	r3, [r3, #8]
    ac64:	2b00      	cmp	r3, #0
    ac66:	d04a      	beq.n	acfe <Can_Ipw_InitLegacyFifoFilter+0x290>
                {
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[u8FilterIdx * 4U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT1;
    ac68:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    ac6c:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    ac70:	681b      	ldr	r3, [r3, #0]
    ac72:	695a      	ldr	r2, [r3, #20]
    ac74:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    ac78:	015b      	lsls	r3, r3, #5
    ac7a:	4413      	add	r3, r2
    ac7c:	685b      	ldr	r3, [r3, #4]
    ac7e:	0d5b      	lsrs	r3, r3, #21
    ac80:	061b      	lsls	r3, r3, #24
    ac82:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    ac86:	4313      	orrs	r3, r2
    ac88:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 4U) + 1U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT2;
    ac8c:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    ac90:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    ac94:	681b      	ldr	r3, [r3, #0]
    ac96:	695a      	ldr	r2, [r3, #20]
    ac98:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    ac9c:	015b      	lsls	r3, r3, #5
    ac9e:	3308      	adds	r3, #8
    aca0:	4413      	add	r3, r2
    aca2:	685b      	ldr	r3, [r3, #4]
    aca4:	0d5b      	lsrs	r3, r3, #21
    aca6:	041b      	lsls	r3, r3, #16
    aca8:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    acac:	4313      	orrs	r3, r2
    acae:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 4U) + 2U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT3;
    acb2:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    acb6:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    acba:	681b      	ldr	r3, [r3, #0]
    acbc:	695a      	ldr	r2, [r3, #20]
    acbe:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    acc2:	015b      	lsls	r3, r3, #5
    acc4:	3310      	adds	r3, #16
    acc6:	4413      	add	r3, r2
    acc8:	685b      	ldr	r3, [r3, #4]
    acca:	0d5b      	lsrs	r3, r3, #21
    accc:	021b      	lsls	r3, r3, #8
    acce:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    acd2:	4313      	orrs	r3, r2
    acd4:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 4U) + 3U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT4;
    acd8:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    acdc:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    ace0:	681b      	ldr	r3, [r3, #0]
    ace2:	695a      	ldr	r2, [r3, #20]
    ace4:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    ace8:	015b      	lsls	r3, r3, #5
    acea:	3318      	adds	r3, #24
    acec:	4413      	add	r3, r2
    acee:	685b      	ldr	r3, [r3, #4]
    acf0:	0d5b      	lsrs	r3, r3, #21
    acf2:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    acf6:	4313      	orrs	r3, r2
    acf8:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
    acfc:	e049      	b.n	ad92 <Can_Ipw_InitLegacyFifoFilter+0x324>
                }
                else
                {
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[u8FilterIdx * 4U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT1;
    acfe:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    ad02:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    ad06:	681b      	ldr	r3, [r3, #0]
    ad08:	695a      	ldr	r2, [r3, #20]
    ad0a:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    ad0e:	015b      	lsls	r3, r3, #5
    ad10:	4413      	add	r3, r2
    ad12:	685b      	ldr	r3, [r3, #4]
    ad14:	08db      	lsrs	r3, r3, #3
    ad16:	061b      	lsls	r3, r3, #24
    ad18:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    ad1c:	4313      	orrs	r3, r2
    ad1e:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 4U) + 1U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT2;
    ad22:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    ad26:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    ad2a:	681b      	ldr	r3, [r3, #0]
    ad2c:	695a      	ldr	r2, [r3, #20]
    ad2e:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    ad32:	015b      	lsls	r3, r3, #5
    ad34:	3308      	adds	r3, #8
    ad36:	4413      	add	r3, r2
    ad38:	685b      	ldr	r3, [r3, #4]
    ad3a:	08db      	lsrs	r3, r3, #3
    ad3c:	041b      	lsls	r3, r3, #16
    ad3e:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    ad42:	4313      	orrs	r3, r2
    ad44:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 4U) + 2U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT3;
    ad48:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    ad4c:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    ad50:	681b      	ldr	r3, [r3, #0]
    ad52:	695a      	ldr	r2, [r3, #20]
    ad54:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    ad58:	015b      	lsls	r3, r3, #5
    ad5a:	3310      	adds	r3, #16
    ad5c:	4413      	add	r3, r2
    ad5e:	685b      	ldr	r3, [r3, #4]
    ad60:	08db      	lsrs	r3, r3, #3
    ad62:	021b      	lsls	r3, r3, #8
    ad64:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    ad68:	4313      	orrs	r3, r2
    ad6a:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 4U) + 3U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT4;
    ad6e:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    ad72:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    ad76:	681b      	ldr	r3, [r3, #0]
    ad78:	695a      	ldr	r2, [r3, #20]
    ad7a:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    ad7e:	015b      	lsls	r3, r3, #5
    ad80:	3318      	adds	r3, #24
    ad82:	4413      	add	r3, r2
    ad84:	685b      	ldr	r3, [r3, #4]
    ad86:	08db      	lsrs	r3, r3, #3
    ad88:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    ad8c:	4313      	orrs	r3, r2
    ad8e:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                }
            }
            /* Already in freeze mode */
            (void)FlexCAN_Ip_SetRxIndividualMask(Can_pController->Can_u8ControllerOffset, u8FilterIdx, u32HwFilterMask);
    ad92:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    ad96:	f2a3 4314 	subw	r3, r3, #1044	; 0x414
    ad9a:	681b      	ldr	r3, [r3, #0]
    ad9c:	789b      	ldrb	r3, [r3, #2]
    ad9e:	f89d 1417 	ldrb.w	r1, [sp, #1047]	; 0x417
    ada2:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    ada6:	4618      	mov	r0, r3
    ada8:	f002 fd22 	bl	d7f0 <FlexCAN_Ip_SetRxIndividualMask_Privileged>
    for (u8FilterIdx=0U; ((u8FilterIdx < u8FiFoFilterIndvCount) && (u8FilterIdx < Can_pHwObject->Can_u8HwFilterCount)); u8FilterIdx++)
    adac:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    adb0:	3301      	adds	r3, #1
    adb2:	f88d 3417 	strb.w	r3, [sp, #1047]	; 0x417
    adb6:	f89d 2417 	ldrb.w	r2, [sp, #1047]	; 0x417
    adba:	f89d 340f 	ldrb.w	r3, [sp, #1039]	; 0x40f
    adbe:	429a      	cmp	r2, r3
    adc0:	d20a      	bcs.n	add8 <Can_Ipw_InitLegacyFifoFilter+0x36a>
    adc2:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    adc6:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    adca:	681b      	ldr	r3, [r3, #0]
    adcc:	7c9b      	ldrb	r3, [r3, #18]
    adce:	f89d 2417 	ldrb.w	r2, [sp, #1047]	; 0x417
    add2:	429a      	cmp	r2, r3
    add4:	f4ff ae85 	bcc.w	aae2 <Can_Ipw_InitLegacyFifoFilter+0x74>
    }

    (void)FlexCAN_Ip_SetRxFifoGlobalMask(Can_pController->Can_u8ControllerOffset, Can_pController->Can_u32LegacyGlobalMask);
    add8:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    addc:	f2a3 4314 	subw	r3, r3, #1044	; 0x414
    ade0:	681b      	ldr	r3, [r3, #0]
    ade2:	789a      	ldrb	r2, [r3, #2]
    ade4:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    ade8:	f2a3 4314 	subw	r3, r3, #1044	; 0x414
    adec:	681b      	ldr	r3, [r3, #0]
    adee:	68db      	ldr	r3, [r3, #12]
    adf0:	4619      	mov	r1, r3
    adf2:	4610      	mov	r0, r2
    adf4:	f002 fd4a 	bl	d88c <FlexCAN_Ip_SetRxFifoGlobalMask_Privileged>
    
    if (u8HwFilterCount != 0U)
    adf8:	f89d 3416 	ldrb.w	r3, [sp, #1046]	; 0x416
    adfc:	2b00      	cmp	r3, #0
    adfe:	d054      	beq.n	aeaa <Can_Ipw_InitLegacyFifoFilter+0x43c>
    {
        for (u8FilterIdx=0U; u8FilterIdx < u8HwFilterCount; u8FilterIdx++)
    ae00:	2300      	movs	r3, #0
    ae02:	f88d 3417 	strb.w	r3, [sp, #1047]	; 0x417
    ae06:	e03e      	b.n	ae86 <Can_Ipw_InitLegacyFifoFilter+0x418>
        {
            RxFifoFilters[u8FilterIdx].id = Can_pHwObject->Can_pHwFilterConfig[u8FilterIdx].Can_u32HwFilterCode;
    ae08:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    ae0c:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    ae10:	681b      	ldr	r3, [r3, #0]
    ae12:	695a      	ldr	r2, [r3, #20]
    ae14:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    ae18:	00db      	lsls	r3, r3, #3
    ae1a:	441a      	add	r2, r3
    ae1c:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    ae20:	6812      	ldr	r2, [r2, #0]
    ae22:	f50d 6183 	add.w	r1, sp, #1048	; 0x418
    ae26:	f5a1 6182 	sub.w	r1, r1, #1040	; 0x410
    ae2a:	00db      	lsls	r3, r3, #3
    ae2c:	440b      	add	r3, r1
    ae2e:	605a      	str	r2, [r3, #4]
            if (Can_pHwObject->Can_IdMessage != CAN_STANDARD)
    ae30:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    ae34:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    ae38:	681b      	ldr	r3, [r3, #0]
    ae3a:	689b      	ldr	r3, [r3, #8]
    ae3c:	2b00      	cmp	r3, #0
    ae3e:	d00a      	beq.n	ae56 <Can_Ipw_InitLegacyFifoFilter+0x3e8>
            {
                RxFifoFilters[u8FilterIdx].isExtendedFrame = TRUE;
    ae40:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    ae44:	f50d 6283 	add.w	r2, sp, #1048	; 0x418
    ae48:	f5a2 6282 	sub.w	r2, r2, #1040	; 0x410
    ae4c:	00db      	lsls	r3, r3, #3
    ae4e:	4413      	add	r3, r2
    ae50:	2201      	movs	r2, #1
    ae52:	705a      	strb	r2, [r3, #1]
    ae54:	e009      	b.n	ae6a <Can_Ipw_InitLegacyFifoFilter+0x3fc>
            }
            else
            {
                RxFifoFilters[u8FilterIdx].isExtendedFrame = FALSE;
    ae56:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    ae5a:	f50d 6283 	add.w	r2, sp, #1048	; 0x418
    ae5e:	f5a2 6282 	sub.w	r2, r2, #1040	; 0x410
    ae62:	00db      	lsls	r3, r3, #3
    ae64:	4413      	add	r3, r2
    ae66:	2200      	movs	r2, #0
    ae68:	705a      	strb	r2, [r3, #1]
            }
            RxFifoFilters[u8FilterIdx].isRemoteFrame = FALSE;
    ae6a:	f89d 2417 	ldrb.w	r2, [sp, #1047]	; 0x417
    ae6e:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    ae72:	f5a3 6382 	sub.w	r3, r3, #1040	; 0x410
    ae76:	2100      	movs	r1, #0
    ae78:	f803 1032 	strb.w	r1, [r3, r2, lsl #3]
        for (u8FilterIdx=0U; u8FilterIdx < u8HwFilterCount; u8FilterIdx++)
    ae7c:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    ae80:	3301      	adds	r3, #1
    ae82:	f88d 3417 	strb.w	r3, [sp, #1047]	; 0x417
    ae86:	f89d 2417 	ldrb.w	r2, [sp, #1047]	; 0x417
    ae8a:	f89d 3416 	ldrb.w	r3, [sp, #1046]	; 0x416
    ae8e:	429a      	cmp	r2, r3
    ae90:	d3ba      	bcc.n	ae08 <Can_Ipw_InitLegacyFifoFilter+0x39a>
        }

        (void)FlexCAN_Ip_ConfigRxFifo(Can_pController->Can_u8ControllerOffset, eElementFormat, RxFifoFilters);
    ae92:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    ae96:	f2a3 4314 	subw	r3, r3, #1044	; 0x414
    ae9a:	681b      	ldr	r3, [r3, #0]
    ae9c:	789b      	ldrb	r3, [r3, #2]
    ae9e:	aa02      	add	r2, sp, #8
    aea0:	f8dd 1408 	ldr.w	r1, [sp, #1032]	; 0x408
    aea4:	4618      	mov	r0, r3
    aea6:	f002 f886 	bl	cfb6 <FlexCAN_Ip_ConfigRxFifo_Privileged>
    }
    
}
    aeaa:	bf00      	nop
    aeac:	f20d 4d1c 	addw	sp, sp, #1052	; 0x41c
    aeb0:	f85d fb04 	ldr.w	pc, [sp], #4

0000aeb4 <Can_Ipw_InitBaudrate>:

#endif /* (CAN_43_FLEXCAN_RX_POLLING_SUPPORT == STD_ON) */

/* Init baudrate for controller */
static void Can_Ipw_InitBaudrate(const Can_43_FLEXCAN_ControllerConfigType * ControllerConfig)
{
    aeb4:	b510      	push	{r4, lr}
    aeb6:	b084      	sub	sp, #16
    aeb8:	9001      	str	r0, [sp, #4]
#if (CAN_43_FLEXCAN_SET_BAUDRATE_API == STD_ON)
    uint16 BaudRateConfigID = Can_au16ControllerBaudRateSel[ControllerConfig->Can_u8ControllerID];
#else
    uint16 BaudRateConfigID = ControllerConfig->Can_u16DefaultBaudrateID;
    aeba:	9b01      	ldr	r3, [sp, #4]
    aebc:	8b9b      	ldrh	r3, [r3, #28]
    aebe:	f8ad 300e 	strh.w	r3, [sp, #14]
        FlexCANTimeSeg.phaseSeg1  = ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_NominalBitRate.Can_u8PhaseSeg1;
        FlexCANTimeSeg.phaseSeg2  = ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_NominalBitRate.Can_u8PhaseSeg2;
        FlexCANTimeSeg.rJumpwidth = ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_NominalBitRate.Can_u8ResyncJumpWidth;
        (void)FlexCAN_Ip_SetBitrate(ControllerConfig->Can_u8ControllerOffset, &FlexCANTimeSeg, FALSE);
#endif /* ((CAN_43_FLEXCAN_DUAL_CLOCK_MODE == STD_ON) || (CAN_43_FLEXCAN_SET_BAUDRATE_API == STD_ON)) */
        if (TRUE == ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_bFDFrame)
    aec2:	9b01      	ldr	r3, [sp, #4]
    aec4:	6a1a      	ldr	r2, [r3, #32]
    aec6:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    aeca:	2116      	movs	r1, #22
    aecc:	fb01 f303 	mul.w	r3, r1, r3
    aed0:	4413      	add	r3, r2
    aed2:	785b      	ldrb	r3, [r3, #1]
    aed4:	2b00      	cmp	r3, #0
    aed6:	d016      	beq.n	af06 <Can_Ipw_InitBaudrate+0x52>
            FlexCANTimeSeg.phaseSeg2  = ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_DataBitRate.Can_u8PhaseSeg2;
            FlexCANTimeSeg.rJumpwidth = ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_DataBitRate.Can_u8ResyncJumpWidth;

            (void)FlexCAN_Ip_SetBitrateCbt(ControllerConfig->Can_u8ControllerOffset, &FlexCANTimeSeg, ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_bBitRateSwitch);
    #endif /* ((CAN_43_FLEXCAN_DUAL_CLOCK_MODE == STD_ON) || (CAN_43_FLEXCAN_SET_BAUDRATE_API == STD_ON)) */
            (void)FlexCAN_Ip_SetTDCOffset(ControllerConfig->Can_u8ControllerOffset, \
    aed8:	9b01      	ldr	r3, [sp, #4]
    aeda:	7898      	ldrb	r0, [r3, #2]
    aedc:	9b01      	ldr	r3, [sp, #4]
    aede:	6a1a      	ldr	r2, [r3, #32]
    aee0:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    aee4:	2116      	movs	r1, #22
    aee6:	fb01 f303 	mul.w	r3, r1, r3
    aeea:	4413      	add	r3, r2
    aeec:	7cd9      	ldrb	r1, [r3, #19]
    aeee:	9b01      	ldr	r3, [sp, #4]
    aef0:	6a1a      	ldr	r2, [r3, #32]
    aef2:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    aef6:	2416      	movs	r4, #22
    aef8:	fb04 f303 	mul.w	r3, r4, r3
    aefc:	4413      	add	r3, r2
    aefe:	7d1b      	ldrb	r3, [r3, #20]
    af00:	461a      	mov	r2, r3
    af02:	f003 f83d 	bl	df80 <FlexCAN_Ip_SetTDCOffset_Privileged>
                                          ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_bTrcvDelayEnable, \
                                          ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_u8TrcvDelayCompOffset);
        }
        (void)FlexCAN_Ip_SetTxArbitrationStartDelay(ControllerConfig->Can_u8ControllerOffset, ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_u8TxArbitrationStartDelay);
    af06:	9b01      	ldr	r3, [sp, #4]
    af08:	7898      	ldrb	r0, [r3, #2]
    af0a:	9b01      	ldr	r3, [sp, #4]
    af0c:	6a1a      	ldr	r2, [r3, #32]
    af0e:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    af12:	2116      	movs	r1, #22
    af14:	fb01 f303 	mul.w	r3, r1, r3
    af18:	4413      	add	r3, r2
    af1a:	7c9b      	ldrb	r3, [r3, #18]
    af1c:	4619      	mov	r1, r3
    af1e:	f003 f883 	bl	e028 <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged>
}
    af22:	bf00      	nop
    af24:	b004      	add	sp, #16
    af26:	bd10      	pop	{r4, pc}

0000af28 <Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer>:
    (
        const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig,
        const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObjectConfig,
        uint8 u8MbIdx
    )
    {
    af28:	b500      	push	{lr}
    af2a:	b087      	sub	sp, #28
    af2c:	9003      	str	r0, [sp, #12]
    af2e:	9102      	str	r1, [sp, #8]
    af30:	4613      	mov	r3, r2
    af32:	f88d 3007 	strb.w	r3, [sp, #7]
        Can_HwHandleType u8HwObjectID = 0U;
    af36:	2300      	movs	r3, #0
    af38:	f8ad 3016 	strh.w	r3, [sp, #22]

        u8HwObjectID = Can_Ipw_au16MbIdxToObjIDMap[Can_pControllerConfig->Can_u8ControllerID][u8MbIdx];
    af3c:	9b03      	ldr	r3, [sp, #12]
    af3e:	785b      	ldrb	r3, [r3, #1]
    af40:	461a      	mov	r2, r3
    af42:	f89d 3007 	ldrb.w	r3, [sp, #7]
    af46:	491c      	ldr	r1, [pc, #112]	; (afb8 <Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer+0x90>)
    af48:	0152      	lsls	r2, r2, #5
    af4a:	4413      	add	r3, r2
    af4c:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
    af50:	f8ad 3016 	strh.w	r3, [sp, #22]
        if ((CAN_43_FLEXCAN_HWOBJ_UNMAPPED != u8HwObjectID) && (FALSE == Can_pHwObjectConfig[u8HwObjectID].Can_bHwObjectUsesPolling))
    af54:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    af58:	f64f 72ff 	movw	r2, #65535	; 0xffff
    af5c:	4293      	cmp	r3, r2
    af5e:	d027      	beq.n	afb0 <Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer+0x88>
    af60:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    af64:	4613      	mov	r3, r2
    af66:	00db      	lsls	r3, r3, #3
    af68:	4413      	add	r3, r2
    af6a:	009b      	lsls	r3, r3, #2
    af6c:	461a      	mov	r2, r3
    af6e:	9b02      	ldr	r3, [sp, #8]
    af70:	4413      	add	r3, r2
    af72:	7b1b      	ldrb	r3, [r3, #12]
    af74:	f083 0301 	eor.w	r3, r3, #1
    af78:	b2db      	uxtb	r3, r3
    af7a:	2b00      	cmp	r3, #0
    af7c:	d018      	beq.n	afb0 <Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer+0x88>
        {
            if (CAN_TX_NORMAL == Can_pHwObjectConfig[u8HwObjectID].Can_eReceiveType)
    af7e:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    af82:	4613      	mov	r3, r2
    af84:	00db      	lsls	r3, r3, #3
    af86:	4413      	add	r3, r2
    af88:	009b      	lsls	r3, r3, #2
    af8a:	461a      	mov	r2, r3
    af8c:	9b02      	ldr	r3, [sp, #8]
    af8e:	4413      	add	r3, r2
    af90:	699b      	ldr	r3, [r3, #24]
    af92:	2b03      	cmp	r3, #3
    af94:	d10c      	bne.n	afb0 <Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer+0x88>
            {
                CanIf_TxConfirmation(Can_Ipw_au16TxPduId[Can_pControllerConfig->Can_u8ControllerID][u8MbIdx]);
    af96:	9b03      	ldr	r3, [sp, #12]
    af98:	785b      	ldrb	r3, [r3, #1]
    af9a:	461a      	mov	r2, r3
    af9c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    afa0:	4906      	ldr	r1, [pc, #24]	; (afbc <Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer+0x94>)
    afa2:	0152      	lsls	r2, r2, #5
    afa4:	4413      	add	r3, r2
    afa6:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
    afaa:	4618      	mov	r0, r3
    afac:	f00c f850 	bl	17050 <CanIf_TxConfirmation>
            }
        }
    }
    afb0:	bf00      	nop
    afb2:	b007      	add	sp, #28
    afb4:	f85d fb04 	ldr.w	pc, [sp], #4
    afb8:	1fff92dc 	.word	0x1fff92dc
    afbc:	1fff925c 	.word	0x1fff925c

0000afc0 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer>:
    (
        const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig,
        const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObjectConfig,
        uint8 u8MbIdx
    )
    {
    afc0:	b500      	push	{lr}
    afc2:	b08f      	sub	sp, #60	; 0x3c
    afc4:	9005      	str	r0, [sp, #20]
    afc6:	9104      	str	r1, [sp, #16]
    afc8:	4613      	mov	r3, r2
    afca:	f88d 300f 	strb.w	r3, [sp, #15]
        Can_HwHandleType u8HwObjectID = 0U;
    afce:	2300      	movs	r3, #0
    afd0:	f8ad 3036 	strh.w	r3, [sp, #54]	; 0x36
        Can_HwType CanIf_Mailbox;
        PduInfoType CanIf_PduInfo;
        const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject = NULL_PTR;
    afd4:	2300      	movs	r3, #0
    afd6:	930c      	str	r3, [sp, #48]	; 0x30
        Flexcan_Ip_MsgBuffType * pReceivedDataBuffer = NULL_PTR;
    afd8:	2300      	movs	r3, #0
    afda:	930b      	str	r3, [sp, #44]	; 0x2c

        u8HwObjectID = Can_Ipw_au16MbIdxToObjIDMap[Can_pControllerConfig->Can_u8ControllerID][u8MbIdx];
    afdc:	9b05      	ldr	r3, [sp, #20]
    afde:	785b      	ldrb	r3, [r3, #1]
    afe0:	461a      	mov	r2, r3
    afe2:	f89d 300f 	ldrb.w	r3, [sp, #15]
    afe6:	4944      	ldr	r1, [pc, #272]	; (b0f8 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x138>)
    afe8:	0152      	lsls	r2, r2, #5
    afea:	4413      	add	r3, r2
    afec:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
    aff0:	f8ad 3036 	strh.w	r3, [sp, #54]	; 0x36
        if ((CAN_43_FLEXCAN_HWOBJ_UNMAPPED != u8HwObjectID) && (FALSE == Can_pHwObjectConfig[u8HwObjectID].Can_bHwObjectUsesPolling))
    aff4:	f8bd 3036 	ldrh.w	r3, [sp, #54]	; 0x36
    aff8:	f64f 72ff 	movw	r2, #65535	; 0xffff
    affc:	4293      	cmp	r3, r2
    affe:	d076      	beq.n	b0ee <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x12e>
    b000:	f8bd 2036 	ldrh.w	r2, [sp, #54]	; 0x36
    b004:	4613      	mov	r3, r2
    b006:	00db      	lsls	r3, r3, #3
    b008:	4413      	add	r3, r2
    b00a:	009b      	lsls	r3, r3, #2
    b00c:	461a      	mov	r2, r3
    b00e:	9b04      	ldr	r3, [sp, #16]
    b010:	4413      	add	r3, r2
    b012:	7b1b      	ldrb	r3, [r3, #12]
    b014:	f083 0301 	eor.w	r3, r3, #1
    b018:	b2db      	uxtb	r3, r3
    b01a:	2b00      	cmp	r3, #0
    b01c:	d067      	beq.n	b0ee <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x12e>
        {
            Can_pHwObject = &Can_pHwObjectConfig[u8HwObjectID];
    b01e:	f8bd 2036 	ldrh.w	r2, [sp, #54]	; 0x36
    b022:	4613      	mov	r3, r2
    b024:	00db      	lsls	r3, r3, #3
    b026:	4413      	add	r3, r2
    b028:	009b      	lsls	r3, r3, #2
    b02a:	461a      	mov	r2, r3
    b02c:	9b04      	ldr	r3, [sp, #16]
    b02e:	4413      	add	r3, r2
    b030:	930c      	str	r3, [sp, #48]	; 0x30

            if (CAN_RX_NORMAL == Can_pHwObject->Can_eReceiveType)
    b032:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    b034:	699b      	ldr	r3, [r3, #24]
    b036:	2b00      	cmp	r3, #0
    b038:	d11d      	bne.n	b076 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0xb6>
            {
                pReceivedDataBuffer = (Can_Ipw_apxStatus[Can_pControllerConfig->Can_u8ControllerID])->mbs[Can_pHwObject->Can_u8HwBufferIndex].pMBmessage;
    b03a:	9b05      	ldr	r3, [sp, #20]
    b03c:	785b      	ldrb	r3, [r3, #1]
    b03e:	461a      	mov	r2, r3
    b040:	4b2e      	ldr	r3, [pc, #184]	; (b0fc <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x13c>)
    b042:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    b046:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    b048:	7f1b      	ldrb	r3, [r3, #28]
    b04a:	011b      	lsls	r3, r3, #4
    b04c:	4413      	add	r3, r2
    b04e:	681b      	ldr	r3, [r3, #0]
    b050:	930b      	str	r3, [sp, #44]	; 0x2c
                Can_Ipw_ParseData(&CanIf_Mailbox, \
    b052:	a906      	add	r1, sp, #24
    b054:	a809      	add	r0, sp, #36	; 0x24
    b056:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    b058:	9300      	str	r3, [sp, #0]
    b05a:	9b05      	ldr	r3, [sp, #20]
    b05c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    b05e:	f7ff fca9 	bl	a9b4 <Can_Ipw_ParseData>
                                  pReceivedDataBuffer, \
                                  Can_pControllerConfig, \
                                  Can_pHwObject \
                                 );
                /* ready to receive in next time */
                (void)FlexCAN_Ip_Receive(Can_pControllerConfig->Can_u8ControllerOffset, \
    b062:	9b05      	ldr	r3, [sp, #20]
    b064:	7898      	ldrb	r0, [r3, #2]
    b066:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    b068:	7f19      	ldrb	r1, [r3, #28]
    b06a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    b06c:	7b1b      	ldrb	r3, [r3, #12]
    b06e:	2200      	movs	r2, #0
    b070:	f001 fe70 	bl	cd54 <FlexCAN_Ip_Receive>
            else
            {
                /* prevent misra */
            }
        }
    }
    b074:	e03b      	b.n	b0ee <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x12e>
            else if (CAN_RX_LEGACY_FIFO == Can_pHwObject->Can_eReceiveType)
    b076:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    b078:	699b      	ldr	r3, [r3, #24]
    b07a:	2b01      	cmp	r3, #1
    b07c:	d137      	bne.n	b0ee <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x12e>
                if ((uint8)7U == u8MbIdx)
    b07e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    b082:	2b07      	cmp	r3, #7
    b084:	d10d      	bne.n	b0a2 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0xe2>
                    (void)Det_ReportRuntimeError((uint16)CAN_43_FLEXCAN_IPW_MODULE_ID, (uint8)CAN_43_FLEXCAN_INSTANCE, (uint8)CAN_43_FLEXCAN_SID_MAIN_FUNCTION_READ, (uint8)CAN_43_FLEXCAN_E_DATALOST);
    b086:	2301      	movs	r3, #1
    b088:	2208      	movs	r2, #8
    b08a:	2100      	movs	r1, #0
    b08c:	2050      	movs	r0, #80	; 0x50
    b08e:	f00b fee5 	bl	16e5c <Det_ReportRuntimeError>
                    if (NULL_PTR != Can_pControllerConfig->Can_pLegacyFiFoOvfNotif)
    b092:	9b05      	ldr	r3, [sp, #20]
    b094:	699b      	ldr	r3, [r3, #24]
    b096:	2b00      	cmp	r3, #0
    b098:	d029      	beq.n	b0ee <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x12e>
                        Can_pControllerConfig->Can_pLegacyFiFoOvfNotif();
    b09a:	9b05      	ldr	r3, [sp, #20]
    b09c:	699b      	ldr	r3, [r3, #24]
    b09e:	4798      	blx	r3
    }
    b0a0:	e025      	b.n	b0ee <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x12e>
                else if ((uint8)6U == u8MbIdx)
    b0a2:	f89d 300f 	ldrb.w	r3, [sp, #15]
    b0a6:	2b06      	cmp	r3, #6
    b0a8:	d107      	bne.n	b0ba <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0xfa>
                    if (NULL_PTR != Can_pControllerConfig->Can_pLegacyFiFoWarnNotif)
    b0aa:	9b05      	ldr	r3, [sp, #20]
    b0ac:	695b      	ldr	r3, [r3, #20]
    b0ae:	2b00      	cmp	r3, #0
    b0b0:	d01d      	beq.n	b0ee <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x12e>
                        Can_pControllerConfig->Can_pLegacyFiFoWarnNotif();
    b0b2:	9b05      	ldr	r3, [sp, #20]
    b0b4:	695b      	ldr	r3, [r3, #20]
    b0b6:	4798      	blx	r3
    }
    b0b8:	e019      	b.n	b0ee <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x12e>
                    pReceivedDataBuffer = (Can_Ipw_apxStatus[Can_pControllerConfig->Can_u8ControllerID])->mbs[Can_pHwObject->Can_u8HwBufferIndex].pMBmessage;
    b0ba:	9b05      	ldr	r3, [sp, #20]
    b0bc:	785b      	ldrb	r3, [r3, #1]
    b0be:	461a      	mov	r2, r3
    b0c0:	4b0e      	ldr	r3, [pc, #56]	; (b0fc <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x13c>)
    b0c2:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
    b0c6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    b0c8:	7f1b      	ldrb	r3, [r3, #28]
    b0ca:	011b      	lsls	r3, r3, #4
    b0cc:	4413      	add	r3, r2
    b0ce:	681b      	ldr	r3, [r3, #0]
    b0d0:	930b      	str	r3, [sp, #44]	; 0x2c
                    Can_Ipw_ParseData(&CanIf_Mailbox, \
    b0d2:	a906      	add	r1, sp, #24
    b0d4:	a809      	add	r0, sp, #36	; 0x24
    b0d6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    b0d8:	9300      	str	r3, [sp, #0]
    b0da:	9b05      	ldr	r3, [sp, #20]
    b0dc:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    b0de:	f7ff fc69 	bl	a9b4 <Can_Ipw_ParseData>
                    (void)FlexCAN_Ip_RxFifo(Can_pControllerConfig->Can_u8ControllerOffset, NULL_PTR);
    b0e2:	9b05      	ldr	r3, [sp, #20]
    b0e4:	789b      	ldrb	r3, [r3, #2]
    b0e6:	2100      	movs	r1, #0
    b0e8:	4618      	mov	r0, r3
    b0ea:	f001 ff31 	bl	cf50 <FlexCAN_Ip_RxFifo>
    }
    b0ee:	bf00      	nop
    b0f0:	b00f      	add	sp, #60	; 0x3c
    b0f2:	f85d fb04 	ldr.w	pc, [sp], #4
    b0f6:	bf00      	nop
    b0f8:	1fff92dc 	.word	0x1fff92dc
    b0fc:	000186d0 	.word	0x000186d0

0000b100 <Can_43_FLEXCAN_Ipw_Init>:
#endif /* (CAN_43_FLEXCAN_MB_INTERRUPT_SUPPORT == STD_ON) */
/*==================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/
Std_ReturnType Can_43_FLEXCAN_Ipw_Init(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
    b100:	b510      	push	{r4, lr}
    b102:	b084      	sub	sp, #16
    b104:	9001      	str	r0, [sp, #4]
    Std_ReturnType eRetVal = (Std_ReturnType)FLEXCAN_STATUS_ERROR;
    b106:	2301      	movs	r3, #1
    b108:	f88d 300c 	strb.w	r3, [sp, #12]
#if (CAN_43_FLEXCAN_MB_INTERRUPT_SUPPORT == STD_ON)
    /* The Index of Hoh in a group that refer to a controller */
    uint8 u8HwObjRefIdx = 0U;
    b10c:	2300      	movs	r3, #0
    b10e:	f88d 300f 	strb.w	r3, [sp, #15]
    uint8 u8ObjIdx = 0U;
    b112:	2300      	movs	r3, #0
    b114:	f88d 300e 	strb.w	r3, [sp, #14]
    const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject = NULL_PTR;
    b118:	2300      	movs	r3, #0
    b11a:	9302      	str	r3, [sp, #8]
    uint8 u8HwBufferCount = 0U;
    b11c:	2300      	movs	r3, #0
    b11e:	f88d 300d 	strb.w	r3, [sp, #13]
    {
        Can_Ipw_u32Seconds = 0U;
    }
#endif
    /* @violates @ref Can_Ipw_c_REF_3 MISRA 2012 Advisory Rule 12.3 */
    eRetVal = (Std_ReturnType)Call_Can_FlexCan_Init(Can_pControllerConfig->Can_u8ControllerOffset, Can_Ipw_apxStatus[Can_pControllerConfig->Can_u8ControllerID], Can_pControllerConfig->HwChannelIpConfig->pFlexcanIpHwConfig);
    b122:	9b01      	ldr	r3, [sp, #4]
    b124:	7898      	ldrb	r0, [r3, #2]
    b126:	9b01      	ldr	r3, [sp, #4]
    b128:	785b      	ldrb	r3, [r3, #1]
    b12a:	461a      	mov	r2, r3
    b12c:	4b77      	ldr	r3, [pc, #476]	; (b30c <Can_43_FLEXCAN_Ipw_Init+0x20c>)
    b12e:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    b132:	9b01      	ldr	r3, [sp, #4]
    b134:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    b136:	681b      	ldr	r3, [r3, #0]
    b138:	461a      	mov	r2, r3
    b13a:	f001 fcff 	bl	cb3c <FlexCAN_Ip_Init_Privileged>
    b13e:	4603      	mov	r3, r0
    b140:	f88d 300c 	strb.w	r3, [sp, #12]
    
    /* by defaut, enable interrupt when setcontroller to start */
    Can_Ipw_abIsInterruptEnabled[Can_pControllerConfig->Can_u8ControllerID] = TRUE;
    b144:	9b01      	ldr	r3, [sp, #4]
    b146:	785b      	ldrb	r3, [r3, #1]
    b148:	461a      	mov	r2, r3
    b14a:	4b71      	ldr	r3, [pc, #452]	; (b310 <Can_43_FLEXCAN_Ipw_Init+0x210>)
    b14c:	2101      	movs	r1, #1
    b14e:	5499      	strb	r1, [r3, r2]
    if ((Std_ReturnType)FLEXCAN_STATUS_SUCCESS == eRetVal)
    b150:	f89d 300c 	ldrb.w	r3, [sp, #12]
    b154:	2b00      	cmp	r3, #0
    b156:	d13b      	bne.n	b1d0 <Can_43_FLEXCAN_Ipw_Init+0xd0>
    {
        /* disable all interrupts */
        (void)FlexCAN_Ip_DisableInterrupts(Can_pControllerConfig->Can_u8ControllerOffset);
    b158:	9b01      	ldr	r3, [sp, #4]
    b15a:	789b      	ldrb	r3, [r3, #2]
    b15c:	4618      	mov	r0, r3
    b15e:	f003 f821 	bl	e1a4 <FlexCAN_Ip_DisableInterrupts_Privileged>

        /* If the FlexCAN_Init retuns SUCCESS then the module is already in freezemode, and FlexCAN_Ip_SetTDCOffset and FlexCAN_Ip_SetTxArbitrationStartDelay will always retun success */
        if (Can_pControllerConfig->Can_pBaudrateConfig[Can_pControllerConfig->Can_u16DefaultBaudrateID].Can_bFDFrame)
    b162:	9b01      	ldr	r3, [sp, #4]
    b164:	6a1a      	ldr	r2, [r3, #32]
    b166:	9b01      	ldr	r3, [sp, #4]
    b168:	8b9b      	ldrh	r3, [r3, #28]
    b16a:	4619      	mov	r1, r3
    b16c:	2316      	movs	r3, #22
    b16e:	fb01 f303 	mul.w	r3, r1, r3
    b172:	4413      	add	r3, r2
    b174:	785b      	ldrb	r3, [r3, #1]
    b176:	2b00      	cmp	r3, #0
    b178:	d018      	beq.n	b1ac <Can_43_FLEXCAN_Ipw_Init+0xac>
        {
            (void)FlexCAN_Ip_SetTDCOffset(Can_pControllerConfig->Can_u8ControllerOffset, \
    b17a:	9b01      	ldr	r3, [sp, #4]
    b17c:	7898      	ldrb	r0, [r3, #2]
    b17e:	9b01      	ldr	r3, [sp, #4]
    b180:	6a1a      	ldr	r2, [r3, #32]
    b182:	9b01      	ldr	r3, [sp, #4]
    b184:	8b9b      	ldrh	r3, [r3, #28]
    b186:	4619      	mov	r1, r3
    b188:	2316      	movs	r3, #22
    b18a:	fb01 f303 	mul.w	r3, r1, r3
    b18e:	4413      	add	r3, r2
    b190:	7cd9      	ldrb	r1, [r3, #19]
    b192:	9b01      	ldr	r3, [sp, #4]
    b194:	6a1a      	ldr	r2, [r3, #32]
    b196:	9b01      	ldr	r3, [sp, #4]
    b198:	8b9b      	ldrh	r3, [r3, #28]
    b19a:	461c      	mov	r4, r3
    b19c:	2316      	movs	r3, #22
    b19e:	fb04 f303 	mul.w	r3, r4, r3
    b1a2:	4413      	add	r3, r2
    b1a4:	7d1b      	ldrb	r3, [r3, #20]
    b1a6:	461a      	mov	r2, r3
    b1a8:	f002 feea 	bl	df80 <FlexCAN_Ip_SetTDCOffset_Privileged>
                                          Can_pControllerConfig->Can_pBaudrateConfig[Can_pControllerConfig->Can_u16DefaultBaudrateID].Can_bTrcvDelayEnable, \
                                          Can_pControllerConfig->Can_pBaudrateConfig[Can_pControllerConfig->Can_u16DefaultBaudrateID].Can_u8TrcvDelayCompOffset);
        }
        (void)FlexCAN_Ip_SetTxArbitrationStartDelay(Can_pControllerConfig->Can_u8ControllerOffset, \
    b1ac:	9b01      	ldr	r3, [sp, #4]
    b1ae:	7898      	ldrb	r0, [r3, #2]
    b1b0:	9b01      	ldr	r3, [sp, #4]
    b1b2:	6a1a      	ldr	r2, [r3, #32]
    b1b4:	9b01      	ldr	r3, [sp, #4]
    b1b6:	8b9b      	ldrh	r3, [r3, #28]
    b1b8:	4619      	mov	r1, r3
    b1ba:	2316      	movs	r3, #22
    b1bc:	fb01 f303 	mul.w	r3, r1, r3
    b1c0:	4413      	add	r3, r2
    b1c2:	7c9b      	ldrb	r3, [r3, #18]
    b1c4:	4619      	mov	r1, r3
    b1c6:	f002 ff2f 	bl	e028 <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged>
                                                    Can_pControllerConfig->Can_pBaudrateConfig[Can_pControllerConfig->Can_u16DefaultBaudrateID].Can_u8TxArbitrationStartDelay);
        
        /* Init all Rx objects */
        Can_Ipw_InitRx(Can_pControllerConfig);
    b1ca:	9801      	ldr	r0, [sp, #4]
    b1cc:	f000 fb0a 	bl	b7e4 <Can_Ipw_InitRx>
    }

#if (CAN_43_FLEXCAN_MB_INTERRUPT_SUPPORT == STD_ON)
    for (u8HwBufferCount = 0U; u8HwBufferCount < CAN_43_FLEXCAN_HWMB_COUNT; u8HwBufferCount++)
    b1d0:	2300      	movs	r3, #0
    b1d2:	f88d 300d 	strb.w	r3, [sp, #13]
    b1d6:	e010      	b.n	b1fa <Can_43_FLEXCAN_Ipw_Init+0xfa>
    {
        Can_Ipw_au16MbIdxToObjIDMap[Can_pControllerConfig->Can_u8ControllerID][u8HwBufferCount] = CAN_43_FLEXCAN_HWOBJ_UNMAPPED;
    b1d8:	9b01      	ldr	r3, [sp, #4]
    b1da:	785b      	ldrb	r3, [r3, #1]
    b1dc:	461a      	mov	r2, r3
    b1de:	f89d 300d 	ldrb.w	r3, [sp, #13]
    b1e2:	494c      	ldr	r1, [pc, #304]	; (b314 <Can_43_FLEXCAN_Ipw_Init+0x214>)
    b1e4:	0152      	lsls	r2, r2, #5
    b1e6:	4413      	add	r3, r2
    b1e8:	f64f 72ff 	movw	r2, #65535	; 0xffff
    b1ec:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
    for (u8HwBufferCount = 0U; u8HwBufferCount < CAN_43_FLEXCAN_HWMB_COUNT; u8HwBufferCount++)
    b1f0:	f89d 300d 	ldrb.w	r3, [sp, #13]
    b1f4:	3301      	adds	r3, #1
    b1f6:	f88d 300d 	strb.w	r3, [sp, #13]
    b1fa:	f89d 300d 	ldrb.w	r3, [sp, #13]
    b1fe:	2b1f      	cmp	r3, #31
    b200:	d9ea      	bls.n	b1d8 <Can_43_FLEXCAN_Ipw_Init+0xd8>
    }
    /* Map MB index to hardware object ID */
    for (u8HwObjRefIdx = 0U; u8HwObjRefIdx < Can_pControllerConfig->Can_u8HwObjectRefCount; u8HwObjRefIdx++)
    b202:	2300      	movs	r3, #0
    b204:	f88d 300f 	strb.w	r3, [sp, #15]
    b208:	e06b      	b.n	b2e2 <Can_43_FLEXCAN_Ipw_Init+0x1e2>
    {
        Can_pHwObject = Can_pControllerConfig->Can_ppHwObject[u8HwObjRefIdx];
    b20a:	9b01      	ldr	r3, [sp, #4]
    b20c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    b20e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    b212:	009b      	lsls	r3, r3, #2
    b214:	4413      	add	r3, r2
    b216:	681b      	ldr	r3, [r3, #0]
    b218:	9302      	str	r3, [sp, #8]
        switch (Can_pHwObject->Can_eReceiveType)
    b21a:	9b02      	ldr	r3, [sp, #8]
    b21c:	699b      	ldr	r3, [r3, #24]
    b21e:	2b03      	cmp	r3, #3
    b220:	d006      	beq.n	b230 <Can_43_FLEXCAN_Ipw_Init+0x130>
    b222:	2b03      	cmp	r3, #3
    b224:	d857      	bhi.n	b2d6 <Can_43_FLEXCAN_Ipw_Init+0x1d6>
    b226:	2b00      	cmp	r3, #0
    b228:	d023      	beq.n	b272 <Can_43_FLEXCAN_Ipw_Init+0x172>
    b22a:	2b01      	cmp	r3, #1
    b22c:	d02f      	beq.n	b28e <Can_43_FLEXCAN_Ipw_Init+0x18e>
                break;
            }
            default:
            {
                /* don't map for enhance fifo object because of out of message buffer memory */
                break;
    b22e:	e052      	b.n	b2d6 <Can_43_FLEXCAN_Ipw_Init+0x1d6>
                for (u8ObjIdx = 0U; u8ObjIdx < Can_pHwObject->Can_u8ObjectCount; u8ObjIdx++)
    b230:	2300      	movs	r3, #0
    b232:	f88d 300e 	strb.w	r3, [sp, #14]
    b236:	e015      	b.n	b264 <Can_43_FLEXCAN_Ipw_Init+0x164>
                    Can_Ipw_au16MbIdxToObjIDMap[Can_pControllerConfig->Can_u8ControllerID][Can_pHwObject->Can_u8HwBufferIndex + u8ObjIdx] = Can_pHwObject->Can_HwObjectID;
    b238:	9b01      	ldr	r3, [sp, #4]
    b23a:	785b      	ldrb	r3, [r3, #1]
    b23c:	461c      	mov	r4, r3
    b23e:	9b02      	ldr	r3, [sp, #8]
    b240:	7f1b      	ldrb	r3, [r3, #28]
    b242:	461a      	mov	r2, r3
    b244:	f89d 300e 	ldrb.w	r3, [sp, #14]
    b248:	4413      	add	r3, r2
    b24a:	9a02      	ldr	r2, [sp, #8]
    b24c:	8810      	ldrh	r0, [r2, #0]
    b24e:	4931      	ldr	r1, [pc, #196]	; (b314 <Can_43_FLEXCAN_Ipw_Init+0x214>)
    b250:	0162      	lsls	r2, r4, #5
    b252:	4413      	add	r3, r2
    b254:	4602      	mov	r2, r0
    b256:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
                for (u8ObjIdx = 0U; u8ObjIdx < Can_pHwObject->Can_u8ObjectCount; u8ObjIdx++)
    b25a:	f89d 300e 	ldrb.w	r3, [sp, #14]
    b25e:	3301      	adds	r3, #1
    b260:	f88d 300e 	strb.w	r3, [sp, #14]
    b264:	9b02      	ldr	r3, [sp, #8]
    b266:	7b9b      	ldrb	r3, [r3, #14]
    b268:	f89d 200e 	ldrb.w	r2, [sp, #14]
    b26c:	429a      	cmp	r2, r3
    b26e:	d3e3      	bcc.n	b238 <Can_43_FLEXCAN_Ipw_Init+0x138>
                break;
    b270:	e032      	b.n	b2d8 <Can_43_FLEXCAN_Ipw_Init+0x1d8>
                Can_Ipw_au16MbIdxToObjIDMap[Can_pControllerConfig->Can_u8ControllerID][Can_pHwObject->Can_u8HwBufferIndex] = Can_pHwObject->Can_HwObjectID;
    b272:	9b01      	ldr	r3, [sp, #4]
    b274:	785b      	ldrb	r3, [r3, #1]
    b276:	461c      	mov	r4, r3
    b278:	9b02      	ldr	r3, [sp, #8]
    b27a:	7f1b      	ldrb	r3, [r3, #28]
    b27c:	4618      	mov	r0, r3
    b27e:	9b02      	ldr	r3, [sp, #8]
    b280:	8819      	ldrh	r1, [r3, #0]
    b282:	4a24      	ldr	r2, [pc, #144]	; (b314 <Can_43_FLEXCAN_Ipw_Init+0x214>)
    b284:	0163      	lsls	r3, r4, #5
    b286:	4403      	add	r3, r0
    b288:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
                break;
    b28c:	e024      	b.n	b2d8 <Can_43_FLEXCAN_Ipw_Init+0x1d8>
                Can_Ipw_au16MbIdxToObjIDMap[Can_pControllerConfig->Can_u8ControllerID][Can_pHwObject->Can_u8HwBufferIndex] = Can_pHwObject->Can_HwObjectID;
    b28e:	9b01      	ldr	r3, [sp, #4]
    b290:	785b      	ldrb	r3, [r3, #1]
    b292:	461c      	mov	r4, r3
    b294:	9b02      	ldr	r3, [sp, #8]
    b296:	7f1b      	ldrb	r3, [r3, #28]
    b298:	4618      	mov	r0, r3
    b29a:	9b02      	ldr	r3, [sp, #8]
    b29c:	8819      	ldrh	r1, [r3, #0]
    b29e:	4a1d      	ldr	r2, [pc, #116]	; (b314 <Can_43_FLEXCAN_Ipw_Init+0x214>)
    b2a0:	0163      	lsls	r3, r4, #5
    b2a2:	4403      	add	r3, r0
    b2a4:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
                Can_Ipw_au16MbIdxToObjIDMap[Can_pControllerConfig->Can_u8ControllerID][6U] = Can_pHwObject->Can_HwObjectID;
    b2a8:	9b01      	ldr	r3, [sp, #4]
    b2aa:	785b      	ldrb	r3, [r3, #1]
    b2ac:	4618      	mov	r0, r3
    b2ae:	9b02      	ldr	r3, [sp, #8]
    b2b0:	8819      	ldrh	r1, [r3, #0]
    b2b2:	4a18      	ldr	r2, [pc, #96]	; (b314 <Can_43_FLEXCAN_Ipw_Init+0x214>)
    b2b4:	0183      	lsls	r3, r0, #6
    b2b6:	4413      	add	r3, r2
    b2b8:	330c      	adds	r3, #12
    b2ba:	460a      	mov	r2, r1
    b2bc:	801a      	strh	r2, [r3, #0]
                Can_Ipw_au16MbIdxToObjIDMap[Can_pControllerConfig->Can_u8ControllerID][7U] = Can_pHwObject->Can_HwObjectID;
    b2be:	9b01      	ldr	r3, [sp, #4]
    b2c0:	785b      	ldrb	r3, [r3, #1]
    b2c2:	4618      	mov	r0, r3
    b2c4:	9b02      	ldr	r3, [sp, #8]
    b2c6:	8819      	ldrh	r1, [r3, #0]
    b2c8:	4a12      	ldr	r2, [pc, #72]	; (b314 <Can_43_FLEXCAN_Ipw_Init+0x214>)
    b2ca:	0183      	lsls	r3, r0, #6
    b2cc:	4413      	add	r3, r2
    b2ce:	330e      	adds	r3, #14
    b2d0:	460a      	mov	r2, r1
    b2d2:	801a      	strh	r2, [r3, #0]
                break;
    b2d4:	e000      	b.n	b2d8 <Can_43_FLEXCAN_Ipw_Init+0x1d8>
                break;
    b2d6:	bf00      	nop
    for (u8HwObjRefIdx = 0U; u8HwObjRefIdx < Can_pControllerConfig->Can_u8HwObjectRefCount; u8HwObjRefIdx++)
    b2d8:	f89d 300f 	ldrb.w	r3, [sp, #15]
    b2dc:	3301      	adds	r3, #1
    b2de:	f88d 300f 	strb.w	r3, [sp, #15]
    b2e2:	9b01      	ldr	r3, [sp, #4]
    b2e4:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
    b2e8:	f89d 200f 	ldrb.w	r2, [sp, #15]
    b2ec:	429a      	cmp	r2, r3
    b2ee:	d38c      	bcc.n	b20a <Can_43_FLEXCAN_Ipw_Init+0x10a>
            }
        }
    }
#endif /* MB_INTERRUPT_SUPPORT */
    eRetVal = (Std_ReturnType)FlexCAN_Ip_SetStopMode(Can_pControllerConfig->Can_u8ControllerOffset);
    b2f0:	9b01      	ldr	r3, [sp, #4]
    b2f2:	789b      	ldrb	r3, [r3, #2]
    b2f4:	4618      	mov	r0, r3
    b2f6:	f002 fca5 	bl	dc44 <FlexCAN_Ip_SetStopMode_Privileged>
    b2fa:	4603      	mov	r3, r0
    b2fc:	f88d 300c 	strb.w	r3, [sp, #12]

    return (Std_ReturnType)eRetVal;
    b300:	f89d 300c 	ldrb.w	r3, [sp, #12]
}
    b304:	4618      	mov	r0, r3
    b306:	b004      	add	sp, #16
    b308:	bd10      	pop	{r4, pc}
    b30a:	bf00      	nop
    b30c:	000186d0 	.word	0x000186d0
    b310:	1fff935c 	.word	0x1fff935c
    b314:	1fff92dc 	.word	0x1fff92dc

0000b318 <Can_43_FLEXCAN_Ipw_DeInit>:

/**
*   @brief      De-Initialize Controller
*/
void Can_43_FLEXCAN_Ipw_DeInit(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
    b318:	b500      	push	{lr}
    b31a:	b083      	sub	sp, #12
    b31c:	9001      	str	r0, [sp, #4]
    /* @violates @ref Can_43_FLEXCAN_Ipw_c_REF_3 MISRA 2012 Advisory Rule 12.3 */
    (void)FlexCAN_Ip_Deinit(Can_pControllerConfig->Can_u8ControllerOffset);
    b31e:	9b01      	ldr	r3, [sp, #4]
    b320:	789b      	ldrb	r3, [r3, #2]
    b322:	4618      	mov	r0, r3
    b324:	f002 fafa 	bl	d91c <FlexCAN_Ip_Deinit_Privileged>
}
    b328:	bf00      	nop
    b32a:	b003      	add	sp, #12
    b32c:	f85d fb04 	ldr.w	pc, [sp], #4

0000b330 <Can_43_FLEXCAN_Ipw_SetControlerErrorInit>:

/**
*   @brief      Set Error Initialization and set Controller to start Mode.
*/
static Std_ReturnType Can_43_FLEXCAN_Ipw_SetControlerErrorInit(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
    b330:	b500      	push	{lr}
    b332:	b085      	sub	sp, #20
    b334:	9001      	str	r0, [sp, #4]
    Flexcan_Ip_StatusType eRetVal = FLEXCAN_STATUS_SUCCESS;
    b336:	2300      	movs	r3, #0
    b338:	9303      	str	r3, [sp, #12]

    if (TRUE == Can_Ipw_abIsInterruptEnabled[Can_pControllerConfig->Can_u8ControllerID])
    b33a:	9b01      	ldr	r3, [sp, #4]
    b33c:	785b      	ldrb	r3, [r3, #1]
    b33e:	461a      	mov	r2, r3
    b340:	4b11      	ldr	r3, [pc, #68]	; (b388 <Can_43_FLEXCAN_Ipw_SetControlerErrorInit+0x58>)
    b342:	5c9b      	ldrb	r3, [r3, r2]
    b344:	2b00      	cmp	r3, #0
    b346:	d012      	beq.n	b36e <Can_43_FLEXCAN_Ipw_SetControlerErrorInit+0x3e>
    {
#if (CAN_43_FLEXCAN_ERROR_INTERRUPT_SUPPORT == STD_ON)
        (void)FlexCAN_Ip_SetErrorInt(Can_pControllerConfig->Can_u8ControllerOffset, FLEXCAN_IP_INT_ERR, TRUE);
#endif /* ERROR_INTERRUPT_SUPPORT */
#if (CAN_43_FLEXCAN_BUSOFF_INTERRUPT_SUPPORT == STD_ON)
        if (FALSE == Can_pControllerConfig->Can_bBusOffUsesPolling)
    b348:	9b01      	ldr	r3, [sp, #4]
    b34a:	7a5b      	ldrb	r3, [r3, #9]
    b34c:	f083 0301 	eor.w	r3, r3, #1
    b350:	b2db      	uxtb	r3, r3
    b352:	2b00      	cmp	r3, #0
    b354:	d006      	beq.n	b364 <Can_43_FLEXCAN_Ipw_SetControlerErrorInit+0x34>
        {
            (void)FlexCAN_Ip_SetErrorInt(Can_pControllerConfig->Can_u8ControllerOffset, FLEXCAN_IP_INT_BUSOFF, TRUE);
    b356:	9b01      	ldr	r3, [sp, #4]
    b358:	789b      	ldrb	r3, [r3, #2]
    b35a:	2201      	movs	r2, #1
    b35c:	2104      	movs	r1, #4
    b35e:	4618      	mov	r0, r3
    b360:	f002 ff4c 	bl	e1fc <FlexCAN_Ip_SetErrorInt_Privileged>
        }
#endif  /* BUSOFF_INTERRUPT_SUPPORT */
        (void)FlexCAN_Ip_EnableInterrupts(Can_pControllerConfig->Can_u8ControllerOffset);
    b364:	9b01      	ldr	r3, [sp, #4]
    b366:	789b      	ldrb	r3, [r3, #2]
    b368:	4618      	mov	r0, r3
    b36a:	f002 feed 	bl	e148 <FlexCAN_Ip_EnableInterrupts_Privileged>
    }
    eRetVal = FlexCAN_Ip_SetStartMode(Can_pControllerConfig->Can_u8ControllerOffset);
    b36e:	9b01      	ldr	r3, [sp, #4]
    b370:	789b      	ldrb	r3, [r3, #2]
    b372:	4618      	mov	r0, r3
    b374:	f002 fc46 	bl	dc04 <FlexCAN_Ip_SetStartMode_Privileged>
    b378:	9003      	str	r0, [sp, #12]

    return (Std_ReturnType)eRetVal;
    b37a:	9b03      	ldr	r3, [sp, #12]
    b37c:	b2db      	uxtb	r3, r3
}
    b37e:	4618      	mov	r0, r3
    b380:	b005      	add	sp, #20
    b382:	f85d fb04 	ldr.w	pc, [sp], #4
    b386:	bf00      	nop
    b388:	1fff935c 	.word	0x1fff935c

0000b38c <Can_43_FLEXCAN_Ipw_SetControllerToStartMode>:

/**
*   @brief      Set Controller to participate the CAN network
*/
Std_ReturnType Can_43_FLEXCAN_Ipw_SetControllerToStartMode(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
    b38c:	b500      	push	{lr}
    b38e:	b087      	sub	sp, #28
    b390:	9001      	str	r0, [sp, #4]
#if (CAN_43_FLEXCAN_MB_INTERRUPT_SUPPORT == STD_ON)
    uint8 u8HwObjRefIdx = 0U;
    b392:	2300      	movs	r3, #0
    b394:	f88d 3017 	strb.w	r3, [sp, #23]
    const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject = NULL_PTR;
    b398:	2300      	movs	r3, #0
    b39a:	9303      	str	r3, [sp, #12]
        {
            Can_Ipw_u32CurrentCompareVal = Stm_Ip_GetCompareValue(CAN_43_FLEXCAN_TS_STM_INSTANCE, CAN_43_FLEXCAN_TS_STM_CHANNEL);
        }
    }
#endif
    eRetVal = FlexCAN_Ip_Init(Can_pControllerConfig->Can_u8ControllerOffset, \
    b39c:	9b01      	ldr	r3, [sp, #4]
    b39e:	7898      	ldrb	r0, [r3, #2]
    b3a0:	9b01      	ldr	r3, [sp, #4]
    b3a2:	785b      	ldrb	r3, [r3, #1]
    b3a4:	461a      	mov	r2, r3
    b3a6:	4b31      	ldr	r3, [pc, #196]	; (b46c <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0xe0>)
    b3a8:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
    b3ac:	9b01      	ldr	r3, [sp, #4]
    b3ae:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    b3b0:	681b      	ldr	r3, [r3, #0]
    b3b2:	461a      	mov	r2, r3
    b3b4:	f001 fbc2 	bl	cb3c <FlexCAN_Ip_Init_Privileged>
    b3b8:	9004      	str	r0, [sp, #16]
                                                    Can_Ipw_apxStatus[Can_pControllerConfig->Can_u8ControllerID], \
                                                    Can_pControllerConfig->HwChannelIpConfig->pFlexcanIpHwConfig);

    if (FLEXCAN_STATUS_SUCCESS == eRetVal)
    b3ba:	9b04      	ldr	r3, [sp, #16]
    b3bc:	2b00      	cmp	r3, #0
    b3be:	d14f      	bne.n	b460 <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0xd4>
    {
        /* disable all interrupts */
        (void)FlexCAN_Ip_DisableInterrupts(Can_pControllerConfig->Can_u8ControllerOffset);
    b3c0:	9b01      	ldr	r3, [sp, #4]
    b3c2:	789b      	ldrb	r3, [r3, #2]
    b3c4:	4618      	mov	r0, r3
    b3c6:	f002 feed 	bl	e1a4 <FlexCAN_Ip_DisableInterrupts_Privileged>

        /* Re-Init baudrate */
        Can_Ipw_InitBaudrate(Can_pControllerConfig);
    b3ca:	9801      	ldr	r0, [sp, #4]
    b3cc:	f7ff fd72 	bl	aeb4 <Can_Ipw_InitBaudrate>

        /* Re-Init all Rx Objects */
        Can_Ipw_InitRx(Can_pControllerConfig);
    b3d0:	9801      	ldr	r0, [sp, #4]
    b3d2:	f000 fa07 	bl	b7e4 <Can_Ipw_InitRx>
            Can_Ipw_abIsTxPduReady[Can_pControllerConfig->Can_u8ControllerID][MbIdx] = FALSE;
        }
    #endif /* ((CAN_43_FLEXCAN_TIMESTAMP_ENABLE == STD_ON) && ((CAN_43_FLEXCAN_TX_POLLING_SUPPORT == STD_ON) || (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON))) */

    #if (CAN_43_FLEXCAN_MB_INTERRUPT_SUPPORT == STD_ON)
        for (u8HwObjRefIdx = 0U; u8HwObjRefIdx < Can_pControllerConfig->Can_u8HwObjectRefCount; u8HwObjRefIdx++)
    b3d6:	2300      	movs	r3, #0
    b3d8:	f88d 3017 	strb.w	r3, [sp, #23]
    b3dc:	e02f      	b.n	b43e <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0xb2>
        {
            Can_pHwObject = (const Can_43_FLEXCAN_HwObjectConfigType *)Can_pControllerConfig->Can_ppHwObject[u8HwObjRefIdx];
    b3de:	9b01      	ldr	r3, [sp, #4]
    b3e0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    b3e2:	f89d 3017 	ldrb.w	r3, [sp, #23]
    b3e6:	009b      	lsls	r3, r3, #2
    b3e8:	4413      	add	r3, r2
    b3ea:	681b      	ldr	r3, [r3, #0]
    b3ec:	9303      	str	r3, [sp, #12]

            if (FALSE == Can_pHwObject->Can_bHwObjectUsesPolling)
    b3ee:	9b03      	ldr	r3, [sp, #12]
    b3f0:	7b1b      	ldrb	r3, [r3, #12]
    b3f2:	f083 0301 	eor.w	r3, r3, #1
    b3f6:	b2db      	uxtb	r3, r3
    b3f8:	2b00      	cmp	r3, #0
    b3fa:	d018      	beq.n	b42e <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0xa2>
            {
                switch (Can_pHwObject->Can_eReceiveType)
    b3fc:	9b03      	ldr	r3, [sp, #12]
    b3fe:	699b      	ldr	r3, [r3, #24]
    b400:	2b00      	cmp	r3, #0
    b402:	d003      	beq.n	b40c <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0x80>
    b404:	3b01      	subs	r3, #1
    b406:	2b01      	cmp	r3, #1
    b408:	d813      	bhi.n	b432 <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0xa6>
    b40a:	e009      	b.n	b420 <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0x94>
                {
                    case CAN_RX_NORMAL:
                    {
                        (void)FlexCAN_Ip_Receive(Can_pControllerConfig->Can_u8ControllerOffset, \
    b40c:	9b01      	ldr	r3, [sp, #4]
    b40e:	7898      	ldrb	r0, [r3, #2]
    b410:	9b03      	ldr	r3, [sp, #12]
    b412:	7f19      	ldrb	r1, [r3, #28]
    b414:	9b03      	ldr	r3, [sp, #12]
    b416:	7b1b      	ldrb	r3, [r3, #12]
    b418:	2200      	movs	r2, #0
    b41a:	f001 fc9b 	bl	cd54 <FlexCAN_Ip_Receive>
                                                 Can_pHwObject->Can_u8HwBufferIndex, \
                                                 NULL_PTR, \
                                                 Can_pHwObject->Can_bHwObjectUsesPolling \
                                                );
                        break;
    b41e:	e009      	b.n	b434 <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0xa8>
                            (void)FlexCAN_Ip_RxFifo(Can_pControllerConfig->Can_u8ControllerOffset, Can_pControllerConfig->pDmaDstAddr);
                        }
                        else
                    #endif
                        {
                            (void)FlexCAN_Ip_RxFifo(Can_pControllerConfig->Can_u8ControllerOffset, NULL_PTR);
    b420:	9b01      	ldr	r3, [sp, #4]
    b422:	789b      	ldrb	r3, [r3, #2]
    b424:	2100      	movs	r1, #0
    b426:	4618      	mov	r0, r3
    b428:	f001 fd92 	bl	cf50 <FlexCAN_Ip_RxFifo>
                        }
                        break;
    b42c:	e002      	b.n	b434 <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0xa8>
                    {
                        /* nothing to do(TX object) */
                        break;
                    }
                }
            }
    b42e:	bf00      	nop
    b430:	e000      	b.n	b434 <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0xa8>
                        break;
    b432:	bf00      	nop
        for (u8HwObjRefIdx = 0U; u8HwObjRefIdx < Can_pControllerConfig->Can_u8HwObjectRefCount; u8HwObjRefIdx++)
    b434:	f89d 3017 	ldrb.w	r3, [sp, #23]
    b438:	3301      	adds	r3, #1
    b43a:	f88d 3017 	strb.w	r3, [sp, #23]
    b43e:	9b01      	ldr	r3, [sp, #4]
    b440:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
    b444:	f89d 2017 	ldrb.w	r2, [sp, #23]
    b448:	429a      	cmp	r2, r3
    b44a:	d3c8      	bcc.n	b3de <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0x52>
        }
    #endif /* CAN_43_FLEXCAN_MB_INTERRUPT_SUPPORT == STD_ON */
        eRetVal = ((Std_ReturnType)E_OK == Can_43_FLEXCAN_Ipw_SetControlerErrorInit(Can_pControllerConfig)) ? (FLEXCAN_STATUS_SUCCESS) : (FLEXCAN_STATUS_ERROR);
    b44c:	9801      	ldr	r0, [sp, #4]
    b44e:	f7ff ff6f 	bl	b330 <Can_43_FLEXCAN_Ipw_SetControlerErrorInit>
    b452:	4603      	mov	r3, r0
    b454:	2b00      	cmp	r3, #0
    b456:	bf14      	ite	ne
    b458:	2301      	movne	r3, #1
    b45a:	2300      	moveq	r3, #0
    b45c:	b2db      	uxtb	r3, r3
    b45e:	9304      	str	r3, [sp, #16]
    }
    return (Std_ReturnType)eRetVal;
    b460:	9b04      	ldr	r3, [sp, #16]
    b462:	b2db      	uxtb	r3, r3
}
    b464:	4618      	mov	r0, r3
    b466:	b007      	add	sp, #28
    b468:	f85d fb04 	ldr.w	pc, [sp], #4
    b46c:	000186d0 	.word	0x000186d0

0000b470 <Can_43_FLEXCAN_Ipw_SetControllerToStopMode>:

/**
*   @brief      Set Controller to stop participating the CAN network
*/
Std_ReturnType Can_43_FLEXCAN_Ipw_SetControllerToStopMode(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
    b470:	b500      	push	{lr}
    b472:	b085      	sub	sp, #20
    b474:	9001      	str	r0, [sp, #4]
    * that are not allowed in the new state. ⌋
    * [SWS_Can_00426] ⌈ Disabling of CAN interrupts shall not be executed, when CAN
    * interrupts have been disabled by function Can_DisableControllerInterrupts.⌋
    */
    Std_ReturnType eReturnValue;
    uint8 u8HwObjRefIdx = 0U;
    b476:	2300      	movs	r3, #0
    b478:	f88d 300e 	strb.w	r3, [sp, #14]
    const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject;
    uint8 u8Idx = 0U;
    b47c:	2300      	movs	r3, #0
    b47e:	f88d 300d 	strb.w	r3, [sp, #13]

    if (FLEXCAN_STATUS_SUCCESS == FlexCAN_Ip_EnterFreezeMode(Can_pControllerConfig->Can_u8ControllerOffset))
    b482:	9b01      	ldr	r3, [sp, #4]
    b484:	789b      	ldrb	r3, [r3, #2]
    b486:	4618      	mov	r0, r3
    b488:	f002 f986 	bl	d798 <FlexCAN_Ip_EnterFreezeMode_Privileged>
    b48c:	4603      	mov	r3, r0
    b48e:	2b00      	cmp	r3, #0
    b490:	d160      	bne.n	b554 <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0xe4>
    {
    #if (CAN_43_FLEXCAN_PUBLIC_ICOM_SUPPORT == STD_ON)
        (void)FlexCAN_Ip_ConfigPN(Can_pControllerConfig->Can_u8ControllerOffset, FALSE, NULL_PTR);
    #endif

    if (TRUE == Can_Ipw_abIsInterruptEnabled[Can_pControllerConfig->Can_u8ControllerID])
    b492:	9b01      	ldr	r3, [sp, #4]
    b494:	785b      	ldrb	r3, [r3, #1]
    b496:	461a      	mov	r2, r3
    b498:	4b33      	ldr	r3, [pc, #204]	; (b568 <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0xf8>)
    b49a:	5c9b      	ldrb	r3, [r3, r2]
    b49c:	2b00      	cmp	r3, #0
    b49e:	d012      	beq.n	b4c6 <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0x56>
    {
        (void)FlexCAN_Ip_DisableInterrupts(Can_pControllerConfig->Can_u8ControllerOffset);
    b4a0:	9b01      	ldr	r3, [sp, #4]
    b4a2:	789b      	ldrb	r3, [r3, #2]
    b4a4:	4618      	mov	r0, r3
    b4a6:	f002 fe7d 	bl	e1a4 <FlexCAN_Ip_DisableInterrupts_Privileged>
#if (CAN_43_FLEXCAN_ERROR_INTERRUPT_SUPPORT == STD_ON)
        (void)FlexCAN_Ip_SetErrorInt(Can_pControllerConfig->Can_u8ControllerOffset, FLEXCAN_IP_INT_ERR, FALSE);
#endif  /*  ERROR_INTERRUPT_SUPPORT */
#if (CAN_43_FLEXCAN_BUSOFF_INTERRUPT_SUPPORT == STD_ON)
        if (FALSE == Can_pControllerConfig->Can_bBusOffUsesPolling)
    b4aa:	9b01      	ldr	r3, [sp, #4]
    b4ac:	7a5b      	ldrb	r3, [r3, #9]
    b4ae:	f083 0301 	eor.w	r3, r3, #1
    b4b2:	b2db      	uxtb	r3, r3
    b4b4:	2b00      	cmp	r3, #0
    b4b6:	d006      	beq.n	b4c6 <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0x56>
        {
            (void)FlexCAN_Ip_SetErrorInt(Can_pControllerConfig->Can_u8ControllerOffset, FLEXCAN_IP_INT_BUSOFF, FALSE);
    b4b8:	9b01      	ldr	r3, [sp, #4]
    b4ba:	789b      	ldrb	r3, [r3, #2]
    b4bc:	2200      	movs	r2, #0
    b4be:	2104      	movs	r1, #4
    b4c0:	4618      	mov	r0, r3
    b4c2:	f002 fe9b 	bl	e1fc <FlexCAN_Ip_SetErrorInt_Privileged>
        }
#endif /* BUSOFF_INTERRUPT_SUPPORT */
    }
    for (u8HwObjRefIdx = 0U; u8HwObjRefIdx < Can_pControllerConfig->Can_u8HwObjectRefCount; u8HwObjRefIdx++)
    b4c6:	2300      	movs	r3, #0
    b4c8:	f88d 300e 	strb.w	r3, [sp, #14]
    b4cc:	e032      	b.n	b534 <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0xc4>
    {
        Can_pHwObject = (const Can_43_FLEXCAN_HwObjectConfigType *)Can_pControllerConfig->Can_ppHwObject[u8HwObjRefIdx];
    b4ce:	9b01      	ldr	r3, [sp, #4]
    b4d0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    b4d2:	f89d 300e 	ldrb.w	r3, [sp, #14]
    b4d6:	009b      	lsls	r3, r3, #2
    b4d8:	4413      	add	r3, r2
    b4da:	681b      	ldr	r3, [r3, #0]
    b4dc:	9302      	str	r3, [sp, #8]

        if (CAN_TX_NORMAL == Can_pHwObject->Can_eReceiveType)
    b4de:	9b02      	ldr	r3, [sp, #8]
    b4e0:	699b      	ldr	r3, [r3, #24]
    b4e2:	2b03      	cmp	r3, #3
    b4e4:	d119      	bne.n	b51a <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0xaa>
        {
            u8Idx = 0U;
    b4e6:	2300      	movs	r3, #0
    b4e8:	f88d 300d 	strb.w	r3, [sp, #13]
            do
            {
                (void)FlexCAN_Ip_AbortTransfer(Can_pControllerConfig->Can_u8ControllerOffset, Can_pHwObject->Can_u8HwBufferIndex + u8Idx);
    b4ec:	9b01      	ldr	r3, [sp, #4]
    b4ee:	7898      	ldrb	r0, [r3, #2]
    b4f0:	9b02      	ldr	r3, [sp, #8]
    b4f2:	7f1a      	ldrb	r2, [r3, #28]
    b4f4:	f89d 300d 	ldrb.w	r3, [sp, #13]
    b4f8:	4413      	add	r3, r2
    b4fa:	b2db      	uxtb	r3, r3
    b4fc:	4619      	mov	r1, r3
    b4fe:	f002 ff03 	bl	e308 <FlexCAN_Ip_AbortTransfer>
                u8Idx++;
    b502:	f89d 300d 	ldrb.w	r3, [sp, #13]
    b506:	3301      	adds	r3, #1
    b508:	f88d 300d 	strb.w	r3, [sp, #13]
            }while (u8Idx < Can_pHwObject->Can_u8ObjectCount);
    b50c:	9b02      	ldr	r3, [sp, #8]
    b50e:	7b9b      	ldrb	r3, [r3, #14]
    b510:	f89d 200d 	ldrb.w	r2, [sp, #13]
    b514:	429a      	cmp	r2, r3
    b516:	d3e9      	bcc.n	b4ec <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0x7c>
    b518:	e007      	b.n	b52a <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0xba>
        }
        else
        {
            (void)FlexCAN_Ip_AbortTransfer(Can_pControllerConfig->Can_u8ControllerOffset, Can_pHwObject->Can_u8HwBufferIndex);
    b51a:	9b01      	ldr	r3, [sp, #4]
    b51c:	789a      	ldrb	r2, [r3, #2]
    b51e:	9b02      	ldr	r3, [sp, #8]
    b520:	7f1b      	ldrb	r3, [r3, #28]
    b522:	4619      	mov	r1, r3
    b524:	4610      	mov	r0, r2
    b526:	f002 feef 	bl	e308 <FlexCAN_Ip_AbortTransfer>
    for (u8HwObjRefIdx = 0U; u8HwObjRefIdx < Can_pControllerConfig->Can_u8HwObjectRefCount; u8HwObjRefIdx++)
    b52a:	f89d 300e 	ldrb.w	r3, [sp, #14]
    b52e:	3301      	adds	r3, #1
    b530:	f88d 300e 	strb.w	r3, [sp, #14]
    b534:	9b01      	ldr	r3, [sp, #4]
    b536:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
    b53a:	f89d 200e 	ldrb.w	r2, [sp, #14]
    b53e:	429a      	cmp	r2, r3
    b540:	d3c5      	bcc.n	b4ce <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0x5e>
        }
    }
    eReturnValue = (Std_ReturnType)FlexCAN_Ip_SetStopMode(Can_pControllerConfig->Can_u8ControllerOffset);
    b542:	9b01      	ldr	r3, [sp, #4]
    b544:	789b      	ldrb	r3, [r3, #2]
    b546:	4618      	mov	r0, r3
    b548:	f002 fb7c 	bl	dc44 <FlexCAN_Ip_SetStopMode_Privileged>
    b54c:	4603      	mov	r3, r0
    b54e:	f88d 300f 	strb.w	r3, [sp, #15]
    b552:	e002      	b.n	b55a <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0xea>
    }
    else
    {
        eReturnValue = E_NOT_OK;
    b554:	2301      	movs	r3, #1
    b556:	f88d 300f 	strb.w	r3, [sp, #15]
    }

    return eReturnValue;
    b55a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    b55e:	4618      	mov	r0, r3
    b560:	b005      	add	sp, #20
    b562:	f85d fb04 	ldr.w	pc, [sp], #4
    b566:	bf00      	nop
    b568:	1fff935c 	.word	0x1fff935c

0000b56c <Can_43_FLEXCAN_Ipw_DisableControllerInterrupts>:
/**
*   @brief      Disable Can Controller Interrupts
*/
void Can_43_FLEXCAN_Ipw_DisableControllerInterrupts(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
    b56c:	b500      	push	{lr}
    b56e:	b083      	sub	sp, #12
    b570:	9001      	str	r0, [sp, #4]
    if (TRUE == Can_Ipw_abIsInterruptEnabled[Can_pControllerConfig->Can_u8ControllerID])
    b572:	9b01      	ldr	r3, [sp, #4]
    b574:	785b      	ldrb	r3, [r3, #1]
    b576:	461a      	mov	r2, r3
    b578:	4b10      	ldr	r3, [pc, #64]	; (b5bc <Can_43_FLEXCAN_Ipw_DisableControllerInterrupts+0x50>)
    b57a:	5c9b      	ldrb	r3, [r3, r2]
    b57c:	2b00      	cmp	r3, #0
    b57e:	d018      	beq.n	b5b2 <Can_43_FLEXCAN_Ipw_DisableControllerInterrupts+0x46>
    {
        /* @violates @ref Can_43_FLEXCAN_Ipw_c_REF_3 MISRA 2012 Advisory Rule 12.3 */
        (void)FlexCAN_Ip_DisableInterrupts(Can_pControllerConfig->Can_u8ControllerOffset);
    b580:	9b01      	ldr	r3, [sp, #4]
    b582:	789b      	ldrb	r3, [r3, #2]
    b584:	4618      	mov	r0, r3
    b586:	f002 fe0d 	bl	e1a4 <FlexCAN_Ip_DisableInterrupts_Privileged>
        Can_Ipw_abIsInterruptEnabled[Can_pControllerConfig->Can_u8ControllerID] = FALSE;
    b58a:	9b01      	ldr	r3, [sp, #4]
    b58c:	785b      	ldrb	r3, [r3, #1]
    b58e:	461a      	mov	r2, r3
    b590:	4b0a      	ldr	r3, [pc, #40]	; (b5bc <Can_43_FLEXCAN_Ipw_DisableControllerInterrupts+0x50>)
    b592:	2100      	movs	r1, #0
    b594:	5499      	strb	r1, [r3, r2]
#if (CAN_43_FLEXCAN_ERROR_INTERRUPT_SUPPORT == STD_ON)
        (void)FlexCAN_Ip_SetErrorInt(Can_pControllerConfig->Can_u8ControllerOffset, FLEXCAN_IP_INT_ERR, FALSE);
#endif  /*  ERROR_INTERRUPT_SUPPORT */
#if (CAN_43_FLEXCAN_BUSOFF_INTERRUPT_SUPPORT == STD_ON)
        if (FALSE == Can_pControllerConfig->Can_bBusOffUsesPolling)
    b596:	9b01      	ldr	r3, [sp, #4]
    b598:	7a5b      	ldrb	r3, [r3, #9]
    b59a:	f083 0301 	eor.w	r3, r3, #1
    b59e:	b2db      	uxtb	r3, r3
    b5a0:	2b00      	cmp	r3, #0
    b5a2:	d006      	beq.n	b5b2 <Can_43_FLEXCAN_Ipw_DisableControllerInterrupts+0x46>
        {
            (void)FlexCAN_Ip_SetErrorInt(Can_pControllerConfig->Can_u8ControllerOffset, FLEXCAN_IP_INT_BUSOFF, FALSE);
    b5a4:	9b01      	ldr	r3, [sp, #4]
    b5a6:	789b      	ldrb	r3, [r3, #2]
    b5a8:	2200      	movs	r2, #0
    b5aa:	2104      	movs	r1, #4
    b5ac:	4618      	mov	r0, r3
    b5ae:	f002 fe25 	bl	e1fc <FlexCAN_Ip_SetErrorInt_Privileged>
        }
#endif /* BUSOFF_INTERRUPT_SUPPORT */
    }
}
    b5b2:	bf00      	nop
    b5b4:	b003      	add	sp, #12
    b5b6:	f85d fb04 	ldr.w	pc, [sp], #4
    b5ba:	bf00      	nop
    b5bc:	1fff935c 	.word	0x1fff935c

0000b5c0 <Can_43_FLEXCAN_Ipw_EnableControllerInterrupts>:

/**
*   @brief      Enable Can Controller Interrupts
*/
void Can_43_FLEXCAN_Ipw_EnableControllerInterrupts(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
    b5c0:	b500      	push	{lr}
    b5c2:	b083      	sub	sp, #12
    b5c4:	9001      	str	r0, [sp, #4]
    /*
    * [SWS_Can_00208] ⌈ The function Can_EnableControllerInterrupts shall perform no
    * action when Can_DisableControllerInterrupts has not been called before.⌋
    */
    if (FALSE == Can_Ipw_abIsInterruptEnabled[Can_pControllerConfig->Can_u8ControllerID])
    b5c6:	9b01      	ldr	r3, [sp, #4]
    b5c8:	785b      	ldrb	r3, [r3, #1]
    b5ca:	461a      	mov	r2, r3
    b5cc:	4b11      	ldr	r3, [pc, #68]	; (b614 <Can_43_FLEXCAN_Ipw_EnableControllerInterrupts+0x54>)
    b5ce:	5c9b      	ldrb	r3, [r3, r2]
    b5d0:	f083 0301 	eor.w	r3, r3, #1
    b5d4:	b2db      	uxtb	r3, r3
    b5d6:	2b00      	cmp	r3, #0
    b5d8:	d018      	beq.n	b60c <Can_43_FLEXCAN_Ipw_EnableControllerInterrupts+0x4c>
    {
        /* @violates @ref Can_43_FLEXCAN_Ipw_c_REF_3 MISRA 2012 Advisory Rule 12.3 */
        (void)FlexCAN_Ip_EnableInterrupts(Can_pControllerConfig->Can_u8ControllerOffset);
    b5da:	9b01      	ldr	r3, [sp, #4]
    b5dc:	789b      	ldrb	r3, [r3, #2]
    b5de:	4618      	mov	r0, r3
    b5e0:	f002 fdb2 	bl	e148 <FlexCAN_Ip_EnableInterrupts_Privileged>
#if (CAN_43_FLEXCAN_ERROR_INTERRUPT_SUPPORT == STD_ON)
        (void)FlexCAN_Ip_SetErrorInt(Can_pControllerConfig->Can_u8ControllerOffset, FLEXCAN_IP_INT_ERR, TRUE);
#endif /* ERROR_INTERRUPT_SUPPORT */
#if (CAN_43_FLEXCAN_BUSOFF_INTERRUPT_SUPPORT == STD_ON)
        if (FALSE == Can_pControllerConfig->Can_bBusOffUsesPolling)
    b5e4:	9b01      	ldr	r3, [sp, #4]
    b5e6:	7a5b      	ldrb	r3, [r3, #9]
    b5e8:	f083 0301 	eor.w	r3, r3, #1
    b5ec:	b2db      	uxtb	r3, r3
    b5ee:	2b00      	cmp	r3, #0
    b5f0:	d006      	beq.n	b600 <Can_43_FLEXCAN_Ipw_EnableControllerInterrupts+0x40>
        {
            (void)FlexCAN_Ip_SetErrorInt(Can_pControllerConfig->Can_u8ControllerOffset, FLEXCAN_IP_INT_BUSOFF, TRUE);
    b5f2:	9b01      	ldr	r3, [sp, #4]
    b5f4:	789b      	ldrb	r3, [r3, #2]
    b5f6:	2201      	movs	r2, #1
    b5f8:	2104      	movs	r1, #4
    b5fa:	4618      	mov	r0, r3
    b5fc:	f002 fdfe 	bl	e1fc <FlexCAN_Ip_SetErrorInt_Privileged>
        }
#endif  /* BUSOFF_INTERRUPT_SUPPORT */
        /* update status */
        Can_Ipw_abIsInterruptEnabled[Can_pControllerConfig->Can_u8ControllerID] = TRUE;
    b600:	9b01      	ldr	r3, [sp, #4]
    b602:	785b      	ldrb	r3, [r3, #1]
    b604:	461a      	mov	r2, r3
    b606:	4b03      	ldr	r3, [pc, #12]	; (b614 <Can_43_FLEXCAN_Ipw_EnableControllerInterrupts+0x54>)
    b608:	2101      	movs	r1, #1
    b60a:	5499      	strb	r1, [r3, r2]
    }
}
    b60c:	bf00      	nop
    b60e:	b003      	add	sp, #12
    b610:	f85d fb04 	ldr.w	pc, [sp], #4
    b614:	1fff935c 	.word	0x1fff935c

0000b618 <Can_43_FLEXCAN_Ipw_GetControllerErrorState>:

/**
*   @brief      Get Controller Error State
*/
Std_ReturnType Can_43_FLEXCAN_Ipw_GetControllerErrorState(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig, uint8 * pValue)
{
    b618:	b500      	push	{lr}
    b61a:	b085      	sub	sp, #20
    b61c:	9001      	str	r0, [sp, #4]
    b61e:	9100      	str	r1, [sp, #0]
    uint32 Error = 0U;
    b620:	2300      	movs	r3, #0
    b622:	9303      	str	r3, [sp, #12]

    Error = FlexCAN_Ip_GetErrorStatus(Can_pControllerConfig->Can_u8ControllerOffset);
    b624:	9b01      	ldr	r3, [sp, #4]
    b626:	789b      	ldrb	r3, [r3, #2]
    b628:	4618      	mov	r0, r3
    b62a:	f001 fe81 	bl	d330 <FlexCAN_Ip_GetErrorStatus>
    b62e:	9003      	str	r0, [sp, #12]

    *pValue = (uint8)((Error & FLEXCAN_ESR1_FLTCONF_MASK)>>FLEXCAN_ESR1_FLTCONF_SHIFT);
    b630:	9b03      	ldr	r3, [sp, #12]
    b632:	091b      	lsrs	r3, r3, #4
    b634:	b2db      	uxtb	r3, r3
    b636:	f003 0303 	and.w	r3, r3, #3
    b63a:	b2da      	uxtb	r2, r3
    b63c:	9b00      	ldr	r3, [sp, #0]
    b63e:	701a      	strb	r2, [r3, #0]
    return E_OK;
    b640:	2300      	movs	r3, #0
}
    b642:	4618      	mov	r0, r3
    b644:	b005      	add	sp, #20
    b646:	f85d fb04 	ldr.w	pc, [sp], #4

0000b64a <Can_43_FLEXCAN_Ipw_GetControllerTxErrorCounter>:

/**
*   @brief      Get Controller Tx Error Counter
*/
Std_ReturnType Can_43_FLEXCAN_Ipw_GetControllerTxErrorCounter(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig, uint8 * pValue)
{
    b64a:	b500      	push	{lr}
    b64c:	b083      	sub	sp, #12
    b64e:	9001      	str	r0, [sp, #4]
    b650:	9100      	str	r1, [sp, #0]
     *pValue = FlexCAN_Ip_GetControllerTxErrorCounter(Can_pControllerConfig->Can_u8ControllerOffset);
    b652:	9b01      	ldr	r3, [sp, #4]
    b654:	789b      	ldrb	r3, [r3, #2]
    b656:	4618      	mov	r0, r3
    b658:	f001 fe7c 	bl	d354 <FlexCAN_Ip_GetControllerTxErrorCounter>
    b65c:	4603      	mov	r3, r0
    b65e:	461a      	mov	r2, r3
    b660:	9b00      	ldr	r3, [sp, #0]
    b662:	701a      	strb	r2, [r3, #0]
     return E_OK;
    b664:	2300      	movs	r3, #0
}
    b666:	4618      	mov	r0, r3
    b668:	b003      	add	sp, #12
    b66a:	f85d fb04 	ldr.w	pc, [sp], #4

0000b66e <Can_43_FLEXCAN_Ipw_GetControllerRxErrorCounter>:

/**
*   @brief      Get Controller Rx Error Counter
*/
Std_ReturnType Can_43_FLEXCAN_Ipw_GetControllerRxErrorCounter(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig, uint8 * pValue)
{
    b66e:	b500      	push	{lr}
    b670:	b083      	sub	sp, #12
    b672:	9001      	str	r0, [sp, #4]
    b674:	9100      	str	r1, [sp, #0]

    *pValue = FlexCAN_Ip_GetControllerRxErrorCounter(Can_pControllerConfig->Can_u8ControllerOffset);
    b676:	9b01      	ldr	r3, [sp, #4]
    b678:	789b      	ldrb	r3, [r3, #2]
    b67a:	4618      	mov	r0, r3
    b67c:	f001 fe7c 	bl	d378 <FlexCAN_Ip_GetControllerRxErrorCounter>
    b680:	4603      	mov	r3, r0
    b682:	461a      	mov	r2, r3
    b684:	9b00      	ldr	r3, [sp, #0]
    b686:	701a      	strb	r2, [r3, #0]
    return E_OK;
    b688:	2300      	movs	r3, #0
}
    b68a:	4618      	mov	r0, r3
    b68c:	b003      	add	sp, #12
    b68e:	f85d fb04 	ldr.w	pc, [sp], #4

0000b692 <Can_43_FLEXCAN_Ipw_Write>:
(
    const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig,
    const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObjectConfig,
    const Can_PduType * PduInfo
)
{
    b692:	b510      	push	{r4, lr}
    b694:	b08c      	sub	sp, #48	; 0x30
    b696:	9005      	str	r0, [sp, #20]
    b698:	9104      	str	r1, [sp, #16]
    b69a:	9203      	str	r2, [sp, #12]
    Flexcan_Ip_StatusType eRetVal = FLEXCAN_STATUS_ERROR;
    b69c:	2301      	movs	r3, #1
    b69e:	930b      	str	r3, [sp, #44]	; 0x2c
    Flexcan_Ip_DataInfoType DataInfo;
    uint8 u8ObjIdx = 0U;
    b6a0:	2300      	movs	r3, #0
    b6a2:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
#if (CAN_43_FLEXCAN_TRIGGER_TRANSMIT_USED == STD_ON)
    PduInfoType CanIf_PduInfo;
    uint8 Data[64U];
#endif

    DataInfo.msg_id_type = FLEXCAN_MSG_ID_STD;
    b6a6:	2300      	movs	r3, #0
    b6a8:	9306      	str	r3, [sp, #24]
    DataInfo.data_length = 0U;
    b6aa:	2300      	movs	r3, #0
    b6ac:	9307      	str	r3, [sp, #28]
    DataInfo.fd_padding = 0U;
    b6ae:	2300      	movs	r3, #0
    b6b0:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
    DataInfo.fd_enable = FALSE;
    b6b4:	2300      	movs	r3, #0
    b6b6:	f88d 3020 	strb.w	r3, [sp, #32]
    DataInfo.enable_brs = FALSE;
    b6ba:	2300      	movs	r3, #0
    b6bc:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    DataInfo.is_remote = FALSE;
    b6c0:	2300      	movs	r3, #0
    b6c2:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    DataInfo.is_polling = FALSE;
    b6c6:	2300      	movs	r3, #0
    b6c8:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
    if (CAN_TX_NORMAL == Can_pHwObjectConfig->Can_eReceiveType)
    b6cc:	9b04      	ldr	r3, [sp, #16]
    b6ce:	699b      	ldr	r3, [r3, #24]
    b6d0:	2b03      	cmp	r3, #3
    b6d2:	d173      	bne.n	b7bc <Can_43_FLEXCAN_Ipw_Write+0x12a>
    {
        DataInfo.msg_id_type = ((PduInfo->id & CAN_43_FLEXCAN_EXTENDED_ID_U32) != 0U) ? FLEXCAN_MSG_ID_EXT : FLEXCAN_MSG_ID_STD;
    b6d4:	9b03      	ldr	r3, [sp, #12]
    b6d6:	681b      	ldr	r3, [r3, #0]
    b6d8:	0fdb      	lsrs	r3, r3, #31
    b6da:	9306      	str	r3, [sp, #24]
        if (Can_pHwObjectConfig->Can_u8PayloadLength <=  PduInfo->length)
    b6dc:	9b04      	ldr	r3, [sp, #16]
    b6de:	7c1a      	ldrb	r2, [r3, #16]
    b6e0:	9b03      	ldr	r3, [sp, #12]
    b6e2:	799b      	ldrb	r3, [r3, #6]
    b6e4:	429a      	cmp	r2, r3
    b6e6:	d803      	bhi.n	b6f0 <Can_43_FLEXCAN_Ipw_Write+0x5e>
        {
            DataInfo.data_length = Can_pHwObjectConfig->Can_u8PayloadLength;
    b6e8:	9b04      	ldr	r3, [sp, #16]
    b6ea:	7c1b      	ldrb	r3, [r3, #16]
    b6ec:	9307      	str	r3, [sp, #28]
    b6ee:	e002      	b.n	b6f6 <Can_43_FLEXCAN_Ipw_Write+0x64>
        }
        else
        {
            DataInfo.data_length = PduInfo->length;
    b6f0:	9b03      	ldr	r3, [sp, #12]
    b6f2:	799b      	ldrb	r3, [r3, #6]
    b6f4:	9307      	str	r3, [sp, #28]
        }
#if (CAN_43_FLEXCAN_FEATURE_HAS_FD == STD_ON)
        DataInfo.fd_padding = Can_pHwObjectConfig->Can_u8PaddingValue;
    b6f6:	9b04      	ldr	r3, [sp, #16]
    b6f8:	7c5b      	ldrb	r3, [r3, #17]
    b6fa:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
        DataInfo.fd_enable = ((PduInfo->id & CAN_43_FLEXCAN_FD_FRAME_U32) != 0U) ? TRUE : FALSE;
    b6fe:	9b03      	ldr	r3, [sp, #12]
    b700:	681b      	ldr	r3, [r3, #0]
    b702:	0f9b      	lsrs	r3, r3, #30
    b704:	f003 0301 	and.w	r3, r3, #1
    b708:	2b00      	cmp	r3, #0
    b70a:	bf14      	ite	ne
    b70c:	2301      	movne	r3, #1
    b70e:	2300      	moveq	r3, #0
    b710:	b2db      	uxtb	r3, r3
    b712:	f88d 3020 	strb.w	r3, [sp, #32]
    #if (CAN_43_FLEXCAN_SET_BAUDRATE_API == STD_ON)
            DataInfo.enable_brs = Can_pControllerConfig->Can_pBaudrateConfig[Can_au16ControllerBaudRateSel[Can_pControllerConfig->Can_u8ControllerID]].Can_bBitRateSwitch;
    #else
        DataInfo.enable_brs = Can_pControllerConfig->Can_pBaudrateConfig[Can_pControllerConfig->Can_u16DefaultBaudrateID].Can_bBitRateSwitch;
    b716:	9b05      	ldr	r3, [sp, #20]
    b718:	6a1a      	ldr	r2, [r3, #32]
    b71a:	9b05      	ldr	r3, [sp, #20]
    b71c:	8b9b      	ldrh	r3, [r3, #28]
    b71e:	4619      	mov	r1, r3
    b720:	2316      	movs	r3, #22
    b722:	fb01 f303 	mul.w	r3, r1, r3
    b726:	4413      	add	r3, r2
    b728:	781b      	ldrb	r3, [r3, #0]
    b72a:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    #endif
#endif
        DataInfo.is_remote = FALSE;
    b72e:	2300      	movs	r3, #0
    b730:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
        DataInfo.is_polling = Can_pHwObjectConfig->Can_bHwObjectUsesPolling;
    b734:	9b04      	ldr	r3, [sp, #16]
    b736:	7b1b      	ldrb	r3, [r3, #12]
    b738:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
        do
        {
            eRetVal = FlexCAN_Ip_GetTransferStatus(Can_pControllerConfig->Can_u8ControllerOffset, Can_pHwObjectConfig->Can_u8HwBufferIndex + u8ObjIdx);
    b73c:	9b05      	ldr	r3, [sp, #20]
    b73e:	7898      	ldrb	r0, [r3, #2]
    b740:	9b04      	ldr	r3, [sp, #16]
    b742:	7f1a      	ldrb	r2, [r3, #28]
    b744:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
    b748:	4413      	add	r3, r2
    b74a:	b2db      	uxtb	r3, r3
    b74c:	4619      	mov	r1, r3
    b74e:	f001 fcdd 	bl	d10c <FlexCAN_Ip_GetTransferStatus>
    b752:	900b      	str	r0, [sp, #44]	; 0x2c
            if (FLEXCAN_STATUS_SUCCESS == eRetVal)
    b754:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    b756:	2b00      	cmp	r3, #0
    b758:	d122      	bne.n	b7a0 <Can_43_FLEXCAN_Ipw_Write+0x10e>
            {
                #if ((CAN_43_FLEXCAN_TX_POLLING_SUPPORT == STD_ON) || (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON))
                Can_Ipw_au16TxPduId[Can_pControllerConfig->Can_u8ControllerID][Can_pHwObjectConfig->Can_u8HwBufferIndex+u8ObjIdx] = PduInfo->swPduHandle;
    b75a:	9b05      	ldr	r3, [sp, #20]
    b75c:	785b      	ldrb	r3, [r3, #1]
    b75e:	461c      	mov	r4, r3
    b760:	9b04      	ldr	r3, [sp, #16]
    b762:	7f1b      	ldrb	r3, [r3, #28]
    b764:	461a      	mov	r2, r3
    b766:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
    b76a:	4413      	add	r3, r2
    b76c:	9a03      	ldr	r2, [sp, #12]
    b76e:	8890      	ldrh	r0, [r2, #4]
    b770:	491b      	ldr	r1, [pc, #108]	; (b7e0 <Can_43_FLEXCAN_Ipw_Write+0x14e>)
    b772:	0162      	lsls	r2, r4, #5
    b774:	4413      	add	r3, r2
    b776:	4602      	mov	r2, r0
    b778:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
                    }
                }
                else
                {
            #endif
                    eRetVal = FlexCAN_Ip_Send(Can_pControllerConfig->Can_u8ControllerOffset, Can_pHwObjectConfig->Can_u8HwBufferIndex + u8ObjIdx, &DataInfo, PduInfo->id, PduInfo->sdu);
    b77c:	9b05      	ldr	r3, [sp, #20]
    b77e:	7898      	ldrb	r0, [r3, #2]
    b780:	9b04      	ldr	r3, [sp, #16]
    b782:	7f1a      	ldrb	r2, [r3, #28]
    b784:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
    b788:	4413      	add	r3, r2
    b78a:	b2d9      	uxtb	r1, r3
    b78c:	9b03      	ldr	r3, [sp, #12]
    b78e:	681c      	ldr	r4, [r3, #0]
    b790:	9b03      	ldr	r3, [sp, #12]
    b792:	689b      	ldr	r3, [r3, #8]
    b794:	aa06      	add	r2, sp, #24
    b796:	9300      	str	r3, [sp, #0]
    b798:	4623      	mov	r3, r4
    b79a:	f001 fa4b 	bl	cc34 <FlexCAN_Ip_Send>
    b79e:	900b      	str	r0, [sp, #44]	; 0x2c
                /* Revert to FALSE due to the MB was not transmitted successfully */
                Can_Ipw_abIsTxPduReady[Can_pControllerConfig->Can_u8ControllerID][Can_pHwObjectConfig->Can_u8HwBufferIndex+u8ObjIdx] = FALSE;
            }
            #endif /* ((CAN_43_FLEXCAN_TIMESTAMP_ENABLE == STD_ON) && ((CAN_43_FLEXCAN_TX_POLLING_SUPPORT == STD_ON) || (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON))) */
            }
            u8ObjIdx++;
    b7a0:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
    b7a4:	3301      	adds	r3, #1
    b7a6:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
        } while ((u8ObjIdx < Can_pHwObjectConfig->Can_u8ObjectCount) && (FLEXCAN_STATUS_BUSY == eRetVal));
    b7aa:	9b04      	ldr	r3, [sp, #16]
    b7ac:	7b9b      	ldrb	r3, [r3, #14]
    b7ae:	f89d 202b 	ldrb.w	r2, [sp, #43]	; 0x2b
    b7b2:	429a      	cmp	r2, r3
    b7b4:	d202      	bcs.n	b7bc <Can_43_FLEXCAN_Ipw_Write+0x12a>
    b7b6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    b7b8:	2b02      	cmp	r3, #2
    b7ba:	d0bf      	beq.n	b73c <Can_43_FLEXCAN_Ipw_Write+0xaa>
    }

    if ((FLEXCAN_STATUS_SUCCESS != eRetVal) && (FLEXCAN_STATUS_BUSY != eRetVal))
    b7bc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    b7be:	2b00      	cmp	r3, #0
    b7c0:	d004      	beq.n	b7cc <Can_43_FLEXCAN_Ipw_Write+0x13a>
    b7c2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    b7c4:	2b02      	cmp	r3, #2
    b7c6:	d001      	beq.n	b7cc <Can_43_FLEXCAN_Ipw_Write+0x13a>
    {
        eRetVal = FLEXCAN_STATUS_ERROR;
    b7c8:	2301      	movs	r3, #1
    b7ca:	930b      	str	r3, [sp, #44]	; 0x2c
    }

    return ((FLEXCAN_STATUS_BUSY == eRetVal) ? ((Std_ReturnType)CAN_BUSY) : ((Std_ReturnType)eRetVal));
    b7cc:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    b7ce:	2b02      	cmp	r3, #2
    b7d0:	d002      	beq.n	b7d8 <Can_43_FLEXCAN_Ipw_Write+0x146>
    b7d2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    b7d4:	b2db      	uxtb	r3, r3
    b7d6:	e000      	b.n	b7da <Can_43_FLEXCAN_Ipw_Write+0x148>
    b7d8:	2302      	movs	r3, #2
}
    b7da:	4618      	mov	r0, r3
    b7dc:	b00c      	add	sp, #48	; 0x30
    b7de:	bd10      	pop	{r4, pc}
    b7e0:	1fff925c 	.word	0x1fff925c

0000b7e4 <Can_Ipw_InitRx>:

static void Can_Ipw_InitRx(const Can_43_FLEXCAN_ControllerConfigType * Can_pController)
{
    b7e4:	b500      	push	{lr}
    b7e6:	b089      	sub	sp, #36	; 0x24
    b7e8:	9001      	str	r0, [sp, #4]
    uint8 u8HwObjRefIdx = 0U;
    b7ea:	2300      	movs	r3, #0
    b7ec:	f88d 301f 	strb.w	r3, [sp, #31]
    const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject;
    Flexcan_Ip_DataInfoType DataInfo;

    /* This function just is called only if controller is in freeze mode */
    /* Always enable individual mask , Already in freeze mode */
    (void)FlexCAN_Ip_SetRxMaskType(Can_pController->Can_u8ControllerOffset, FLEXCAN_RX_MASK_INDIVIDUAL);
    b7f0:	9b01      	ldr	r3, [sp, #4]
    b7f2:	789b      	ldrb	r3, [r3, #2]
    b7f4:	2101      	movs	r1, #1
    b7f6:	4618      	mov	r0, r3
    b7f8:	f002 fa42 	bl	dc80 <FlexCAN_Ip_SetRxMaskType_Privileged>

    for (u8HwObjRefIdx = 0U; u8HwObjRefIdx < Can_pController->Can_u8HwObjectRefCount; u8HwObjRefIdx++)
    b7fc:	2300      	movs	r3, #0
    b7fe:	f88d 301f 	strb.w	r3, [sp, #31]
    b802:	e03a      	b.n	b87a <Can_Ipw_InitRx+0x96>
    {
        Can_pHwObject = (const Can_43_FLEXCAN_HwObjectConfigType *)Can_pController->Can_ppHwObject[u8HwObjRefIdx];
    b804:	9b01      	ldr	r3, [sp, #4]
    b806:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    b808:	f89d 301f 	ldrb.w	r3, [sp, #31]
    b80c:	009b      	lsls	r3, r3, #2
    b80e:	4413      	add	r3, r2
    b810:	681b      	ldr	r3, [r3, #0]
    b812:	9306      	str	r3, [sp, #24]

        if (CAN_RX_NORMAL == Can_pHwObject->Can_eReceiveType)
    b814:	9b06      	ldr	r3, [sp, #24]
    b816:	699b      	ldr	r3, [r3, #24]
    b818:	2b00      	cmp	r3, #0
    b81a:	d121      	bne.n	b860 <Can_Ipw_InitRx+0x7c>
        {
            DataInfo.fd_enable = FALSE;
    b81c:	2300      	movs	r3, #0
    b81e:	f88d 3010 	strb.w	r3, [sp, #16]
            DataInfo.data_length = 0U;
    b822:	2300      	movs	r3, #0
    b824:	9303      	str	r3, [sp, #12]
            if (Can_pHwObject->Can_IdMessage != CAN_STANDARD)
    b826:	9b06      	ldr	r3, [sp, #24]
    b828:	689b      	ldr	r3, [r3, #8]
    b82a:	2b00      	cmp	r3, #0
    b82c:	d002      	beq.n	b834 <Can_Ipw_InitRx+0x50>
            {
                DataInfo.msg_id_type = FLEXCAN_MSG_ID_EXT;
    b82e:	2301      	movs	r3, #1
    b830:	9302      	str	r3, [sp, #8]
    b832:	e001      	b.n	b838 <Can_Ipw_InitRx+0x54>
            }
            else
            {
                DataInfo.msg_id_type = FLEXCAN_MSG_ID_STD;
    b834:	2300      	movs	r3, #0
    b836:	9302      	str	r3, [sp, #8]
            }
            (void)FlexCAN_Ip_ConfigRxMb(Can_pController->Can_u8ControllerOffset, Can_pHwObject->Can_u8HwBufferIndex, &DataInfo, Can_pHwObject->Can_pHwFilterConfig->Can_u32HwFilterCode);
    b838:	9b01      	ldr	r3, [sp, #4]
    b83a:	7898      	ldrb	r0, [r3, #2]
    b83c:	9b06      	ldr	r3, [sp, #24]
    b83e:	7f19      	ldrb	r1, [r3, #28]
    b840:	9b06      	ldr	r3, [sp, #24]
    b842:	695b      	ldr	r3, [r3, #20]
    b844:	681b      	ldr	r3, [r3, #0]
    b846:	aa02      	add	r2, sp, #8
    b848:	f001 fa40 	bl	cccc <FlexCAN_Ip_ConfigRxMb>
            /* Already in freeze mode */
            (void)FlexCAN_Ip_SetRxIndividualMask(Can_pController->Can_u8ControllerOffset, Can_pHwObject->Can_u8HwBufferIndex, Can_pHwObject->Can_pHwFilterConfig->Can_u32HwFilterMask);
    b84c:	9b01      	ldr	r3, [sp, #4]
    b84e:	7898      	ldrb	r0, [r3, #2]
    b850:	9b06      	ldr	r3, [sp, #24]
    b852:	7f19      	ldrb	r1, [r3, #28]
    b854:	9b06      	ldr	r3, [sp, #24]
    b856:	695b      	ldr	r3, [r3, #20]
    b858:	685b      	ldr	r3, [r3, #4]
    b85a:	461a      	mov	r2, r3
    b85c:	f001 ffc8 	bl	d7f0 <FlexCAN_Ip_SetRxIndividualMask_Privileged>
        }

        if (CAN_RX_LEGACY_FIFO == Can_pHwObject->Can_eReceiveType)
    b860:	9b06      	ldr	r3, [sp, #24]
    b862:	699b      	ldr	r3, [r3, #24]
    b864:	2b01      	cmp	r3, #1
    b866:	d103      	bne.n	b870 <Can_Ipw_InitRx+0x8c>
        {
            Can_Ipw_InitLegacyFifoFilter(Can_pController, Can_pHwObject);
    b868:	9906      	ldr	r1, [sp, #24]
    b86a:	9801      	ldr	r0, [sp, #4]
    b86c:	f7ff f8ff 	bl	aa6e <Can_Ipw_InitLegacyFifoFilter>
    for (u8HwObjRefIdx = 0U; u8HwObjRefIdx < Can_pController->Can_u8HwObjectRefCount; u8HwObjRefIdx++)
    b870:	f89d 301f 	ldrb.w	r3, [sp, #31]
    b874:	3301      	adds	r3, #1
    b876:	f88d 301f 	strb.w	r3, [sp, #31]
    b87a:	9b01      	ldr	r3, [sp, #4]
    b87c:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
    b880:	f89d 201f 	ldrb.w	r2, [sp, #31]
    b884:	429a      	cmp	r2, r3
    b886:	d3bd      	bcc.n	b804 <Can_Ipw_InitRx+0x20>
        }
    }
}
    b888:	bf00      	nop
    b88a:	bf00      	nop
    b88c:	b009      	add	sp, #36	; 0x24
    b88e:	f85d fb04 	ldr.w	pc, [sp], #4

0000b892 <Can_43_FLEXCAN_Ipw_MainFunction_Mode>:
void Can_43_FLEXCAN_Ipw_MainFunction_Mode
(
    const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig,
    Can_ControllerStateType * Can_pControllerState
)
{
    b892:	b500      	push	{lr}
    b894:	b083      	sub	sp, #12
    b896:	9001      	str	r0, [sp, #4]
    b898:	9100      	str	r1, [sp, #0]
    /* @violates @ref Can_43_FLEXCAN_Ipw_c_REF_3 MISRA 2012 Advisory Rule 12.3 */
    if (CAN_CS_STARTED == *Can_pControllerState)
    b89a:	9b00      	ldr	r3, [sp, #0]
    b89c:	681b      	ldr	r3, [r3, #0]
    b89e:	2b01      	cmp	r3, #1
    b8a0:	d114      	bne.n	b8cc <Can_43_FLEXCAN_Ipw_MainFunction_Mode+0x3a>
    {
        if (FALSE == FlexCAN_Ip_GetStartMode(Can_pControllerConfig->Can_u8ControllerOffset))
    b8a2:	9b01      	ldr	r3, [sp, #4]
    b8a4:	789b      	ldrb	r3, [r3, #2]
    b8a6:	4618      	mov	r0, r3
    b8a8:	f002 f994 	bl	dbd4 <FlexCAN_Ip_GetStartMode_Privileged>
    b8ac:	4603      	mov	r3, r0
    b8ae:	f083 0301 	eor.w	r3, r3, #1
    b8b2:	b2db      	uxtb	r3, r3
    b8b4:	2b00      	cmp	r3, #0
    b8b6:	d01e      	beq.n	b8f6 <Can_43_FLEXCAN_Ipw_MainFunction_Mode+0x64>
        {
            *Can_pControllerState = CAN_CS_STOPPED;
    b8b8:	9b00      	ldr	r3, [sp, #0]
    b8ba:	2202      	movs	r2, #2
    b8bc:	601a      	str	r2, [r3, #0]
            CanIf_ControllerModeIndication(Can_pControllerConfig->Can_u8AbstControllerID, CAN_CS_STOPPED);
    b8be:	9b01      	ldr	r3, [sp, #4]
    b8c0:	781b      	ldrb	r3, [r3, #0]
    b8c2:	2102      	movs	r1, #2
    b8c4:	4618      	mov	r0, r3
    b8c6:	f00b fc61 	bl	1718c <CanIf_ControllerModeIndication>
    }
    else
    {
        /* nothing to do */
    }
}
    b8ca:	e014      	b.n	b8f6 <Can_43_FLEXCAN_Ipw_MainFunction_Mode+0x64>
    else if (CAN_CS_STOPPED == *Can_pControllerState)
    b8cc:	9b00      	ldr	r3, [sp, #0]
    b8ce:	681b      	ldr	r3, [r3, #0]
    b8d0:	2b02      	cmp	r3, #2
    b8d2:	d110      	bne.n	b8f6 <Can_43_FLEXCAN_Ipw_MainFunction_Mode+0x64>
        if (TRUE == FlexCAN_Ip_GetStartMode(Can_pControllerConfig->Can_u8ControllerOffset))
    b8d4:	9b01      	ldr	r3, [sp, #4]
    b8d6:	789b      	ldrb	r3, [r3, #2]
    b8d8:	4618      	mov	r0, r3
    b8da:	f002 f97b 	bl	dbd4 <FlexCAN_Ip_GetStartMode_Privileged>
    b8de:	4603      	mov	r3, r0
    b8e0:	2b00      	cmp	r3, #0
    b8e2:	d008      	beq.n	b8f6 <Can_43_FLEXCAN_Ipw_MainFunction_Mode+0x64>
            *Can_pControllerState = CAN_CS_STARTED;
    b8e4:	9b00      	ldr	r3, [sp, #0]
    b8e6:	2201      	movs	r2, #1
    b8e8:	601a      	str	r2, [r3, #0]
            CanIf_ControllerModeIndication(Can_pControllerConfig->Can_u8AbstControllerID, CAN_CS_STARTED);
    b8ea:	9b01      	ldr	r3, [sp, #4]
    b8ec:	781b      	ldrb	r3, [r3, #0]
    b8ee:	2101      	movs	r1, #1
    b8f0:	4618      	mov	r0, r3
    b8f2:	f00b fc4b 	bl	1718c <CanIf_ControllerModeIndication>
}
    b8f6:	bf00      	nop
    b8f8:	b003      	add	sp, #12
    b8fa:	f85d fb04 	ldr.w	pc, [sp], #4

0000b8fe <Can_43_FLEXCAN_Ipw_ProcessHwObject>:
        const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig,
        const Can_43_FLEXCAN_ConfigType * Can_pConfig,
        uint8 u8MbIdx,
        Can_43_FLEXCAN_MbType mbType
    )
    {
    b8fe:	b500      	push	{lr}
    b900:	b085      	sub	sp, #20
    b902:	9003      	str	r0, [sp, #12]
    b904:	9102      	str	r1, [sp, #8]
    b906:	9300      	str	r3, [sp, #0]
    b908:	4613      	mov	r3, r2
    b90a:	f88d 3007 	strb.w	r3, [sp, #7]
        switch (mbType)
    b90e:	9b00      	ldr	r3, [sp, #0]
    b910:	2b03      	cmp	r3, #3
    b912:	d009      	beq.n	b928 <Can_43_FLEXCAN_Ipw_ProcessHwObject+0x2a>
    b914:	9b00      	ldr	r3, [sp, #0]
    b916:	2b03      	cmp	r3, #3
    b918:	d821      	bhi.n	b95e <Can_43_FLEXCAN_Ipw_ProcessHwObject+0x60>
    b91a:	9b00      	ldr	r3, [sp, #0]
    b91c:	2b00      	cmp	r3, #0
    b91e:	d00c      	beq.n	b93a <Can_43_FLEXCAN_Ipw_ProcessHwObject+0x3c>
    b920:	9b00      	ldr	r3, [sp, #0]
    b922:	2b01      	cmp	r3, #1
    b924:	d012      	beq.n	b94c <Can_43_FLEXCAN_Ipw_ProcessHwObject+0x4e>
                break;
            }
            default:
            {
                /* prevent misra */
                break;
    b926:	e01a      	b.n	b95e <Can_43_FLEXCAN_Ipw_ProcessHwObject+0x60>
                Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer(Can_pControllerConfig, Can_pConfig->Can_pHwObjectConfig, u8MbIdx);
    b928:	9b02      	ldr	r3, [sp, #8]
    b92a:	691b      	ldr	r3, [r3, #16]
    b92c:	f89d 2007 	ldrb.w	r2, [sp, #7]
    b930:	4619      	mov	r1, r3
    b932:	9803      	ldr	r0, [sp, #12]
    b934:	f7ff faf8 	bl	af28 <Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer>
                break;
    b938:	e012      	b.n	b960 <Can_43_FLEXCAN_Ipw_ProcessHwObject+0x62>
                Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer(Can_pControllerConfig, Can_pConfig->Can_pHwObjectConfig, u8MbIdx);
    b93a:	9b02      	ldr	r3, [sp, #8]
    b93c:	691b      	ldr	r3, [r3, #16]
    b93e:	f89d 2007 	ldrb.w	r2, [sp, #7]
    b942:	4619      	mov	r1, r3
    b944:	9803      	ldr	r0, [sp, #12]
    b946:	f7ff fb3b 	bl	afc0 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer>
                break;
    b94a:	e009      	b.n	b960 <Can_43_FLEXCAN_Ipw_ProcessHwObject+0x62>
                    Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer(Can_pControllerConfig, Can_pConfig->Can_pHwObjectConfig, u8MbIdx);
    b94c:	9b02      	ldr	r3, [sp, #8]
    b94e:	691b      	ldr	r3, [r3, #16]
    b950:	f89d 2007 	ldrb.w	r2, [sp, #7]
    b954:	4619      	mov	r1, r3
    b956:	9803      	ldr	r0, [sp, #12]
    b958:	f7ff fb32 	bl	afc0 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer>
                break;
    b95c:	e000      	b.n	b960 <Can_43_FLEXCAN_Ipw_ProcessHwObject+0x62>
                break;
    b95e:	bf00      	nop
            }
        }
    }
    b960:	bf00      	nop
    b962:	b005      	add	sp, #20
    b964:	f85d fb04 	ldr.w	pc, [sp], #4

0000b968 <Can_43_FLEXCAN_CommonIrqCallback>:
void Can_43_FLEXCAN_CommonIrqCallback(uint8 u8Instance,
                           Flexcan_Ip_EventType event,
                           uint32 u32buffIdx,
                           const Flexcan_Ip_StateType *driverState
                          )
{
    b968:	b500      	push	{lr}
    b96a:	b085      	sub	sp, #20
    b96c:	9102      	str	r1, [sp, #8]
    b96e:	9201      	str	r2, [sp, #4]
    b970:	9300      	str	r3, [sp, #0]
    b972:	4603      	mov	r3, r0
    b974:	f88d 300f 	strb.w	r3, [sp, #15]
    else
    {
#endif /* CAN_43_FLEXCAN_FEATURE_HAS_ENHANCED_RX_FIFO */
    #if (CAN_43_FLEXCAN_MB_INTERRUPT_SUPPORT == STD_ON)
        /* This callback is just used for interrupt buffter */
        if (FALSE == (driverState->mbs[u32buffIdx].isPolling))
    b978:	9a00      	ldr	r2, [sp, #0]
    b97a:	9b01      	ldr	r3, [sp, #4]
    b97c:	011b      	lsls	r3, r3, #4
    b97e:	4413      	add	r3, r2
    b980:	3308      	adds	r3, #8
    b982:	781b      	ldrb	r3, [r3, #0]
    b984:	f083 0301 	eor.w	r3, r3, #1
    b988:	b2db      	uxtb	r3, r3
    b98a:	2b00      	cmp	r3, #0
    b98c:	d03b      	beq.n	ba06 <Can_43_FLEXCAN_CommonIrqCallback+0x9e>
    b98e:	9b02      	ldr	r3, [sp, #8]
    b990:	2b04      	cmp	r3, #4
    b992:	d83a      	bhi.n	ba0a <Can_43_FLEXCAN_CommonIrqCallback+0xa2>
    b994:	a201      	add	r2, pc, #4	; (adr r2, b99c <Can_43_FLEXCAN_CommonIrqCallback+0x34>)
    b996:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    b99a:	bf00      	nop
    b99c:	0000b9c3 	.word	0x0000b9c3
    b9a0:	0000b9d5 	.word	0x0000b9d5
    b9a4:	0000b9e7 	.word	0x0000b9e7
    b9a8:	0000b9f7 	.word	0x0000b9f7
    b9ac:	0000b9b1 	.word	0x0000b9b1
        {
            switch (event)
            {
                case FLEXCAN_EVENT_TX_COMPLETE:
                {
                    Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt(u8Instance, (uint8)u32buffIdx, CAN_TX_NORMAL);
    b9b0:	9b01      	ldr	r3, [sp, #4]
    b9b2:	b2d9      	uxtb	r1, r3
    b9b4:	f89d 300f 	ldrb.w	r3, [sp, #15]
    b9b8:	2203      	movs	r2, #3
    b9ba:	4618      	mov	r0, r3
    b9bc:	f7fe ff72 	bl	a8a4 <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt>
                    break;
    b9c0:	e024      	b.n	ba0c <Can_43_FLEXCAN_CommonIrqCallback+0xa4>
                }
                case FLEXCAN_EVENT_RX_COMPLETE:
                {
                    Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt(u8Instance, (uint8)u32buffIdx, CAN_RX_NORMAL);
    b9c2:	9b01      	ldr	r3, [sp, #4]
    b9c4:	b2d9      	uxtb	r1, r3
    b9c6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    b9ca:	2200      	movs	r2, #0
    b9cc:	4618      	mov	r0, r3
    b9ce:	f7fe ff69 	bl	a8a4 <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt>
                    break;
    b9d2:	e01b      	b.n	ba0c <Can_43_FLEXCAN_CommonIrqCallback+0xa4>
                }
                case FLEXCAN_EVENT_RXFIFO_COMPLETE:
                {
                    Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt(u8Instance, (uint8)u32buffIdx, CAN_RX_LEGACY_FIFO);
    b9d4:	9b01      	ldr	r3, [sp, #4]
    b9d6:	b2d9      	uxtb	r1, r3
    b9d8:	f89d 300f 	ldrb.w	r3, [sp, #15]
    b9dc:	2201      	movs	r2, #1
    b9de:	4618      	mov	r0, r3
    b9e0:	f7fe ff60 	bl	a8a4 <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt>
                    break;
    b9e4:	e012      	b.n	ba0c <Can_43_FLEXCAN_CommonIrqCallback+0xa4>
                }
                case FLEXCAN_EVENT_RXFIFO_WARNING:
                {
                    Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt(u8Instance, 6U, CAN_RX_LEGACY_FIFO);
    b9e6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    b9ea:	2201      	movs	r2, #1
    b9ec:	2106      	movs	r1, #6
    b9ee:	4618      	mov	r0, r3
    b9f0:	f7fe ff58 	bl	a8a4 <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt>
                    break;
    b9f4:	e00a      	b.n	ba0c <Can_43_FLEXCAN_CommonIrqCallback+0xa4>
                }
                case FLEXCAN_EVENT_RXFIFO_OVERFLOW:
                {
                    Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt(u8Instance, 7U, CAN_RX_LEGACY_FIFO);
    b9f6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    b9fa:	2201      	movs	r2, #1
    b9fc:	2107      	movs	r1, #7
    b9fe:	4618      	mov	r0, r3
    ba00:	f7fe ff50 	bl	a8a4 <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt>
                    break;
    ba04:	e002      	b.n	ba0c <Can_43_FLEXCAN_CommonIrqCallback+0xa4>
                {
                    /* nothing to do */
                    break;
                }
            }
        }
    ba06:	bf00      	nop
    ba08:	e000      	b.n	ba0c <Can_43_FLEXCAN_CommonIrqCallback+0xa4>
                    break;
    ba0a:	bf00      	nop
        Can_43_FLEXCAN_ProcessPNInterrupt(u8Instance);
    }
#endif /* (CAN_43_FLEXCAN_FEATURE_HAS_PRETENDED_NETWORKING == STD_ON) */
    (void)u32buffIdx;
    (void)driverState;
}
    ba0c:	bf00      	nop
    ba0e:	b005      	add	sp, #20
    ba10:	f85d fb04 	ldr.w	pc, [sp], #4

0000ba14 <Can_43_FLEXCAN_ErrorIrqCallback>:
void Can_43_FLEXCAN_ErrorIrqCallback(uint8 u8Instance,
                          Flexcan_Ip_EventType event,
                          uint32 u32ErrStatus,
                          const Flexcan_Ip_StateType *driverState
                         )
{
    ba14:	b500      	push	{lr}
    ba16:	b085      	sub	sp, #20
    ba18:	9102      	str	r1, [sp, #8]
    ba1a:	9201      	str	r2, [sp, #4]
    ba1c:	9300      	str	r3, [sp, #0]
    ba1e:	4603      	mov	r3, r0
    ba20:	f88d 300f 	strb.w	r3, [sp, #15]
    (void) driverState; /* not used yet */
#if (CAN_43_FLEXCAN_ERROR_INTERRUPT_SUPPORT != STD_ON)
    (void) u32ErrStatus; /* prevent compiler warning */
#endif /* (CAN_43_FLEXCAN_ERROR_INTERRUPT_SUPPORT != STD_ON) */

    switch (event)
    ba24:	9b02      	ldr	r3, [sp, #8]
    ba26:	2b07      	cmp	r3, #7
    ba28:	d105      	bne.n	ba36 <Can_43_FLEXCAN_ErrorIrqCallback+0x22>
        }
#endif /* (CAN_43_FLEXCAN_ERROR_INTERRUPT_SUPPORT == STD_ON) */
        /* this function is called for both interrupt & polling */
        case FLEXCAN_EVENT_BUSOFF:
        {
            Can_43_FLEXCAN_ProcessBusOffInterrupt(u8Instance);
    ba2a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    ba2e:	4618      	mov	r0, r3
    ba30:	f7fe ff7a 	bl	a928 <Can_43_FLEXCAN_ProcessBusOffInterrupt>
            break;
    ba34:	e000      	b.n	ba38 <Can_43_FLEXCAN_ErrorIrqCallback+0x24>
        }
        default:
        {
            /* nothing to do */
            break;
    ba36:	bf00      	nop
        }
    }
}
    ba38:	bf00      	nop
    ba3a:	b005      	add	sp, #20
    ba3c:	f85d fb04 	ldr.w	pc, [sp], #4

0000ba40 <FlexCAN_SetRxFifoGlobalMask>:
 *
 * @param[in]   base  The FlexCAN base address
 * @param[in]   Mask     Sets mask
 */
static inline void FlexCAN_SetRxFifoGlobalMask(FLEXCAN_Type * base, uint32 Mask)
{
    ba40:	b082      	sub	sp, #8
    ba42:	9001      	str	r0, [sp, #4]
    ba44:	9100      	str	r1, [sp, #0]
    (base->RXFGMASK) = Mask;
    ba46:	9b01      	ldr	r3, [sp, #4]
    ba48:	9a00      	ldr	r2, [sp, #0]
    ba4a:	649a      	str	r2, [r3, #72]	; 0x48
}
    ba4c:	bf00      	nop
    ba4e:	b002      	add	sp, #8
    ba50:	4770      	bx	lr

0000ba52 <FlexCAN_SetTDCOffset>:
 */
static inline void FlexCAN_SetTDCOffset(FLEXCAN_Type * base,
                                        boolean enable,
                                        uint8 offset
                                       )
{
    ba52:	b084      	sub	sp, #16
    ba54:	9001      	str	r0, [sp, #4]
    ba56:	460b      	mov	r3, r1
    ba58:	f88d 3003 	strb.w	r3, [sp, #3]
    ba5c:	4613      	mov	r3, r2
    ba5e:	f88d 3002 	strb.w	r3, [sp, #2]
    uint32 tmp;

    tmp = base->FDCTRL;
    ba62:	9b01      	ldr	r3, [sp, #4]
    ba64:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    ba68:	9303      	str	r3, [sp, #12]
    tmp &= ~(FLEXCAN_FDCTRL_TDCEN_MASK | FLEXCAN_FDCTRL_TDCOFF_MASK);
    ba6a:	9b03      	ldr	r3, [sp, #12]
    ba6c:	f423 431f 	bic.w	r3, r3, #40704	; 0x9f00
    ba70:	9303      	str	r3, [sp, #12]

    if (enable)
    ba72:	f89d 3003 	ldrb.w	r3, [sp, #3]
    ba76:	2b00      	cmp	r3, #0
    ba78:	d00b      	beq.n	ba92 <FlexCAN_SetTDCOffset+0x40>
    {
        tmp = tmp | FLEXCAN_FDCTRL_TDCEN_MASK;
    ba7a:	9b03      	ldr	r3, [sp, #12]
    ba7c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    ba80:	9303      	str	r3, [sp, #12]
        tmp = tmp | FLEXCAN_FDCTRL_TDCOFF(offset);
    ba82:	f89d 3002 	ldrb.w	r3, [sp, #2]
    ba86:	021b      	lsls	r3, r3, #8
    ba88:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
    ba8c:	9a03      	ldr	r2, [sp, #12]
    ba8e:	4313      	orrs	r3, r2
    ba90:	9303      	str	r3, [sp, #12]
    }

    base->FDCTRL = tmp;
    ba92:	9b01      	ldr	r3, [sp, #4]
    ba94:	9a03      	ldr	r2, [sp, #12]
    ba96:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
}
    ba9a:	bf00      	nop
    ba9c:	b004      	add	sp, #16
    ba9e:	4770      	bx	lr

0000baa0 <FlexCAN_IsEnabled>:
 *
 * @param   base    The FlexCAN base address
 * @return  TRUE if enabled; FALSE if disabled
 */
static inline boolean FlexCAN_IsEnabled(const FLEXCAN_Type * pBase)
{
    baa0:	b082      	sub	sp, #8
    baa2:	9001      	str	r0, [sp, #4]
    return (((pBase->MCR & FLEXCAN_MCR_MDIS_MASK) >> FLEXCAN_MCR_MDIS_SHIFT) != 0U) ? FALSE : TRUE;
    baa4:	9b01      	ldr	r3, [sp, #4]
    baa6:	681b      	ldr	r3, [r3, #0]
    baa8:	43db      	mvns	r3, r3
    baaa:	0fdb      	lsrs	r3, r3, #31
    baac:	b2db      	uxtb	r3, r3
}
    baae:	4618      	mov	r0, r3
    bab0:	b002      	add	sp, #8
    bab2:	4770      	bx	lr

0000bab4 <FlexCAN_SetFDEnabled>:
 */
static inline void FlexCAN_SetFDEnabled(FLEXCAN_Type * base,
                                        boolean enableFD,
                                        boolean enableBRS
                                       )
{
    bab4:	b082      	sub	sp, #8
    bab6:	9001      	str	r0, [sp, #4]
    bab8:	460b      	mov	r3, r1
    baba:	f88d 3003 	strb.w	r3, [sp, #3]
    babe:	4613      	mov	r3, r2
    bac0:	f88d 3002 	strb.w	r3, [sp, #2]
    base->MCR = (base->MCR & ~FLEXCAN_MCR_FDEN_MASK) | FLEXCAN_MCR_FDEN(enableFD ? 1UL : 0UL);
    bac4:	9b01      	ldr	r3, [sp, #4]
    bac6:	681b      	ldr	r3, [r3, #0]
    bac8:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    bacc:	f89d 2003 	ldrb.w	r2, [sp, #3]
    bad0:	2a00      	cmp	r2, #0
    bad2:	d002      	beq.n	bada <FlexCAN_SetFDEnabled+0x26>
    bad4:	f44f 6200 	mov.w	r2, #2048	; 0x800
    bad8:	e000      	b.n	badc <FlexCAN_SetFDEnabled+0x28>
    bada:	2200      	movs	r2, #0
    badc:	431a      	orrs	r2, r3
    bade:	9b01      	ldr	r3, [sp, #4]
    bae0:	601a      	str	r2, [r3, #0]

    /* Enable BitRate Switch support from BRS_TX_MB field or ignore it */
    base->FDCTRL = (base->FDCTRL & ~FLEXCAN_FDCTRL_FDRATE_MASK) | FLEXCAN_FDCTRL_FDRATE(enableBRS ? 1UL : 0UL);
    bae2:	9b01      	ldr	r3, [sp, #4]
    bae4:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    bae8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    baec:	f89d 2002 	ldrb.w	r2, [sp, #2]
    baf0:	2a00      	cmp	r2, #0
    baf2:	d002      	beq.n	bafa <FlexCAN_SetFDEnabled+0x46>
    baf4:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    baf8:	e000      	b.n	bafc <FlexCAN_SetFDEnabled+0x48>
    bafa:	2200      	movs	r2, #0
    bafc:	431a      	orrs	r2, r3
    bafe:	9b01      	ldr	r3, [sp, #4]
    bb00:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00

    /* Disable Transmission Delay Compensation by default */
    base->FDCTRL &= ~(FLEXCAN_FDCTRL_TDCEN_MASK | FLEXCAN_FDCTRL_TDCOFF_MASK);
    bb04:	9b01      	ldr	r3, [sp, #4]
    bb06:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    bb0a:	f423 421f 	bic.w	r2, r3, #40704	; 0x9f00
    bb0e:	9b01      	ldr	r3, [sp, #4]
    bb10:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
}
    bb14:	bf00      	nop
    bb16:	b002      	add	sp, #8
    bb18:	4770      	bx	lr

0000bb1a <FlexCAN_SetListenOnlyMode>:
 *
 * @param   base    The FlexCAN base address
 * @param   enable  TRUE to enable; FALSE to disable
 */
static inline void FlexCAN_SetListenOnlyMode(FLEXCAN_Type * base, boolean enableListenOnly)
{
    bb1a:	b082      	sub	sp, #8
    bb1c:	9001      	str	r0, [sp, #4]
    bb1e:	460b      	mov	r3, r1
    bb20:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_LOM_MASK) | FLEXCAN_CTRL1_LOM(enableListenOnly ? 1UL : 0UL);
    bb24:	9b01      	ldr	r3, [sp, #4]
    bb26:	685b      	ldr	r3, [r3, #4]
    bb28:	f023 0308 	bic.w	r3, r3, #8
    bb2c:	f89d 2003 	ldrb.w	r2, [sp, #3]
    bb30:	2a00      	cmp	r2, #0
    bb32:	d001      	beq.n	bb38 <FlexCAN_SetListenOnlyMode+0x1e>
    bb34:	2208      	movs	r2, #8
    bb36:	e000      	b.n	bb3a <FlexCAN_SetListenOnlyMode+0x20>
    bb38:	2200      	movs	r2, #0
    bb3a:	431a      	orrs	r2, r3
    bb3c:	9b01      	ldr	r3, [sp, #4]
    bb3e:	605a      	str	r2, [r3, #4]
}
    bb40:	bf00      	nop
    bb42:	b002      	add	sp, #8
    bb44:	4770      	bx	lr

0000bb46 <FlexCAN_UnlockRxMsgBuff>:
 * @brief Unlocks the FlexCAN Rx message buffer.
 *
 * @param   base     The FlexCAN base address
 */
static inline void FlexCAN_UnlockRxMsgBuff(const FLEXCAN_Type * base)
{
    bb46:	b082      	sub	sp, #8
    bb48:	9001      	str	r0, [sp, #4]
    /* Unlock the mailbox by reading the free running timer */
    (void)base->TIMER;
    bb4a:	9b01      	ldr	r3, [sp, #4]
    bb4c:	689b      	ldr	r3, [r3, #8]
}
    bb4e:	bf00      	nop
    bb50:	b002      	add	sp, #8
    bb52:	4770      	bx	lr

0000bb54 <FlexCAN_ClearMsgBuffIntStatusFlag>:
 *
 * @param   base        The FlexCAN base address
 * @param   msgBuffIdx  Index of the message buffer
 */
static inline void FlexCAN_ClearMsgBuffIntStatusFlag(FLEXCAN_Type * base, uint32 msgBuffIdx)
{
    bb54:	b084      	sub	sp, #16
    bb56:	9001      	str	r0, [sp, #4]
    bb58:	9100      	str	r1, [sp, #0]
    uint32 flag = ((uint32)1U << (msgBuffIdx % 32U));
    bb5a:	9b00      	ldr	r3, [sp, #0]
    bb5c:	f003 031f 	and.w	r3, r3, #31
    bb60:	2201      	movs	r2, #1
    bb62:	fa02 f303 	lsl.w	r3, r2, r3
    bb66:	9303      	str	r3, [sp, #12]

    /* Clear the corresponding message buffer interrupt flag*/
    if (msgBuffIdx < 32U)
    bb68:	9b00      	ldr	r3, [sp, #0]
    bb6a:	2b1f      	cmp	r3, #31
    bb6c:	d802      	bhi.n	bb74 <FlexCAN_ClearMsgBuffIntStatusFlag+0x20>
    {
        (base->IFLAG1) = (flag);
    bb6e:	9b01      	ldr	r3, [sp, #4]
    bb70:	9a03      	ldr	r2, [sp, #12]
    bb72:	631a      	str	r2, [r3, #48]	; 0x30
    else
    {
        (base->IFLAG4) = (flag);
    }
#endif
}
    bb74:	bf00      	nop
    bb76:	b004      	add	sp, #16
    bb78:	4770      	bx	lr

0000bb7a <FlexCAN_GetBuffStatusFlag>:
 * @param   base                The FlexCAN base address
 * @param   msgBuffIdx  Index of the message buffer
 * @return  flag        The value of interrupt flag of the message buffer.
 */
static inline uint8 FlexCAN_GetBuffStatusFlag(const FLEXCAN_Type * base, uint32 msgBuffIdx)
{
    bb7a:	b084      	sub	sp, #16
    bb7c:	9001      	str	r0, [sp, #4]
    bb7e:	9100      	str	r1, [sp, #0]
    uint32 flag = 0U;
    bb80:	2300      	movs	r3, #0
    bb82:	9303      	str	r3, [sp, #12]

    if (msgBuffIdx < 32U)
    bb84:	9b00      	ldr	r3, [sp, #0]
    bb86:	2b1f      	cmp	r3, #31
    bb88:	d80e      	bhi.n	bba8 <FlexCAN_GetBuffStatusFlag+0x2e>
    {
        flag = ((base->IFLAG1 & ((uint32)1U << (msgBuffIdx % 32U))) >> (msgBuffIdx % 32U));
    bb8a:	9b01      	ldr	r3, [sp, #4]
    bb8c:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    bb8e:	9b00      	ldr	r3, [sp, #0]
    bb90:	f003 031f 	and.w	r3, r3, #31
    bb94:	2101      	movs	r1, #1
    bb96:	fa01 f303 	lsl.w	r3, r1, r3
    bb9a:	401a      	ands	r2, r3
    bb9c:	9b00      	ldr	r3, [sp, #0]
    bb9e:	f003 031f 	and.w	r3, r3, #31
    bba2:	fa22 f303 	lsr.w	r3, r2, r3
    bba6:	9303      	str	r3, [sp, #12]
    {
        flag = ((base->IFLAG4 & ((uint32)1U << (msgBuffIdx % 32U))) >> (msgBuffIdx % 32U));
    }
#endif

    return (uint8)flag;
    bba8:	9b03      	ldr	r3, [sp, #12]
    bbaa:	b2db      	uxtb	r3, r3
}
    bbac:	4618      	mov	r0, r3
    bbae:	b004      	add	sp, #16
    bbb0:	4770      	bx	lr

0000bbb2 <FlexCAN_SetFDTimeSegments>:
 *
 * @param   base The FlexCAN base address
 * @param   timeSeg    FlexCAN time segments, which need to be set for the bit rate.
 */
static inline void FlexCAN_SetFDTimeSegments(FLEXCAN_Type * base, const Flexcan_Ip_TimeSegmentType * timeSeg)
{
    bbb2:	b082      	sub	sp, #8
    bbb4:	9001      	str	r0, [sp, #4]
    bbb6:	9100      	str	r1, [sp, #0]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(timeSeg != NULL_PTR);
#endif
    /* Set FlexCAN time segments*/
    (base->FDCBT) = ((base->FDCBT) & ~((FLEXCAN_FDCBT_FPROPSEG_MASK | FLEXCAN_FDCBT_FPSEG2_MASK |
    bbb8:	9b01      	ldr	r3, [sp, #4]
    bbba:	f8d3 2c04 	ldr.w	r2, [r3, #3076]	; 0xc04
    bbbe:	4b15      	ldr	r3, [pc, #84]	; (bc14 <FlexCAN_SetFDTimeSegments+0x62>)
    bbc0:	4013      	ands	r3, r2
    bbc2:	9a01      	ldr	r2, [sp, #4]
    bbc4:	f8c2 3c04 	str.w	r3, [r2, #3076]	; 0xc04
                                        FLEXCAN_FDCBT_FPSEG1_MASK | FLEXCAN_FDCBT_FPRESDIV_MASK
                                       ) | FLEXCAN_FDCBT_FRJW_MASK
                                      )
                    );

    (base->FDCBT) = ((base->FDCBT) | (FLEXCAN_FDCBT_FPROPSEG(timeSeg->propSeg) |
    bbc8:	9b01      	ldr	r3, [sp, #4]
    bbca:	f8d3 2c04 	ldr.w	r2, [r3, #3076]	; 0xc04
    bbce:	9b00      	ldr	r3, [sp, #0]
    bbd0:	681b      	ldr	r3, [r3, #0]
    bbd2:	029b      	lsls	r3, r3, #10
    bbd4:	f403 41f8 	and.w	r1, r3, #31744	; 0x7c00
                                      FLEXCAN_FDCBT_FPSEG2(timeSeg->phaseSeg2) |
    bbd8:	9b00      	ldr	r3, [sp, #0]
    bbda:	689b      	ldr	r3, [r3, #8]
    bbdc:	f003 0307 	and.w	r3, r3, #7
    (base->FDCBT) = ((base->FDCBT) | (FLEXCAN_FDCBT_FPROPSEG(timeSeg->propSeg) |
    bbe0:	4319      	orrs	r1, r3
                                      FLEXCAN_FDCBT_FPSEG1(timeSeg->phaseSeg1) |
    bbe2:	9b00      	ldr	r3, [sp, #0]
    bbe4:	685b      	ldr	r3, [r3, #4]
    bbe6:	015b      	lsls	r3, r3, #5
    bbe8:	b2db      	uxtb	r3, r3
                                      FLEXCAN_FDCBT_FPSEG2(timeSeg->phaseSeg2) |
    bbea:	4319      	orrs	r1, r3
                                      FLEXCAN_FDCBT_FPRESDIV(timeSeg->preDivider) |
    bbec:	9b00      	ldr	r3, [sp, #0]
    bbee:	68db      	ldr	r3, [r3, #12]
    bbf0:	0518      	lsls	r0, r3, #20
    bbf2:	4b09      	ldr	r3, [pc, #36]	; (bc18 <FlexCAN_SetFDTimeSegments+0x66>)
    bbf4:	4003      	ands	r3, r0
                                      FLEXCAN_FDCBT_FPSEG1(timeSeg->phaseSeg1) |
    bbf6:	4319      	orrs	r1, r3
                                      FLEXCAN_FDCBT_FRJW(timeSeg->rJumpwidth)
    bbf8:	9b00      	ldr	r3, [sp, #0]
    bbfa:	691b      	ldr	r3, [r3, #16]
    bbfc:	041b      	lsls	r3, r3, #16
    bbfe:	f403 23e0 	and.w	r3, r3, #458752	; 0x70000
                                      FLEXCAN_FDCBT_FPRESDIV(timeSeg->preDivider) |
    bc02:	430b      	orrs	r3, r1
    (base->FDCBT) = ((base->FDCBT) | (FLEXCAN_FDCBT_FPROPSEG(timeSeg->propSeg) |
    bc04:	431a      	orrs	r2, r3
    bc06:	9b01      	ldr	r3, [sp, #4]
    bc08:	f8c3 2c04 	str.w	r2, [r3, #3076]	; 0xc04
                                     )
                    );
}
    bc0c:	bf00      	nop
    bc0e:	b002      	add	sp, #8
    bc10:	4770      	bx	lr
    bc12:	bf00      	nop
    bc14:	c0088318 	.word	0xc0088318
    bc18:	3ff00000 	.word	0x3ff00000

0000bc1c <FlexCAN_SetTimeSegments>:
 *
 * @param   base The FlexCAN base address
 * @param   timeSeg    FlexCAN time segments, which need to be set for the bit rate.
 */
static inline void FlexCAN_SetTimeSegments(FLEXCAN_Type * base, const Flexcan_Ip_TimeSegmentType * timeSeg)
{
    bc1c:	b082      	sub	sp, #8
    bc1e:	9001      	str	r0, [sp, #4]
    bc20:	9100      	str	r1, [sp, #0]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(timeSeg != NULL_PTR);
#endif
    (base->CTRL1) = ((base->CTRL1) & ~((FLEXCAN_CTRL1_PROPSEG_MASK | FLEXCAN_CTRL1_PSEG2_MASK |
    bc22:	9b01      	ldr	r3, [sp, #4]
    bc24:	685a      	ldr	r2, [r3, #4]
    bc26:	f64f 73f8 	movw	r3, #65528	; 0xfff8
    bc2a:	4013      	ands	r3, r2
    bc2c:	9a01      	ldr	r2, [sp, #4]
    bc2e:	6053      	str	r3, [r2, #4]
                                        FLEXCAN_CTRL1_PSEG1_MASK | FLEXCAN_CTRL1_PRESDIV_MASK
                                       ) | FLEXCAN_CTRL1_RJW_MASK
                                      )
                    );

    (base->CTRL1) = ((base->CTRL1) | (FLEXCAN_CTRL1_PROPSEG(timeSeg->propSeg) |
    bc30:	9b01      	ldr	r3, [sp, #4]
    bc32:	685a      	ldr	r2, [r3, #4]
    bc34:	9b00      	ldr	r3, [sp, #0]
    bc36:	681b      	ldr	r3, [r3, #0]
    bc38:	f003 0107 	and.w	r1, r3, #7
                                      FLEXCAN_CTRL1_PSEG2(timeSeg->phaseSeg2) |
    bc3c:	9b00      	ldr	r3, [sp, #0]
    bc3e:	689b      	ldr	r3, [r3, #8]
    bc40:	041b      	lsls	r3, r3, #16
    bc42:	f403 23e0 	and.w	r3, r3, #458752	; 0x70000
    (base->CTRL1) = ((base->CTRL1) | (FLEXCAN_CTRL1_PROPSEG(timeSeg->propSeg) |
    bc46:	4319      	orrs	r1, r3
                                      FLEXCAN_CTRL1_PSEG1(timeSeg->phaseSeg1) |
    bc48:	9b00      	ldr	r3, [sp, #0]
    bc4a:	685b      	ldr	r3, [r3, #4]
    bc4c:	04db      	lsls	r3, r3, #19
    bc4e:	f403 1360 	and.w	r3, r3, #3670016	; 0x380000
                                      FLEXCAN_CTRL1_PSEG2(timeSeg->phaseSeg2) |
    bc52:	4319      	orrs	r1, r3
                                      FLEXCAN_CTRL1_PRESDIV(timeSeg->preDivider) |
    bc54:	9b00      	ldr	r3, [sp, #0]
    bc56:	68db      	ldr	r3, [r3, #12]
    bc58:	061b      	lsls	r3, r3, #24
                                      FLEXCAN_CTRL1_PSEG1(timeSeg->phaseSeg1) |
    bc5a:	4319      	orrs	r1, r3
                                      FLEXCAN_CTRL1_RJW(timeSeg->rJumpwidth)
    bc5c:	9b00      	ldr	r3, [sp, #0]
    bc5e:	691b      	ldr	r3, [r3, #16]
    bc60:	059b      	lsls	r3, r3, #22
    bc62:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
                                      FLEXCAN_CTRL1_PRESDIV(timeSeg->preDivider) |
    bc66:	430b      	orrs	r3, r1
    (base->CTRL1) = ((base->CTRL1) | (FLEXCAN_CTRL1_PROPSEG(timeSeg->propSeg) |
    bc68:	431a      	orrs	r2, r3
    bc6a:	9b01      	ldr	r3, [sp, #4]
    bc6c:	605a      	str	r2, [r3, #4]
                                     )
                    );
}
    bc6e:	bf00      	nop
    bc70:	b002      	add	sp, #8
    bc72:	4770      	bx	lr

0000bc74 <FlexCAN_SetExtendedTimeSegments>:
 *
 * @param   base The FlexCAN base address
 * @param   timeSeg    FlexCAN time segments, which need to be set for the bit rate.
 */
static inline void FlexCAN_SetExtendedTimeSegments(FLEXCAN_Type * base, const Flexcan_Ip_TimeSegmentType * timeSeg)
{
    bc74:	b082      	sub	sp, #8
    bc76:	9001      	str	r0, [sp, #4]
    bc78:	9100      	str	r1, [sp, #0]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(timeSeg != NULL_PTR);
#endif
    /* If extended bit time definitions are enabled, use CBT register */
    (base->CBT) = ((base->CBT) & ~((FLEXCAN_CBT_EPROPSEG_MASK | FLEXCAN_CBT_EPSEG2_MASK |
    bc7a:	9b01      	ldr	r3, [sp, #4]
    bc7c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    bc7e:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
    bc82:	9b01      	ldr	r3, [sp, #4]
    bc84:	651a      	str	r2, [r3, #80]	; 0x50
                                    FLEXCAN_CBT_EPSEG1_MASK | FLEXCAN_CBT_EPRESDIV_MASK
                                   ) | FLEXCAN_CBT_ERJW_MASK
                                  )
                  );

    (base->CBT) = ((base->CBT) | (FLEXCAN_CBT_EPROPSEG(timeSeg->propSeg) |
    bc86:	9b01      	ldr	r3, [sp, #4]
    bc88:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    bc8a:	9b00      	ldr	r3, [sp, #0]
    bc8c:	681b      	ldr	r3, [r3, #0]
    bc8e:	029b      	lsls	r3, r3, #10
    bc90:	b299      	uxth	r1, r3
                                  FLEXCAN_CBT_EPSEG2(timeSeg->phaseSeg2) |
    bc92:	9b00      	ldr	r3, [sp, #0]
    bc94:	689b      	ldr	r3, [r3, #8]
    bc96:	f003 031f 	and.w	r3, r3, #31
    (base->CBT) = ((base->CBT) | (FLEXCAN_CBT_EPROPSEG(timeSeg->propSeg) |
    bc9a:	4319      	orrs	r1, r3
                                  FLEXCAN_CBT_EPSEG1(timeSeg->phaseSeg1) |
    bc9c:	9b00      	ldr	r3, [sp, #0]
    bc9e:	685b      	ldr	r3, [r3, #4]
    bca0:	015b      	lsls	r3, r3, #5
    bca2:	f403 7378 	and.w	r3, r3, #992	; 0x3e0
                                  FLEXCAN_CBT_EPSEG2(timeSeg->phaseSeg2) |
    bca6:	4319      	orrs	r1, r3
                                  FLEXCAN_CBT_EPRESDIV(timeSeg->preDivider) |
    bca8:	9b00      	ldr	r3, [sp, #0]
    bcaa:	68db      	ldr	r3, [r3, #12]
    bcac:	0558      	lsls	r0, r3, #21
    bcae:	4b07      	ldr	r3, [pc, #28]	; (bccc <FlexCAN_SetExtendedTimeSegments+0x58>)
    bcb0:	4003      	ands	r3, r0
                                  FLEXCAN_CBT_EPSEG1(timeSeg->phaseSeg1) |
    bcb2:	4319      	orrs	r1, r3
                                  FLEXCAN_CBT_ERJW(timeSeg->rJumpwidth)
    bcb4:	9b00      	ldr	r3, [sp, #0]
    bcb6:	691b      	ldr	r3, [r3, #16]
    bcb8:	041b      	lsls	r3, r3, #16
    bcba:	f403 13f8 	and.w	r3, r3, #2031616	; 0x1f0000
                                  FLEXCAN_CBT_EPRESDIV(timeSeg->preDivider) |
    bcbe:	430b      	orrs	r3, r1
    (base->CBT) = ((base->CBT) | (FLEXCAN_CBT_EPROPSEG(timeSeg->propSeg) |
    bcc0:	431a      	orrs	r2, r3
    bcc2:	9b01      	ldr	r3, [sp, #4]
    bcc4:	651a      	str	r2, [r3, #80]	; 0x50
                                 )
                  );
}
    bcc6:	bf00      	nop
    bcc8:	b002      	add	sp, #8
    bcca:	4770      	bx	lr
    bccc:	7fe00000 	.word	0x7fe00000

0000bcd0 <FlexCAN_GetExtendedTimeSegments>:
 *
 * @param[in]   base The FlexCAN base address
 * @param[out]   timeSeg    FlexCAN time segments read for bit rate
 */
static inline void FlexCAN_GetExtendedTimeSegments(const FLEXCAN_Type * base, Flexcan_Ip_TimeSegmentType * timeSeg)
{
    bcd0:	b082      	sub	sp, #8
    bcd2:	9001      	str	r0, [sp, #4]
    bcd4:	9100      	str	r1, [sp, #0]
    timeSeg->preDivider = ((base->CBT) & FLEXCAN_CBT_EPRESDIV_MASK) >> FLEXCAN_CBT_EPRESDIV_SHIFT;
    bcd6:	9b01      	ldr	r3, [sp, #4]
    bcd8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    bcda:	0d5b      	lsrs	r3, r3, #21
    bcdc:	f3c3 0209 	ubfx	r2, r3, #0, #10
    bce0:	9b00      	ldr	r3, [sp, #0]
    bce2:	60da      	str	r2, [r3, #12]
    timeSeg->propSeg = ((base->CBT) & FLEXCAN_CBT_EPROPSEG_MASK) >> FLEXCAN_CBT_EPROPSEG_SHIFT;
    bce4:	9b01      	ldr	r3, [sp, #4]
    bce6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    bce8:	0a9b      	lsrs	r3, r3, #10
    bcea:	f003 023f 	and.w	r2, r3, #63	; 0x3f
    bcee:	9b00      	ldr	r3, [sp, #0]
    bcf0:	601a      	str	r2, [r3, #0]
    timeSeg->phaseSeg1 = ((base->CBT) & FLEXCAN_CBT_EPSEG1_MASK) >> FLEXCAN_CBT_EPSEG1_SHIFT;
    bcf2:	9b01      	ldr	r3, [sp, #4]
    bcf4:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    bcf6:	095b      	lsrs	r3, r3, #5
    bcf8:	f003 021f 	and.w	r2, r3, #31
    bcfc:	9b00      	ldr	r3, [sp, #0]
    bcfe:	605a      	str	r2, [r3, #4]
    timeSeg->phaseSeg2 = ((base->CBT) & FLEXCAN_CBT_EPSEG2_MASK) >> FLEXCAN_CBT_EPSEG2_SHIFT;
    bd00:	9b01      	ldr	r3, [sp, #4]
    bd02:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    bd04:	f003 021f 	and.w	r2, r3, #31
    bd08:	9b00      	ldr	r3, [sp, #0]
    bd0a:	609a      	str	r2, [r3, #8]
    timeSeg->rJumpwidth = ((base->CBT) & FLEXCAN_CBT_ERJW_MASK) >> FLEXCAN_CBT_ERJW_SHIFT;
    bd0c:	9b01      	ldr	r3, [sp, #4]
    bd0e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    bd10:	0c1b      	lsrs	r3, r3, #16
    bd12:	f003 021f 	and.w	r2, r3, #31
    bd16:	9b00      	ldr	r3, [sp, #0]
    bd18:	611a      	str	r2, [r3, #16]
}
    bd1a:	bf00      	nop
    bd1c:	b002      	add	sp, #8
    bd1e:	4770      	bx	lr

0000bd20 <FlexCAN_GetTimeSegments>:
 *
 * @param[in]   base The FlexCAN base address
 * @param[out]   timeSeg    FlexCAN time segments read for bit rate
 */
static inline void FlexCAN_GetTimeSegments(const FLEXCAN_Type * base, Flexcan_Ip_TimeSegmentType * timeSeg)
{
    bd20:	b082      	sub	sp, #8
    bd22:	9001      	str	r0, [sp, #4]
    bd24:	9100      	str	r1, [sp, #0]
    timeSeg->preDivider = ((base->CTRL1) & FLEXCAN_CTRL1_PRESDIV_MASK) >> FLEXCAN_CTRL1_PRESDIV_SHIFT;
    bd26:	9b01      	ldr	r3, [sp, #4]
    bd28:	685b      	ldr	r3, [r3, #4]
    bd2a:	0e1b      	lsrs	r3, r3, #24
    bd2c:	b2da      	uxtb	r2, r3
    bd2e:	9b00      	ldr	r3, [sp, #0]
    bd30:	60da      	str	r2, [r3, #12]
    timeSeg->propSeg = ((base->CTRL1) & FLEXCAN_CTRL1_PROPSEG_MASK) >> FLEXCAN_CTRL1_PROPSEG_SHIFT;
    bd32:	9b01      	ldr	r3, [sp, #4]
    bd34:	685b      	ldr	r3, [r3, #4]
    bd36:	f003 0207 	and.w	r2, r3, #7
    bd3a:	9b00      	ldr	r3, [sp, #0]
    bd3c:	601a      	str	r2, [r3, #0]
    timeSeg->phaseSeg1 = ((base->CTRL1) & FLEXCAN_CTRL1_PSEG1_MASK) >> FLEXCAN_CTRL1_PSEG1_SHIFT;
    bd3e:	9b01      	ldr	r3, [sp, #4]
    bd40:	685b      	ldr	r3, [r3, #4]
    bd42:	0cdb      	lsrs	r3, r3, #19
    bd44:	f003 0207 	and.w	r2, r3, #7
    bd48:	9b00      	ldr	r3, [sp, #0]
    bd4a:	605a      	str	r2, [r3, #4]
    timeSeg->phaseSeg2 = ((base->CTRL1) & FLEXCAN_CTRL1_PSEG2_MASK) >> FLEXCAN_CTRL1_PSEG2_SHIFT;
    bd4c:	9b01      	ldr	r3, [sp, #4]
    bd4e:	685b      	ldr	r3, [r3, #4]
    bd50:	0c1b      	lsrs	r3, r3, #16
    bd52:	f003 0207 	and.w	r2, r3, #7
    bd56:	9b00      	ldr	r3, [sp, #0]
    bd58:	609a      	str	r2, [r3, #8]
    timeSeg->rJumpwidth = ((base->CTRL1) & FLEXCAN_CTRL1_RJW_MASK) >> FLEXCAN_CTRL1_RJW_SHIFT;
    bd5a:	9b01      	ldr	r3, [sp, #4]
    bd5c:	685b      	ldr	r3, [r3, #4]
    bd5e:	0d9b      	lsrs	r3, r3, #22
    bd60:	f003 0203 	and.w	r2, r3, #3
    bd64:	9b00      	ldr	r3, [sp, #0]
    bd66:	611a      	str	r2, [r3, #16]
}
    bd68:	bf00      	nop
    bd6a:	b002      	add	sp, #8
    bd6c:	4770      	bx	lr

0000bd6e <FlexCAN_GetFDTimeSegments>:
 *
 * @param   base The FlexCAN base address
 * @param   timeSeg    FlexCAN time segments read for bit rate
 */
static inline void FlexCAN_GetFDTimeSegments(const FLEXCAN_Type * base, Flexcan_Ip_TimeSegmentType * timeSeg)
{
    bd6e:	b082      	sub	sp, #8
    bd70:	9001      	str	r0, [sp, #4]
    bd72:	9100      	str	r1, [sp, #0]
    timeSeg->preDivider = ((base->FDCBT) & FLEXCAN_FDCBT_FPRESDIV_MASK) >> FLEXCAN_FDCBT_FPRESDIV_SHIFT;
    bd74:	9b01      	ldr	r3, [sp, #4]
    bd76:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	; 0xc04
    bd7a:	0d1b      	lsrs	r3, r3, #20
    bd7c:	f3c3 0209 	ubfx	r2, r3, #0, #10
    bd80:	9b00      	ldr	r3, [sp, #0]
    bd82:	60da      	str	r2, [r3, #12]
    timeSeg->propSeg = ((base->FDCBT) & FLEXCAN_FDCBT_FPROPSEG_MASK) >> FLEXCAN_FDCBT_FPROPSEG_SHIFT;
    bd84:	9b01      	ldr	r3, [sp, #4]
    bd86:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	; 0xc04
    bd8a:	0a9b      	lsrs	r3, r3, #10
    bd8c:	f003 021f 	and.w	r2, r3, #31
    bd90:	9b00      	ldr	r3, [sp, #0]
    bd92:	601a      	str	r2, [r3, #0]
    timeSeg->phaseSeg1 = ((base->FDCBT) & FLEXCAN_FDCBT_FPSEG1_MASK) >> FLEXCAN_FDCBT_FPSEG1_SHIFT;
    bd94:	9b01      	ldr	r3, [sp, #4]
    bd96:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	; 0xc04
    bd9a:	095b      	lsrs	r3, r3, #5
    bd9c:	f003 0207 	and.w	r2, r3, #7
    bda0:	9b00      	ldr	r3, [sp, #0]
    bda2:	605a      	str	r2, [r3, #4]
    timeSeg->phaseSeg2 = ((base->FDCBT) & FLEXCAN_FDCBT_FPSEG2_MASK) >> FLEXCAN_FDCBT_FPSEG2_SHIFT;
    bda4:	9b01      	ldr	r3, [sp, #4]
    bda6:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	; 0xc04
    bdaa:	f003 0207 	and.w	r2, r3, #7
    bdae:	9b00      	ldr	r3, [sp, #0]
    bdb0:	609a      	str	r2, [r3, #8]
    timeSeg->rJumpwidth = ((base->FDCBT) & FLEXCAN_FDCBT_FRJW_MASK) >> FLEXCAN_FDCBT_FRJW_SHIFT;
    bdb2:	9b01      	ldr	r3, [sp, #4]
    bdb4:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	; 0xc04
    bdb8:	0c1b      	lsrs	r3, r3, #16
    bdba:	f003 0207 	and.w	r2, r3, #7
    bdbe:	9b00      	ldr	r3, [sp, #0]
    bdc0:	611a      	str	r2, [r3, #16]
}
    bdc2:	bf00      	nop
    bdc4:	b002      	add	sp, #8
    bdc6:	4770      	bx	lr

0000bdc8 <FlexCAN_IsExCbtEnabled>:
 *
 * @param   base    The FlexCAN base address
 * @return  TRUE if enabled; FALSE if disabled
 */
static inline boolean FlexCAN_IsExCbtEnabled(const FLEXCAN_Type * pBase)
{
    bdc8:	b082      	sub	sp, #8
    bdca:	9001      	str	r0, [sp, #4]
    return (0U == ((pBase->CBT & FLEXCAN_CBT_BTF_MASK) >> FLEXCAN_CBT_BTF_SHIFT)) ? FALSE : TRUE;
    bdcc:	9b01      	ldr	r3, [sp, #4]
    bdce:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    bdd0:	0fdb      	lsrs	r3, r3, #31
    bdd2:	b2db      	uxtb	r3, r3
}
    bdd4:	4618      	mov	r0, r3
    bdd6:	b002      	add	sp, #8
    bdd8:	4770      	bx	lr

0000bdda <FlexCAN_EnableExtCbt>:
 *
 * @param   base    The FlexCAN base address
 * @param   enableCBT Enable/Disable use of Extent Time Segments
 */
static inline void FlexCAN_EnableExtCbt(FLEXCAN_Type * base, boolean enableCBT)
{   /* Enable the use of extended bit time definitions */
    bdda:	b082      	sub	sp, #8
    bddc:	9001      	str	r0, [sp, #4]
    bdde:	460b      	mov	r3, r1
    bde0:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CBT = (base->CBT & ~FLEXCAN_CBT_BTF_MASK) | FLEXCAN_CBT_BTF(enableCBT ? 1UL : 0UL);
    bde4:	9b01      	ldr	r3, [sp, #4]
    bde6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    bde8:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    bdec:	f89d 2003 	ldrb.w	r2, [sp, #3]
    bdf0:	2a00      	cmp	r2, #0
    bdf2:	d002      	beq.n	bdfa <FlexCAN_EnableExtCbt+0x20>
    bdf4:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    bdf8:	e000      	b.n	bdfc <FlexCAN_EnableExtCbt+0x22>
    bdfa:	2200      	movs	r2, #0
    bdfc:	431a      	orrs	r2, r3
    bdfe:	9b01      	ldr	r3, [sp, #4]
    be00:	651a      	str	r2, [r3, #80]	; 0x50
}
    be02:	bf00      	nop
    be04:	b002      	add	sp, #8
    be06:	4770      	bx	lr

0000be08 <FlexCAN_SetSelfReception>:
 *
 * @param   base  The FlexCAN base address
 * @param   enable Enable/Disable Self Reception
 */
static inline void FlexCAN_SetSelfReception(FLEXCAN_Type * base, boolean enable)
{
    be08:	b082      	sub	sp, #8
    be0a:	9001      	str	r0, [sp, #4]
    be0c:	460b      	mov	r3, r1
    be0e:	f88d 3003 	strb.w	r3, [sp, #3]
    base->MCR = (base->MCR & ~FLEXCAN_MCR_SRXDIS_MASK) | FLEXCAN_MCR_SRXDIS(enable ? 0UL : 1UL);
    be12:	9b01      	ldr	r3, [sp, #4]
    be14:	681b      	ldr	r3, [r3, #0]
    be16:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    be1a:	f89d 2003 	ldrb.w	r2, [sp, #3]
    be1e:	2a00      	cmp	r2, #0
    be20:	d001      	beq.n	be26 <FlexCAN_SetSelfReception+0x1e>
    be22:	2200      	movs	r2, #0
    be24:	e001      	b.n	be2a <FlexCAN_SetSelfReception+0x22>
    be26:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    be2a:	431a      	orrs	r2, r3
    be2c:	9b01      	ldr	r3, [sp, #4]
    be2e:	601a      	str	r2, [r3, #0]
}
    be30:	bf00      	nop
    be32:	b002      	add	sp, #8
    be34:	4770      	bx	lr

0000be36 <FlexCAN_IsFDEnabled>:
 *
 * @param   base    The FlexCAN base address
 * @return  TRUE if enabled; FALSE if disabled
 */
static inline boolean FlexCAN_IsFDEnabled(const FLEXCAN_Type * base)
{
    be36:	b082      	sub	sp, #8
    be38:	9001      	str	r0, [sp, #4]
    return ((base->MCR & FLEXCAN_MCR_FDEN_MASK) >> FLEXCAN_MCR_FDEN_SHIFT) != 0U;
    be3a:	9b01      	ldr	r3, [sp, #4]
    be3c:	681b      	ldr	r3, [r3, #0]
    be3e:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    be42:	2b00      	cmp	r3, #0
    be44:	bf14      	ite	ne
    be46:	2301      	movne	r3, #1
    be48:	2300      	moveq	r3, #0
    be4a:	b2db      	uxtb	r3, r3
}
    be4c:	4618      	mov	r0, r3
    be4e:	b002      	add	sp, #8
    be50:	4770      	bx	lr

0000be52 <FlexCAN_IsListenOnlyModeEnabled>:
 *
 * @param   base    The FlexCAN base address
 * @return  TRUE if enabled; FALSE if disabled
 */
static inline boolean FlexCAN_IsListenOnlyModeEnabled(const FLEXCAN_Type * base)
{
    be52:	b082      	sub	sp, #8
    be54:	9001      	str	r0, [sp, #4]
    return (((base->CTRL1 & (FLEXCAN_CTRL1_LOM_MASK)) != 0U) ? TRUE : FALSE);
    be56:	9b01      	ldr	r3, [sp, #4]
    be58:	685b      	ldr	r3, [r3, #4]
    be5a:	f003 0308 	and.w	r3, r3, #8
    be5e:	2b00      	cmp	r3, #0
    be60:	bf14      	ite	ne
    be62:	2301      	movne	r3, #1
    be64:	2300      	moveq	r3, #0
    be66:	b2db      	uxtb	r3, r3
}
    be68:	4618      	mov	r0, r3
    be6a:	b002      	add	sp, #8
    be6c:	4770      	bx	lr

0000be6e <RxFifoOcuppiedLastMsgBuff>:
 *
 * @param   x    Number of Configured RxFIFO Filters
 * @return  number of last MB occupied by RxFIFO
 */
static inline uint32 RxFifoOcuppiedLastMsgBuff(uint8 x)
{
    be6e:	b082      	sub	sp, #8
    be70:	4603      	mov	r3, r0
    be72:	f88d 3007 	strb.w	r3, [sp, #7]
    return 5U + (((((uint32)x) + 1U) * 8U) / 4U);
    be76:	f89d 3007 	ldrb.w	r3, [sp, #7]
    be7a:	3301      	adds	r3, #1
    be7c:	00db      	lsls	r3, r3, #3
    be7e:	089b      	lsrs	r3, r3, #2
    be80:	3305      	adds	r3, #5
}
    be82:	4618      	mov	r0, r3
    be84:	b002      	add	sp, #8
    be86:	4770      	bx	lr

0000be88 <FlexCAN_SetClkSrc>:
 *
 * @param   base  The FlexCAN base address
 * @param   enable Specifies if The CAN engine clock source is the oscillator clock(FALSE) or peripheral clock(TRUE).
 */
static inline void FlexCAN_SetClkSrc(FLEXCAN_Type * base, boolean enable)
{
    be88:	b082      	sub	sp, #8
    be8a:	9001      	str	r0, [sp, #4]
    be8c:	460b      	mov	r3, r1
    be8e:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_CLKSRC_MASK) | FLEXCAN_CTRL1_CLKSRC(enable ? 1UL : 0UL);
    be92:	9b01      	ldr	r3, [sp, #4]
    be94:	685b      	ldr	r3, [r3, #4]
    be96:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
    be9a:	f89d 2003 	ldrb.w	r2, [sp, #3]
    be9e:	2a00      	cmp	r2, #0
    bea0:	d002      	beq.n	bea8 <FlexCAN_SetClkSrc+0x20>
    bea2:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    bea6:	e000      	b.n	beaa <FlexCAN_SetClkSrc+0x22>
    bea8:	2200      	movs	r2, #0
    beaa:	431a      	orrs	r2, r3
    beac:	9b01      	ldr	r3, [sp, #4]
    beae:	605a      	str	r2, [r3, #4]
}
    beb0:	bf00      	nop
    beb2:	b002      	add	sp, #8
    beb4:	4770      	bx	lr

0000beb6 <FlexCAN_GetMsgBuffIntStatusFlag>:
 * @param   base  The FlexCAN base address
 * @param   msgBuffIdx       Index of the message buffer
 * @return  the individual Message Buffer interrupt flag (0 and 1 are the flag value)
 */
static inline uint8 FlexCAN_GetMsgBuffIntStatusFlag(const FLEXCAN_Type * base, uint32 msgBuffIdx)
{
    beb6:	b084      	sub	sp, #16
    beb8:	9001      	str	r0, [sp, #4]
    beba:	9100      	str	r1, [sp, #0]
    /* TODO: This need to be protected multithread access*/
    uint8 flag = 0;
    bebc:	2300      	movs	r3, #0
    bebe:	f88d 300f 	strb.w	r3, [sp, #15]
    uint32 mask;

    if (msgBuffIdx < 32U)
    bec2:	9b00      	ldr	r3, [sp, #0]
    bec4:	2b1f      	cmp	r3, #31
    bec6:	d810      	bhi.n	beea <FlexCAN_GetMsgBuffIntStatusFlag+0x34>
    {
        mask = base->IMASK1 & FLEXCAN_IMASK1_BUF31TO0M_MASK;
    bec8:	9b01      	ldr	r3, [sp, #4]
    beca:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    becc:	9302      	str	r3, [sp, #8]
        flag = (uint8)(((base->IFLAG1 & mask) >> (msgBuffIdx % 32U)) & 1U);
    bece:	9b01      	ldr	r3, [sp, #4]
    bed0:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    bed2:	9b02      	ldr	r3, [sp, #8]
    bed4:	401a      	ands	r2, r3
    bed6:	9b00      	ldr	r3, [sp, #0]
    bed8:	f003 031f 	and.w	r3, r3, #31
    bedc:	fa22 f303 	lsr.w	r3, r2, r3
    bee0:	b2db      	uxtb	r3, r3
    bee2:	f003 0301 	and.w	r3, r3, #1
    bee6:	f88d 300f 	strb.w	r3, [sp, #15]
        mask = base->IMASK4 & FLEXCAN_IMASK4_BUF127TO96M_MASK;
        flag = (uint8)(((base->IFLAG4 & mask) >> (msgBuffIdx % 32U)) & 1U);
    }
#endif

    return flag;
    beea:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    beee:	4618      	mov	r0, r3
    bef0:	b004      	add	sp, #16
    bef2:	4770      	bx	lr

0000bef4 <FlexCAN_SetRxMsgBuffGlobalMask>:
 *
 * @param   base  The FlexCAN base address
 * @param   Mask  Mask Value
 */
static inline void FlexCAN_SetRxMsgBuffGlobalMask(FLEXCAN_Type * base, uint32 Mask)
{
    bef4:	b082      	sub	sp, #8
    bef6:	9001      	str	r0, [sp, #4]
    bef8:	9100      	str	r1, [sp, #0]
    (base->RXMGMASK) = Mask;
    befa:	9b01      	ldr	r3, [sp, #4]
    befc:	9a00      	ldr	r2, [sp, #0]
    befe:	611a      	str	r2, [r3, #16]
}
    bf00:	bf00      	nop
    bf02:	b002      	add	sp, #8
    bf04:	4770      	bx	lr

0000bf06 <FlexCAN_SetRxIndividualMask>:
 */
static inline void FlexCAN_SetRxIndividualMask(FLEXCAN_Type * base,
                                               uint32 msgBuffIdx,
                                               uint32 mask
                                              )
{
    bf06:	b084      	sub	sp, #16
    bf08:	9003      	str	r0, [sp, #12]
    bf0a:	9102      	str	r1, [sp, #8]
    bf0c:	9201      	str	r2, [sp, #4]
    base->RXIMR[msgBuffIdx] = mask;
    bf0e:	9b03      	ldr	r3, [sp, #12]
    bf10:	9a02      	ldr	r2, [sp, #8]
    bf12:	f502 7208 	add.w	r2, r2, #544	; 0x220
    bf16:	9901      	ldr	r1, [sp, #4]
    bf18:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    bf1c:	bf00      	nop
    bf1e:	b004      	add	sp, #16
    bf20:	4770      	bx	lr

0000bf22 <FlexCAN_SetTxArbitrationStartDelay>:
 *
 * @param   base  The FlexCAN base address
 * @param   tasd  The Tx arbitration start delay value
 */
static inline void FlexCAN_SetTxArbitrationStartDelay(FLEXCAN_Type * base, uint8 tasd)
{
    bf22:	b082      	sub	sp, #8
    bf24:	9001      	str	r0, [sp, #4]
    bf26:	460b      	mov	r3, r1
    bf28:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_TASD_MASK) | FLEXCAN_CTRL2_TASD(tasd);
    bf2c:	9b01      	ldr	r3, [sp, #4]
    bf2e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    bf30:	f423 0278 	bic.w	r2, r3, #16252928	; 0xf80000
    bf34:	f89d 3003 	ldrb.w	r3, [sp, #3]
    bf38:	04db      	lsls	r3, r3, #19
    bf3a:	f403 0378 	and.w	r3, r3, #16252928	; 0xf80000
    bf3e:	431a      	orrs	r2, r3
    bf40:	9b01      	ldr	r3, [sp, #4]
    bf42:	635a      	str	r2, [r3, #52]	; 0x34
}
    bf44:	bf00      	nop
    bf46:	b002      	add	sp, #8
    bf48:	4770      	bx	lr

0000bf4a <FlexCAN_SetRxMaskType>:
 *
 * @param   base  The FlexCAN base address
 * @param   type         The FlexCAN Rx mask type
 */
static inline void FlexCAN_SetRxMaskType(FLEXCAN_Type * base, Flexcan_Ip_RxMaskType type)
{
    bf4a:	b082      	sub	sp, #8
    bf4c:	9001      	str	r0, [sp, #4]
    bf4e:	9100      	str	r1, [sp, #0]
    /* Set RX masking type (RX global mask or RX individual mask)*/
    if (FLEXCAN_RX_MASK_GLOBAL == type)
    bf50:	9b00      	ldr	r3, [sp, #0]
    bf52:	2b00      	cmp	r3, #0
    bf54:	d106      	bne.n	bf64 <FlexCAN_SetRxMaskType+0x1a>
    {
        /* Enable Global RX masking */
        base->MCR = (base->MCR & ~FLEXCAN_MCR_IRMQ_MASK) | FLEXCAN_MCR_IRMQ(0U);
    bf56:	9b01      	ldr	r3, [sp, #4]
    bf58:	681b      	ldr	r3, [r3, #0]
    bf5a:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
    bf5e:	9b01      	ldr	r3, [sp, #4]
    bf60:	601a      	str	r2, [r3, #0]
    else
    {
        /* Enable Individual Rx Masking and Queue */
        base->MCR = (base->MCR & ~FLEXCAN_MCR_IRMQ_MASK) | FLEXCAN_MCR_IRMQ(1U);
    }
}
    bf62:	e005      	b.n	bf70 <FlexCAN_SetRxMaskType+0x26>
        base->MCR = (base->MCR & ~FLEXCAN_MCR_IRMQ_MASK) | FLEXCAN_MCR_IRMQ(1U);
    bf64:	9b01      	ldr	r3, [sp, #4]
    bf66:	681b      	ldr	r3, [r3, #0]
    bf68:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
    bf6c:	9b01      	ldr	r3, [sp, #4]
    bf6e:	601a      	str	r2, [r3, #0]
}
    bf70:	bf00      	nop
    bf72:	b002      	add	sp, #8
    bf74:	4770      	bx	lr

0000bf76 <FlexCAN_SetRegDefaultVal>:
 * @brief Will set Flexcan Peripheral Register to default val.
 *
 * @param   base    The FlexCAN base address
 */
static inline void FlexCAN_SetRegDefaultVal(FLEXCAN_Type * base)
{
    bf76:	b500      	push	{lr}
    bf78:	b083      	sub	sp, #12
    bf7a:	9001      	str	r0, [sp, #4]
        base->ERFCR = FLEXCAN_IP_ERFCR_DEFAULT_VALUE_U32;
    }
#endif /* (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) */
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
    #if defined(CAN_FEATURE_S32K1XX)
    if (TRUE == FlexCAN_IsFDAvailable(base))
    bf7c:	9801      	ldr	r0, [sp, #4]
    bf7e:	f002 ff85 	bl	ee8c <FlexCAN_IsFDAvailable>
    bf82:	4603      	mov	r3, r0
    bf84:	2b00      	cmp	r3, #0
    bf86:	d007      	beq.n	bf98 <FlexCAN_SetRegDefaultVal+0x22>
    {
    #endif /* defined(CAN_FEATURE_S32K1XX) */
        base->FDCBT = FLEXCAN_IP_FDCBT_DEFAULT_VALUE_U32;
    bf88:	9b01      	ldr	r3, [sp, #4]
    bf8a:	2200      	movs	r2, #0
    bf8c:	f8c3 2c04 	str.w	r2, [r3, #3076]	; 0xc04
        base->FDCTRL = FLEXCAN_IP_FDCTRL_DEFAULT_VALUE_U32;
    bf90:	9b01      	ldr	r3, [sp, #4]
    bf92:	4a12      	ldr	r2, [pc, #72]	; (bfdc <FlexCAN_SetRegDefaultVal+0x66>)
    bf94:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
    {
        base->IFLAG2 = FLEXCAN_IP_IFLAG_DEFAULT_VALUE_U32;
        base->IMASK2 = FLEXCAN_IP_IMASK_DEFAULT_VALUE_U32;
    }
#endif /* (FLEXCAN_IP_FEATURE_MAX_MB_NUM > 32U) */
    base->IFLAG1 = FLEXCAN_IP_IFLAG_DEFAULT_VALUE_U32;
    bf98:	9b01      	ldr	r3, [sp, #4]
    bf9a:	f04f 32ff 	mov.w	r2, #4294967295
    bf9e:	631a      	str	r2, [r3, #48]	; 0x30
    base->IMASK1 = FLEXCAN_IP_IMASK_DEFAULT_VALUE_U32;
    bfa0:	9b01      	ldr	r3, [sp, #4]
    bfa2:	2200      	movs	r2, #0
    bfa4:	629a      	str	r2, [r3, #40]	; 0x28
    base->CBT = FLEXCAN_IP_CBT_DEFAULT_VALUE_U32;
    bfa6:	9b01      	ldr	r3, [sp, #4]
    bfa8:	2200      	movs	r2, #0
    bfaa:	651a      	str	r2, [r3, #80]	; 0x50
    base->CTRL2 = FLEXCAN_IP_CTRL2_DEFAULT_VALUE_U32;
    bfac:	9b01      	ldr	r3, [sp, #4]
    bfae:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    bfb2:	635a      	str	r2, [r3, #52]	; 0x34
    base->ESR1 = FLEXCAN_IP_ESR1_DEFAULT_VALUE_U32;
    bfb4:	9b01      	ldr	r3, [sp, #4]
    bfb6:	4a0a      	ldr	r2, [pc, #40]	; (bfe0 <FlexCAN_SetRegDefaultVal+0x6a>)
    bfb8:	621a      	str	r2, [r3, #32]
    base->ECR = FLEXCAN_IP_ECR_DEFAULT_VALUE_U32;
    bfba:	9b01      	ldr	r3, [sp, #4]
    bfbc:	2200      	movs	r2, #0
    bfbe:	61da      	str	r2, [r3, #28]
    base->TIMER = FLEXCAN_IP_TIMER_DEFAULT_VALUE_U32;
    bfc0:	9b01      	ldr	r3, [sp, #4]
    bfc2:	2200      	movs	r2, #0
    bfc4:	609a      	str	r2, [r3, #8]
    base->CTRL1 = FLEXCAN_IP_CTRL1_DEFAULT_VALUE_U32;
    bfc6:	9b01      	ldr	r3, [sp, #4]
    bfc8:	2200      	movs	r2, #0
    bfca:	605a      	str	r2, [r3, #4]
    base->EPRS  = FLEXCAN_IP_EPRS_DEFAULT_VALUE_U32;
    base->ENCBT = FLEXCAN_IP_ENCBT_DEFAULT_VALUE_U32;
    base->EDCBT = FLEXCAN_IP_EDCBT_DEFAULT_VALUE_U32;
    base->ETDC  = FLEXCAN_IP_ETDC_DEFAULT_VALUE_U32;
#endif
    base->MCR = FLEXCAN_IP_MCR_DEFAULT_VALUE_U32;
    bfcc:	9b01      	ldr	r3, [sp, #4]
    bfce:	4a05      	ldr	r2, [pc, #20]	; (bfe4 <FlexCAN_SetRegDefaultVal+0x6e>)
    bfd0:	601a      	str	r2, [r3, #0]
}
    bfd2:	bf00      	nop
    bfd4:	b003      	add	sp, #12
    bfd6:	f85d fb04 	ldr.w	pc, [sp], #4
    bfda:	bf00      	nop
    bfdc:	80004100 	.word	0x80004100
    bfe0:	0003b006 	.word	0x0003b006
    bfe4:	d890000f 	.word	0xd890000f

0000bfe8 <FlexCAN_InitRxFifo>:
 * Description   : Initialize fifo and dma if requested.
 *
 * This is not a public API as it is called from other driver functions.
 *END**************************************************************************/
static Flexcan_Ip_StatusType FlexCAN_InitRxFifo(FLEXCAN_Type * pBase, const Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
    bfe8:	b500      	push	{lr}
    bfea:	b085      	sub	sp, #20
    bfec:	9001      	str	r0, [sp, #4]
    bfee:	9100      	str	r1, [sp, #0]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    bff0:	2300      	movs	r3, #0
    bff2:	9303      	str	r3, [sp, #12]

    /* Enable RxFIFO feature, if requested. This might fail if the FD mode is enabled. */
    if (Flexcan_Ip_pData->is_rx_fifo_needed)
    bff4:	9b00      	ldr	r3, [sp, #0]
    bff6:	7a1b      	ldrb	r3, [r3, #8]
    bff8:	2b00      	cmp	r3, #0
    bffa:	d006      	beq.n	c00a <FlexCAN_InitRxFifo+0x22>
    {
        eResult = FlexCAN_EnableRxFifo(pBase, (uint32)Flexcan_Ip_pData->num_id_filters);
    bffc:	9b00      	ldr	r3, [sp, #0]
    bffe:	685b      	ldr	r3, [r3, #4]
    c000:	4619      	mov	r1, r3
    c002:	9801      	ldr	r0, [sp, #4]
    c004:	f002 fefe 	bl	ee04 <FlexCAN_EnableRxFifo>
    c008:	9003      	str	r0, [sp, #12]
        FlexCAN_SetRxFifoDMA(pBase, FALSE);
    }
    }
#endif /* FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */

    return eResult;
    c00a:	9b03      	ldr	r3, [sp, #12]
}
    c00c:	4618      	mov	r0, r3
    c00e:	b005      	add	sp, #20
    c010:	f85d fb04 	ldr.w	pc, [sp], #4

0000c014 <FlexCAN_InitCtroll>:
 * Description   : Initialize basically controller.
 *
 * This is not a public API as it is called from other driver functions.
 *END**************************************************************************/
static Flexcan_Ip_StatusType FlexCAN_InitCtroll(FLEXCAN_Type * pBase, const Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
    c014:	b500      	push	{lr}
    c016:	b085      	sub	sp, #20
    c018:	9001      	str	r0, [sp, #4]
    c01a:	9100      	str	r1, [sp, #0]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    c01c:	2300      	movs	r3, #0
    c01e:	9303      	str	r3, [sp, #12]
    /* Disable the self reception feature if FlexCAN is not in loopback mode. */
    if (Flexcan_Ip_pData->flexcanMode != FLEXCAN_LOOPBACK_MODE)
    c020:	9b00      	ldr	r3, [sp, #0]
    c022:	68db      	ldr	r3, [r3, #12]
    c024:	2b02      	cmp	r3, #2
    c026:	d003      	beq.n	c030 <FlexCAN_InitCtroll+0x1c>
    {
        FlexCAN_SetSelfReception(pBase, FALSE);
    c028:	2100      	movs	r1, #0
    c02a:	9801      	ldr	r0, [sp, #4]
    c02c:	f7ff feec 	bl	be08 <FlexCAN_SetSelfReception>
    }

    /* Init legacy fifo, enhanced fifo if requested. */
    eResult = FlexCAN_InitRxFifo(pBase, Flexcan_Ip_pData);
    c030:	9900      	ldr	r1, [sp, #0]
    c032:	9801      	ldr	r0, [sp, #4]
    c034:	f7ff ffd8 	bl	bfe8 <FlexCAN_InitRxFifo>
    c038:	9003      	str	r0, [sp, #12]
    if (eResult != FLEXCAN_STATUS_SUCCESS)
    c03a:	9b03      	ldr	r3, [sp, #12]
    c03c:	2b00      	cmp	r3, #0
    c03e:	d006      	beq.n	c04e <FlexCAN_InitCtroll+0x3a>
    {
        /* To enter Disable Mode requires FreezMode first */
        (void)FlexCAN_EnterFreezeMode(pBase);
    c040:	9801      	ldr	r0, [sp, #4]
    c042:	f002 fd03 	bl	ea4c <FlexCAN_EnterFreezeMode>
        (void)FlexCAN_Disable(pBase);
    c046:	9801      	ldr	r0, [sp, #4]
    c048:	f002 fdca 	bl	ebe0 <FlexCAN_Disable>
    c04c:	e00b      	b.n	c066 <FlexCAN_InitCtroll+0x52>
    }
    else
    {
    #if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        /* Set payload size. */
        FlexCAN_SetPayloadSize(pBase, &Flexcan_Ip_pData->payload);
    c04e:	9b00      	ldr	r3, [sp, #0]
    c050:	3314      	adds	r3, #20
    c052:	4619      	mov	r1, r3
    c054:	9801      	ldr	r0, [sp, #4]
    c056:	f002 ff3b 	bl	eed0 <FlexCAN_SetPayloadSize>
            /* To enter Disable Mode requires FreezMode first */
            (void)FlexCAN_EnterFreezeMode(pBase);
            (void)FlexCAN_Disable(pBase);
        }
    #else
        (void)FlexCAN_SetMaxMsgBuffNum(pBase, Flexcan_Ip_pData->max_num_mb);
    c05a:	9b00      	ldr	r3, [sp, #0]
    c05c:	681b      	ldr	r3, [r3, #0]
    c05e:	4619      	mov	r1, r3
    c060:	9801      	ldr	r0, [sp, #4]
    c062:	f003 fab7 	bl	f5d4 <FlexCAN_SetMaxMsgBuffNum>
    #endif /* FLEXCAN_IP_DEV_ERROR_DETECT */
    }
    return eResult;
    c066:	9b03      	ldr	r3, [sp, #12]
}
    c068:	4618      	mov	r0, r3
    c06a:	b005      	add	sp, #20
    c06c:	f85d fb04 	ldr.w	pc, [sp], #4

0000c070 <FlexCAN_InitController>:
 * Description   : Initialize basically controller.
 *
 * This is not a public API as it is called from other driver functions.
 *END**************************************************************************/
static Flexcan_Ip_StatusType FlexCAN_InitController(uint8 Instance, FLEXCAN_Type * pBase, const Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
    c070:	b500      	push	{lr}
    c072:	b087      	sub	sp, #28
    c074:	4603      	mov	r3, r0
    c076:	9102      	str	r1, [sp, #8]
    c078:	9201      	str	r2, [sp, #4]
    c07a:	f88d 300f 	strb.w	r3, [sp, #15]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    c07e:	2300      	movs	r3, #0
    c080:	9305      	str	r3, [sp, #20]

    if (FlexCAN_IsEnabled(pBase))
    c082:	9802      	ldr	r0, [sp, #8]
    c084:	f7ff fd0c 	bl	baa0 <FlexCAN_IsEnabled>
    c088:	4603      	mov	r3, r0
    c08a:	2b00      	cmp	r3, #0
    c08c:	d00a      	beq.n	c0a4 <FlexCAN_InitController+0x34>
    {
        /* To enter Disable Mode requires FreezMode first */
        eResult = FlexCAN_EnterFreezeMode(pBase);
    c08e:	9802      	ldr	r0, [sp, #8]
    c090:	f002 fcdc 	bl	ea4c <FlexCAN_EnterFreezeMode>
    c094:	9005      	str	r0, [sp, #20]
        if (FLEXCAN_STATUS_SUCCESS == eResult)
    c096:	9b05      	ldr	r3, [sp, #20]
    c098:	2b00      	cmp	r3, #0
    c09a:	d103      	bne.n	c0a4 <FlexCAN_InitController+0x34>
        {
            eResult = FlexCAN_Disable(pBase);
    c09c:	9802      	ldr	r0, [sp, #8]
    c09e:	f002 fd9f 	bl	ebe0 <FlexCAN_Disable>
    c0a2:	9005      	str	r0, [sp, #20]
        }
    }

    if (FLEXCAN_STATUS_SUCCESS == eResult)
    c0a4:	9b05      	ldr	r3, [sp, #20]
    c0a6:	2b00      	cmp	r3, #0
    c0a8:	d137      	bne.n	c11a <FlexCAN_InitController+0xaa>
    {
    #if (FLEXCAN_IP_FEATURE_HAS_PE_CLKSRC_SELECT == STD_ON)
        /* Select a source clock for the FlexCAN engine */
        FlexCAN_SetClkSrc(pBase, Flexcan_Ip_pData->is_pe_clock);
    c0aa:	9b01      	ldr	r3, [sp, #4]
    c0ac:	7e5b      	ldrb	r3, [r3, #25]
    c0ae:	4619      	mov	r1, r3
    c0b0:	9802      	ldr	r0, [sp, #8]
    c0b2:	f7ff fee9 	bl	be88 <FlexCAN_SetClkSrc>
    #endif
        /* Enable FlexCAN Module need to perform SoftReset & ClearRam */
        pBase->MCR &= ~FLEXCAN_MCR_MDIS_MASK;
    c0b6:	9b02      	ldr	r3, [sp, #8]
    c0b8:	681b      	ldr	r3, [r3, #0]
    c0ba:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
    c0be:	9b02      	ldr	r3, [sp, #8]
    c0c0:	601a      	str	r2, [r3, #0]
        /* Initialize FLEXCAN device */
        eResult = FlexCAN_Init(pBase);
    c0c2:	9802      	ldr	r0, [sp, #8]
    c0c4:	f002 fe28 	bl	ed18 <FlexCAN_Init>
    c0c8:	9005      	str	r0, [sp, #20]
        if (eResult != FLEXCAN_STATUS_SUCCESS)
    c0ca:	9b05      	ldr	r3, [sp, #20]
    c0cc:	2b00      	cmp	r3, #0
    c0ce:	d006      	beq.n	c0de <FlexCAN_InitController+0x6e>
        {
            /* To enter Disable Mode requires FreezMode first */
            (void)FlexCAN_EnterFreezeMode(pBase);
    c0d0:	9802      	ldr	r0, [sp, #8]
    c0d2:	f002 fcbb 	bl	ea4c <FlexCAN_EnterFreezeMode>
            (void)FlexCAN_Disable(pBase);
    c0d6:	9802      	ldr	r0, [sp, #8]
    c0d8:	f002 fd82 	bl	ebe0 <FlexCAN_Disable>
    c0dc:	e01d      	b.n	c11a <FlexCAN_InitController+0xaa>
            /* Disable the Protection again because is enabled by soft reset */
            FlexCAN_DisableMemErrorDetection(pBase);
        #endif

        #if defined(CAN_FEATURE_S32K1XX)
            if (TRUE == FlexCAN_IsFDAvailable(pBase))
    c0de:	9802      	ldr	r0, [sp, #8]
    c0e0:	f002 fed4 	bl	ee8c <FlexCAN_IsFDAvailable>
    c0e4:	4603      	mov	r3, r0
    c0e6:	2b00      	cmp	r3, #0
    c0e8:	d007      	beq.n	c0fa <FlexCAN_InitController+0x8a>
            {
        #endif /* defined(CAN_FEATURE_S32K1XX) */
                /* Enable/Disable FD and check FD was set as expected. Setting FD as enabled
                 * might fail if the current CAN instance does not support FD. */
                FlexCAN_SetFDEnabled(pBase, Flexcan_Ip_pData->fd_enable, Flexcan_Ip_pData->bitRateSwitch);
    c0ea:	9b01      	ldr	r3, [sp, #4]
    c0ec:	7e19      	ldrb	r1, [r3, #24]
    c0ee:	9b01      	ldr	r3, [sp, #4]
    c0f0:	7edb      	ldrb	r3, [r3, #27]
    c0f2:	461a      	mov	r2, r3
    c0f4:	9802      	ldr	r0, [sp, #8]
    c0f6:	f7ff fcdd 	bl	bab4 <FlexCAN_SetFDEnabled>
                }*/
        #if defined(CAN_FEATURE_S32K1XX)
            }
        #endif /* defined(CAN_FEATURE_S32K1XX) */
            /* configure depends on controller options. */
            FlexCAN_ConfigCtrlOptions(pBase, Flexcan_Ip_pData->ctrlOptions);
    c0fa:	9b01      	ldr	r3, [sp, #4]
    c0fc:	691b      	ldr	r3, [r3, #16]
    c0fe:	4619      	mov	r1, r3
    c100:	9802      	ldr	r0, [sp, #8]
    c102:	f003 fdeb 	bl	fcdc <FlexCAN_ConfigCtrlOptions>
            /* reset Imask buffers */
            FlexCAN_ResetImaskBuff(Instance);
    c106:	f89d 300f 	ldrb.w	r3, [sp, #15]
    c10a:	4618      	mov	r0, r3
    c10c:	f003 fe56 	bl	fdbc <FlexCAN_ResetImaskBuff>
            eResult = FlexCAN_InitCtroll(pBase, Flexcan_Ip_pData);
    c110:	9901      	ldr	r1, [sp, #4]
    c112:	9802      	ldr	r0, [sp, #8]
    c114:	f7ff ff7e 	bl	c014 <FlexCAN_InitCtroll>
    c118:	9005      	str	r0, [sp, #20]
        }
    }
    return eResult;
    c11a:	9b05      	ldr	r3, [sp, #20]
}
    c11c:	4618      	mov	r0, r3
    c11e:	b007      	add	sp, #28
    c120:	f85d fb04 	ldr.w	pc, [sp], #4

0000c124 <FlexCAN_InitBaudrate>:
 * Description   : Init baudrate for given controller.
 * This is not a public API as it is called from other driver functions.
 *
 *END**************************************************************************/
static void FlexCAN_InitBaudrate(FLEXCAN_Type * pBase, const Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
    c124:	b500      	push	{lr}
    c126:	b083      	sub	sp, #12
    c128:	9001      	str	r0, [sp, #4]
    c12a:	9100      	str	r1, [sp, #0]
    /* Enable the use of extended bit time definitions */
    FlexCAN_EnableExtCbt(pBase, Flexcan_Ip_pData->fd_enable);
    c12c:	9b00      	ldr	r3, [sp, #0]
    c12e:	7e1b      	ldrb	r3, [r3, #24]
    c130:	4619      	mov	r1, r3
    c132:	9801      	ldr	r0, [sp, #4]
    c134:	f7ff fe51 	bl	bdda <FlexCAN_EnableExtCbt>
        /* Disable Enhanced CBT time segments */
        pBase->CTRL2 &= ~FLEXCAN_CTRL2_BTE_MASK;
#endif
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        /* Set bit rate. */
        if (Flexcan_Ip_pData->fd_enable)
    c138:	9b00      	ldr	r3, [sp, #0]
    c13a:	7e1b      	ldrb	r3, [r3, #24]
    c13c:	2b00      	cmp	r3, #0
    c13e:	d00c      	beq.n	c15a <FlexCAN_InitBaudrate+0x36>
        {
            /* Write Normal bit time configuration to CBT register */
            FlexCAN_SetExtendedTimeSegments(pBase, &Flexcan_Ip_pData->bitrate);
    c140:	9b00      	ldr	r3, [sp, #0]
    c142:	331c      	adds	r3, #28
    c144:	4619      	mov	r1, r3
    c146:	9801      	ldr	r0, [sp, #4]
    c148:	f7ff fd94 	bl	bc74 <FlexCAN_SetExtendedTimeSegments>
            /* Write Data bit time configuration to FDCBT register */
            FlexCAN_SetFDTimeSegments(pBase, &Flexcan_Ip_pData->bitrate_cbt);
    c14c:	9b00      	ldr	r3, [sp, #0]
    c14e:	3330      	adds	r3, #48	; 0x30
    c150:	4619      	mov	r1, r3
    c152:	9801      	ldr	r0, [sp, #4]
    c154:	f7ff fd2d 	bl	bbb2 <FlexCAN_SetFDTimeSegments>
            /* Write Normal bit time configuration to CTRL1 register */
            FlexCAN_SetTimeSegments(pBase, &Flexcan_Ip_pData->bitrate);
        }
#endif
    }
}
    c158:	e005      	b.n	c166 <FlexCAN_InitBaudrate+0x42>
            FlexCAN_SetTimeSegments(pBase, &Flexcan_Ip_pData->bitrate);
    c15a:	9b00      	ldr	r3, [sp, #0]
    c15c:	331c      	adds	r3, #28
    c15e:	4619      	mov	r1, r3
    c160:	9801      	ldr	r0, [sp, #4]
    c162:	f7ff fd5b 	bl	bc1c <FlexCAN_SetTimeSegments>
}
    c166:	bf00      	nop
    c168:	b003      	add	sp, #12
    c16a:	f85d fb04 	ldr.w	pc, [sp], #4

0000c16e <FlexCAN_ProccessLegacyRxFIFO>:
 * Description   : This function will process the enhanced RxFIFO in blocking mode.
 * This is not a public API as it is called from other driver functions.
 *
 *END**************************************************************************/
static Flexcan_Ip_StatusType FlexCAN_ProccessLegacyRxFIFO(uint8 u8Instance, uint32 u32TimeoutMs)
{
    c16e:	b500      	push	{lr}
    c170:	b08d      	sub	sp, #52	; 0x34
    c172:	4603      	mov	r3, r0
    c174:	9102      	str	r1, [sp, #8]
    c176:	f88d 300f 	strb.w	r3, [sp, #15]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    c17a:	2300      	movs	r3, #0
    c17c:	930b      	str	r3, [sp, #44]	; 0x2c
    Flexcan_Ip_StateType * pState = Flexcan_Ip_apxState[u8Instance];
    c17e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    c182:	4a46      	ldr	r2, [pc, #280]	; (c29c <FlexCAN_ProccessLegacyRxFIFO+0x12e>)
    c184:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c188:	9308      	str	r3, [sp, #32]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    c18a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    c18e:	4a44      	ldr	r2, [pc, #272]	; (c2a0 <FlexCAN_ProccessLegacyRxFIFO+0x132>)
    c190:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c194:	9307      	str	r3, [sp, #28]
    uint32 timeStart = 0U;
    c196:	2300      	movs	r3, #0
    c198:	9305      	str	r3, [sp, #20]
    uint32 timeElapsed = 0U;
    c19a:	2300      	movs	r3, #0
    c19c:	930a      	str	r3, [sp, #40]	; 0x28
    uint32 mS2Ticks = OsIf_MicrosToTicks((u32TimeoutMs * 1000U), FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    c19e:	9b02      	ldr	r3, [sp, #8]
    c1a0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    c1a4:	fb02 f303 	mul.w	r3, r2, r3
    c1a8:	2100      	movs	r1, #0
    c1aa:	4618      	mov	r0, r3
    c1ac:	f7f5 ff0a 	bl	1fc4 <OsIf_MicrosToTicks>
    c1b0:	9006      	str	r0, [sp, #24]
    uint32 u32intType = 0U;
    c1b2:	2300      	movs	r3, #0
    c1b4:	9309      	str	r3, [sp, #36]	; 0x24

        timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    c1b6:	2000      	movs	r0, #0
    c1b8:	f7f5 feb8 	bl	1f2c <OsIf_GetCounter>
    c1bc:	4603      	mov	r3, r0
    c1be:	9305      	str	r3, [sp, #20]

        while (FLEXCAN_MB_RX_BUSY == pState->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state)
    c1c0:	e02a      	b.n	c218 <FlexCAN_ProccessLegacyRxFIFO+0xaa>
        {
            if (FLEXCAN_RXFIFO_USING_POLLING == pState->transferType)
    c1c2:	9b08      	ldr	r3, [sp, #32]
    c1c4:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
    c1c8:	2b01      	cmp	r3, #1
    c1ca:	d115      	bne.n	c1f8 <FlexCAN_ProccessLegacyRxFIFO+0x8a>
            {
                for (u32intType = FLEXCAN_IP_LEGACY_RXFIFO_OVERFLOW; \
    c1cc:	2307      	movs	r3, #7
    c1ce:	9309      	str	r3, [sp, #36]	; 0x24
    c1d0:	e00f      	b.n	c1f2 <FlexCAN_ProccessLegacyRxFIFO+0x84>
                     u32intType >= FLEXCAN_IP_LEGACY_RXFIFO_FRAME_AVAILABLE; \
                     u32intType--)
                {
                    if (FlexCAN_GetBuffStatusFlag(pBase, u32intType) != 0U)
    c1d2:	9909      	ldr	r1, [sp, #36]	; 0x24
    c1d4:	9807      	ldr	r0, [sp, #28]
    c1d6:	f7ff fcd0 	bl	bb7a <FlexCAN_GetBuffStatusFlag>
    c1da:	4603      	mov	r3, r0
    c1dc:	2b00      	cmp	r3, #0
    c1de:	d005      	beq.n	c1ec <FlexCAN_ProccessLegacyRxFIFO+0x7e>
                    {
                        FlexCAN_IRQHandlerRxFIFO(u8Instance, u32intType);
    c1e0:	f89d 300f 	ldrb.w	r3, [sp, #15]
    c1e4:	9909      	ldr	r1, [sp, #36]	; 0x24
    c1e6:	4618      	mov	r0, r3
    c1e8:	f000 fb06 	bl	c7f8 <FlexCAN_IRQHandlerRxFIFO>
                     u32intType--)
    c1ec:	9b09      	ldr	r3, [sp, #36]	; 0x24
    c1ee:	3b01      	subs	r3, #1
    c1f0:	9309      	str	r3, [sp, #36]	; 0x24
                for (u32intType = FLEXCAN_IP_LEGACY_RXFIFO_OVERFLOW; \
    c1f2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    c1f4:	2b04      	cmp	r3, #4
    c1f6:	d8ec      	bhi.n	c1d2 <FlexCAN_ProccessLegacyRxFIFO+0x64>
                    }
                }
            }

            timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    c1f8:	ab05      	add	r3, sp, #20
    c1fa:	2100      	movs	r1, #0
    c1fc:	4618      	mov	r0, r3
    c1fe:	f7f5 feae 	bl	1f5e <OsIf_GetElapsed>
    c202:	4602      	mov	r2, r0
    c204:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    c206:	4413      	add	r3, r2
    c208:	930a      	str	r3, [sp, #40]	; 0x28
            if (timeElapsed >= mS2Ticks)
    c20a:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    c20c:	9b06      	ldr	r3, [sp, #24]
    c20e:	429a      	cmp	r2, r3
    c210:	d302      	bcc.n	c218 <FlexCAN_ProccessLegacyRxFIFO+0xaa>
            {
                eResult = FLEXCAN_STATUS_TIMEOUT;
    c212:	2303      	movs	r3, #3
    c214:	930b      	str	r3, [sp, #44]	; 0x2c
                break;
    c216:	e003      	b.n	c220 <FlexCAN_ProccessLegacyRxFIFO+0xb2>
        while (FLEXCAN_MB_RX_BUSY == pState->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state)
    c218:	9b08      	ldr	r3, [sp, #32]
    c21a:	685b      	ldr	r3, [r3, #4]
    c21c:	2b01      	cmp	r3, #1
    c21e:	d0d0      	beq.n	c1c2 <FlexCAN_ProccessLegacyRxFIFO+0x54>
            }
        }

        if ((FLEXCAN_STATUS_TIMEOUT == eResult) && (FLEXCAN_RXFIFO_USING_POLLING != pState->transferType))
    c220:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    c222:	2b03      	cmp	r3, #3
    c224:	d125      	bne.n	c272 <FlexCAN_ProccessLegacyRxFIFO+0x104>
    c226:	9b08      	ldr	r3, [sp, #32]
    c228:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
    c22c:	2b01      	cmp	r3, #1
    c22e:	d020      	beq.n	c272 <FlexCAN_ProccessLegacyRxFIFO+0x104>
        {
            /* Disable RX FIFO interrupts*/
            (void)FlexCAN_SetMsgBuffIntCmd(pBase, u8Instance, FLEXCAN_IP_LEGACY_RXFIFO_FRAME_AVAILABLE, FALSE, pState->isIntActive);
    c230:	9b08      	ldr	r3, [sp, #32]
    c232:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    c236:	f89d 100f 	ldrb.w	r1, [sp, #15]
    c23a:	9300      	str	r3, [sp, #0]
    c23c:	2300      	movs	r3, #0
    c23e:	2205      	movs	r2, #5
    c240:	9807      	ldr	r0, [sp, #28]
    c242:	f002 feef 	bl	f024 <FlexCAN_SetMsgBuffIntCmd>
            (void)FlexCAN_SetMsgBuffIntCmd(pBase, u8Instance, FLEXCAN_IP_LEGACY_RXFIFO_WARNING, FALSE, pState->isIntActive);
    c246:	9b08      	ldr	r3, [sp, #32]
    c248:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    c24c:	f89d 100f 	ldrb.w	r1, [sp, #15]
    c250:	9300      	str	r3, [sp, #0]
    c252:	2300      	movs	r3, #0
    c254:	2206      	movs	r2, #6
    c256:	9807      	ldr	r0, [sp, #28]
    c258:	f002 fee4 	bl	f024 <FlexCAN_SetMsgBuffIntCmd>
            (void)FlexCAN_SetMsgBuffIntCmd(pBase, u8Instance, FLEXCAN_IP_LEGACY_RXFIFO_OVERFLOW, FALSE, pState->isIntActive);
    c25c:	9b08      	ldr	r3, [sp, #32]
    c25e:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    c262:	f89d 100f 	ldrb.w	r1, [sp, #15]
    c266:	9300      	str	r3, [sp, #0]
    c268:	2300      	movs	r3, #0
    c26a:	2207      	movs	r2, #7
    c26c:	9807      	ldr	r0, [sp, #28]
    c26e:	f002 fed9 	bl	f024 <FlexCAN_SetMsgBuffIntCmd>
                (void)Dma_Ip_SetLogicChannelCommand(pState->rxFifoDMAChannel, DMA_IP_CH_CLEAR_HARDWARE_REQUEST);
            }
#endif
        }

        switch (pState->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state)
    c272:	9b08      	ldr	r3, [sp, #32]
    c274:	685b      	ldr	r3, [r3, #4]
    c276:	2b00      	cmp	r3, #0
    c278:	d005      	beq.n	c286 <FlexCAN_ProccessLegacyRxFIFO+0x118>
    c27a:	2b01      	cmp	r3, #1
    c27c:	d106      	bne.n	c28c <FlexCAN_ProccessLegacyRxFIFO+0x11e>
        {
            case FLEXCAN_MB_RX_BUSY:
                pState->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state = FLEXCAN_MB_IDLE;
    c27e:	9b08      	ldr	r3, [sp, #32]
    c280:	2200      	movs	r2, #0
    c282:	605a      	str	r2, [r3, #4]
                break;
    c284:	e005      	b.n	c292 <FlexCAN_ProccessLegacyRxFIFO+0x124>
            case FLEXCAN_MB_IDLE:
                eResult = FLEXCAN_STATUS_SUCCESS;
    c286:	2300      	movs	r3, #0
    c288:	930b      	str	r3, [sp, #44]	; 0x2c
                break;
    c28a:	e002      	b.n	c292 <FlexCAN_ProccessLegacyRxFIFO+0x124>
            case FLEXCAN_MB_DMA_ERROR:
                eResult = FLEXCAN_STATUS_ERROR;
                break;
#endif /* if FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */
            default:
                eResult = FLEXCAN_STATUS_ERROR;
    c28c:	2301      	movs	r3, #1
    c28e:	930b      	str	r3, [sp, #44]	; 0x2c
                break;
    c290:	bf00      	nop
        }

    return eResult;
    c292:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
}
    c294:	4618      	mov	r0, r3
    c296:	b00d      	add	sp, #52	; 0x34
    c298:	f85d fb04 	ldr.w	pc, [sp], #4
    c29c:	1fff9360 	.word	0x1fff9360
    c2a0:	000186d8 	.word	0x000186d8

0000c2a4 <FlexCAN_StartRxMessageBufferData>:
static Flexcan_Ip_StatusType FlexCAN_StartRxMessageBufferData(uint8 instance,
                                                              uint8 mb_idx,
                                                              Flexcan_Ip_MsgBuffType * data,
                                                              boolean isPolling
                                                             )
{
    c2a4:	b084      	sub	sp, #16
    c2a6:	9200      	str	r2, [sp, #0]
    c2a8:	461a      	mov	r2, r3
    c2aa:	4603      	mov	r3, r0
    c2ac:	f88d 3007 	strb.w	r3, [sp, #7]
    c2b0:	460b      	mov	r3, r1
    c2b2:	f88d 3006 	strb.w	r3, [sp, #6]
    c2b6:	4613      	mov	r3, r2
    c2b8:	f88d 3005 	strb.w	r3, [sp, #5]

    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    c2bc:	2300      	movs	r3, #0
    c2be:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
#endif
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    c2c0:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c2c4:	4a15      	ldr	r2, [pc, #84]	; (c31c <FlexCAN_StartRxMessageBufferData+0x78>)
    c2c6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c2ca:	9302      	str	r3, [sp, #8]
    }
    else
    {
#endif
        /* Start receiving mailbox */
        if (state->mbs[mb_idx].state != FLEXCAN_MB_IDLE)
    c2cc:	f89d 3006 	ldrb.w	r3, [sp, #6]
    c2d0:	9a02      	ldr	r2, [sp, #8]
    c2d2:	011b      	lsls	r3, r3, #4
    c2d4:	4413      	add	r3, r2
    c2d6:	3304      	adds	r3, #4
    c2d8:	681b      	ldr	r3, [r3, #0]
    c2da:	2b00      	cmp	r3, #0
    c2dc:	d002      	beq.n	c2e4 <FlexCAN_StartRxMessageBufferData+0x40>
        {
            result = FLEXCAN_STATUS_BUSY;
    c2de:	2302      	movs	r3, #2
    c2e0:	9303      	str	r3, [sp, #12]
    c2e2:	e017      	b.n	c314 <FlexCAN_StartRxMessageBufferData+0x70>
        }
        else
        {
            state->mbs[mb_idx].state = FLEXCAN_MB_RX_BUSY;
    c2e4:	f89d 3006 	ldrb.w	r3, [sp, #6]
    c2e8:	9a02      	ldr	r2, [sp, #8]
    c2ea:	011b      	lsls	r3, r3, #4
    c2ec:	4413      	add	r3, r2
    c2ee:	3304      	adds	r3, #4
    c2f0:	2201      	movs	r2, #1
    c2f2:	601a      	str	r2, [r3, #0]
            state->mbs[mb_idx].pMBmessage = data;
    c2f4:	f89d 3006 	ldrb.w	r3, [sp, #6]
    c2f8:	9a02      	ldr	r2, [sp, #8]
    c2fa:	011b      	lsls	r3, r3, #4
    c2fc:	4413      	add	r3, r2
    c2fe:	9a00      	ldr	r2, [sp, #0]
    c300:	601a      	str	r2, [r3, #0]
            state->mbs[mb_idx].isPolling = isPolling;
    c302:	f89d 3006 	ldrb.w	r3, [sp, #6]
    c306:	9a02      	ldr	r2, [sp, #8]
    c308:	011b      	lsls	r3, r3, #4
    c30a:	4413      	add	r3, r2
    c30c:	3308      	adds	r3, #8
    c30e:	f89d 2005 	ldrb.w	r2, [sp, #5]
    c312:	701a      	strb	r2, [r3, #0]
        }
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    }
#endif
    return result;
    c314:	9b03      	ldr	r3, [sp, #12]
}
    c316:	4618      	mov	r0, r3
    c318:	b004      	add	sp, #16
    c31a:	4770      	bx	lr
    c31c:	1fff9360 	.word	0x1fff9360

0000c320 <FlexCAN_StartSendData>:
                                                   uint8 mb_idx,
                                                   const Flexcan_Ip_DataInfoType * tx_info,
                                                   uint32 msg_id,
                                                   const uint8 * mb_data
                                                  )
{
    c320:	b500      	push	{lr}
    c322:	b08f      	sub	sp, #60	; 0x3c
    c324:	9204      	str	r2, [sp, #16]
    c326:	9303      	str	r3, [sp, #12]
    c328:	4603      	mov	r3, r0
    c32a:	f88d 3017 	strb.w	r3, [sp, #23]
    c32e:	460b      	mov	r3, r1
    c330:	f88d 3016 	strb.w	r3, [sp, #22]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    c334:	2300      	movs	r3, #0
    c336:	930d      	str	r3, [sp, #52]	; 0x34
    Flexcan_Ip_MsbuffCodeStatusType cs;
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[Flexcan_Ip_u8Instance];
    c338:	f89d 3017 	ldrb.w	r3, [sp, #23]
    c33c:	4a38      	ldr	r2, [pc, #224]	; (c420 <FlexCAN_StartSendData+0x100>)
    c33e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c342:	930c      	str	r3, [sp, #48]	; 0x30
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[Flexcan_Ip_u8Instance];
    c344:	f89d 3017 	ldrb.w	r3, [sp, #23]
    c348:	4a36      	ldr	r2, [pc, #216]	; (c424 <FlexCAN_StartSendData+0x104>)
    c34a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c34e:	930b      	str	r3, [sp, #44]	; 0x2c
    volatile uint32 * pMbAddr = NULL_PTR;
    c350:	2300      	movs	r3, #0
    c352:	930a      	str	r3, [sp, #40]	; 0x28
        eResult = FLEXCAN_STATUS_BUFF_OUT_OF_RANGE;
    }
    else
    {
#endif
        if (state->mbs[mb_idx].state != FLEXCAN_MB_IDLE)
    c354:	f89d 3016 	ldrb.w	r3, [sp, #22]
    c358:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    c35a:	011b      	lsls	r3, r3, #4
    c35c:	4413      	add	r3, r2
    c35e:	3304      	adds	r3, #4
    c360:	681b      	ldr	r3, [r3, #0]
    c362:	2b00      	cmp	r3, #0
    c364:	d002      	beq.n	c36c <FlexCAN_StartSendData+0x4c>
        {
            eResult = FLEXCAN_STATUS_BUSY;
    c366:	2302      	movs	r3, #2
    c368:	930d      	str	r3, [sp, #52]	; 0x34
    c36a:	e053      	b.n	c414 <FlexCAN_StartSendData+0xf4>
        }
        else
        {
            /* Clear message buffer flag */
            FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    c36c:	f89d 3016 	ldrb.w	r3, [sp, #22]
    c370:	4619      	mov	r1, r3
    c372:	980b      	ldr	r0, [sp, #44]	; 0x2c
    c374:	f7ff fbee 	bl	bb54 <FlexCAN_ClearMsgBuffIntStatusFlag>

            state->mbs[mb_idx].state = FLEXCAN_MB_TX_BUSY;
    c378:	f89d 3016 	ldrb.w	r3, [sp, #22]
    c37c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    c37e:	011b      	lsls	r3, r3, #4
    c380:	4413      	add	r3, r2
    c382:	3304      	adds	r3, #4
    c384:	2202      	movs	r2, #2
    c386:	601a      	str	r2, [r3, #0]
            state->mbs[mb_idx].time_stamp = 0U;
    c388:	f89d 3016 	ldrb.w	r3, [sp, #22]
    c38c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    c38e:	011b      	lsls	r3, r3, #4
    c390:	4413      	add	r3, r2
    c392:	330c      	adds	r3, #12
    c394:	2200      	movs	r2, #0
    c396:	601a      	str	r2, [r3, #0]
            state->mbs[mb_idx].isPolling = tx_info->is_polling;
    c398:	f89d 3016 	ldrb.w	r3, [sp, #22]
    c39c:	9a04      	ldr	r2, [sp, #16]
    c39e:	7b11      	ldrb	r1, [r2, #12]
    c3a0:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    c3a2:	011b      	lsls	r3, r3, #4
    c3a4:	4413      	add	r3, r2
    c3a6:	3308      	adds	r3, #8
    c3a8:	460a      	mov	r2, r1
    c3aa:	701a      	strb	r2, [r3, #0]
            state->mbs[mb_idx].isRemote = tx_info->is_remote;
    c3ac:	f89d 3016 	ldrb.w	r3, [sp, #22]
    c3b0:	9a04      	ldr	r2, [sp, #16]
    c3b2:	7ad1      	ldrb	r1, [r2, #11]
    c3b4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    c3b6:	011b      	lsls	r3, r3, #4
    c3b8:	4413      	add	r3, r2
    c3ba:	3309      	adds	r3, #9
    c3bc:	460a      	mov	r2, r1
    c3be:	701a      	strb	r2, [r3, #0]

            cs.dataLen = tx_info->data_length;
    c3c0:	9b04      	ldr	r3, [sp, #16]
    c3c2:	685b      	ldr	r3, [r3, #4]
    c3c4:	9308      	str	r3, [sp, #32]

            cs.msgIdType = tx_info->msg_id_type;
    c3c6:	9b04      	ldr	r3, [sp, #16]
    c3c8:	681b      	ldr	r3, [r3, #0]
    c3ca:	9307      	str	r3, [sp, #28]

        #if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
            cs.fd_enable = tx_info->fd_enable;
    c3cc:	9b04      	ldr	r3, [sp, #16]
    c3ce:	7a1b      	ldrb	r3, [r3, #8]
    c3d0:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
            cs.fd_padding = tx_info->fd_padding;
    c3d4:	9b04      	ldr	r3, [sp, #16]
    c3d6:	7a5b      	ldrb	r3, [r3, #9]
    c3d8:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
            cs.enable_brs = tx_info->enable_brs;
    c3dc:	9b04      	ldr	r3, [sp, #16]
    c3de:	7a9b      	ldrb	r3, [r3, #10]
    c3e0:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
        #endif

            if (tx_info->is_remote)
    c3e4:	9b04      	ldr	r3, [sp, #16]
    c3e6:	7adb      	ldrb	r3, [r3, #11]
    c3e8:	2b00      	cmp	r3, #0
    c3ea:	d002      	beq.n	c3f2 <FlexCAN_StartSendData+0xd2>
            {
                cs.code = (uint32)FLEXCAN_TX_REMOTE;
    c3ec:	231c      	movs	r3, #28
    c3ee:	9306      	str	r3, [sp, #24]
    c3f0:	e001      	b.n	c3f6 <FlexCAN_StartSendData+0xd6>
            }
            else
            {
                cs.code = (uint32)FLEXCAN_TX_DATA;
    c3f2:	230c      	movs	r3, #12
    c3f4:	9306      	str	r3, [sp, #24]
            }
            pMbAddr = FlexCAN_GetMsgBuffRegion(base, mb_idx);
    c3f6:	f89d 3016 	ldrb.w	r3, [sp, #22]
    c3fa:	4619      	mov	r1, r3
    c3fc:	980b      	ldr	r0, [sp, #44]	; 0x2c
    c3fe:	f002 fa89 	bl	e914 <FlexCAN_GetMsgBuffRegion>
    c402:	900a      	str	r0, [sp, #40]	; 0x28
            FlexCAN_SetTxMsgBuff(pMbAddr, &cs, msg_id, mb_data, FALSE);
    c404:	a906      	add	r1, sp, #24
    c406:	2300      	movs	r3, #0
    c408:	9300      	str	r3, [sp, #0]
    c40a:	9b10      	ldr	r3, [sp, #64]	; 0x40
    c40c:	9a03      	ldr	r2, [sp, #12]
    c40e:	980a      	ldr	r0, [sp, #40]	; 0x28
    c410:	f002 ffd2 	bl	f3b8 <FlexCAN_SetTxMsgBuff>
        }
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    }
#endif
    return eResult;
    c414:	9b0d      	ldr	r3, [sp, #52]	; 0x34
}
    c416:	4618      	mov	r0, r3
    c418:	b00f      	add	sp, #60	; 0x3c
    c41a:	f85d fb04 	ldr.w	pc, [sp], #4
    c41e:	bf00      	nop
    c420:	1fff9360 	.word	0x1fff9360
    c424:	000186d8 	.word	0x000186d8

0000c428 <FlexCAN_StartRxMessageFifoData>:
 * receiving data and enabling the interrupt.
 * This is not a public API as it is called from other driver functions.
 *
 *END**************************************************************************/
static Flexcan_Ip_StatusType FlexCAN_StartRxMessageFifoData(uint8 instance, Flexcan_Ip_MsgBuffType * data)
{
    c428:	b500      	push	{lr}
    c42a:	b089      	sub	sp, #36	; 0x24
    c42c:	4603      	mov	r3, r0
    c42e:	9102      	str	r1, [sp, #8]
    c430:	f88d 300f 	strb.w	r3, [sp, #15]

    FLEXCAN_Type * base = NULL_PTR;
    c434:	2300      	movs	r3, #0
    c436:	9306      	str	r3, [sp, #24]
    Flexcan_Ip_StateType * state = NULL_PTR;
    c438:	2300      	movs	r3, #0
    c43a:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    c43c:	2300      	movs	r3, #0
    c43e:	9307      	str	r3, [sp, #28]

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    base = Flexcan_Ip_apxBase[instance];
    c440:	f89d 300f 	ldrb.w	r3, [sp, #15]
    c444:	4a26      	ldr	r2, [pc, #152]	; (c4e0 <FlexCAN_StartRxMessageFifoData+0xb8>)
    c446:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c44a:	9306      	str	r3, [sp, #24]
    state = Flexcan_Ip_apxState[instance];
    c44c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    c450:	4a24      	ldr	r2, [pc, #144]	; (c4e4 <FlexCAN_StartRxMessageFifoData+0xbc>)
    c452:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c456:	9305      	str	r3, [sp, #20]
    #endif
    }
#endif /* FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */

    /* Start receiving fifo */
    if (state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state == FLEXCAN_MB_RX_BUSY)
    c458:	9b05      	ldr	r3, [sp, #20]
    c45a:	685b      	ldr	r3, [r3, #4]
    c45c:	2b01      	cmp	r3, #1
    c45e:	d102      	bne.n	c466 <FlexCAN_StartRxMessageFifoData+0x3e>
    {
        eResult = FLEXCAN_STATUS_BUSY;
    c460:	2302      	movs	r3, #2
    c462:	9307      	str	r3, [sp, #28]
    c464:	e036      	b.n	c4d4 <FlexCAN_StartRxMessageFifoData+0xac>
    }
    else
    {
    state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state = FLEXCAN_MB_RX_BUSY;
    c466:	9b05      	ldr	r3, [sp, #20]
    c468:	2201      	movs	r2, #1
    c46a:	605a      	str	r2, [r3, #4]
    if (FLEXCAN_RXFIFO_USING_POLLING == state->transferType)
    c46c:	9b05      	ldr	r3, [sp, #20]
    c46e:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
    c472:	2b01      	cmp	r3, #1
    c474:	d102      	bne.n	c47c <FlexCAN_StartRxMessageFifoData+0x54>
    {
        state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].isPolling = TRUE;
    c476:	9b05      	ldr	r3, [sp, #20]
    c478:	2201      	movs	r2, #1
    c47a:	721a      	strb	r2, [r3, #8]
    }

    /* This will get filled by the interrupt handler */
    state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].pMBmessage = data;
    c47c:	9b05      	ldr	r3, [sp, #20]
    c47e:	9a02      	ldr	r2, [sp, #8]
    c480:	601a      	str	r2, [r3, #0]

    if (FLEXCAN_RXFIFO_USING_INTERRUPTS == state->transferType)
    c482:	9b05      	ldr	r3, [sp, #20]
    c484:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
    c488:	2b00      	cmp	r3, #0
    c48a:	d123      	bne.n	c4d4 <FlexCAN_StartRxMessageFifoData+0xac>
    {
        state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].isPolling = FALSE;
    c48c:	9b05      	ldr	r3, [sp, #20]
    c48e:	2200      	movs	r2, #0
    c490:	721a      	strb	r2, [r3, #8]
        /* Enable RX FIFO interrupts*/
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, FLEXCAN_IP_LEGACY_RXFIFO_WARNING, TRUE, state->isIntActive);
    c492:	9b05      	ldr	r3, [sp, #20]
    c494:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    c498:	f89d 100f 	ldrb.w	r1, [sp, #15]
    c49c:	9300      	str	r3, [sp, #0]
    c49e:	2301      	movs	r3, #1
    c4a0:	2206      	movs	r2, #6
    c4a2:	9806      	ldr	r0, [sp, #24]
    c4a4:	f002 fdbe 	bl	f024 <FlexCAN_SetMsgBuffIntCmd>
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, FLEXCAN_IP_LEGACY_RXFIFO_OVERFLOW, TRUE, state->isIntActive);
    c4a8:	9b05      	ldr	r3, [sp, #20]
    c4aa:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    c4ae:	f89d 100f 	ldrb.w	r1, [sp, #15]
    c4b2:	9300      	str	r3, [sp, #0]
    c4b4:	2301      	movs	r3, #1
    c4b6:	2207      	movs	r2, #7
    c4b8:	9806      	ldr	r0, [sp, #24]
    c4ba:	f002 fdb3 	bl	f024 <FlexCAN_SetMsgBuffIntCmd>
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, FLEXCAN_IP_LEGACY_RXFIFO_FRAME_AVAILABLE, TRUE, state->isIntActive);
    c4be:	9b05      	ldr	r3, [sp, #20]
    c4c0:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    c4c4:	f89d 100f 	ldrb.w	r1, [sp, #15]
    c4c8:	9300      	str	r3, [sp, #0]
    c4ca:	2301      	movs	r3, #1
    c4cc:	2205      	movs	r2, #5
    c4ce:	9806      	ldr	r0, [sp, #24]
    c4d0:	f002 fda8 	bl	f024 <FlexCAN_SetMsgBuffIntCmd>
#endif /* if FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */
    }
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    }
#endif
    return eResult;
    c4d4:	9b07      	ldr	r3, [sp, #28]
}
    c4d6:	4618      	mov	r0, r3
    c4d8:	b009      	add	sp, #36	; 0x24
    c4da:	f85d fb04 	ldr.w	pc, [sp], #4
    c4de:	bf00      	nop
    c4e0:	000186d8 	.word	0x000186d8
    c4e4:	1fff9360 	.word	0x1fff9360

0000c4e8 <FlexCAN_IRQHandlerRxMB>:
 *
 * This is not a public API as it is called whenever an interrupt and receive
 * individual MB occurs
 *END**************************************************************************/
static void FlexCAN_IRQHandlerRxMB(uint8 instance, uint32 mb_idx)
{
    c4e8:	b510      	push	{r4, lr}
    c4ea:	b09e      	sub	sp, #120	; 0x78
    c4ec:	4603      	mov	r3, r0
    c4ee:	9102      	str	r1, [sp, #8]
    c4f0:	f88d 300f 	strb.w	r3, [sp, #15]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    c4f4:	f89d 300f 	ldrb.w	r3, [sp, #15]
    c4f8:	4a70      	ldr	r2, [pc, #448]	; (c6bc <FlexCAN_IRQHandlerRxMB+0x1d4>)
    c4fa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c4fe:	931c      	str	r3, [sp, #112]	; 0x70
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    c500:	f89d 300f 	ldrb.w	r3, [sp, #15]
    c504:	4a6e      	ldr	r2, [pc, #440]	; (c6c0 <FlexCAN_IRQHandlerRxMB+0x1d8>)
    c506:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c50a:	931b      	str	r3, [sp, #108]	; 0x6c
    Flexcan_Ip_MsgBuffType data;
    boolean bCurrentIntStat = FALSE;
    c50c:	2300      	movs	r3, #0
    c50e:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b

    /* If use pass NULL_PTR, they can get data in callback function by getting state->mbs[mb_idx].pMBmessage  */
    if (NULL_PTR == state->mbs[mb_idx].pMBmessage)
    c512:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    c514:	9b02      	ldr	r3, [sp, #8]
    c516:	011b      	lsls	r3, r3, #4
    c518:	4413      	add	r3, r2
    c51a:	681b      	ldr	r3, [r3, #0]
    c51c:	2b00      	cmp	r3, #0
    c51e:	d105      	bne.n	c52c <FlexCAN_IRQHandlerRxMB+0x44>
    {
        state->mbs[mb_idx].pMBmessage = &data;
    c520:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    c522:	9b02      	ldr	r3, [sp, #8]
    c524:	011b      	lsls	r3, r3, #4
    c526:	4413      	add	r3, r2
    c528:	aa05      	add	r2, sp, #20
    c52a:	601a      	str	r2, [r3, #0]
    }

#if (defined (ERR_IPV_FLEXCAN_E050246) || defined (ERR_IPV_FLEXCAN_E050630))
    boolean bIsCriticalSectionNeeded = FALSE;
    c52c:	2300      	movs	r3, #0
    c52e:	f88d 3077 	strb.w	r3, [sp, #119]	; 0x77

    /* Expectation: the sequence will not be interrupted when it already in interupt context */
    if (TRUE == state->mbs[mb_idx].isPolling)
    c532:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    c534:	9b02      	ldr	r3, [sp, #8]
    c536:	011b      	lsls	r3, r3, #4
    c538:	4413      	add	r3, r2
    c53a:	3308      	adds	r3, #8
    c53c:	781b      	ldrb	r3, [r3, #0]
    c53e:	2b00      	cmp	r3, #0
    c540:	d008      	beq.n	c554 <FlexCAN_IRQHandlerRxMB+0x6c>
        if ((state->bIsLegacyFifoEn ||  state->bIsEnhancedFifoEn) && (0U != (base->CTRL2 & FLEXCAN_CTRL2_TSTAMPCAP_MASK)))
        #else
        if ((state->bIsLegacyFifoEn) && (0U != (base->CTRL2 & FLEXCAN_CTRL2_TSTAMPCAP_MASK)))
        #endif /* (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) */
    #elif defined (ERR_IPV_FLEXCAN_E050246)
        if (state->bIsLegacyFifoEn)
    c542:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    c544:	f893 3214 	ldrb.w	r3, [r3, #532]	; 0x214
    c548:	2b00      	cmp	r3, #0
    c54a:	d003      	beq.n	c554 <FlexCAN_IRQHandlerRxMB+0x6c>
    #endif
        {
            bIsCriticalSectionNeeded = TRUE;
    c54c:	2301      	movs	r3, #1
    c54e:	f88d 3077 	strb.w	r3, [sp, #119]	; 0x77
            /* Disable all IRQs */
            OsIf_SuspendAllInterrupts();
    c552:	b672      	cpsid	i
        }
    }
#endif /* (defined(ERR_IPV_FLEXCAN_E050246) || defined(ERR_IPV_FLEXCAN_E050630)) */

    /* Lock RX message buffer and RX FIFO*/
    FlexCAN_LockRxMsgBuff(base, mb_idx);
    c554:	9902      	ldr	r1, [sp, #8]
    c556:	981c      	ldr	r0, [sp, #112]	; 0x70
    c558:	f002 fd55 	bl	f006 <FlexCAN_LockRxMsgBuff>

    /* Get RX MB field values*/
    FlexCAN_GetMsgBuff(base, mb_idx, state->mbs[mb_idx].pMBmessage);
    c55c:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    c55e:	9b02      	ldr	r3, [sp, #8]
    c560:	011b      	lsls	r3, r3, #4
    c562:	4413      	add	r3, r2
    c564:	681b      	ldr	r3, [r3, #0]
    c566:	461a      	mov	r2, r3
    c568:	9902      	ldr	r1, [sp, #8]
    c56a:	981c      	ldr	r0, [sp, #112]	; 0x70
    c56c:	f002 fe7a 	bl	f264 <FlexCAN_GetMsgBuff>

    FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    c570:	9902      	ldr	r1, [sp, #8]
    c572:	981c      	ldr	r0, [sp, #112]	; 0x70
    c574:	f7ff faee 	bl	bb54 <FlexCAN_ClearMsgBuffIntStatusFlag>

#if defined (ERR_IPV_FLEXCAN_E050246)
    /* the CODE field is updated with an incorrect value when MBx is locked by software for more than 20 CAN bit times and FIFO enable.
    When the CODE field is corrupted, it's probably updated with any value that is invalid. Except EMPTY, FULL and OVERRUN other values can not make MB unlocked and move-in process. */
    if ((state->bIsLegacyFifoEn) && \
    c578:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    c57a:	f893 3214 	ldrb.w	r3, [r3, #532]	; 0x214
    c57e:	2b00      	cmp	r3, #0
    c580:	d032      	beq.n	c5e8 <FlexCAN_IRQHandlerRxMB+0x100>
    ((uint32)FLEXCAN_RX_FULL != ((state->mbs[mb_idx].pMBmessage->cs & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT)) && \
    c582:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    c584:	9b02      	ldr	r3, [sp, #8]
    c586:	011b      	lsls	r3, r3, #4
    c588:	4413      	add	r3, r2
    c58a:	681b      	ldr	r3, [r3, #0]
    c58c:	681b      	ldr	r3, [r3, #0]
    c58e:	0e1b      	lsrs	r3, r3, #24
    c590:	f003 030f 	and.w	r3, r3, #15
    if ((state->bIsLegacyFifoEn) && \
    c594:	2b02      	cmp	r3, #2
    c596:	d027      	beq.n	c5e8 <FlexCAN_IRQHandlerRxMB+0x100>
    ((uint32)FLEXCAN_RX_EMPTY != ((state->mbs[mb_idx].pMBmessage->cs & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT)) && \
    c598:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    c59a:	9b02      	ldr	r3, [sp, #8]
    c59c:	011b      	lsls	r3, r3, #4
    c59e:	4413      	add	r3, r2
    c5a0:	681b      	ldr	r3, [r3, #0]
    c5a2:	681b      	ldr	r3, [r3, #0]
    c5a4:	0e1b      	lsrs	r3, r3, #24
    c5a6:	f003 030f 	and.w	r3, r3, #15
    ((uint32)FLEXCAN_RX_FULL != ((state->mbs[mb_idx].pMBmessage->cs & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT)) && \
    c5aa:	2b04      	cmp	r3, #4
    c5ac:	d01c      	beq.n	c5e8 <FlexCAN_IRQHandlerRxMB+0x100>
    ((uint32)FLEXCAN_RX_OVERRUN != ((state->mbs[mb_idx].pMBmessage->cs & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT)))
    c5ae:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    c5b0:	9b02      	ldr	r3, [sp, #8]
    c5b2:	011b      	lsls	r3, r3, #4
    c5b4:	4413      	add	r3, r2
    c5b6:	681b      	ldr	r3, [r3, #0]
    c5b8:	681b      	ldr	r3, [r3, #0]
    c5ba:	0e1b      	lsrs	r3, r3, #24
    c5bc:	f003 030f 	and.w	r3, r3, #15
    ((uint32)FLEXCAN_RX_EMPTY != ((state->mbs[mb_idx].pMBmessage->cs & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT)) && \
    c5c0:	2b06      	cmp	r3, #6
    c5c2:	d011      	beq.n	c5e8 <FlexCAN_IRQHandlerRxMB+0x100>
    {
        /* Update the cs code for next sequence move in MB.
        A CPU write into the C/S word also unlocks the MB */
        volatile uint32 *flexcan_mb = FlexCAN_GetMsgBuffRegion(base, mb_idx);
    c5c4:	9902      	ldr	r1, [sp, #8]
    c5c6:	981c      	ldr	r0, [sp, #112]	; 0x70
    c5c8:	f002 f9a4 	bl	e914 <FlexCAN_GetMsgBuffRegion>
    c5cc:	9019      	str	r0, [sp, #100]	; 0x64
        *flexcan_mb &= ~FLEXCAN_IP_CS_CODE_MASK;
    c5ce:	9b19      	ldr	r3, [sp, #100]	; 0x64
    c5d0:	681b      	ldr	r3, [r3, #0]
    c5d2:	f023 6270 	bic.w	r2, r3, #251658240	; 0xf000000
    c5d6:	9b19      	ldr	r3, [sp, #100]	; 0x64
    c5d8:	601a      	str	r2, [r3, #0]
        *flexcan_mb |= (((uint32)FLEXCAN_RX_EMPTY) << FLEXCAN_IP_CS_CODE_SHIFT) & FLEXCAN_IP_CS_CODE_MASK;
    c5da:	9b19      	ldr	r3, [sp, #100]	; 0x64
    c5dc:	681b      	ldr	r3, [r3, #0]
    c5de:	f043 6280 	orr.w	r2, r3, #67108864	; 0x4000000
    c5e2:	9b19      	ldr	r3, [sp, #100]	; 0x64
    c5e4:	601a      	str	r2, [r3, #0]
    {
    c5e6:	e002      	b.n	c5ee <FlexCAN_IRQHandlerRxMB+0x106>
    }
    else
#endif
    {
    /* Unlock RX message buffer and RX FIFO*/
    FlexCAN_UnlockRxMsgBuff(base);
    c5e8:	981c      	ldr	r0, [sp, #112]	; 0x70
    c5ea:	f7ff faac 	bl	bb46 <FlexCAN_UnlockRxMsgBuff>
    }

#if (defined (ERR_IPV_FLEXCAN_E050246) || defined (ERR_IPV_FLEXCAN_E050630))
    /* To ensure that interrupts are resumed when they are suspended */
    if (TRUE == bIsCriticalSectionNeeded)
    c5ee:	f89d 3077 	ldrb.w	r3, [sp, #119]	; 0x77
    c5f2:	2b00      	cmp	r3, #0
    c5f4:	d000      	beq.n	c5f8 <FlexCAN_IRQHandlerRxMB+0x110>
    {
        /* Enable all IRQs */
        OsIf_ResumeAllInterrupts();
    c5f6:	b662      	cpsie	i
    }
#endif /* (defined(ERR_IPV_FLEXCAN_E050246) || defined(ERR_IPV_FLEXCAN_E050630)) */

    state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;
    c5f8:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    c5fa:	9b02      	ldr	r3, [sp, #8]
    c5fc:	011b      	lsls	r3, r3, #4
    c5fe:	4413      	add	r3, r2
    c600:	3304      	adds	r3, #4
    c602:	2200      	movs	r2, #0
    c604:	601a      	str	r2, [r3, #0]

    bCurrentIntStat = state->mbs[mb_idx].isPolling;
    c606:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    c608:	9b02      	ldr	r3, [sp, #8]
    c60a:	011b      	lsls	r3, r3, #4
    c60c:	4413      	add	r3, r2
    c60e:	3308      	adds	r3, #8
    c610:	781b      	ldrb	r3, [r3, #0]
    c612:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b

    /* Invoke callback */
    if (state->callback != NULL_PTR)
    c616:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    c618:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    c61c:	2b00      	cmp	r3, #0
    c61e:	d008      	beq.n	c632 <FlexCAN_IRQHandlerRxMB+0x14a>
    {
        state->callback(instance, FLEXCAN_EVENT_RX_COMPLETE, mb_idx, state);
    c620:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    c622:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    c626:	f89d 000f 	ldrb.w	r0, [sp, #15]
    c62a:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    c62c:	9a02      	ldr	r2, [sp, #8]
    c62e:	2100      	movs	r1, #0
    c630:	47a0      	blx	r4
    }

    if ((FLEXCAN_MB_IDLE == state->mbs[mb_idx].state) && (FALSE == state->mbs[mb_idx].isPolling))
    c632:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    c634:	9b02      	ldr	r3, [sp, #8]
    c636:	011b      	lsls	r3, r3, #4
    c638:	4413      	add	r3, r2
    c63a:	3304      	adds	r3, #4
    c63c:	681b      	ldr	r3, [r3, #0]
    c63e:	2b00      	cmp	r3, #0
    c640:	d11e      	bne.n	c680 <FlexCAN_IRQHandlerRxMB+0x198>
    c642:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    c644:	9b02      	ldr	r3, [sp, #8]
    c646:	011b      	lsls	r3, r3, #4
    c648:	4413      	add	r3, r2
    c64a:	3308      	adds	r3, #8
    c64c:	781b      	ldrb	r3, [r3, #0]
    c64e:	f083 0301 	eor.w	r3, r3, #1
    c652:	b2db      	uxtb	r3, r3
    c654:	2b00      	cmp	r3, #0
    c656:	d013      	beq.n	c680 <FlexCAN_IRQHandlerRxMB+0x198>
    {
        /* callback is not called, need to reset to default value */
        state->mbs[mb_idx].isPolling = TRUE;
    c658:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    c65a:	9b02      	ldr	r3, [sp, #8]
    c65c:	011b      	lsls	r3, r3, #4
    c65e:	4413      	add	r3, r2
    c660:	3308      	adds	r3, #8
    c662:	2201      	movs	r2, #1
    c664:	701a      	strb	r2, [r3, #0]
        /* Disable the transmitter data register empty interrupt for case: mb is interrupt (it was not use in above callback with the same index) */
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, mb_idx, FALSE, state->isIntActive);
    c666:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    c668:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    c66c:	f89d 100f 	ldrb.w	r1, [sp, #15]
    c670:	9300      	str	r3, [sp, #0]
    c672:	2300      	movs	r3, #0
    c674:	9a02      	ldr	r2, [sp, #8]
    c676:	981c      	ldr	r0, [sp, #112]	; 0x70
    c678:	f002 fcd4 	bl	f024 <FlexCAN_SetMsgBuffIntCmd>
    c67c:	bf00      	nop
    else
    {
        /* Prevent misra */
        /* When processing type change from POLL->POLL or INTERRUPT -> INTERRUPT(this Mb is used continously in callback), no need to disable interrupt in the ISR */
    }
}
    c67e:	e019      	b.n	c6b4 <FlexCAN_IRQHandlerRxMB+0x1cc>
    else if ((FALSE == bCurrentIntStat) && (TRUE == state->mbs[mb_idx].isPolling))
    c680:	f89d 306b 	ldrb.w	r3, [sp, #107]	; 0x6b
    c684:	f083 0301 	eor.w	r3, r3, #1
    c688:	b2db      	uxtb	r3, r3
    c68a:	2b00      	cmp	r3, #0
    c68c:	d012      	beq.n	c6b4 <FlexCAN_IRQHandlerRxMB+0x1cc>
    c68e:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    c690:	9b02      	ldr	r3, [sp, #8]
    c692:	011b      	lsls	r3, r3, #4
    c694:	4413      	add	r3, r2
    c696:	3308      	adds	r3, #8
    c698:	781b      	ldrb	r3, [r3, #0]
    c69a:	2b00      	cmp	r3, #0
    c69c:	d00a      	beq.n	c6b4 <FlexCAN_IRQHandlerRxMB+0x1cc>
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, mb_idx, FALSE, state->isIntActive);
    c69e:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    c6a0:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    c6a4:	f89d 100f 	ldrb.w	r1, [sp, #15]
    c6a8:	9300      	str	r3, [sp, #0]
    c6aa:	2300      	movs	r3, #0
    c6ac:	9a02      	ldr	r2, [sp, #8]
    c6ae:	981c      	ldr	r0, [sp, #112]	; 0x70
    c6b0:	f002 fcb8 	bl	f024 <FlexCAN_SetMsgBuffIntCmd>
}
    c6b4:	bf00      	nop
    c6b6:	b01e      	add	sp, #120	; 0x78
    c6b8:	bd10      	pop	{r4, pc}
    c6ba:	bf00      	nop
    c6bc:	000186d8 	.word	0x000186d8
    c6c0:	1fff9360 	.word	0x1fff9360

0000c6c4 <FlexCAN_IRQHandlerTxMB>:
 * note: just using in interrupt mode
 * This is not a public API as it is called whenever an interrupt and receive
 * individual MB occurs
 *END**************************************************************************/
static void FlexCAN_IRQHandlerTxMB(uint8 u8Instance, uint32 u32MbIdx)
{
    c6c4:	b510      	push	{r4, lr}
    c6c6:	b09a      	sub	sp, #104	; 0x68
    c6c8:	4603      	mov	r3, r0
    c6ca:	9102      	str	r1, [sp, #8]
    c6cc:	f88d 300f 	strb.w	r3, [sp, #15]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    c6d0:	f89d 300f 	ldrb.w	r3, [sp, #15]
    c6d4:	4a46      	ldr	r2, [pc, #280]	; (c7f0 <FlexCAN_IRQHandlerTxMB+0x12c>)
    c6d6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c6da:	9319      	str	r3, [sp, #100]	; 0x64
    Flexcan_Ip_StateType * pState = Flexcan_Ip_apxState[u8Instance];
    c6dc:	f89d 300f 	ldrb.w	r3, [sp, #15]
    c6e0:	4a44      	ldr	r2, [pc, #272]	; (c7f4 <FlexCAN_IRQHandlerTxMB+0x130>)
    c6e2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c6e6:	9318      	str	r3, [sp, #96]	; 0x60
    Flexcan_Ip_MsgBuffType mb;
    mb.cs = 0U;
    c6e8:	2300      	movs	r3, #0
    c6ea:	9304      	str	r3, [sp, #16]
    mb.time_stamp = 0U;
    c6ec:	2300      	movs	r3, #0
    c6ee:	9317      	str	r3, [sp, #92]	; 0x5c
    if (pState->mbs[u32MbIdx].isRemote)
    c6f0:	9a18      	ldr	r2, [sp, #96]	; 0x60
    c6f2:	9b02      	ldr	r3, [sp, #8]
    c6f4:	011b      	lsls	r3, r3, #4
    c6f6:	4413      	add	r3, r2
    c6f8:	3309      	adds	r3, #9
    c6fa:	781b      	ldrb	r3, [r3, #0]
    c6fc:	2b00      	cmp	r3, #0
    c6fe:	d01e      	beq.n	c73e <FlexCAN_IRQHandlerTxMB+0x7a>
    {
        FlexCAN_LockRxMsgBuff(pBase, u32MbIdx);
    c700:	9902      	ldr	r1, [sp, #8]
    c702:	9819      	ldr	r0, [sp, #100]	; 0x64
    c704:	f002 fc7f 	bl	f006 <FlexCAN_LockRxMsgBuff>
        FlexCAN_GetMsgBuff(pBase, u32MbIdx, &mb);
    c708:	ab04      	add	r3, sp, #16
    c70a:	461a      	mov	r2, r3
    c70c:	9902      	ldr	r1, [sp, #8]
    c70e:	9819      	ldr	r0, [sp, #100]	; 0x64
    c710:	f002 fda8 	bl	f264 <FlexCAN_GetMsgBuff>
        FlexCAN_UnlockRxMsgBuff(pBase);
    c714:	9819      	ldr	r0, [sp, #100]	; 0x64
    c716:	f7ff fa16 	bl	bb46 <FlexCAN_UnlockRxMsgBuff>
        pState->mbs[u32MbIdx].time_stamp = mb.time_stamp;
    c71a:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    c71c:	9918      	ldr	r1, [sp, #96]	; 0x60
    c71e:	9b02      	ldr	r3, [sp, #8]
    c720:	011b      	lsls	r3, r3, #4
    c722:	440b      	add	r3, r1
    c724:	330c      	adds	r3, #12
    c726:	601a      	str	r2, [r3, #0]
        /* If the frame was a remote frame, clear the flag only if the response was
        * not received yet. If the response was received, leave the flag set in order
        * to be handled when the user calls FLEXCAN_DRV_RxMessageBuffer. */
        if ((uint32)FLEXCAN_RX_EMPTY == ((mb.cs & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT))
    c728:	9b04      	ldr	r3, [sp, #16]
    c72a:	0e1b      	lsrs	r3, r3, #24
    c72c:	f003 030f 	and.w	r3, r3, #15
    c730:	2b04      	cmp	r3, #4
    c732:	d116      	bne.n	c762 <FlexCAN_IRQHandlerTxMB+0x9e>
        {
            FlexCAN_ClearMsgBuffIntStatusFlag(pBase, u32MbIdx);
    c734:	9902      	ldr	r1, [sp, #8]
    c736:	9819      	ldr	r0, [sp, #100]	; 0x64
    c738:	f7ff fa0c 	bl	bb54 <FlexCAN_ClearMsgBuffIntStatusFlag>
    c73c:	e011      	b.n	c762 <FlexCAN_IRQHandlerTxMB+0x9e>
        }
    }
    else
    {
        pState->mbs[u32MbIdx].time_stamp = FlexCAN_GetMsgBuffTimestamp(pBase, u32MbIdx);
    c73e:	9902      	ldr	r1, [sp, #8]
    c740:	9819      	ldr	r0, [sp, #100]	; 0x64
    c742:	f002 fd7b 	bl	f23c <FlexCAN_GetMsgBuffTimestamp>
    c746:	4601      	mov	r1, r0
    c748:	9a18      	ldr	r2, [sp, #96]	; 0x60
    c74a:	9b02      	ldr	r3, [sp, #8]
    c74c:	011b      	lsls	r3, r3, #4
    c74e:	4413      	add	r3, r2
    c750:	330c      	adds	r3, #12
    c752:	6019      	str	r1, [r3, #0]
        FlexCAN_UnlockRxMsgBuff(pBase);
    c754:	9819      	ldr	r0, [sp, #100]	; 0x64
    c756:	f7ff f9f6 	bl	bb46 <FlexCAN_UnlockRxMsgBuff>
        FlexCAN_ClearMsgBuffIntStatusFlag(pBase, u32MbIdx);
    c75a:	9902      	ldr	r1, [sp, #8]
    c75c:	9819      	ldr	r0, [sp, #100]	; 0x64
    c75e:	f7ff f9f9 	bl	bb54 <FlexCAN_ClearMsgBuffIntStatusFlag>
    }

    pState->mbs[u32MbIdx].state = FLEXCAN_MB_IDLE;
    c762:	9a18      	ldr	r2, [sp, #96]	; 0x60
    c764:	9b02      	ldr	r3, [sp, #8]
    c766:	011b      	lsls	r3, r3, #4
    c768:	4413      	add	r3, r2
    c76a:	3304      	adds	r3, #4
    c76c:	2200      	movs	r2, #0
    c76e:	601a      	str	r2, [r3, #0]

    /* Invoke callback */
    if (pState->callback != NULL_PTR)
    c770:	9b18      	ldr	r3, [sp, #96]	; 0x60
    c772:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    c776:	2b00      	cmp	r3, #0
    c778:	d008      	beq.n	c78c <FlexCAN_IRQHandlerTxMB+0xc8>
    {
        pState->callback(u8Instance, FLEXCAN_EVENT_TX_COMPLETE, u32MbIdx, pState);
    c77a:	9b18      	ldr	r3, [sp, #96]	; 0x60
    c77c:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    c780:	f89d 000f 	ldrb.w	r0, [sp, #15]
    c784:	9b18      	ldr	r3, [sp, #96]	; 0x60
    c786:	9a02      	ldr	r2, [sp, #8]
    c788:	2104      	movs	r1, #4
    c78a:	47a0      	blx	r4
    }

    if (FLEXCAN_MB_IDLE == pState->mbs[u32MbIdx].state)
    c78c:	9a18      	ldr	r2, [sp, #96]	; 0x60
    c78e:	9b02      	ldr	r3, [sp, #8]
    c790:	011b      	lsls	r3, r3, #4
    c792:	4413      	add	r3, r2
    c794:	3304      	adds	r3, #4
    c796:	681b      	ldr	r3, [r3, #0]
    c798:	2b00      	cmp	r3, #0
    c79a:	d112      	bne.n	c7c2 <FlexCAN_IRQHandlerTxMB+0xfe>
    {
        /* callback is not called, need to reset to default value */
        pState->mbs[u32MbIdx].isPolling = TRUE;
    c79c:	9a18      	ldr	r2, [sp, #96]	; 0x60
    c79e:	9b02      	ldr	r3, [sp, #8]
    c7a0:	011b      	lsls	r3, r3, #4
    c7a2:	4413      	add	r3, r2
    c7a4:	3308      	adds	r3, #8
    c7a6:	2201      	movs	r2, #1
    c7a8:	701a      	strb	r2, [r3, #0]
        /* Disable the transmitter data register empty interrupt for case: mb is interrupt (it was not use in above callback with the same index) */
        (void)FlexCAN_SetMsgBuffIntCmd(pBase, u8Instance, u32MbIdx, FALSE, pState->isIntActive);
    c7aa:	9b18      	ldr	r3, [sp, #96]	; 0x60
    c7ac:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    c7b0:	f89d 100f 	ldrb.w	r1, [sp, #15]
    c7b4:	9300      	str	r3, [sp, #0]
    c7b6:	2300      	movs	r3, #0
    c7b8:	9a02      	ldr	r2, [sp, #8]
    c7ba:	9819      	ldr	r0, [sp, #100]	; 0x64
    c7bc:	f002 fc32 	bl	f024 <FlexCAN_SetMsgBuffIntCmd>
    else
    {
        /* Prevent misra */
        /* When processing type change from POLL->POLL or INTERRUPT -> INTERRUPT(this Mb is used continously in callback), no need to disable interrupt in the ISR */
    }
}
    c7c0:	e012      	b.n	c7e8 <FlexCAN_IRQHandlerTxMB+0x124>
    else if (TRUE == pState->mbs[u32MbIdx].isPolling)
    c7c2:	9a18      	ldr	r2, [sp, #96]	; 0x60
    c7c4:	9b02      	ldr	r3, [sp, #8]
    c7c6:	011b      	lsls	r3, r3, #4
    c7c8:	4413      	add	r3, r2
    c7ca:	3308      	adds	r3, #8
    c7cc:	781b      	ldrb	r3, [r3, #0]
    c7ce:	2b00      	cmp	r3, #0
    c7d0:	d00a      	beq.n	c7e8 <FlexCAN_IRQHandlerTxMB+0x124>
        (void)FlexCAN_SetMsgBuffIntCmd(pBase, u8Instance, u32MbIdx, FALSE, pState->isIntActive);
    c7d2:	9b18      	ldr	r3, [sp, #96]	; 0x60
    c7d4:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    c7d8:	f89d 100f 	ldrb.w	r1, [sp, #15]
    c7dc:	9300      	str	r3, [sp, #0]
    c7de:	2300      	movs	r3, #0
    c7e0:	9a02      	ldr	r2, [sp, #8]
    c7e2:	9819      	ldr	r0, [sp, #100]	; 0x64
    c7e4:	f002 fc1e 	bl	f024 <FlexCAN_SetMsgBuffIntCmd>
}
    c7e8:	bf00      	nop
    c7ea:	b01a      	add	sp, #104	; 0x68
    c7ec:	bd10      	pop	{r4, pc}
    c7ee:	bf00      	nop
    c7f0:	000186d8 	.word	0x000186d8
    c7f4:	1fff9360 	.word	0x1fff9360

0000c7f8 <FlexCAN_IRQHandlerRxFIFO>:
 * Function Name : FlexCAN_IRQHandlerRxFIFO
 * Description   : Process IRQHandler in case of RxFIFO mode selection for CAN interface.
 *
 *END**************************************************************************/
static inline void FlexCAN_IRQHandlerRxFIFO(uint8 instance, uint32 mb_idx)
{
    c7f8:	b510      	push	{r4, lr}
    c7fa:	b098      	sub	sp, #96	; 0x60
    c7fc:	4603      	mov	r3, r0
    c7fe:	9100      	str	r1, [sp, #0]
    c800:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    c804:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c808:	4a3c      	ldr	r2, [pc, #240]	; (c8fc <FlexCAN_IRQHandlerRxFIFO+0x104>)
    c80a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c80e:	9317      	str	r3, [sp, #92]	; 0x5c
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    c810:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c814:	4a3a      	ldr	r2, [pc, #232]	; (c900 <FlexCAN_IRQHandlerRxFIFO+0x108>)
    c816:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c81a:	9316      	str	r3, [sp, #88]	; 0x58
    Flexcan_Ip_MsgBuffType data;

    /* If use pass NULL_PTR, they can get data in callback function by getting state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].pMBmessage  */
    if (NULL_PTR == state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].pMBmessage)
    c81c:	9b16      	ldr	r3, [sp, #88]	; 0x58
    c81e:	681b      	ldr	r3, [r3, #0]
    c820:	2b00      	cmp	r3, #0
    c822:	d102      	bne.n	c82a <FlexCAN_IRQHandlerRxFIFO+0x32>
    {
        state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].pMBmessage = &data;
    c824:	9b16      	ldr	r3, [sp, #88]	; 0x58
    c826:	aa02      	add	r2, sp, #8
    c828:	601a      	str	r2, [r3, #0]
    }
    switch (mb_idx)
    c82a:	9b00      	ldr	r3, [sp, #0]
    c82c:	2b07      	cmp	r3, #7
    c82e:	d048      	beq.n	c8c2 <FlexCAN_IRQHandlerRxFIFO+0xca>
    c830:	9b00      	ldr	r3, [sp, #0]
    c832:	2b07      	cmp	r3, #7
    c834:	d858      	bhi.n	c8e8 <FlexCAN_IRQHandlerRxFIFO+0xf0>
    c836:	9b00      	ldr	r3, [sp, #0]
    c838:	2b05      	cmp	r3, #5
    c83a:	d003      	beq.n	c844 <FlexCAN_IRQHandlerRxFIFO+0x4c>
    c83c:	9b00      	ldr	r3, [sp, #0]
    c83e:	2b06      	cmp	r3, #6
    c840:	d02c      	beq.n	c89c <FlexCAN_IRQHandlerRxFIFO+0xa4>
            }

            break;
        default:
            /* Do Nothing */
            break;
    c842:	e051      	b.n	c8e8 <FlexCAN_IRQHandlerRxFIFO+0xf0>
            if (FLEXCAN_MB_RX_BUSY == state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state)
    c844:	9b16      	ldr	r3, [sp, #88]	; 0x58
    c846:	685b      	ldr	r3, [r3, #4]
    c848:	2b01      	cmp	r3, #1
    c84a:	d14f      	bne.n	c8ec <FlexCAN_IRQHandlerRxFIFO+0xf4>
                FlexCAN_ReadRxFifo(base, state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].pMBmessage);
    c84c:	9b16      	ldr	r3, [sp, #88]	; 0x58
    c84e:	681b      	ldr	r3, [r3, #0]
    c850:	4619      	mov	r1, r3
    c852:	9817      	ldr	r0, [sp, #92]	; 0x5c
    c854:	f003 f98d 	bl	fb72 <FlexCAN_ReadRxFifo>
                FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    c858:	9900      	ldr	r1, [sp, #0]
    c85a:	9817      	ldr	r0, [sp, #92]	; 0x5c
    c85c:	f7ff f97a 	bl	bb54 <FlexCAN_ClearMsgBuffIntStatusFlag>
                state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state = FLEXCAN_MB_IDLE;
    c860:	9b16      	ldr	r3, [sp, #88]	; 0x58
    c862:	2200      	movs	r2, #0
    c864:	605a      	str	r2, [r3, #4]
                if (state->callback != NULL_PTR)
    c866:	9b16      	ldr	r3, [sp, #88]	; 0x58
    c868:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    c86c:	2b00      	cmp	r3, #0
    c86e:	d008      	beq.n	c882 <FlexCAN_IRQHandlerRxFIFO+0x8a>
                    state->callback(instance, FLEXCAN_EVENT_RXFIFO_COMPLETE, FLEXCAN_IP_MB_HANDLE_RXFIFO, state);
    c870:	9b16      	ldr	r3, [sp, #88]	; 0x58
    c872:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    c876:	f89d 0007 	ldrb.w	r0, [sp, #7]
    c87a:	9b16      	ldr	r3, [sp, #88]	; 0x58
    c87c:	2200      	movs	r2, #0
    c87e:	2101      	movs	r1, #1
    c880:	47a0      	blx	r4
                if (FLEXCAN_MB_IDLE == state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state)
    c882:	9b16      	ldr	r3, [sp, #88]	; 0x58
    c884:	685b      	ldr	r3, [r3, #4]
    c886:	2b00      	cmp	r3, #0
    c888:	d130      	bne.n	c8ec <FlexCAN_IRQHandlerRxFIFO+0xf4>
                    state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].isPolling = TRUE;
    c88a:	9b16      	ldr	r3, [sp, #88]	; 0x58
    c88c:	2201      	movs	r2, #1
    c88e:	721a      	strb	r2, [r3, #8]
                    FlexCAN_CompleteRxMessageFifoData(instance);
    c890:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c894:	4618      	mov	r0, r3
    c896:	f000 fc61 	bl	d15c <FlexCAN_CompleteRxMessageFifoData>
            break;
    c89a:	e027      	b.n	c8ec <FlexCAN_IRQHandlerRxFIFO+0xf4>
            FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    c89c:	9900      	ldr	r1, [sp, #0]
    c89e:	9817      	ldr	r0, [sp, #92]	; 0x5c
    c8a0:	f7ff f958 	bl	bb54 <FlexCAN_ClearMsgBuffIntStatusFlag>
            if (state->callback != NULL_PTR)
    c8a4:	9b16      	ldr	r3, [sp, #88]	; 0x58
    c8a6:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    c8aa:	2b00      	cmp	r3, #0
    c8ac:	d020      	beq.n	c8f0 <FlexCAN_IRQHandlerRxFIFO+0xf8>
                state->callback(instance, FLEXCAN_EVENT_RXFIFO_WARNING, FLEXCAN_IP_MB_HANDLE_RXFIFO, state);
    c8ae:	9b16      	ldr	r3, [sp, #88]	; 0x58
    c8b0:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    c8b4:	f89d 0007 	ldrb.w	r0, [sp, #7]
    c8b8:	9b16      	ldr	r3, [sp, #88]	; 0x58
    c8ba:	2200      	movs	r2, #0
    c8bc:	2102      	movs	r1, #2
    c8be:	47a0      	blx	r4
            break;
    c8c0:	e016      	b.n	c8f0 <FlexCAN_IRQHandlerRxFIFO+0xf8>
            FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    c8c2:	9900      	ldr	r1, [sp, #0]
    c8c4:	9817      	ldr	r0, [sp, #92]	; 0x5c
    c8c6:	f7ff f945 	bl	bb54 <FlexCAN_ClearMsgBuffIntStatusFlag>
            if (state->callback != NULL_PTR)
    c8ca:	9b16      	ldr	r3, [sp, #88]	; 0x58
    c8cc:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    c8d0:	2b00      	cmp	r3, #0
    c8d2:	d00f      	beq.n	c8f4 <FlexCAN_IRQHandlerRxFIFO+0xfc>
                state->callback(instance, FLEXCAN_EVENT_RXFIFO_OVERFLOW, FLEXCAN_IP_MB_HANDLE_RXFIFO, state);
    c8d4:	9b16      	ldr	r3, [sp, #88]	; 0x58
    c8d6:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    c8da:	f89d 0007 	ldrb.w	r0, [sp, #7]
    c8de:	9b16      	ldr	r3, [sp, #88]	; 0x58
    c8e0:	2200      	movs	r2, #0
    c8e2:	2103      	movs	r1, #3
    c8e4:	47a0      	blx	r4
            break;
    c8e6:	e005      	b.n	c8f4 <FlexCAN_IRQHandlerRxFIFO+0xfc>
            break;
    c8e8:	bf00      	nop
    c8ea:	e004      	b.n	c8f6 <FlexCAN_IRQHandlerRxFIFO+0xfe>
            break;
    c8ec:	bf00      	nop
    c8ee:	e002      	b.n	c8f6 <FlexCAN_IRQHandlerRxFIFO+0xfe>
            break;
    c8f0:	bf00      	nop
    c8f2:	e000      	b.n	c8f6 <FlexCAN_IRQHandlerRxFIFO+0xfe>
            break;
    c8f4:	bf00      	nop
    }
}
    c8f6:	bf00      	nop
    c8f8:	b018      	add	sp, #96	; 0x60
    c8fa:	bd10      	pop	{r4, pc}
    c8fc:	000186d8 	.word	0x000186d8
    c900:	1fff9360 	.word	0x1fff9360

0000c904 <FlexCAN_AbortTxTransfer>:
 * Description   : Abort transfer for Tx buffer.
 *
 * This is not a public API as it is called from other driver functions.
 *END**************************************************************************/
static Flexcan_Ip_StatusType FlexCAN_AbortTxTransfer(uint8 u8Instance, uint8 mb_idx)
{
    c904:	b500      	push	{lr}
    c906:	b08b      	sub	sp, #44	; 0x2c
    c908:	4603      	mov	r3, r0
    c90a:	460a      	mov	r2, r1
    c90c:	f88d 3007 	strb.w	r3, [sp, #7]
    c910:	4613      	mov	r3, r2
    c912:	f88d 3006 	strb.w	r3, [sp, #6]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    c916:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c91a:	4a3c      	ldr	r2, [pc, #240]	; (ca0c <FlexCAN_AbortTxTransfer+0x108>)
    c91c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c920:	9307      	str	r3, [sp, #28]
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[u8Instance];
    c922:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c926:	4a3a      	ldr	r2, [pc, #232]	; (ca10 <FlexCAN_AbortTxTransfer+0x10c>)
    c928:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c92c:	9306      	str	r3, [sp, #24]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    c92e:	2300      	movs	r3, #0
    c930:	9309      	str	r3, [sp, #36]	; 0x24

    uint32 timeStart = 0U;
    c932:	2300      	movs	r3, #0
    c934:	9302      	str	r3, [sp, #8]
    uint32 timeElapsed = 0U;
    c936:	2300      	movs	r3, #0
    c938:	9308      	str	r3, [sp, #32]
    uint32 flexcan_mb_config = 0;
    c93a:	2300      	movs	r3, #0
    c93c:	9305      	str	r3, [sp, #20]
    uint32 uS2Ticks = 0U;
    c93e:	2300      	movs	r3, #0
    c940:	9304      	str	r3, [sp, #16]
    volatile uint32 * flexcan_mb = NULL_PTR;
    c942:	2300      	movs	r3, #0
    c944:	9303      	str	r3, [sp, #12]

    flexcan_mb = FlexCAN_GetMsgBuffRegion(pBase, mb_idx);
    c946:	f89d 3006 	ldrb.w	r3, [sp, #6]
    c94a:	4619      	mov	r1, r3
    c94c:	9807      	ldr	r0, [sp, #28]
    c94e:	f001 ffe1 	bl	e914 <FlexCAN_GetMsgBuffRegion>
    c952:	9003      	str	r0, [sp, #12]
    flexcan_mb_config = * flexcan_mb;
    c954:	9b03      	ldr	r3, [sp, #12]
    c956:	681b      	ldr	r3, [r3, #0]
    c958:	9305      	str	r3, [sp, #20]
    /* Reset the code */
    flexcan_mb_config &= (~FLEXCAN_IP_CS_CODE_MASK);
    c95a:	9b05      	ldr	r3, [sp, #20]
    c95c:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    c960:	9305      	str	r3, [sp, #20]
    flexcan_mb_config |= (uint32)(((uint32)FLEXCAN_TX_ABORT & (uint32)0x1F) << (uint8)FLEXCAN_IP_CS_CODE_SHIFT) & (uint32)FLEXCAN_IP_CS_CODE_MASK;
    c962:	9b05      	ldr	r3, [sp, #20]
    c964:	f043 6310 	orr.w	r3, r3, #150994944	; 0x9000000
    c968:	9305      	str	r3, [sp, #20]
    *flexcan_mb = flexcan_mb_config;
    c96a:	9b03      	ldr	r3, [sp, #12]
    c96c:	9a05      	ldr	r2, [sp, #20]
    c96e:	601a      	str	r2, [r3, #0]

    /* Wait to finish abort operation */
    uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    c970:	2100      	movs	r1, #0
    c972:	4828      	ldr	r0, [pc, #160]	; (ca14 <FlexCAN_AbortTxTransfer+0x110>)
    c974:	f7f5 fb26 	bl	1fc4 <OsIf_MicrosToTicks>
    c978:	9004      	str	r0, [sp, #16]
    timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    c97a:	2000      	movs	r0, #0
    c97c:	f7f5 fad6 	bl	1f2c <OsIf_GetCounter>
    c980:	4603      	mov	r3, r0
    c982:	9302      	str	r3, [sp, #8]
    while (0U == FlexCAN_GetBuffStatusFlag(pBase, mb_idx))
    c984:	e00f      	b.n	c9a6 <FlexCAN_AbortTxTransfer+0xa2>
    {
        timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    c986:	ab02      	add	r3, sp, #8
    c988:	2100      	movs	r1, #0
    c98a:	4618      	mov	r0, r3
    c98c:	f7f5 fae7 	bl	1f5e <OsIf_GetElapsed>
    c990:	4602      	mov	r2, r0
    c992:	9b08      	ldr	r3, [sp, #32]
    c994:	4413      	add	r3, r2
    c996:	9308      	str	r3, [sp, #32]
        if (timeElapsed >= uS2Ticks)
    c998:	9a08      	ldr	r2, [sp, #32]
    c99a:	9b04      	ldr	r3, [sp, #16]
    c99c:	429a      	cmp	r2, r3
    c99e:	d302      	bcc.n	c9a6 <FlexCAN_AbortTxTransfer+0xa2>
        {
            result = FLEXCAN_STATUS_TIMEOUT;
    c9a0:	2303      	movs	r3, #3
    c9a2:	9309      	str	r3, [sp, #36]	; 0x24
            break;
    c9a4:	e008      	b.n	c9b8 <FlexCAN_AbortTxTransfer+0xb4>
    while (0U == FlexCAN_GetBuffStatusFlag(pBase, mb_idx))
    c9a6:	f89d 3006 	ldrb.w	r3, [sp, #6]
    c9aa:	4619      	mov	r1, r3
    c9ac:	9807      	ldr	r0, [sp, #28]
    c9ae:	f7ff f8e4 	bl	bb7a <FlexCAN_GetBuffStatusFlag>
    c9b2:	4603      	mov	r3, r0
    c9b4:	2b00      	cmp	r3, #0
    c9b6:	d0e6      	beq.n	c986 <FlexCAN_AbortTxTransfer+0x82>
        }
    }
    if (result != FLEXCAN_STATUS_TIMEOUT)
    c9b8:	9b09      	ldr	r3, [sp, #36]	; 0x24
    c9ba:	2b03      	cmp	r3, #3
    c9bc:	d012      	beq.n	c9e4 <FlexCAN_AbortTxTransfer+0xe0>
    {
        flexcan_mb_config = *flexcan_mb;
    c9be:	9b03      	ldr	r3, [sp, #12]
    c9c0:	681b      	ldr	r3, [r3, #0]
    c9c2:	9305      	str	r3, [sp, #20]
        /* Check if the MBs have been safely Inactivated */
        if ((uint32)FLEXCAN_TX_INACTIVE == ((flexcan_mb_config & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT))
    c9c4:	9b05      	ldr	r3, [sp, #20]
    c9c6:	0e1b      	lsrs	r3, r3, #24
    c9c8:	f003 030f 	and.w	r3, r3, #15
    c9cc:	2b08      	cmp	r3, #8
    c9ce:	d101      	bne.n	c9d4 <FlexCAN_AbortTxTransfer+0xd0>
        {
            /* Transmission have occurred */
            result = FLEXCAN_STATUS_NO_TRANSFER_IN_PROGRESS;
    c9d0:	2305      	movs	r3, #5
    c9d2:	9309      	str	r3, [sp, #36]	; 0x24
        }

        if ((uint32)FLEXCAN_TX_ABORT == ((flexcan_mb_config & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT))
    c9d4:	9b05      	ldr	r3, [sp, #20]
    c9d6:	0e1b      	lsrs	r3, r3, #24
    c9d8:	f003 030f 	and.w	r3, r3, #15
    c9dc:	2b09      	cmp	r3, #9
    c9de:	d101      	bne.n	c9e4 <FlexCAN_AbortTxTransfer+0xe0>
        {
            /* Transmission have been aborted */
            result = FLEXCAN_STATUS_SUCCESS;
    c9e0:	2300      	movs	r3, #0
    c9e2:	9309      	str	r3, [sp, #36]	; 0x24
        }
    }
    /* Clear message buffer flag */
    FlexCAN_ClearMsgBuffIntStatusFlag(pBase, mb_idx);
    c9e4:	f89d 3006 	ldrb.w	r3, [sp, #6]
    c9e8:	4619      	mov	r1, r3
    c9ea:	9807      	ldr	r0, [sp, #28]
    c9ec:	f7ff f8b2 	bl	bb54 <FlexCAN_ClearMsgBuffIntStatusFlag>
    state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;
    c9f0:	f89d 3006 	ldrb.w	r3, [sp, #6]
    c9f4:	9a06      	ldr	r2, [sp, #24]
    c9f6:	011b      	lsls	r3, r3, #4
    c9f8:	4413      	add	r3, r2
    c9fa:	3304      	adds	r3, #4
    c9fc:	2200      	movs	r2, #0
    c9fe:	601a      	str	r2, [r3, #0]

    return result;
    ca00:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    ca02:	4618      	mov	r0, r3
    ca04:	b00b      	add	sp, #44	; 0x2c
    ca06:	f85d fb04 	ldr.w	pc, [sp], #4
    ca0a:	bf00      	nop
    ca0c:	000186d8 	.word	0x000186d8
    ca10:	1fff9360 	.word	0x1fff9360
    ca14:	000f4240 	.word	0x000f4240

0000ca18 <FlexCAN_AbortRxTransfer>:
 * Description   : Abort transfer for Rx normal or legacy fifo if enabled.
 *
 * This is not a public API as it is called from other driver functions.
 *END**************************************************************************/
static void FlexCAN_AbortRxTransfer(uint8 u8Instance, uint8 mb_idx)
{
    ca18:	b500      	push	{lr}
    ca1a:	b089      	sub	sp, #36	; 0x24
    ca1c:	4603      	mov	r3, r0
    ca1e:	460a      	mov	r2, r1
    ca20:	f88d 3007 	strb.w	r3, [sp, #7]
    ca24:	4613      	mov	r3, r2
    ca26:	f88d 3006 	strb.w	r3, [sp, #6]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    ca2a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    ca2e:	4a41      	ldr	r2, [pc, #260]	; (cb34 <FlexCAN_AbortRxTransfer+0x11c>)
    ca30:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ca34:	9307      	str	r3, [sp, #28]
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[u8Instance];
    ca36:	f89d 3007 	ldrb.w	r3, [sp, #7]
    ca3a:	4a3f      	ldr	r2, [pc, #252]	; (cb38 <FlexCAN_AbortRxTransfer+0x120>)
    ca3c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ca40:	9306      	str	r3, [sp, #24]
    uint8 val1 = 0U;
    ca42:	2300      	movs	r3, #0
    ca44:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32 val2 = 0U;
    ca48:	2300      	movs	r3, #0
    ca4a:	9304      	str	r3, [sp, #16]
    uint32 flexcan_mb_config = 0;
    ca4c:	2300      	movs	r3, #0
    ca4e:	9303      	str	r3, [sp, #12]
    volatile uint32 * flexcan_mb = NULL_PTR;
    ca50:	2300      	movs	r3, #0
    ca52:	9302      	str	r3, [sp, #8]

    state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;
    ca54:	f89d 3006 	ldrb.w	r3, [sp, #6]
    ca58:	9a06      	ldr	r2, [sp, #24]
    ca5a:	011b      	lsls	r3, r3, #4
    ca5c:	4413      	add	r3, r2
    ca5e:	3304      	adds	r3, #4
    ca60:	2200      	movs	r2, #0
    ca62:	601a      	str	r2, [r3, #0]
    /* Check if fifo enabled */
    if (TRUE == state->bIsLegacyFifoEn)
    ca64:	9b06      	ldr	r3, [sp, #24]
    ca66:	f893 3214 	ldrb.w	r3, [r3, #532]	; 0x214
    ca6a:	2b00      	cmp	r3, #0
    ca6c:	d03c      	beq.n	cae8 <FlexCAN_AbortRxTransfer+0xd0>
    {
        /* Get the number of RX FIFO Filters*/
        val1 = (uint8)(((pBase->CTRL2) & FLEXCAN_CTRL2_RFFN_MASK) >> FLEXCAN_CTRL2_RFFN_SHIFT);
    ca6e:	9b07      	ldr	r3, [sp, #28]
    ca70:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    ca72:	0e1b      	lsrs	r3, r3, #24
    ca74:	b2db      	uxtb	r3, r3
    ca76:	f003 030f 	and.w	r3, r3, #15
    ca7a:	f88d 3017 	strb.w	r3, [sp, #23]
        /* Get the number if MBs occupied by RX FIFO and ID filter table*/
        /* the Rx FIFO occupies the memory space originally reserved for MB0-5*/
        /* Every number of RFFN means 8 number of RX FIFO filters*/
        /* and every 4 number of RX FIFO filters occupied one MB*/
        val2 = RxFifoOcuppiedLastMsgBuff(val1);
    ca7e:	f89d 3017 	ldrb.w	r3, [sp, #23]
    ca82:	4618      	mov	r0, r3
    ca84:	f7ff f9f3 	bl	be6e <RxFifoOcuppiedLastMsgBuff>
    ca88:	9004      	str	r0, [sp, #16]
        if (mb_idx > val2)
    ca8a:	f89d 3006 	ldrb.w	r3, [sp, #6]
    ca8e:	9a04      	ldr	r2, [sp, #16]
    ca90:	429a      	cmp	r2, r3
    ca92:	d21b      	bcs.n	cacc <FlexCAN_AbortRxTransfer+0xb4>
        {
            /* This operation is not allowed for MB that are part of RxFIFO */
            flexcan_mb = FlexCAN_GetMsgBuffRegion(pBase, mb_idx);
    ca94:	f89d 3006 	ldrb.w	r3, [sp, #6]
    ca98:	4619      	mov	r1, r3
    ca9a:	9807      	ldr	r0, [sp, #28]
    ca9c:	f001 ff3a 	bl	e914 <FlexCAN_GetMsgBuffRegion>
    caa0:	9002      	str	r0, [sp, #8]
            flexcan_mb_config = * flexcan_mb;
    caa2:	9b02      	ldr	r3, [sp, #8]
    caa4:	681b      	ldr	r3, [r3, #0]
    caa6:	9303      	str	r3, [sp, #12]
            /* Reset the code and unlock the MB */
            flexcan_mb_config &= (uint32)(~FLEXCAN_IP_CS_CODE_MASK);
    caa8:	9b03      	ldr	r3, [sp, #12]
    caaa:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    caae:	9303      	str	r3, [sp, #12]
            flexcan_mb_config |= (uint32)(((uint32)FLEXCAN_RX_INACTIVE & (uint32)0x1F) << (uint8)FLEXCAN_IP_CS_CODE_SHIFT) & (uint32)FLEXCAN_IP_CS_CODE_MASK;
            *flexcan_mb = flexcan_mb_config;
    cab0:	9b02      	ldr	r3, [sp, #8]
    cab2:	9a03      	ldr	r2, [sp, #12]
    cab4:	601a      	str	r2, [r3, #0]
            /* Reconfigure The MB as left by RxMBconfig */
            flexcan_mb_config &= (~FLEXCAN_IP_CS_CODE_MASK);
    cab6:	9b03      	ldr	r3, [sp, #12]
    cab8:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    cabc:	9303      	str	r3, [sp, #12]
            flexcan_mb_config |= (uint32)(((uint32)FLEXCAN_RX_EMPTY & (uint32)0x1F) << (uint8)FLEXCAN_IP_CS_CODE_SHIFT) & (uint32)FLEXCAN_IP_CS_CODE_MASK;
    cabe:	9b03      	ldr	r3, [sp, #12]
    cac0:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
    cac4:	9303      	str	r3, [sp, #12]
            *flexcan_mb = flexcan_mb_config;
    cac6:	9b02      	ldr	r3, [sp, #8]
    cac8:	9a03      	ldr	r2, [sp, #12]
    caca:	601a      	str	r2, [r3, #0]
        }
        if (FLEXCAN_IP_MB_HANDLE_RXFIFO == mb_idx)
    cacc:	f89d 3006 	ldrb.w	r3, [sp, #6]
    cad0:	2b00      	cmp	r3, #0
    cad2:	d125      	bne.n	cb20 <FlexCAN_AbortRxTransfer+0x108>
        {
            FLEXCAN_ClearMsgBuffIntCmd(pBase, u8Instance, FLEXCAN_IP_LEGACY_RXFIFO_FRAME_AVAILABLE, state->isIntActive);
    cad4:	9b06      	ldr	r3, [sp, #24]
    cad6:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    cada:	f89d 1007 	ldrb.w	r1, [sp, #7]
    cade:	2205      	movs	r2, #5
    cae0:	9807      	ldr	r0, [sp, #28]
    cae2:	f002 faf5 	bl	f0d0 <FLEXCAN_ClearMsgBuffIntCmd>
    cae6:	e01b      	b.n	cb20 <FlexCAN_AbortRxTransfer+0x108>
        }
    }
    else
    {
        /* This operation is not allowed for MB that are part of RxFIFO */
        flexcan_mb = FlexCAN_GetMsgBuffRegion(pBase, mb_idx);
    cae8:	f89d 3006 	ldrb.w	r3, [sp, #6]
    caec:	4619      	mov	r1, r3
    caee:	9807      	ldr	r0, [sp, #28]
    caf0:	f001 ff10 	bl	e914 <FlexCAN_GetMsgBuffRegion>
    caf4:	9002      	str	r0, [sp, #8]
        flexcan_mb_config = * flexcan_mb;
    caf6:	9b02      	ldr	r3, [sp, #8]
    caf8:	681b      	ldr	r3, [r3, #0]
    cafa:	9303      	str	r3, [sp, #12]
        /* Reset the code and unlock the MB */
        flexcan_mb_config &= (~FLEXCAN_IP_CS_CODE_MASK);
    cafc:	9b03      	ldr	r3, [sp, #12]
    cafe:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    cb02:	9303      	str	r3, [sp, #12]
        flexcan_mb_config |= (uint32)(((uint32)FLEXCAN_RX_INACTIVE & (uint32)0x1F) << (uint8)FLEXCAN_IP_CS_CODE_SHIFT) & (uint32)FLEXCAN_IP_CS_CODE_MASK;
        *flexcan_mb = flexcan_mb_config;
    cb04:	9b02      	ldr	r3, [sp, #8]
    cb06:	9a03      	ldr	r2, [sp, #12]
    cb08:	601a      	str	r2, [r3, #0]
        /* Reconfigure The MB as left by RxMBconfig */
        flexcan_mb_config &= (~FLEXCAN_IP_CS_CODE_MASK);
    cb0a:	9b03      	ldr	r3, [sp, #12]
    cb0c:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    cb10:	9303      	str	r3, [sp, #12]
        flexcan_mb_config |= (uint32)(((uint32)FLEXCAN_RX_EMPTY & (uint32)0x1F) << (uint8)FLEXCAN_IP_CS_CODE_SHIFT) & (uint32)FLEXCAN_IP_CS_CODE_MASK;
    cb12:	9b03      	ldr	r3, [sp, #12]
    cb14:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
    cb18:	9303      	str	r3, [sp, #12]
        *flexcan_mb = flexcan_mb_config;
    cb1a:	9b02      	ldr	r3, [sp, #8]
    cb1c:	9a03      	ldr	r2, [sp, #12]
    cb1e:	601a      	str	r2, [r3, #0]
    }
    /* Clear message buffer flag */
    FlexCAN_ClearMsgBuffIntStatusFlag(pBase, mb_idx);
    cb20:	f89d 3006 	ldrb.w	r3, [sp, #6]
    cb24:	4619      	mov	r1, r3
    cb26:	9807      	ldr	r0, [sp, #28]
    cb28:	f7ff f814 	bl	bb54 <FlexCAN_ClearMsgBuffIntStatusFlag>
}
    cb2c:	bf00      	nop
    cb2e:	b009      	add	sp, #36	; 0x24
    cb30:	f85d fb04 	ldr.w	pc, [sp], #4
    cb34:	000186d8 	.word	0x000186d8
    cb38:	1fff9360 	.word	0x1fff9360

0000cb3c <FlexCAN_Ip_Init_Privileged>:
/* implements FlexCAN_Ip_Init_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_Init_Privileged(uint8 Flexcan_Ip_u8Instance,
                                                 Flexcan_Ip_StateType * Flexcan_Ip_pState,
                                                 const Flexcan_Ip_ConfigType * Flexcan_Ip_pData
                                                )
{
    cb3c:	b500      	push	{lr}
    cb3e:	b089      	sub	sp, #36	; 0x24
    cb40:	4603      	mov	r3, r0
    cb42:	9102      	str	r1, [sp, #8]
    cb44:	9201      	str	r2, [sp, #4]
    cb46:	f88d 300f 	strb.w	r3, [sp, #15]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    cb4a:	2300      	movs	r3, #0
    cb4c:	9306      	str	r3, [sp, #24]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[Flexcan_Ip_u8Instance];
    cb4e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    cb52:	4a36      	ldr	r2, [pc, #216]	; (cc2c <FlexCAN_Ip_Init_Privileged+0xf0>)
    cb54:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    cb58:	9305      	str	r3, [sp, #20]
    {
        OsIf_Trusted_Call1param(FlexCAN_SetUserAccessAllowed, pBase);
    }
#endif

    eResult = FlexCAN_InitController(Flexcan_Ip_u8Instance, pBase, Flexcan_Ip_pData);
    cb5a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    cb5e:	9a01      	ldr	r2, [sp, #4]
    cb60:	9905      	ldr	r1, [sp, #20]
    cb62:	4618      	mov	r0, r3
    cb64:	f7ff fa84 	bl	c070 <FlexCAN_InitController>
    cb68:	9006      	str	r0, [sp, #24]
    if (FLEXCAN_STATUS_SUCCESS == eResult)
    cb6a:	9b06      	ldr	r3, [sp, #24]
    cb6c:	2b00      	cmp	r3, #0
    cb6e:	d158      	bne.n	cc22 <FlexCAN_Ip_Init_Privileged+0xe6>
    {
        /* Init Baudrate */
        FlexCAN_InitBaudrate(pBase, Flexcan_Ip_pData);
    cb70:	9901      	ldr	r1, [sp, #4]
    cb72:	9805      	ldr	r0, [sp, #20]
    cb74:	f7ff fad6 	bl	c124 <FlexCAN_InitBaudrate>
        /* Select mode */
        FlexCAN_SetOperationMode(pBase, Flexcan_Ip_pData->flexcanMode);
    cb78:	9b01      	ldr	r3, [sp, #4]
    cb7a:	68db      	ldr	r3, [r3, #12]
    cb7c:	4619      	mov	r1, r3
    cb7e:	9805      	ldr	r0, [sp, #20]
    cb80:	f002 fdb8 	bl	f6f4 <FlexCAN_SetOperationMode>

#if (FLEXCAN_IP_FEATURE_HAS_TS_ENABLE == STD_ON)
        FlexCAN_ConfigTimestamp(Flexcan_Ip_u8Instance, pBase, (const Flexcan_Ip_TimeStampConfigType *)(&Flexcan_Ip_pData->time_stamp));
#endif   /* (FLEXCAN_IP_FEATURE_HAS_TS_ENABLE == STD_ON) */

        for (i = 0; i < (uint8)FLEXCAN_IP_FEATURE_MAX_MB_NUM; i++)
    cb84:	2300      	movs	r3, #0
    cb86:	9307      	str	r3, [sp, #28]
    cb88:	e01d      	b.n	cbc6 <FlexCAN_Ip_Init_Privileged+0x8a>
        {
            /* Check if blocking need to be any more present in sync\async discussions */
            /* Sync up isPolling status with hw (Imask), at the begining all Imask = 0 => isPolling = TRUE */
            Flexcan_Ip_pState->mbs[i].isPolling = TRUE;
    cb8a:	9a02      	ldr	r2, [sp, #8]
    cb8c:	9b07      	ldr	r3, [sp, #28]
    cb8e:	011b      	lsls	r3, r3, #4
    cb90:	4413      	add	r3, r2
    cb92:	3308      	adds	r3, #8
    cb94:	2201      	movs	r2, #1
    cb96:	701a      	strb	r2, [r3, #0]
            Flexcan_Ip_pState->mbs[i].pMBmessage = NULL_PTR;
    cb98:	9a02      	ldr	r2, [sp, #8]
    cb9a:	9b07      	ldr	r3, [sp, #28]
    cb9c:	011b      	lsls	r3, r3, #4
    cb9e:	4413      	add	r3, r2
    cba0:	2200      	movs	r2, #0
    cba2:	601a      	str	r2, [r3, #0]
            Flexcan_Ip_pState->mbs[i].state = FLEXCAN_MB_IDLE;
    cba4:	9a02      	ldr	r2, [sp, #8]
    cba6:	9b07      	ldr	r3, [sp, #28]
    cba8:	011b      	lsls	r3, r3, #4
    cbaa:	4413      	add	r3, r2
    cbac:	3304      	adds	r3, #4
    cbae:	2200      	movs	r2, #0
    cbb0:	601a      	str	r2, [r3, #0]
            Flexcan_Ip_pState->mbs[i].time_stamp = 0U;
    cbb2:	9a02      	ldr	r2, [sp, #8]
    cbb4:	9b07      	ldr	r3, [sp, #28]
    cbb6:	011b      	lsls	r3, r3, #4
    cbb8:	4413      	add	r3, r2
    cbba:	330c      	adds	r3, #12
    cbbc:	2200      	movs	r2, #0
    cbbe:	601a      	str	r2, [r3, #0]
        for (i = 0; i < (uint8)FLEXCAN_IP_FEATURE_MAX_MB_NUM; i++)
    cbc0:	9b07      	ldr	r3, [sp, #28]
    cbc2:	3301      	adds	r3, #1
    cbc4:	9307      	str	r3, [sp, #28]
    cbc6:	9b07      	ldr	r3, [sp, #28]
    cbc8:	2b1f      	cmp	r3, #31
    cbca:	d9de      	bls.n	cb8a <FlexCAN_Ip_Init_Privileged+0x4e>
        /* Sync up isPolling status with hw (Imask), at the begining all Imask = 0 => isPolling = TRUE */
        Flexcan_Ip_pState->enhancedFifoOutput.isPolling = TRUE;
        Flexcan_Ip_pState->enhancedFifoOutput.state = FLEXCAN_MB_IDLE;
#endif

        Flexcan_Ip_pState->transferType = Flexcan_Ip_pData->transfer_type;
    cbcc:	9b01      	ldr	r3, [sp, #4]
    cbce:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    cbd0:	9b02      	ldr	r3, [sp, #8]
    cbd2:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
        Flexcan_Ip_pState->u32NumOfMbTransferByDMA = Flexcan_Ip_pData->num_enhanced_watermark;
#endif /* FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO */
#endif /* FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */

        /* Clear Callbacks in case of autovariables garbage */
        Flexcan_Ip_pState->callback = Flexcan_Ip_pData->Callback;
    cbd6:	9b01      	ldr	r3, [sp, #4]
    cbd8:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    cbda:	9b02      	ldr	r3, [sp, #8]
    cbdc:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
        Flexcan_Ip_pState->callbackParam = NULL_PTR;
    cbe0:	9b02      	ldr	r3, [sp, #8]
    cbe2:	2200      	movs	r2, #0
    cbe4:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
        Flexcan_Ip_pState->error_callback = Flexcan_Ip_pData->ErrorCallback;
    cbe8:	9b01      	ldr	r3, [sp, #4]
    cbea:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    cbec:	9b02      	ldr	r3, [sp, #8]
    cbee:	f8c3 2208 	str.w	r2, [r3, #520]	; 0x208
        Flexcan_Ip_pState->errorCallbackParam = NULL_PTR;
    cbf2:	9b02      	ldr	r3, [sp, #8]
    cbf4:	2200      	movs	r2, #0
    cbf6:	f8c3 220c 	str.w	r2, [r3, #524]	; 0x20c
        Flexcan_Ip_pState->bIsLegacyFifoEn = Flexcan_Ip_pData->is_rx_fifo_needed;
    cbfa:	9b01      	ldr	r3, [sp, #4]
    cbfc:	7a1a      	ldrb	r2, [r3, #8]
    cbfe:	9b02      	ldr	r3, [sp, #8]
    cc00:	f883 2214 	strb.w	r2, [r3, #532]	; 0x214
#if (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON)
        Flexcan_Ip_pState->bIsEnhancedFifoEn = Flexcan_Ip_pData->is_enhanced_rx_fifo_needed;
#endif /* FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO */
        Flexcan_Ip_pState->u32MaxMbNum = Flexcan_Ip_pData->max_num_mb;
    cc04:	9b01      	ldr	r3, [sp, #4]
    cc06:	681a      	ldr	r2, [r3, #0]
    cc08:	9b02      	ldr	r3, [sp, #8]
    cc0a:	f8c3 2218 	str.w	r2, [r3, #536]	; 0x218
        Flexcan_Ip_pState->isIntActive = TRUE;
    cc0e:	9b02      	ldr	r3, [sp, #8]
    cc10:	2201      	movs	r2, #1
    cc12:	f883 221c 	strb.w	r2, [r3, #540]	; 0x21c
        /* Save runtime structure pointers so irq handler can point to the correct state structure */
        Flexcan_Ip_apxState[Flexcan_Ip_u8Instance] = Flexcan_Ip_pState;
    cc16:	f89d 300f 	ldrb.w	r3, [sp, #15]
    cc1a:	4905      	ldr	r1, [pc, #20]	; (cc30 <FlexCAN_Ip_Init_Privileged+0xf4>)
    cc1c:	9a02      	ldr	r2, [sp, #8]
    cc1e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    return eResult;
    cc22:	9b06      	ldr	r3, [sp, #24]
}
    cc24:	4618      	mov	r0, r3
    cc26:	b009      	add	sp, #36	; 0x24
    cc28:	f85d fb04 	ldr.w	pc, [sp], #4
    cc2c:	000186d8 	.word	0x000186d8
    cc30:	1fff9360 	.word	0x1fff9360

0000cc34 <FlexCAN_Ip_Send>:
                                      uint8 mb_idx,
                                      const Flexcan_Ip_DataInfoType * tx_info,
                                      uint32 msg_id,
                                      const uint8 * mb_data
                                     )
{
    cc34:	b500      	push	{lr}
    cc36:	b08b      	sub	sp, #44	; 0x2c
    cc38:	9204      	str	r2, [sp, #16]
    cc3a:	9303      	str	r3, [sp, #12]
    cc3c:	4603      	mov	r3, r0
    cc3e:	f88d 3017 	strb.w	r3, [sp, #23]
    cc42:	460b      	mov	r3, r1
    cc44:	f88d 3016 	strb.w	r3, [sp, #22]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_ERROR;
    cc48:	2301      	movs	r3, #1
    cc4a:	9309      	str	r3, [sp, #36]	; 0x24
#if (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON)
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    cc4c:	f89d 3017 	ldrb.w	r3, [sp, #23]
    cc50:	4a1c      	ldr	r2, [pc, #112]	; (ccc4 <FlexCAN_Ip_Send+0x90>)
    cc52:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    cc56:	9308      	str	r3, [sp, #32]
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    cc58:	f89d 3017 	ldrb.w	r3, [sp, #23]
    cc5c:	4a1a      	ldr	r2, [pc, #104]	; (ccc8 <FlexCAN_Ip_Send+0x94>)
    cc5e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    cc62:	9307      	str	r3, [sp, #28]

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert(tx_info != NULL_PTR);
#endif
    if (!FlexCAN_IsListenOnlyModeEnabled(base))
    cc64:	9808      	ldr	r0, [sp, #32]
    cc66:	f7ff f8f4 	bl	be52 <FlexCAN_IsListenOnlyModeEnabled>
    cc6a:	4603      	mov	r3, r0
    cc6c:	f083 0301 	eor.w	r3, r3, #1
    cc70:	b2db      	uxtb	r3, r3
    cc72:	2b00      	cmp	r3, #0
    cc74:	d021      	beq.n	ccba <FlexCAN_Ip_Send+0x86>
    {
        result = FlexCAN_StartSendData(instance, mb_idx, tx_info, msg_id, mb_data);
    cc76:	f89d 1016 	ldrb.w	r1, [sp, #22]
    cc7a:	f89d 0017 	ldrb.w	r0, [sp, #23]
    cc7e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    cc80:	9300      	str	r3, [sp, #0]
    cc82:	9b03      	ldr	r3, [sp, #12]
    cc84:	9a04      	ldr	r2, [sp, #16]
    cc86:	f7ff fb4b 	bl	c320 <FlexCAN_StartSendData>
    cc8a:	9009      	str	r0, [sp, #36]	; 0x24
#if (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON)
        if ((FLEXCAN_STATUS_SUCCESS ==  result) && (FALSE == tx_info->is_polling))
    cc8c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    cc8e:	2b00      	cmp	r3, #0
    cc90:	d113      	bne.n	ccba <FlexCAN_Ip_Send+0x86>
    cc92:	9b04      	ldr	r3, [sp, #16]
    cc94:	7b1b      	ldrb	r3, [r3, #12]
    cc96:	f083 0301 	eor.w	r3, r3, #1
    cc9a:	b2db      	uxtb	r3, r3
    cc9c:	2b00      	cmp	r3, #0
    cc9e:	d00c      	beq.n	ccba <FlexCAN_Ip_Send+0x86>
        {
            /* Enable message buffer interrupt*/
            result = FlexCAN_SetMsgBuffIntCmd(base, instance, mb_idx, TRUE, state->isIntActive);
    cca0:	f89d 2016 	ldrb.w	r2, [sp, #22]
    cca4:	9b07      	ldr	r3, [sp, #28]
    cca6:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    ccaa:	f89d 1017 	ldrb.w	r1, [sp, #23]
    ccae:	9300      	str	r3, [sp, #0]
    ccb0:	2301      	movs	r3, #1
    ccb2:	9808      	ldr	r0, [sp, #32]
    ccb4:	f002 f9b6 	bl	f024 <FlexCAN_SetMsgBuffIntCmd>
    ccb8:	9009      	str	r0, [sp, #36]	; 0x24
        }
#endif
    }
    return result;
    ccba:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    ccbc:	4618      	mov	r0, r3
    ccbe:	b00b      	add	sp, #44	; 0x2c
    ccc0:	f85d fb04 	ldr.w	pc, [sp], #4
    ccc4:	000186d8 	.word	0x000186d8
    ccc8:	1fff9360 	.word	0x1fff9360

0000cccc <FlexCAN_Ip_ConfigRxMb>:
Flexcan_Ip_StatusType FlexCAN_Ip_ConfigRxMb(uint8 instance,
                                            uint8 mb_idx,
                                            const Flexcan_Ip_DataInfoType * rx_info,
                                            uint32 msg_id
                                           )
{
    cccc:	b500      	push	{lr}
    ccce:	b08b      	sub	sp, #44	; 0x2c
    ccd0:	9202      	str	r2, [sp, #8]
    ccd2:	9301      	str	r3, [sp, #4]
    ccd4:	4603      	mov	r3, r0
    ccd6:	f88d 300f 	strb.w	r3, [sp, #15]
    ccda:	460b      	mov	r3, r1
    ccdc:	f88d 300e 	strb.w	r3, [sp, #14]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    cce0:	2300      	movs	r3, #0
    cce2:	9309      	str	r3, [sp, #36]	; 0x24
    Flexcan_Ip_MsbuffCodeStatusType cs;
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    cce4:	f89d 300f 	ldrb.w	r3, [sp, #15]
    cce8:	4a19      	ldr	r2, [pc, #100]	; (cd50 <FlexCAN_Ip_ConfigRxMb+0x84>)
    ccea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ccee:	9308      	str	r3, [sp, #32]
    }
    else
    {
#endif
        /* Clear the message buffer flag if previous remained triggered */
        FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    ccf0:	f89d 300e 	ldrb.w	r3, [sp, #14]
    ccf4:	4619      	mov	r1, r3
    ccf6:	9808      	ldr	r0, [sp, #32]
    ccf8:	f7fe ff2c 	bl	bb54 <FlexCAN_ClearMsgBuffIntStatusFlag>

        cs.dataLen = rx_info->data_length;
    ccfc:	9b02      	ldr	r3, [sp, #8]
    ccfe:	685b      	ldr	r3, [r3, #4]
    cd00:	9306      	str	r3, [sp, #24]
        cs.msgIdType = rx_info->msg_id_type;
    cd02:	9b02      	ldr	r3, [sp, #8]
    cd04:	681b      	ldr	r3, [r3, #0]
    cd06:	9305      	str	r3, [sp, #20]
    #if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        cs.fd_enable = rx_info->fd_enable;
    cd08:	9b02      	ldr	r3, [sp, #8]
    cd0a:	7a1b      	ldrb	r3, [r3, #8]
    cd0c:	f88d 301c 	strb.w	r3, [sp, #28]
    #endif

        /* Initialize rx mb*/
        cs.code = (uint32)FLEXCAN_RX_NOT_USED;
    cd10:	230f      	movs	r3, #15
    cd12:	9304      	str	r3, [sp, #16]
        FlexCAN_SetRxMsgBuff(base, mb_idx, &cs, msg_id);
    cd14:	f89d 100e 	ldrb.w	r1, [sp, #14]
    cd18:	aa04      	add	r2, sp, #16
    cd1a:	9b01      	ldr	r3, [sp, #4]
    cd1c:	9808      	ldr	r0, [sp, #32]
    cd1e:	f002 fa25 	bl	f16c <FlexCAN_SetRxMsgBuff>

        /* Initialize receive MB*/
        cs.code = (uint32)FLEXCAN_RX_INACTIVE;
    cd22:	2300      	movs	r3, #0
    cd24:	9304      	str	r3, [sp, #16]
        FlexCAN_SetRxMsgBuff(base, mb_idx, &cs, msg_id);
    cd26:	f89d 100e 	ldrb.w	r1, [sp, #14]
    cd2a:	aa04      	add	r2, sp, #16
    cd2c:	9b01      	ldr	r3, [sp, #4]
    cd2e:	9808      	ldr	r0, [sp, #32]
    cd30:	f002 fa1c 	bl	f16c <FlexCAN_SetRxMsgBuff>

        /* Set up FlexCAN message buffer fields for receiving data*/
        cs.code = (uint32)FLEXCAN_RX_EMPTY;
    cd34:	2304      	movs	r3, #4
    cd36:	9304      	str	r3, [sp, #16]
        FlexCAN_SetRxMsgBuff(base, mb_idx, &cs, msg_id);
    cd38:	f89d 100e 	ldrb.w	r1, [sp, #14]
    cd3c:	aa04      	add	r2, sp, #16
    cd3e:	9b01      	ldr	r3, [sp, #4]
    cd40:	9808      	ldr	r0, [sp, #32]
    cd42:	f002 fa13 	bl	f16c <FlexCAN_SetRxMsgBuff>
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    }
#endif
    return eResult;
    cd46:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    cd48:	4618      	mov	r0, r3
    cd4a:	b00b      	add	sp, #44	; 0x2c
    cd4c:	f85d fb04 	ldr.w	pc, [sp], #4
    cd50:	000186d8 	.word	0x000186d8

0000cd54 <FlexCAN_Ip_Receive>:
Flexcan_Ip_StatusType FlexCAN_Ip_Receive(uint8 instance,
                                         uint8 mb_idx,
                                         Flexcan_Ip_MsgBuffType * data,
                                         boolean isPolling
                                        )
{
    cd54:	b500      	push	{lr}
    cd56:	b089      	sub	sp, #36	; 0x24
    cd58:	9202      	str	r2, [sp, #8]
    cd5a:	461a      	mov	r2, r3
    cd5c:	4603      	mov	r3, r0
    cd5e:	f88d 300f 	strb.w	r3, [sp, #15]
    cd62:	460b      	mov	r3, r1
    cd64:	f88d 300e 	strb.w	r3, [sp, #14]
    cd68:	4613      	mov	r3, r2
    cd6a:	f88d 300d 	strb.w	r3, [sp, #13]

    Flexcan_Ip_StatusType result;
#if (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON)
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    cd6e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    cd72:	4a18      	ldr	r2, [pc, #96]	; (cdd4 <FlexCAN_Ip_Receive+0x80>)
    cd74:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    cd78:	9306      	str	r3, [sp, #24]
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    cd7a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    cd7e:	4a16      	ldr	r2, [pc, #88]	; (cdd8 <FlexCAN_Ip_Receive+0x84>)
    cd80:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    cd84:	9305      	str	r3, [sp, #20]
#endif
    #if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    #endif

    result = FlexCAN_StartRxMessageBufferData(instance, mb_idx, data, isPolling);
    cd86:	f89d 300d 	ldrb.w	r3, [sp, #13]
    cd8a:	f89d 100e 	ldrb.w	r1, [sp, #14]
    cd8e:	f89d 000f 	ldrb.w	r0, [sp, #15]
    cd92:	9a02      	ldr	r2, [sp, #8]
    cd94:	f7ff fa86 	bl	c2a4 <FlexCAN_StartRxMessageBufferData>
    cd98:	9007      	str	r0, [sp, #28]
#if (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON)
    if ((FLEXCAN_STATUS_SUCCESS == result) && (FALSE == isPolling))
    cd9a:	9b07      	ldr	r3, [sp, #28]
    cd9c:	2b00      	cmp	r3, #0
    cd9e:	d113      	bne.n	cdc8 <FlexCAN_Ip_Receive+0x74>
    cda0:	f89d 300d 	ldrb.w	r3, [sp, #13]
    cda4:	f083 0301 	eor.w	r3, r3, #1
    cda8:	b2db      	uxtb	r3, r3
    cdaa:	2b00      	cmp	r3, #0
    cdac:	d00c      	beq.n	cdc8 <FlexCAN_Ip_Receive+0x74>
    {
        /* Enable MB interrupt*/
        result = FlexCAN_SetMsgBuffIntCmd(base, instance, mb_idx, TRUE, state->isIntActive);
    cdae:	f89d 200e 	ldrb.w	r2, [sp, #14]
    cdb2:	9b05      	ldr	r3, [sp, #20]
    cdb4:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    cdb8:	f89d 100f 	ldrb.w	r1, [sp, #15]
    cdbc:	9300      	str	r3, [sp, #0]
    cdbe:	2301      	movs	r3, #1
    cdc0:	9806      	ldr	r0, [sp, #24]
    cdc2:	f002 f92f 	bl	f024 <FlexCAN_SetMsgBuffIntCmd>
    cdc6:	9007      	str	r0, [sp, #28]
    }
#endif
    return result;
    cdc8:	9b07      	ldr	r3, [sp, #28]
}
    cdca:	4618      	mov	r0, r3
    cdcc:	b009      	add	sp, #36	; 0x24
    cdce:	f85d fb04 	ldr.w	pc, [sp], #4
    cdd2:	bf00      	nop
    cdd4:	000186d8 	.word	0x000186d8
    cdd8:	1fff9360 	.word	0x1fff9360

0000cddc <FlexCAN_Ip_ReceiveBlocking>:
                                                 uint8 mb_idx,
                                                 Flexcan_Ip_MsgBuffType * data,
                                                 boolean isPolling,
                                                 uint32 u32TimeoutMs
                                                )
{
    cddc:	b500      	push	{lr}
    cdde:	b08b      	sub	sp, #44	; 0x2c
    cde0:	9202      	str	r2, [sp, #8]
    cde2:	461a      	mov	r2, r3
    cde4:	4603      	mov	r3, r0
    cde6:	f88d 300f 	strb.w	r3, [sp, #15]
    cdea:	460b      	mov	r3, r1
    cdec:	f88d 300e 	strb.w	r3, [sp, #14]
    cdf0:	4613      	mov	r3, r2
    cdf2:	f88d 300d 	strb.w	r3, [sp, #13]
    Flexcan_Ip_StatusType result;
    uint32 timeStart = 0U;
    cdf6:	2300      	movs	r3, #0
    cdf8:	9304      	str	r3, [sp, #16]
    uint32 timeElapsed = 0U;
    cdfa:	2300      	movs	r3, #0
    cdfc:	9308      	str	r3, [sp, #32]
    uint32 mS2Ticks = OsIf_MicrosToTicks((u32TimeoutMs * 1000U), FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    cdfe:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    ce00:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    ce04:	fb02 f303 	mul.w	r3, r2, r3
    ce08:	2100      	movs	r1, #0
    ce0a:	4618      	mov	r0, r3
    ce0c:	f7f5 f8da 	bl	1fc4 <OsIf_MicrosToTicks>
    ce10:	9007      	str	r0, [sp, #28]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    ce12:	f89d 300f 	ldrb.w	r3, [sp, #15]
    ce16:	4a4c      	ldr	r2, [pc, #304]	; (cf48 <FlexCAN_Ip_ReceiveBlocking+0x16c>)
    ce18:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ce1c:	9306      	str	r3, [sp, #24]
#if (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON)
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    ce1e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    ce22:	4a4a      	ldr	r2, [pc, #296]	; (cf4c <FlexCAN_Ip_ReceiveBlocking+0x170>)
    ce24:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ce28:	9305      	str	r3, [sp, #20]
#else
    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
#endif
    result = FlexCAN_StartRxMessageBufferData(instance, mb_idx, data, isPolling);
    ce2a:	f89d 300d 	ldrb.w	r3, [sp, #13]
    ce2e:	f89d 100e 	ldrb.w	r1, [sp, #14]
    ce32:	f89d 000f 	ldrb.w	r0, [sp, #15]
    ce36:	9a02      	ldr	r2, [sp, #8]
    ce38:	f7ff fa34 	bl	c2a4 <FlexCAN_StartRxMessageBufferData>
    ce3c:	9009      	str	r0, [sp, #36]	; 0x24
#if (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON)
    if ((FLEXCAN_STATUS_SUCCESS == result) && (FALSE == isPolling))
    ce3e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ce40:	2b00      	cmp	r3, #0
    ce42:	d113      	bne.n	ce6c <FlexCAN_Ip_ReceiveBlocking+0x90>
    ce44:	f89d 300d 	ldrb.w	r3, [sp, #13]
    ce48:	f083 0301 	eor.w	r3, r3, #1
    ce4c:	b2db      	uxtb	r3, r3
    ce4e:	2b00      	cmp	r3, #0
    ce50:	d00c      	beq.n	ce6c <FlexCAN_Ip_ReceiveBlocking+0x90>
    {
        /* Enable MB interrupt*/
        result = FlexCAN_SetMsgBuffIntCmd(base, instance, mb_idx, TRUE, state->isIntActive);
    ce52:	f89d 200e 	ldrb.w	r2, [sp, #14]
    ce56:	9b06      	ldr	r3, [sp, #24]
    ce58:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    ce5c:	f89d 100f 	ldrb.w	r1, [sp, #15]
    ce60:	9300      	str	r3, [sp, #0]
    ce62:	2301      	movs	r3, #1
    ce64:	9805      	ldr	r0, [sp, #20]
    ce66:	f002 f8dd 	bl	f024 <FlexCAN_SetMsgBuffIntCmd>
    ce6a:	9009      	str	r0, [sp, #36]	; 0x24
    }
#endif
    if (FLEXCAN_STATUS_SUCCESS == result)
    ce6c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ce6e:	2b00      	cmp	r3, #0
    ce70:	d133      	bne.n	ceda <FlexCAN_Ip_ReceiveBlocking+0xfe>
    {
        timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    ce72:	2000      	movs	r0, #0
    ce74:	f7f5 f85a 	bl	1f2c <OsIf_GetCounter>
    ce78:	4603      	mov	r3, r0
    ce7a:	9304      	str	r3, [sp, #16]
        while (FLEXCAN_MB_RX_BUSY == state->mbs[mb_idx].state)
    ce7c:	e024      	b.n	cec8 <FlexCAN_Ip_ReceiveBlocking+0xec>
        {
            if (TRUE == isPolling)
    ce7e:	f89d 300d 	ldrb.w	r3, [sp, #13]
    ce82:	2b00      	cmp	r3, #0
    ce84:	d010      	beq.n	cea8 <FlexCAN_Ip_ReceiveBlocking+0xcc>
            {
                if (FlexCAN_GetBuffStatusFlag(base, mb_idx) != 0U)
    ce86:	f89d 300e 	ldrb.w	r3, [sp, #14]
    ce8a:	4619      	mov	r1, r3
    ce8c:	9805      	ldr	r0, [sp, #20]
    ce8e:	f7fe fe74 	bl	bb7a <FlexCAN_GetBuffStatusFlag>
    ce92:	4603      	mov	r3, r0
    ce94:	2b00      	cmp	r3, #0
    ce96:	d007      	beq.n	cea8 <FlexCAN_Ip_ReceiveBlocking+0xcc>
                {
                    FlexCAN_IRQHandlerRxMB(instance, mb_idx);
    ce98:	f89d 200e 	ldrb.w	r2, [sp, #14]
    ce9c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    cea0:	4611      	mov	r1, r2
    cea2:	4618      	mov	r0, r3
    cea4:	f7ff fb20 	bl	c4e8 <FlexCAN_IRQHandlerRxMB>
                }
            }
            timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    cea8:	ab04      	add	r3, sp, #16
    ceaa:	2100      	movs	r1, #0
    ceac:	4618      	mov	r0, r3
    ceae:	f7f5 f856 	bl	1f5e <OsIf_GetElapsed>
    ceb2:	4602      	mov	r2, r0
    ceb4:	9b08      	ldr	r3, [sp, #32]
    ceb6:	4413      	add	r3, r2
    ceb8:	9308      	str	r3, [sp, #32]
            if (timeElapsed >= mS2Ticks)
    ceba:	9a08      	ldr	r2, [sp, #32]
    cebc:	9b07      	ldr	r3, [sp, #28]
    cebe:	429a      	cmp	r2, r3
    cec0:	d302      	bcc.n	cec8 <FlexCAN_Ip_ReceiveBlocking+0xec>
            {
                result = FLEXCAN_STATUS_TIMEOUT;
    cec2:	2303      	movs	r3, #3
    cec4:	9309      	str	r3, [sp, #36]	; 0x24
                break;
    cec6:	e008      	b.n	ceda <FlexCAN_Ip_ReceiveBlocking+0xfe>
        while (FLEXCAN_MB_RX_BUSY == state->mbs[mb_idx].state)
    cec8:	f89d 300e 	ldrb.w	r3, [sp, #14]
    cecc:	9a06      	ldr	r2, [sp, #24]
    cece:	011b      	lsls	r3, r3, #4
    ced0:	4413      	add	r3, r2
    ced2:	3304      	adds	r3, #4
    ced4:	681b      	ldr	r3, [r3, #0]
    ced6:	2b01      	cmp	r3, #1
    ced8:	d0d1      	beq.n	ce7e <FlexCAN_Ip_ReceiveBlocking+0xa2>
            }
        }
    }

    if ((FLEXCAN_STATUS_TIMEOUT == result) && (FALSE == isPolling))
    ceda:	9b09      	ldr	r3, [sp, #36]	; 0x24
    cedc:	2b03      	cmp	r3, #3
    cede:	d112      	bne.n	cf06 <FlexCAN_Ip_ReceiveBlocking+0x12a>
    cee0:	f89d 300d 	ldrb.w	r3, [sp, #13]
    cee4:	f083 0301 	eor.w	r3, r3, #1
    cee8:	b2db      	uxtb	r3, r3
    ceea:	2b00      	cmp	r3, #0
    ceec:	d00b      	beq.n	cf06 <FlexCAN_Ip_ReceiveBlocking+0x12a>
    {
#if (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON)
        /* Disable Mb interrupt*/
       (void)FlexCAN_SetMsgBuffIntCmd(base, instance, mb_idx, FALSE, state->isIntActive);
    ceee:	f89d 200e 	ldrb.w	r2, [sp, #14]
    cef2:	9b06      	ldr	r3, [sp, #24]
    cef4:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    cef8:	f89d 100f 	ldrb.w	r1, [sp, #15]
    cefc:	9300      	str	r3, [sp, #0]
    cefe:	2300      	movs	r3, #0
    cf00:	9805      	ldr	r0, [sp, #20]
    cf02:	f002 f88f 	bl	f024 <FlexCAN_SetMsgBuffIntCmd>
#endif
    }

    if ((FLEXCAN_STATUS_BUFF_OUT_OF_RANGE != result) && (FLEXCAN_STATUS_BUSY != result))
    cf06:	9b09      	ldr	r3, [sp, #36]	; 0x24
    cf08:	2b04      	cmp	r3, #4
    cf0a:	d018      	beq.n	cf3e <FlexCAN_Ip_ReceiveBlocking+0x162>
    cf0c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    cf0e:	2b02      	cmp	r3, #2
    cf10:	d015      	beq.n	cf3e <FlexCAN_Ip_ReceiveBlocking+0x162>
    {
        if ((FLEXCAN_MB_IDLE == state->mbs[mb_idx].state))
    cf12:	f89d 300e 	ldrb.w	r3, [sp, #14]
    cf16:	9a06      	ldr	r2, [sp, #24]
    cf18:	011b      	lsls	r3, r3, #4
    cf1a:	4413      	add	r3, r2
    cf1c:	3304      	adds	r3, #4
    cf1e:	681b      	ldr	r3, [r3, #0]
    cf20:	2b00      	cmp	r3, #0
    cf22:	d102      	bne.n	cf2a <FlexCAN_Ip_ReceiveBlocking+0x14e>
        {
            result = FLEXCAN_STATUS_SUCCESS;
    cf24:	2300      	movs	r3, #0
    cf26:	9309      	str	r3, [sp, #36]	; 0x24
    cf28:	e009      	b.n	cf3e <FlexCAN_Ip_ReceiveBlocking+0x162>
        }
        else
        {
            state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;
    cf2a:	f89d 300e 	ldrb.w	r3, [sp, #14]
    cf2e:	9a06      	ldr	r2, [sp, #24]
    cf30:	011b      	lsls	r3, r3, #4
    cf32:	4413      	add	r3, r2
    cf34:	3304      	adds	r3, #4
    cf36:	2200      	movs	r2, #0
    cf38:	601a      	str	r2, [r3, #0]
            result = FLEXCAN_STATUS_TIMEOUT;
    cf3a:	2303      	movs	r3, #3
    cf3c:	9309      	str	r3, [sp, #36]	; 0x24
        }
    }
    return result;
    cf3e:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    cf40:	4618      	mov	r0, r3
    cf42:	b00b      	add	sp, #44	; 0x2c
    cf44:	f85d fb04 	ldr.w	pc, [sp], #4
    cf48:	1fff9360 	.word	0x1fff9360
    cf4c:	000186d8 	.word	0x000186d8

0000cf50 <FlexCAN_Ip_RxFifo>:
 * after the frame was received and read into the specified buffer.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_RxFifo_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_RxFifo(uint8 instance, Flexcan_Ip_MsgBuffType * data)
{
    cf50:	b500      	push	{lr}
    cf52:	b085      	sub	sp, #20
    cf54:	4603      	mov	r3, r0
    cf56:	9100      	str	r1, [sp, #0]
    cf58:	f88d 3007 	strb.w	r3, [sp, #7]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    cf5c:	2300      	movs	r3, #0
    cf5e:	9303      	str	r3, [sp, #12]
        }
    }
    else
#endif /*FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO*/
    {
        result = FlexCAN_StartRxMessageFifoData(instance, data);
    cf60:	f89d 3007 	ldrb.w	r3, [sp, #7]
    cf64:	9900      	ldr	r1, [sp, #0]
    cf66:	4618      	mov	r0, r3
    cf68:	f7ff fa5e 	bl	c428 <FlexCAN_StartRxMessageFifoData>
    cf6c:	9003      	str	r0, [sp, #12]
    }
    return result;
    cf6e:	9b03      	ldr	r3, [sp, #12]
}
    cf70:	4618      	mov	r0, r3
    cf72:	b005      	add	sp, #20
    cf74:	f85d fb04 	ldr.w	pc, [sp], #4

0000cf78 <FlexCAN_Ip_RxFifoBlocking>:
 *
 *END**************************************************************************/

/* implements FlexCAN_Ip_RxFifoBlocking_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_RxFifoBlocking(uint8 instance, Flexcan_Ip_MsgBuffType *data, uint32 timeout)
{
    cf78:	b500      	push	{lr}
    cf7a:	b087      	sub	sp, #28
    cf7c:	4603      	mov	r3, r0
    cf7e:	9102      	str	r1, [sp, #8]
    cf80:	9201      	str	r2, [sp, #4]
    cf82:	f88d 300f 	strb.w	r3, [sp, #15]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    cf86:	2300      	movs	r3, #0
    cf88:	9305      	str	r3, [sp, #20]
        }
    }
    else
#endif /*FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO*/
    {
        result = FlexCAN_StartRxMessageFifoData(instance, data);
    cf8a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    cf8e:	9902      	ldr	r1, [sp, #8]
    cf90:	4618      	mov	r0, r3
    cf92:	f7ff fa49 	bl	c428 <FlexCAN_StartRxMessageFifoData>
    cf96:	9005      	str	r0, [sp, #20]
        if (FLEXCAN_STATUS_SUCCESS == result)
    cf98:	9b05      	ldr	r3, [sp, #20]
    cf9a:	2b00      	cmp	r3, #0
    cf9c:	d106      	bne.n	cfac <FlexCAN_Ip_RxFifoBlocking+0x34>
        {
            result = FlexCAN_ProccessLegacyRxFIFO(instance, timeout);
    cf9e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    cfa2:	9901      	ldr	r1, [sp, #4]
    cfa4:	4618      	mov	r0, r3
    cfa6:	f7ff f8e2 	bl	c16e <FlexCAN_ProccessLegacyRxFIFO>
    cfaa:	9005      	str	r0, [sp, #20]
        }
    }
    return result;
    cfac:	9b05      	ldr	r3, [sp, #20]
}
    cfae:	4618      	mov	r0, r3
    cfb0:	b007      	add	sp, #28
    cfb2:	f85d fb04 	ldr.w	pc, [sp], #4

0000cfb6 <FlexCAN_Ip_ConfigRxFifo_Privileged>:
/* implements FlexCAN_Ip_ConfigRxFifo_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_ConfigRxFifo_Privileged(uint8 instance,
                                                         Flexcan_Ip_RxFifoIdElementFormatType id_format,
                                                         const Flexcan_Ip_IdTableType * id_filter_table
                                                        )
{
    cfb6:	b500      	push	{lr}
    cfb8:	b089      	sub	sp, #36	; 0x24
    cfba:	4603      	mov	r3, r0
    cfbc:	9102      	str	r1, [sp, #8]
    cfbe:	9201      	str	r2, [sp, #4]
    cfc0:	f88d 300f 	strb.w	r3, [sp, #15]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    cfc4:	2300      	movs	r3, #0
    cfc6:	9307      	str	r3, [sp, #28]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    cfc8:	2300      	movs	r3, #0
    cfca:	9306      	str	r3, [sp, #24]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    cfcc:	f89d 300f 	ldrb.w	r3, [sp, #15]
    cfd0:	4a1c      	ldr	r2, [pc, #112]	; (d044 <FlexCAN_Ip_ConfigRxFifo_Privileged+0x8e>)
    cfd2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    cfd6:	9305      	str	r3, [sp, #20]
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    cfd8:	9805      	ldr	r0, [sp, #20]
    cfda:	f7fe fd61 	bl	baa0 <FlexCAN_IsEnabled>
    cfde:	4603      	mov	r3, r0
    cfe0:	2b00      	cmp	r3, #0
    cfe2:	bf14      	ite	ne
    cfe4:	2301      	movne	r3, #1
    cfe6:	2300      	moveq	r3, #0
    cfe8:	b2db      	uxtb	r3, r3
    cfea:	f083 0301 	eor.w	r3, r3, #1
    cfee:	b2db      	uxtb	r3, r3
    cff0:	f88d 3013 	strb.w	r3, [sp, #19]
    cff4:	f89d 3013 	ldrb.w	r3, [sp, #19]
    cff8:	f003 0301 	and.w	r3, r3, #1
    cffc:	f88d 3013 	strb.w	r3, [sp, #19]

    if (TRUE == disabled)
    d000:	f89d 3013 	ldrb.w	r3, [sp, #19]
    d004:	2b00      	cmp	r3, #0
    d006:	d003      	beq.n	d010 <FlexCAN_Ip_ConfigRxFifo_Privileged+0x5a>
    {
        result = FlexCAN_Enable(pBase);
    d008:	9805      	ldr	r0, [sp, #20]
    d00a:	f001 fd6b 	bl	eae4 <FlexCAN_Enable>
    d00e:	9007      	str	r0, [sp, #28]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    d010:	9b07      	ldr	r3, [sp, #28]
    d012:	2b00      	cmp	r3, #0
    d014:	d104      	bne.n	d020 <FlexCAN_Ip_ConfigRxFifo_Privileged+0x6a>
    {
        /* Initialize rx fifo*/
        FlexCAN_SetRxFifoFilter(pBase, id_format, id_filter_table);
    d016:	9a01      	ldr	r2, [sp, #4]
    d018:	9902      	ldr	r1, [sp, #8]
    d01a:	9805      	ldr	r0, [sp, #20]
    d01c:	f002 fba5 	bl	f76a <FlexCAN_SetRxFifoFilter>
    }

    if (TRUE == disabled)
    d020:	f89d 3013 	ldrb.w	r3, [sp, #19]
    d024:	2b00      	cmp	r3, #0
    d026:	d008      	beq.n	d03a <FlexCAN_Ip_ConfigRxFifo_Privileged+0x84>
    {
        status = FlexCAN_Disable(pBase);
    d028:	9805      	ldr	r0, [sp, #20]
    d02a:	f001 fdd9 	bl	ebe0 <FlexCAN_Disable>
    d02e:	9006      	str	r0, [sp, #24]
        if (FLEXCAN_STATUS_SUCCESS != status)
    d030:	9b06      	ldr	r3, [sp, #24]
    d032:	2b00      	cmp	r3, #0
    d034:	d001      	beq.n	d03a <FlexCAN_Ip_ConfigRxFifo_Privileged+0x84>
        {
            result = status;
    d036:	9b06      	ldr	r3, [sp, #24]
    d038:	9307      	str	r3, [sp, #28]
        }
    }

    return result;
    d03a:	9b07      	ldr	r3, [sp, #28]
}
    d03c:	4618      	mov	r0, r3
    d03e:	b009      	add	sp, #36	; 0x24
    d040:	f85d fb04 	ldr.w	pc, [sp], #4
    d044:	000186d8 	.word	0x000186d8

0000d048 <FlexCAN_Ip_ConfigRemoteResponseMb>:
                                                        uint8 mb_idx,
                                                        const Flexcan_Ip_DataInfoType *tx_info,
                                                        uint32 msg_id,
                                                        const uint8 *mb_data
                                                       )
{
    d048:	b500      	push	{lr}
    d04a:	b08f      	sub	sp, #60	; 0x3c
    d04c:	9204      	str	r2, [sp, #16]
    d04e:	9303      	str	r3, [sp, #12]
    d050:	4603      	mov	r3, r0
    d052:	f88d 3017 	strb.w	r3, [sp, #23]
    d056:	460b      	mov	r3, r1
    d058:	f88d 3016 	strb.w	r3, [sp, #22]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    d05c:	2300      	movs	r3, #0
    d05e:	930d      	str	r3, [sp, #52]	; 0x34
    Flexcan_Ip_MsbuffCodeStatusType cs;
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    d060:	f89d 3017 	ldrb.w	r3, [sp, #23]
    d064:	4a27      	ldr	r2, [pc, #156]	; (d104 <FlexCAN_Ip_ConfigRemoteResponseMb+0xbc>)
    d066:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d06a:	930c      	str	r3, [sp, #48]	; 0x30
    const Flexcan_Ip_StateType * const state = Flexcan_Ip_apxState[instance];
    d06c:	f89d 3017 	ldrb.w	r3, [sp, #23]
    d070:	4a25      	ldr	r2, [pc, #148]	; (d108 <FlexCAN_Ip_ConfigRemoteResponseMb+0xc0>)
    d072:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d076:	930b      	str	r3, [sp, #44]	; 0x2c
    volatile uint32 * pMbAddr = NULL_PTR;
    d078:	2300      	movs	r3, #0
    d07a:	930a      	str	r3, [sp, #40]	; 0x28
    if (TRUE == FlexCAN_IsMbOutOfRange(pBase, mb_idx, state->bIsLegacyFifoEn, state->u32MaxMbNum))
    {
        result = FLEXCAN_STATUS_BUFF_OUT_OF_RANGE;
    }
#endif
    if (FLEXCAN_STATUS_SUCCESS == result)
    d07c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    d07e:	2b00      	cmp	r3, #0
    d080:	d13a      	bne.n	d0f8 <FlexCAN_Ip_ConfigRemoteResponseMb+0xb0>
    {
        /* Initialize transmit mb*/
        cs.dataLen = tx_info->data_length;
    d082:	9b04      	ldr	r3, [sp, #16]
    d084:	685b      	ldr	r3, [r3, #4]
    d086:	9308      	str	r3, [sp, #32]
        cs.msgIdType = tx_info->msg_id_type;
    d088:	9b04      	ldr	r3, [sp, #16]
    d08a:	681b      	ldr	r3, [r3, #0]
    d08c:	9307      	str	r3, [sp, #28]
        cs.code = (uint32)FLEXCAN_RX_RANSWER;
    d08e:	230a      	movs	r3, #10
    d090:	9306      	str	r3, [sp, #24]
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        cs.fd_enable = FALSE;
    d092:	2300      	movs	r3, #0
    d094:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
        cs.enable_brs = FALSE;
    d098:	2300      	movs	r3, #0
    d09a:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
        cs.fd_padding = 0x00U;
    d09e:	2300      	movs	r3, #0
    d0a0:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
#endif
        FlexCAN_ClearMsgBuffIntStatusFlag(pBase, mb_idx);
    d0a4:	f89d 3016 	ldrb.w	r3, [sp, #22]
    d0a8:	4619      	mov	r1, r3
    d0aa:	980c      	ldr	r0, [sp, #48]	; 0x30
    d0ac:	f7fe fd52 	bl	bb54 <FlexCAN_ClearMsgBuffIntStatusFlag>
        pMbAddr = FlexCAN_GetMsgBuffRegion(pBase, mb_idx);
    d0b0:	f89d 3016 	ldrb.w	r3, [sp, #22]
    d0b4:	4619      	mov	r1, r3
    d0b6:	980c      	ldr	r0, [sp, #48]	; 0x30
    d0b8:	f001 fc2c 	bl	e914 <FlexCAN_GetMsgBuffRegion>
    d0bc:	900a      	str	r0, [sp, #40]	; 0x28
        FlexCAN_SetTxMsgBuff(pMbAddr, &cs, msg_id, mb_data, tx_info->is_remote);
    d0be:	9b04      	ldr	r3, [sp, #16]
    d0c0:	7adb      	ldrb	r3, [r3, #11]
    d0c2:	a906      	add	r1, sp, #24
    d0c4:	9300      	str	r3, [sp, #0]
    d0c6:	9b10      	ldr	r3, [sp, #64]	; 0x40
    d0c8:	9a03      	ldr	r2, [sp, #12]
    d0ca:	980a      	ldr	r0, [sp, #40]	; 0x28
    d0cc:	f002 f974 	bl	f3b8 <FlexCAN_SetTxMsgBuff>
        if (FALSE == tx_info->is_polling)
    d0d0:	9b04      	ldr	r3, [sp, #16]
    d0d2:	7b1b      	ldrb	r3, [r3, #12]
    d0d4:	f083 0301 	eor.w	r3, r3, #1
    d0d8:	b2db      	uxtb	r3, r3
    d0da:	2b00      	cmp	r3, #0
    d0dc:	d00c      	beq.n	d0f8 <FlexCAN_Ip_ConfigRemoteResponseMb+0xb0>
        {
            /* Enable MB interrupt*/
            result = FlexCAN_SetMsgBuffIntCmd(pBase, instance, mb_idx, TRUE, state->isIntActive);
    d0de:	f89d 2016 	ldrb.w	r2, [sp, #22]
    d0e2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d0e4:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    d0e8:	f89d 1017 	ldrb.w	r1, [sp, #23]
    d0ec:	9300      	str	r3, [sp, #0]
    d0ee:	2301      	movs	r3, #1
    d0f0:	980c      	ldr	r0, [sp, #48]	; 0x30
    d0f2:	f001 ff97 	bl	f024 <FlexCAN_SetMsgBuffIntCmd>
    d0f6:	900d      	str	r0, [sp, #52]	; 0x34
        }
    }
    return result;
    d0f8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
}
    d0fa:	4618      	mov	r0, r3
    d0fc:	b00f      	add	sp, #60	; 0x3c
    d0fe:	f85d fb04 	ldr.w	pc, [sp], #4
    d102:	bf00      	nop
    d104:	000186d8 	.word	0x000186d8
    d108:	1fff9360 	.word	0x1fff9360

0000d10c <FlexCAN_Ip_GetTransferStatus>:
 * or complete (success). In case Enhanced Rx Fifo, mb_idx will be 255.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetTransferStatus_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_GetTransferStatus(uint8 instance, uint8 mb_idx)
{
    d10c:	b084      	sub	sp, #16
    d10e:	4603      	mov	r3, r0
    d110:	460a      	mov	r2, r1
    d112:	f88d 3007 	strb.w	r3, [sp, #7]
    d116:	4613      	mov	r3, r2
    d118:	f88d 3006 	strb.w	r3, [sp, #6]

    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    d11c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    d120:	4a0d      	ldr	r2, [pc, #52]	; (d158 <FlexCAN_Ip_GetTransferStatus+0x4c>)
    d122:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d126:	9302      	str	r3, [sp, #8]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_ERROR;
    d128:	2301      	movs	r3, #1
    d12a:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert((mb_idx < (uint8)FLEXCAN_IP_FEATURE_MAX_MB_NUM) || (255u == mb_idx));
#endif

    if (mb_idx < (uint8)FLEXCAN_IP_FEATURE_MAX_MB_NUM)
    d12c:	f89d 3006 	ldrb.w	r3, [sp, #6]
    d130:	2b1f      	cmp	r3, #31
    d132:	d80d      	bhi.n	d150 <FlexCAN_Ip_GetTransferStatus+0x44>
    {
        if (FLEXCAN_MB_IDLE == state->mbs[mb_idx].state)
    d134:	f89d 3006 	ldrb.w	r3, [sp, #6]
    d138:	9a02      	ldr	r2, [sp, #8]
    d13a:	011b      	lsls	r3, r3, #4
    d13c:	4413      	add	r3, r2
    d13e:	3304      	adds	r3, #4
    d140:	681b      	ldr	r3, [r3, #0]
    d142:	2b00      	cmp	r3, #0
    d144:	d102      	bne.n	d14c <FlexCAN_Ip_GetTransferStatus+0x40>
        {
            status = FLEXCAN_STATUS_SUCCESS;
    d146:	2300      	movs	r3, #0
    d148:	9303      	str	r3, [sp, #12]
    d14a:	e001      	b.n	d150 <FlexCAN_Ip_GetTransferStatus+0x44>
            status = FLEXCAN_STATUS_ERROR;
        }
#endif
        else
        {
            status = FLEXCAN_STATUS_BUSY;
    d14c:	2302      	movs	r3, #2
    d14e:	9303      	str	r3, [sp, #12]
            status = FLEXCAN_STATUS_BUSY;
        }
    }
#endif /* FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO */

    return status;
    d150:	9b03      	ldr	r3, [sp, #12]
}
    d152:	4618      	mov	r0, r3
    d154:	b004      	add	sp, #16
    d156:	4770      	bx	lr
    d158:	1fff9360 	.word	0x1fff9360

0000d15c <FlexCAN_CompleteRxMessageFifoData>:
 * data and disabling the interrupt.
 * This is not a public API as it is called from other driver functions.
 *
 *END**************************************************************************/
static void FlexCAN_CompleteRxMessageFifoData(uint8 instance)
{
    d15c:	b500      	push	{lr}
    d15e:	b087      	sub	sp, #28
    d160:	4603      	mov	r3, r0
    d162:	f88d 300f 	strb.w	r3, [sp, #15]

    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    d166:	f89d 300f 	ldrb.w	r3, [sp, #15]
    d16a:	4a1d      	ldr	r2, [pc, #116]	; (d1e0 <FlexCAN_CompleteRxMessageFifoData+0x84>)
    d16c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d170:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    d172:	f89d 300f 	ldrb.w	r3, [sp, #15]
    d176:	4a1b      	ldr	r2, [pc, #108]	; (d1e4 <FlexCAN_CompleteRxMessageFifoData+0x88>)
    d178:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d17c:	9304      	str	r3, [sp, #16]

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    if (FLEXCAN_RXFIFO_USING_INTERRUPTS == state->transferType)
    d17e:	9b04      	ldr	r3, [sp, #16]
    d180:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
    d184:	2b00      	cmp	r3, #0
    d186:	d120      	bne.n	d1ca <FlexCAN_CompleteRxMessageFifoData+0x6e>
    {
        /* Disable RX FIFO interrupts*/
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, FLEXCAN_IP_LEGACY_RXFIFO_FRAME_AVAILABLE, FALSE, state->isIntActive);
    d188:	9b04      	ldr	r3, [sp, #16]
    d18a:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    d18e:	f89d 100f 	ldrb.w	r1, [sp, #15]
    d192:	9300      	str	r3, [sp, #0]
    d194:	2300      	movs	r3, #0
    d196:	2205      	movs	r2, #5
    d198:	9805      	ldr	r0, [sp, #20]
    d19a:	f001 ff43 	bl	f024 <FlexCAN_SetMsgBuffIntCmd>
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, FLEXCAN_IP_LEGACY_RXFIFO_WARNING, FALSE, state->isIntActive);
    d19e:	9b04      	ldr	r3, [sp, #16]
    d1a0:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    d1a4:	f89d 100f 	ldrb.w	r1, [sp, #15]
    d1a8:	9300      	str	r3, [sp, #0]
    d1aa:	2300      	movs	r3, #0
    d1ac:	2206      	movs	r2, #6
    d1ae:	9805      	ldr	r0, [sp, #20]
    d1b0:	f001 ff38 	bl	f024 <FlexCAN_SetMsgBuffIntCmd>
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, FLEXCAN_IP_LEGACY_RXFIFO_OVERFLOW, FALSE, state->isIntActive);
    d1b4:	9b04      	ldr	r3, [sp, #16]
    d1b6:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    d1ba:	f89d 100f 	ldrb.w	r1, [sp, #15]
    d1be:	9300      	str	r3, [sp, #0]
    d1c0:	2300      	movs	r3, #0
    d1c2:	2207      	movs	r2, #7
    d1c4:	9805      	ldr	r0, [sp, #20]
    d1c6:	f001 ff2d 	bl	f024 <FlexCAN_SetMsgBuffIntCmd>
    {
        /* do nothing when transferType is POLLING */
    }
#endif /* if FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */
    /* Clear fifo message*/
    state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].pMBmessage = NULL_PTR;
    d1ca:	9b04      	ldr	r3, [sp, #16]
    d1cc:	2200      	movs	r2, #0
    d1ce:	601a      	str	r2, [r3, #0]
            state->callback(instance, FLEXCAN_EVENT_DMA_ERROR, FLEXCAN_IP_MB_HANDLE_RXFIFO, state);
        }
    }

#else
    state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state = FLEXCAN_MB_IDLE;
    d1d0:	9b04      	ldr	r3, [sp, #16]
    d1d2:	2200      	movs	r2, #0
    d1d4:	605a      	str	r2, [r3, #4]
#endif /* if FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */
}
    d1d6:	bf00      	nop
    d1d8:	b007      	add	sp, #28
    d1da:	f85d fb04 	ldr.w	pc, [sp], #4
    d1de:	bf00      	nop
    d1e0:	000186d8 	.word	0x000186d8
    d1e4:	1fff9360 	.word	0x1fff9360

0000d1e8 <FlexCAN_IRQHandler>:
    uint32 endMbIdx
    #if (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON)
    ,boolean bEnhancedFifoExisted
    #endif
)
{
    d1e8:	b500      	push	{lr}
    d1ea:	b08b      	sub	sp, #44	; 0x2c
    d1ec:	4603      	mov	r3, r0
    d1ee:	9102      	str	r1, [sp, #8]
    d1f0:	9201      	str	r2, [sp, #4]
    d1f2:	f88d 300f 	strb.w	r3, [sp, #15]
    uint32 u32MbHandle = 0U;
    d1f6:	2300      	movs	r3, #0
    d1f8:	9309      	str	r3, [sp, #36]	; 0x24
    uint32 flag_reg = 0;
    d1fa:	2300      	movs	r3, #0
    d1fc:	9308      	str	r3, [sp, #32]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    d1fe:	f89d 300f 	ldrb.w	r3, [sp, #15]
    d202:	4a3f      	ldr	r2, [pc, #252]	; (d300 <FlexCAN_IRQHandler+0x118>)
    d204:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d208:	9306      	str	r3, [sp, #24]
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    d20a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    d20e:	4a3d      	ldr	r2, [pc, #244]	; (d304 <FlexCAN_IRQHandler+0x11c>)
    d210:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d214:	9305      	str	r3, [sp, #20]

    /* Get the interrupts that are enabled and ready */
    uint32 mb_idx = endMbIdx;
    d216:	9b01      	ldr	r3, [sp, #4]
    d218:	9307      	str	r3, [sp, #28]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert(endMbIdx < (uint8)FLEXCAN_IP_FEATURE_MAX_MB_NUM);
#endif
    /* Check if instance initialized */
    if (NULL_PTR != state)
    d21a:	9b05      	ldr	r3, [sp, #20]
    d21c:	2b00      	cmp	r3, #0
    d21e:	d05c      	beq.n	d2da <FlexCAN_IRQHandler+0xf2>
    {
        flag_reg = FlexCAN_GetMsgBuffIntStatusFlag(base, mb_idx);
    d220:	9907      	ldr	r1, [sp, #28]
    d222:	9806      	ldr	r0, [sp, #24]
    d224:	f7fe fe47 	bl	beb6 <FlexCAN_GetMsgBuffIntStatusFlag>
    d228:	4603      	mov	r3, r0
    d22a:	9308      	str	r3, [sp, #32]

        while ((0U == flag_reg) && (mb_idx > startMbIdx))
    d22c:	e008      	b.n	d240 <FlexCAN_IRQHandler+0x58>
        {
            mb_idx--;
    d22e:	9b07      	ldr	r3, [sp, #28]
    d230:	3b01      	subs	r3, #1
    d232:	9307      	str	r3, [sp, #28]
            flag_reg = FlexCAN_GetMsgBuffIntStatusFlag(base, mb_idx);
    d234:	9907      	ldr	r1, [sp, #28]
    d236:	9806      	ldr	r0, [sp, #24]
    d238:	f7fe fe3d 	bl	beb6 <FlexCAN_GetMsgBuffIntStatusFlag>
    d23c:	4603      	mov	r3, r0
    d23e:	9308      	str	r3, [sp, #32]
        while ((0U == flag_reg) && (mb_idx > startMbIdx))
    d240:	9b08      	ldr	r3, [sp, #32]
    d242:	2b00      	cmp	r3, #0
    d244:	d103      	bne.n	d24e <FlexCAN_IRQHandler+0x66>
    d246:	9a07      	ldr	r2, [sp, #28]
    d248:	9b02      	ldr	r3, [sp, #8]
    d24a:	429a      	cmp	r2, r3
    d24c:	d8ef      	bhi.n	d22e <FlexCAN_IRQHandler+0x46>
        }

        /* Check Tx/Rx interrupt flag and clear the interrupt */
        if (flag_reg != 0U)
    d24e:	9b08      	ldr	r3, [sp, #32]
    d250:	2b00      	cmp	r3, #0
    d252:	d050      	beq.n	d2f6 <FlexCAN_IRQHandler+0x10e>
        {
            /* For legacy fifo, mb handler is FLEXCAN_IP_MB_HANDLE_RXFIFO(0) */
            u32MbHandle = mb_idx;
    d254:	9b07      	ldr	r3, [sp, #28]
    d256:	9309      	str	r3, [sp, #36]	; 0x24

            if ((TRUE == state->bIsLegacyFifoEn) && (mb_idx <= FLEXCAN_IP_LEGACY_RXFIFO_OVERFLOW))
    d258:	9b05      	ldr	r3, [sp, #20]
    d25a:	f893 3214 	ldrb.w	r3, [r3, #532]	; 0x214
    d25e:	2b00      	cmp	r3, #0
    d260:	d00b      	beq.n	d27a <FlexCAN_IRQHandler+0x92>
    d262:	9b07      	ldr	r3, [sp, #28]
    d264:	2b07      	cmp	r3, #7
    d266:	d808      	bhi.n	d27a <FlexCAN_IRQHandler+0x92>
            {
                FlexCAN_IRQHandlerRxFIFO(instance, mb_idx);
    d268:	f89d 300f 	ldrb.w	r3, [sp, #15]
    d26c:	9907      	ldr	r1, [sp, #28]
    d26e:	4618      	mov	r0, r3
    d270:	f7ff fac2 	bl	c7f8 <FlexCAN_IRQHandlerRxFIFO>
                u32MbHandle = (uint32)FLEXCAN_IP_MB_HANDLE_RXFIFO;
    d274:	2300      	movs	r3, #0
    d276:	9309      	str	r3, [sp, #36]	; 0x24
    d278:	e00d      	b.n	d296 <FlexCAN_IRQHandler+0xae>
            }
            else
            {
                /* Check mailbox completed reception */
                if (FLEXCAN_MB_RX_BUSY == state->mbs[u32MbHandle].state)
    d27a:	9a05      	ldr	r2, [sp, #20]
    d27c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    d27e:	011b      	lsls	r3, r3, #4
    d280:	4413      	add	r3, r2
    d282:	3304      	adds	r3, #4
    d284:	681b      	ldr	r3, [r3, #0]
    d286:	2b01      	cmp	r3, #1
    d288:	d105      	bne.n	d296 <FlexCAN_IRQHandler+0xae>
                {
                    FlexCAN_IRQHandlerRxMB(instance, mb_idx);
    d28a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    d28e:	9907      	ldr	r1, [sp, #28]
    d290:	4618      	mov	r0, r3
    d292:	f7ff f929 	bl	c4e8 <FlexCAN_IRQHandlerRxMB>
                }
            }

            /* Check mailbox completed transmission */
            if (FLEXCAN_MB_TX_BUSY == state->mbs[u32MbHandle].state)
    d296:	9a05      	ldr	r2, [sp, #20]
    d298:	9b09      	ldr	r3, [sp, #36]	; 0x24
    d29a:	011b      	lsls	r3, r3, #4
    d29c:	4413      	add	r3, r2
    d29e:	3304      	adds	r3, #4
    d2a0:	681b      	ldr	r3, [r3, #0]
    d2a2:	2b02      	cmp	r3, #2
    d2a4:	d105      	bne.n	d2b2 <FlexCAN_IRQHandler+0xca>
            {
                FlexCAN_IRQHandlerTxMB(instance, mb_idx);
    d2a6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    d2aa:	9907      	ldr	r1, [sp, #28]
    d2ac:	4618      	mov	r0, r3
    d2ae:	f7ff fa09 	bl	c6c4 <FlexCAN_IRQHandlerTxMB>
            }

            /* Check for spurious interrupt */
            if (FlexCAN_GetMsgBuffIntStatusFlag(base, mb_idx) != 0U)
    d2b2:	9907      	ldr	r1, [sp, #28]
    d2b4:	9806      	ldr	r0, [sp, #24]
    d2b6:	f7fe fdfe 	bl	beb6 <FlexCAN_GetMsgBuffIntStatusFlag>
    d2ba:	4603      	mov	r3, r0
    d2bc:	2b00      	cmp	r3, #0
    d2be:	d01a      	beq.n	d2f6 <FlexCAN_IRQHandler+0x10e>
            {
                if (state->mbs[u32MbHandle].state == FLEXCAN_MB_IDLE)
    d2c0:	9a05      	ldr	r2, [sp, #20]
    d2c2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    d2c4:	011b      	lsls	r3, r3, #4
    d2c6:	4413      	add	r3, r2
    d2c8:	3304      	adds	r3, #4
    d2ca:	681b      	ldr	r3, [r3, #0]
    d2cc:	2b00      	cmp	r3, #0
    d2ce:	d112      	bne.n	d2f6 <FlexCAN_IRQHandler+0x10e>
                {
                    /* In case of desynchronized status of the MB to avoid trapping in ISR
                    * clear the MB flag */
                    FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    d2d0:	9907      	ldr	r1, [sp, #28]
    d2d2:	9806      	ldr	r0, [sp, #24]
    d2d4:	f7fe fc3e 	bl	bb54 <FlexCAN_ClearMsgBuffIntStatusFlag>
            FlexCAN_ClearEnhancedRxFifoIntStatusFlag(base, FLEXCAN_IP_ENHANCED_RXFIFO_OVERFLOW);
            FlexCAN_ClearEnhancedRxFifoIntStatusFlag(base, FLEXCAN_IP_ENHANCED_RXFIFO_UNDERFLOW);
        }
    #endif /* End of (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) */
    }
}
    d2d8:	e00d      	b.n	d2f6 <FlexCAN_IRQHandler+0x10e>
        for (mb_idx = startMbIdx; mb_idx <= endMbIdx; mb_idx++)
    d2da:	9b02      	ldr	r3, [sp, #8]
    d2dc:	9307      	str	r3, [sp, #28]
    d2de:	e006      	b.n	d2ee <FlexCAN_IRQHandler+0x106>
            FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    d2e0:	9907      	ldr	r1, [sp, #28]
    d2e2:	9806      	ldr	r0, [sp, #24]
    d2e4:	f7fe fc36 	bl	bb54 <FlexCAN_ClearMsgBuffIntStatusFlag>
        for (mb_idx = startMbIdx; mb_idx <= endMbIdx; mb_idx++)
    d2e8:	9b07      	ldr	r3, [sp, #28]
    d2ea:	3301      	adds	r3, #1
    d2ec:	9307      	str	r3, [sp, #28]
    d2ee:	9a07      	ldr	r2, [sp, #28]
    d2f0:	9b01      	ldr	r3, [sp, #4]
    d2f2:	429a      	cmp	r2, r3
    d2f4:	d9f4      	bls.n	d2e0 <FlexCAN_IRQHandler+0xf8>
}
    d2f6:	bf00      	nop
    d2f8:	b00b      	add	sp, #44	; 0x2c
    d2fa:	f85d fb04 	ldr.w	pc, [sp], #4
    d2fe:	bf00      	nop
    d300:	000186d8 	.word	0x000186d8
    d304:	1fff9360 	.word	0x1fff9360

0000d308 <FlexCAN_Ip_ClearErrorStatus>:
 *                 transmission of a CAN frame.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_ClearErrorStatus_Activity */
void FlexCAN_Ip_ClearErrorStatus(uint8 instance, uint32 error)
{
    d308:	b084      	sub	sp, #16
    d30a:	4603      	mov	r3, r0
    d30c:	9100      	str	r1, [sp, #0]
    d30e:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    d312:	f89d 3007 	ldrb.w	r3, [sp, #7]
    d316:	4a05      	ldr	r2, [pc, #20]	; (d32c <FlexCAN_Ip_ClearErrorStatus+0x24>)
    d318:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d31c:	9303      	str	r3, [sp, #12]

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    base->ESR1 = error;
    d31e:	9b03      	ldr	r3, [sp, #12]
    d320:	9a00      	ldr	r2, [sp, #0]
    d322:	621a      	str	r2, [r3, #32]
}
    d324:	bf00      	nop
    d326:	b004      	add	sp, #16
    d328:	4770      	bx	lr
    d32a:	bf00      	nop
    d32c:	000186d8 	.word	0x000186d8

0000d330 <FlexCAN_Ip_GetErrorStatus>:
 *                 transmission of a CAN frame and some general status of the device.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetErrorStatus_Activity */
uint32 FlexCAN_Ip_GetErrorStatus(uint8 instance)
{
    d330:	b084      	sub	sp, #16
    d332:	4603      	mov	r3, r0
    d334:	f88d 3007 	strb.w	r3, [sp, #7]

    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    d338:	f89d 3007 	ldrb.w	r3, [sp, #7]
    d33c:	4a04      	ldr	r2, [pc, #16]	; (d350 <FlexCAN_Ip_GetErrorStatus+0x20>)
    d33e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d342:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    return (uint32)(base->ESR1);
    d344:	9b03      	ldr	r3, [sp, #12]
    d346:	6a1b      	ldr	r3, [r3, #32]
}
    d348:	4618      	mov	r0, r3
    d34a:	b004      	add	sp, #16
    d34c:	4770      	bx	lr
    d34e:	bf00      	nop
    d350:	000186d8 	.word	0x000186d8

0000d354 <FlexCAN_Ip_GetControllerTxErrorCounter>:
 *                 transmitted messages.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetControllerTxErrorCounter_Activity */
uint8 FlexCAN_Ip_GetControllerTxErrorCounter(uint8 instance)
{
    d354:	b084      	sub	sp, #16
    d356:	4603      	mov	r3, r0
    d358:	f88d 3007 	strb.w	r3, [sp, #7]

    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    d35c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    d360:	4a04      	ldr	r2, [pc, #16]	; (d374 <FlexCAN_Ip_GetControllerTxErrorCounter+0x20>)
    d362:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d366:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    return (uint8)((base->ECR & FLEXCAN_ECR_TXERRCNT_MASK) >> FLEXCAN_ECR_TXERRCNT_SHIFT);
    d368:	9b03      	ldr	r3, [sp, #12]
    d36a:	69db      	ldr	r3, [r3, #28]
    d36c:	b2db      	uxtb	r3, r3
}
    d36e:	4618      	mov	r0, r3
    d370:	b004      	add	sp, #16
    d372:	4770      	bx	lr
    d374:	000186d8 	.word	0x000186d8

0000d378 <FlexCAN_Ip_GetControllerRxErrorCounter>:
 *                 received messages.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetControllerRxErrorCounter_Activity */
uint8 FlexCAN_Ip_GetControllerRxErrorCounter(uint8 instance)
{
    d378:	b084      	sub	sp, #16
    d37a:	4603      	mov	r3, r0
    d37c:	f88d 3007 	strb.w	r3, [sp, #7]

    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    d380:	f89d 3007 	ldrb.w	r3, [sp, #7]
    d384:	4a05      	ldr	r2, [pc, #20]	; (d39c <FlexCAN_Ip_GetControllerRxErrorCounter+0x24>)
    d386:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d38a:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    return (uint8)((base->ECR & FLEXCAN_ECR_RXERRCNT_MASK) >> FLEXCAN_ECR_RXERRCNT_SHIFT);
    d38c:	9b03      	ldr	r3, [sp, #12]
    d38e:	69db      	ldr	r3, [r3, #28]
    d390:	0a1b      	lsrs	r3, r3, #8
    d392:	b2db      	uxtb	r3, r3
}
    d394:	4618      	mov	r0, r3
    d396:	b004      	add	sp, #16
    d398:	4770      	bx	lr
    d39a:	bf00      	nop
    d39c:	000186d8 	.word	0x000186d8

0000d3a0 <FlexCAN_Error_IRQHandler>:
 * This is not a public API as it is called whenever an interrupt occurs.
 *
 *END**************************************************************************/
/* implements  CAN_X_ERROR_ISR_Activity */
void FlexCAN_Error_IRQHandler(uint8 instance)
{
    d3a0:	b510      	push	{r4, lr}
    d3a2:	b086      	sub	sp, #24
    d3a4:	4603      	mov	r3, r0
    d3a6:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    d3aa:	f89d 3007 	ldrb.w	r3, [sp, #7]
    d3ae:	4a29      	ldr	r2, [pc, #164]	; (d454 <FlexCAN_Error_IRQHandler+0xb4>)
    d3b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d3b4:	9304      	str	r3, [sp, #16]
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    d3b6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    d3ba:	4a27      	ldr	r2, [pc, #156]	; (d458 <FlexCAN_Error_IRQHandler+0xb8>)
    d3bc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d3c0:	9303      	str	r3, [sp, #12]
    uint32 u32ErrStatus = 0U;
    d3c2:	2300      	movs	r3, #0
    d3c4:	9305      	str	r3, [sp, #20]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    /* Check if the instance initialized */
    if (NULL_PTR != state)
    d3c6:	9b03      	ldr	r3, [sp, #12]
    d3c8:	2b00      	cmp	r3, #0
    d3ca:	d03d      	beq.n	d448 <FlexCAN_Error_IRQHandler+0xa8>
    {
        /* Get error status to get value updated */
        u32ErrStatus = pBase->ESR1;
    d3cc:	9b04      	ldr	r3, [sp, #16]
    d3ce:	6a1b      	ldr	r3, [r3, #32]
    d3d0:	9305      	str	r3, [sp, #20]

        /* Check spurious interrupt */
        if (((uint32)0U != (u32ErrStatus & ((uint32)FLEXCAN_ESR1_ERRINT_MASK))) && ((uint32)0U != (pBase->CTRL1 & ((uint32)FLEXCAN_CTRL1_ERRMSK_MASK))))
    d3d2:	9b05      	ldr	r3, [sp, #20]
    d3d4:	f003 0302 	and.w	r3, r3, #2
    d3d8:	2b00      	cmp	r3, #0
    d3da:	d019      	beq.n	d410 <FlexCAN_Error_IRQHandler+0x70>
    d3dc:	9b04      	ldr	r3, [sp, #16]
    d3de:	685b      	ldr	r3, [r3, #4]
    d3e0:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
    d3e4:	2b00      	cmp	r3, #0
    d3e6:	d013      	beq.n	d410 <FlexCAN_Error_IRQHandler+0x70>
        {
            pBase->ESR1 = FLEXCAN_ESR1_ERRINT_MASK;
    d3e8:	9b04      	ldr	r3, [sp, #16]
    d3ea:	2202      	movs	r2, #2
    d3ec:	621a      	str	r2, [r3, #32]
            /* Invoke callback */
            if (state->error_callback != NULL_PTR)
    d3ee:	9b03      	ldr	r3, [sp, #12]
    d3f0:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
    d3f4:	2b00      	cmp	r3, #0
    d3f6:	d00b      	beq.n	d410 <FlexCAN_Error_IRQHandler+0x70>
            {
                state->error_callback(instance, FLEXCAN_EVENT_ERROR, u32ErrStatus, state);
    d3f8:	9b03      	ldr	r3, [sp, #12]
    d3fa:	f8d3 4208 	ldr.w	r4, [r3, #520]	; 0x208
    d3fe:	f89d 0007 	ldrb.w	r0, [sp, #7]
    d402:	9b03      	ldr	r3, [sp, #12]
    d404:	9a05      	ldr	r2, [sp, #20]
    d406:	2105      	movs	r1, #5
    d408:	47a0      	blx	r4
            #if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
                /* Get error status to get value updated due to user may handle ESR1 register */
                u32ErrStatus = pBase->ESR1;
    d40a:	9b04      	ldr	r3, [sp, #16]
    d40c:	6a1b      	ldr	r3, [r3, #32]
    d40e:	9305      	str	r3, [sp, #20]
            }
        }

    #if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        /* Check if this is spurious interrupt */
        if (((uint32)0U != (u32ErrStatus & ((uint32)FLEXCAN_ESR1_ERRINT_FAST_MASK))) && ((uint32)0U != (pBase->CTRL2 & ((uint32)FLEXCAN_CTRL2_ERRMSK_FAST_MASK))))
    d410:	9b05      	ldr	r3, [sp, #20]
    d412:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    d416:	2b00      	cmp	r3, #0
    d418:	d019      	beq.n	d44e <FlexCAN_Error_IRQHandler+0xae>
    d41a:	9b04      	ldr	r3, [sp, #16]
    d41c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    d41e:	2b00      	cmp	r3, #0
    d420:	da15      	bge.n	d44e <FlexCAN_Error_IRQHandler+0xae>
        {
            pBase->ESR1 = FLEXCAN_ESR1_ERRINT_FAST_MASK;
    d422:	9b04      	ldr	r3, [sp, #16]
    d424:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    d428:	621a      	str	r2, [r3, #32]
            /* Invoke callback */
            if (state->error_callback != NULL_PTR)
    d42a:	9b03      	ldr	r3, [sp, #12]
    d42c:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
    d430:	2b00      	cmp	r3, #0
    d432:	d00c      	beq.n	d44e <FlexCAN_Error_IRQHandler+0xae>
            {
                state->error_callback(instance, FLEXCAN_EVENT_ERROR_FAST, u32ErrStatus, state);
    d434:	9b03      	ldr	r3, [sp, #12]
    d436:	f8d3 4208 	ldr.w	r4, [r3, #520]	; 0x208
    d43a:	f89d 0007 	ldrb.w	r0, [sp, #7]
    d43e:	9b03      	ldr	r3, [sp, #12]
    d440:	9a05      	ldr	r2, [sp, #20]
    d442:	2106      	movs	r1, #6
    d444:	47a0      	blx	r4
    }
    else
    {
        (pBase->ESR1) = FLEXCAN_IP_ERROR_INT;
    }
}
    d446:	e002      	b.n	d44e <FlexCAN_Error_IRQHandler+0xae>
        (pBase->ESR1) = FLEXCAN_IP_ERROR_INT;
    d448:	9b04      	ldr	r3, [sp, #16]
    d44a:	4a04      	ldr	r2, [pc, #16]	; (d45c <FlexCAN_Error_IRQHandler+0xbc>)
    d44c:	621a      	str	r2, [r3, #32]
}
    d44e:	bf00      	nop
    d450:	b006      	add	sp, #24
    d452:	bd10      	pop	{r4, pc}
    d454:	000186d8 	.word	0x000186d8
    d458:	1fff9360 	.word	0x1fff9360
    d45c:	00300002 	.word	0x00300002

0000d460 <FlexCAN_BusOff_IRQHandler>:
 * This is not a public API as it is called whenever an interrupt occurs.
 *
 *END**************************************************************************/
/* implements CAN_X_BUSOFF_ISR_Activity */
void FlexCAN_BusOff_IRQHandler(uint8 instance)
{
    d460:	b510      	push	{r4, lr}
    d462:	b086      	sub	sp, #24
    d464:	4603      	mov	r3, r0
    d466:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    d46a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    d46e:	4a3a      	ldr	r2, [pc, #232]	; (d558 <FlexCAN_BusOff_IRQHandler+0xf8>)
    d470:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d474:	9304      	str	r3, [sp, #16]
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    d476:	f89d 3007 	ldrb.w	r3, [sp, #7]
    d47a:	4a38      	ldr	r2, [pc, #224]	; (d55c <FlexCAN_BusOff_IRQHandler+0xfc>)
    d47c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d480:	9303      	str	r3, [sp, #12]
    uint32 u32ErrStatus = 0U;
    d482:	2300      	movs	r3, #0
    d484:	9305      	str	r3, [sp, #20]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    /* Check If Driver initialized */
    if (NULL_PTR != state)
    d486:	9b03      	ldr	r3, [sp, #12]
    d488:	2b00      	cmp	r3, #0
    d48a:	d05f      	beq.n	d54c <FlexCAN_BusOff_IRQHandler+0xec>
    {
        /* Get error status to get value updated */
        u32ErrStatus = base->ESR1;
    d48c:	9b04      	ldr	r3, [sp, #16]
    d48e:	6a1b      	ldr	r3, [r3, #32]
    d490:	9305      	str	r3, [sp, #20]

        /* Check spurious interrupt */
        if (((uint32)0U != (u32ErrStatus & ((uint32)FLEXCAN_ESR1_TWRNINT_MASK))) && (0U != (base->CTRL1 & ((uint32)FLEXCAN_CTRL1_TWRNMSK_MASK))))
    d492:	9b05      	ldr	r3, [sp, #20]
    d494:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
    d498:	2b00      	cmp	r3, #0
    d49a:	d01a      	beq.n	d4d2 <FlexCAN_BusOff_IRQHandler+0x72>
    d49c:	9b04      	ldr	r3, [sp, #16]
    d49e:	685b      	ldr	r3, [r3, #4]
    d4a0:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    d4a4:	2b00      	cmp	r3, #0
    d4a6:	d014      	beq.n	d4d2 <FlexCAN_BusOff_IRQHandler+0x72>
        {
            base->ESR1 = FLEXCAN_ESR1_TWRNINT_MASK;
    d4a8:	9b04      	ldr	r3, [sp, #16]
    d4aa:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    d4ae:	621a      	str	r2, [r3, #32]
            /* Invoke callback */
            if (state->error_callback != NULL_PTR)
    d4b0:	9b03      	ldr	r3, [sp, #12]
    d4b2:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
    d4b6:	2b00      	cmp	r3, #0
    d4b8:	d00b      	beq.n	d4d2 <FlexCAN_BusOff_IRQHandler+0x72>
            {
                state->error_callback(instance, FLEXCAN_EVENT_TX_WARNING, u32ErrStatus, state);
    d4ba:	9b03      	ldr	r3, [sp, #12]
    d4bc:	f8d3 4208 	ldr.w	r4, [r3, #520]	; 0x208
    d4c0:	f89d 0007 	ldrb.w	r0, [sp, #7]
    d4c4:	9b03      	ldr	r3, [sp, #12]
    d4c6:	9a05      	ldr	r2, [sp, #20]
    d4c8:	2109      	movs	r1, #9
    d4ca:	47a0      	blx	r4
                /* Get error status to get value updated due to user may handle ESR1 register */
                u32ErrStatus = base->ESR1;
    d4cc:	9b04      	ldr	r3, [sp, #16]
    d4ce:	6a1b      	ldr	r3, [r3, #32]
    d4d0:	9305      	str	r3, [sp, #20]
            }
        }

        /* Check spurious interrupt */
        if (((uint32)0U != (u32ErrStatus & ((uint32)FLEXCAN_ESR1_RWRNINT_MASK))) && (0U != (base->CTRL1 & ((uint32)FLEXCAN_CTRL1_RWRNMSK_MASK))))
    d4d2:	9b05      	ldr	r3, [sp, #20]
    d4d4:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
    d4d8:	2b00      	cmp	r3, #0
    d4da:	d01a      	beq.n	d512 <FlexCAN_BusOff_IRQHandler+0xb2>
    d4dc:	9b04      	ldr	r3, [sp, #16]
    d4de:	685b      	ldr	r3, [r3, #4]
    d4e0:	f403 6380 	and.w	r3, r3, #1024	; 0x400
    d4e4:	2b00      	cmp	r3, #0
    d4e6:	d014      	beq.n	d512 <FlexCAN_BusOff_IRQHandler+0xb2>
        {
            base->ESR1 = FLEXCAN_ESR1_RWRNINT_MASK;
    d4e8:	9b04      	ldr	r3, [sp, #16]
    d4ea:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    d4ee:	621a      	str	r2, [r3, #32]
            /* Invoke callback */
            if (state->error_callback != NULL_PTR)
    d4f0:	9b03      	ldr	r3, [sp, #12]
    d4f2:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
    d4f6:	2b00      	cmp	r3, #0
    d4f8:	d00b      	beq.n	d512 <FlexCAN_BusOff_IRQHandler+0xb2>
            {
                state->error_callback(instance, FLEXCAN_EVENT_RX_WARNING, u32ErrStatus, state);
    d4fa:	9b03      	ldr	r3, [sp, #12]
    d4fc:	f8d3 4208 	ldr.w	r4, [r3, #520]	; 0x208
    d500:	f89d 0007 	ldrb.w	r0, [sp, #7]
    d504:	9b03      	ldr	r3, [sp, #12]
    d506:	9a05      	ldr	r2, [sp, #20]
    d508:	2108      	movs	r1, #8
    d50a:	47a0      	blx	r4
                /* Get error status to get value updated due to user may handle ESR1 register */
                u32ErrStatus = base->ESR1;
    d50c:	9b04      	ldr	r3, [sp, #16]
    d50e:	6a1b      	ldr	r3, [r3, #32]
    d510:	9305      	str	r3, [sp, #20]
            }
        }

        /* Check spurious interrupt */
        if (((uint32)0U != (u32ErrStatus & ((uint32)FLEXCAN_ESR1_BOFFINT_MASK))) && ((uint32)0U != (base->CTRL1 & ((uint32)FLEXCAN_CTRL1_BOFFMSK_MASK))))
    d512:	9b05      	ldr	r3, [sp, #20]
    d514:	f003 0304 	and.w	r3, r3, #4
    d518:	2b00      	cmp	r3, #0
    d51a:	d01a      	beq.n	d552 <FlexCAN_BusOff_IRQHandler+0xf2>
    d51c:	9b04      	ldr	r3, [sp, #16]
    d51e:	685b      	ldr	r3, [r3, #4]
    d520:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
    d524:	2b00      	cmp	r3, #0
    d526:	d014      	beq.n	d552 <FlexCAN_BusOff_IRQHandler+0xf2>
        {
            base->ESR1 = FLEXCAN_ESR1_BOFFINT_MASK;
    d528:	9b04      	ldr	r3, [sp, #16]
    d52a:	2204      	movs	r2, #4
    d52c:	621a      	str	r2, [r3, #32]
            /* Invoke callback */
            if (state->error_callback != NULL_PTR)
    d52e:	9b03      	ldr	r3, [sp, #12]
    d530:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
    d534:	2b00      	cmp	r3, #0
    d536:	d00c      	beq.n	d552 <FlexCAN_BusOff_IRQHandler+0xf2>
            {
                state->error_callback(instance, FLEXCAN_EVENT_BUSOFF, u32ErrStatus, state);
    d538:	9b03      	ldr	r3, [sp, #12]
    d53a:	f8d3 4208 	ldr.w	r4, [r3, #520]	; 0x208
    d53e:	f89d 0007 	ldrb.w	r0, [sp, #7]
    d542:	9b03      	ldr	r3, [sp, #12]
    d544:	9a05      	ldr	r2, [sp, #20]
    d546:	2107      	movs	r1, #7
    d548:	47a0      	blx	r4
    }
    else
    {
        base->ESR1 = FLEXCAN_IP_BUS_OFF_INT;
    }
}
    d54a:	e002      	b.n	d552 <FlexCAN_BusOff_IRQHandler+0xf2>
        base->ESR1 = FLEXCAN_IP_BUS_OFF_INT;
    d54c:	9b04      	ldr	r3, [sp, #16]
    d54e:	4a04      	ldr	r2, [pc, #16]	; (d560 <FlexCAN_BusOff_IRQHandler+0x100>)
    d550:	621a      	str	r2, [r3, #32]
}
    d552:	bf00      	nop
    d554:	b006      	add	sp, #24
    d556:	bd10      	pop	{r4, pc}
    d558:	000186d8 	.word	0x000186d8
    d55c:	1fff9360 	.word	0x1fff9360
    d560:	000b0004 	.word	0x000b0004

0000d564 <FlexCAN_Ip_SendBlocking>:
                                              const Flexcan_Ip_DataInfoType * tx_info,
                                              uint32 msg_id,
                                              const uint8 * mb_data,
                                              uint32 timeout_ms
                                             )
{
    d564:	b500      	push	{lr}
    d566:	b091      	sub	sp, #68	; 0x44
    d568:	9204      	str	r2, [sp, #16]
    d56a:	9303      	str	r3, [sp, #12]
    d56c:	4603      	mov	r3, r0
    d56e:	f88d 3017 	strb.w	r3, [sp, #23]
    d572:	460b      	mov	r3, r1
    d574:	f88d 3016 	strb.w	r3, [sp, #22]
    Flexcan_Ip_StatusType result;
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    d578:	f89d 3017 	ldrb.w	r3, [sp, #23]
    d57c:	4a5f      	ldr	r2, [pc, #380]	; (d6fc <FlexCAN_Ip_SendBlocking+0x198>)
    d57e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d582:	930d      	str	r3, [sp, #52]	; 0x34
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    d584:	f89d 3017 	ldrb.w	r3, [sp, #23]
    d588:	4a5d      	ldr	r2, [pc, #372]	; (d700 <FlexCAN_Ip_SendBlocking+0x19c>)
    d58a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d58e:	930c      	str	r3, [sp, #48]	; 0x30

    uint32 timeStart = 0U;
    d590:	2300      	movs	r3, #0
    d592:	9307      	str	r3, [sp, #28]
    uint32 timeElapsed = 0U;
    d594:	2300      	movs	r3, #0
    d596:	930e      	str	r3, [sp, #56]	; 0x38
    uint32 mS2Ticks = OsIf_MicrosToTicks((timeout_ms * 1000U), FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    d598:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    d59a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    d59e:	fb02 f303 	mul.w	r3, r2, r3
    d5a2:	2100      	movs	r1, #0
    d5a4:	4618      	mov	r0, r3
    d5a6:	f7f4 fd0d 	bl	1fc4 <OsIf_MicrosToTicks>
    d5aa:	900b      	str	r0, [sp, #44]	; 0x2c
    uint32 uS2Ticks = 0U;
    d5ac:	2300      	movs	r3, #0
    d5ae:	930a      	str	r3, [sp, #40]	; 0x28
    uint32 flexcan_mb_config = 0;
    d5b0:	2300      	movs	r3, #0
    d5b2:	9309      	str	r3, [sp, #36]	; 0x24

    volatile uint32 * flexcan_mb = NULL_PTR;
    d5b4:	2300      	movs	r3, #0
    d5b6:	9308      	str	r3, [sp, #32]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert(tx_info != NULL_PTR);
#endif

    result = FlexCAN_StartSendData(instance, mb_idx, tx_info, msg_id, mb_data);
    d5b8:	f89d 1016 	ldrb.w	r1, [sp, #22]
    d5bc:	f89d 0017 	ldrb.w	r0, [sp, #23]
    d5c0:	9b12      	ldr	r3, [sp, #72]	; 0x48
    d5c2:	9300      	str	r3, [sp, #0]
    d5c4:	9b03      	ldr	r3, [sp, #12]
    d5c6:	9a04      	ldr	r2, [sp, #16]
    d5c8:	f7fe feaa 	bl	c320 <FlexCAN_StartSendData>
    d5cc:	900f      	str	r0, [sp, #60]	; 0x3c

    if (FLEXCAN_STATUS_SUCCESS == result)
    d5ce:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    d5d0:	2b00      	cmp	r3, #0
    d5d2:	f040 808d 	bne.w	d6f0 <FlexCAN_Ip_SendBlocking+0x18c>
    {
        timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    d5d6:	2000      	movs	r0, #0
    d5d8:	f7f4 fca8 	bl	1f2c <OsIf_GetCounter>
    d5dc:	4603      	mov	r3, r0
    d5de:	9307      	str	r3, [sp, #28]
        while (FlexCAN_GetBuffStatusFlag(base, mb_idx) != 1U)
    d5e0:	e00f      	b.n	d602 <FlexCAN_Ip_SendBlocking+0x9e>
        {
            timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    d5e2:	ab07      	add	r3, sp, #28
    d5e4:	2100      	movs	r1, #0
    d5e6:	4618      	mov	r0, r3
    d5e8:	f7f4 fcb9 	bl	1f5e <OsIf_GetElapsed>
    d5ec:	4602      	mov	r2, r0
    d5ee:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    d5f0:	4413      	add	r3, r2
    d5f2:	930e      	str	r3, [sp, #56]	; 0x38
            if (timeElapsed >= mS2Ticks)
    d5f4:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    d5f6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d5f8:	429a      	cmp	r2, r3
    d5fa:	d302      	bcc.n	d602 <FlexCAN_Ip_SendBlocking+0x9e>
            {
                result = FLEXCAN_STATUS_TIMEOUT;
    d5fc:	2303      	movs	r3, #3
    d5fe:	930f      	str	r3, [sp, #60]	; 0x3c
                break;
    d600:	e008      	b.n	d614 <FlexCAN_Ip_SendBlocking+0xb0>
        while (FlexCAN_GetBuffStatusFlag(base, mb_idx) != 1U)
    d602:	f89d 3016 	ldrb.w	r3, [sp, #22]
    d606:	4619      	mov	r1, r3
    d608:	980d      	ldr	r0, [sp, #52]	; 0x34
    d60a:	f7fe fab6 	bl	bb7a <FlexCAN_GetBuffStatusFlag>
    d60e:	4603      	mov	r3, r0
    d610:	2b01      	cmp	r3, #1
    d612:	d1e6      	bne.n	d5e2 <FlexCAN_Ip_SendBlocking+0x7e>
            }
        }

        if ((FLEXCAN_STATUS_TIMEOUT == result) && (state->mbs[mb_idx].state != FLEXCAN_MB_IDLE))
    d614:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    d616:	2b03      	cmp	r3, #3
    d618:	d15c      	bne.n	d6d4 <FlexCAN_Ip_SendBlocking+0x170>
    d61a:	f89d 3016 	ldrb.w	r3, [sp, #22]
    d61e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    d620:	011b      	lsls	r3, r3, #4
    d622:	4413      	add	r3, r2
    d624:	3304      	adds	r3, #4
    d626:	681b      	ldr	r3, [r3, #0]
    d628:	2b00      	cmp	r3, #0
    d62a:	d053      	beq.n	d6d4 <FlexCAN_Ip_SendBlocking+0x170>
        {
                /* Clear message buffer flag */
                FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    d62c:	f89d 3016 	ldrb.w	r3, [sp, #22]
    d630:	4619      	mov	r1, r3
    d632:	980d      	ldr	r0, [sp, #52]	; 0x34
    d634:	f7fe fa8e 	bl	bb54 <FlexCAN_ClearMsgBuffIntStatusFlag>
                flexcan_mb = FlexCAN_GetMsgBuffRegion(base, mb_idx);
    d638:	f89d 3016 	ldrb.w	r3, [sp, #22]
    d63c:	4619      	mov	r1, r3
    d63e:	980d      	ldr	r0, [sp, #52]	; 0x34
    d640:	f001 f968 	bl	e914 <FlexCAN_GetMsgBuffRegion>
    d644:	9008      	str	r0, [sp, #32]
                flexcan_mb_config = * flexcan_mb;
    d646:	9b08      	ldr	r3, [sp, #32]
    d648:	681b      	ldr	r3, [r3, #0]
    d64a:	9309      	str	r3, [sp, #36]	; 0x24
                /* Reset the code */
                flexcan_mb_config &= (uint32)(~FLEXCAN_IP_CS_CODE_MASK);
    d64c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    d64e:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    d652:	9309      	str	r3, [sp, #36]	; 0x24
                flexcan_mb_config |= ((uint32)(((uint32)FLEXCAN_TX_ABORT & (uint32)0x1F) << (uint8)FLEXCAN_IP_CS_CODE_SHIFT) & (uint32)FLEXCAN_IP_CS_CODE_MASK);
    d654:	9b09      	ldr	r3, [sp, #36]	; 0x24
    d656:	f043 6310 	orr.w	r3, r3, #150994944	; 0x9000000
    d65a:	9309      	str	r3, [sp, #36]	; 0x24
                *flexcan_mb = flexcan_mb_config;
    d65c:	9b08      	ldr	r3, [sp, #32]
    d65e:	9a09      	ldr	r2, [sp, #36]	; 0x24
    d660:	601a      	str	r2, [r3, #0]

                /* Wait to finish abort operation */
                uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    d662:	2100      	movs	r1, #0
    d664:	4827      	ldr	r0, [pc, #156]	; (d704 <FlexCAN_Ip_SendBlocking+0x1a0>)
    d666:	f7f4 fcad 	bl	1fc4 <OsIf_MicrosToTicks>
    d66a:	900a      	str	r0, [sp, #40]	; 0x28
                timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    d66c:	2000      	movs	r0, #0
    d66e:	f7f4 fc5d 	bl	1f2c <OsIf_GetCounter>
    d672:	4603      	mov	r3, r0
    d674:	9307      	str	r3, [sp, #28]
                 timeElapsed = 0U;
    d676:	2300      	movs	r3, #0
    d678:	930e      	str	r3, [sp, #56]	; 0x38
                while (0U == FlexCAN_GetBuffStatusFlag(base, mb_idx))
    d67a:	e00f      	b.n	d69c <FlexCAN_Ip_SendBlocking+0x138>
                {
                    timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    d67c:	ab07      	add	r3, sp, #28
    d67e:	2100      	movs	r1, #0
    d680:	4618      	mov	r0, r3
    d682:	f7f4 fc6c 	bl	1f5e <OsIf_GetElapsed>
    d686:	4602      	mov	r2, r0
    d688:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    d68a:	4413      	add	r3, r2
    d68c:	930e      	str	r3, [sp, #56]	; 0x38
                    if (timeElapsed >= uS2Ticks)
    d68e:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    d690:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    d692:	429a      	cmp	r2, r3
    d694:	d302      	bcc.n	d69c <FlexCAN_Ip_SendBlocking+0x138>
                    {
                        result = FLEXCAN_STATUS_TIMEOUT;
    d696:	2303      	movs	r3, #3
    d698:	930f      	str	r3, [sp, #60]	; 0x3c
                        break;
    d69a:	e008      	b.n	d6ae <FlexCAN_Ip_SendBlocking+0x14a>
                while (0U == FlexCAN_GetBuffStatusFlag(base, mb_idx))
    d69c:	f89d 3016 	ldrb.w	r3, [sp, #22]
    d6a0:	4619      	mov	r1, r3
    d6a2:	980d      	ldr	r0, [sp, #52]	; 0x34
    d6a4:	f7fe fa69 	bl	bb7a <FlexCAN_GetBuffStatusFlag>
    d6a8:	4603      	mov	r3, r0
    d6aa:	2b00      	cmp	r3, #0
    d6ac:	d0e6      	beq.n	d67c <FlexCAN_Ip_SendBlocking+0x118>
                    }
                }

                flexcan_mb_config = *flexcan_mb;
    d6ae:	9b08      	ldr	r3, [sp, #32]
    d6b0:	681b      	ldr	r3, [r3, #0]
    d6b2:	9309      	str	r3, [sp, #36]	; 0x24
                /* Check if the MBs have been safely Inactivated */
                if ((uint32)FLEXCAN_TX_INACTIVE == ((flexcan_mb_config & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT))
    d6b4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    d6b6:	0e1b      	lsrs	r3, r3, #24
    d6b8:	f003 030f 	and.w	r3, r3, #15
    d6bc:	2b08      	cmp	r3, #8
    d6be:	d101      	bne.n	d6c4 <FlexCAN_Ip_SendBlocking+0x160>
                {
                    /* Transmission have occurred */
                    result = FLEXCAN_STATUS_SUCCESS;
    d6c0:	2300      	movs	r3, #0
    d6c2:	930f      	str	r3, [sp, #60]	; 0x3c
                }

                if ((uint32)FLEXCAN_TX_ABORT == ((flexcan_mb_config & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT))
    d6c4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    d6c6:	0e1b      	lsrs	r3, r3, #24
    d6c8:	f003 030f 	and.w	r3, r3, #15
    d6cc:	2b09      	cmp	r3, #9
    d6ce:	d101      	bne.n	d6d4 <FlexCAN_Ip_SendBlocking+0x170>
                {
                    /* Transmission have been aborted */
                    result = FLEXCAN_STATUS_TIMEOUT;
    d6d0:	2303      	movs	r3, #3
    d6d2:	930f      	str	r3, [sp, #60]	; 0x3c
                }
        }

        /* Clear message buffer flag */
        FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    d6d4:	f89d 3016 	ldrb.w	r3, [sp, #22]
    d6d8:	4619      	mov	r1, r3
    d6da:	980d      	ldr	r0, [sp, #52]	; 0x34
    d6dc:	f7fe fa3a 	bl	bb54 <FlexCAN_ClearMsgBuffIntStatusFlag>

        state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;
    d6e0:	f89d 3016 	ldrb.w	r3, [sp, #22]
    d6e4:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    d6e6:	011b      	lsls	r3, r3, #4
    d6e8:	4413      	add	r3, r2
    d6ea:	3304      	adds	r3, #4
    d6ec:	2200      	movs	r2, #0
    d6ee:	601a      	str	r2, [r3, #0]
    }
    return result;
    d6f0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
}
    d6f2:	4618      	mov	r0, r3
    d6f4:	b011      	add	sp, #68	; 0x44
    d6f6:	f85d fb04 	ldr.w	pc, [sp], #4
    d6fa:	bf00      	nop
    d6fc:	000186d8 	.word	0x000186d8
    d700:	1fff9360 	.word	0x1fff9360
    d704:	000f4240 	.word	0x000f4240

0000d708 <FlexCAN_Ip_SetRxMbGlobalMask_Privileged>:
 *
 *END**************************************************************************/

/* implements FlexCAN_Ip_SetRxMbGlobalMask_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetRxMbGlobalMask_Privileged(uint8 instance, uint32 mask)
{
    d708:	b500      	push	{lr}
    d70a:	b087      	sub	sp, #28
    d70c:	4603      	mov	r3, r0
    d70e:	9100      	str	r1, [sp, #0]
    d710:	f88d 3007 	strb.w	r3, [sp, #7]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    d714:	2300      	movs	r3, #0
    d716:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    d718:	2300      	movs	r3, #0
    d71a:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    d71c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    d720:	4a1c      	ldr	r2, [pc, #112]	; (d794 <FlexCAN_Ip_SetRxMbGlobalMask_Privileged+0x8c>)
    d722:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d726:	9303      	str	r3, [sp, #12]
#endif

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    d728:	9803      	ldr	r0, [sp, #12]
    d72a:	f7fe f9b9 	bl	baa0 <FlexCAN_IsEnabled>
    d72e:	4603      	mov	r3, r0
    d730:	2b00      	cmp	r3, #0
    d732:	bf14      	ite	ne
    d734:	2301      	movne	r3, #1
    d736:	2300      	moveq	r3, #0
    d738:	b2db      	uxtb	r3, r3
    d73a:	f083 0301 	eor.w	r3, r3, #1
    d73e:	b2db      	uxtb	r3, r3
    d740:	f88d 300b 	strb.w	r3, [sp, #11]
    d744:	f89d 300b 	ldrb.w	r3, [sp, #11]
    d748:	f003 0301 	and.w	r3, r3, #1
    d74c:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    d750:	f89d 300b 	ldrb.w	r3, [sp, #11]
    d754:	2b00      	cmp	r3, #0
    d756:	d003      	beq.n	d760 <FlexCAN_Ip_SetRxMbGlobalMask_Privileged+0x58>
    {
        result = FlexCAN_Enable(pBase);
    d758:	9803      	ldr	r0, [sp, #12]
    d75a:	f001 f9c3 	bl	eae4 <FlexCAN_Enable>
    d75e:	9005      	str	r0, [sp, #20]
    if ((FALSE == freeze) && (FLEXCAN_STATUS_SUCCESS == result))
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif
    if (FLEXCAN_STATUS_SUCCESS == result)
    d760:	9b05      	ldr	r3, [sp, #20]
    d762:	2b00      	cmp	r3, #0
    d764:	d103      	bne.n	d76e <FlexCAN_Ip_SetRxMbGlobalMask_Privileged+0x66>
    {
        FlexCAN_SetRxMsgBuffGlobalMask(pBase, mask);
    d766:	9900      	ldr	r1, [sp, #0]
    d768:	9803      	ldr	r0, [sp, #12]
    d76a:	f7fe fbc3 	bl	bef4 <FlexCAN_SetRxMsgBuffGlobalMask>
    }

    if (TRUE == disabled)
    d76e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    d772:	2b00      	cmp	r3, #0
    d774:	d008      	beq.n	d788 <FlexCAN_Ip_SetRxMbGlobalMask_Privileged+0x80>
    {
        status = FlexCAN_Disable(pBase);
    d776:	9803      	ldr	r0, [sp, #12]
    d778:	f001 fa32 	bl	ebe0 <FlexCAN_Disable>
    d77c:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    d77e:	9b04      	ldr	r3, [sp, #16]
    d780:	2b00      	cmp	r3, #0
    d782:	d001      	beq.n	d788 <FlexCAN_Ip_SetRxMbGlobalMask_Privileged+0x80>
        {
            result = status;
    d784:	9b04      	ldr	r3, [sp, #16]
    d786:	9305      	str	r3, [sp, #20]
        }
    }
    return result;
    d788:	9b05      	ldr	r3, [sp, #20]
}
    d78a:	4618      	mov	r0, r3
    d78c:	b007      	add	sp, #28
    d78e:	f85d fb04 	ldr.w	pc, [sp], #4
    d792:	bf00      	nop
    d794:	000186d8 	.word	0x000186d8

0000d798 <FlexCAN_Ip_EnterFreezeMode_Privileged>:
 * Description   : Enter Driver In freeze Mode.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_EnterFreezeMode_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_EnterFreezeMode_Privileged(uint8 instance)
{
    d798:	b500      	push	{lr}
    d79a:	b085      	sub	sp, #20
    d79c:	4603      	mov	r3, r0
    d79e:	f88d 3007 	strb.w	r3, [sp, #7]
        FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    d7a2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    d7a6:	4a06      	ldr	r2, [pc, #24]	; (d7c0 <FlexCAN_Ip_EnterFreezeMode_Privileged+0x28>)
    d7a8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d7ac:	9303      	str	r3, [sp, #12]
        return FlexCAN_EnterFreezeMode(base);
    d7ae:	9803      	ldr	r0, [sp, #12]
    d7b0:	f001 f94c 	bl	ea4c <FlexCAN_EnterFreezeMode>
    d7b4:	4603      	mov	r3, r0
}
    d7b6:	4618      	mov	r0, r3
    d7b8:	b005      	add	sp, #20
    d7ba:	f85d fb04 	ldr.w	pc, [sp], #4
    d7be:	bf00      	nop
    d7c0:	000186d8 	.word	0x000186d8

0000d7c4 <FlexCAN_Ip_ExitFreezeMode_Privileged>:
 * Description   : Exit Driver from freeze Mode.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_ExitFreezeMode_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_ExitFreezeMode_Privileged(uint8 instance)
{
    d7c4:	b500      	push	{lr}
    d7c6:	b085      	sub	sp, #20
    d7c8:	4603      	mov	r3, r0
    d7ca:	f88d 3007 	strb.w	r3, [sp, #7]
        FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    d7ce:	f89d 3007 	ldrb.w	r3, [sp, #7]
    d7d2:	4a06      	ldr	r2, [pc, #24]	; (d7ec <FlexCAN_Ip_ExitFreezeMode_Privileged+0x28>)
    d7d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d7d8:	9303      	str	r3, [sp, #12]
        return FlexCAN_ExitFreezeMode(base);
    d7da:	9803      	ldr	r0, [sp, #12]
    d7dc:	f001 f9be 	bl	eb5c <FlexCAN_ExitFreezeMode>
    d7e0:	4603      	mov	r3, r0
}
    d7e2:	4618      	mov	r0, r3
    d7e4:	b005      	add	sp, #20
    d7e6:	f85d fb04 	ldr.w	pc, [sp], #4
    d7ea:	bf00      	nop
    d7ec:	000186d8 	.word	0x000186d8

0000d7f0 <FlexCAN_Ip_SetRxIndividualMask_Privileged>:
 * Description   : Set Rx individual mask as absolute value provided by mask parameter
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetRxIndividualMask_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetRxIndividualMask_Privileged(uint8 instance, uint8 mb_idx, uint32 mask)
{
    d7f0:	b500      	push	{lr}
    d7f2:	b087      	sub	sp, #28
    d7f4:	4603      	mov	r3, r0
    d7f6:	9200      	str	r2, [sp, #0]
    d7f8:	f88d 3007 	strb.w	r3, [sp, #7]
    d7fc:	460b      	mov	r3, r1
    d7fe:	f88d 3006 	strb.w	r3, [sp, #6]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    d802:	2300      	movs	r3, #0
    d804:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    d806:	2300      	movs	r3, #0
    d808:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    d80a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    d80e:	4a1e      	ldr	r2, [pc, #120]	; (d888 <FlexCAN_Ip_SetRxIndividualMask_Privileged+0x98>)
    d810:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d814:	9303      	str	r3, [sp, #12]
    }
    else
    {
#endif

    boolean disabled = !FlexCAN_IsEnabled(pBase);
    d816:	9803      	ldr	r0, [sp, #12]
    d818:	f7fe f942 	bl	baa0 <FlexCAN_IsEnabled>
    d81c:	4603      	mov	r3, r0
    d81e:	2b00      	cmp	r3, #0
    d820:	bf14      	ite	ne
    d822:	2301      	movne	r3, #1
    d824:	2300      	moveq	r3, #0
    d826:	b2db      	uxtb	r3, r3
    d828:	f083 0301 	eor.w	r3, r3, #1
    d82c:	b2db      	uxtb	r3, r3
    d82e:	f88d 300b 	strb.w	r3, [sp, #11]
    d832:	f89d 300b 	ldrb.w	r3, [sp, #11]
    d836:	f003 0301 	and.w	r3, r3, #1
    d83a:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    d83e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    d842:	2b00      	cmp	r3, #0
    d844:	d003      	beq.n	d84e <FlexCAN_Ip_SetRxIndividualMask_Privileged+0x5e>
    {
        result = FlexCAN_Enable(pBase);
    d846:	9803      	ldr	r0, [sp, #12]
    d848:	f001 f94c 	bl	eae4 <FlexCAN_Enable>
    d84c:	9005      	str	r0, [sp, #20]
    if ((FALSE == freeze) && (FLEXCAN_STATUS_SUCCESS == result))
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif
    if (FLEXCAN_STATUS_SUCCESS == result)
    d84e:	9b05      	ldr	r3, [sp, #20]
    d850:	2b00      	cmp	r3, #0
    d852:	d106      	bne.n	d862 <FlexCAN_Ip_SetRxIndividualMask_Privileged+0x72>
    {
        FlexCAN_SetRxIndividualMask(pBase, mb_idx, mask);
    d854:	f89d 3006 	ldrb.w	r3, [sp, #6]
    d858:	9a00      	ldr	r2, [sp, #0]
    d85a:	4619      	mov	r1, r3
    d85c:	9803      	ldr	r0, [sp, #12]
    d85e:	f7fe fb52 	bl	bf06 <FlexCAN_SetRxIndividualMask>
    }

    if (TRUE == disabled)
    d862:	f89d 300b 	ldrb.w	r3, [sp, #11]
    d866:	2b00      	cmp	r3, #0
    d868:	d008      	beq.n	d87c <FlexCAN_Ip_SetRxIndividualMask_Privileged+0x8c>
    {
        status = FlexCAN_Disable(pBase);
    d86a:	9803      	ldr	r0, [sp, #12]
    d86c:	f001 f9b8 	bl	ebe0 <FlexCAN_Disable>
    d870:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    d872:	9b04      	ldr	r3, [sp, #16]
    d874:	2b00      	cmp	r3, #0
    d876:	d001      	beq.n	d87c <FlexCAN_Ip_SetRxIndividualMask_Privileged+0x8c>
        {
            result = status;
    d878:	9b04      	ldr	r3, [sp, #16]
    d87a:	9305      	str	r3, [sp, #20]
        }
    }
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    }
#endif
    return result;
    d87c:	9b05      	ldr	r3, [sp, #20]
}
    d87e:	4618      	mov	r0, r3
    d880:	b007      	add	sp, #28
    d882:	f85d fb04 	ldr.w	pc, [sp], #4
    d886:	bf00      	nop
    d888:	000186d8 	.word	0x000186d8

0000d88c <FlexCAN_Ip_SetRxFifoGlobalMask_Privileged>:
 * Description   : Set RxFifo Global Mask.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetRxFifoGlobalMask_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetRxFifoGlobalMask_Privileged(uint8 instance, uint32 mask)
{
    d88c:	b500      	push	{lr}
    d88e:	b087      	sub	sp, #28
    d890:	4603      	mov	r3, r0
    d892:	9100      	str	r1, [sp, #0]
    d894:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    d898:	2300      	movs	r3, #0
    d89a:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    d89c:	2300      	movs	r3, #0
    d89e:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    d8a0:	f89d 3007 	ldrb.w	r3, [sp, #7]
    d8a4:	4a1c      	ldr	r2, [pc, #112]	; (d918 <FlexCAN_Ip_SetRxFifoGlobalMask_Privileged+0x8c>)
    d8a6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d8aa:	9303      	str	r3, [sp, #12]
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    d8ac:	9803      	ldr	r0, [sp, #12]
    d8ae:	f7fe f8f7 	bl	baa0 <FlexCAN_IsEnabled>
    d8b2:	4603      	mov	r3, r0
    d8b4:	2b00      	cmp	r3, #0
    d8b6:	bf14      	ite	ne
    d8b8:	2301      	movne	r3, #1
    d8ba:	2300      	moveq	r3, #0
    d8bc:	b2db      	uxtb	r3, r3
    d8be:	f083 0301 	eor.w	r3, r3, #1
    d8c2:	b2db      	uxtb	r3, r3
    d8c4:	f88d 300b 	strb.w	r3, [sp, #11]
    d8c8:	f89d 300b 	ldrb.w	r3, [sp, #11]
    d8cc:	f003 0301 	and.w	r3, r3, #1
    d8d0:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    d8d4:	f89d 300b 	ldrb.w	r3, [sp, #11]
    d8d8:	2b00      	cmp	r3, #0
    d8da:	d003      	beq.n	d8e4 <FlexCAN_Ip_SetRxFifoGlobalMask_Privileged+0x58>
    {
        result = FlexCAN_Enable(pBase);
    d8dc:	9803      	ldr	r0, [sp, #12]
    d8de:	f001 f901 	bl	eae4 <FlexCAN_Enable>
    d8e2:	9005      	str	r0, [sp, #20]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    d8e4:	9b05      	ldr	r3, [sp, #20]
    d8e6:	2b00      	cmp	r3, #0
    d8e8:	d103      	bne.n	d8f2 <FlexCAN_Ip_SetRxFifoGlobalMask_Privileged+0x66>
    {
        FlexCAN_SetRxFifoGlobalMask(pBase, mask);
    d8ea:	9900      	ldr	r1, [sp, #0]
    d8ec:	9803      	ldr	r0, [sp, #12]
    d8ee:	f7fe f8a7 	bl	ba40 <FlexCAN_SetRxFifoGlobalMask>
    }

    if (TRUE == disabled)
    d8f2:	f89d 300b 	ldrb.w	r3, [sp, #11]
    d8f6:	2b00      	cmp	r3, #0
    d8f8:	d008      	beq.n	d90c <FlexCAN_Ip_SetRxFifoGlobalMask_Privileged+0x80>
    {
        status = FlexCAN_Disable(pBase);
    d8fa:	9803      	ldr	r0, [sp, #12]
    d8fc:	f001 f970 	bl	ebe0 <FlexCAN_Disable>
    d900:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    d902:	9b04      	ldr	r3, [sp, #16]
    d904:	2b00      	cmp	r3, #0
    d906:	d001      	beq.n	d90c <FlexCAN_Ip_SetRxFifoGlobalMask_Privileged+0x80>
        {
            result = status;
    d908:	9b04      	ldr	r3, [sp, #16]
    d90a:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    d90c:	9b05      	ldr	r3, [sp, #20]
}
    d90e:	4618      	mov	r0, r3
    d910:	b007      	add	sp, #28
    d912:	f85d fb04 	ldr.w	pc, [sp], #4
    d916:	bf00      	nop
    d918:	000186d8 	.word	0x000186d8

0000d91c <FlexCAN_Ip_Deinit_Privileged>:
 * This function will disable all FlexCAN interrupts, and disable the FlexCAN.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_Deinit_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_Deinit_Privileged(uint8 instance)
{
    d91c:	b500      	push	{lr}
    d91e:	b085      	sub	sp, #20
    d920:	4603      	mov	r3, r0
    d922:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    d926:	f89d 3007 	ldrb.w	r3, [sp, #7]
    d92a:	4a0e      	ldr	r2, [pc, #56]	; (d964 <FlexCAN_Ip_Deinit_Privileged+0x48>)
    d92c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d930:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    /* Enter Freeze Mode Required before to enter Disabled Mode */
    result = FlexCAN_EnterFreezeMode(base);
    d932:	9803      	ldr	r0, [sp, #12]
    d934:	f001 f88a 	bl	ea4c <FlexCAN_EnterFreezeMode>
    d938:	9002      	str	r0, [sp, #8]
    if (FLEXCAN_STATUS_SUCCESS == result)
    d93a:	9b02      	ldr	r3, [sp, #8]
    d93c:	2b00      	cmp	r3, #0
    d93e:	d10b      	bne.n	d958 <FlexCAN_Ip_Deinit_Privileged+0x3c>
    {
        /* Reset registers */
        FlexCAN_SetRegDefaultVal(base);
    d940:	9803      	ldr	r0, [sp, #12]
    d942:	f7fe fb18 	bl	bf76 <FlexCAN_SetRegDefaultVal>
        /* wait for disable */
        (void)FlexCAN_Disable(base);
    d946:	9803      	ldr	r0, [sp, #12]
    d948:	f001 f94a 	bl	ebe0 <FlexCAN_Disable>
        /* Clear state pointer that is checked by FLEXCAN_DRV_Init */
        Flexcan_Ip_apxState[instance] = NULL_PTR;
    d94c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    d950:	4a05      	ldr	r2, [pc, #20]	; (d968 <FlexCAN_Ip_Deinit_Privileged+0x4c>)
    d952:	2100      	movs	r1, #0
    d954:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
            OsIf_Trusted_Call1param(FlexCAN_ClrUserAccessAllowed, base);
        }
    #endif
    }

    return result;
    d958:	9b02      	ldr	r3, [sp, #8]
}
    d95a:	4618      	mov	r0, r3
    d95c:	b005      	add	sp, #20
    d95e:	f85d fb04 	ldr.w	pc, [sp], #4
    d962:	bf00      	nop
    d964:	000186d8 	.word	0x000186d8
    d968:	1fff9360 	.word	0x1fff9360

0000d96c <FlexCAN_Ip_MainFunctionRead>:
 * This function read the messages received as pulling or if the Interrupts are disabled.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_MainFunctionRead_Activity */
void FlexCAN_Ip_MainFunctionRead(uint8 instance, uint8 mb_idx)
{
    d96c:	b500      	push	{lr}
    d96e:	b085      	sub	sp, #20
    d970:	4603      	mov	r3, r0
    d972:	460a      	mov	r2, r1
    d974:	f88d 3007 	strb.w	r3, [sp, #7]
    d978:	4613      	mov	r3, r2
    d97a:	f88d 3006 	strb.w	r3, [sp, #6]
    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    d97e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    d982:	4a22      	ldr	r2, [pc, #136]	; (da0c <FlexCAN_Ip_MainFunctionRead+0xa0>)
    d984:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d988:	9303      	str	r3, [sp, #12]
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    d98a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    d98e:	4a20      	ldr	r2, [pc, #128]	; (da10 <FlexCAN_Ip_MainFunctionRead+0xa4>)
    d990:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d994:	9302      	str	r3, [sp, #8]
        }
    }
    else
    {
#endif /* (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) */
        if ((TRUE == state->bIsLegacyFifoEn) && (mb_idx <= FLEXCAN_IP_LEGACY_RXFIFO_OVERFLOW))
    d996:	9b02      	ldr	r3, [sp, #8]
    d998:	f893 3214 	ldrb.w	r3, [r3, #532]	; 0x214
    d99c:	2b00      	cmp	r3, #0
    d99e:	d015      	beq.n	d9cc <FlexCAN_Ip_MainFunctionRead+0x60>
    d9a0:	f89d 3006 	ldrb.w	r3, [sp, #6]
    d9a4:	2b07      	cmp	r3, #7
    d9a6:	d811      	bhi.n	d9cc <FlexCAN_Ip_MainFunctionRead+0x60>
        {
            /* just process available legacy fifo event only */
            if ((uint8)FLEXCAN_IP_MB_HANDLE_RXFIFO == mb_idx)
    d9a8:	f89d 3006 	ldrb.w	r3, [sp, #6]
    d9ac:	2b00      	cmp	r3, #0
    d9ae:	d128      	bne.n	da02 <FlexCAN_Ip_MainFunctionRead+0x96>
            {
                if (FlexCAN_GetBuffStatusFlag(base, FLEXCAN_IP_LEGACY_RXFIFO_FRAME_AVAILABLE) != 0U)
    d9b0:	2105      	movs	r1, #5
    d9b2:	9803      	ldr	r0, [sp, #12]
    d9b4:	f7fe f8e1 	bl	bb7a <FlexCAN_GetBuffStatusFlag>
    d9b8:	4603      	mov	r3, r0
    d9ba:	2b00      	cmp	r3, #0
    d9bc:	d021      	beq.n	da02 <FlexCAN_Ip_MainFunctionRead+0x96>
                {
                    FlexCAN_IRQHandlerRxFIFO(instance, FLEXCAN_IP_LEGACY_RXFIFO_FRAME_AVAILABLE);
    d9be:	f89d 3007 	ldrb.w	r3, [sp, #7]
    d9c2:	2105      	movs	r1, #5
    d9c4:	4618      	mov	r0, r3
    d9c6:	f7fe ff17 	bl	c7f8 <FlexCAN_IRQHandlerRxFIFO>
            if ((uint8)FLEXCAN_IP_MB_HANDLE_RXFIFO == mb_idx)
    d9ca:	e01a      	b.n	da02 <FlexCAN_Ip_MainFunctionRead+0x96>
                }
            }
        }
        else
        {
            if (FlexCAN_GetBuffStatusFlag(base, mb_idx) != 0U)
    d9cc:	f89d 3006 	ldrb.w	r3, [sp, #6]
    d9d0:	4619      	mov	r1, r3
    d9d2:	9803      	ldr	r0, [sp, #12]
    d9d4:	f7fe f8d1 	bl	bb7a <FlexCAN_GetBuffStatusFlag>
    d9d8:	4603      	mov	r3, r0
    d9da:	2b00      	cmp	r3, #0
    d9dc:	d012      	beq.n	da04 <FlexCAN_Ip_MainFunctionRead+0x98>
            {
                /* Check mailbox completed reception */
                if (FLEXCAN_MB_RX_BUSY == state->mbs[mb_idx].state)
    d9de:	f89d 3006 	ldrb.w	r3, [sp, #6]
    d9e2:	9a02      	ldr	r2, [sp, #8]
    d9e4:	011b      	lsls	r3, r3, #4
    d9e6:	4413      	add	r3, r2
    d9e8:	3304      	adds	r3, #4
    d9ea:	681b      	ldr	r3, [r3, #0]
    d9ec:	2b01      	cmp	r3, #1
    d9ee:	d109      	bne.n	da04 <FlexCAN_Ip_MainFunctionRead+0x98>
                {
                    FlexCAN_IRQHandlerRxMB(instance, mb_idx);
    d9f0:	f89d 2006 	ldrb.w	r2, [sp, #6]
    d9f4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    d9f8:	4611      	mov	r1, r2
    d9fa:	4618      	mov	r0, r3
    d9fc:	f7fe fd74 	bl	c4e8 <FlexCAN_IRQHandlerRxMB>
            }
        }
#if (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON)
    }
#endif /* (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) */
}
    da00:	e000      	b.n	da04 <FlexCAN_Ip_MainFunctionRead+0x98>
            if ((uint8)FLEXCAN_IP_MB_HANDLE_RXFIFO == mb_idx)
    da02:	bf00      	nop
}
    da04:	bf00      	nop
    da06:	b005      	add	sp, #20
    da08:	f85d fb04 	ldr.w	pc, [sp], #4
    da0c:	000186d8 	.word	0x000186d8
    da10:	1fff9360 	.word	0x1fff9360

0000da14 <FlexCAN_Ip_MainFunctionBusOff_Privileged>:
 * This function check the bus off event.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_MainFunctionBusOff_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_MainFunctionBusOff_Privileged(uint8 instance)
{
    da14:	b510      	push	{r4, lr}
    da16:	b086      	sub	sp, #24
    da18:	4603      	mov	r3, r0
    da1a:	f88d 3007 	strb.w	r3, [sp, #7]
    Flexcan_Ip_StatusType eRetVal = FLEXCAN_STATUS_ERROR;
    da1e:	2301      	movs	r3, #1
    da20:	9305      	str	r3, [sp, #20]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    da22:	f89d 3007 	ldrb.w	r3, [sp, #7]
    da26:	4a15      	ldr	r2, [pc, #84]	; (da7c <FlexCAN_Ip_MainFunctionBusOff_Privileged+0x68>)
    da28:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    da2c:	9304      	str	r3, [sp, #16]
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    da2e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    da32:	4a13      	ldr	r2, [pc, #76]	; (da80 <FlexCAN_Ip_MainFunctionBusOff_Privileged+0x6c>)
    da34:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    da38:	9303      	str	r3, [sp, #12]
    uint32 u32ErrStatus = 0U;
    da3a:	2300      	movs	r3, #0
    da3c:	9302      	str	r3, [sp, #8]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    /* Get error status */
    u32ErrStatus = base->ESR1;
    da3e:	9b04      	ldr	r3, [sp, #16]
    da40:	6a1b      	ldr	r3, [r3, #32]
    da42:	9302      	str	r3, [sp, #8]

    if (0U != (u32ErrStatus & FLEXCAN_ESR1_BOFFINT_MASK))
    da44:	9b02      	ldr	r3, [sp, #8]
    da46:	f003 0304 	and.w	r3, r3, #4
    da4a:	2b00      	cmp	r3, #0
    da4c:	d012      	beq.n	da74 <FlexCAN_Ip_MainFunctionBusOff_Privileged+0x60>
    {
        /* Invoke callback */
        if (state->error_callback != NULL_PTR)
    da4e:	9b03      	ldr	r3, [sp, #12]
    da50:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
    da54:	2b00      	cmp	r3, #0
    da56:	d008      	beq.n	da6a <FlexCAN_Ip_MainFunctionBusOff_Privileged+0x56>
        {
            state->error_callback(instance, FLEXCAN_EVENT_BUSOFF, u32ErrStatus, state);
    da58:	9b03      	ldr	r3, [sp, #12]
    da5a:	f8d3 4208 	ldr.w	r4, [r3, #520]	; 0x208
    da5e:	f89d 0007 	ldrb.w	r0, [sp, #7]
    da62:	9b03      	ldr	r3, [sp, #12]
    da64:	9a02      	ldr	r2, [sp, #8]
    da66:	2107      	movs	r1, #7
    da68:	47a0      	blx	r4
        }
        /* Clear BusOff Status Flag */
        base->ESR1 = FLEXCAN_ESR1_BOFFINT_MASK;
    da6a:	9b04      	ldr	r3, [sp, #16]
    da6c:	2204      	movs	r2, #4
    da6e:	621a      	str	r2, [r3, #32]
        eRetVal = FLEXCAN_STATUS_SUCCESS;
    da70:	2300      	movs	r3, #0
    da72:	9305      	str	r3, [sp, #20]
    }
    return eRetVal;
    da74:	9b05      	ldr	r3, [sp, #20]
}
    da76:	4618      	mov	r0, r3
    da78:	b006      	add	sp, #24
    da7a:	bd10      	pop	{r4, pc}
    da7c:	000186d8 	.word	0x000186d8
    da80:	1fff9360 	.word	0x1fff9360

0000da84 <FlexCAN_Ip_MainFunctionWrite>:
 * This function check the message if have been sent.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_MainFunctionWrite_Activity */
void FlexCAN_Ip_MainFunctionWrite(uint8 instance, uint8 mb_idx)
{
    da84:	b510      	push	{r4, lr}
    da86:	b098      	sub	sp, #96	; 0x60
    da88:	4603      	mov	r3, r0
    da8a:	460a      	mov	r2, r1
    da8c:	f88d 3007 	strb.w	r3, [sp, #7]
    da90:	4613      	mov	r3, r2
    da92:	f88d 3006 	strb.w	r3, [sp, #6]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    da96:	f89d 3007 	ldrb.w	r3, [sp, #7]
    da9a:	4a3f      	ldr	r2, [pc, #252]	; (db98 <FlexCAN_Ip_MainFunctionWrite+0x114>)
    da9c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    daa0:	9317      	str	r3, [sp, #92]	; 0x5c
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    daa2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    daa6:	4a3d      	ldr	r2, [pc, #244]	; (db9c <FlexCAN_Ip_MainFunctionWrite+0x118>)
    daa8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    daac:	9316      	str	r3, [sp, #88]	; 0x58

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    if (FlexCAN_GetBuffStatusFlag(base, mb_idx) != 0U)
    daae:	f89d 3006 	ldrb.w	r3, [sp, #6]
    dab2:	4619      	mov	r1, r3
    dab4:	9817      	ldr	r0, [sp, #92]	; 0x5c
    dab6:	f7fe f860 	bl	bb7a <FlexCAN_GetBuffStatusFlag>
    daba:	4603      	mov	r3, r0
    dabc:	2b00      	cmp	r3, #0
    dabe:	d068      	beq.n	db92 <FlexCAN_Ip_MainFunctionWrite+0x10e>
    {
        if (FLEXCAN_MB_TX_BUSY == state->mbs[mb_idx].state)
    dac0:	f89d 3006 	ldrb.w	r3, [sp, #6]
    dac4:	9a16      	ldr	r2, [sp, #88]	; 0x58
    dac6:	011b      	lsls	r3, r3, #4
    dac8:	4413      	add	r3, r2
    daca:	3304      	adds	r3, #4
    dacc:	681b      	ldr	r3, [r3, #0]
    dace:	2b02      	cmp	r3, #2
    dad0:	d15f      	bne.n	db92 <FlexCAN_Ip_MainFunctionWrite+0x10e>
        {
            if (state->mbs[mb_idx].isRemote)
    dad2:	f89d 3006 	ldrb.w	r3, [sp, #6]
    dad6:	9a16      	ldr	r2, [sp, #88]	; 0x58
    dad8:	011b      	lsls	r3, r3, #4
    dada:	4413      	add	r3, r2
    dadc:	3309      	adds	r3, #9
    dade:	781b      	ldrb	r3, [r3, #0]
    dae0:	2b00      	cmp	r3, #0
    dae2:	d028      	beq.n	db36 <FlexCAN_Ip_MainFunctionWrite+0xb2>
            {
                Flexcan_Ip_MsgBuffType mb;
                mb.cs = 0U;
    dae4:	2300      	movs	r3, #0
    dae6:	9302      	str	r3, [sp, #8]
                mb.time_stamp = 0U;
    dae8:	2300      	movs	r3, #0
    daea:	9315      	str	r3, [sp, #84]	; 0x54
                FlexCAN_LockRxMsgBuff(base, mb_idx);
    daec:	f89d 3006 	ldrb.w	r3, [sp, #6]
    daf0:	4619      	mov	r1, r3
    daf2:	9817      	ldr	r0, [sp, #92]	; 0x5c
    daf4:	f001 fa87 	bl	f006 <FlexCAN_LockRxMsgBuff>
                FlexCAN_GetMsgBuff(base, mb_idx, &mb);
    daf8:	f89d 3006 	ldrb.w	r3, [sp, #6]
    dafc:	aa02      	add	r2, sp, #8
    dafe:	4619      	mov	r1, r3
    db00:	9817      	ldr	r0, [sp, #92]	; 0x5c
    db02:	f001 fbaf 	bl	f264 <FlexCAN_GetMsgBuff>
                FlexCAN_UnlockRxMsgBuff(base);
    db06:	9817      	ldr	r0, [sp, #92]	; 0x5c
    db08:	f7fe f81d 	bl	bb46 <FlexCAN_UnlockRxMsgBuff>
                state->mbs[mb_idx].time_stamp = mb.time_stamp;
    db0c:	f89d 3006 	ldrb.w	r3, [sp, #6]
    db10:	9a15      	ldr	r2, [sp, #84]	; 0x54
    db12:	9916      	ldr	r1, [sp, #88]	; 0x58
    db14:	011b      	lsls	r3, r3, #4
    db16:	440b      	add	r3, r1
    db18:	330c      	adds	r3, #12
    db1a:	601a      	str	r2, [r3, #0]
                /* If the frame was a remote frame, clear the flag only if the response was
                * not received yet. If the response was received, leave the flag set in order
                * to be handled when the user calls FLEXCAN_DRV_RxMessageBuffer. */
                if ((uint32)FLEXCAN_RX_EMPTY == ((mb.cs & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT))
    db1c:	9b02      	ldr	r3, [sp, #8]
    db1e:	0e1b      	lsrs	r3, r3, #24
    db20:	f003 030f 	and.w	r3, r3, #15
    db24:	2b04      	cmp	r3, #4
    db26:	d11d      	bne.n	db64 <FlexCAN_Ip_MainFunctionWrite+0xe0>
                {
                    FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    db28:	f89d 3006 	ldrb.w	r3, [sp, #6]
    db2c:	4619      	mov	r1, r3
    db2e:	9817      	ldr	r0, [sp, #92]	; 0x5c
    db30:	f7fe f810 	bl	bb54 <FlexCAN_ClearMsgBuffIntStatusFlag>
    db34:	e016      	b.n	db64 <FlexCAN_Ip_MainFunctionWrite+0xe0>
                }
            }
            else
            {
                state->mbs[mb_idx].time_stamp = FlexCAN_GetMsgBuffTimestamp(base, mb_idx);
    db36:	f89d 3006 	ldrb.w	r3, [sp, #6]
    db3a:	f89d 4006 	ldrb.w	r4, [sp, #6]
    db3e:	4619      	mov	r1, r3
    db40:	9817      	ldr	r0, [sp, #92]	; 0x5c
    db42:	f001 fb7b 	bl	f23c <FlexCAN_GetMsgBuffTimestamp>
    db46:	4601      	mov	r1, r0
    db48:	9a16      	ldr	r2, [sp, #88]	; 0x58
    db4a:	0123      	lsls	r3, r4, #4
    db4c:	4413      	add	r3, r2
    db4e:	330c      	adds	r3, #12
    db50:	6019      	str	r1, [r3, #0]
                FlexCAN_UnlockRxMsgBuff(base);
    db52:	9817      	ldr	r0, [sp, #92]	; 0x5c
    db54:	f7fd fff7 	bl	bb46 <FlexCAN_UnlockRxMsgBuff>
                /* Clear message buffer flag */
                FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    db58:	f89d 3006 	ldrb.w	r3, [sp, #6]
    db5c:	4619      	mov	r1, r3
    db5e:	9817      	ldr	r0, [sp, #92]	; 0x5c
    db60:	f7fd fff8 	bl	bb54 <FlexCAN_ClearMsgBuffIntStatusFlag>
            }

            state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;
    db64:	f89d 3006 	ldrb.w	r3, [sp, #6]
    db68:	9a16      	ldr	r2, [sp, #88]	; 0x58
    db6a:	011b      	lsls	r3, r3, #4
    db6c:	4413      	add	r3, r2
    db6e:	3304      	adds	r3, #4
    db70:	2200      	movs	r2, #0
    db72:	601a      	str	r2, [r3, #0]

            /* Invoke callback */
            if (state->callback != NULL_PTR)
    db74:	9b16      	ldr	r3, [sp, #88]	; 0x58
    db76:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    db7a:	2b00      	cmp	r3, #0
    db7c:	d009      	beq.n	db92 <FlexCAN_Ip_MainFunctionWrite+0x10e>
            {
                state->callback(instance, FLEXCAN_EVENT_TX_COMPLETE, mb_idx, state);
    db7e:	9b16      	ldr	r3, [sp, #88]	; 0x58
    db80:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    db84:	f89d 2006 	ldrb.w	r2, [sp, #6]
    db88:	f89d 0007 	ldrb.w	r0, [sp, #7]
    db8c:	9b16      	ldr	r3, [sp, #88]	; 0x58
    db8e:	2104      	movs	r1, #4
    db90:	47a0      	blx	r4
            }
        }
    }
}
    db92:	bf00      	nop
    db94:	b018      	add	sp, #96	; 0x60
    db96:	bd10      	pop	{r4, pc}
    db98:	000186d8 	.word	0x000186d8
    db9c:	1fff9360 	.word	0x1fff9360

0000dba0 <FlexCAN_Ip_GetStopMode_Privileged>:
 * Description   : Check if the FlexCAN instance is STOPPED.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetStopMode_Activity */
boolean FlexCAN_Ip_GetStopMode_Privileged(uint8 instance)
{
    dba0:	b084      	sub	sp, #16
    dba2:	4603      	mov	r3, r0
    dba4:	f88d 3007 	strb.w	r3, [sp, #7]
    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    dba8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    dbac:	4a08      	ldr	r2, [pc, #32]	; (dbd0 <FlexCAN_Ip_GetStopMode_Privileged+0x30>)
    dbae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    dbb2:	9303      	str	r3, [sp, #12]
    return ((FLEXCAN_MCR_LPMACK_MASK == (base->MCR & FLEXCAN_MCR_LPMACK_MASK)) ? TRUE : FALSE);
    dbb4:	9b03      	ldr	r3, [sp, #12]
    dbb6:	681b      	ldr	r3, [r3, #0]
    dbb8:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    dbbc:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
    dbc0:	bf0c      	ite	eq
    dbc2:	2301      	moveq	r3, #1
    dbc4:	2300      	movne	r3, #0
    dbc6:	b2db      	uxtb	r3, r3
}
    dbc8:	4618      	mov	r0, r3
    dbca:	b004      	add	sp, #16
    dbcc:	4770      	bx	lr
    dbce:	bf00      	nop
    dbd0:	000186d8 	.word	0x000186d8

0000dbd4 <FlexCAN_Ip_GetStartMode_Privileged>:
 * Description   : Check if the FlexCAN instance is STARTED.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetStartMode_Activity */
boolean FlexCAN_Ip_GetStartMode_Privileged(uint8 instance)
{
    dbd4:	b084      	sub	sp, #16
    dbd6:	4603      	mov	r3, r0
    dbd8:	f88d 3007 	strb.w	r3, [sp, #7]
    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    dbdc:	f89d 3007 	ldrb.w	r3, [sp, #7]
    dbe0:	4a07      	ldr	r2, [pc, #28]	; (dc00 <FlexCAN_Ip_GetStartMode_Privileged+0x2c>)
    dbe2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    dbe6:	9303      	str	r3, [sp, #12]
    return ((0U == (base->MCR & (FLEXCAN_MCR_LPMACK_MASK | FLEXCAN_MCR_FRZACK_MASK))) ? TRUE : FALSE);
    dbe8:	9b03      	ldr	r3, [sp, #12]
    dbea:	681b      	ldr	r3, [r3, #0]
    dbec:	f003 7388 	and.w	r3, r3, #17825792	; 0x1100000
    dbf0:	2b00      	cmp	r3, #0
    dbf2:	bf0c      	ite	eq
    dbf4:	2301      	moveq	r3, #1
    dbf6:	2300      	movne	r3, #0
    dbf8:	b2db      	uxtb	r3, r3
}
    dbfa:	4618      	mov	r0, r3
    dbfc:	b004      	add	sp, #16
    dbfe:	4770      	bx	lr
    dc00:	000186d8 	.word	0x000186d8

0000dc04 <FlexCAN_Ip_SetStartMode_Privileged>:
 * Description   : Set the FlexCAN instance in START mode.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetStartMode_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetStartMode_Privileged(uint8 instance)
{
    dc04:	b500      	push	{lr}
    dc06:	b085      	sub	sp, #20
    dc08:	4603      	mov	r3, r0
    dc0a:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    dc0e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    dc12:	4a0b      	ldr	r2, [pc, #44]	; (dc40 <FlexCAN_Ip_SetStartMode_Privileged+0x3c>)
    dc14:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    dc18:	9303      	str	r3, [sp, #12]
    /* Start critical section: implementation depends on integrator */
    SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07();
    dc1a:	f006 faf7 	bl	1420c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07>
    /* Enable Flexcan Module */
    pBase->MCR &= ~FLEXCAN_MCR_MDIS_MASK;
    dc1e:	9b03      	ldr	r3, [sp, #12]
    dc20:	681b      	ldr	r3, [r3, #0]
    dc22:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
    dc26:	9b03      	ldr	r3, [sp, #12]
    dc28:	601a      	str	r2, [r3, #0]
    /* End critical section: implementation depends on integrator */
    SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07();
    dc2a:	f006 fb1b 	bl	14264 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07>

    return (FlexCAN_ExitFreezeMode(pBase));
    dc2e:	9803      	ldr	r0, [sp, #12]
    dc30:	f000 ff94 	bl	eb5c <FlexCAN_ExitFreezeMode>
    dc34:	4603      	mov	r3, r0
}
    dc36:	4618      	mov	r0, r3
    dc38:	b005      	add	sp, #20
    dc3a:	f85d fb04 	ldr.w	pc, [sp], #4
    dc3e:	bf00      	nop
    dc40:	000186d8 	.word	0x000186d8

0000dc44 <FlexCAN_Ip_SetStopMode_Privileged>:
 * Description   : Set the FlexCAN instance in STOP mode.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetStopMode_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetStopMode_Privileged(uint8 instance)
{
    dc44:	b500      	push	{lr}
    dc46:	b085      	sub	sp, #20
    dc48:	4603      	mov	r3, r0
    dc4a:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    dc4e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    dc52:	4a0a      	ldr	r2, [pc, #40]	; (dc7c <FlexCAN_Ip_SetStopMode_Privileged+0x38>)
    dc54:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    dc58:	9302      	str	r3, [sp, #8]
    Flexcan_Ip_StatusType status;
    status = FlexCAN_EnterFreezeMode(pBase);
    dc5a:	9802      	ldr	r0, [sp, #8]
    dc5c:	f000 fef6 	bl	ea4c <FlexCAN_EnterFreezeMode>
    dc60:	9003      	str	r0, [sp, #12]
    if (FLEXCAN_STATUS_SUCCESS == status)
    dc62:	9b03      	ldr	r3, [sp, #12]
    dc64:	2b00      	cmp	r3, #0
    dc66:	d103      	bne.n	dc70 <FlexCAN_Ip_SetStopMode_Privileged+0x2c>

        /* TODO: reset MB status */

        /* TODO: disable all interrupt */

        status = FlexCAN_Disable(pBase);
    dc68:	9802      	ldr	r0, [sp, #8]
    dc6a:	f000 ffb9 	bl	ebe0 <FlexCAN_Disable>
    dc6e:	9003      	str	r0, [sp, #12]
    }
    return status;
    dc70:	9b03      	ldr	r3, [sp, #12]
}
    dc72:	4618      	mov	r0, r3
    dc74:	b005      	add	sp, #20
    dc76:	f85d fb04 	ldr.w	pc, [sp], #4
    dc7a:	bf00      	nop
    dc7c:	000186d8 	.word	0x000186d8

0000dc80 <FlexCAN_Ip_SetRxMaskType_Privileged>:
 * mask.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetRxMaskType_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetRxMaskType_Privileged(uint8 instance, Flexcan_Ip_RxMaskType type)
{
    dc80:	b500      	push	{lr}
    dc82:	b087      	sub	sp, #28
    dc84:	4603      	mov	r3, r0
    dc86:	9100      	str	r1, [sp, #0]
    dc88:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    dc8c:	2300      	movs	r3, #0
    dc8e:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    dc90:	2300      	movs	r3, #0
    dc92:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    dc94:	f89d 3007 	ldrb.w	r3, [sp, #7]
    dc98:	4a1e      	ldr	r2, [pc, #120]	; (dd14 <FlexCAN_Ip_SetRxMaskType_Privileged+0x94>)
    dc9a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    dc9e:	9303      	str	r3, [sp, #12]
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    dca0:	9803      	ldr	r0, [sp, #12]
    dca2:	f7fd fefd 	bl	baa0 <FlexCAN_IsEnabled>
    dca6:	4603      	mov	r3, r0
    dca8:	2b00      	cmp	r3, #0
    dcaa:	bf14      	ite	ne
    dcac:	2301      	movne	r3, #1
    dcae:	2300      	moveq	r3, #0
    dcb0:	b2db      	uxtb	r3, r3
    dcb2:	f083 0301 	eor.w	r3, r3, #1
    dcb6:	b2db      	uxtb	r3, r3
    dcb8:	f88d 300b 	strb.w	r3, [sp, #11]
    dcbc:	f89d 300b 	ldrb.w	r3, [sp, #11]
    dcc0:	f003 0301 	and.w	r3, r3, #1
    dcc4:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    dcc8:	f89d 300b 	ldrb.w	r3, [sp, #11]
    dccc:	2b00      	cmp	r3, #0
    dcce:	d003      	beq.n	dcd8 <FlexCAN_Ip_SetRxMaskType_Privileged+0x58>
    {
        result = FlexCAN_Enable(pBase);
    dcd0:	9803      	ldr	r0, [sp, #12]
    dcd2:	f000 ff07 	bl	eae4 <FlexCAN_Enable>
    dcd6:	9005      	str	r0, [sp, #20]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    dcd8:	9b05      	ldr	r3, [sp, #20]
    dcda:	2b00      	cmp	r3, #0
    dcdc:	d107      	bne.n	dcee <FlexCAN_Ip_SetRxMaskType_Privileged+0x6e>
    {
        /* Start critical section: implementation depends on integrator */
        SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08();
    dcde:	f006 fae7 	bl	142b0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08>
        FlexCAN_SetRxMaskType(pBase, type);
    dce2:	9900      	ldr	r1, [sp, #0]
    dce4:	9803      	ldr	r0, [sp, #12]
    dce6:	f7fe f930 	bl	bf4a <FlexCAN_SetRxMaskType>
        /* End critical section: implementation depends on integrator */
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08();
    dcea:	f006 fb0d 	bl	14308 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08>
    }

    if (TRUE == disabled)
    dcee:	f89d 300b 	ldrb.w	r3, [sp, #11]
    dcf2:	2b00      	cmp	r3, #0
    dcf4:	d008      	beq.n	dd08 <FlexCAN_Ip_SetRxMaskType_Privileged+0x88>
    {
        status = FlexCAN_Disable(pBase);
    dcf6:	9803      	ldr	r0, [sp, #12]
    dcf8:	f000 ff72 	bl	ebe0 <FlexCAN_Disable>
    dcfc:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    dcfe:	9b04      	ldr	r3, [sp, #16]
    dd00:	2b00      	cmp	r3, #0
    dd02:	d001      	beq.n	dd08 <FlexCAN_Ip_SetRxMaskType_Privileged+0x88>
        {
            result = status;
    dd04:	9b04      	ldr	r3, [sp, #16]
    dd06:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    dd08:	9b05      	ldr	r3, [sp, #20]
}
    dd0a:	4618      	mov	r0, r3
    dd0c:	b007      	add	sp, #28
    dd0e:	f85d fb04 	ldr.w	pc, [sp], #4
    dd12:	bf00      	nop
    dd14:	000186d8 	.word	0x000186d8

0000dd18 <FlexCAN_Ip_SetBitrate_Privileged>:
 *
 *END**************************************************************************/

/* implements  FlexCAN_Ip_SetBitrate_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetBitrate_Privileged(uint8 instance, const Flexcan_Ip_TimeSegmentType * bitrate, boolean enhExt)
{
    dd18:	b500      	push	{lr}
    dd1a:	b087      	sub	sp, #28
    dd1c:	4603      	mov	r3, r0
    dd1e:	9100      	str	r1, [sp, #0]
    dd20:	f88d 3007 	strb.w	r3, [sp, #7]
    dd24:	4613      	mov	r3, r2
    dd26:	f88d 3006 	strb.w	r3, [sp, #6]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert(bitrate != NULL_PTR);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    dd2a:	2300      	movs	r3, #0
    dd2c:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    dd2e:	2300      	movs	r3, #0
    dd30:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    dd32:	f89d 3007 	ldrb.w	r3, [sp, #7]
    dd36:	4a1c      	ldr	r2, [pc, #112]	; (dda8 <FlexCAN_Ip_SetBitrate_Privileged+0x90>)
    dd38:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    dd3c:	9303      	str	r3, [sp, #12]
    /* Check if the FlexCAN is enabled or not */
    boolean disabled = ((pBase->MCR & FLEXCAN_MCR_MDIS_MASK) != 0U) ? TRUE : FALSE;
    dd3e:	9b03      	ldr	r3, [sp, #12]
    dd40:	681b      	ldr	r3, [r3, #0]
    dd42:	0fdb      	lsrs	r3, r3, #31
    dd44:	f88d 300b 	strb.w	r3, [sp, #11]
#if (FLEXCAN_IP_FEATURE_HAS_ENHANCE_CBT == STD_OFF)
    (void)enhExt;
#endif
    if (TRUE == disabled)
    dd48:	f89d 300b 	ldrb.w	r3, [sp, #11]
    dd4c:	2b00      	cmp	r3, #0
    dd4e:	d003      	beq.n	dd58 <FlexCAN_Ip_SetBitrate_Privileged+0x40>
    {
        result = FlexCAN_Enable(pBase);
    dd50:	9803      	ldr	r0, [sp, #12]
    dd52:	f000 fec7 	bl	eae4 <FlexCAN_Enable>
    dd56:	9005      	str	r0, [sp, #20]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    dd58:	9b05      	ldr	r3, [sp, #20]
    dd5a:	2b00      	cmp	r3, #0
    dd5c:	d112      	bne.n	dd84 <FlexCAN_Ip_SetBitrate_Privileged+0x6c>
    {
        /* Start critical section: implementation depends on integrator */
        SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14();
    dd5e:	f006 fc93 	bl	14688 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14>
            FlexCAN_SetEnhancedNominalTimeSegments(pBase, bitrate);
        }
        else
#endif
        {
            if (TRUE == FlexCAN_IsExCbtEnabled(pBase))
    dd62:	9803      	ldr	r0, [sp, #12]
    dd64:	f7fe f830 	bl	bdc8 <FlexCAN_IsExCbtEnabled>
    dd68:	4603      	mov	r3, r0
    dd6a:	2b00      	cmp	r3, #0
    dd6c:	d004      	beq.n	dd78 <FlexCAN_Ip_SetBitrate_Privileged+0x60>
            {
                FlexCAN_SetExtendedTimeSegments(pBase, bitrate);
    dd6e:	9900      	ldr	r1, [sp, #0]
    dd70:	9803      	ldr	r0, [sp, #12]
    dd72:	f7fd ff7f 	bl	bc74 <FlexCAN_SetExtendedTimeSegments>
    dd76:	e003      	b.n	dd80 <FlexCAN_Ip_SetBitrate_Privileged+0x68>
            }
            else
            {
                FlexCAN_SetTimeSegments(pBase, bitrate);
    dd78:	9900      	ldr	r1, [sp, #0]
    dd7a:	9803      	ldr	r0, [sp, #12]
    dd7c:	f7fd ff4e 	bl	bc1c <FlexCAN_SetTimeSegments>
            }
        }
        /* End critical section: implementation depends on integrator */
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14();
    dd80:	f006 fcae 	bl	146e0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14>
    }

    if (TRUE == disabled)
    dd84:	f89d 300b 	ldrb.w	r3, [sp, #11]
    dd88:	2b00      	cmp	r3, #0
    dd8a:	d008      	beq.n	dd9e <FlexCAN_Ip_SetBitrate_Privileged+0x86>
    {
        status = FlexCAN_Disable(pBase);
    dd8c:	9803      	ldr	r0, [sp, #12]
    dd8e:	f000 ff27 	bl	ebe0 <FlexCAN_Disable>
    dd92:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    dd94:	9b04      	ldr	r3, [sp, #16]
    dd96:	2b00      	cmp	r3, #0
    dd98:	d001      	beq.n	dd9e <FlexCAN_Ip_SetBitrate_Privileged+0x86>
        {
            result = status;
    dd9a:	9b04      	ldr	r3, [sp, #16]
    dd9c:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    dd9e:	9b05      	ldr	r3, [sp, #20]
}
    dda0:	4618      	mov	r0, r3
    dda2:	b007      	add	sp, #28
    dda4:	f85d fb04 	ldr.w	pc, [sp], #4
    dda8:	000186d8 	.word	0x000186d8

0000ddac <FlexCAN_Ip_GetBitrate>:
 * or the arbitration phase of FD frames.
 *
 *END**************************************************************************/
 /* implements   FlexCAN_Ip_GetBitrate_Activity */
boolean FlexCAN_Ip_GetBitrate(uint8 instance, Flexcan_Ip_TimeSegmentType * bitrate)
{
    ddac:	b500      	push	{lr}
    ddae:	b085      	sub	sp, #20
    ddb0:	4603      	mov	r3, r0
    ddb2:	9100      	str	r1, [sp, #0]
    ddb4:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert(bitrate != NULL_PTR);
#endif
    const FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    ddb8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    ddbc:	4a0d      	ldr	r2, [pc, #52]	; (ddf4 <FlexCAN_Ip_GetBitrate+0x48>)
    ddbe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ddc2:	9303      	str	r3, [sp, #12]
    boolean enhCbt = FALSE;
    ddc4:	2300      	movs	r3, #0
    ddc6:	f88d 300b 	strb.w	r3, [sp, #11]
        FlexCAN_GetEnhancedNominalTimeSegments(pBase, bitrate);
    }
    else
#endif
    {
        if (TRUE == FlexCAN_IsExCbtEnabled(pBase))
    ddca:	9803      	ldr	r0, [sp, #12]
    ddcc:	f7fd fffc 	bl	bdc8 <FlexCAN_IsExCbtEnabled>
    ddd0:	4603      	mov	r3, r0
    ddd2:	2b00      	cmp	r3, #0
    ddd4:	d004      	beq.n	dde0 <FlexCAN_Ip_GetBitrate+0x34>
        {
            /* Get the Extended time segments*/
            FlexCAN_GetExtendedTimeSegments(pBase, bitrate);
    ddd6:	9900      	ldr	r1, [sp, #0]
    ddd8:	9803      	ldr	r0, [sp, #12]
    ddda:	f7fd ff79 	bl	bcd0 <FlexCAN_GetExtendedTimeSegments>
    ddde:	e003      	b.n	dde8 <FlexCAN_Ip_GetBitrate+0x3c>
        }
        else
        {
            /* Get the time segments*/
            FlexCAN_GetTimeSegments(pBase, bitrate);
    dde0:	9900      	ldr	r1, [sp, #0]
    dde2:	9803      	ldr	r0, [sp, #12]
    dde4:	f7fd ff9c 	bl	bd20 <FlexCAN_GetTimeSegments>
        }
    }
    return enhCbt;
    dde8:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
    ddec:	4618      	mov	r0, r3
    ddee:	b005      	add	sp, #20
    ddf0:	f85d fb04 	ldr.w	pc, [sp], #4
    ddf4:	000186d8 	.word	0x000186d8

0000ddf8 <FlexCAN_Ip_ClearTDCFail>:
 * Description   : This function clear the TDC Fail flag.
 *
 *END**************************************************************************/
/* implements   FlexCAN_Ip_ClearTDCFail_Activity */
void FlexCAN_Ip_ClearTDCFail(uint8 u8Instance)
{
    ddf8:	b500      	push	{lr}
    ddfa:	b085      	sub	sp, #20
    ddfc:	4603      	mov	r3, r0
    ddfe:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(u8Instance < FLEXCAN_INSTANCE_COUNT);
#endif
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    de02:	f89d 3007 	ldrb.w	r3, [sp, #7]
    de06:	4a0a      	ldr	r2, [pc, #40]	; (de30 <FlexCAN_Ip_ClearTDCFail+0x38>)
    de08:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    de0c:	9303      	str	r3, [sp, #12]
    /* Start critical section: implementation depends on integrator */
    SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09();
    de0e:	f006 faa1 	bl	14354 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09>
        pBase->ETDC |=  FLEXCAN_ETDC_ETDCFAIL_MASK;
    }
    else
#endif
    {
        pBase->FDCTRL |= FLEXCAN_FDCTRL_TDCFAIL_MASK;
    de12:	9b03      	ldr	r3, [sp, #12]
    de14:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    de18:	f443 4280 	orr.w	r2, r3, #16384	; 0x4000
    de1c:	9b03      	ldr	r3, [sp, #12]
    de1e:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
    }
    /* End critical section: implementation depends on integrator */
    SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09();
    de22:	f006 fac3 	bl	143ac <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09>
}
    de26:	bf00      	nop
    de28:	b005      	add	sp, #20
    de2a:	f85d fb04 	ldr.w	pc, [sp], #4
    de2e:	bf00      	nop
    de30:	000186d8 	.word	0x000186d8

0000de34 <FlexCAN_Ip_GetTDCFail>:
 *
 *END**************************************************************************/

/* implements    FlexCAN_Ip_GetTDCFail_Activity */
boolean FlexCAN_Ip_GetTDCFail(uint8 u8Instance)
{
    de34:	b084      	sub	sp, #16
    de36:	4603      	mov	r3, r0
    de38:	f88d 3007 	strb.w	r3, [sp, #7]
    boolean value=FALSE;
    de3c:	2300      	movs	r3, #0
    de3e:	f88d 300f 	strb.w	r3, [sp, #15]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(u8Instance < FLEXCAN_INSTANCE_COUNT);
#endif
    const FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    de42:	f89d 3007 	ldrb.w	r3, [sp, #7]
    de46:	4a0a      	ldr	r2, [pc, #40]	; (de70 <FlexCAN_Ip_GetTDCFail+0x3c>)
    de48:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    de4c:	9302      	str	r3, [sp, #8]
        value = ((pBase->ETDC & FLEXCAN_ETDC_ETDCFAIL_MASK) == FLEXCAN_ETDC_ETDCFAIL_MASK) ? TRUE : FALSE;
    }
    else
#endif
    {
        value = ((pBase->FDCTRL & FLEXCAN_FDCTRL_TDCFAIL_MASK) == FLEXCAN_FDCTRL_TDCFAIL_MASK) ? TRUE : FALSE;
    de4e:	9b02      	ldr	r3, [sp, #8]
    de50:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    de54:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
    de58:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
    de5c:	bf0c      	ite	eq
    de5e:	2301      	moveq	r3, #1
    de60:	2300      	movne	r3, #0
    de62:	f88d 300f 	strb.w	r3, [sp, #15]
    }
    return value;
    de66:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    de6a:	4618      	mov	r0, r3
    de6c:	b004      	add	sp, #16
    de6e:	4770      	bx	lr
    de70:	000186d8 	.word	0x000186d8

0000de74 <FlexCAN_Ip_GetTDCValue>:
 *
 *END**************************************************************************/

/* implements FlexCAN_Ip_GetTDCValue_Activity */
uint8 FlexCAN_Ip_GetTDCValue(uint8 u8Instance)
{
    de74:	b084      	sub	sp, #16
    de76:	4603      	mov	r3, r0
    de78:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 value = 0;
    de7c:	2300      	movs	r3, #0
    de7e:	f88d 300f 	strb.w	r3, [sp, #15]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(u8Instance < FLEXCAN_INSTANCE_COUNT);
#endif
    const FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    de82:	f89d 3007 	ldrb.w	r3, [sp, #7]
    de86:	4a08      	ldr	r2, [pc, #32]	; (dea8 <FlexCAN_Ip_GetTDCValue+0x34>)
    de88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    de8c:	9302      	str	r3, [sp, #8]
        value = (uint8)((pBase->ETDC& FLEXCAN_ETDC_ETDCVAL_MASK) >> FLEXCAN_ETDC_ETDCVAL_SHIFT);
    }
    else
#endif
    {
        value = (uint8)((pBase->FDCTRL & FLEXCAN_FDCTRL_TDCVAL_MASK) >> FLEXCAN_FDCTRL_TDCVAL_SHIFT);
    de8e:	9b02      	ldr	r3, [sp, #8]
    de90:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    de94:	b2db      	uxtb	r3, r3
    de96:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    de9a:	f88d 300f 	strb.w	r3, [sp, #15]
    }
    return value;
    de9e:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    dea2:	4618      	mov	r0, r3
    dea4:	b004      	add	sp, #16
    dea6:	4770      	bx	lr
    dea8:	000186d8 	.word	0x000186d8

0000deac <FlexCAN_Ip_SetBitrateCbt_Privileged>:
 *
 *END**************************************************************************/

/* implements  FlexCAN_Ip_SetBitrateCbt_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetBitrateCbt_Privileged(uint8 instance, const Flexcan_Ip_TimeSegmentType * bitrate, boolean bitRateSwitch)
{
    deac:	b500      	push	{lr}
    deae:	b087      	sub	sp, #28
    deb0:	4603      	mov	r3, r0
    deb2:	9100      	str	r1, [sp, #0]
    deb4:	f88d 3007 	strb.w	r3, [sp, #7]
    deb8:	4613      	mov	r3, r2
    deba:	f88d 3006 	strb.w	r3, [sp, #6]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert(bitrate != NULL_PTR);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    debe:	2300      	movs	r3, #0
    dec0:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    dec2:	2300      	movs	r3, #0
    dec4:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    dec6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    deca:	4a1e      	ldr	r2, [pc, #120]	; (df44 <FlexCAN_Ip_SetBitrateCbt_Privileged+0x98>)
    decc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ded0:	9303      	str	r3, [sp, #12]
    boolean fd_enable = FlexCAN_IsFDEnabled(pBase);
    ded2:	9803      	ldr	r0, [sp, #12]
    ded4:	f7fd ffaf 	bl	be36 <FlexCAN_IsFDEnabled>
    ded8:	4603      	mov	r3, r0
    deda:	f88d 300b 	strb.w	r3, [sp, #11]
    /* Check if the FlexCAN is enabled or not */
    boolean disabled = ((pBase->MCR & FLEXCAN_MCR_MDIS_MASK) != 0U) ? TRUE : FALSE;
    dede:	9b03      	ldr	r3, [sp, #12]
    dee0:	681b      	ldr	r3, [r3, #0]
    dee2:	0fdb      	lsrs	r3, r3, #31
    dee4:	f88d 300a 	strb.w	r3, [sp, #10]

    if (TRUE == disabled)
    dee8:	f89d 300a 	ldrb.w	r3, [sp, #10]
    deec:	2b00      	cmp	r3, #0
    deee:	d003      	beq.n	def8 <FlexCAN_Ip_SetBitrateCbt_Privileged+0x4c>
    {
        result = FlexCAN_Enable(pBase);
    def0:	9803      	ldr	r0, [sp, #12]
    def2:	f000 fdf7 	bl	eae4 <FlexCAN_Enable>
    def6:	9005      	str	r0, [sp, #20]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    def8:	9b05      	ldr	r3, [sp, #20]
    defa:	2b00      	cmp	r3, #0
    defc:	d10f      	bne.n	df1e <FlexCAN_Ip_SetBitrateCbt_Privileged+0x72>
    {
#if (FLEXCAN_IP_FEATURE_HAS_ENHANCE_CBT == STD_ON)
        boolean enhCbt = FlexCAN_IsEnhCbtEnabled(pBase);
#endif
        /* Start critical section: implementation depends on integrator */
        SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15();
    defe:	f006 fc15 	bl	1472c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15>
        FlexCAN_SetFDEnabled(pBase, fd_enable, bitRateSwitch);
    df02:	f89d 2006 	ldrb.w	r2, [sp, #6]
    df06:	f89d 300b 	ldrb.w	r3, [sp, #11]
    df0a:	4619      	mov	r1, r3
    df0c:	9803      	ldr	r0, [sp, #12]
    df0e:	f7fd fdd1 	bl	bab4 <FlexCAN_SetFDEnabled>
        }
        else
#endif
        {
            /* Set time segments*/
            FlexCAN_SetFDTimeSegments(pBase, bitrate);
    df12:	9900      	ldr	r1, [sp, #0]
    df14:	9803      	ldr	r0, [sp, #12]
    df16:	f7fd fe4c 	bl	bbb2 <FlexCAN_SetFDTimeSegments>
        }
        /* End critical section: implementation depends on integrator */
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15();
    df1a:	f006 fc33 	bl	14784 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15>
    }

    if (TRUE == disabled)
    df1e:	f89d 300a 	ldrb.w	r3, [sp, #10]
    df22:	2b00      	cmp	r3, #0
    df24:	d008      	beq.n	df38 <FlexCAN_Ip_SetBitrateCbt_Privileged+0x8c>
    {
        status = FlexCAN_Disable(pBase);
    df26:	9803      	ldr	r0, [sp, #12]
    df28:	f000 fe5a 	bl	ebe0 <FlexCAN_Disable>
    df2c:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    df2e:	9b04      	ldr	r3, [sp, #16]
    df30:	2b00      	cmp	r3, #0
    df32:	d001      	beq.n	df38 <FlexCAN_Ip_SetBitrateCbt_Privileged+0x8c>
        {
            result = status;
    df34:	9b04      	ldr	r3, [sp, #16]
    df36:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    df38:	9b05      	ldr	r3, [sp, #20]
}
    df3a:	4618      	mov	r0, r3
    df3c:	b007      	add	sp, #28
    df3e:	f85d fb04 	ldr.w	pc, [sp], #4
    df42:	bf00      	nop
    df44:	000186d8 	.word	0x000186d8

0000df48 <FlexCAN_Ip_GetBitrateFD>:
 * of FD frames.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetBitrateFD_Activity */
boolean FlexCAN_Ip_GetBitrateFD(uint8 instance, Flexcan_Ip_TimeSegmentType * bitrate)
{
    df48:	b500      	push	{lr}
    df4a:	b085      	sub	sp, #20
    df4c:	4603      	mov	r3, r0
    df4e:	9100      	str	r1, [sp, #0]
    df50:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert(bitrate != NULL_PTR);
#endif
    const FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    df54:	f89d 3007 	ldrb.w	r3, [sp, #7]
    df58:	4a08      	ldr	r2, [pc, #32]	; (df7c <FlexCAN_Ip_GetBitrateFD+0x34>)
    df5a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    df5e:	9303      	str	r3, [sp, #12]
    boolean enhCbt = FALSE;
    df60:	2300      	movs	r3, #0
    df62:	f88d 300b 	strb.w	r3, [sp, #11]
    }
    else
#endif
    {
        /* Get the time segments*/
        FlexCAN_GetFDTimeSegments(pBase, bitrate);
    df66:	9900      	ldr	r1, [sp, #0]
    df68:	9803      	ldr	r0, [sp, #12]
    df6a:	f7fd ff00 	bl	bd6e <FlexCAN_GetFDTimeSegments>
    }
    return enhCbt;
    df6e:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
    df72:	4618      	mov	r0, r3
    df74:	b005      	add	sp, #20
    df76:	f85d fb04 	ldr.w	pc, [sp], #4
    df7a:	bf00      	nop
    df7c:	000186d8 	.word	0x000186d8

0000df80 <FlexCAN_Ip_SetTDCOffset_Privileged>:
 * the Transceiver Delay Compensation Offset.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetTDCOffset_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetTDCOffset_Privileged(uint8 instance, boolean enable, uint8 offset)
{
    df80:	b500      	push	{lr}
    df82:	b087      	sub	sp, #28
    df84:	4603      	mov	r3, r0
    df86:	f88d 3007 	strb.w	r3, [sp, #7]
    df8a:	460b      	mov	r3, r1
    df8c:	f88d 3006 	strb.w	r3, [sp, #6]
    df90:	4613      	mov	r3, r2
    df92:	f88d 3005 	strb.w	r3, [sp, #5]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    df96:	2300      	movs	r3, #0
    df98:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    df9a:	2300      	movs	r3, #0
    df9c:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    df9e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    dfa2:	4a20      	ldr	r2, [pc, #128]	; (e024 <FlexCAN_Ip_SetTDCOffset_Privileged+0xa4>)
    dfa4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    dfa8:	9303      	str	r3, [sp, #12]
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    dfaa:	9803      	ldr	r0, [sp, #12]
    dfac:	f7fd fd78 	bl	baa0 <FlexCAN_IsEnabled>
    dfb0:	4603      	mov	r3, r0
    dfb2:	2b00      	cmp	r3, #0
    dfb4:	bf14      	ite	ne
    dfb6:	2301      	movne	r3, #1
    dfb8:	2300      	moveq	r3, #0
    dfba:	b2db      	uxtb	r3, r3
    dfbc:	f083 0301 	eor.w	r3, r3, #1
    dfc0:	b2db      	uxtb	r3, r3
    dfc2:	f88d 300b 	strb.w	r3, [sp, #11]
    dfc6:	f89d 300b 	ldrb.w	r3, [sp, #11]
    dfca:	f003 0301 	and.w	r3, r3, #1
    dfce:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    dfd2:	f89d 300b 	ldrb.w	r3, [sp, #11]
    dfd6:	2b00      	cmp	r3, #0
    dfd8:	d003      	beq.n	dfe2 <FlexCAN_Ip_SetTDCOffset_Privileged+0x62>
    {
        result = FlexCAN_Enable(pBase);
    dfda:	9803      	ldr	r0, [sp, #12]
    dfdc:	f000 fd82 	bl	eae4 <FlexCAN_Enable>
    dfe0:	9005      	str	r0, [sp, #20]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    dfe2:	9b05      	ldr	r3, [sp, #20]
    dfe4:	2b00      	cmp	r3, #0
    dfe6:	d10b      	bne.n	e000 <FlexCAN_Ip_SetTDCOffset_Privileged+0x80>
    {
        /* Check if enhaced CBT is Enabled */
        SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16();
    dfe8:	f006 fbf2 	bl	147d0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16>
        }
        else
#endif
        {
            /* Enable/Disable TDC and set the TDC Offset */
            FlexCAN_SetTDCOffset(pBase, enable, offset);
    dfec:	f89d 2005 	ldrb.w	r2, [sp, #5]
    dff0:	f89d 3006 	ldrb.w	r3, [sp, #6]
    dff4:	4619      	mov	r1, r3
    dff6:	9803      	ldr	r0, [sp, #12]
    dff8:	f7fd fd2b 	bl	ba52 <FlexCAN_SetTDCOffset>
        }
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16();
    dffc:	f006 fc14 	bl	14828 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16>
        /* Check if enhaced CBT is Enabled */
    }

    if (TRUE == disabled)
    e000:	f89d 300b 	ldrb.w	r3, [sp, #11]
    e004:	2b00      	cmp	r3, #0
    e006:	d008      	beq.n	e01a <FlexCAN_Ip_SetTDCOffset_Privileged+0x9a>
    {
        status = FlexCAN_Disable(pBase);
    e008:	9803      	ldr	r0, [sp, #12]
    e00a:	f000 fde9 	bl	ebe0 <FlexCAN_Disable>
    e00e:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    e010:	9b04      	ldr	r3, [sp, #16]
    e012:	2b00      	cmp	r3, #0
    e014:	d001      	beq.n	e01a <FlexCAN_Ip_SetTDCOffset_Privileged+0x9a>
        {
            result = status;
    e016:	9b04      	ldr	r3, [sp, #16]
    e018:	9305      	str	r3, [sp, #20]
        }
    }
    return result;
    e01a:	9b05      	ldr	r3, [sp, #20]
}
    e01c:	4618      	mov	r0, r3
    e01e:	b007      	add	sp, #28
    e020:	f85d fb04 	ldr.w	pc, [sp], #4
    e024:	000186d8 	.word	0x000186d8

0000e028 <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged>:
 * be delayed from the first bit of CRC field on CAN bus.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetTxArbitrationStartDelay_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged(uint8 instance,  uint8 value)
{
    e028:	b500      	push	{lr}
    e02a:	b087      	sub	sp, #28
    e02c:	4603      	mov	r3, r0
    e02e:	460a      	mov	r2, r1
    e030:	f88d 3007 	strb.w	r3, [sp, #7]
    e034:	4613      	mov	r3, r2
    e036:	f88d 3006 	strb.w	r3, [sp, #6]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    e03a:	2300      	movs	r3, #0
    e03c:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    e03e:	2300      	movs	r3, #0
    e040:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    e042:	f89d 3007 	ldrb.w	r3, [sp, #7]
    e046:	4a1f      	ldr	r2, [pc, #124]	; (e0c4 <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged+0x9c>)
    e048:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e04c:	9303      	str	r3, [sp, #12]
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    e04e:	9803      	ldr	r0, [sp, #12]
    e050:	f7fd fd26 	bl	baa0 <FlexCAN_IsEnabled>
    e054:	4603      	mov	r3, r0
    e056:	2b00      	cmp	r3, #0
    e058:	bf14      	ite	ne
    e05a:	2301      	movne	r3, #1
    e05c:	2300      	moveq	r3, #0
    e05e:	b2db      	uxtb	r3, r3
    e060:	f083 0301 	eor.w	r3, r3, #1
    e064:	b2db      	uxtb	r3, r3
    e066:	f88d 300b 	strb.w	r3, [sp, #11]
    e06a:	f89d 300b 	ldrb.w	r3, [sp, #11]
    e06e:	f003 0301 	and.w	r3, r3, #1
    e072:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    e076:	f89d 300b 	ldrb.w	r3, [sp, #11]
    e07a:	2b00      	cmp	r3, #0
    e07c:	d003      	beq.n	e086 <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged+0x5e>
    {
        result = FlexCAN_Enable(pBase);
    e07e:	9803      	ldr	r0, [sp, #12]
    e080:	f000 fd30 	bl	eae4 <FlexCAN_Enable>
    e084:	9005      	str	r0, [sp, #20]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    e086:	9b05      	ldr	r3, [sp, #20]
    e088:	2b00      	cmp	r3, #0
    e08a:	d109      	bne.n	e0a0 <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged+0x78>
    {
        /* Start critical section: implementation depends on integrator */
        SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17();
    e08c:	f006 fbf2 	bl	14874 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17>
        FlexCAN_SetTxArbitrationStartDelay(pBase, value);
    e090:	f89d 3006 	ldrb.w	r3, [sp, #6]
    e094:	4619      	mov	r1, r3
    e096:	9803      	ldr	r0, [sp, #12]
    e098:	f7fd ff43 	bl	bf22 <FlexCAN_SetTxArbitrationStartDelay>
        /* End critical section: implementation depends on integrator */
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17();
    e09c:	f006 fc16 	bl	148cc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17>
    }

    if (TRUE == disabled)
    e0a0:	f89d 300b 	ldrb.w	r3, [sp, #11]
    e0a4:	2b00      	cmp	r3, #0
    e0a6:	d008      	beq.n	e0ba <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged+0x92>
    {
        status = FlexCAN_Disable(pBase);
    e0a8:	9803      	ldr	r0, [sp, #12]
    e0aa:	f000 fd99 	bl	ebe0 <FlexCAN_Disable>
    e0ae:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    e0b0:	9b04      	ldr	r3, [sp, #16]
    e0b2:	2b00      	cmp	r3, #0
    e0b4:	d001      	beq.n	e0ba <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged+0x92>
        {
            result = status;
    e0b6:	9b04      	ldr	r3, [sp, #16]
    e0b8:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    e0ba:	9b05      	ldr	r3, [sp, #20]
}
    e0bc:	4618      	mov	r0, r3
    e0be:	b007      	add	sp, #28
    e0c0:	f85d fb04 	ldr.w	pc, [sp], #4
    e0c4:	000186d8 	.word	0x000186d8

0000e0c8 <FlexCAN_Ip_GetBuffStatusFlag>:
 * In case of a complete operation this flag is set.
 * In case msgBuff is 255 will return Enhanced Overflow Status Flag.
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetBuffStatusFlag_Activity */
boolean FlexCAN_Ip_GetBuffStatusFlag(uint8 instance, uint8 msgBuffIdx)
{
    e0c8:	b500      	push	{lr}
    e0ca:	b085      	sub	sp, #20
    e0cc:	4603      	mov	r3, r0
    e0ce:	460a      	mov	r2, r1
    e0d0:	f88d 3007 	strb.w	r3, [sp, #7]
    e0d4:	4613      	mov	r3, r2
    e0d6:	f88d 3006 	strb.w	r3, [sp, #6]
    boolean returnResult;
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    const FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    e0da:	f89d 3007 	ldrb.w	r3, [sp, #7]
    e0de:	4a0b      	ldr	r2, [pc, #44]	; (e10c <FlexCAN_Ip_GetBuffStatusFlag+0x44>)
    e0e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e0e4:	9303      	str	r3, [sp, #12]
        returnResult = ((1U == FlexCAN_GetEnhancedRxFIFOStatusFlag(pBase, FLEXCAN_IP_ENHANCED_RXFIFO_OVERFLOW)) ? TRUE : FALSE);
    }
    else
#endif
    {
        returnResult = ((1U == FlexCAN_GetBuffStatusFlag(pBase, msgBuffIdx)) ? TRUE : FALSE);
    e0e6:	f89d 3006 	ldrb.w	r3, [sp, #6]
    e0ea:	4619      	mov	r1, r3
    e0ec:	9803      	ldr	r0, [sp, #12]
    e0ee:	f7fd fd44 	bl	bb7a <FlexCAN_GetBuffStatusFlag>
    e0f2:	4603      	mov	r3, r0
    e0f4:	2b01      	cmp	r3, #1
    e0f6:	bf0c      	ite	eq
    e0f8:	2301      	moveq	r3, #1
    e0fa:	2300      	movne	r3, #0
    e0fc:	f88d 300b 	strb.w	r3, [sp, #11]
    }
    return returnResult;
    e100:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
    e104:	4618      	mov	r0, r3
    e106:	b005      	add	sp, #20
    e108:	f85d fb04 	ldr.w	pc, [sp], #4
    e10c:	000186d8 	.word	0x000186d8

0000e110 <FlexCAN_Ip_ClearBuffStatusFlag>:
 * Description   : Clear FlexCAN Message Buffer Status Flag.
 * In case msgBuff is 255 will clear Enhanced Overflow Status Flag.
 *END**************************************************************************/
/* implements FlexCAN_Ip_ClearBuffStatusFlag_Activity */
void FlexCAN_Ip_ClearBuffStatusFlag(uint8 instance, uint8 msgBuffIdx)
{
    e110:	b500      	push	{lr}
    e112:	b085      	sub	sp, #20
    e114:	4603      	mov	r3, r0
    e116:	460a      	mov	r2, r1
    e118:	f88d 3007 	strb.w	r3, [sp, #7]
    e11c:	4613      	mov	r3, r2
    e11e:	f88d 3006 	strb.w	r3, [sp, #6]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    e122:	f89d 3007 	ldrb.w	r3, [sp, #7]
    e126:	4a07      	ldr	r2, [pc, #28]	; (e144 <FlexCAN_Ip_ClearBuffStatusFlag+0x34>)
    e128:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e12c:	9303      	str	r3, [sp, #12]
        FlexCAN_ClearEnhancedRxFifoIntStatusFlag(pBase, FLEXCAN_IP_ENHANCED_RXFIFO_OVERFLOW);
    }
    else
#endif
    {
        FlexCAN_ClearMsgBuffIntStatusFlag(pBase, msgBuffIdx);
    e12e:	f89d 3006 	ldrb.w	r3, [sp, #6]
    e132:	4619      	mov	r1, r3
    e134:	9803      	ldr	r0, [sp, #12]
    e136:	f7fd fd0d 	bl	bb54 <FlexCAN_ClearMsgBuffIntStatusFlag>
    }
}
    e13a:	bf00      	nop
    e13c:	b005      	add	sp, #20
    e13e:	f85d fb04 	ldr.w	pc, [sp], #4
    e142:	bf00      	nop
    e144:	000186d8 	.word	0x000186d8

0000e148 <FlexCAN_Ip_EnableInterrupts_Privileged>:
 * Description   : Enable all mb interrupts configured.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_EnableInterrupts_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_EnableInterrupts_Privileged(uint8 u8Instance)
{
    e148:	b500      	push	{lr}
    e14a:	b087      	sub	sp, #28
    e14c:	4603      	mov	r3, r0
    e14e:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    e152:	f89d 3007 	ldrb.w	r3, [sp, #7]
    e156:	4a11      	ldr	r2, [pc, #68]	; (e19c <FlexCAN_Ip_EnableInterrupts_Privileged+0x54>)
    e158:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e15c:	9304      	str	r3, [sp, #16]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_ERROR;
    e15e:	2301      	movs	r3, #1
    e160:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[u8Instance];
    e162:	f89d 3007 	ldrb.w	r3, [sp, #7]
    e166:	4a0e      	ldr	r2, [pc, #56]	; (e1a0 <FlexCAN_Ip_EnableInterrupts_Privileged+0x58>)
    e168:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e16c:	9303      	str	r3, [sp, #12]

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(u8Instance < FLEXCAN_INSTANCE_COUNT);
#endif

    if (TRUE == FlexCAN_IsEnabled(pBase))
    e16e:	9804      	ldr	r0, [sp, #16]
    e170:	f7fd fc96 	bl	baa0 <FlexCAN_IsEnabled>
    e174:	4603      	mov	r3, r0
    e176:	2b00      	cmp	r3, #0
    e178:	d00b      	beq.n	e192 <FlexCAN_Ip_EnableInterrupts_Privileged+0x4a>
    {
        FlexCAN_EnableInterrupts(pBase, u8Instance);
    e17a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    e17e:	4619      	mov	r1, r3
    e180:	9804      	ldr	r0, [sp, #16]
    e182:	f000 ffe1 	bl	f148 <FlexCAN_EnableInterrupts>
            {
                FlexCAN_SetEnhancedRxFifoIntAll(pBase, TRUE);
            }
        }
    #endif
        state->isIntActive = TRUE;
    e186:	9b03      	ldr	r3, [sp, #12]
    e188:	2201      	movs	r2, #1
    e18a:	f883 221c 	strb.w	r2, [r3, #540]	; 0x21c
        result = FLEXCAN_STATUS_SUCCESS;
    e18e:	2300      	movs	r3, #0
    e190:	9305      	str	r3, [sp, #20]
    }

    return result;
    e192:	9b05      	ldr	r3, [sp, #20]
}
    e194:	4618      	mov	r0, r3
    e196:	b007      	add	sp, #28
    e198:	f85d fb04 	ldr.w	pc, [sp], #4
    e19c:	000186d8 	.word	0x000186d8
    e1a0:	1fff9360 	.word	0x1fff9360

0000e1a4 <FlexCAN_Ip_DisableInterrupts_Privileged>:
 * Description   : Enable all interrupts configured.
 *
 *END**************************************************************************/
 /* implements FlexCAN_Ip_DisableInterrupts_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_DisableInterrupts_Privileged(uint8 u8Instance)
{
    e1a4:	b500      	push	{lr}
    e1a6:	b087      	sub	sp, #28
    e1a8:	4603      	mov	r3, r0
    e1aa:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    e1ae:	f89d 3007 	ldrb.w	r3, [sp, #7]
    e1b2:	4a10      	ldr	r2, [pc, #64]	; (e1f4 <FlexCAN_Ip_DisableInterrupts_Privileged+0x50>)
    e1b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e1b8:	9304      	str	r3, [sp, #16]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_ERROR;
    e1ba:	2301      	movs	r3, #1
    e1bc:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[u8Instance];
    e1be:	f89d 3007 	ldrb.w	r3, [sp, #7]
    e1c2:	4a0d      	ldr	r2, [pc, #52]	; (e1f8 <FlexCAN_Ip_DisableInterrupts_Privileged+0x54>)
    e1c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e1c8:	9303      	str	r3, [sp, #12]

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(u8Instance < FLEXCAN_INSTANCE_COUNT);
#endif

    if (TRUE == FlexCAN_IsEnabled(pBase))
    e1ca:	9804      	ldr	r0, [sp, #16]
    e1cc:	f7fd fc68 	bl	baa0 <FlexCAN_IsEnabled>
    e1d0:	4603      	mov	r3, r0
    e1d2:	2b00      	cmp	r3, #0
    e1d4:	d008      	beq.n	e1e8 <FlexCAN_Ip_DisableInterrupts_Privileged+0x44>
    {
        FlexCAN_DisableInterrupts(pBase);
    e1d6:	9804      	ldr	r0, [sp, #16]
    e1d8:	f000 ffae 	bl	f138 <FlexCAN_DisableInterrupts>
            {
                FlexCAN_SetEnhancedRxFifoIntAll(pBase, FALSE);
            }
        }
#endif
        state->isIntActive = FALSE;
    e1dc:	9b03      	ldr	r3, [sp, #12]
    e1de:	2200      	movs	r2, #0
    e1e0:	f883 221c 	strb.w	r2, [r3, #540]	; 0x21c
        result = FLEXCAN_STATUS_SUCCESS;
    e1e4:	2300      	movs	r3, #0
    e1e6:	9305      	str	r3, [sp, #20]
    }

    return result;
    e1e8:	9b05      	ldr	r3, [sp, #20]
}
    e1ea:	4618      	mov	r0, r3
    e1ec:	b007      	add	sp, #28
    e1ee:	f85d fb04 	ldr.w	pc, [sp], #4
    e1f2:	bf00      	nop
    e1f4:	000186d8 	.word	0x000186d8
    e1f8:	1fff9360 	.word	0x1fff9360

0000e1fc <FlexCAN_Ip_SetErrorInt_Privileged>:
 * Description   : Enable\Disable Error or BusOff Interrupt
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetErrorInt_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetErrorInt_Privileged(uint8 u8Instance, Flexcan_Ip_ErrorIntType type, boolean enable)
{
    e1fc:	b500      	push	{lr}
    e1fe:	b087      	sub	sp, #28
    e200:	4603      	mov	r3, r0
    e202:	9100      	str	r1, [sp, #0]
    e204:	f88d 3007 	strb.w	r3, [sp, #7]
    e208:	4613      	mov	r3, r2
    e20a:	f88d 3006 	strb.w	r3, [sp, #6]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(u8Instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    e20e:	2300      	movs	r3, #0
    e210:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    e212:	2300      	movs	r3, #0
    e214:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    e216:	f89d 3007 	ldrb.w	r3, [sp, #7]
    e21a:	4a3a      	ldr	r2, [pc, #232]	; (e304 <FlexCAN_Ip_SetErrorInt_Privileged+0x108>)
    e21c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e220:	9303      	str	r3, [sp, #12]
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    e222:	9803      	ldr	r0, [sp, #12]
    e224:	f7fd fc3c 	bl	baa0 <FlexCAN_IsEnabled>
    e228:	4603      	mov	r3, r0
    e22a:	2b00      	cmp	r3, #0
    e22c:	bf14      	ite	ne
    e22e:	2301      	movne	r3, #1
    e230:	2300      	moveq	r3, #0
    e232:	b2db      	uxtb	r3, r3
    e234:	f083 0301 	eor.w	r3, r3, #1
    e238:	b2db      	uxtb	r3, r3
    e23a:	f88d 300b 	strb.w	r3, [sp, #11]
    e23e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    e242:	f003 0301 	and.w	r3, r3, #1
    e246:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    e24a:	f89d 300b 	ldrb.w	r3, [sp, #11]
    e24e:	2b00      	cmp	r3, #0
    e250:	d003      	beq.n	e25a <FlexCAN_Ip_SetErrorInt_Privileged+0x5e>
    {
        result = FlexCAN_Enable(pBase);
    e252:	9803      	ldr	r0, [sp, #12]
    e254:	f000 fc46 	bl	eae4 <FlexCAN_Enable>
    e258:	9005      	str	r0, [sp, #20]
    }

    if (FLEXCAN_STATUS_SUCCESS == result)
    e25a:	9b05      	ldr	r3, [sp, #20]
    e25c:	2b00      	cmp	r3, #0
    e25e:	d13c      	bne.n	e2da <FlexCAN_Ip_SetErrorInt_Privileged+0xde>
    e260:	9b00      	ldr	r3, [sp, #0]
    e262:	2b04      	cmp	r3, #4
    e264:	d83b      	bhi.n	e2de <FlexCAN_Ip_SetErrorInt_Privileged+0xe2>
    e266:	a201      	add	r2, pc, #4	; (adr r2, e26c <FlexCAN_Ip_SetErrorInt_Privileged+0x70>)
    e268:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    e26c:	0000e2b7 	.word	0x0000e2b7
    e270:	0000e2c9 	.word	0x0000e2c9
    e274:	0000e293 	.word	0x0000e293
    e278:	0000e2a5 	.word	0x0000e2a5
    e27c:	0000e281 	.word	0x0000e281
    {
        switch (type)
        {
            case FLEXCAN_IP_INT_BUSOFF:
            {
                FlexCAN_SetErrIntCmd(pBase, FLEXCAN_INT_BUSOFF, enable);
    e280:	f89d 3006 	ldrb.w	r3, [sp, #6]
    e284:	461a      	mov	r2, r3
    e286:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    e28a:	9803      	ldr	r0, [sp, #12]
    e28c:	f000 fce8 	bl	ec60 <FlexCAN_SetErrIntCmd>
                break;
    e290:	e026      	b.n	e2e0 <FlexCAN_Ip_SetErrorInt_Privileged+0xe4>
            }
            case FLEXCAN_IP_INT_ERR:
            {
                FlexCAN_SetErrIntCmd(pBase, FLEXCAN_INT_ERR, enable);
    e292:	f89d 3006 	ldrb.w	r3, [sp, #6]
    e296:	461a      	mov	r2, r3
    e298:	f44f 4180 	mov.w	r1, #16384	; 0x4000
    e29c:	9803      	ldr	r0, [sp, #12]
    e29e:	f000 fcdf 	bl	ec60 <FlexCAN_SetErrIntCmd>
                break;
    e2a2:	e01d      	b.n	e2e0 <FlexCAN_Ip_SetErrorInt_Privileged+0xe4>
            }
            case FLEXCAN_IP_INT_ERR_FAST :
            {
                FlexCAN_SetErrIntCmd(pBase, FLEXCAN_INT_ERR_FAST, enable);
    e2a4:	f89d 3006 	ldrb.w	r3, [sp, #6]
    e2a8:	461a      	mov	r2, r3
    e2aa:	f244 0101 	movw	r1, #16385	; 0x4001
    e2ae:	9803      	ldr	r0, [sp, #12]
    e2b0:	f000 fcd6 	bl	ec60 <FlexCAN_SetErrIntCmd>
                break;
    e2b4:	e014      	b.n	e2e0 <FlexCAN_Ip_SetErrorInt_Privileged+0xe4>
                    {
                        result = FLEXCAN_STATUS_ERROR;
                    }else
                #endif
                {
                    FlexCAN_SetErrIntCmd(pBase, FLEXCAN_INT_RX_WARNING, enable);
    e2b6:	f89d 3006 	ldrb.w	r3, [sp, #6]
    e2ba:	461a      	mov	r2, r3
    e2bc:	f44f 6180 	mov.w	r1, #1024	; 0x400
    e2c0:	9803      	ldr	r0, [sp, #12]
    e2c2:	f000 fccd 	bl	ec60 <FlexCAN_SetErrIntCmd>
                }
                break;
    e2c6:	e00b      	b.n	e2e0 <FlexCAN_Ip_SetErrorInt_Privileged+0xe4>
                    {
                        result = FLEXCAN_STATUS_ERROR;
                    }else
                #endif
                {
                    FlexCAN_SetErrIntCmd(pBase, FLEXCAN_INT_TX_WARNING, enable);
    e2c8:	f89d 3006 	ldrb.w	r3, [sp, #6]
    e2cc:	461a      	mov	r2, r3
    e2ce:	f44f 6100 	mov.w	r1, #2048	; 0x800
    e2d2:	9803      	ldr	r0, [sp, #12]
    e2d4:	f000 fcc4 	bl	ec60 <FlexCAN_SetErrIntCmd>
                }
                break;
    e2d8:	e002      	b.n	e2e0 <FlexCAN_Ip_SetErrorInt_Privileged+0xe4>
                    /* Should not get here */
                #endif
                break;
            }
        }
    }
    e2da:	bf00      	nop
    e2dc:	e000      	b.n	e2e0 <FlexCAN_Ip_SetErrorInt_Privileged+0xe4>
                break;
    e2de:	bf00      	nop

    if (TRUE == disabled)
    e2e0:	f89d 300b 	ldrb.w	r3, [sp, #11]
    e2e4:	2b00      	cmp	r3, #0
    e2e6:	d008      	beq.n	e2fa <FlexCAN_Ip_SetErrorInt_Privileged+0xfe>
    {
        status = FlexCAN_Disable(pBase);
    e2e8:	9803      	ldr	r0, [sp, #12]
    e2ea:	f000 fc79 	bl	ebe0 <FlexCAN_Disable>
    e2ee:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    e2f0:	9b04      	ldr	r3, [sp, #16]
    e2f2:	2b00      	cmp	r3, #0
    e2f4:	d001      	beq.n	e2fa <FlexCAN_Ip_SetErrorInt_Privileged+0xfe>
        {
            result = status;
    e2f6:	9b04      	ldr	r3, [sp, #16]
    e2f8:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    e2fa:	9b05      	ldr	r3, [sp, #20]
}
    e2fc:	4618      	mov	r0, r3
    e2fe:	b007      	add	sp, #28
    e300:	f85d fb04 	ldr.w	pc, [sp], #4
    e304:	000186d8 	.word	0x000186d8

0000e308 <FlexCAN_Ip_AbortTransfer>:
 * receiver.
 *
 *END**************************************************************************/
/* implements    FlexCAN_Ip_AbortTransfer_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_AbortTransfer(uint8 u8Instance, uint8 mb_idx)
{
    e308:	b500      	push	{lr}
    e30a:	b087      	sub	sp, #28
    e30c:	4603      	mov	r3, r0
    e30e:	460a      	mov	r2, r1
    e310:	f88d 3007 	strb.w	r3, [sp, #7]
    e314:	4613      	mov	r3, r2
    e316:	f88d 3006 	strb.w	r3, [sp, #6]
    #if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
        DevAssert(u8Instance < FLEXCAN_INSTANCE_COUNT);
        DevAssert((mb_idx < (uint8)FLEXCAN_IP_FEATURE_MAX_MB_NUM) || (255u == mb_idx));
    #endif
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    e31a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    e31e:	4a27      	ldr	r2, [pc, #156]	; (e3bc <FlexCAN_Ip_AbortTransfer+0xb4>)
    e320:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e324:	9304      	str	r3, [sp, #16]
#if ((FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) && (FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE == STD_ON))
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[u8Instance];
#else
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[u8Instance];
    e326:	f89d 3007 	ldrb.w	r3, [sp, #7]
    e32a:	4a25      	ldr	r2, [pc, #148]	; (e3c0 <FlexCAN_Ip_AbortTransfer+0xb8>)
    e32c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e330:	9303      	str	r3, [sp, #12]
#endif /* (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) && (FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE == STD_ON) */
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    e332:	2300      	movs	r3, #0
    e334:	9305      	str	r3, [sp, #20]

    if (mb_idx < (uint8)FLEXCAN_IP_FEATURE_MAX_MB_NUM)
    e336:	f89d 3006 	ldrb.w	r3, [sp, #6]
    e33a:	2b1f      	cmp	r3, #31
    e33c:	d838      	bhi.n	e3b0 <FlexCAN_Ip_AbortTransfer+0xa8>
    {

    if (FLEXCAN_MB_IDLE == state->mbs[mb_idx].state)
    e33e:	f89d 3006 	ldrb.w	r3, [sp, #6]
    e342:	9a03      	ldr	r2, [sp, #12]
    e344:	011b      	lsls	r3, r3, #4
    e346:	4413      	add	r3, r2
    e348:	3304      	adds	r3, #4
    e34a:	681b      	ldr	r3, [r3, #0]
    e34c:	2b00      	cmp	r3, #0
    e34e:	d102      	bne.n	e356 <FlexCAN_Ip_AbortTransfer+0x4e>
    {
        result = FLEXCAN_STATUS_NO_TRANSFER_IN_PROGRESS;
    e350:	2305      	movs	r3, #5
    e352:	9305      	str	r3, [sp, #20]
    e354:	e02c      	b.n	e3b0 <FlexCAN_Ip_AbortTransfer+0xa8>
    }
    else
    {
        FLEXCAN_ClearMsgBuffIntCmd(pBase, u8Instance, mb_idx, state->isIntActive);
    e356:	f89d 2006 	ldrb.w	r2, [sp, #6]
    e35a:	9b03      	ldr	r3, [sp, #12]
    e35c:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    e360:	f89d 1007 	ldrb.w	r1, [sp, #7]
    e364:	9804      	ldr	r0, [sp, #16]
    e366:	f000 feb3 	bl	f0d0 <FLEXCAN_ClearMsgBuffIntCmd>
        if (FLEXCAN_MB_TX_BUSY == state->mbs[mb_idx].state)
    e36a:	f89d 3006 	ldrb.w	r3, [sp, #6]
    e36e:	9a03      	ldr	r2, [sp, #12]
    e370:	011b      	lsls	r3, r3, #4
    e372:	4413      	add	r3, r2
    e374:	3304      	adds	r3, #4
    e376:	681b      	ldr	r3, [r3, #0]
    e378:	2b02      	cmp	r3, #2
    e37a:	d108      	bne.n	e38e <FlexCAN_Ip_AbortTransfer+0x86>
        {
            result = FlexCAN_AbortTxTransfer(u8Instance, mb_idx);
    e37c:	f89d 2006 	ldrb.w	r2, [sp, #6]
    e380:	f89d 3007 	ldrb.w	r3, [sp, #7]
    e384:	4611      	mov	r1, r2
    e386:	4618      	mov	r0, r3
    e388:	f7fe fabc 	bl	c904 <FlexCAN_AbortTxTransfer>
    e38c:	9005      	str	r0, [sp, #20]
        }

        if (FLEXCAN_MB_RX_BUSY == state->mbs[mb_idx].state)
    e38e:	f89d 3006 	ldrb.w	r3, [sp, #6]
    e392:	9a03      	ldr	r2, [sp, #12]
    e394:	011b      	lsls	r3, r3, #4
    e396:	4413      	add	r3, r2
    e398:	3304      	adds	r3, #4
    e39a:	681b      	ldr	r3, [r3, #0]
    e39c:	2b01      	cmp	r3, #1
    e39e:	d107      	bne.n	e3b0 <FlexCAN_Ip_AbortTransfer+0xa8>
        {
            FlexCAN_AbortRxTransfer(u8Instance, mb_idx);
    e3a0:	f89d 2006 	ldrb.w	r2, [sp, #6]
    e3a4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    e3a8:	4611      	mov	r1, r2
    e3aa:	4618      	mov	r0, r3
    e3ac:	f7fe fb34 	bl	ca18 <FlexCAN_AbortRxTransfer>
        }
    }
#endif /* if FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */
#endif /* if FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO */

    return result;
    e3b0:	9b05      	ldr	r3, [sp, #20]
}
    e3b2:	4618      	mov	r0, r3
    e3b4:	b007      	add	sp, #28
    e3b6:	f85d fb04 	ldr.w	pc, [sp], #4
    e3ba:	bf00      	nop
    e3bc:	000186d8 	.word	0x000186d8
    e3c0:	1fff9360 	.word	0x1fff9360

0000e3c4 <FlexCAN_Ip_SetRxMb14Mask_Privileged>:

/* implements    FlexCAN_Ip_SetRxMb14Mask_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetRxMb14Mask_Privileged(uint8 instance, uint32 mask)
{
    e3c4:	b500      	push	{lr}
    e3c6:	b087      	sub	sp, #28
    e3c8:	4603      	mov	r3, r0
    e3ca:	9100      	str	r1, [sp, #0]
    e3cc:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    e3d0:	2300      	movs	r3, #0
    e3d2:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    e3d4:	2300      	movs	r3, #0
    e3d6:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    e3d8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    e3dc:	4a1b      	ldr	r2, [pc, #108]	; (e44c <FlexCAN_Ip_SetRxMb14Mask_Privileged+0x88>)
    e3de:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e3e2:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    boolean freeze = FALSE;
#endif
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    e3e4:	9803      	ldr	r0, [sp, #12]
    e3e6:	f7fd fb5b 	bl	baa0 <FlexCAN_IsEnabled>
    e3ea:	4603      	mov	r3, r0
    e3ec:	2b00      	cmp	r3, #0
    e3ee:	bf14      	ite	ne
    e3f0:	2301      	movne	r3, #1
    e3f2:	2300      	moveq	r3, #0
    e3f4:	b2db      	uxtb	r3, r3
    e3f6:	f083 0301 	eor.w	r3, r3, #1
    e3fa:	b2db      	uxtb	r3, r3
    e3fc:	f88d 300b 	strb.w	r3, [sp, #11]
    e400:	f89d 300b 	ldrb.w	r3, [sp, #11]
    e404:	f003 0301 	and.w	r3, r3, #1
    e408:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    e40c:	f89d 300b 	ldrb.w	r3, [sp, #11]
    e410:	2b00      	cmp	r3, #0
    e412:	d003      	beq.n	e41c <FlexCAN_Ip_SetRxMb14Mask_Privileged+0x58>
    {
        result = FlexCAN_Enable(pBase);
    e414:	9803      	ldr	r0, [sp, #12]
    e416:	f000 fb65 	bl	eae4 <FlexCAN_Enable>
    e41a:	9005      	str	r0, [sp, #20]
    if ((FALSE == freeze) && (FLEXCAN_STATUS_SUCCESS == result))
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif
    if (FLEXCAN_STATUS_SUCCESS == result)
    e41c:	9b05      	ldr	r3, [sp, #20]
    e41e:	2b00      	cmp	r3, #0
    e420:	d102      	bne.n	e428 <FlexCAN_Ip_SetRxMb14Mask_Privileged+0x64>
    {
        pBase->RX14MASK = mask;
    e422:	9b03      	ldr	r3, [sp, #12]
    e424:	9a00      	ldr	r2, [sp, #0]
    e426:	615a      	str	r2, [r3, #20]
    }
    if (TRUE == disabled)
    e428:	f89d 300b 	ldrb.w	r3, [sp, #11]
    e42c:	2b00      	cmp	r3, #0
    e42e:	d008      	beq.n	e442 <FlexCAN_Ip_SetRxMb14Mask_Privileged+0x7e>
    {
        status = FlexCAN_Disable(pBase);
    e430:	9803      	ldr	r0, [sp, #12]
    e432:	f000 fbd5 	bl	ebe0 <FlexCAN_Disable>
    e436:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    e438:	9b04      	ldr	r3, [sp, #16]
    e43a:	2b00      	cmp	r3, #0
    e43c:	d001      	beq.n	e442 <FlexCAN_Ip_SetRxMb14Mask_Privileged+0x7e>
        {
            result = status;
    e43e:	9b04      	ldr	r3, [sp, #16]
    e440:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    e442:	9b05      	ldr	r3, [sp, #20]
}
    e444:	4618      	mov	r0, r3
    e446:	b007      	add	sp, #28
    e448:	f85d fb04 	ldr.w	pc, [sp], #4
    e44c:	000186d8 	.word	0x000186d8

0000e450 <FlexCAN_Ip_SetRxMb15Mask_Privileged>:

/* implements    FlexCAN_Ip_SetRxMb15Mask_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetRxMb15Mask_Privileged(uint8 instance, uint32 mask)
{
    e450:	b500      	push	{lr}
    e452:	b087      	sub	sp, #28
    e454:	4603      	mov	r3, r0
    e456:	9100      	str	r1, [sp, #0]
    e458:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    e45c:	2300      	movs	r3, #0
    e45e:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    e460:	2300      	movs	r3, #0
    e462:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    e464:	f89d 3007 	ldrb.w	r3, [sp, #7]
    e468:	4a1b      	ldr	r2, [pc, #108]	; (e4d8 <FlexCAN_Ip_SetRxMb15Mask_Privileged+0x88>)
    e46a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e46e:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    boolean freeze = FALSE;
#endif
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    e470:	9803      	ldr	r0, [sp, #12]
    e472:	f7fd fb15 	bl	baa0 <FlexCAN_IsEnabled>
    e476:	4603      	mov	r3, r0
    e478:	2b00      	cmp	r3, #0
    e47a:	bf14      	ite	ne
    e47c:	2301      	movne	r3, #1
    e47e:	2300      	moveq	r3, #0
    e480:	b2db      	uxtb	r3, r3
    e482:	f083 0301 	eor.w	r3, r3, #1
    e486:	b2db      	uxtb	r3, r3
    e488:	f88d 300b 	strb.w	r3, [sp, #11]
    e48c:	f89d 300b 	ldrb.w	r3, [sp, #11]
    e490:	f003 0301 	and.w	r3, r3, #1
    e494:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    e498:	f89d 300b 	ldrb.w	r3, [sp, #11]
    e49c:	2b00      	cmp	r3, #0
    e49e:	d003      	beq.n	e4a8 <FlexCAN_Ip_SetRxMb15Mask_Privileged+0x58>
    {
        result = FlexCAN_Enable(pBase);
    e4a0:	9803      	ldr	r0, [sp, #12]
    e4a2:	f000 fb1f 	bl	eae4 <FlexCAN_Enable>
    e4a6:	9005      	str	r0, [sp, #20]
    if ((FALSE == freeze) && (FLEXCAN_STATUS_SUCCESS == result))
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif
    if (FLEXCAN_STATUS_SUCCESS == result)
    e4a8:	9b05      	ldr	r3, [sp, #20]
    e4aa:	2b00      	cmp	r3, #0
    e4ac:	d102      	bne.n	e4b4 <FlexCAN_Ip_SetRxMb15Mask_Privileged+0x64>
    {
        pBase->RX15MASK = mask;
    e4ae:	9b03      	ldr	r3, [sp, #12]
    e4b0:	9a00      	ldr	r2, [sp, #0]
    e4b2:	619a      	str	r2, [r3, #24]
    }

    if (TRUE == disabled)
    e4b4:	f89d 300b 	ldrb.w	r3, [sp, #11]
    e4b8:	2b00      	cmp	r3, #0
    e4ba:	d008      	beq.n	e4ce <FlexCAN_Ip_SetRxMb15Mask_Privileged+0x7e>
    {
        status = FlexCAN_Disable(pBase);
    e4bc:	9803      	ldr	r0, [sp, #12]
    e4be:	f000 fb8f 	bl	ebe0 <FlexCAN_Disable>
    e4c2:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    e4c4:	9b04      	ldr	r3, [sp, #16]
    e4c6:	2b00      	cmp	r3, #0
    e4c8:	d001      	beq.n	e4ce <FlexCAN_Ip_SetRxMb15Mask_Privileged+0x7e>
        {
            result = status;
    e4ca:	9b04      	ldr	r3, [sp, #16]
    e4cc:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    e4ce:	9b05      	ldr	r3, [sp, #20]
}
    e4d0:	4618      	mov	r0, r3
    e4d2:	b007      	add	sp, #28
    e4d4:	f85d fb04 	ldr.w	pc, [sp], #4
    e4d8:	000186d8 	.word	0x000186d8

0000e4dc <FlexCAN_Ip_SetListenOnlyMode_Privileged>:
 * This function will enable or disable Listen Only mode.
 *
 *END**************************************************************************/
/* implements  FlexCAN_Ip_SetListenOnlyMode_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetListenOnlyMode_Privileged(uint8 instance, const boolean enable)
{
    e4dc:	b500      	push	{lr}
    e4de:	b087      	sub	sp, #28
    e4e0:	4603      	mov	r3, r0
    e4e2:	460a      	mov	r2, r1
    e4e4:	f88d 3007 	strb.w	r3, [sp, #7]
    e4e8:	4613      	mov	r3, r2
    e4ea:	f88d 3006 	strb.w	r3, [sp, #6]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    e4ee:	2300      	movs	r3, #0
    e4f0:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    e4f2:	2300      	movs	r3, #0
    e4f4:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    e4f6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    e4fa:	4a1f      	ldr	r2, [pc, #124]	; (e578 <FlexCAN_Ip_SetListenOnlyMode_Privileged+0x9c>)
    e4fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e500:	9303      	str	r3, [sp, #12]
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    e502:	9803      	ldr	r0, [sp, #12]
    e504:	f7fd facc 	bl	baa0 <FlexCAN_IsEnabled>
    e508:	4603      	mov	r3, r0
    e50a:	2b00      	cmp	r3, #0
    e50c:	bf14      	ite	ne
    e50e:	2301      	movne	r3, #1
    e510:	2300      	moveq	r3, #0
    e512:	b2db      	uxtb	r3, r3
    e514:	f083 0301 	eor.w	r3, r3, #1
    e518:	b2db      	uxtb	r3, r3
    e51a:	f88d 300b 	strb.w	r3, [sp, #11]
    e51e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    e522:	f003 0301 	and.w	r3, r3, #1
    e526:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    e52a:	f89d 300b 	ldrb.w	r3, [sp, #11]
    e52e:	2b00      	cmp	r3, #0
    e530:	d003      	beq.n	e53a <FlexCAN_Ip_SetListenOnlyMode_Privileged+0x5e>
    {
        result = FlexCAN_Enable(pBase);
    e532:	9803      	ldr	r0, [sp, #12]
    e534:	f000 fad6 	bl	eae4 <FlexCAN_Enable>
    e538:	9005      	str	r0, [sp, #20]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    e53a:	9b05      	ldr	r3, [sp, #20]
    e53c:	2b00      	cmp	r3, #0
    e53e:	d109      	bne.n	e554 <FlexCAN_Ip_SetListenOnlyMode_Privileged+0x78>
    {
        /* Start critical section: implementation depends on integrator */
        SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10();
    e540:	f005 ff5a 	bl	143f8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10>
        FlexCAN_SetListenOnlyMode(pBase, enable);
    e544:	f89d 3006 	ldrb.w	r3, [sp, #6]
    e548:	4619      	mov	r1, r3
    e54a:	9803      	ldr	r0, [sp, #12]
    e54c:	f7fd fae5 	bl	bb1a <FlexCAN_SetListenOnlyMode>
        /* End critical section: implementation depends on integrator */
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10();
    e550:	f005 ff7e 	bl	14450 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10>
    }

    if (TRUE == disabled)
    e554:	f89d 300b 	ldrb.w	r3, [sp, #11]
    e558:	2b00      	cmp	r3, #0
    e55a:	d008      	beq.n	e56e <FlexCAN_Ip_SetListenOnlyMode_Privileged+0x92>
    {
        status = FlexCAN_Disable(pBase);
    e55c:	9803      	ldr	r0, [sp, #12]
    e55e:	f000 fb3f 	bl	ebe0 <FlexCAN_Disable>
    e562:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    e564:	9b04      	ldr	r3, [sp, #16]
    e566:	2b00      	cmp	r3, #0
    e568:	d001      	beq.n	e56e <FlexCAN_Ip_SetListenOnlyMode_Privileged+0x92>
        {
            result = status;
    e56a:	9b04      	ldr	r3, [sp, #16]
    e56c:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    e56e:	9b05      	ldr	r3, [sp, #20]
}
    e570:	4618      	mov	r0, r3
    e572:	b007      	add	sp, #28
    e574:	f85d fb04 	ldr.w	pc, [sp], #4
    e578:	000186d8 	.word	0x000186d8

0000e57c <FlexCAN_Ip_GetListenOnlyMode>:
 * Description   : Check if Listen Only mode is ENABLE.
 *
 *END**************************************************************************/
/* implements  FlexCAN_Ip_GetListenOnlyMode_Activity */
boolean FlexCAN_Ip_GetListenOnlyMode(uint8 instance)
{
    e57c:	b500      	push	{lr}
    e57e:	b085      	sub	sp, #20
    e580:	4603      	mov	r3, r0
    e582:	f88d 3007 	strb.w	r3, [sp, #7]
    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    e586:	f89d 3007 	ldrb.w	r3, [sp, #7]
    e58a:	4a06      	ldr	r2, [pc, #24]	; (e5a4 <FlexCAN_Ip_GetListenOnlyMode+0x28>)
    e58c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e590:	9303      	str	r3, [sp, #12]
    return FlexCAN_IsListenOnlyModeEnabled(base);
    e592:	9803      	ldr	r0, [sp, #12]
    e594:	f7fd fc5d 	bl	be52 <FlexCAN_IsListenOnlyModeEnabled>
    e598:	4603      	mov	r3, r0
}
    e59a:	4618      	mov	r0, r3
    e59c:	b005      	add	sp, #20
    e59e:	f85d fb04 	ldr.w	pc, [sp], #4
    e5a2:	bf00      	nop
    e5a4:	000186d8 	.word	0x000186d8

0000e5a8 <FlexCAN_Ip_ManualBusOffRecovery>:
 * Description   : Recover manually from bus-off if possible.
 *
 *END**************************************************************************/
/* implements  FlexCAN_Ip_ManualBusOffRecovery_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_ManualBusOffRecovery(uint8 Instance)
{
    e5a8:	b500      	push	{lr}
    e5aa:	b089      	sub	sp, #36	; 0x24
    e5ac:	4603      	mov	r3, r0
    e5ae:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * Base = Flexcan_Ip_apxBase[Instance];
    e5b2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    e5b6:	4a27      	ldr	r2, [pc, #156]	; (e654 <FlexCAN_Ip_ManualBusOffRecovery+0xac>)
    e5b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e5bc:	9305      	str	r3, [sp, #20]
    uint32 timeStart = 0U;
    e5be:	2300      	movs	r3, #0
    e5c0:	9303      	str	r3, [sp, #12]
    uint32 timeElapsed = 0U;
    e5c2:	2300      	movs	r3, #0
    e5c4:	9307      	str	r3, [sp, #28]
    uint32 uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    e5c6:	2100      	movs	r1, #0
    e5c8:	4823      	ldr	r0, [pc, #140]	; (e658 <FlexCAN_Ip_ManualBusOffRecovery+0xb0>)
    e5ca:	f7f3 fcfb 	bl	1fc4 <OsIf_MicrosToTicks>
    e5ce:	9004      	str	r0, [sp, #16]
    Flexcan_Ip_StatusType RetVal = FLEXCAN_STATUS_ERROR;
    e5d0:	2301      	movs	r3, #1
    e5d2:	9306      	str	r3, [sp, #24]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < FLEXCAN_INSTANCE_COUNT);
#endif

    /* Recover from bus-off when Automatic recovering from Bus Off state disabled. */
    if ((Base->CTRL1 & FLEXCAN_CTRL1_BOFFREC_MASK) != 0U)
    e5d4:	9b05      	ldr	r3, [sp, #20]
    e5d6:	685b      	ldr	r3, [r3, #4]
    e5d8:	f003 0340 	and.w	r3, r3, #64	; 0x40
    e5dc:	2b00      	cmp	r3, #0
    e5de:	d033      	beq.n	e648 <FlexCAN_Ip_ManualBusOffRecovery+0xa0>
    {
        RetVal = FLEXCAN_STATUS_SUCCESS;
    e5e0:	2300      	movs	r3, #0
    e5e2:	9306      	str	r3, [sp, #24]
        /* return success if the controller is not in bus-off */
        if ((Base->ESR1 & FLEXCAN_IP_ESR1_FLTCONF_BUS_OFF) != 0U)
    e5e4:	9b05      	ldr	r3, [sp, #20]
    e5e6:	6a1b      	ldr	r3, [r3, #32]
    e5e8:	f003 0320 	and.w	r3, r3, #32
    e5ec:	2b00      	cmp	r3, #0
    e5ee:	d02b      	beq.n	e648 <FlexCAN_Ip_ManualBusOffRecovery+0xa0>
        {
            SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20();
    e5f0:	f006 fa36 	bl	14a60 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20>
            /* negate to recover from bus-off */
            Base->CTRL1 &= ~FLEXCAN_CTRL1_BOFFREC_MASK;
    e5f4:	9b05      	ldr	r3, [sp, #20]
    e5f6:	685b      	ldr	r3, [r3, #4]
    e5f8:	f023 0240 	bic.w	r2, r3, #64	; 0x40
    e5fc:	9b05      	ldr	r3, [sp, #20]
    e5fe:	605a      	str	r2, [r3, #4]
            /* re-assert to disable bus-off auto reocvery */
            Base->CTRL1 |= FLEXCAN_CTRL1_BOFFREC_MASK;
    e600:	9b05      	ldr	r3, [sp, #20]
    e602:	685b      	ldr	r3, [r3, #4]
    e604:	f043 0240 	orr.w	r2, r3, #64	; 0x40
    e608:	9b05      	ldr	r3, [sp, #20]
    e60a:	605a      	str	r2, [r3, #4]
            SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20();
    e60c:	f006 fa54 	bl	14ab8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20>
            /* Wait till exit bus-off */
            timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    e610:	2000      	movs	r0, #0
    e612:	f7f3 fc8b 	bl	1f2c <OsIf_GetCounter>
    e616:	4603      	mov	r3, r0
    e618:	9303      	str	r3, [sp, #12]

            while ((Base->ESR1 & FLEXCAN_IP_ESR1_FLTCONF_BUS_OFF) != 0U)
    e61a:	e00f      	b.n	e63c <FlexCAN_Ip_ManualBusOffRecovery+0x94>
            {
                timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    e61c:	ab03      	add	r3, sp, #12
    e61e:	2100      	movs	r1, #0
    e620:	4618      	mov	r0, r3
    e622:	f7f3 fc9c 	bl	1f5e <OsIf_GetElapsed>
    e626:	4602      	mov	r2, r0
    e628:	9b07      	ldr	r3, [sp, #28]
    e62a:	4413      	add	r3, r2
    e62c:	9307      	str	r3, [sp, #28]
                if (timeElapsed >= uS2Ticks)
    e62e:	9a07      	ldr	r2, [sp, #28]
    e630:	9b04      	ldr	r3, [sp, #16]
    e632:	429a      	cmp	r2, r3
    e634:	d302      	bcc.n	e63c <FlexCAN_Ip_ManualBusOffRecovery+0x94>
                {
                    RetVal = FLEXCAN_STATUS_TIMEOUT;
    e636:	2303      	movs	r3, #3
    e638:	9306      	str	r3, [sp, #24]
                    break;
    e63a:	e005      	b.n	e648 <FlexCAN_Ip_ManualBusOffRecovery+0xa0>
            while ((Base->ESR1 & FLEXCAN_IP_ESR1_FLTCONF_BUS_OFF) != 0U)
    e63c:	9b05      	ldr	r3, [sp, #20]
    e63e:	6a1b      	ldr	r3, [r3, #32]
    e640:	f003 0320 	and.w	r3, r3, #32
    e644:	2b00      	cmp	r3, #0
    e646:	d1e9      	bne.n	e61c <FlexCAN_Ip_ManualBusOffRecovery+0x74>
                }
            }
        }
    }

    return RetVal;
    e648:	9b06      	ldr	r3, [sp, #24]
}
    e64a:	4618      	mov	r0, r3
    e64c:	b009      	add	sp, #36	; 0x24
    e64e:	f85d fb04 	ldr.w	pc, [sp], #4
    e652:	bf00      	nop
    e654:	000186d8 	.word	0x000186d8
    e658:	000f4240 	.word	0x000f4240

0000e65c <FlexCAN_SetSelfReception>:
{
    e65c:	b082      	sub	sp, #8
    e65e:	9001      	str	r0, [sp, #4]
    e660:	460b      	mov	r3, r1
    e662:	f88d 3003 	strb.w	r3, [sp, #3]
    base->MCR = (base->MCR & ~FLEXCAN_MCR_SRXDIS_MASK) | FLEXCAN_MCR_SRXDIS(enable ? 0UL : 1UL);
    e666:	9b01      	ldr	r3, [sp, #4]
    e668:	681b      	ldr	r3, [r3, #0]
    e66a:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    e66e:	f89d 2003 	ldrb.w	r2, [sp, #3]
    e672:	2a00      	cmp	r2, #0
    e674:	d001      	beq.n	e67a <FlexCAN_SetSelfReception+0x1e>
    e676:	2200      	movs	r2, #0
    e678:	e001      	b.n	e67e <FlexCAN_SetSelfReception+0x22>
    e67a:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    e67e:	431a      	orrs	r2, r3
    e680:	9b01      	ldr	r3, [sp, #4]
    e682:	601a      	str	r2, [r3, #0]
}
    e684:	bf00      	nop
    e686:	b002      	add	sp, #8
    e688:	4770      	bx	lr

0000e68a <FlexCAN_IsFDEnabled>:
{
    e68a:	b082      	sub	sp, #8
    e68c:	9001      	str	r0, [sp, #4]
    return ((base->MCR & FLEXCAN_MCR_FDEN_MASK) >> FLEXCAN_MCR_FDEN_SHIFT) != 0U;
    e68e:	9b01      	ldr	r3, [sp, #4]
    e690:	681b      	ldr	r3, [r3, #0]
    e692:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    e696:	2b00      	cmp	r3, #0
    e698:	bf14      	ite	ne
    e69a:	2301      	movne	r3, #1
    e69c:	2300      	moveq	r3, #0
    e69e:	b2db      	uxtb	r3, r3
}
    e6a0:	4618      	mov	r0, r3
    e6a2:	b002      	add	sp, #8
    e6a4:	4770      	bx	lr

0000e6a6 <FlexCAN_SetIsoCan>:
{
    e6a6:	b082      	sub	sp, #8
    e6a8:	9001      	str	r0, [sp, #4]
    e6aa:	460b      	mov	r3, r1
    e6ac:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_ISOCANFDEN_MASK) | FLEXCAN_CTRL2_ISOCANFDEN(enable ? 1UL : 0UL);
    e6b0:	9b01      	ldr	r3, [sp, #4]
    e6b2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    e6b4:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    e6b8:	f89d 2003 	ldrb.w	r2, [sp, #3]
    e6bc:	2a00      	cmp	r2, #0
    e6be:	d002      	beq.n	e6c6 <FlexCAN_SetIsoCan+0x20>
    e6c0:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    e6c4:	e000      	b.n	e6c8 <FlexCAN_SetIsoCan+0x22>
    e6c6:	2200      	movs	r2, #0
    e6c8:	431a      	orrs	r2, r3
    e6ca:	9b01      	ldr	r3, [sp, #4]
    e6cc:	635a      	str	r2, [r3, #52]	; 0x34
}
    e6ce:	bf00      	nop
    e6d0:	b002      	add	sp, #8
    e6d2:	4770      	bx	lr

0000e6d4 <FlexCAN_SetEntireFrameArbitrationFieldComparison>:
{
    e6d4:	b082      	sub	sp, #8
    e6d6:	9001      	str	r0, [sp, #4]
    e6d8:	460b      	mov	r3, r1
    e6da:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_EACEN_MASK) | FLEXCAN_CTRL2_EACEN(enable ? 1UL : 0UL);
    e6de:	9b01      	ldr	r3, [sp, #4]
    e6e0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    e6e2:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    e6e6:	f89d 2003 	ldrb.w	r2, [sp, #3]
    e6ea:	2a00      	cmp	r2, #0
    e6ec:	d002      	beq.n	e6f4 <FlexCAN_SetEntireFrameArbitrationFieldComparison+0x20>
    e6ee:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    e6f2:	e000      	b.n	e6f6 <FlexCAN_SetEntireFrameArbitrationFieldComparison+0x22>
    e6f4:	2200      	movs	r2, #0
    e6f6:	431a      	orrs	r2, r3
    e6f8:	9b01      	ldr	r3, [sp, #4]
    e6fa:	635a      	str	r2, [r3, #52]	; 0x34
}
    e6fc:	bf00      	nop
    e6fe:	b002      	add	sp, #8
    e700:	4770      	bx	lr

0000e702 <FlexCAN_SetProtocolException>:
{
    e702:	b082      	sub	sp, #8
    e704:	9001      	str	r0, [sp, #4]
    e706:	460b      	mov	r3, r1
    e708:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_PREXCEN_MASK) | FLEXCAN_CTRL2_PREXCEN(enable ? 1UL : 0UL);
    e70c:	9b01      	ldr	r3, [sp, #4]
    e70e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    e710:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
    e714:	f89d 2003 	ldrb.w	r2, [sp, #3]
    e718:	2a00      	cmp	r2, #0
    e71a:	d002      	beq.n	e722 <FlexCAN_SetProtocolException+0x20>
    e71c:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    e720:	e000      	b.n	e724 <FlexCAN_SetProtocolException+0x22>
    e722:	2200      	movs	r2, #0
    e724:	431a      	orrs	r2, r3
    e726:	9b01      	ldr	r3, [sp, #4]
    e728:	635a      	str	r2, [r3, #52]	; 0x34
}
    e72a:	bf00      	nop
    e72c:	b002      	add	sp, #8
    e72e:	4770      	bx	lr

0000e730 <FlexCAN_SetRemoteReqStore>:
{
    e730:	b082      	sub	sp, #8
    e732:	9001      	str	r0, [sp, #4]
    e734:	460b      	mov	r3, r1
    e736:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_RRS_MASK) | FLEXCAN_CTRL2_RRS(enable ? 1UL : 0UL);
    e73a:	9b01      	ldr	r3, [sp, #4]
    e73c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    e73e:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    e742:	f89d 2003 	ldrb.w	r2, [sp, #3]
    e746:	2a00      	cmp	r2, #0
    e748:	d002      	beq.n	e750 <FlexCAN_SetRemoteReqStore+0x20>
    e74a:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    e74e:	e000      	b.n	e752 <FlexCAN_SetRemoteReqStore+0x22>
    e750:	2200      	movs	r2, #0
    e752:	431a      	orrs	r2, r3
    e754:	9b01      	ldr	r3, [sp, #4]
    e756:	635a      	str	r2, [r3, #52]	; 0x34
}
    e758:	bf00      	nop
    e75a:	b002      	add	sp, #8
    e75c:	4770      	bx	lr

0000e75e <FlexCAN_SetBusOffAutorecovery>:
{
    e75e:	b082      	sub	sp, #8
    e760:	9001      	str	r0, [sp, #4]
    e762:	460b      	mov	r3, r1
    e764:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_BOFFREC_MASK) | FLEXCAN_CTRL1_BOFFREC(enable ? 0UL : 1UL);
    e768:	9b01      	ldr	r3, [sp, #4]
    e76a:	685b      	ldr	r3, [r3, #4]
    e76c:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    e770:	f89d 2003 	ldrb.w	r2, [sp, #3]
    e774:	2a00      	cmp	r2, #0
    e776:	d001      	beq.n	e77c <FlexCAN_SetBusOffAutorecovery+0x1e>
    e778:	2200      	movs	r2, #0
    e77a:	e000      	b.n	e77e <FlexCAN_SetBusOffAutorecovery+0x20>
    e77c:	2240      	movs	r2, #64	; 0x40
    e77e:	431a      	orrs	r2, r3
    e780:	9b01      	ldr	r3, [sp, #4]
    e782:	605a      	str	r2, [r3, #4]
}
    e784:	bf00      	nop
    e786:	b002      	add	sp, #8
    e788:	4770      	bx	lr

0000e78a <FlexCAN_SetEdgeFilter>:
{
    e78a:	b082      	sub	sp, #8
    e78c:	9001      	str	r0, [sp, #4]
    e78e:	460b      	mov	r3, r1
    e790:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_EDFLTDIS_MASK) | FLEXCAN_CTRL2_EDFLTDIS(enable ? 0UL : 1UL);
    e794:	9b01      	ldr	r3, [sp, #4]
    e796:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    e798:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    e79c:	f89d 2003 	ldrb.w	r2, [sp, #3]
    e7a0:	2a00      	cmp	r2, #0
    e7a2:	d001      	beq.n	e7a8 <FlexCAN_SetEdgeFilter+0x1e>
    e7a4:	2200      	movs	r2, #0
    e7a6:	e001      	b.n	e7ac <FlexCAN_SetEdgeFilter+0x22>
    e7a8:	f44f 6200 	mov.w	r2, #2048	; 0x800
    e7ac:	431a      	orrs	r2, r3
    e7ae:	9b01      	ldr	r3, [sp, #4]
    e7b0:	635a      	str	r2, [r3, #52]	; 0x34
}
    e7b2:	bf00      	nop
    e7b4:	b002      	add	sp, #8
    e7b6:	4770      	bx	lr

0000e7b8 <FlexCAN_CanBitSampling>:
{
    e7b8:	b082      	sub	sp, #8
    e7ba:	9001      	str	r0, [sp, #4]
    e7bc:	460b      	mov	r3, r1
    e7be:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_SMP_MASK) | FLEXCAN_CTRL1_SMP(enable ? 1UL : 0UL);
    e7c2:	9b01      	ldr	r3, [sp, #4]
    e7c4:	685b      	ldr	r3, [r3, #4]
    e7c6:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    e7ca:	f89d 2003 	ldrb.w	r2, [sp, #3]
    e7ce:	2a00      	cmp	r2, #0
    e7d0:	d001      	beq.n	e7d6 <FlexCAN_CanBitSampling+0x1e>
    e7d2:	2280      	movs	r2, #128	; 0x80
    e7d4:	e000      	b.n	e7d8 <FlexCAN_CanBitSampling+0x20>
    e7d6:	2200      	movs	r2, #0
    e7d8:	431a      	orrs	r2, r3
    e7da:	9b01      	ldr	r3, [sp, #4]
    e7dc:	605a      	str	r2, [r3, #4]
}
    e7de:	bf00      	nop
    e7e0:	b002      	add	sp, #8
    e7e2:	4770      	bx	lr

0000e7e4 <FlexCAN_ComputeDLCValue>:
 * Function Name: FLEXCAN_ComputeDLCValue
 * Description  : Computes the DLC field value, given a payload size (in bytes).
 *
 *END**************************************************************************/
static uint8 FlexCAN_ComputeDLCValue(uint8 payloadSize)
{
    e7e4:	b084      	sub	sp, #16
    e7e6:	4603      	mov	r3, r0
    e7e8:	f88d 3007 	strb.w	r3, [sp, #7]
    uint32 ret = 0xFFU;                   /* 0,  1,  2,  3,  4,  5,  6,  7,  8, */
    e7ec:	23ff      	movs	r3, #255	; 0xff
    e7ee:	9303      	str	r3, [sp, #12]
                                           FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES,
                                           FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES,
                                           FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES
                                          };

    if (payloadSize <= 64U)
    e7f0:	f89d 3007 	ldrb.w	r3, [sp, #7]
    e7f4:	2b40      	cmp	r3, #64	; 0x40
    e7f6:	d804      	bhi.n	e802 <FlexCAN_ComputeDLCValue+0x1e>
    {
        ret = payload_code[payloadSize];
    e7f8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    e7fc:	4a03      	ldr	r2, [pc, #12]	; (e80c <FlexCAN_ComputeDLCValue+0x28>)
    e7fe:	5cd3      	ldrb	r3, [r2, r3]
    e800:	9303      	str	r3, [sp, #12]
    else
    {
        /* The argument is not a valid payload size will return 0xFF*/
    }

    return (uint8)ret;
    e802:	9b03      	ldr	r3, [sp, #12]
    e804:	b2db      	uxtb	r3, r3
}
    e806:	4618      	mov	r0, r3
    e808:	b004      	add	sp, #16
    e80a:	4770      	bx	lr
    e80c:	000186e4 	.word	0x000186e4

0000e810 <FlexCAN_ClearRAM>:
 * Function Name : FLEXCAN_ClearRAM
 * Description   : Clears FlexCAN memory positions that require initialization.
 *
 *END**************************************************************************/
static void FlexCAN_ClearRAM(FLEXCAN_Type * base)
{
    e810:	b500      	push	{lr}
    e812:	b087      	sub	sp, #28
    e814:	9001      	str	r0, [sp, #4]
    uint32 databyte;
    uint32 RAM_size   = FlexCAN_GetMaxMbNum(base) * 4U;
    e816:	9801      	ldr	r0, [sp, #4]
    e818:	f000 f8f6 	bl	ea08 <FlexCAN_GetMaxMbNum>
    e81c:	4603      	mov	r3, r0
    e81e:	009b      	lsls	r3, r3, #2
    e820:	9304      	str	r3, [sp, #16]
    uint32 RXIMR_size = FlexCAN_GetMaxMbNum(base);
    e822:	9801      	ldr	r0, [sp, #4]
    e824:	f000 f8f0 	bl	ea08 <FlexCAN_GetMaxMbNum>
    e828:	9003      	str	r0, [sp, #12]
    /* Address of base + ram offset to point to MB start address */
    volatile uint32 * RAM = (uint32 *)((Flexcan_Ip_PtrSizeType)base + (uint32)FLEXCAN_IP_FEATURE_RAM_OFFSET);
    e82a:	9b01      	ldr	r3, [sp, #4]
    e82c:	3380      	adds	r3, #128	; 0x80
    e82e:	9302      	str	r3, [sp, #8]
    /* Clear MB region */
    for (databyte = 0U; databyte < RAM_size; databyte++)
    e830:	2300      	movs	r3, #0
    e832:	9305      	str	r3, [sp, #20]
    e834:	e008      	b.n	e848 <FlexCAN_ClearRAM+0x38>
    {
        RAM[databyte] = 0x0U;
    e836:	9b05      	ldr	r3, [sp, #20]
    e838:	009b      	lsls	r3, r3, #2
    e83a:	9a02      	ldr	r2, [sp, #8]
    e83c:	4413      	add	r3, r2
    e83e:	2200      	movs	r2, #0
    e840:	601a      	str	r2, [r3, #0]
    for (databyte = 0U; databyte < RAM_size; databyte++)
    e842:	9b05      	ldr	r3, [sp, #20]
    e844:	3301      	adds	r3, #1
    e846:	9305      	str	r3, [sp, #20]
    e848:	9a05      	ldr	r2, [sp, #20]
    e84a:	9b04      	ldr	r3, [sp, #16]
    e84c:	429a      	cmp	r2, r3
    e84e:	d3f2      	bcc.n	e836 <FlexCAN_ClearRAM+0x26>
    }
    RAM = (volatile uint32 *)base->RXIMR;
    e850:	9b01      	ldr	r3, [sp, #4]
    e852:	f503 6308 	add.w	r3, r3, #2176	; 0x880
    e856:	9302      	str	r3, [sp, #8]
    /* Clear RXIMR region */
    for (databyte = 0U; databyte < RXIMR_size; databyte++)
    e858:	2300      	movs	r3, #0
    e85a:	9305      	str	r3, [sp, #20]
    e85c:	e008      	b.n	e870 <FlexCAN_ClearRAM+0x60>
    {
        RAM[databyte] = 0x0U;
    e85e:	9b05      	ldr	r3, [sp, #20]
    e860:	009b      	lsls	r3, r3, #2
    e862:	9a02      	ldr	r2, [sp, #8]
    e864:	4413      	add	r3, r2
    e866:	2200      	movs	r2, #0
    e868:	601a      	str	r2, [r3, #0]
    for (databyte = 0U; databyte < RXIMR_size; databyte++)
    e86a:	9b05      	ldr	r3, [sp, #20]
    e86c:	3301      	adds	r3, #1
    e86e:	9305      	str	r3, [sp, #20]
    e870:	9a05      	ldr	r2, [sp, #20]
    e872:	9b03      	ldr	r3, [sp, #12]
    e874:	429a      	cmp	r2, r3
    e876:	d3f2      	bcc.n	e85e <FlexCAN_ClearRAM+0x4e>
    }
#endif
    /* Clear WRMFRZ bit in CTRL2 Register to restrict write access to memory */
    base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_WRMFRZ_MASK) | FLEXCAN_CTRL2_WRMFRZ(0U);
#endif /* if FLEXCAN_IP_FEATURE_HAS_MEM_ERR_DET */
}
    e878:	bf00      	nop
    e87a:	bf00      	nop
    e87c:	b007      	add	sp, #28
    e87e:	f85d fb04 	ldr.w	pc, [sp], #4

0000e882 <FlexCAN_ComputePayloadSize>:
#if (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON)
uint8 FlexCAN_ComputePayloadSize(uint8 dlcValue)
#else
static uint8 FlexCAN_ComputePayloadSize(uint8 dlcValue)
#endif /* (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) */
{
    e882:	b084      	sub	sp, #16
    e884:	4603      	mov	r3, r0
    e886:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 ret = 8U;
    e88a:	2308      	movs	r3, #8
    e88c:	f88d 300f 	strb.w	r3, [sp, #15]

    if (dlcValue <= 8U)
    e890:	f89d 3007 	ldrb.w	r3, [sp, #7]
    e894:	2b08      	cmp	r3, #8
    e896:	d804      	bhi.n	e8a2 <FlexCAN_ComputePayloadSize+0x20>
    {
        ret = dlcValue;
    e898:	f89d 3007 	ldrb.w	r3, [sp, #7]
    e89c:	f88d 300f 	strb.w	r3, [sp, #15]
    e8a0:	e033      	b.n	e90a <FlexCAN_ComputePayloadSize+0x88>
    }
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
    else
    {
        switch (dlcValue)
    e8a2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    e8a6:	3b09      	subs	r3, #9
    e8a8:	2b06      	cmp	r3, #6
    e8aa:	d82d      	bhi.n	e908 <FlexCAN_ComputePayloadSize+0x86>
    e8ac:	a201      	add	r2, pc, #4	; (adr r2, e8b4 <FlexCAN_ComputePayloadSize+0x32>)
    e8ae:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    e8b2:	bf00      	nop
    e8b4:	0000e8d1 	.word	0x0000e8d1
    e8b8:	0000e8d9 	.word	0x0000e8d9
    e8bc:	0000e8e1 	.word	0x0000e8e1
    e8c0:	0000e8e9 	.word	0x0000e8e9
    e8c4:	0000e8f1 	.word	0x0000e8f1
    e8c8:	0000e8f9 	.word	0x0000e8f9
    e8cc:	0000e901 	.word	0x0000e901
        {
            case FLEXCAN_IP_DLC_VALUE_12_BYTES:
                ret = 12U;
    e8d0:	230c      	movs	r3, #12
    e8d2:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    e8d6:	e018      	b.n	e90a <FlexCAN_ComputePayloadSize+0x88>
            case FLEXCAN_IP_DLC_VALUE_16_BYTES:
                ret = 16U;
    e8d8:	2310      	movs	r3, #16
    e8da:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    e8de:	e014      	b.n	e90a <FlexCAN_ComputePayloadSize+0x88>
            case FLEXCAN_IP_DLC_VALUE_20_BYTES:
                ret = 20U;
    e8e0:	2314      	movs	r3, #20
    e8e2:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    e8e6:	e010      	b.n	e90a <FlexCAN_ComputePayloadSize+0x88>
            case FLEXCAN_IP_DLC_VALUE_24_BYTES:
                ret = 24U;
    e8e8:	2318      	movs	r3, #24
    e8ea:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    e8ee:	e00c      	b.n	e90a <FlexCAN_ComputePayloadSize+0x88>
            case FLEXCAN_IP_DLC_VALUE_32_BYTES:
                ret = 32U;
    e8f0:	2320      	movs	r3, #32
    e8f2:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    e8f6:	e008      	b.n	e90a <FlexCAN_ComputePayloadSize+0x88>
            case FLEXCAN_IP_DLC_VALUE_48_BYTES:
                ret = 48U;
    e8f8:	2330      	movs	r3, #48	; 0x30
    e8fa:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    e8fe:	e004      	b.n	e90a <FlexCAN_ComputePayloadSize+0x88>
            case FLEXCAN_IP_DLC_VALUE_64_BYTES:
                ret = 64U;
    e900:	2340      	movs	r3, #64	; 0x40
    e902:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    e906:	e000      	b.n	e90a <FlexCAN_ComputePayloadSize+0x88>
            default:
                /* The argument is not a valid DLC size */
                break;
    e908:	bf00      	nop
        }
    }
#endif /* FLEXCAN_IP_FEATURE_HAS_FD */

    return ret;
    e90a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    e90e:	4618      	mov	r0, r3
    e910:	b004      	add	sp, #16
    e912:	4770      	bx	lr

0000e914 <FlexCAN_GetMsgBuffRegion>:
 * Function Name : FLEXCAN_GetMsgBuffRegion
 * Description   : Returns the start of a MB area, based on its index.
 *
 *END**************************************************************************/
volatile uint32 * FlexCAN_GetMsgBuffRegion(const FLEXCAN_Type * base, uint32 msgBuffIdx)
{
    e914:	b500      	push	{lr}
    e916:	b08b      	sub	sp, #44	; 0x2c
    e918:	9001      	str	r0, [sp, #4]
    e91a:	9100      	str	r1, [sp, #0]
    uint8 arbitration_field_size = 8U;
    e91c:	2308      	movs	r3, #8
    e91e:	f88d 3020 	strb.w	r3, [sp, #32]
    uint8 mb_size = 0U;
    e922:	2300      	movs	r3, #0
    e924:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    uint32 ramBlockSize = 512U;
    e928:	f44f 7300 	mov.w	r3, #512	; 0x200
    e92c:	9307      	str	r3, [sp, #28]
    uint16 ramBlockOffset = 0;
    e92e:	2300      	movs	r3, #0
    e930:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    uint8 msgBuffIdxBackup = (uint8)msgBuffIdx;
    e934:	9b00      	ldr	r3, [sp, #0]
    e936:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    uint8 i=0U;
    e93a:	2300      	movs	r3, #0
    e93c:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    uint8 maxMbNum=0U;
    e940:	2300      	movs	r3, #0
    e942:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
    uint32 mb_index=0U;
    e946:	2300      	movs	r3, #0
    e948:	9306      	str	r3, [sp, #24]
    uint8 payload_size=0U;
    e94a:	2300      	movs	r3, #0
    e94c:	f88d 3017 	strb.w	r3, [sp, #23]
    volatile uint32 * RAM = (uint32*)((Flexcan_Ip_PtrSizeType)base + (uint32)FLEXCAN_IP_FEATURE_RAM_OFFSET);
    e950:	9b01      	ldr	r3, [sp, #4]
    e952:	3380      	adds	r3, #128	; 0x80
    e954:	9304      	str	r3, [sp, #16]
    volatile uint32 * pAddressRet = NULL_PTR;
    e956:	2300      	movs	r3, #0
    e958:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_FEATURE_HAS_EXPANDABLE_MEMORY == STD_ON)
    volatile uint32 * RAM_EXPANDED = (uint32*)((Flexcan_Ip_PtrSizeType)base + (uint32)FLEXCAN_IP_FEATURE_EXP_RAM_OFFSET);
#endif

    for (i=0; i< (uint8)FLEXCAN_IP_FEATURE_MBDSR_COUNT; i++)
    e95a:	2300      	movs	r3, #0
    e95c:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    e960:	e02d      	b.n	e9be <FlexCAN_GetMsgBuffRegion+0xaa>
    {
        payload_size = FlexCAN_GetPayloadSize(base, i);
    e962:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
    e966:	4619      	mov	r1, r3
    e968:	9801      	ldr	r0, [sp, #4]
    e96a:	f000 fad1 	bl	ef10 <FlexCAN_GetPayloadSize>
    e96e:	4603      	mov	r3, r0
    e970:	f88d 3017 	strb.w	r3, [sp, #23]
        mb_size = (uint8)(payload_size + arbitration_field_size);
    e974:	f89d 2017 	ldrb.w	r2, [sp, #23]
    e978:	f89d 3020 	ldrb.w	r3, [sp, #32]
    e97c:	4413      	add	r3, r2
    e97e:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
        maxMbNum = (uint8)(ramBlockSize / mb_size);
    e982:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    e986:	9a07      	ldr	r2, [sp, #28]
    e988:	fbb2 f3f3 	udiv	r3, r2, r3
    e98c:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
        if (maxMbNum > msgBuffIdxBackup)
    e990:	f89d 2021 	ldrb.w	r2, [sp, #33]	; 0x21
    e994:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    e998:	429a      	cmp	r2, r3
    e99a:	d815      	bhi.n	e9c8 <FlexCAN_GetMsgBuffRegion+0xb4>
        {
            break;
        }
        ramBlockOffset += 128U;
    e99c:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    e9a0:	3380      	adds	r3, #128	; 0x80
    e9a2:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
        msgBuffIdxBackup -= maxMbNum;
    e9a6:	f89d 2023 	ldrb.w	r2, [sp, #35]	; 0x23
    e9aa:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
    e9ae:	1ad3      	subs	r3, r2, r3
    e9b0:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    for (i=0; i< (uint8)FLEXCAN_IP_FEATURE_MBDSR_COUNT; i++)
    e9b4:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
    e9b8:	3301      	adds	r3, #1
    e9ba:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    e9be:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
    e9c2:	2b00      	cmp	r3, #0
    e9c4:	d0cd      	beq.n	e962 <FlexCAN_GetMsgBuffRegion+0x4e>
    e9c6:	e000      	b.n	e9ca <FlexCAN_GetMsgBuffRegion+0xb6>
            break;
    e9c8:	bf00      	nop
    }
    else
#endif
    {
        /* Multiply the MB index by the MB size (in words) */
        mb_index = (uint32)ramBlockOffset + (((uint32)msgBuffIdxBackup % (uint32)maxMbNum) * ((uint32)mb_size >> 2U));
    e9ca:	f8bd 1024 	ldrh.w	r1, [sp, #36]	; 0x24
    e9ce:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    e9d2:	f89d 2021 	ldrb.w	r2, [sp, #33]	; 0x21
    e9d6:	fbb3 f0f2 	udiv	r0, r3, r2
    e9da:	fb00 f202 	mul.w	r2, r0, r2
    e9de:	1a9b      	subs	r3, r3, r2
    e9e0:	b2db      	uxtb	r3, r3
    e9e2:	461a      	mov	r2, r3
    e9e4:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    e9e8:	089b      	lsrs	r3, r3, #2
    e9ea:	b2db      	uxtb	r3, r3
    e9ec:	fb02 f303 	mul.w	r3, r2, r3
    e9f0:	440b      	add	r3, r1
    e9f2:	9306      	str	r3, [sp, #24]
        pAddressRet = &(RAM[mb_index]);
    e9f4:	9b06      	ldr	r3, [sp, #24]
    e9f6:	009b      	lsls	r3, r3, #2
    e9f8:	9a04      	ldr	r2, [sp, #16]
    e9fa:	4413      	add	r3, r2
    e9fc:	9303      	str	r3, [sp, #12]
    }

    return pAddressRet;
    e9fe:	9b03      	ldr	r3, [sp, #12]
}
    ea00:	4618      	mov	r0, r3
    ea02:	b00b      	add	sp, #44	; 0x2c
    ea04:	f85d fb04 	ldr.w	pc, [sp], #4

0000ea08 <FlexCAN_GetMaxMbNum>:
 * Function Name : FlexCAN_GetMaxMbNum
 * Description   : Computes the maximum RAM size occupied by MBs.
 *
 *END**************************************************************************/
uint32 FlexCAN_GetMaxMbNum(const FLEXCAN_Type * base)
{
    ea08:	b084      	sub	sp, #16
    ea0a:	9001      	str	r0, [sp, #4]
    uint32 i, ret = 0u;
    ea0c:	2300      	movs	r3, #0
    ea0e:	9302      	str	r3, [sp, #8]
    static FLEXCAN_Type * const flexcanBase[] = IP_FLEXCAN_BASE_PTRS;
    static const uint32 maxMbNum[] = FLEXCAN_IP_FEATURE_MAX_MB_NUM_ARRAY;

    for (i = 0u; i < FLEXCAN_INSTANCE_COUNT; i++)
    ea10:	2300      	movs	r3, #0
    ea12:	9303      	str	r3, [sp, #12]
    ea14:	e00e      	b.n	ea34 <FlexCAN_GetMaxMbNum+0x2c>
    {
        if (base == flexcanBase[i])
    ea16:	4a0b      	ldr	r2, [pc, #44]	; (ea44 <FlexCAN_GetMaxMbNum+0x3c>)
    ea18:	9b03      	ldr	r3, [sp, #12]
    ea1a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ea1e:	9a01      	ldr	r2, [sp, #4]
    ea20:	429a      	cmp	r2, r3
    ea22:	d104      	bne.n	ea2e <FlexCAN_GetMaxMbNum+0x26>
        {
            ret = maxMbNum[i];
    ea24:	4a08      	ldr	r2, [pc, #32]	; (ea48 <FlexCAN_GetMaxMbNum+0x40>)
    ea26:	9b03      	ldr	r3, [sp, #12]
    ea28:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ea2c:	9302      	str	r3, [sp, #8]
    for (i = 0u; i < FLEXCAN_INSTANCE_COUNT; i++)
    ea2e:	9b03      	ldr	r3, [sp, #12]
    ea30:	3301      	adds	r3, #1
    ea32:	9303      	str	r3, [sp, #12]
    ea34:	9b03      	ldr	r3, [sp, #12]
    ea36:	2b02      	cmp	r3, #2
    ea38:	d9ed      	bls.n	ea16 <FlexCAN_GetMaxMbNum+0xe>
        }
    }
    return ret;
    ea3a:	9b02      	ldr	r3, [sp, #8]
}
    ea3c:	4618      	mov	r0, r3
    ea3e:	b004      	add	sp, #16
    ea40:	4770      	bx	lr
    ea42:	bf00      	nop
    ea44:	00018728 	.word	0x00018728
    ea48:	00018734 	.word	0x00018734

0000ea4c <FlexCAN_EnterFreezeMode>:
 * Function Name : FLEXCAN_EnterFreezeMode
 * Description   : Enter the freeze mode.
 *
 *END**************************************************************************/
Flexcan_Ip_StatusType FlexCAN_EnterFreezeMode(FLEXCAN_Type * base)
{
    ea4c:	b500      	push	{lr}
    ea4e:	b087      	sub	sp, #28
    ea50:	9001      	str	r0, [sp, #4]
    uint32 timeStart = 0U;
    ea52:	2300      	movs	r3, #0
    ea54:	9302      	str	r3, [sp, #8]
    uint32 timeElapsed = 0U;
    ea56:	2300      	movs	r3, #0
    ea58:	9305      	str	r3, [sp, #20]
    uint32 uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    ea5a:	2100      	movs	r1, #0
    ea5c:	4820      	ldr	r0, [pc, #128]	; (eae0 <FlexCAN_EnterFreezeMode+0x94>)
    ea5e:	f7f3 fab1 	bl	1fc4 <OsIf_MicrosToTicks>
    ea62:	9003      	str	r0, [sp, #12]
    Flexcan_Ip_StatusType returnResult = FLEXCAN_STATUS_SUCCESS;
    ea64:	2300      	movs	r3, #0
    ea66:	9304      	str	r3, [sp, #16]

    /* Start critical section: implementation depends on integrator */
    SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02();
    ea68:	f005 fa36 	bl	13ed8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02>
    base->MCR = (base->MCR & ~FLEXCAN_MCR_FRZ_MASK) | FLEXCAN_MCR_FRZ(1U);
    ea6c:	9b01      	ldr	r3, [sp, #4]
    ea6e:	681b      	ldr	r3, [r3, #0]
    ea70:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
    ea74:	9b01      	ldr	r3, [sp, #4]
    ea76:	601a      	str	r2, [r3, #0]
    base->MCR = (base->MCR & ~FLEXCAN_MCR_HALT_MASK) | FLEXCAN_MCR_HALT(1U);
    ea78:	9b01      	ldr	r3, [sp, #4]
    ea7a:	681b      	ldr	r3, [r3, #0]
    ea7c:	f043 5280 	orr.w	r2, r3, #268435456	; 0x10000000
    ea80:	9b01      	ldr	r3, [sp, #4]
    ea82:	601a      	str	r2, [r3, #0]
    if (((base->MCR & FLEXCAN_MCR_MDIS_MASK) >> FLEXCAN_MCR_MDIS_SHIFT) != 0U)
    ea84:	9b01      	ldr	r3, [sp, #4]
    ea86:	681b      	ldr	r3, [r3, #0]
    ea88:	2b00      	cmp	r3, #0
    ea8a:	da05      	bge.n	ea98 <FlexCAN_EnterFreezeMode+0x4c>
    {
        base->MCR &= ~FLEXCAN_MCR_MDIS_MASK;
    ea8c:	9b01      	ldr	r3, [sp, #4]
    ea8e:	681b      	ldr	r3, [r3, #0]
    ea90:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
    ea94:	9b01      	ldr	r3, [sp, #4]
    ea96:	601a      	str	r2, [r3, #0]
    }
    /* End critical section: implementation depends on integrator */
    SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02();
    ea98:	f005 fa4a 	bl	13f30 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02>
    /* Wait for entering the freeze mode */
    timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    ea9c:	2000      	movs	r0, #0
    ea9e:	f7f3 fa45 	bl	1f2c <OsIf_GetCounter>
    eaa2:	4603      	mov	r3, r0
    eaa4:	9302      	str	r3, [sp, #8]
    while (0U == ((base->MCR & FLEXCAN_MCR_FRZACK_MASK) >> FLEXCAN_MCR_FRZACK_SHIFT))
    eaa6:	e00f      	b.n	eac8 <FlexCAN_EnterFreezeMode+0x7c>
    {
        timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    eaa8:	ab02      	add	r3, sp, #8
    eaaa:	2100      	movs	r1, #0
    eaac:	4618      	mov	r0, r3
    eaae:	f7f3 fa56 	bl	1f5e <OsIf_GetElapsed>
    eab2:	4602      	mov	r2, r0
    eab4:	9b05      	ldr	r3, [sp, #20]
    eab6:	4413      	add	r3, r2
    eab8:	9305      	str	r3, [sp, #20]
        if (timeElapsed >= uS2Ticks)
    eaba:	9a05      	ldr	r2, [sp, #20]
    eabc:	9b03      	ldr	r3, [sp, #12]
    eabe:	429a      	cmp	r2, r3
    eac0:	d302      	bcc.n	eac8 <FlexCAN_EnterFreezeMode+0x7c>
        {
            returnResult = FLEXCAN_STATUS_TIMEOUT;
    eac2:	2303      	movs	r3, #3
    eac4:	9304      	str	r3, [sp, #16]
            break;
    eac6:	e005      	b.n	ead4 <FlexCAN_EnterFreezeMode+0x88>
    while (0U == ((base->MCR & FLEXCAN_MCR_FRZACK_MASK) >> FLEXCAN_MCR_FRZACK_SHIFT))
    eac8:	9b01      	ldr	r3, [sp, #4]
    eaca:	681b      	ldr	r3, [r3, #0]
    eacc:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
    ead0:	2b00      	cmp	r3, #0
    ead2:	d0e9      	beq.n	eaa8 <FlexCAN_EnterFreezeMode+0x5c>
        }
    }

    return returnResult;
    ead4:	9b04      	ldr	r3, [sp, #16]
}
    ead6:	4618      	mov	r0, r3
    ead8:	b007      	add	sp, #28
    eada:	f85d fb04 	ldr.w	pc, [sp], #4
    eade:	bf00      	nop
    eae0:	000f4240 	.word	0x000f4240

0000eae4 <FlexCAN_Enable>:
 * Function Name : FlexCAN_Enable
 * Description   : Enable the clock for FlexCAN Module.
 *
 *END**************************************************************************/
Flexcan_Ip_StatusType FlexCAN_Enable(FLEXCAN_Type * base)
{
    eae4:	b500      	push	{lr}
    eae6:	b087      	sub	sp, #28
    eae8:	9001      	str	r0, [sp, #4]
    uint32 timeStart = 0U;
    eaea:	2300      	movs	r3, #0
    eaec:	9302      	str	r3, [sp, #8]
    uint32 timeElapsed = 0U;
    eaee:	2300      	movs	r3, #0
    eaf0:	9305      	str	r3, [sp, #20]
    uint32 uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    eaf2:	2100      	movs	r1, #0
    eaf4:	4818      	ldr	r0, [pc, #96]	; (eb58 <FlexCAN_Enable+0x74>)
    eaf6:	f7f3 fa65 	bl	1fc4 <OsIf_MicrosToTicks>
    eafa:	9003      	str	r0, [sp, #12]
    Flexcan_Ip_StatusType returnValue = FLEXCAN_STATUS_SUCCESS;
    eafc:	2300      	movs	r3, #0
    eafe:	9304      	str	r3, [sp, #16]

    /* Start critical section: implementation depends on integrator */
    SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03();
    eb00:	f005 fa3c 	bl	13f7c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03>

    /* Enable Module */
    base->MCR &= ~FLEXCAN_MCR_MDIS_MASK;
    eb04:	9b01      	ldr	r3, [sp, #4]
    eb06:	681b      	ldr	r3, [r3, #0]
    eb08:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
    eb0c:	9b01      	ldr	r3, [sp, #4]
    eb0e:	601a      	str	r2, [r3, #0]
    /* End critical section: implementation depends on integrator */
    SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03();
    eb10:	f005 fa60 	bl	13fd4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03>
    /* Wait for entering the freeze mode */
    timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    eb14:	2000      	movs	r0, #0
    eb16:	f7f3 fa09 	bl	1f2c <OsIf_GetCounter>
    eb1a:	4603      	mov	r3, r0
    eb1c:	9302      	str	r3, [sp, #8]
    while (0U == ((base->MCR & FLEXCAN_MCR_FRZACK_MASK) >> FLEXCAN_MCR_FRZACK_SHIFT))
    eb1e:	e00f      	b.n	eb40 <FlexCAN_Enable+0x5c>
    {
        timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    eb20:	ab02      	add	r3, sp, #8
    eb22:	2100      	movs	r1, #0
    eb24:	4618      	mov	r0, r3
    eb26:	f7f3 fa1a 	bl	1f5e <OsIf_GetElapsed>
    eb2a:	4602      	mov	r2, r0
    eb2c:	9b05      	ldr	r3, [sp, #20]
    eb2e:	4413      	add	r3, r2
    eb30:	9305      	str	r3, [sp, #20]
        if (timeElapsed >= uS2Ticks)
    eb32:	9a05      	ldr	r2, [sp, #20]
    eb34:	9b03      	ldr	r3, [sp, #12]
    eb36:	429a      	cmp	r2, r3
    eb38:	d302      	bcc.n	eb40 <FlexCAN_Enable+0x5c>
        {
            returnValue = FLEXCAN_STATUS_TIMEOUT;
    eb3a:	2303      	movs	r3, #3
    eb3c:	9304      	str	r3, [sp, #16]
            break;
    eb3e:	e005      	b.n	eb4c <FlexCAN_Enable+0x68>
    while (0U == ((base->MCR & FLEXCAN_MCR_FRZACK_MASK) >> FLEXCAN_MCR_FRZACK_SHIFT))
    eb40:	9b01      	ldr	r3, [sp, #4]
    eb42:	681b      	ldr	r3, [r3, #0]
    eb44:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
    eb48:	2b00      	cmp	r3, #0
    eb4a:	d0e9      	beq.n	eb20 <FlexCAN_Enable+0x3c>
        }
    }
    return returnValue;
    eb4c:	9b04      	ldr	r3, [sp, #16]
}
    eb4e:	4618      	mov	r0, r3
    eb50:	b007      	add	sp, #28
    eb52:	f85d fb04 	ldr.w	pc, [sp], #4
    eb56:	bf00      	nop
    eb58:	000f4240 	.word	0x000f4240

0000eb5c <FlexCAN_ExitFreezeMode>:
 * Function Name : FLEXCAN_ExitFreezeMode
 * Description   : Exit of freeze mode.
 *
 *END**************************************************************************/
Flexcan_Ip_StatusType FlexCAN_ExitFreezeMode(FLEXCAN_Type * base)
{
    eb5c:	b500      	push	{lr}
    eb5e:	b087      	sub	sp, #28
    eb60:	9001      	str	r0, [sp, #4]
    uint32 timeStart = 0U;
    eb62:	2300      	movs	r3, #0
    eb64:	9302      	str	r3, [sp, #8]
    uint32 timeElapsed = 0U;
    eb66:	2300      	movs	r3, #0
    eb68:	9305      	str	r3, [sp, #20]
    uint32 uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    eb6a:	2100      	movs	r1, #0
    eb6c:	481b      	ldr	r0, [pc, #108]	; (ebdc <FlexCAN_ExitFreezeMode+0x80>)
    eb6e:	f7f3 fa29 	bl	1fc4 <OsIf_MicrosToTicks>
    eb72:	9003      	str	r0, [sp, #12]
    Flexcan_Ip_StatusType returnValue = FLEXCAN_STATUS_SUCCESS;
    eb74:	2300      	movs	r3, #0
    eb76:	9304      	str	r3, [sp, #16]

    /* Start critical section: implementation depends on integrator */
    SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04();
    eb78:	f005 fa52 	bl	14020 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04>
    base->MCR = (base->MCR & ~FLEXCAN_MCR_HALT_MASK) | FLEXCAN_MCR_HALT(0U);
    eb7c:	9b01      	ldr	r3, [sp, #4]
    eb7e:	681b      	ldr	r3, [r3, #0]
    eb80:	f023 5280 	bic.w	r2, r3, #268435456	; 0x10000000
    eb84:	9b01      	ldr	r3, [sp, #4]
    eb86:	601a      	str	r2, [r3, #0]
    base->MCR = (base->MCR & ~FLEXCAN_MCR_FRZ_MASK) | FLEXCAN_MCR_FRZ(0U);
    eb88:	9b01      	ldr	r3, [sp, #4]
    eb8a:	681b      	ldr	r3, [r3, #0]
    eb8c:	f023 4280 	bic.w	r2, r3, #1073741824	; 0x40000000
    eb90:	9b01      	ldr	r3, [sp, #4]
    eb92:	601a      	str	r2, [r3, #0]
    /* End critical section: implementation depends on integrator */
    SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04();
    eb94:	f005 fa70 	bl	14078 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04>
    /* Wait till exit freeze mode */
    timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    eb98:	2000      	movs	r0, #0
    eb9a:	f7f3 f9c7 	bl	1f2c <OsIf_GetCounter>
    eb9e:	4603      	mov	r3, r0
    eba0:	9302      	str	r3, [sp, #8]
    while (((base->MCR & FLEXCAN_MCR_FRZACK_MASK) >> FLEXCAN_MCR_FRZACK_SHIFT) != 0U)
    eba2:	e00f      	b.n	ebc4 <FlexCAN_ExitFreezeMode+0x68>
    {
        timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    eba4:	ab02      	add	r3, sp, #8
    eba6:	2100      	movs	r1, #0
    eba8:	4618      	mov	r0, r3
    ebaa:	f7f3 f9d8 	bl	1f5e <OsIf_GetElapsed>
    ebae:	4602      	mov	r2, r0
    ebb0:	9b05      	ldr	r3, [sp, #20]
    ebb2:	4413      	add	r3, r2
    ebb4:	9305      	str	r3, [sp, #20]
        if (timeElapsed >= uS2Ticks)
    ebb6:	9a05      	ldr	r2, [sp, #20]
    ebb8:	9b03      	ldr	r3, [sp, #12]
    ebba:	429a      	cmp	r2, r3
    ebbc:	d302      	bcc.n	ebc4 <FlexCAN_ExitFreezeMode+0x68>
        {
            returnValue = FLEXCAN_STATUS_TIMEOUT;
    ebbe:	2303      	movs	r3, #3
    ebc0:	9304      	str	r3, [sp, #16]
            break;
    ebc2:	e005      	b.n	ebd0 <FlexCAN_ExitFreezeMode+0x74>
    while (((base->MCR & FLEXCAN_MCR_FRZACK_MASK) >> FLEXCAN_MCR_FRZACK_SHIFT) != 0U)
    ebc4:	9b01      	ldr	r3, [sp, #4]
    ebc6:	681b      	ldr	r3, [r3, #0]
    ebc8:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
    ebcc:	2b00      	cmp	r3, #0
    ebce:	d1e9      	bne.n	eba4 <FlexCAN_ExitFreezeMode+0x48>
        }
    }
    return returnValue;
    ebd0:	9b04      	ldr	r3, [sp, #16]
}
    ebd2:	4618      	mov	r0, r3
    ebd4:	b007      	add	sp, #28
    ebd6:	f85d fb04 	ldr.w	pc, [sp], #4
    ebda:	bf00      	nop
    ebdc:	000f4240 	.word	0x000f4240

0000ebe0 <FlexCAN_Disable>:
 * Description   : Disable FlexCAN module.
 * This function will disable FlexCAN module.
 *
 *END**************************************************************************/
Flexcan_Ip_StatusType FlexCAN_Disable(FLEXCAN_Type * base)
{
    ebe0:	b500      	push	{lr}
    ebe2:	b087      	sub	sp, #28
    ebe4:	9001      	str	r0, [sp, #4]
    uint32 timeStart = 0U;
    ebe6:	2300      	movs	r3, #0
    ebe8:	9302      	str	r3, [sp, #8]
    uint32 timeElapsed = 0U;
    ebea:	2300      	movs	r3, #0
    ebec:	9305      	str	r3, [sp, #20]
    uint32 uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    ebee:	2100      	movs	r1, #0
    ebf0:	481a      	ldr	r0, [pc, #104]	; (ec5c <FlexCAN_Disable+0x7c>)
    ebf2:	f7f3 f9e7 	bl	1fc4 <OsIf_MicrosToTicks>
    ebf6:	9003      	str	r0, [sp, #12]
    Flexcan_Ip_StatusType returnResult = FLEXCAN_STATUS_SUCCESS;
    ebf8:	2300      	movs	r3, #0
    ebfa:	9304      	str	r3, [sp, #16]

    /* To access the memory mapped registers */
    /* Enter disable mode (hard reset). */
    if (0U == ((base->MCR & FLEXCAN_MCR_MDIS_MASK) >> FLEXCAN_MCR_MDIS_SHIFT))
    ebfc:	9b01      	ldr	r3, [sp, #4]
    ebfe:	681b      	ldr	r3, [r3, #0]
    ec00:	2b00      	cmp	r3, #0
    ec02:	db25      	blt.n	ec50 <FlexCAN_Disable+0x70>
    {
        /* Start critical section: implementation depends on integrator */
        SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05();
    ec04:	f005 fa5e 	bl	140c4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05>
        /* Clock disable (module) */
        base->MCR = (base->MCR & ~FLEXCAN_MCR_MDIS_MASK) | FLEXCAN_MCR_MDIS(1U);
    ec08:	9b01      	ldr	r3, [sp, #4]
    ec0a:	681b      	ldr	r3, [r3, #0]
    ec0c:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
    ec10:	9b01      	ldr	r3, [sp, #4]
    ec12:	601a      	str	r2, [r3, #0]
        /* End critical section: implementation depends on integrator */
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05();
    ec14:	f005 fa82 	bl	1411c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05>
        /* Wait until disable mode acknowledged */
        timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    ec18:	2000      	movs	r0, #0
    ec1a:	f7f3 f987 	bl	1f2c <OsIf_GetCounter>
    ec1e:	4603      	mov	r3, r0
    ec20:	9302      	str	r3, [sp, #8]
        while (0U == ((base->MCR & FLEXCAN_MCR_LPMACK_MASK) >> FLEXCAN_MCR_LPMACK_SHIFT))
    ec22:	e00f      	b.n	ec44 <FlexCAN_Disable+0x64>
        {
            timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    ec24:	ab02      	add	r3, sp, #8
    ec26:	2100      	movs	r1, #0
    ec28:	4618      	mov	r0, r3
    ec2a:	f7f3 f998 	bl	1f5e <OsIf_GetElapsed>
    ec2e:	4602      	mov	r2, r0
    ec30:	9b05      	ldr	r3, [sp, #20]
    ec32:	4413      	add	r3, r2
    ec34:	9305      	str	r3, [sp, #20]
            if (timeElapsed >= uS2Ticks)
    ec36:	9a05      	ldr	r2, [sp, #20]
    ec38:	9b03      	ldr	r3, [sp, #12]
    ec3a:	429a      	cmp	r2, r3
    ec3c:	d302      	bcc.n	ec44 <FlexCAN_Disable+0x64>
            {
                returnResult = FLEXCAN_STATUS_TIMEOUT;
    ec3e:	2303      	movs	r3, #3
    ec40:	9304      	str	r3, [sp, #16]
                break;
    ec42:	e005      	b.n	ec50 <FlexCAN_Disable+0x70>
        while (0U == ((base->MCR & FLEXCAN_MCR_LPMACK_MASK) >> FLEXCAN_MCR_LPMACK_SHIFT))
    ec44:	9b01      	ldr	r3, [sp, #4]
    ec46:	681b      	ldr	r3, [r3, #0]
    ec48:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    ec4c:	2b00      	cmp	r3, #0
    ec4e:	d0e9      	beq.n	ec24 <FlexCAN_Disable+0x44>
            }
        }
    }
    return returnResult;
    ec50:	9b04      	ldr	r3, [sp, #16]
}
    ec52:	4618      	mov	r0, r3
    ec54:	b007      	add	sp, #28
    ec56:	f85d fb04 	ldr.w	pc, [sp], #4
    ec5a:	bf00      	nop
    ec5c:	000f4240 	.word	0x000f4240

0000ec60 <FlexCAN_SetErrIntCmd>:
 * Description   : Enable the error interrupts.
 * This function will enable Error interrupt.
 *
 *END**************************************************************************/
void FlexCAN_SetErrIntCmd(FLEXCAN_Type * base, flexcan_int_type_t errType, boolean enable)
{
    ec60:	b500      	push	{lr}
    ec62:	b087      	sub	sp, #28
    ec64:	9003      	str	r0, [sp, #12]
    ec66:	9102      	str	r1, [sp, #8]
    ec68:	4613      	mov	r3, r2
    ec6a:	f88d 3007 	strb.w	r3, [sp, #7]
    uint32 temp = (uint32)errType;
    ec6e:	9b02      	ldr	r3, [sp, #8]
    ec70:	9305      	str	r3, [sp, #20]

    /* Start critical section: implementation depends on integrator */
    SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06();
    ec72:	f005 fa79 	bl	14168 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06>
    if (enable)
    ec76:	f89d 3007 	ldrb.w	r3, [sp, #7]
    ec7a:	2b00      	cmp	r3, #0
    ec7c:	d020      	beq.n	ecc0 <FlexCAN_SetErrIntCmd+0x60>
    {
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        if (FLEXCAN_INT_ERR_FAST == errType)
    ec7e:	9b02      	ldr	r3, [sp, #8]
    ec80:	f244 0201 	movw	r2, #16385	; 0x4001
    ec84:	4293      	cmp	r3, r2
    ec86:	d106      	bne.n	ec96 <FlexCAN_SetErrIntCmd+0x36>
        {
            base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_ERRMSK_FAST_MASK) | FLEXCAN_CTRL2_ERRMSK_FAST(1U);
    ec88:	9b03      	ldr	r3, [sp, #12]
    ec8a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    ec8c:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
    ec90:	9b03      	ldr	r3, [sp, #12]
    ec92:	635a      	str	r2, [r3, #52]	; 0x34
    ec94:	e03a      	b.n	ed0c <FlexCAN_SetErrIntCmd+0xac>
            (void)temp;
        }
        else
#endif
        {
            if ((FLEXCAN_INT_RX_WARNING == errType) || (FLEXCAN_INT_TX_WARNING == errType))
    ec96:	9b02      	ldr	r3, [sp, #8]
    ec98:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    ec9c:	d003      	beq.n	eca6 <FlexCAN_SetErrIntCmd+0x46>
    ec9e:	9b02      	ldr	r3, [sp, #8]
    eca0:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
    eca4:	d105      	bne.n	ecb2 <FlexCAN_SetErrIntCmd+0x52>
            {
                base->MCR = (base->MCR & ~FLEXCAN_MCR_WRNEN_MASK) | FLEXCAN_MCR_WRNEN(1U);
    eca6:	9b03      	ldr	r3, [sp, #12]
    eca8:	681b      	ldr	r3, [r3, #0]
    ecaa:	f443 1200 	orr.w	r2, r3, #2097152	; 0x200000
    ecae:	9b03      	ldr	r3, [sp, #12]
    ecb0:	601a      	str	r2, [r3, #0]
            }
            (base->CTRL1) = ((base->CTRL1) | (temp));
    ecb2:	9b03      	ldr	r3, [sp, #12]
    ecb4:	685a      	ldr	r2, [r3, #4]
    ecb6:	9b05      	ldr	r3, [sp, #20]
    ecb8:	431a      	orrs	r2, r3
    ecba:	9b03      	ldr	r3, [sp, #12]
    ecbc:	605a      	str	r2, [r3, #4]
    ecbe:	e025      	b.n	ed0c <FlexCAN_SetErrIntCmd+0xac>
        }
    }
    else
    {
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        if (FLEXCAN_INT_ERR_FAST == errType)
    ecc0:	9b02      	ldr	r3, [sp, #8]
    ecc2:	f244 0201 	movw	r2, #16385	; 0x4001
    ecc6:	4293      	cmp	r3, r2
    ecc8:	d106      	bne.n	ecd8 <FlexCAN_SetErrIntCmd+0x78>
        {
            base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_ERRMSK_FAST_MASK) | FLEXCAN_CTRL2_ERRMSK_FAST(0U);
    ecca:	9b03      	ldr	r3, [sp, #12]
    eccc:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    ecce:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
    ecd2:	9b03      	ldr	r3, [sp, #12]
    ecd4:	635a      	str	r2, [r3, #52]	; 0x34
    ecd6:	e019      	b.n	ed0c <FlexCAN_SetErrIntCmd+0xac>
            (void)temp;
        }
        else
#endif
        {
            (base->CTRL1) = ((base->CTRL1) & ~(temp));
    ecd8:	9b03      	ldr	r3, [sp, #12]
    ecda:	685a      	ldr	r2, [r3, #4]
    ecdc:	9b05      	ldr	r3, [sp, #20]
    ecde:	43db      	mvns	r3, r3
    ece0:	401a      	ands	r2, r3
    ece2:	9b03      	ldr	r3, [sp, #12]
    ece4:	605a      	str	r2, [r3, #4]
            temp = base->CTRL1;
    ece6:	9b03      	ldr	r3, [sp, #12]
    ece8:	685b      	ldr	r3, [r3, #4]
    ecea:	9305      	str	r3, [sp, #20]
            if ((0U == (temp & (uint32)FLEXCAN_INT_RX_WARNING)) && (0U == (temp & (uint32)FLEXCAN_INT_TX_WARNING)))
    ecec:	9b05      	ldr	r3, [sp, #20]
    ecee:	f403 6380 	and.w	r3, r3, #1024	; 0x400
    ecf2:	2b00      	cmp	r3, #0
    ecf4:	d10a      	bne.n	ed0c <FlexCAN_SetErrIntCmd+0xac>
    ecf6:	9b05      	ldr	r3, [sp, #20]
    ecf8:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    ecfc:	2b00      	cmp	r3, #0
    ecfe:	d105      	bne.n	ed0c <FlexCAN_SetErrIntCmd+0xac>
            {
                /* If WRNEN disabled then both FLEXCAN_INT_RX_WARNING and FLEXCAN_INT_TX_WARNING will be disabled */
                base->MCR = (base->MCR & ~FLEXCAN_MCR_WRNEN_MASK) | FLEXCAN_MCR_WRNEN(0U);
    ed00:	9b03      	ldr	r3, [sp, #12]
    ed02:	681b      	ldr	r3, [r3, #0]
    ed04:	f423 1200 	bic.w	r2, r3, #2097152	; 0x200000
    ed08:	9b03      	ldr	r3, [sp, #12]
    ed0a:	601a      	str	r2, [r3, #0]
            }
        }
    }
    /* End critical section: implementation depends on integrator */
    SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06();
    ed0c:	f005 fa58 	bl	141c0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06>
}
    ed10:	bf00      	nop
    ed12:	b007      	add	sp, #28
    ed14:	f85d fb04 	ldr.w	pc, [sp], #4

0000ed18 <FlexCAN_Init>:
 * buffers, initialize all message buffers as inactive, enable RX FIFO
 * if needed, mask all mask bits, and disable all MB interrupts.
 *
 *END**************************************************************************/
Flexcan_Ip_StatusType FlexCAN_Init(FLEXCAN_Type * base)
{
    ed18:	b500      	push	{lr}
    ed1a:	b087      	sub	sp, #28
    ed1c:	9001      	str	r0, [sp, #4]
    uint32 timeStart = 0U;
    ed1e:	2300      	movs	r3, #0
    ed20:	9302      	str	r3, [sp, #8]
    uint32 timeElapsed = 0U;
    ed22:	2300      	movs	r3, #0
    ed24:	9305      	str	r3, [sp, #20]
    uint32 uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    ed26:	2100      	movs	r1, #0
    ed28:	4833      	ldr	r0, [pc, #204]	; (edf8 <FlexCAN_Init+0xe0>)
    ed2a:	f7f3 f94b 	bl	1fc4 <OsIf_MicrosToTicks>
    ed2e:	9003      	str	r0, [sp, #12]
    Flexcan_Ip_StatusType returnResult = FLEXCAN_STATUS_SUCCESS;
    ed30:	2300      	movs	r3, #0
    ed32:	9304      	str	r3, [sp, #16]

    /* Reset the FLEXCAN */
    base->MCR = (base->MCR & ~FLEXCAN_MCR_SOFTRST_MASK) | FLEXCAN_MCR_SOFTRST(1U);
    ed34:	9b01      	ldr	r3, [sp, #4]
    ed36:	681b      	ldr	r3, [r3, #0]
    ed38:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
    ed3c:	9b01      	ldr	r3, [sp, #4]
    ed3e:	601a      	str	r2, [r3, #0]
    /* Wait for reset cycle to complete */
    timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    ed40:	2000      	movs	r0, #0
    ed42:	f7f3 f8f3 	bl	1f2c <OsIf_GetCounter>
    ed46:	4603      	mov	r3, r0
    ed48:	9302      	str	r3, [sp, #8]
    while (((base->MCR & FLEXCAN_MCR_SOFTRST_MASK) >> FLEXCAN_MCR_SOFTRST_SHIFT) != 0U)
    ed4a:	e00f      	b.n	ed6c <FlexCAN_Init+0x54>
    {
        timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    ed4c:	ab02      	add	r3, sp, #8
    ed4e:	2100      	movs	r1, #0
    ed50:	4618      	mov	r0, r3
    ed52:	f7f3 f904 	bl	1f5e <OsIf_GetElapsed>
    ed56:	4602      	mov	r2, r0
    ed58:	9b05      	ldr	r3, [sp, #20]
    ed5a:	4413      	add	r3, r2
    ed5c:	9305      	str	r3, [sp, #20]
        if (timeElapsed >= uS2Ticks)
    ed5e:	9a05      	ldr	r2, [sp, #20]
    ed60:	9b03      	ldr	r3, [sp, #12]
    ed62:	429a      	cmp	r2, r3
    ed64:	d302      	bcc.n	ed6c <FlexCAN_Init+0x54>
        {
            returnResult = FLEXCAN_STATUS_TIMEOUT;
    ed66:	2303      	movs	r3, #3
    ed68:	9304      	str	r3, [sp, #16]
            break;
    ed6a:	e005      	b.n	ed78 <FlexCAN_Init+0x60>
    while (((base->MCR & FLEXCAN_MCR_SOFTRST_MASK) >> FLEXCAN_MCR_SOFTRST_SHIFT) != 0U)
    ed6c:	9b01      	ldr	r3, [sp, #4]
    ed6e:	681b      	ldr	r3, [r3, #0]
    ed70:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
    ed74:	2b00      	cmp	r3, #0
    ed76:	d1e9      	bne.n	ed4c <FlexCAN_Init+0x34>
        }
    }
    if (FLEXCAN_STATUS_SUCCESS == returnResult)
    ed78:	9b04      	ldr	r3, [sp, #16]
    ed7a:	2b00      	cmp	r3, #0
    ed7c:	d136      	bne.n	edec <FlexCAN_Init+0xd4>
    {
        /* Avoid Abort Transmission, use Inactive MB */
        base->MCR = (base->MCR & ~FLEXCAN_MCR_AEN_MASK) | FLEXCAN_MCR_AEN(1U);
    ed7e:	9b01      	ldr	r3, [sp, #4]
    ed80:	681b      	ldr	r3, [r3, #0]
    ed82:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
    ed86:	9b01      	ldr	r3, [sp, #4]
    ed88:	601a      	str	r2, [r3, #0]
        /* Clear FlexCAN memory */
        FlexCAN_ClearRAM(base);
    ed8a:	9801      	ldr	r0, [sp, #4]
    ed8c:	f7ff fd40 	bl	e810 <FlexCAN_ClearRAM>
        /* Rx global mask*/
        (base->RXMGMASK) = (uint32)(FLEXCAN_RXMGMASK_MG_MASK);
    ed90:	9b01      	ldr	r3, [sp, #4]
    ed92:	f04f 32ff 	mov.w	r2, #4294967295
    ed96:	611a      	str	r2, [r3, #16]
        /* Rx reg 14 mask*/
        (base->RX14MASK) =  (uint32)(FLEXCAN_RX14MASK_RX14M_MASK);
    ed98:	9b01      	ldr	r3, [sp, #4]
    ed9a:	f04f 32ff 	mov.w	r2, #4294967295
    ed9e:	615a      	str	r2, [r3, #20]
        /* Rx reg 15 mask*/
        (base->RX15MASK) = (uint32)(FLEXCAN_RX15MASK_RX15M_MASK);
    eda0:	9b01      	ldr	r3, [sp, #4]
    eda2:	f04f 32ff 	mov.w	r2, #4294967295
    eda6:	619a      	str	r2, [r3, #24]
        /* Disable all MB interrupts */
        (base->IMASK1) = 0x0;
    eda8:	9b01      	ldr	r3, [sp, #4]
    edaa:	2200      	movs	r2, #0
    edac:	629a      	str	r2, [r3, #40]	; 0x28
        /* Clear all MB interrupt flags */
        (base->IFLAG1) = FLEXCAN_IMASK1_BUF31TO0M_MASK;
    edae:	9b01      	ldr	r3, [sp, #4]
    edb0:	f04f 32ff 	mov.w	r2, #4294967295
    edb4:	631a      	str	r2, [r3, #48]	; 0x30
            (base->IMASK4) = 0x0;
            (base->IFLAG4) = FLEXCAN_IMASK4_BUF127TO96M_MASK;
        }
#endif
        /* Clear all error interrupt flags */
        (base->ESR1) = FLEXCAN_IP_ALL_INT;
    edb6:	9b01      	ldr	r3, [sp, #4]
    edb8:	4a10      	ldr	r2, [pc, #64]	; (edfc <FlexCAN_Init+0xe4>)
    edba:	621a      	str	r2, [r3, #32]
        /* clear registers which are not effected by soft reset */
        base->CTRL1 = FLEXCAN_IP_CTRL1_DEFAULT_VALUE_U32;
    edbc:	9b01      	ldr	r3, [sp, #4]
    edbe:	2200      	movs	r2, #0
    edc0:	605a      	str	r2, [r3, #4]
        base->CTRL2 = FLEXCAN_IP_CTRL2_DEFAULT_VALUE_U32;
    edc2:	9b01      	ldr	r3, [sp, #4]
    edc4:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    edc8:	635a      	str	r2, [r3, #52]	; 0x34
        base->CBT   = FLEXCAN_IP_CBT_DEFAULT_VALUE_U32;
    edca:	9b01      	ldr	r3, [sp, #4]
    edcc:	2200      	movs	r2, #0
    edce:	651a      	str	r2, [r3, #80]	; 0x50
        base->EDCBT = FLEXCAN_IP_EDCBT_DEFAULT_VALUE_U32;
        base->ETDC  = FLEXCAN_IP_ETDC_DEFAULT_VALUE_U32;
#endif
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
    #if defined(CAN_FEATURE_S32K1XX)
    if (TRUE == FlexCAN_IsFDAvailable(base))
    edd0:	9801      	ldr	r0, [sp, #4]
    edd2:	f000 f85b 	bl	ee8c <FlexCAN_IsFDAvailable>
    edd6:	4603      	mov	r3, r0
    edd8:	2b00      	cmp	r3, #0
    edda:	d007      	beq.n	edec <FlexCAN_Init+0xd4>
    {
    #endif /* defined(CAN_FEATURE_S32K1XX) */
        base->FDCBT = FLEXCAN_IP_FDCBT_DEFAULT_VALUE_U32;
    eddc:	9b01      	ldr	r3, [sp, #4]
    edde:	2200      	movs	r2, #0
    ede0:	f8c3 2c04 	str.w	r2, [r3, #3076]	; 0xc04
        base->FDCTRL = FLEXCAN_IP_FDCTRL_DEFAULT_VALUE_U32;
    ede4:	9b01      	ldr	r3, [sp, #4]
    ede6:	4a06      	ldr	r2, [pc, #24]	; (ee00 <FlexCAN_Init+0xe8>)
    ede8:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
    #if defined(CAN_FEATURE_S32K1XX)
    }
    #endif /* defined(CAN_FEATURE_S32K1XX) */
#endif /* (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON) */
    }
    return returnResult;
    edec:	9b04      	ldr	r3, [sp, #16]
}
    edee:	4618      	mov	r0, r3
    edf0:	b007      	add	sp, #28
    edf2:	f85d fb04 	ldr.w	pc, [sp], #4
    edf6:	bf00      	nop
    edf8:	000f4240 	.word	0x000f4240
    edfc:	003b0006 	.word	0x003b0006
    ee00:	80004100 	.word	0x80004100

0000ee04 <FlexCAN_EnableRxFifo>:
 * This function will enable the Rx FIFO feature.
 *
 *END**************************************************************************/
Flexcan_Ip_StatusType FlexCAN_EnableRxFifo(FLEXCAN_Type * base,
                                         uint32 numOfFilters)
{
    ee04:	b500      	push	{lr}
    ee06:	b087      	sub	sp, #28
    ee08:	9001      	str	r0, [sp, #4]
    ee0a:	9100      	str	r1, [sp, #0]
    uint32 i;
    uint16 noOfMbx = (uint16)FlexCAN_GetMaxMbNum(base);
    ee0c:	9801      	ldr	r0, [sp, #4]
    ee0e:	f7ff fdfb 	bl	ea08 <FlexCAN_GetMaxMbNum>
    ee12:	4603      	mov	r3, r0
    ee14:	f8ad 300e 	strh.w	r3, [sp, #14]
    Flexcan_Ip_StatusType stat = FLEXCAN_STATUS_SUCCESS;
    ee18:	2300      	movs	r3, #0
    ee1a:	9304      	str	r3, [sp, #16]

    /* RxFIFO cannot be enabled if FD is enabled */
    if (((base->MCR & FLEXCAN_MCR_FDEN_MASK) >> FLEXCAN_MCR_FDEN_SHIFT) != 0U)
    ee1c:	9b01      	ldr	r3, [sp, #4]
    ee1e:	681b      	ldr	r3, [r3, #0]
    ee20:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    ee24:	2b00      	cmp	r3, #0
    ee26:	d001      	beq.n	ee2c <FlexCAN_EnableRxFifo+0x28>
    {
        stat = FLEXCAN_STATUS_ERROR;
    ee28:	2301      	movs	r3, #1
    ee2a:	9304      	str	r3, [sp, #16]
    }
    if (FLEXCAN_STATUS_SUCCESS == stat)
    ee2c:	9b04      	ldr	r3, [sp, #16]
    ee2e:	2b00      	cmp	r3, #0
    ee30:	d127      	bne.n	ee82 <FlexCAN_EnableRxFifo+0x7e>
    {
        /* Enable RX FIFO */
        base->MCR = (base->MCR & ~FLEXCAN_MCR_RFEN_MASK) | FLEXCAN_MCR_RFEN(1U);
    ee32:	9b01      	ldr	r3, [sp, #4]
    ee34:	681b      	ldr	r3, [r3, #0]
    ee36:	f043 5200 	orr.w	r2, r3, #536870912	; 0x20000000
    ee3a:	9b01      	ldr	r3, [sp, #4]
    ee3c:	601a      	str	r2, [r3, #0]
        /* Set the number of the RX FIFO filters needed */
        base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_RFFN_MASK) | ((numOfFilters << FLEXCAN_CTRL2_RFFN_SHIFT) & FLEXCAN_CTRL2_RFFN_MASK);
    ee3e:	9b01      	ldr	r3, [sp, #4]
    ee40:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    ee42:	f023 6270 	bic.w	r2, r3, #251658240	; 0xf000000
    ee46:	9b00      	ldr	r3, [sp, #0]
    ee48:	061b      	lsls	r3, r3, #24
    ee4a:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    ee4e:	431a      	orrs	r2, r3
    ee50:	9b01      	ldr	r3, [sp, #4]
    ee52:	635a      	str	r2, [r3, #52]	; 0x34
        /* RX FIFO global mask, take in consideration all filter fields*/
        (base->RXFGMASK) = FLEXCAN_RXFGMASK_FGM_MASK;
    ee54:	9b01      	ldr	r3, [sp, #4]
    ee56:	f04f 32ff 	mov.w	r2, #4294967295
    ee5a:	649a      	str	r2, [r3, #72]	; 0x48

        for (i = 0U; i < noOfMbx; i++)
    ee5c:	2300      	movs	r3, #0
    ee5e:	9305      	str	r3, [sp, #20]
    ee60:	e00a      	b.n	ee78 <FlexCAN_EnableRxFifo+0x74>
        {
            /* RX individual mask */
            base->RXIMR[i] = (FLEXCAN_RXIMR_MI_MASK << FLEXCAN_IP_ID_EXT_SHIFT) & (FLEXCAN_IP_ID_STD_MASK | FLEXCAN_IP_ID_EXT_MASK);
    ee62:	9b01      	ldr	r3, [sp, #4]
    ee64:	9a05      	ldr	r2, [sp, #20]
    ee66:	f502 7208 	add.w	r2, r2, #544	; 0x220
    ee6a:	f06f 4160 	mvn.w	r1, #3758096384	; 0xe0000000
    ee6e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        for (i = 0U; i < noOfMbx; i++)
    ee72:	9b05      	ldr	r3, [sp, #20]
    ee74:	3301      	adds	r3, #1
    ee76:	9305      	str	r3, [sp, #20]
    ee78:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    ee7c:	9a05      	ldr	r2, [sp, #20]
    ee7e:	429a      	cmp	r2, r3
    ee80:	d3ef      	bcc.n	ee62 <FlexCAN_EnableRxFifo+0x5e>
        }
    }
    return stat;
    ee82:	9b04      	ldr	r3, [sp, #16]
}
    ee84:	4618      	mov	r0, r3
    ee86:	b007      	add	sp, #28
    ee88:	f85d fb04 	ldr.w	pc, [sp], #4

0000ee8c <FlexCAN_IsFDAvailable>:
 * Description   : Checks if FlexCAN has FD Support.
 * This function is private.
 *
 *END**************************************************************************/
boolean FlexCAN_IsFDAvailable(const FLEXCAN_Type * base)
{
    ee8c:	b084      	sub	sp, #16
    ee8e:	9001      	str	r0, [sp, #4]
    uint32 i=0U;
    ee90:	2300      	movs	r3, #0
    ee92:	9303      	str	r3, [sp, #12]
    static FLEXCAN_Type * const flexcanBase[] = CAN_BASE_PTRS_HAS_FD;
    boolean returnValue = FALSE;
    ee94:	2300      	movs	r3, #0
    ee96:	f88d 300b 	strb.w	r3, [sp, #11]
    for (i = 0U; i < CAN_FEATURE_FD_INSTANCES; i++)
    ee9a:	2300      	movs	r3, #0
    ee9c:	9303      	str	r3, [sp, #12]
    ee9e:	e00d      	b.n	eebc <FlexCAN_IsFDAvailable+0x30>
    {
        if (base == flexcanBase[i])
    eea0:	4a0a      	ldr	r2, [pc, #40]	; (eecc <FlexCAN_IsFDAvailable+0x40>)
    eea2:	9b03      	ldr	r3, [sp, #12]
    eea4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    eea8:	9a01      	ldr	r2, [sp, #4]
    eeaa:	429a      	cmp	r2, r3
    eeac:	d103      	bne.n	eeb6 <FlexCAN_IsFDAvailable+0x2a>
        {
            returnValue = TRUE;
    eeae:	2301      	movs	r3, #1
    eeb0:	f88d 300b 	strb.w	r3, [sp, #11]
            break;
    eeb4:	e005      	b.n	eec2 <FlexCAN_IsFDAvailable+0x36>
    for (i = 0U; i < CAN_FEATURE_FD_INSTANCES; i++)
    eeb6:	9b03      	ldr	r3, [sp, #12]
    eeb8:	3301      	adds	r3, #1
    eeba:	9303      	str	r3, [sp, #12]
    eebc:	9b03      	ldr	r3, [sp, #12]
    eebe:	2b00      	cmp	r3, #0
    eec0:	d0ee      	beq.n	eea0 <FlexCAN_IsFDAvailable+0x14>
        }
    }

    return returnValue;
    eec2:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
    eec6:	4618      	mov	r0, r3
    eec8:	b004      	add	sp, #16
    eeca:	4770      	bx	lr
    eecc:	00018740 	.word	0x00018740

0000eed0 <FlexCAN_SetPayloadSize>:
 * Description   : Sets the payload size of the MBs.
 *
 *END**************************************************************************/
void FlexCAN_SetPayloadSize(FLEXCAN_Type * base,
                            const Flexcan_Ip_PayloadSizeType * payloadSize)
{
    eed0:	b500      	push	{lr}
    eed2:	b085      	sub	sp, #20
    eed4:	9001      	str	r0, [sp, #4]
    eed6:	9100      	str	r1, [sp, #0]
    #if (FLEXCAN_IP_FEATURE_MBDSR_COUNT > 3U)
    DevAssert(FlexCAN_IsFDEnabled(base) || (FLEXCAN_PAYLOAD_SIZE_8 == payloadSize->payloadBlock3));
    #endif
#endif
    /* If FD is not enabled, only 8 bytes payload is supported */
    if (FlexCAN_IsFDEnabled(base))
    eed8:	9801      	ldr	r0, [sp, #4]
    eeda:	f7ff fbd6 	bl	e68a <FlexCAN_IsFDEnabled>
    eede:	4603      	mov	r3, r0
    eee0:	2b00      	cmp	r3, #0
    eee2:	d011      	beq.n	ef08 <FlexCAN_SetPayloadSize+0x38>
    {
        tmp = base->FDCTRL;
    eee4:	9b01      	ldr	r3, [sp, #4]
    eee6:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    eeea:	9303      	str	r3, [sp, #12]
        tmp &= ~(FLEXCAN_FDCTRL_MBDSR0_MASK);
    eeec:	9b03      	ldr	r3, [sp, #12]
    eeee:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    eef2:	9303      	str	r3, [sp, #12]
        tmp |= ((uint32)payloadSize->payloadBlock0) << FLEXCAN_FDCTRL_MBDSR0_SHIFT;
    eef4:	9b00      	ldr	r3, [sp, #0]
    eef6:	681b      	ldr	r3, [r3, #0]
    eef8:	041b      	lsls	r3, r3, #16
    eefa:	9a03      	ldr	r2, [sp, #12]
    eefc:	4313      	orrs	r3, r2
    eefe:	9303      	str	r3, [sp, #12]
#endif
#if (FLEXCAN_IP_FEATURE_MBDSR_COUNT > 3U)
        tmp &= ~(FLEXCAN_FDCTRL_MBDSR3_MASK);
        tmp |= ((uint32)payloadSize->payloadBlock3) << FLEXCAN_FDCTRL_MBDSR3_SHIFT;
#endif
        base->FDCTRL = tmp;
    ef00:	9b01      	ldr	r3, [sp, #4]
    ef02:	9a03      	ldr	r2, [sp, #12]
    ef04:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
    }
}
    ef08:	bf00      	nop
    ef0a:	b005      	add	sp, #20
    ef0c:	f85d fb04 	ldr.w	pc, [sp], #4

0000ef10 <FlexCAN_GetPayloadSize>:
 * Function Name : FLEXCAN_GetPayloadSize
 * Description   : Returns the payload size of the MBs (in bytes).
 *
 *END**************************************************************************/
static uint8 FlexCAN_GetPayloadSize(const FLEXCAN_Type * base, uint8 mbdsrIdx)
{
    ef10:	b500      	push	{lr}
    ef12:	b085      	sub	sp, #20
    ef14:	9001      	str	r0, [sp, #4]
    ef16:	460b      	mov	r3, r1
    ef18:	f88d 3003 	strb.w	r3, [sp, #3]
    uint32 payloadSize = 0U;
    ef1c:	2300      	movs	r3, #0
    ef1e:	9303      	str	r3, [sp, #12]

#if defined(CAN_FEATURE_S32K1XX)
    if (TRUE == FlexCAN_IsFDAvailable(base))
    ef20:	9801      	ldr	r0, [sp, #4]
    ef22:	f7ff ffb3 	bl	ee8c <FlexCAN_IsFDAvailable>
    ef26:	4603      	mov	r3, r0
    ef28:	2b00      	cmp	r3, #0
    ef2a:	d019      	beq.n	ef60 <FlexCAN_GetPayloadSize+0x50>
    {
#endif /* defined(CAN_FEATURE_S32K1XX) */
    switch (mbdsrIdx)
    ef2c:	f89d 3003 	ldrb.w	r3, [sp, #3]
    ef30:	2b00      	cmp	r3, #0
    ef32:	d10a      	bne.n	ef4a <FlexCAN_GetPayloadSize+0x3a>
    {
        case 0 : {  payloadSize = 8UL << ((base->FDCTRL & FLEXCAN_FDCTRL_MBDSR0_MASK) >> FLEXCAN_FDCTRL_MBDSR0_SHIFT); } break;
    ef34:	9b01      	ldr	r3, [sp, #4]
    ef36:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    ef3a:	0c1b      	lsrs	r3, r3, #16
    ef3c:	f003 0303 	and.w	r3, r3, #3
    ef40:	2208      	movs	r2, #8
    ef42:	fa02 f303 	lsl.w	r3, r2, r3
    ef46:	9303      	str	r3, [sp, #12]
    ef48:	e00c      	b.n	ef64 <FlexCAN_GetPayloadSize+0x54>
        case 2 : {  payloadSize = 8UL << ((base->FDCTRL & FLEXCAN_FDCTRL_MBDSR2_MASK) >> FLEXCAN_FDCTRL_MBDSR2_SHIFT); } break;
    #endif
    #if (FLEXCAN_IP_FEATURE_MBDSR_COUNT > 3U)
        case 3 : {  payloadSize = 8UL << ((base->FDCTRL & FLEXCAN_FDCTRL_MBDSR3_MASK) >> FLEXCAN_FDCTRL_MBDSR3_SHIFT); } break;
    #endif
        default :{  payloadSize = 8UL << ((base->FDCTRL & FLEXCAN_FDCTRL_MBDSR0_MASK) >> FLEXCAN_FDCTRL_MBDSR0_SHIFT); } break;
    ef4a:	9b01      	ldr	r3, [sp, #4]
    ef4c:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    ef50:	0c1b      	lsrs	r3, r3, #16
    ef52:	f003 0303 	and.w	r3, r3, #3
    ef56:	2208      	movs	r2, #8
    ef58:	fa02 f303 	lsl.w	r3, r2, r3
    ef5c:	9303      	str	r3, [sp, #12]
    ef5e:	e001      	b.n	ef64 <FlexCAN_GetPayloadSize+0x54>
    }
    #if defined(CAN_FEATURE_S32K1XX)
    }
    else
    {
        payloadSize = 8U;
    ef60:	2308      	movs	r3, #8
    ef62:	9303      	str	r3, [sp, #12]
    }
    #endif /* defined(CAN_FEATURE_S32K1XX) */
    return (uint8)payloadSize;
    ef64:	9b03      	ldr	r3, [sp, #12]
    ef66:	b2db      	uxtb	r3, r3
}
    ef68:	4618      	mov	r0, r3
    ef6a:	b005      	add	sp, #20
    ef6c:	f85d fb04 	ldr.w	pc, [sp], #4

0000ef70 <FlexCAN_GetMbPayloadSize>:



uint8 FlexCAN_GetMbPayloadSize(const FLEXCAN_Type * base, uint32 maxMsgBuffNum)
{
    ef70:	b500      	push	{lr}
    ef72:	b087      	sub	sp, #28
    ef74:	9001      	str	r0, [sp, #4]
    ef76:	9100      	str	r1, [sp, #0]
    uint8 arbitration_field_size = 8U;
    ef78:	2308      	movs	r3, #8
    ef7a:	f88d 3014 	strb.w	r3, [sp, #20]
    uint32 ramBlockSize = 512U;
    ef7e:	f44f 7300 	mov.w	r3, #512	; 0x200
    ef82:	9304      	str	r3, [sp, #16]
    uint8 can_real_payload = 8U;
    ef84:	2308      	movs	r3, #8
    ef86:	f88d 3017 	strb.w	r3, [sp, #23]
    uint8 maxMbBlockNum = 0U;
    ef8a:	2300      	movs	r3, #0
    ef8c:	f88d 3016 	strb.w	r3, [sp, #22]
    uint8 i=0U;
    ef90:	2300      	movs	r3, #0
    ef92:	f88d 3015 	strb.w	r3, [sp, #21]
    uint8 mb_size = 0U;
    ef96:	2300      	movs	r3, #0
    ef98:	f88d 300f 	strb.w	r3, [sp, #15]

    for (i=0; i< (uint8)FLEXCAN_IP_FEATURE_MBDSR_COUNT; i++)
    ef9c:	2300      	movs	r3, #0
    ef9e:	f88d 3015 	strb.w	r3, [sp, #21]
    efa2:	e024      	b.n	efee <FlexCAN_GetMbPayloadSize+0x7e>
    {
        /* Check that the number of MBs is supported based on the payload size*/
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        can_real_payload = FlexCAN_GetPayloadSize(base, i);
    efa4:	f89d 3015 	ldrb.w	r3, [sp, #21]
    efa8:	4619      	mov	r1, r3
    efaa:	9801      	ldr	r0, [sp, #4]
    efac:	f7ff ffb0 	bl	ef10 <FlexCAN_GetPayloadSize>
    efb0:	4603      	mov	r3, r0
    efb2:	f88d 3017 	strb.w	r3, [sp, #23]
#endif /* Else can_real_payload will remain as 8 payload size */
        mb_size = (uint8)(can_real_payload + arbitration_field_size);
    efb6:	f89d 2017 	ldrb.w	r2, [sp, #23]
    efba:	f89d 3014 	ldrb.w	r3, [sp, #20]
    efbe:	4413      	add	r3, r2
    efc0:	f88d 300f 	strb.w	r3, [sp, #15]
        maxMbBlockNum += (uint8)(ramBlockSize / mb_size);
    efc4:	f89d 300f 	ldrb.w	r3, [sp, #15]
    efc8:	9a04      	ldr	r2, [sp, #16]
    efca:	fbb2 f3f3 	udiv	r3, r2, r3
    efce:	b2da      	uxtb	r2, r3
    efd0:	f89d 3016 	ldrb.w	r3, [sp, #22]
    efd4:	4413      	add	r3, r2
    efd6:	f88d 3016 	strb.w	r3, [sp, #22]
        if (maxMbBlockNum > maxMsgBuffNum)
    efda:	f89d 3016 	ldrb.w	r3, [sp, #22]
    efde:	9a00      	ldr	r2, [sp, #0]
    efe0:	429a      	cmp	r2, r3
    efe2:	d309      	bcc.n	eff8 <FlexCAN_GetMbPayloadSize+0x88>
    for (i=0; i< (uint8)FLEXCAN_IP_FEATURE_MBDSR_COUNT; i++)
    efe4:	f89d 3015 	ldrb.w	r3, [sp, #21]
    efe8:	3301      	adds	r3, #1
    efea:	f88d 3015 	strb.w	r3, [sp, #21]
    efee:	f89d 3015 	ldrb.w	r3, [sp, #21]
    eff2:	2b00      	cmp	r3, #0
    eff4:	d0d6      	beq.n	efa4 <FlexCAN_GetMbPayloadSize+0x34>
    eff6:	e000      	b.n	effa <FlexCAN_GetMbPayloadSize+0x8a>
        {
            break;
    eff8:	bf00      	nop
    {
        can_real_payload = 64U;
    }
 #endif

    return can_real_payload;
    effa:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    effe:	4618      	mov	r0, r3
    f000:	b007      	add	sp, #28
    f002:	f85d fb04 	ldr.w	pc, [sp], #4

0000f006 <FlexCAN_LockRxMsgBuff>:
 * Description   : Lock the RX message buffer.
 * This function will lock the RX message buffer.
 *
 *END**************************************************************************/
void FlexCAN_LockRxMsgBuff(const FLEXCAN_Type * base, uint32 msgBuffIdx)
{
    f006:	b500      	push	{lr}
    f008:	b085      	sub	sp, #20
    f00a:	9001      	str	r0, [sp, #4]
    f00c:	9100      	str	r1, [sp, #0]
    volatile const uint32 * flexcan_mb = FlexCAN_GetMsgBuffRegion(base, msgBuffIdx);
    f00e:	9900      	ldr	r1, [sp, #0]
    f010:	9801      	ldr	r0, [sp, #4]
    f012:	f7ff fc7f 	bl	e914 <FlexCAN_GetMsgBuffRegion>
    f016:	9003      	str	r0, [sp, #12]

    /* Lock the mailbox by reading it */
    (void)*flexcan_mb;
    f018:	9b03      	ldr	r3, [sp, #12]
    f01a:	681b      	ldr	r3, [r3, #0]
}
    f01c:	bf00      	nop
    f01e:	b005      	add	sp, #20
    f020:	f85d fb04 	ldr.w	pc, [sp], #4

0000f024 <FlexCAN_SetMsgBuffIntCmd>:
                                               uint8 u8Instance,
                                               uint32 msgBuffIdx,
                                               boolean enable,
                                               boolean bIsIntActive
                                              )
{
    f024:	b500      	push	{lr}
    f026:	b087      	sub	sp, #28
    f028:	9003      	str	r0, [sp, #12]
    f02a:	9201      	str	r2, [sp, #4]
    f02c:	461a      	mov	r2, r3
    f02e:	460b      	mov	r3, r1
    f030:	f88d 300b 	strb.w	r3, [sp, #11]
    f034:	4613      	mov	r3, r2
    f036:	f88d 300a 	strb.w	r3, [sp, #10]
    uint32 temp;
    Flexcan_Ip_StatusType stat = FLEXCAN_STATUS_SUCCESS;
    f03a:	2300      	movs	r3, #0
    f03c:	9305      	str	r3, [sp, #20]

        /* Enable the corresponding message buffer Interrupt */
        temp = 1UL << (msgBuffIdx % 32U);
    f03e:	9b01      	ldr	r3, [sp, #4]
    f040:	f003 031f 	and.w	r3, r3, #31
    f044:	2201      	movs	r2, #1
    f046:	fa02 f303 	lsl.w	r3, r2, r3
    f04a:	9304      	str	r3, [sp, #16]
        if (msgBuffIdx < 32U)
    f04c:	9b01      	ldr	r3, [sp, #4]
    f04e:	2b1f      	cmp	r3, #31
    f050:	d837      	bhi.n	f0c2 <FlexCAN_SetMsgBuffIntCmd+0x9e>
        {
            if (enable)
    f052:	f89d 300a 	ldrb.w	r3, [sp, #10]
    f056:	2b00      	cmp	r3, #0
    f058:	d01b      	beq.n	f092 <FlexCAN_SetMsgBuffIntCmd+0x6e>
            {
                /* Start critical section: implementation depends on integrator */
                SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18();
    f05a:	f005 fc5d 	bl	14918 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18>
                FlexCAN_Ip_au32ImaskBuff[u8Instance][0U] = ((FlexCAN_Ip_au32ImaskBuff[u8Instance][0U]) | (temp));
    f05e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    f062:	4a1a      	ldr	r2, [pc, #104]	; (f0cc <FlexCAN_SetMsgBuffIntCmd+0xa8>)
    f064:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    f068:	f89d 300b 	ldrb.w	r3, [sp, #11]
    f06c:	9a04      	ldr	r2, [sp, #16]
    f06e:	430a      	orrs	r2, r1
    f070:	4916      	ldr	r1, [pc, #88]	; (f0cc <FlexCAN_SetMsgBuffIntCmd+0xa8>)
    f072:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                if (TRUE == bIsIntActive)
    f076:	f89d 3020 	ldrb.w	r3, [sp, #32]
    f07a:	2b00      	cmp	r3, #0
    f07c:	d006      	beq.n	f08c <FlexCAN_SetMsgBuffIntCmd+0x68>
                {
                    base->IMASK1 = FlexCAN_Ip_au32ImaskBuff[u8Instance][0U];
    f07e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    f082:	4a12      	ldr	r2, [pc, #72]	; (f0cc <FlexCAN_SetMsgBuffIntCmd+0xa8>)
    f084:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    f088:	9b03      	ldr	r3, [sp, #12]
    f08a:	629a      	str	r2, [r3, #40]	; 0x28
                }
                /* End critical section: implementation depends on integrator */
                SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18();
    f08c:	f005 fc70 	bl	14970 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18>
    f090:	e017      	b.n	f0c2 <FlexCAN_SetMsgBuffIntCmd+0x9e>
            }
            else
            {
                /* Start critical section: implementation depends on integrator */
                SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18();
    f092:	f005 fc41 	bl	14918 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18>
                FlexCAN_Ip_au32ImaskBuff[u8Instance][0U] = ((FlexCAN_Ip_au32ImaskBuff[u8Instance][0U]) & ~(temp));
    f096:	f89d 300b 	ldrb.w	r3, [sp, #11]
    f09a:	4a0c      	ldr	r2, [pc, #48]	; (f0cc <FlexCAN_SetMsgBuffIntCmd+0xa8>)
    f09c:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    f0a0:	9b04      	ldr	r3, [sp, #16]
    f0a2:	43da      	mvns	r2, r3
    f0a4:	f89d 300b 	ldrb.w	r3, [sp, #11]
    f0a8:	400a      	ands	r2, r1
    f0aa:	4908      	ldr	r1, [pc, #32]	; (f0cc <FlexCAN_SetMsgBuffIntCmd+0xa8>)
    f0ac:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                base->IMASK1 = FlexCAN_Ip_au32ImaskBuff[u8Instance][0U];
    f0b0:	f89d 300b 	ldrb.w	r3, [sp, #11]
    f0b4:	4a05      	ldr	r2, [pc, #20]	; (f0cc <FlexCAN_SetMsgBuffIntCmd+0xa8>)
    f0b6:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    f0ba:	9b03      	ldr	r3, [sp, #12]
    f0bc:	629a      	str	r2, [r3, #40]	; 0x28
                /* End critical section: implementation depends on integrator */
                SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18();
    f0be:	f005 fc57 	bl	14970 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18>
                SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18();
            }
        }
#endif /* if FLEXCAN_IP_FEATURE_MAX_MB_NUM > 96U */

    return stat;
    f0c2:	9b05      	ldr	r3, [sp, #20]
}
    f0c4:	4618      	mov	r0, r3
    f0c6:	b007      	add	sp, #28
    f0c8:	f85d fb04 	ldr.w	pc, [sp], #4
    f0cc:	1fff936c 	.word	0x1fff936c

0000f0d0 <FLEXCAN_ClearMsgBuffIntCmd>:
void FLEXCAN_ClearMsgBuffIntCmd(FLEXCAN_Type * pBase,
                                uint8 u8Instance,
                                uint32 mb_idx,
                                boolean bIsIntActive
                               )
{
    f0d0:	b500      	push	{lr}
    f0d2:	b087      	sub	sp, #28
    f0d4:	9003      	str	r0, [sp, #12]
    f0d6:	9201      	str	r2, [sp, #4]
    f0d8:	461a      	mov	r2, r3
    f0da:	460b      	mov	r3, r1
    f0dc:	f88d 300b 	strb.w	r3, [sp, #11]
    f0e0:	4613      	mov	r3, r2
    f0e2:	f88d 300a 	strb.w	r3, [sp, #10]
    uint32 temp = (1UL << (mb_idx % 32U));
    f0e6:	9b01      	ldr	r3, [sp, #4]
    f0e8:	f003 031f 	and.w	r3, r3, #31
    f0ec:	2201      	movs	r2, #1
    f0ee:	fa02 f303 	lsl.w	r3, r2, r3
    f0f2:	9305      	str	r3, [sp, #20]

 /* Stop the running transfer. */
    if (mb_idx < 32U)
    f0f4:	9b01      	ldr	r3, [sp, #4]
    f0f6:	2b1f      	cmp	r3, #31
    f0f8:	d818      	bhi.n	f12c <FLEXCAN_ClearMsgBuffIntCmd+0x5c>
    {
          /* Start critical section: implementation depends on integrator */
          SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11();
    f0fa:	f005 f9cf 	bl	1449c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11>
          FlexCAN_Ip_au32ImaskBuff[u8Instance][0U] = (pBase->IMASK1 & (~temp));
    f0fe:	9b03      	ldr	r3, [sp, #12]
    f100:	6a99      	ldr	r1, [r3, #40]	; 0x28
    f102:	9b05      	ldr	r3, [sp, #20]
    f104:	43da      	mvns	r2, r3
    f106:	f89d 300b 	ldrb.w	r3, [sp, #11]
    f10a:	400a      	ands	r2, r1
    f10c:	4909      	ldr	r1, [pc, #36]	; (f134 <FLEXCAN_ClearMsgBuffIntCmd+0x64>)
    f10e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
          if (TRUE == bIsIntActive)
    f112:	f89d 300a 	ldrb.w	r3, [sp, #10]
    f116:	2b00      	cmp	r3, #0
    f118:	d006      	beq.n	f128 <FLEXCAN_ClearMsgBuffIntCmd+0x58>
          {
              pBase->IMASK1 = FlexCAN_Ip_au32ImaskBuff[u8Instance][0U];
    f11a:	f89d 300b 	ldrb.w	r3, [sp, #11]
    f11e:	4a05      	ldr	r2, [pc, #20]	; (f134 <FLEXCAN_ClearMsgBuffIntCmd+0x64>)
    f120:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    f124:	9b03      	ldr	r3, [sp, #12]
    f126:	629a      	str	r2, [r3, #40]	; 0x28
          }
          /* End critical section: implementation depends on integrator */
          SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11();
    f128:	f005 f9e4 	bl	144f4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11>
        }
        /* End critical section: implementation depends on integrator */
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11();
    }
#endif /* #if FLEXCAN_IP_FEATURE_MAX_MB_NUM > 96U */
}
    f12c:	bf00      	nop
    f12e:	b007      	add	sp, #28
    f130:	f85d fb04 	ldr.w	pc, [sp], #4
    f134:	1fff936c 	.word	0x1fff936c

0000f138 <FlexCAN_DisableInterrupts>:


void FlexCAN_DisableInterrupts(FLEXCAN_Type * pBase)
{
    f138:	b082      	sub	sp, #8
    f13a:	9001      	str	r0, [sp, #4]
#if (FLEXCAN_IP_FEATURE_MAX_MB_NUM > 32U)
    uint32 u32MaxMbCrtlNum = FlexCAN_GetMaxMbNum(pBase);
#endif /* (FLEXCAN_IP_FEATURE_MAX_MB_NUM > 32U) */

    pBase->IMASK1 = 0U;
    f13c:	9b01      	ldr	r3, [sp, #4]
    f13e:	2200      	movs	r2, #0
    f140:	629a      	str	r2, [r3, #40]	; 0x28
    if (u32MaxMbCrtlNum > 96U)
    {
        pBase->IMASK4 = 0U;
    }
#endif /* (FLEXCAN_IP_FEATURE_MAX_MB_NUM > 96U) */
}
    f142:	bf00      	nop
    f144:	b002      	add	sp, #8
    f146:	4770      	bx	lr

0000f148 <FlexCAN_EnableInterrupts>:

void FlexCAN_EnableInterrupts(FLEXCAN_Type * pBase, uint8 u8Instance)
{
    f148:	b082      	sub	sp, #8
    f14a:	9001      	str	r0, [sp, #4]
    f14c:	460b      	mov	r3, r1
    f14e:	f88d 3003 	strb.w	r3, [sp, #3]
#if (FLEXCAN_IP_FEATURE_MAX_MB_NUM > 32U)
    uint32 u32MaxMbCrtlNum = FlexCAN_GetMaxMbNum(pBase);
#endif /* (FLEXCAN_IP_FEATURE_MAX_MB_NUM > 32U) */

    pBase->IMASK1 = FlexCAN_Ip_au32ImaskBuff[u8Instance][0U];
    f152:	f89d 3003 	ldrb.w	r3, [sp, #3]
    f156:	4a04      	ldr	r2, [pc, #16]	; (f168 <FlexCAN_EnableInterrupts+0x20>)
    f158:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    f15c:	9b01      	ldr	r3, [sp, #4]
    f15e:	629a      	str	r2, [r3, #40]	; 0x28
    if (u32MaxMbCrtlNum > 96U)
    {
        pBase->IMASK4 = FlexCAN_Ip_au32ImaskBuff[u8Instance][3U];
    }
#endif /* (FLEXCAN_IP_FEATURE_MAX_MB_NUM > 96U) */
}
    f160:	bf00      	nop
    f162:	b002      	add	sp, #8
    f164:	4770      	bx	lr
    f166:	bf00      	nop
    f168:	1fff936c 	.word	0x1fff936c

0000f16c <FlexCAN_SetRxMsgBuff>:
void FlexCAN_SetRxMsgBuff(const FLEXCAN_Type * base,
                          uint32 msgBuffIdx,
                          const Flexcan_Ip_MsbuffCodeStatusType * cs,
                          uint32 msgId
                         )
{
    f16c:	b500      	push	{lr}
    f16e:	b087      	sub	sp, #28
    f170:	9003      	str	r0, [sp, #12]
    f172:	9102      	str	r1, [sp, #8]
    f174:	9201      	str	r2, [sp, #4]
    f176:	9300      	str	r3, [sp, #0]
    volatile uint32 * flexcan_mb = FlexCAN_GetMsgBuffRegion(base, msgBuffIdx);
    f178:	9902      	ldr	r1, [sp, #8]
    f17a:	9803      	ldr	r0, [sp, #12]
    f17c:	f7ff fbca 	bl	e914 <FlexCAN_GetMsgBuffRegion>
    f180:	9005      	str	r0, [sp, #20]
    volatile uint32 * flexcan_mb_id = &flexcan_mb[1];
    f182:	9b05      	ldr	r3, [sp, #20]
    f184:	3304      	adds	r3, #4
    f186:	9304      	str	r3, [sp, #16]
    DevAssert(cs != NULL_PTR);
#endif


    /* Clean up the arbitration field area */
    *flexcan_mb = 0;
    f188:	9b05      	ldr	r3, [sp, #20]
    f18a:	2200      	movs	r2, #0
    f18c:	601a      	str	r2, [r3, #0]
    *flexcan_mb_id = 0;
    f18e:	9b04      	ldr	r3, [sp, #16]
    f190:	2200      	movs	r2, #0
    f192:	601a      	str	r2, [r3, #0]

    /* Set the ID according the format structure */
    if (FLEXCAN_MSG_ID_EXT == cs->msgIdType)
    f194:	9b01      	ldr	r3, [sp, #4]
    f196:	685b      	ldr	r3, [r3, #4]
    f198:	2b01      	cmp	r3, #1
    f19a:	d119      	bne.n	f1d0 <FlexCAN_SetRxMsgBuff+0x64>
    {
        /* Set IDE */
        *flexcan_mb |= FLEXCAN_IP_CS_IDE_MASK;
    f19c:	9b05      	ldr	r3, [sp, #20]
    f19e:	681b      	ldr	r3, [r3, #0]
    f1a0:	f443 1200 	orr.w	r2, r3, #2097152	; 0x200000
    f1a4:	9b05      	ldr	r3, [sp, #20]
    f1a6:	601a      	str	r2, [r3, #0]

        /* Clear SRR bit */
        *flexcan_mb &= ~FLEXCAN_IP_CS_SRR_MASK;
    f1a8:	9b05      	ldr	r3, [sp, #20]
    f1aa:	681b      	ldr	r3, [r3, #0]
    f1ac:	f423 0280 	bic.w	r2, r3, #4194304	; 0x400000
    f1b0:	9b05      	ldr	r3, [sp, #20]
    f1b2:	601a      	str	r2, [r3, #0]

        /* ID [28-0] */
        *flexcan_mb_id &= ~(FLEXCAN_IP_ID_STD_MASK | FLEXCAN_IP_ID_EXT_MASK);
    f1b4:	9b04      	ldr	r3, [sp, #16]
    f1b6:	681b      	ldr	r3, [r3, #0]
    f1b8:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
    f1bc:	9b04      	ldr	r3, [sp, #16]
    f1be:	601a      	str	r2, [r3, #0]
        *flexcan_mb_id |= (msgId & (FLEXCAN_IP_ID_STD_MASK | FLEXCAN_IP_ID_EXT_MASK));
    f1c0:	9b04      	ldr	r3, [sp, #16]
    f1c2:	681a      	ldr	r2, [r3, #0]
    f1c4:	9b00      	ldr	r3, [sp, #0]
    f1c6:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
    f1ca:	431a      	orrs	r2, r3
    f1cc:	9b04      	ldr	r3, [sp, #16]
    f1ce:	601a      	str	r2, [r3, #0]
    }

    if (FLEXCAN_MSG_ID_STD == cs->msgIdType)
    f1d0:	9b01      	ldr	r3, [sp, #4]
    f1d2:	685b      	ldr	r3, [r3, #4]
    f1d4:	2b00      	cmp	r3, #0
    f1d6:	d116      	bne.n	f206 <FlexCAN_SetRxMsgBuff+0x9a>
    {
        /* Make sure IDE and SRR are not set */
        *flexcan_mb &= ~(FLEXCAN_IP_CS_IDE_MASK | FLEXCAN_IP_CS_SRR_MASK);
    f1d8:	9b05      	ldr	r3, [sp, #20]
    f1da:	681b      	ldr	r3, [r3, #0]
    f1dc:	f423 02c0 	bic.w	r2, r3, #6291456	; 0x600000
    f1e0:	9b05      	ldr	r3, [sp, #20]
    f1e2:	601a      	str	r2, [r3, #0]

        /* ID[28-18] */
        *flexcan_mb_id &= ~FLEXCAN_IP_ID_STD_MASK;
    f1e4:	9b04      	ldr	r3, [sp, #16]
    f1e6:	681b      	ldr	r3, [r3, #0]
    f1e8:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
    f1ec:	f423 13e0 	bic.w	r3, r3, #1835008	; 0x1c0000
    f1f0:	9a04      	ldr	r2, [sp, #16]
    f1f2:	6013      	str	r3, [r2, #0]
        *flexcan_mb_id |= (msgId << FLEXCAN_IP_ID_STD_SHIFT) & FLEXCAN_IP_ID_STD_MASK;
    f1f4:	9b04      	ldr	r3, [sp, #16]
    f1f6:	681a      	ldr	r2, [r3, #0]
    f1f8:	9b00      	ldr	r3, [sp, #0]
    f1fa:	0499      	lsls	r1, r3, #18
    f1fc:	4b0e      	ldr	r3, [pc, #56]	; (f238 <FlexCAN_SetRxMsgBuff+0xcc>)
    f1fe:	400b      	ands	r3, r1
    f200:	431a      	orrs	r2, r3
    f202:	9b04      	ldr	r3, [sp, #16]
    f204:	601a      	str	r2, [r3, #0]
    }

    /* Set MB CODE */
    if ((uint32)FLEXCAN_RX_NOT_USED != cs->code)
    f206:	9b01      	ldr	r3, [sp, #4]
    f208:	681b      	ldr	r3, [r3, #0]
    f20a:	2b0f      	cmp	r3, #15
    f20c:	d00f      	beq.n	f22e <FlexCAN_SetRxMsgBuff+0xc2>
    {
        *flexcan_mb &= ~FLEXCAN_IP_CS_CODE_MASK;
    f20e:	9b05      	ldr	r3, [sp, #20]
    f210:	681b      	ldr	r3, [r3, #0]
    f212:	f023 6270 	bic.w	r2, r3, #251658240	; 0xf000000
    f216:	9b05      	ldr	r3, [sp, #20]
    f218:	601a      	str	r2, [r3, #0]
        *flexcan_mb |= (cs->code << FLEXCAN_IP_CS_CODE_SHIFT) & FLEXCAN_IP_CS_CODE_MASK;
    f21a:	9b05      	ldr	r3, [sp, #20]
    f21c:	681a      	ldr	r2, [r3, #0]
    f21e:	9b01      	ldr	r3, [sp, #4]
    f220:	681b      	ldr	r3, [r3, #0]
    f222:	061b      	lsls	r3, r3, #24
    f224:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    f228:	431a      	orrs	r2, r3
    f22a:	9b05      	ldr	r3, [sp, #20]
    f22c:	601a      	str	r2, [r3, #0]
    }
}
    f22e:	bf00      	nop
    f230:	b007      	add	sp, #28
    f232:	f85d fb04 	ldr.w	pc, [sp], #4
    f236:	bf00      	nop
    f238:	1ffc0000 	.word	0x1ffc0000

0000f23c <FlexCAN_GetMsgBuffTimestamp>:
 * Function Name : FlexCAN_GetMsgBuffTimestamp
 * Description   : Get a message buffer timestamp value.
 *
 *END**************************************************************************/
uint32 FlexCAN_GetMsgBuffTimestamp(const FLEXCAN_Type * base, uint32 msgBuffIdx)
{
    f23c:	b500      	push	{lr}
    f23e:	b085      	sub	sp, #20
    f240:	9001      	str	r0, [sp, #4]
    f242:	9100      	str	r1, [sp, #0]
    uint32 TimeStamp = 0U;
    f244:	2300      	movs	r3, #0
    f246:	9303      	str	r3, [sp, #12]
    volatile const uint32 * Flexcan_Mb = FlexCAN_GetMsgBuffRegion(base, msgBuffIdx);
    f248:	9900      	ldr	r1, [sp, #0]
    f24a:	9801      	ldr	r0, [sp, #4]
    f24c:	f7ff fb62 	bl	e914 <FlexCAN_GetMsgBuffRegion>
    f250:	9002      	str	r0, [sp, #8]
        TimeStamp = (uint32)base->HR_TIME_STAMP[msgBuffIdx];
    }
    else
#endif /* EATURE_CAN_HAS_HR_TIMER */
    {
        TimeStamp = (uint32)((*Flexcan_Mb & FLEXCAN_IP_CS_TIME_STAMP_MASK) >> FLEXCAN_IP_CS_TIME_STAMP_SHIFT);
    f252:	9b02      	ldr	r3, [sp, #8]
    f254:	681b      	ldr	r3, [r3, #0]
    f256:	b29b      	uxth	r3, r3
    f258:	9303      	str	r3, [sp, #12]
    }
    return TimeStamp;
    f25a:	9b03      	ldr	r3, [sp, #12]
}
    f25c:	4618      	mov	r0, r3
    f25e:	b005      	add	sp, #20
    f260:	f85d fb04 	ldr.w	pc, [sp], #4

0000f264 <FlexCAN_GetMsgBuff>:
 *END**************************************************************************/
void FlexCAN_GetMsgBuff(const FLEXCAN_Type * base,
                        uint32 msgBuffIdx,
                        Flexcan_Ip_MsgBuffType * msgBuff
                       )
{
    f264:	b500      	push	{lr}
    f266:	b08d      	sub	sp, #52	; 0x34
    f268:	9003      	str	r0, [sp, #12]
    f26a:	9102      	str	r1, [sp, #8]
    f26c:	9201      	str	r2, [sp, #4]

    uint8 i;
    volatile const uint32 * Flexcan_Mb = FlexCAN_GetMsgBuffRegion(base, msgBuffIdx);
    f26e:	9902      	ldr	r1, [sp, #8]
    f270:	9803      	ldr	r0, [sp, #12]
    f272:	f7ff fb4f 	bl	e914 <FlexCAN_GetMsgBuffRegion>
    f276:	900a      	str	r0, [sp, #40]	; 0x28
    volatile const uint32 * Flexcan_Mb_Id   = &Flexcan_Mb[1];
    f278:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f27a:	3304      	adds	r3, #4
    f27c:	9309      	str	r3, [sp, #36]	; 0x24
    volatile const uint8 * Flexcan_Mb_Data = (volatile const uint8 *)(&Flexcan_Mb[2]);
    f27e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f280:	3308      	adds	r3, #8
    f282:	9308      	str	r3, [sp, #32]
    volatile const uint32 * Flexcan_Mb_Data_32 = &Flexcan_Mb[2];
    f284:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f286:	3308      	adds	r3, #8
    f288:	9307      	str	r3, [sp, #28]
    uint32 * MsgBuff_Data_32 = NULL_PTR;
    f28a:	2300      	movs	r3, #0
    f28c:	9306      	str	r3, [sp, #24]
    uint32 MbWord;

    uint8 Flexcan_Mb_Dlc_Value = (uint8)(((*Flexcan_Mb) & FLEXCAN_IP_CS_DLC_MASK) >> 16);
    f28e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f290:	681b      	ldr	r3, [r3, #0]
    f292:	0c1b      	lsrs	r3, r3, #16
    f294:	b2db      	uxtb	r3, r3
    f296:	f003 030f 	and.w	r3, r3, #15
    f29a:	f88d 3017 	strb.w	r3, [sp, #23]
    uint8 Payload_Size = FlexCAN_ComputePayloadSize(Flexcan_Mb_Dlc_Value);
    f29e:	f89d 3017 	ldrb.w	r3, [sp, #23]
    f2a2:	4618      	mov	r0, r3
    f2a4:	f7ff faed 	bl	e882 <FlexCAN_ComputePayloadSize>
    f2a8:	4603      	mov	r3, r0
    f2aa:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(msgBuff != NULL_PTR);
#endif
    /* Asign after NULL Check */
    MsgBuff_Data_32 = (uint32 *)(msgBuff->data);
    f2ae:	9b01      	ldr	r3, [sp, #4]
    f2b0:	3308      	adds	r3, #8
    f2b2:	9306      	str	r3, [sp, #24]
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
    /* Payload Size is based on MBDSR for 1 MBDSR corresponds 32 * 8Bytes MBs  */
    if (Payload_Size > FlexCAN_GetMbPayloadSize(base, msgBuffIdx))
    f2b4:	9902      	ldr	r1, [sp, #8]
    f2b6:	9803      	ldr	r0, [sp, #12]
    f2b8:	f7ff fe5a 	bl	ef70 <FlexCAN_GetMbPayloadSize>
    f2bc:	4603      	mov	r3, r0
    f2be:	461a      	mov	r2, r3
    f2c0:	f89d 302e 	ldrb.w	r3, [sp, #46]	; 0x2e
    f2c4:	4293      	cmp	r3, r2
    f2c6:	d906      	bls.n	f2d6 <FlexCAN_GetMsgBuff+0x72>
    {
        Payload_Size = FlexCAN_GetMbPayloadSize(base, msgBuffIdx);
    f2c8:	9902      	ldr	r1, [sp, #8]
    f2ca:	9803      	ldr	r0, [sp, #12]
    f2cc:	f7ff fe50 	bl	ef70 <FlexCAN_GetMbPayloadSize>
    f2d0:	4603      	mov	r3, r0
    f2d2:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
    }
#endif /* FLEXCAN_IP_FEATURE_HAS_FD */

    msgBuff->dataLen = Payload_Size;
    f2d6:	9b01      	ldr	r3, [sp, #4]
    f2d8:	f89d 202e 	ldrb.w	r2, [sp, #46]	; 0x2e
    f2dc:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
    /* Get a MB field values */
    msgBuff->cs = *Flexcan_Mb;
    f2e0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f2e2:	681a      	ldr	r2, [r3, #0]
    f2e4:	9b01      	ldr	r3, [sp, #4]
    f2e6:	601a      	str	r2, [r3, #0]
    if ((msgBuff->cs & FLEXCAN_IP_CS_IDE_MASK) != 0U)
    f2e8:	9b01      	ldr	r3, [sp, #4]
    f2ea:	681b      	ldr	r3, [r3, #0]
    f2ec:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
    f2f0:	2b00      	cmp	r3, #0
    f2f2:	d004      	beq.n	f2fe <FlexCAN_GetMsgBuff+0x9a>
    {
        msgBuff->msgId = (*Flexcan_Mb_Id);
    f2f4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    f2f6:	681a      	ldr	r2, [r3, #0]
    f2f8:	9b01      	ldr	r3, [sp, #4]
    f2fa:	605a      	str	r2, [r3, #4]
    f2fc:	e004      	b.n	f308 <FlexCAN_GetMsgBuff+0xa4>
    }
    else
    {
        msgBuff->msgId = (*Flexcan_Mb_Id) >> FLEXCAN_IP_ID_STD_SHIFT;
    f2fe:	9b09      	ldr	r3, [sp, #36]	; 0x24
    f300:	681b      	ldr	r3, [r3, #0]
    f302:	0c9a      	lsrs	r2, r3, #18
    f304:	9b01      	ldr	r3, [sp, #4]
    f306:	605a      	str	r2, [r3, #4]
        msgBuff->time_stamp = (uint32)base->HR_TIME_STAMP[msgBuffIdx];
    }
    else
#endif /* EATURE_CAN_HAS_HR_TIMER */
    {
        msgBuff->time_stamp = (uint32)((msgBuff->cs & FLEXCAN_IP_CS_TIME_STAMP_MASK) >> FLEXCAN_IP_CS_TIME_STAMP_SHIFT);
    f308:	9b01      	ldr	r3, [sp, #4]
    f30a:	681b      	ldr	r3, [r3, #0]
    f30c:	b29a      	uxth	r2, r3
    f30e:	9b01      	ldr	r3, [sp, #4]
    f310:	64da      	str	r2, [r3, #76]	; 0x4c
            FLEXCAN_IP_SWAP_BYTES_IN_WORD(MbWord, MsgBuff_Data_32[i >> 2U]);
        }
    }

#else  /* if (defined (CPU_S32K116) || defined (CPU_S32K118)) */
    for (i = 0U; i < (Payload_Size & ~3U); i += 4U)
    f312:	2300      	movs	r3, #0
    f314:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    f318:	e025      	b.n	f366 <FlexCAN_GetMsgBuff+0x102>
    {
        MbWord = Flexcan_Mb_Data_32[i >> 2U];
    f31a:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
    f31e:	089b      	lsrs	r3, r3, #2
    f320:	b2db      	uxtb	r3, r3
    f322:	009b      	lsls	r3, r3, #2
    f324:	9a07      	ldr	r2, [sp, #28]
    f326:	4413      	add	r3, r2
    f328:	681b      	ldr	r3, [r3, #0]
    f32a:	9304      	str	r3, [sp, #16]
        FLEXCAN_IP_SWAP_BYTES_IN_WORD((MbWord), (MsgBuff_Data_32[i >> 2U]));
    f32c:	9b04      	ldr	r3, [sp, #16]
    f32e:	0e1a      	lsrs	r2, r3, #24
    f330:	9b04      	ldr	r3, [sp, #16]
    f332:	0a1b      	lsrs	r3, r3, #8
    f334:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    f338:	431a      	orrs	r2, r3
    f33a:	9b04      	ldr	r3, [sp, #16]
    f33c:	021b      	lsls	r3, r3, #8
    f33e:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
    f342:	ea42 0103 	orr.w	r1, r2, r3
    f346:	9b04      	ldr	r3, [sp, #16]
    f348:	061a      	lsls	r2, r3, #24
    f34a:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
    f34e:	089b      	lsrs	r3, r3, #2
    f350:	b2db      	uxtb	r3, r3
    f352:	009b      	lsls	r3, r3, #2
    f354:	9806      	ldr	r0, [sp, #24]
    f356:	4403      	add	r3, r0
    f358:	430a      	orrs	r2, r1
    f35a:	601a      	str	r2, [r3, #0]
    for (i = 0U; i < (Payload_Size & ~3U); i += 4U)
    f35c:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
    f360:	3304      	adds	r3, #4
    f362:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    f366:	f89d 202f 	ldrb.w	r2, [sp, #47]	; 0x2f
    f36a:	f89d 302e 	ldrb.w	r3, [sp, #46]	; 0x2e
    f36e:	f023 0303 	bic.w	r3, r3, #3
    f372:	429a      	cmp	r2, r3
    f374:	d3d1      	bcc.n	f31a <FlexCAN_GetMsgBuff+0xb6>
    }

#endif /* if (defined (CPU_S32K116) || defined (CPU_S32K118)) */
    for (; i < Payload_Size; i++)
    f376:	e014      	b.n	f3a2 <FlexCAN_GetMsgBuff+0x13e>
    {   /* Max allowed value for index is 63 */
        msgBuff->data[i] = Flexcan_Mb_Data[FLEXCAN_IP_SWAP_BYTES_IN_WORD_INDEX(i)];
    f378:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
    f37c:	f083 0303 	eor.w	r3, r3, #3
    f380:	b2db      	uxtb	r3, r3
    f382:	461a      	mov	r2, r3
    f384:	9b08      	ldr	r3, [sp, #32]
    f386:	441a      	add	r2, r3
    f388:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
    f38c:	7812      	ldrb	r2, [r2, #0]
    f38e:	b2d1      	uxtb	r1, r2
    f390:	9a01      	ldr	r2, [sp, #4]
    f392:	4413      	add	r3, r2
    f394:	460a      	mov	r2, r1
    f396:	721a      	strb	r2, [r3, #8]
    for (; i < Payload_Size; i++)
    f398:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
    f39c:	3301      	adds	r3, #1
    f39e:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    f3a2:	f89d 202f 	ldrb.w	r2, [sp, #47]	; 0x2f
    f3a6:	f89d 302e 	ldrb.w	r3, [sp, #46]	; 0x2e
    f3aa:	429a      	cmp	r2, r3
    f3ac:	d3e4      	bcc.n	f378 <FlexCAN_GetMsgBuff+0x114>
    }
}
    f3ae:	bf00      	nop
    f3b0:	bf00      	nop
    f3b2:	b00d      	add	sp, #52	; 0x34
    f3b4:	f85d fb04 	ldr.w	pc, [sp], #4

0000f3b8 <FlexCAN_SetTxMsgBuff>:
                          const Flexcan_Ip_MsbuffCodeStatusType * cs,
                          uint32 msgId,
                          const uint8 * msgData,
                          const boolean isRemote
                         )
{
    f3b8:	b500      	push	{lr}
    f3ba:	b08d      	sub	sp, #52	; 0x34
    f3bc:	9003      	str	r0, [sp, #12]
    f3be:	9102      	str	r1, [sp, #8]
    f3c0:	9201      	str	r2, [sp, #4]
    f3c2:	9300      	str	r3, [sp, #0]
    uint32 Flexcan_Mb_Config = 0;
    f3c4:	2300      	movs	r3, #0
    f3c6:	930b      	str	r3, [sp, #44]	; 0x2c
    uint32 DataByte;
    uint8 Dlc_Value;
    uint8 Payload_Size;
    volatile uint32 * Flexcan_Mb = pMbAddr;
    f3c8:	9b03      	ldr	r3, [sp, #12]
    f3ca:	9309      	str	r3, [sp, #36]	; 0x24
    volatile uint32 * Flexcan_Mb_Id   = &Flexcan_Mb[1];
    f3cc:	9b09      	ldr	r3, [sp, #36]	; 0x24
    f3ce:	3304      	adds	r3, #4
    f3d0:	9308      	str	r3, [sp, #32]
    volatile uint8 * Flexcan_Mb_Data = (volatile uint8*)(&Flexcan_Mb[2]);
    f3d2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    f3d4:	3308      	adds	r3, #8
    f3d6:	9307      	str	r3, [sp, #28]
    volatile uint32 * Flexcan_Mb_Data_32 = &Flexcan_Mb[2];
    f3d8:	9b09      	ldr	r3, [sp, #36]	; 0x24
    f3da:	3308      	adds	r3, #8
    f3dc:	9306      	str	r3, [sp, #24]
    const uint32 * MsgData_32 = (const uint32*)msgData;
    f3de:	9b00      	ldr	r3, [sp, #0]
    f3e0:	9305      	str	r3, [sp, #20]
    #if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
        DevAssert(cs != NULL_PTR);
    #endif

        /* Clean up the arbitration field area and set TxMB Inactive */
        *Flexcan_Mb = (uint32)((((uint32)FLEXCAN_TX_INACTIVE & (uint32)0x1F) << (uint8)FLEXCAN_IP_CS_CODE_SHIFT) & (uint32)FLEXCAN_IP_CS_CODE_MASK);
    f3e2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    f3e4:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
    f3e8:	601a      	str	r2, [r3, #0]
        *Flexcan_Mb_Id = 0;
    f3ea:	9b08      	ldr	r3, [sp, #32]
    f3ec:	2200      	movs	r2, #0
    f3ee:	601a      	str	r2, [r3, #0]

        /* Compute the value of the DLC field */
        Dlc_Value = FlexCAN_ComputeDLCValue((uint8)cs->dataLen);
    f3f0:	9b02      	ldr	r3, [sp, #8]
    f3f2:	689b      	ldr	r3, [r3, #8]
    f3f4:	b2db      	uxtb	r3, r3
    f3f6:	4618      	mov	r0, r3
    f3f8:	f7ff f9f4 	bl	e7e4 <FlexCAN_ComputeDLCValue>
    f3fc:	4603      	mov	r3, r0
    f3fe:	f88d 3013 	strb.w	r3, [sp, #19]
        /* Copy user's buffer into the message buffer data area */
        if (msgData != NULL_PTR)
    f402:	9b00      	ldr	r3, [sp, #0]
    f404:	2b00      	cmp	r3, #0
    f406:	d065      	beq.n	f4d4 <FlexCAN_SetTxMsgBuff+0x11c>
        {
#if (defined(S32K116) || defined (S32K118))
            (void)MsgData_32;
            DataByte = FlexCAN_DataTransferTxMsgBuff(Flexcan_Mb_Data_32, cs, msgData);
#else
            for (DataByte = 0; DataByte < (cs->dataLen & ~3U); DataByte += 4U)
    f408:	2300      	movs	r3, #0
    f40a:	930a      	str	r3, [sp, #40]	; 0x28
    f40c:	e02c      	b.n	f468 <FlexCAN_SetTxMsgBuff+0xb0>
            {
                FLEXCAN_IP_SWAP_BYTES_IN_WORD((MsgData_32[DataByte >> 2U]), (Flexcan_Mb_Data_32[DataByte >> 2U]));
    f40e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f410:	089b      	lsrs	r3, r3, #2
    f412:	009b      	lsls	r3, r3, #2
    f414:	9a05      	ldr	r2, [sp, #20]
    f416:	4413      	add	r3, r2
    f418:	681b      	ldr	r3, [r3, #0]
    f41a:	0e1a      	lsrs	r2, r3, #24
    f41c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f41e:	089b      	lsrs	r3, r3, #2
    f420:	009b      	lsls	r3, r3, #2
    f422:	9905      	ldr	r1, [sp, #20]
    f424:	440b      	add	r3, r1
    f426:	681b      	ldr	r3, [r3, #0]
    f428:	0a1b      	lsrs	r3, r3, #8
    f42a:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    f42e:	431a      	orrs	r2, r3
    f430:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f432:	089b      	lsrs	r3, r3, #2
    f434:	009b      	lsls	r3, r3, #2
    f436:	9905      	ldr	r1, [sp, #20]
    f438:	440b      	add	r3, r1
    f43a:	681b      	ldr	r3, [r3, #0]
    f43c:	021b      	lsls	r3, r3, #8
    f43e:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
    f442:	ea42 0103 	orr.w	r1, r2, r3
    f446:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f448:	089b      	lsrs	r3, r3, #2
    f44a:	009b      	lsls	r3, r3, #2
    f44c:	9a05      	ldr	r2, [sp, #20]
    f44e:	4413      	add	r3, r2
    f450:	681b      	ldr	r3, [r3, #0]
    f452:	061a      	lsls	r2, r3, #24
    f454:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f456:	089b      	lsrs	r3, r3, #2
    f458:	009b      	lsls	r3, r3, #2
    f45a:	9806      	ldr	r0, [sp, #24]
    f45c:	4403      	add	r3, r0
    f45e:	430a      	orrs	r2, r1
    f460:	601a      	str	r2, [r3, #0]
            for (DataByte = 0; DataByte < (cs->dataLen & ~3U); DataByte += 4U)
    f462:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f464:	3304      	adds	r3, #4
    f466:	930a      	str	r3, [sp, #40]	; 0x28
    f468:	9b02      	ldr	r3, [sp, #8]
    f46a:	689b      	ldr	r3, [r3, #8]
    f46c:	f023 0303 	bic.w	r3, r3, #3
    f470:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    f472:	429a      	cmp	r2, r3
    f474:	d3cb      	bcc.n	f40e <FlexCAN_SetTxMsgBuff+0x56>
            }
#endif /* (defined(S32K116) || defined (S32K118)) */
            for ( ; DataByte < cs->dataLen; DataByte++)
    f476:	e00c      	b.n	f492 <FlexCAN_SetTxMsgBuff+0xda>
            {
                Flexcan_Mb_Data[FLEXCAN_IP_SWAP_BYTES_IN_WORD_INDEX(DataByte)] =  msgData[DataByte];
    f478:	9a00      	ldr	r2, [sp, #0]
    f47a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f47c:	441a      	add	r2, r3
    f47e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f480:	f083 0303 	eor.w	r3, r3, #3
    f484:	9907      	ldr	r1, [sp, #28]
    f486:	440b      	add	r3, r1
    f488:	7812      	ldrb	r2, [r2, #0]
    f48a:	701a      	strb	r2, [r3, #0]
            for ( ; DataByte < cs->dataLen; DataByte++)
    f48c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f48e:	3301      	adds	r3, #1
    f490:	930a      	str	r3, [sp, #40]	; 0x28
    f492:	9b02      	ldr	r3, [sp, #8]
    f494:	689b      	ldr	r3, [r3, #8]
    f496:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    f498:	429a      	cmp	r2, r3
    f49a:	d3ed      	bcc.n	f478 <FlexCAN_SetTxMsgBuff+0xc0>
            }
        #if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
            Payload_Size = FlexCAN_ComputePayloadSize(Dlc_Value);
    f49c:	f89d 3013 	ldrb.w	r3, [sp, #19]
    f4a0:	4618      	mov	r0, r3
    f4a2:	f7ff f9ee 	bl	e882 <FlexCAN_ComputePayloadSize>
    f4a6:	4603      	mov	r3, r0
    f4a8:	f88d 3012 	strb.w	r3, [sp, #18]
            /* Add padding, if needed */
            for (DataByte = cs->dataLen; DataByte < Payload_Size; DataByte++)
    f4ac:	9b02      	ldr	r3, [sp, #8]
    f4ae:	689b      	ldr	r3, [r3, #8]
    f4b0:	930a      	str	r3, [sp, #40]	; 0x28
    f4b2:	e00a      	b.n	f4ca <FlexCAN_SetTxMsgBuff+0x112>
            {
                Flexcan_Mb_Data[FLEXCAN_IP_SWAP_BYTES_IN_WORD_INDEX(DataByte)] = cs->fd_padding;
    f4b4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f4b6:	f083 0303 	eor.w	r3, r3, #3
    f4ba:	9a07      	ldr	r2, [sp, #28]
    f4bc:	4413      	add	r3, r2
    f4be:	9a02      	ldr	r2, [sp, #8]
    f4c0:	7b52      	ldrb	r2, [r2, #13]
    f4c2:	701a      	strb	r2, [r3, #0]
            for (DataByte = cs->dataLen; DataByte < Payload_Size; DataByte++)
    f4c4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f4c6:	3301      	adds	r3, #1
    f4c8:	930a      	str	r3, [sp, #40]	; 0x28
    f4ca:	f89d 3012 	ldrb.w	r3, [sp, #18]
    f4ce:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    f4d0:	429a      	cmp	r2, r3
    f4d2:	d3ef      	bcc.n	f4b4 <FlexCAN_SetTxMsgBuff+0xfc>
            }
        #endif /* FLEXCAN_IP_FEATURE_HAS_FD */
        }
        /* Set the ID according the format structure */
        if (FLEXCAN_MSG_ID_EXT == cs->msgIdType)
    f4d4:	9b02      	ldr	r3, [sp, #8]
    f4d6:	685b      	ldr	r3, [r3, #4]
    f4d8:	2b01      	cmp	r3, #1
    f4da:	d111      	bne.n	f500 <FlexCAN_SetTxMsgBuff+0x148>
        {
            /* ID [28-0] */
            *Flexcan_Mb_Id &= ~(FLEXCAN_IP_ID_STD_MASK | FLEXCAN_IP_ID_EXT_MASK);
    f4dc:	9b08      	ldr	r3, [sp, #32]
    f4de:	681b      	ldr	r3, [r3, #0]
    f4e0:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
    f4e4:	9b08      	ldr	r3, [sp, #32]
    f4e6:	601a      	str	r2, [r3, #0]
            *Flexcan_Mb_Id |= (msgId & (FLEXCAN_IP_ID_STD_MASK | FLEXCAN_IP_ID_EXT_MASK));
    f4e8:	9b08      	ldr	r3, [sp, #32]
    f4ea:	681a      	ldr	r2, [r3, #0]
    f4ec:	9b01      	ldr	r3, [sp, #4]
    f4ee:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
    f4f2:	431a      	orrs	r2, r3
    f4f4:	9b08      	ldr	r3, [sp, #32]
    f4f6:	601a      	str	r2, [r3, #0]
            /* Set IDE and SRR bit*/
            Flexcan_Mb_Config |= (FLEXCAN_IP_CS_IDE_MASK | FLEXCAN_IP_CS_SRR_MASK);
    f4f8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f4fa:	f443 03c0 	orr.w	r3, r3, #6291456	; 0x600000
    f4fe:	930b      	str	r3, [sp, #44]	; 0x2c
        }
        if (FLEXCAN_MSG_ID_STD == cs->msgIdType)
    f500:	9b02      	ldr	r3, [sp, #8]
    f502:	685b      	ldr	r3, [r3, #4]
    f504:	2b00      	cmp	r3, #0
    f506:	d114      	bne.n	f532 <FlexCAN_SetTxMsgBuff+0x17a>
        {
            /* ID[28-18] */
            *Flexcan_Mb_Id &= ~FLEXCAN_IP_ID_STD_MASK;
    f508:	9b08      	ldr	r3, [sp, #32]
    f50a:	681b      	ldr	r3, [r3, #0]
    f50c:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
    f510:	f423 13e0 	bic.w	r3, r3, #1835008	; 0x1c0000
    f514:	9a08      	ldr	r2, [sp, #32]
    f516:	6013      	str	r3, [r2, #0]
            *Flexcan_Mb_Id |= (msgId << FLEXCAN_IP_ID_STD_SHIFT) & FLEXCAN_IP_ID_STD_MASK;
    f518:	9b08      	ldr	r3, [sp, #32]
    f51a:	681a      	ldr	r2, [r3, #0]
    f51c:	9b01      	ldr	r3, [sp, #4]
    f51e:	0499      	lsls	r1, r3, #18
    f520:	4b2b      	ldr	r3, [pc, #172]	; (f5d0 <FlexCAN_SetTxMsgBuff+0x218>)
    f522:	400b      	ands	r3, r1
    f524:	431a      	orrs	r2, r3
    f526:	9b08      	ldr	r3, [sp, #32]
    f528:	601a      	str	r2, [r3, #0]
            /* make sure IDE and SRR are not set */
            Flexcan_Mb_Config &= ~(FLEXCAN_IP_CS_IDE_MASK | FLEXCAN_IP_CS_SRR_MASK);
    f52a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f52c:	f423 03c0 	bic.w	r3, r3, #6291456	; 0x600000
    f530:	930b      	str	r3, [sp, #44]	; 0x2c
        }
        /* Set the length of data in bytes */
        Flexcan_Mb_Config &= ~FLEXCAN_IP_CS_DLC_MASK;
    f532:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f534:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    f538:	930b      	str	r3, [sp, #44]	; 0x2c
        Flexcan_Mb_Config |= ((uint32)Dlc_Value << FLEXCAN_IP_CS_DLC_SHIFT) & FLEXCAN_IP_CS_DLC_MASK;
    f53a:	f89d 3013 	ldrb.w	r3, [sp, #19]
    f53e:	041b      	lsls	r3, r3, #16
    f540:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
    f544:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    f546:	4313      	orrs	r3, r2
    f548:	930b      	str	r3, [sp, #44]	; 0x2c
        /* Set MB CODE */
        if (cs->code != (uint32)FLEXCAN_TX_NOT_USED)
    f54a:	9b02      	ldr	r3, [sp, #8]
    f54c:	681b      	ldr	r3, [r3, #0]
    f54e:	2b0f      	cmp	r3, #15
    f550:	d03a      	beq.n	f5c8 <FlexCAN_SetTxMsgBuff+0x210>
        {
            if ((uint32)FLEXCAN_TX_REMOTE == cs->code)
    f552:	9b02      	ldr	r3, [sp, #8]
    f554:	681b      	ldr	r3, [r3, #0]
    f556:	2b1c      	cmp	r3, #28
    f558:	d104      	bne.n	f564 <FlexCAN_SetTxMsgBuff+0x1ac>
            {
                /* Set RTR bit */
                Flexcan_Mb_Config |= FLEXCAN_IP_CS_RTR_MASK;
    f55a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f55c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    f560:	930b      	str	r3, [sp, #44]	; 0x2c
    f562:	e007      	b.n	f574 <FlexCAN_SetTxMsgBuff+0x1bc>
            }
            else
            {
                if (TRUE == isRemote)
    f564:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
    f568:	2b00      	cmp	r3, #0
    f56a:	d003      	beq.n	f574 <FlexCAN_SetTxMsgBuff+0x1bc>
                {
                    /* Set RTR bit */
                    Flexcan_Mb_Config |= FLEXCAN_IP_CS_RTR_MASK;
    f56c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f56e:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    f572:	930b      	str	r3, [sp, #44]	; 0x2c
                }
            }
            /* Reset the code */
            Flexcan_Mb_Config &= ~FLEXCAN_IP_CS_CODE_MASK;
    f574:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f576:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    f57a:	930b      	str	r3, [sp, #44]	; 0x2c
            /* Set the code */
            if (cs->fd_enable)
    f57c:	9b02      	ldr	r3, [sp, #8]
    f57e:	7b1b      	ldrb	r3, [r3, #12]
    f580:	2b00      	cmp	r3, #0
    f582:	d00e      	beq.n	f5a2 <FlexCAN_SetTxMsgBuff+0x1ea>
            {
                Flexcan_Mb_Config |= ((cs->code << FLEXCAN_IP_CS_CODE_SHIFT) & FLEXCAN_IP_CS_CODE_MASK) | FLEXCAN_IP_MB_EDL_MASK;
    f584:	9b02      	ldr	r3, [sp, #8]
    f586:	681b      	ldr	r3, [r3, #0]
    f588:	061b      	lsls	r3, r3, #24
    f58a:	f003 6270 	and.w	r2, r3, #251658240	; 0xf000000
    f58e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f590:	4313      	orrs	r3, r2
    f592:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    f596:	930b      	str	r3, [sp, #44]	; 0x2c
                /* In case of FD frame not supported RTR */
                Flexcan_Mb_Config &= ~FLEXCAN_IP_CS_RTR_MASK;
    f598:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f59a:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
    f59e:	930b      	str	r3, [sp, #44]	; 0x2c
    f5a0:	e007      	b.n	f5b2 <FlexCAN_SetTxMsgBuff+0x1fa>
            }
            else
            {
                Flexcan_Mb_Config |= (cs->code << FLEXCAN_IP_CS_CODE_SHIFT) & FLEXCAN_IP_CS_CODE_MASK;
    f5a2:	9b02      	ldr	r3, [sp, #8]
    f5a4:	681b      	ldr	r3, [r3, #0]
    f5a6:	061b      	lsls	r3, r3, #24
    f5a8:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    f5ac:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    f5ae:	4313      	orrs	r3, r2
    f5b0:	930b      	str	r3, [sp, #44]	; 0x2c
            }

            if (cs->enable_brs)
    f5b2:	9b02      	ldr	r3, [sp, #8]
    f5b4:	7b9b      	ldrb	r3, [r3, #14]
    f5b6:	2b00      	cmp	r3, #0
    f5b8:	d003      	beq.n	f5c2 <FlexCAN_SetTxMsgBuff+0x20a>
            {
                Flexcan_Mb_Config |= FLEXCAN_IP_MB_BRS_MASK;
    f5ba:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f5bc:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    f5c0:	930b      	str	r3, [sp, #44]	; 0x2c
            }
            *Flexcan_Mb = Flexcan_Mb_Config;
    f5c2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    f5c4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    f5c6:	601a      	str	r2, [r3, #0]
        }
}
    f5c8:	bf00      	nop
    f5ca:	b00d      	add	sp, #52	; 0x34
    f5cc:	f85d fb04 	ldr.w	pc, [sp], #4
    f5d0:	1ffc0000 	.word	0x1ffc0000

0000f5d4 <FlexCAN_SetMaxMsgBuffNum>:
 * Description   : Set the number of the last Message Buffers.
 * This function will define the number of the last Message Buffers
 *
 *END***************************************************************************/
Flexcan_Ip_StatusType FlexCAN_SetMaxMsgBuffNum(FLEXCAN_Type * base, uint32 maxMsgBuffNum)
{
    f5d4:	b500      	push	{lr}
    f5d6:	b08f      	sub	sp, #60	; 0x3c
    f5d8:	9001      	str	r0, [sp, #4]
    f5da:	9100      	str	r1, [sp, #0]
    uint32 MsgBuffIdx;
    uint32 DataByte;
    const volatile uint32 * RAM = (uint32*)((Flexcan_Ip_PtrSizeType)base + (uint32)FLEXCAN_IP_FEATURE_RAM_OFFSET);
    f5dc:	9b01      	ldr	r3, [sp, #4]
    f5de:	3380      	adds	r3, #128	; 0x80
    f5e0:	930a      	str	r3, [sp, #40]	; 0x28
#if (STD_ON == FLEXCAN_IP_FEATURE_HAS_EXPANDABLE_MEMORY)
    const volatile uint32 * RAM_EXPANDED = (uint32*)((Flexcan_Ip_PtrSizeType)base + (uint32)FLEXCAN_IP_FEATURE_EXP_RAM_OFFSET);
#endif /* FLEXCAN_IP_FEATURE_HAS_EXPANDABLE_MEMORY */
    const volatile uint32 * ValEndMbPointer = NULL_PTR;
    f5e2:	2300      	movs	r3, #0
    f5e4:	9309      	str	r3, [sp, #36]	; 0x24
    volatile uint32 *Flexcan_Mb = NULL_PTR;
    f5e6:	2300      	movs	r3, #0
    f5e8:	9308      	str	r3, [sp, #32]
    volatile uint32 *Flexcan_Mb_Id   = NULL_PTR ;
    f5ea:	2300      	movs	r3, #0
    f5ec:	9307      	str	r3, [sp, #28]
    volatile uint8  *Flexcan_Mb_Data = NULL_PTR;
    f5ee:	2300      	movs	r3, #0
    f5f0:	9306      	str	r3, [sp, #24]
    uint8 Arbitration_Field_Size = 8U;
    f5f2:	2308      	movs	r3, #8
    f5f4:	f88d 3017 	strb.w	r3, [sp, #23]
    uint8 Can_Real_Payload = FlexCAN_GetMbPayloadSize(base, maxMsgBuffNum - (uint32)1U);
    f5f8:	9b00      	ldr	r3, [sp, #0]
    f5fa:	3b01      	subs	r3, #1
    f5fc:	4619      	mov	r1, r3
    f5fe:	9801      	ldr	r0, [sp, #4]
    f600:	f7ff fcb6 	bl	ef70 <FlexCAN_GetMbPayloadSize>
    f604:	4603      	mov	r3, r0
    f606:	f88d 3016 	strb.w	r3, [sp, #22]
    Flexcan_Ip_PtrSizeType ValEndMb = 0U;
    f60a:	2300      	movs	r3, #0
    f60c:	9304      	str	r3, [sp, #16]
    Flexcan_Ip_PtrSizeType ValEndRam = 0U;
    f60e:	2300      	movs	r3, #0
    f610:	9303      	str	r3, [sp, #12]
    Flexcan_Ip_StatusType Status = FLEXCAN_STATUS_SUCCESS;
    f612:	2300      	movs	r3, #0
    f614:	930b      	str	r3, [sp, #44]	; 0x2c

    #if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
        DevAssert(maxMsgBuffNum>0U);
    #endif

    ValEndMbPointer = FlexCAN_GetMsgBuffRegion(base, (maxMsgBuffNum - (uint32)1U));
    f616:	9b00      	ldr	r3, [sp, #0]
    f618:	3b01      	subs	r3, #1
    f61a:	4619      	mov	r1, r3
    f61c:	9801      	ldr	r0, [sp, #4]
    f61e:	f7ff f979 	bl	e914 <FlexCAN_GetMsgBuffRegion>
    f622:	9009      	str	r0, [sp, #36]	; 0x24

    ValEndMb = (Flexcan_Ip_PtrSizeType)ValEndMbPointer + Can_Real_Payload + Arbitration_Field_Size;
    f624:	f89d 2016 	ldrb.w	r2, [sp, #22]
    f628:	9b09      	ldr	r3, [sp, #36]	; 0x24
    f62a:	441a      	add	r2, r3
    f62c:	f89d 3017 	ldrb.w	r3, [sp, #23]
    f630:	4413      	add	r3, r2
    f632:	9304      	str	r3, [sp, #16]
    else
    {
        ValEndRam = (Flexcan_Ip_PtrSizeType)&RAM[(FlexCAN_GetMaxMbNum(base) * 4U)];
    }
#else
    ValEndRam = (Flexcan_Ip_PtrSizeType)&RAM[(FlexCAN_GetMaxMbNum(base) * 4U)];
    f634:	9801      	ldr	r0, [sp, #4]
    f636:	f7ff f9e7 	bl	ea08 <FlexCAN_GetMaxMbNum>
    f63a:	4603      	mov	r3, r0
    f63c:	011b      	lsls	r3, r3, #4
    f63e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    f640:	4413      	add	r3, r2
    f642:	9303      	str	r3, [sp, #12]
#endif /* FLEXCAN_IP_FEATURE_HAS_EXPANDABLE_MEMORY */

    if ((ValEndMb > ValEndRam) || (maxMsgBuffNum > FlexCAN_GetMaxMbNum(base)))
    f644:	9a04      	ldr	r2, [sp, #16]
    f646:	9b03      	ldr	r3, [sp, #12]
    f648:	429a      	cmp	r2, r3
    f64a:	d806      	bhi.n	f65a <FlexCAN_SetMaxMsgBuffNum+0x86>
    f64c:	9801      	ldr	r0, [sp, #4]
    f64e:	f7ff f9db 	bl	ea08 <FlexCAN_GetMaxMbNum>
    f652:	4602      	mov	r2, r0
    f654:	9b00      	ldr	r3, [sp, #0]
    f656:	4293      	cmp	r3, r2
    f658:	d901      	bls.n	f65e <FlexCAN_SetMaxMsgBuffNum+0x8a>
    {
        Status = FLEXCAN_STATUS_BUFF_OUT_OF_RANGE;
    f65a:	2304      	movs	r3, #4
    f65c:	930b      	str	r3, [sp, #44]	; 0x2c
    }

    if (FLEXCAN_STATUS_SUCCESS == Status)
    f65e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f660:	2b00      	cmp	r3, #0
    f662:	d142      	bne.n	f6ea <FlexCAN_SetMaxMsgBuffNum+0x116>
    {
        /* Set the maximum number of MBs*/
        base->MCR = (base->MCR & ~FLEXCAN_MCR_MAXMB_MASK) | (((maxMsgBuffNum-1U) << FLEXCAN_MCR_MAXMB_SHIFT) & FLEXCAN_MCR_MAXMB_MASK);
    f664:	9b01      	ldr	r3, [sp, #4]
    f666:	681b      	ldr	r3, [r3, #0]
    f668:	f023 027f 	bic.w	r2, r3, #127	; 0x7f
    f66c:	9b00      	ldr	r3, [sp, #0]
    f66e:	3b01      	subs	r3, #1
    f670:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    f674:	431a      	orrs	r2, r3
    f676:	9b01      	ldr	r3, [sp, #4]
    f678:	601a      	str	r2, [r3, #0]
        if (!(((base->MCR & FLEXCAN_MCR_RFEN_MASK) >> FLEXCAN_MCR_RFEN_SHIFT) != 0U))
    f67a:	9b01      	ldr	r3, [sp, #4]
    f67c:	681b      	ldr	r3, [r3, #0]
    f67e:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
    f682:	2b00      	cmp	r3, #0
    f684:	d131      	bne.n	f6ea <FlexCAN_SetMaxMsgBuffNum+0x116>
        {
            /* Initialize all message buffers as inactive */
            for (MsgBuffIdx = 0; MsgBuffIdx < maxMsgBuffNum; MsgBuffIdx++)
    f686:	2300      	movs	r3, #0
    f688:	930d      	str	r3, [sp, #52]	; 0x34
    f68a:	e02a      	b.n	f6e2 <FlexCAN_SetMaxMsgBuffNum+0x10e>
            {
                Flexcan_Mb = FlexCAN_GetMsgBuffRegion(base, MsgBuffIdx);
    f68c:	990d      	ldr	r1, [sp, #52]	; 0x34
    f68e:	9801      	ldr	r0, [sp, #4]
    f690:	f7ff f940 	bl	e914 <FlexCAN_GetMsgBuffRegion>
    f694:	9008      	str	r0, [sp, #32]
                Flexcan_Mb_Id   = &Flexcan_Mb[1];
    f696:	9b08      	ldr	r3, [sp, #32]
    f698:	3304      	adds	r3, #4
    f69a:	9307      	str	r3, [sp, #28]
                Flexcan_Mb_Data = (volatile uint8*)(&Flexcan_Mb[2]);
    f69c:	9b08      	ldr	r3, [sp, #32]
    f69e:	3308      	adds	r3, #8
    f6a0:	9306      	str	r3, [sp, #24]
                *Flexcan_Mb = 0x0U;
    f6a2:	9b08      	ldr	r3, [sp, #32]
    f6a4:	2200      	movs	r2, #0
    f6a6:	601a      	str	r2, [r3, #0]
                *Flexcan_Mb_Id = 0x0U;
    f6a8:	9b07      	ldr	r3, [sp, #28]
    f6aa:	2200      	movs	r2, #0
    f6ac:	601a      	str	r2, [r3, #0]
                Can_Real_Payload = FlexCAN_GetMbPayloadSize(base, MsgBuffIdx);
    f6ae:	990d      	ldr	r1, [sp, #52]	; 0x34
    f6b0:	9801      	ldr	r0, [sp, #4]
    f6b2:	f7ff fc5d 	bl	ef70 <FlexCAN_GetMbPayloadSize>
    f6b6:	4603      	mov	r3, r0
    f6b8:	f88d 3016 	strb.w	r3, [sp, #22]
                for (DataByte = 0; DataByte < Can_Real_Payload; DataByte++)
    f6bc:	2300      	movs	r3, #0
    f6be:	930c      	str	r3, [sp, #48]	; 0x30
    f6c0:	e007      	b.n	f6d2 <FlexCAN_SetMaxMsgBuffNum+0xfe>
                {
                   Flexcan_Mb_Data[DataByte] = 0x0U;
    f6c2:	9a06      	ldr	r2, [sp, #24]
    f6c4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    f6c6:	4413      	add	r3, r2
    f6c8:	2200      	movs	r2, #0
    f6ca:	701a      	strb	r2, [r3, #0]
                for (DataByte = 0; DataByte < Can_Real_Payload; DataByte++)
    f6cc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    f6ce:	3301      	adds	r3, #1
    f6d0:	930c      	str	r3, [sp, #48]	; 0x30
    f6d2:	f89d 3016 	ldrb.w	r3, [sp, #22]
    f6d6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    f6d8:	429a      	cmp	r2, r3
    f6da:	d3f2      	bcc.n	f6c2 <FlexCAN_SetMaxMsgBuffNum+0xee>
            for (MsgBuffIdx = 0; MsgBuffIdx < maxMsgBuffNum; MsgBuffIdx++)
    f6dc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    f6de:	3301      	adds	r3, #1
    f6e0:	930d      	str	r3, [sp, #52]	; 0x34
    f6e2:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    f6e4:	9b00      	ldr	r3, [sp, #0]
    f6e6:	429a      	cmp	r2, r3
    f6e8:	d3d0      	bcc.n	f68c <FlexCAN_SetMaxMsgBuffNum+0xb8>
                }
            }
        }
    }
    return Status;
    f6ea:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
}
    f6ec:	4618      	mov	r0, r3
    f6ee:	b00f      	add	sp, #60	; 0x3c
    f6f0:	f85d fb04 	ldr.w	pc, [sp], #4

0000f6f4 <FlexCAN_SetOperationMode>:
 * Description   : Enable a FlexCAN operation mode.
 * This function will enable one of the modes listed in flexcan_operation_modes_t.
 *
 *END**************************************************************************/
void FlexCAN_SetOperationMode(FLEXCAN_Type * base, Flexcan_Ip_ModesType mode)
{
    f6f4:	b500      	push	{lr}
    f6f6:	b083      	sub	sp, #12
    f6f8:	9001      	str	r0, [sp, #4]
    f6fa:	9100      	str	r1, [sp, #0]
    switch (mode)
    f6fc:	9b00      	ldr	r3, [sp, #0]
    f6fe:	2b02      	cmp	r3, #2
    f700:	d01d      	beq.n	f73e <FlexCAN_SetOperationMode+0x4a>
    f702:	9b00      	ldr	r3, [sp, #0]
    f704:	2b02      	cmp	r3, #2
    f706:	d82b      	bhi.n	f760 <FlexCAN_SetOperationMode+0x6c>
    f708:	9b00      	ldr	r3, [sp, #0]
    f70a:	2b00      	cmp	r3, #0
    f70c:	d003      	beq.n	f716 <FlexCAN_SetOperationMode+0x22>
    f70e:	9b00      	ldr	r3, [sp, #0]
    f710:	2b01      	cmp	r3, #1
    f712:	d00d      	beq.n	f730 <FlexCAN_SetOperationMode+0x3c>
            /* Enable Self Reception */
            FlexCAN_SetSelfReception(base, TRUE);
            break;
        default:
            /* Should not get here */
            break;
    f714:	e024      	b.n	f760 <FlexCAN_SetOperationMode+0x6c>
            base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_LOM_MASK) | FLEXCAN_CTRL1_LOM(0U);
    f716:	9b01      	ldr	r3, [sp, #4]
    f718:	685b      	ldr	r3, [r3, #4]
    f71a:	f023 0208 	bic.w	r2, r3, #8
    f71e:	9b01      	ldr	r3, [sp, #4]
    f720:	605a      	str	r2, [r3, #4]
            base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_LPB_MASK) | FLEXCAN_CTRL1_LPB(0U);
    f722:	9b01      	ldr	r3, [sp, #4]
    f724:	685b      	ldr	r3, [r3, #4]
    f726:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
    f72a:	9b01      	ldr	r3, [sp, #4]
    f72c:	605a      	str	r2, [r3, #4]
            break;
    f72e:	e018      	b.n	f762 <FlexCAN_SetOperationMode+0x6e>
            base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_LOM_MASK) | FLEXCAN_CTRL1_LOM(1U);
    f730:	9b01      	ldr	r3, [sp, #4]
    f732:	685b      	ldr	r3, [r3, #4]
    f734:	f043 0208 	orr.w	r2, r3, #8
    f738:	9b01      	ldr	r3, [sp, #4]
    f73a:	605a      	str	r2, [r3, #4]
            break;
    f73c:	e011      	b.n	f762 <FlexCAN_SetOperationMode+0x6e>
            base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_LPB_MASK) | FLEXCAN_CTRL1_LPB(1U);
    f73e:	9b01      	ldr	r3, [sp, #4]
    f740:	685b      	ldr	r3, [r3, #4]
    f742:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
    f746:	9b01      	ldr	r3, [sp, #4]
    f748:	605a      	str	r2, [r3, #4]
            base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_LOM_MASK) | FLEXCAN_CTRL1_LOM(0U);
    f74a:	9b01      	ldr	r3, [sp, #4]
    f74c:	685b      	ldr	r3, [r3, #4]
    f74e:	f023 0208 	bic.w	r2, r3, #8
    f752:	9b01      	ldr	r3, [sp, #4]
    f754:	605a      	str	r2, [r3, #4]
            FlexCAN_SetSelfReception(base, TRUE);
    f756:	2101      	movs	r1, #1
    f758:	9801      	ldr	r0, [sp, #4]
    f75a:	f7fe ff7f 	bl	e65c <FlexCAN_SetSelfReception>
            break;
    f75e:	e000      	b.n	f762 <FlexCAN_SetOperationMode+0x6e>
            break;
    f760:	bf00      	nop
    }
}
    f762:	bf00      	nop
    f764:	b003      	add	sp, #12
    f766:	f85d fb04 	ldr.w	pc, [sp], #4

0000f76a <FlexCAN_SetRxFifoFilter>:
 *END**************************************************************************/
void FlexCAN_SetRxFifoFilter(FLEXCAN_Type * base,
                             Flexcan_Ip_RxFifoIdElementFormatType idFormat,
                             const Flexcan_Ip_IdTableType * idFilterTable
                            )
{
    f76a:	b500      	push	{lr}
    f76c:	b08d      	sub	sp, #52	; 0x34
    f76e:	9003      	str	r0, [sp, #12]
    f770:	9102      	str	r1, [sp, #8]
    f772:	9201      	str	r2, [sp, #4]

    /* Set RX FIFO ID filter table elements*/
    uint32 i, j, NumOfFilters;
    uint32 Val1 = 0UL, Val2 = 0UL, Val = 0UL;
    f774:	2300      	movs	r3, #0
    f776:	9309      	str	r3, [sp, #36]	; 0x24
    f778:	2300      	movs	r3, #0
    f77a:	9308      	str	r3, [sp, #32]
    f77c:	2300      	movs	r3, #0
    f77e:	9307      	str	r3, [sp, #28]
    volatile uint32 * FilterTable = (uint32 *)((Flexcan_Ip_PtrSizeType)base + (uint32)FLEXCAN_IP_RX_FIFO_FILTER_TABLE_OFFSET);
    f780:	9b03      	ldr	r3, [sp, #12]
    f782:	33e0      	adds	r3, #224	; 0xe0
    f784:	9306      	str	r3, [sp, #24]

    #if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
        DevAssert((idFilterTable != NULL_PTR) || (FLEXCAN_RX_FIFO_ID_FORMAT_D == idFormat));
    #endif

    NumOfFilters = (((base->CTRL2) & FLEXCAN_CTRL2_RFFN_MASK) >> FLEXCAN_CTRL2_RFFN_SHIFT);
    f786:	9b03      	ldr	r3, [sp, #12]
    f788:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    f78a:	0e1b      	lsrs	r3, r3, #24
    f78c:	f003 030f 	and.w	r3, r3, #15
    f790:	9305      	str	r3, [sp, #20]
    f792:	9b02      	ldr	r3, [sp, #8]
    f794:	2b03      	cmp	r3, #3
    f796:	f200 81e7 	bhi.w	fb68 <FlexCAN_SetRxFifoFilter+0x3fe>
    f79a:	a201      	add	r2, pc, #4	; (adr r2, f7a0 <FlexCAN_SetRxFifoFilter+0x36>)
    f79c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    f7a0:	0000f7b1 	.word	0x0000f7b1
    f7a4:	0000f84b 	.word	0x0000f84b
    f7a8:	0000f985 	.word	0x0000f985
    f7ac:	0000fb53 	.word	0x0000fb53
    switch (idFormat)
    {
        case (FLEXCAN_RX_FIFO_ID_FORMAT_A):
            /* Start critical section: implementation depends on integrator */
            SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    f7b0:	f004 ff18 	bl	145e4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            /* One full ID (standard and extended) per ID Filter Table element.*/
            (base->MCR) =
                (((base->MCR) & ~(FLEXCAN_MCR_IDAM_MASK)) |
    f7b4:	9b03      	ldr	r3, [sp, #12]
    f7b6:	681b      	ldr	r3, [r3, #0]
    f7b8:	f423 7240 	bic.w	r2, r3, #768	; 0x300
            (base->MCR) =
    f7bc:	9b03      	ldr	r3, [sp, #12]
    f7be:	601a      	str	r2, [r3, #0]
                 ((((uint32)(((uint32)(FLEXCAN_RX_FIFO_ID_FORMAT_A)) << FLEXCAN_MCR_IDAM_SHIFT)) & FLEXCAN_MCR_IDAM_MASK)));
            /* End critical section: implementation depends on integrator */
            SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    f7c0:	f004 ff3c 	bl	1463c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            for (i = 0U; i < FLEXCAN_IP_RXFIFO_FILTER_ELEM_NUM(NumOfFilters); i++)
    f7c4:	2300      	movs	r3, #0
    f7c6:	930b      	str	r3, [sp, #44]	; 0x2c
    f7c8:	e038      	b.n	f83c <FlexCAN_SetRxFifoFilter+0xd2>
            {
                Val = 0UL;
    f7ca:	2300      	movs	r3, #0
    f7cc:	9307      	str	r3, [sp, #28]

                if (idFilterTable[i].isRemoteFrame)
    f7ce:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f7d0:	00db      	lsls	r3, r3, #3
    f7d2:	9a01      	ldr	r2, [sp, #4]
    f7d4:	4413      	add	r3, r2
    f7d6:	781b      	ldrb	r3, [r3, #0]
    f7d8:	2b00      	cmp	r3, #0
    f7da:	d002      	beq.n	f7e2 <FlexCAN_SetRxFifoFilter+0x78>
                {
                    Val = FLEXCAN_IP_RX_FIFO_ACCEPT_REMOTE_FRAME << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATAB_RTR_SHIFT;
    f7dc:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
    f7e0:	9307      	str	r3, [sp, #28]
                }

                if (idFilterTable[i].isExtendedFrame)
    f7e2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f7e4:	00db      	lsls	r3, r3, #3
    f7e6:	9a01      	ldr	r2, [sp, #4]
    f7e8:	4413      	add	r3, r2
    f7ea:	785b      	ldrb	r3, [r3, #1]
    f7ec:	2b00      	cmp	r3, #0
    f7ee:	d013      	beq.n	f818 <FlexCAN_SetRxFifoFilter+0xae>
                {
                    Val |= FLEXCAN_IP_RX_FIFO_ACCEPT_EXT_FRAME << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATAB_IDE_SHIFT;
    f7f0:	9b07      	ldr	r3, [sp, #28]
    f7f2:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    f7f6:	9307      	str	r3, [sp, #28]
                    FilterTable[i] = Val + ((idFilterTable[i].id << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATA_EXT_SHIFT) &
    f7f8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f7fa:	00db      	lsls	r3, r3, #3
    f7fc:	9a01      	ldr	r2, [sp, #4]
    f7fe:	4413      	add	r3, r2
    f800:	685b      	ldr	r3, [r3, #4]
    f802:	005b      	lsls	r3, r3, #1
    f804:	f023 4140 	bic.w	r1, r3, #3221225472	; 0xc0000000
    f808:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f80a:	009b      	lsls	r3, r3, #2
    f80c:	9a06      	ldr	r2, [sp, #24]
    f80e:	4413      	add	r3, r2
    f810:	9a07      	ldr	r2, [sp, #28]
    f812:	440a      	add	r2, r1
    f814:	601a      	str	r2, [r3, #0]
    f816:	e00e      	b.n	f836 <FlexCAN_SetRxFifoFilter+0xcc>
                                             FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATA_EXT_MASK
                                           );
                }
                else
                {
                    FilterTable[i] = Val + ((idFilterTable[i].id << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATA_STD_SHIFT) &
    f818:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f81a:	00db      	lsls	r3, r3, #3
    f81c:	9a01      	ldr	r2, [sp, #4]
    f81e:	4413      	add	r3, r2
    f820:	685b      	ldr	r3, [r3, #4]
    f822:	04da      	lsls	r2, r3, #19
    f824:	4b9d      	ldr	r3, [pc, #628]	; (fa9c <FlexCAN_SetRxFifoFilter+0x332>)
    f826:	4013      	ands	r3, r2
    f828:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    f82a:	0092      	lsls	r2, r2, #2
    f82c:	9906      	ldr	r1, [sp, #24]
    f82e:	440a      	add	r2, r1
    f830:	9907      	ldr	r1, [sp, #28]
    f832:	440b      	add	r3, r1
    f834:	6013      	str	r3, [r2, #0]
            for (i = 0U; i < FLEXCAN_IP_RXFIFO_FILTER_ELEM_NUM(NumOfFilters); i++)
    f836:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f838:	3301      	adds	r3, #1
    f83a:	930b      	str	r3, [sp, #44]	; 0x2c
    f83c:	9b05      	ldr	r3, [sp, #20]
    f83e:	3301      	adds	r3, #1
    f840:	00db      	lsls	r3, r3, #3
    f842:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    f844:	429a      	cmp	r2, r3
    f846:	d3c0      	bcc.n	f7ca <FlexCAN_SetRxFifoFilter+0x60>
                                             FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATA_STD_MASK
                                           );
                }
            }
            break;
    f848:	e18f      	b.n	fb6a <FlexCAN_SetRxFifoFilter+0x400>
        case (FLEXCAN_RX_FIFO_ID_FORMAT_B):
            /* Two full standard IDs or two partial 14-bit (standard and extended) IDs*/
            /* per ID Filter Table element.*/
            /* Start critical section: implementation depends on integrator */
            SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    f84a:	f004 fecb 	bl	145e4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            (base->MCR) =
                (((base->MCR) & ~(FLEXCAN_MCR_IDAM_MASK)) | ((((uint32)(((uint32)(FLEXCAN_RX_FIFO_ID_FORMAT_B)) << FLEXCAN_MCR_IDAM_SHIFT)) & FLEXCAN_MCR_IDAM_MASK)));
    f84e:	9b03      	ldr	r3, [sp, #12]
    f850:	681b      	ldr	r3, [r3, #0]
    f852:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    f856:	f443 7280 	orr.w	r2, r3, #256	; 0x100
            (base->MCR) =
    f85a:	9b03      	ldr	r3, [sp, #12]
    f85c:	601a      	str	r2, [r3, #0]
            /* End critical section: implementation depends on integrator */
            SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    f85e:	f004 feed 	bl	1463c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            j = 0U;
    f862:	2300      	movs	r3, #0
    f864:	930a      	str	r3, [sp, #40]	; 0x28
            for (i = 0U; i < FLEXCAN_IP_RXFIFO_FILTER_ELEM_NUM(NumOfFilters); i++)
    f866:	2300      	movs	r3, #0
    f868:	930b      	str	r3, [sp, #44]	; 0x2c
    f86a:	e083      	b.n	f974 <FlexCAN_SetRxFifoFilter+0x20a>
            {
                Val1 = 0U;
    f86c:	2300      	movs	r3, #0
    f86e:	9309      	str	r3, [sp, #36]	; 0x24
                Val2 = 0U;
    f870:	2300      	movs	r3, #0
    f872:	9308      	str	r3, [sp, #32]

                if (idFilterTable[j].isRemoteFrame)
    f874:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f876:	00db      	lsls	r3, r3, #3
    f878:	9a01      	ldr	r2, [sp, #4]
    f87a:	4413      	add	r3, r2
    f87c:	781b      	ldrb	r3, [r3, #0]
    f87e:	2b00      	cmp	r3, #0
    f880:	d002      	beq.n	f888 <FlexCAN_SetRxFifoFilter+0x11e>
                {
                    Val1 = FLEXCAN_IP_RX_FIFO_ACCEPT_REMOTE_FRAME << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATAB_RTR_SHIFT;
    f882:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
    f886:	9309      	str	r3, [sp, #36]	; 0x24
                }

                if (idFilterTable[j + 1U].isRemoteFrame)
    f888:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f88a:	3301      	adds	r3, #1
    f88c:	00db      	lsls	r3, r3, #3
    f88e:	9a01      	ldr	r2, [sp, #4]
    f890:	4413      	add	r3, r2
    f892:	781b      	ldrb	r3, [r3, #0]
    f894:	2b00      	cmp	r3, #0
    f896:	d002      	beq.n	f89e <FlexCAN_SetRxFifoFilter+0x134>
                {
                    Val2 = FLEXCAN_IP_RX_FIFO_ACCEPT_REMOTE_FRAME << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_RTR_SHIFT;
    f898:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    f89c:	9308      	str	r3, [sp, #32]
                }

                if (idFilterTable[j].isExtendedFrame)
    f89e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f8a0:	00db      	lsls	r3, r3, #3
    f8a2:	9a01      	ldr	r2, [sp, #4]
    f8a4:	4413      	add	r3, r2
    f8a6:	785b      	ldrb	r3, [r3, #1]
    f8a8:	2b00      	cmp	r3, #0
    f8aa:	d014      	beq.n	f8d6 <FlexCAN_SetRxFifoFilter+0x16c>
                {
                    Val1 |= FLEXCAN_IP_RX_FIFO_ACCEPT_EXT_FRAME << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATAB_IDE_SHIFT;
    f8ac:	9b09      	ldr	r3, [sp, #36]	; 0x24
    f8ae:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    f8b2:	9309      	str	r3, [sp, #36]	; 0x24

                    FilterTable[i] = Val1 + (((idFilterTable[j].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_MASK) >>
    f8b4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f8b6:	00db      	lsls	r3, r3, #3
    f8b8:	9a01      	ldr	r2, [sp, #4]
    f8ba:	4413      	add	r3, r2
    f8bc:	685b      	ldr	r3, [r3, #4]
    f8be:	0bdb      	lsrs	r3, r3, #15
                                               FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_CMP_SHIFT
                                             ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_SHIFT1
    f8c0:	041a      	lsls	r2, r3, #16
    f8c2:	4b77      	ldr	r3, [pc, #476]	; (faa0 <FlexCAN_SetRxFifoFilter+0x336>)
    f8c4:	4013      	ands	r3, r2
                    FilterTable[i] = Val1 + (((idFilterTable[j].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_MASK) >>
    f8c6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    f8c8:	0092      	lsls	r2, r2, #2
    f8ca:	9906      	ldr	r1, [sp, #24]
    f8cc:	440a      	add	r2, r1
    f8ce:	9909      	ldr	r1, [sp, #36]	; 0x24
    f8d0:	440b      	add	r3, r1
    f8d2:	6013      	str	r3, [r2, #0]
    f8d4:	e00e      	b.n	f8f4 <FlexCAN_SetRxFifoFilter+0x18a>
                                            );
                }
                else
                {
                    FilterTable[i] = Val1 + ((idFilterTable[j].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_STD_MASK) <<
    f8d6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f8d8:	00db      	lsls	r3, r3, #3
    f8da:	9a01      	ldr	r2, [sp, #4]
    f8dc:	4413      	add	r3, r2
    f8de:	685b      	ldr	r3, [r3, #4]
    f8e0:	04da      	lsls	r2, r3, #19
    f8e2:	4b6e      	ldr	r3, [pc, #440]	; (fa9c <FlexCAN_SetRxFifoFilter+0x332>)
    f8e4:	4013      	ands	r3, r2
    f8e6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    f8e8:	0092      	lsls	r2, r2, #2
    f8ea:	9906      	ldr	r1, [sp, #24]
    f8ec:	440a      	add	r2, r1
    f8ee:	9909      	ldr	r1, [sp, #36]	; 0x24
    f8f0:	440b      	add	r3, r1
    f8f2:	6013      	str	r3, [r2, #0]
                                              FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_STD_SHIFT1
                                            );
                }

                if (idFilterTable[j + 1U].isExtendedFrame)
    f8f4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f8f6:	3301      	adds	r3, #1
    f8f8:	00db      	lsls	r3, r3, #3
    f8fa:	9a01      	ldr	r2, [sp, #4]
    f8fc:	4413      	add	r3, r2
    f8fe:	785b      	ldrb	r3, [r3, #1]
    f900:	2b00      	cmp	r3, #0
    f902:	d01a      	beq.n	f93a <FlexCAN_SetRxFifoFilter+0x1d0>
                {
                    Val2 |= FLEXCAN_IP_RX_FIFO_ACCEPT_EXT_FRAME << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_IDE_SHIFT;
    f904:	9b08      	ldr	r3, [sp, #32]
    f906:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    f90a:	9308      	str	r3, [sp, #32]

                    FilterTable[i] |= Val2 + (((idFilterTable[j + 1U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_MASK) >>
    f90c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f90e:	009b      	lsls	r3, r3, #2
    f910:	9a06      	ldr	r2, [sp, #24]
    f912:	4413      	add	r3, r2
    f914:	6819      	ldr	r1, [r3, #0]
    f916:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f918:	3301      	adds	r3, #1
    f91a:	00db      	lsls	r3, r3, #3
    f91c:	9a01      	ldr	r2, [sp, #4]
    f91e:	4413      	add	r3, r2
    f920:	685b      	ldr	r3, [r3, #4]
    f922:	0bdb      	lsrs	r3, r3, #15
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_CMP_SHIFT
                                              ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_SHIFT2
    f924:	f3c3 020d 	ubfx	r2, r3, #0, #14
                    FilterTable[i] |= Val2 + (((idFilterTable[j + 1U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_MASK) >>
    f928:	9b08      	ldr	r3, [sp, #32]
    f92a:	441a      	add	r2, r3
    f92c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f92e:	009b      	lsls	r3, r3, #2
    f930:	9806      	ldr	r0, [sp, #24]
    f932:	4403      	add	r3, r0
    f934:	430a      	orrs	r2, r1
    f936:	601a      	str	r2, [r3, #0]
    f938:	e016      	b.n	f968 <FlexCAN_SetRxFifoFilter+0x1fe>
                                             );
                }
                else
                {
                    FilterTable[i] |= Val2 + ((idFilterTable[j + 1U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_STD_MASK) <<
    f93a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f93c:	009b      	lsls	r3, r3, #2
    f93e:	9a06      	ldr	r2, [sp, #24]
    f940:	4413      	add	r3, r2
    f942:	6819      	ldr	r1, [r3, #0]
    f944:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f946:	3301      	adds	r3, #1
    f948:	00db      	lsls	r3, r3, #3
    f94a:	9a01      	ldr	r2, [sp, #4]
    f94c:	4413      	add	r3, r2
    f94e:	685b      	ldr	r3, [r3, #4]
    f950:	00da      	lsls	r2, r3, #3
    f952:	f643 73f8 	movw	r3, #16376	; 0x3ff8
    f956:	4013      	ands	r3, r2
    f958:	9a08      	ldr	r2, [sp, #32]
    f95a:	441a      	add	r2, r3
    f95c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f95e:	009b      	lsls	r3, r3, #2
    f960:	9806      	ldr	r0, [sp, #24]
    f962:	4403      	add	r3, r0
    f964:	430a      	orrs	r2, r1
    f966:	601a      	str	r2, [r3, #0]
                                               FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_STD_SHIFT2
                                             );
                }

                j = j + 2U;
    f968:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f96a:	3302      	adds	r3, #2
    f96c:	930a      	str	r3, [sp, #40]	; 0x28
            for (i = 0U; i < FLEXCAN_IP_RXFIFO_FILTER_ELEM_NUM(NumOfFilters); i++)
    f96e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f970:	3301      	adds	r3, #1
    f972:	930b      	str	r3, [sp, #44]	; 0x2c
    f974:	9b05      	ldr	r3, [sp, #20]
    f976:	3301      	adds	r3, #1
    f978:	00db      	lsls	r3, r3, #3
    f97a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    f97c:	429a      	cmp	r2, r3
    f97e:	f4ff af75 	bcc.w	f86c <FlexCAN_SetRxFifoFilter+0x102>
            }
            break;
    f982:	e0f2      	b.n	fb6a <FlexCAN_SetRxFifoFilter+0x400>
        case (FLEXCAN_RX_FIFO_ID_FORMAT_C):
            /* Four partial 8-bit Standard IDs per ID Filter Table element.*/
            /* Start critical section: implementation depends on integrator */
            SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    f984:	f004 fe2e 	bl	145e4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            (base->MCR) =
                (((base->MCR) & ~(FLEXCAN_MCR_IDAM_MASK)) |
    f988:	9b03      	ldr	r3, [sp, #12]
    f98a:	681b      	ldr	r3, [r3, #0]
    f98c:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    f990:	f443 7200 	orr.w	r2, r3, #512	; 0x200
            (base->MCR) =
    f994:	9b03      	ldr	r3, [sp, #12]
    f996:	601a      	str	r2, [r3, #0]
                 ((((uint32)(((uint32)(FLEXCAN_RX_FIFO_ID_FORMAT_C)) << FLEXCAN_MCR_IDAM_SHIFT)) & FLEXCAN_MCR_IDAM_MASK))
                );
            /* End critical section: implementation depends on integrator */
            SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    f998:	f004 fe50 	bl	1463c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            j = 0U;
    f99c:	2300      	movs	r3, #0
    f99e:	930a      	str	r3, [sp, #40]	; 0x28
            for (i = 0U; i < FLEXCAN_IP_RXFIFO_FILTER_ELEM_NUM(NumOfFilters); i++)
    f9a0:	2300      	movs	r3, #0
    f9a2:	930b      	str	r3, [sp, #44]	; 0x2c
    f9a4:	e0cd      	b.n	fb42 <FlexCAN_SetRxFifoFilter+0x3d8>
            {
                if (idFilterTable[j].isExtendedFrame)
    f9a6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f9a8:	00db      	lsls	r3, r3, #3
    f9aa:	9a01      	ldr	r2, [sp, #4]
    f9ac:	4413      	add	r3, r2
    f9ae:	785b      	ldrb	r3, [r3, #1]
    f9b0:	2b00      	cmp	r3, #0
    f9b2:	d00e      	beq.n	f9d2 <FlexCAN_SetRxFifoFilter+0x268>
                {
                    FilterTable[i] = Val1 + (((idFilterTable[j].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    f9b4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f9b6:	00db      	lsls	r3, r3, #3
    f9b8:	9a01      	ldr	r2, [sp, #4]
    f9ba:	4413      	add	r3, r2
    f9bc:	685b      	ldr	r3, [r3, #4]
    f9be:	0d5b      	lsrs	r3, r3, #21
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT
                                             ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT1
    f9c0:	0619      	lsls	r1, r3, #24
                    FilterTable[i] = Val1 + (((idFilterTable[j].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    f9c2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f9c4:	009b      	lsls	r3, r3, #2
    f9c6:	9a06      	ldr	r2, [sp, #24]
    f9c8:	4413      	add	r3, r2
    f9ca:	9a09      	ldr	r2, [sp, #36]	; 0x24
    f9cc:	440a      	add	r2, r1
    f9ce:	601a      	str	r2, [r3, #0]
    f9d0:	e00d      	b.n	f9ee <FlexCAN_SetRxFifoFilter+0x284>
                                            );
                }
                else
                {
                    FilterTable[i] = Val1 + (((idFilterTable[j].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>
    f9d2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f9d4:	00db      	lsls	r3, r3, #3
    f9d6:	9a01      	ldr	r2, [sp, #4]
    f9d8:	4413      	add	r3, r2
    f9da:	685b      	ldr	r3, [r3, #4]
    f9dc:	08db      	lsrs	r3, r3, #3
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT
                                             ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT1
    f9de:	0619      	lsls	r1, r3, #24
                    FilterTable[i] = Val1 + (((idFilterTable[j].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>
    f9e0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    f9e2:	009b      	lsls	r3, r3, #2
    f9e4:	9a06      	ldr	r2, [sp, #24]
    f9e6:	4413      	add	r3, r2
    f9e8:	9a09      	ldr	r2, [sp, #36]	; 0x24
    f9ea:	440a      	add	r2, r1
    f9ec:	601a      	str	r2, [r3, #0]
                                            );
                }

                if (idFilterTable[j + 1U].isExtendedFrame)
    f9ee:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    f9f0:	3301      	adds	r3, #1
    f9f2:	00db      	lsls	r3, r3, #3
    f9f4:	9a01      	ldr	r2, [sp, #4]
    f9f6:	4413      	add	r3, r2
    f9f8:	785b      	ldrb	r3, [r3, #1]
    f9fa:	2b00      	cmp	r3, #0
    f9fc:	d017      	beq.n	fa2e <FlexCAN_SetRxFifoFilter+0x2c4>
                {
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 1U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    f9fe:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    fa00:	009b      	lsls	r3, r3, #2
    fa02:	9a06      	ldr	r2, [sp, #24]
    fa04:	4413      	add	r3, r2
    fa06:	6819      	ldr	r1, [r3, #0]
    fa08:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    fa0a:	3301      	adds	r3, #1
    fa0c:	00db      	lsls	r3, r3, #3
    fa0e:	9a01      	ldr	r2, [sp, #4]
    fa10:	4413      	add	r3, r2
    fa12:	685b      	ldr	r3, [r3, #4]
    fa14:	0d5b      	lsrs	r3, r3, #21
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT
                                              ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT2
    fa16:	041b      	lsls	r3, r3, #16
    fa18:	f403 027f 	and.w	r2, r3, #16711680	; 0xff0000
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 1U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    fa1c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    fa1e:	441a      	add	r2, r3
    fa20:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    fa22:	009b      	lsls	r3, r3, #2
    fa24:	9806      	ldr	r0, [sp, #24]
    fa26:	4403      	add	r3, r0
    fa28:	430a      	orrs	r2, r1
    fa2a:	601a      	str	r2, [r3, #0]
    fa2c:	e016      	b.n	fa5c <FlexCAN_SetRxFifoFilter+0x2f2>
                                             );
                }
                else
                {
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 1U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>
    fa2e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    fa30:	009b      	lsls	r3, r3, #2
    fa32:	9a06      	ldr	r2, [sp, #24]
    fa34:	4413      	add	r3, r2
    fa36:	6819      	ldr	r1, [r3, #0]
    fa38:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    fa3a:	3301      	adds	r3, #1
    fa3c:	00db      	lsls	r3, r3, #3
    fa3e:	9a01      	ldr	r2, [sp, #4]
    fa40:	4413      	add	r3, r2
    fa42:	685b      	ldr	r3, [r3, #4]
    fa44:	08db      	lsrs	r3, r3, #3
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT
                                              ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT2
    fa46:	041b      	lsls	r3, r3, #16
    fa48:	f403 027f 	and.w	r2, r3, #16711680	; 0xff0000
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 1U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>
    fa4c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    fa4e:	441a      	add	r2, r3
    fa50:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    fa52:	009b      	lsls	r3, r3, #2
    fa54:	9806      	ldr	r0, [sp, #24]
    fa56:	4403      	add	r3, r0
    fa58:	430a      	orrs	r2, r1
    fa5a:	601a      	str	r2, [r3, #0]
                                             );
                }

                if (idFilterTable[j + 2U].isExtendedFrame)
    fa5c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    fa5e:	3302      	adds	r3, #2
    fa60:	00db      	lsls	r3, r3, #3
    fa62:	9a01      	ldr	r2, [sp, #4]
    fa64:	4413      	add	r3, r2
    fa66:	785b      	ldrb	r3, [r3, #1]
    fa68:	2b00      	cmp	r3, #0
    fa6a:	d01b      	beq.n	faa4 <FlexCAN_SetRxFifoFilter+0x33a>
                {
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 2U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    fa6c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    fa6e:	009b      	lsls	r3, r3, #2
    fa70:	9a06      	ldr	r2, [sp, #24]
    fa72:	4413      	add	r3, r2
    fa74:	6819      	ldr	r1, [r3, #0]
    fa76:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    fa78:	3302      	adds	r3, #2
    fa7a:	00db      	lsls	r3, r3, #3
    fa7c:	9a01      	ldr	r2, [sp, #4]
    fa7e:	4413      	add	r3, r2
    fa80:	685b      	ldr	r3, [r3, #4]
    fa82:	0d5b      	lsrs	r3, r3, #21
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT
                                              ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT3
    fa84:	021b      	lsls	r3, r3, #8
    fa86:	b29a      	uxth	r2, r3
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 2U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    fa88:	9b09      	ldr	r3, [sp, #36]	; 0x24
    fa8a:	441a      	add	r2, r3
    fa8c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    fa8e:	009b      	lsls	r3, r3, #2
    fa90:	9806      	ldr	r0, [sp, #24]
    fa92:	4403      	add	r3, r0
    fa94:	430a      	orrs	r2, r1
    fa96:	601a      	str	r2, [r3, #0]
    fa98:	e01a      	b.n	fad0 <FlexCAN_SetRxFifoFilter+0x366>
    fa9a:	bf00      	nop
    fa9c:	3ff80000 	.word	0x3ff80000
    faa0:	3fff0000 	.word	0x3fff0000
                                             );
                }
                else
                {
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 2U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>
    faa4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    faa6:	009b      	lsls	r3, r3, #2
    faa8:	9a06      	ldr	r2, [sp, #24]
    faaa:	4413      	add	r3, r2
    faac:	6819      	ldr	r1, [r3, #0]
    faae:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    fab0:	3302      	adds	r3, #2
    fab2:	00db      	lsls	r3, r3, #3
    fab4:	9a01      	ldr	r2, [sp, #4]
    fab6:	4413      	add	r3, r2
    fab8:	685b      	ldr	r3, [r3, #4]
    faba:	08db      	lsrs	r3, r3, #3
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT
                                              ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT3
    fabc:	021b      	lsls	r3, r3, #8
    fabe:	b29a      	uxth	r2, r3
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 2U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>
    fac0:	9b09      	ldr	r3, [sp, #36]	; 0x24
    fac2:	441a      	add	r2, r3
    fac4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    fac6:	009b      	lsls	r3, r3, #2
    fac8:	9806      	ldr	r0, [sp, #24]
    faca:	4403      	add	r3, r0
    facc:	430a      	orrs	r2, r1
    face:	601a      	str	r2, [r3, #0]
                                             );
                }

                if (idFilterTable[j + 3U].isExtendedFrame)
    fad0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    fad2:	3303      	adds	r3, #3
    fad4:	00db      	lsls	r3, r3, #3
    fad6:	9a01      	ldr	r2, [sp, #4]
    fad8:	4413      	add	r3, r2
    fada:	785b      	ldrb	r3, [r3, #1]
    fadc:	2b00      	cmp	r3, #0
    fade:	d015      	beq.n	fb0c <FlexCAN_SetRxFifoFilter+0x3a2>
                {
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 3U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    fae0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    fae2:	009b      	lsls	r3, r3, #2
    fae4:	9a06      	ldr	r2, [sp, #24]
    fae6:	4413      	add	r3, r2
    fae8:	6819      	ldr	r1, [r3, #0]
    faea:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    faec:	3303      	adds	r3, #3
    faee:	00db      	lsls	r3, r3, #3
    faf0:	9a01      	ldr	r2, [sp, #4]
    faf2:	4413      	add	r3, r2
    faf4:	685b      	ldr	r3, [r3, #4]
    faf6:	0d5b      	lsrs	r3, r3, #21
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT
                                              ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT4
    faf8:	b2da      	uxtb	r2, r3
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 3U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    fafa:	9b09      	ldr	r3, [sp, #36]	; 0x24
    fafc:	441a      	add	r2, r3
    fafe:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    fb00:	009b      	lsls	r3, r3, #2
    fb02:	9806      	ldr	r0, [sp, #24]
    fb04:	4403      	add	r3, r0
    fb06:	430a      	orrs	r2, r1
    fb08:	601a      	str	r2, [r3, #0]
    fb0a:	e014      	b.n	fb36 <FlexCAN_SetRxFifoFilter+0x3cc>
                                             );
                }
                else
                {
                    FilterTable[i] |= Val1 +
    fb0c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    fb0e:	009b      	lsls	r3, r3, #2
    fb10:	9a06      	ldr	r2, [sp, #24]
    fb12:	4413      	add	r3, r2
    fb14:	6819      	ldr	r1, [r3, #0]
                                      (((idFilterTable[j + 3U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>
    fb16:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    fb18:	3303      	adds	r3, #3
    fb1a:	00db      	lsls	r3, r3, #3
    fb1c:	9a01      	ldr	r2, [sp, #4]
    fb1e:	4413      	add	r3, r2
    fb20:	685b      	ldr	r3, [r3, #4]
    fb22:	08db      	lsrs	r3, r3, #3
                                        FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT
                                       ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT4
    fb24:	b2da      	uxtb	r2, r3
                    FilterTable[i] |= Val1 +
    fb26:	9b09      	ldr	r3, [sp, #36]	; 0x24
    fb28:	441a      	add	r2, r3
    fb2a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    fb2c:	009b      	lsls	r3, r3, #2
    fb2e:	9806      	ldr	r0, [sp, #24]
    fb30:	4403      	add	r3, r0
    fb32:	430a      	orrs	r2, r1
    fb34:	601a      	str	r2, [r3, #0]
                                      );
                }

                j = j + 4U;
    fb36:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    fb38:	3304      	adds	r3, #4
    fb3a:	930a      	str	r3, [sp, #40]	; 0x28
            for (i = 0U; i < FLEXCAN_IP_RXFIFO_FILTER_ELEM_NUM(NumOfFilters); i++)
    fb3c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    fb3e:	3301      	adds	r3, #1
    fb40:	930b      	str	r3, [sp, #44]	; 0x2c
    fb42:	9b05      	ldr	r3, [sp, #20]
    fb44:	3301      	adds	r3, #1
    fb46:	00db      	lsls	r3, r3, #3
    fb48:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    fb4a:	429a      	cmp	r2, r3
    fb4c:	f4ff af2b 	bcc.w	f9a6 <FlexCAN_SetRxFifoFilter+0x23c>
            }
            break;
    fb50:	e00b      	b.n	fb6a <FlexCAN_SetRxFifoFilter+0x400>
        case (FLEXCAN_RX_FIFO_ID_FORMAT_D):
            /* All frames rejected.*/
            /* Start critical section: implementation depends on integrator */
            SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    fb52:	f004 fd47 	bl	145e4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            (base->MCR) =
                (((base->MCR) & ~(FLEXCAN_MCR_IDAM_MASK)) |
    fb56:	9b03      	ldr	r3, [sp, #12]
    fb58:	681b      	ldr	r3, [r3, #0]
    fb5a:	f443 7240 	orr.w	r2, r3, #768	; 0x300
            (base->MCR) =
    fb5e:	9b03      	ldr	r3, [sp, #12]
    fb60:	601a      	str	r2, [r3, #0]
                 ((((uint32)(((uint32)(FLEXCAN_RX_FIFO_ID_FORMAT_D)) << FLEXCAN_MCR_IDAM_SHIFT)) & FLEXCAN_MCR_IDAM_MASK))
                );
            /* End critical section: implementation depends on integrator */
            SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    fb62:	f004 fd6b 	bl	1463c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            break;
    fb66:	e000      	b.n	fb6a <FlexCAN_SetRxFifoFilter+0x400>
        default:
            /* Should not get here */
            break;
    fb68:	bf00      	nop
    }
}
    fb6a:	bf00      	nop
    fb6c:	b00d      	add	sp, #52	; 0x34
    fb6e:	f85d fb04 	ldr.w	pc, [sp], #4

0000fb72 <FlexCAN_ReadRxFifo>:
 * Description   : Read Rx FIFO data.
 * This function will copy MB[0] data field into user's buffer.
 *
 *END**************************************************************************/
void FlexCAN_ReadRxFifo(const FLEXCAN_Type * base, Flexcan_Ip_MsgBuffType * rxFifo)
{
    fb72:	b500      	push	{lr}
    fb74:	b08b      	sub	sp, #44	; 0x2c
    fb76:	9001      	str	r0, [sp, #4]
    fb78:	9100      	str	r1, [sp, #0]
    uint32 x;
    uint8 Index;
    const uint8 * p;
    #endif

    volatile const uint32 * flexcan_mb = (uint32 *)((Flexcan_Ip_PtrSizeType)base + (uint32)FLEXCAN_IP_FEATURE_RAM_OFFSET);
    fb7a:	9b01      	ldr	r3, [sp, #4]
    fb7c:	3380      	adds	r3, #128	; 0x80
    fb7e:	9307      	str	r3, [sp, #28]
    volatile const uint32 * flexcan_mb_id = &flexcan_mb[1];
    fb80:	9b07      	ldr	r3, [sp, #28]
    fb82:	3304      	adds	r3, #4
    fb84:	9306      	str	r3, [sp, #24]
    volatile const uint32 * flexcan_mb_data_32 = &flexcan_mb[2];
    fb86:	9b07      	ldr	r3, [sp, #28]
    fb88:	3308      	adds	r3, #8
    fb8a:	9305      	str	r3, [sp, #20]
    uint32 * msgData_32 = NULL_PTR;
    fb8c:	2300      	movs	r3, #0
    fb8e:	9304      	str	r3, [sp, #16]
    uint8 flexcan_mb_dlc_value = (uint8)(((*flexcan_mb) & FLEXCAN_IP_CS_DLC_MASK) >> 16);
    fb90:	9b07      	ldr	r3, [sp, #28]
    fb92:	681b      	ldr	r3, [r3, #0]
    fb94:	0c1b      	lsrs	r3, r3, #16
    fb96:	b2db      	uxtb	r3, r3
    fb98:	f003 030f 	and.w	r3, r3, #15
    fb9c:	f88d 300f 	strb.w	r3, [sp, #15]
    uint8 can_real_payload = FlexCAN_ComputePayloadSize(flexcan_mb_dlc_value);
    fba0:	f89d 300f 	ldrb.w	r3, [sp, #15]
    fba4:	4618      	mov	r0, r3
    fba6:	f7fe fe6c 	bl	e882 <FlexCAN_ComputePayloadSize>
    fbaa:	4603      	mov	r3, r0
    fbac:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23

    #if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
        DevAssert(rxFifo != NULL_PTR);
    #endif
    msgData_32 = (uint32 *)(rxFifo->data);
    fbb0:	9b00      	ldr	r3, [sp, #0]
    fbb2:	3308      	adds	r3, #8
    fbb4:	9304      	str	r3, [sp, #16]
       Check if the length of received data packet bigger than the maximum length accepted,
       then processing flow shall continue with the maximum length defined by configuration.
       Legacy FIFO just support in normal mode.
    */
    /* no need to check if FD enabled or not because this function just is invoked when legacy fifo enabled only ! */
    if (can_real_payload > 8U)
    fbb6:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    fbba:	2b08      	cmp	r3, #8
    fbbc:	d902      	bls.n	fbc4 <FlexCAN_ReadRxFifo+0x52>
    {
        can_real_payload = 8U;
    fbbe:	2308      	movs	r3, #8
    fbc0:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    }

    rxFifo->dataLen = can_real_payload;
    fbc4:	9b00      	ldr	r3, [sp, #0]
    fbc6:	f89d 2023 	ldrb.w	r2, [sp, #35]	; 0x23
    fbca:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
    rxFifo->cs = *flexcan_mb;
    fbce:	9b07      	ldr	r3, [sp, #28]
    fbd0:	681a      	ldr	r2, [r3, #0]
    fbd2:	9b00      	ldr	r3, [sp, #0]
    fbd4:	601a      	str	r2, [r3, #0]
    if ((rxFifo->cs & FLEXCAN_IP_CS_IDE_MASK) != 0U)
    fbd6:	9b00      	ldr	r3, [sp, #0]
    fbd8:	681b      	ldr	r3, [r3, #0]
    fbda:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
    fbde:	2b00      	cmp	r3, #0
    fbe0:	d004      	beq.n	fbec <FlexCAN_ReadRxFifo+0x7a>
    {
        rxFifo->msgId = *flexcan_mb_id;
    fbe2:	9b06      	ldr	r3, [sp, #24]
    fbe4:	681a      	ldr	r2, [r3, #0]
    fbe6:	9b00      	ldr	r3, [sp, #0]
    fbe8:	605a      	str	r2, [r3, #4]
    fbea:	e004      	b.n	fbf6 <FlexCAN_ReadRxFifo+0x84>
    }
    else
    {
        rxFifo->msgId = (*flexcan_mb_id) >> FLEXCAN_IP_ID_STD_SHIFT;
    fbec:	9b06      	ldr	r3, [sp, #24]
    fbee:	681b      	ldr	r3, [r3, #0]
    fbf0:	0c9a      	lsrs	r2, r3, #18
    fbf2:	9b00      	ldr	r3, [sp, #0]
    fbf4:	605a      	str	r2, [r3, #4]
    }
    /* Extract the IDHIT */
    rxFifo->id_hit = (uint8)base->RXFIR;
    fbf6:	9b01      	ldr	r3, [sp, #4]
    fbf8:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    fbfa:	b2da      	uxtb	r2, r3
    fbfc:	9b00      	ldr	r3, [sp, #0]
    fbfe:	f883 2049 	strb.w	r2, [r3, #73]	; 0x49
    /* Extract the Time Stamp */
    rxFifo->time_stamp = (uint32)((rxFifo->cs & FLEXCAN_IP_CS_TIME_STAMP_MASK) >> FLEXCAN_IP_CS_TIME_STAMP_SHIFT);
    fc02:	9b00      	ldr	r3, [sp, #0]
    fc04:	681b      	ldr	r3, [r3, #0]
    fc06:	b29a      	uxth	r2, r3
    fc08:	9b00      	ldr	r3, [sp, #0]
    fc0a:	64da      	str	r2, [r3, #76]	; 0x4c
            FLEXCAN_IP_SWAP_BYTES_IN_WORD(MbWord, msgData_32[DataByte >> 2U]);
        }
    }
#else  /* if (defined (CPU_S32K116) || defined (CPU_S32K118)) */
      /* Copy MB[0] data field into user's buffer */
    for (DataByte = 0U; DataByte < can_real_payload; DataByte += 4U)
    fc0c:	2300      	movs	r3, #0
    fc0e:	9309      	str	r3, [sp, #36]	; 0x24
    fc10:	e01f      	b.n	fc52 <FlexCAN_ReadRxFifo+0xe0>
    {
        MbWord = flexcan_mb_data_32[DataByte >> 2U];
    fc12:	9b09      	ldr	r3, [sp, #36]	; 0x24
    fc14:	089b      	lsrs	r3, r3, #2
    fc16:	009b      	lsls	r3, r3, #2
    fc18:	9a05      	ldr	r2, [sp, #20]
    fc1a:	4413      	add	r3, r2
    fc1c:	681b      	ldr	r3, [r3, #0]
    fc1e:	9302      	str	r3, [sp, #8]
        FLEXCAN_IP_SWAP_BYTES_IN_WORD((MbWord), (msgData_32[DataByte >> 2U]));
    fc20:	9b02      	ldr	r3, [sp, #8]
    fc22:	0e1a      	lsrs	r2, r3, #24
    fc24:	9b02      	ldr	r3, [sp, #8]
    fc26:	0a1b      	lsrs	r3, r3, #8
    fc28:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    fc2c:	431a      	orrs	r2, r3
    fc2e:	9b02      	ldr	r3, [sp, #8]
    fc30:	021b      	lsls	r3, r3, #8
    fc32:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
    fc36:	ea42 0103 	orr.w	r1, r2, r3
    fc3a:	9b02      	ldr	r3, [sp, #8]
    fc3c:	061a      	lsls	r2, r3, #24
    fc3e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    fc40:	089b      	lsrs	r3, r3, #2
    fc42:	009b      	lsls	r3, r3, #2
    fc44:	9804      	ldr	r0, [sp, #16]
    fc46:	4403      	add	r3, r0
    fc48:	430a      	orrs	r2, r1
    fc4a:	601a      	str	r2, [r3, #0]
    for (DataByte = 0U; DataByte < can_real_payload; DataByte += 4U)
    fc4c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    fc4e:	3304      	adds	r3, #4
    fc50:	9309      	str	r3, [sp, #36]	; 0x24
    fc52:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    fc56:	9a09      	ldr	r2, [sp, #36]	; 0x24
    fc58:	429a      	cmp	r2, r3
    fc5a:	d3da      	bcc.n	fc12 <FlexCAN_ReadRxFifo+0xa0>
    }
#endif /* if (defined (CPU_S32K116) || defined (CPU_S32K118)) */
}
    fc5c:	bf00      	nop
    fc5e:	bf00      	nop
    fc60:	b00b      	add	sp, #44	; 0x2c
    fc62:	f85d fb04 	ldr.w	pc, [sp], #4

0000fc66 <FlexCAN_IsMbOutOfRange>:
    const FLEXCAN_Type * pBase,
    uint8 u8MbIndex,
    boolean bIsLegacyFifoEn,
    uint32 u32MaxMbNum
)
{
    fc66:	b088      	sub	sp, #32
    fc68:	9003      	str	r0, [sp, #12]
    fc6a:	9301      	str	r3, [sp, #4]
    fc6c:	460b      	mov	r3, r1
    fc6e:	f88d 300b 	strb.w	r3, [sp, #11]
    fc72:	4613      	mov	r3, r2
    fc74:	f88d 300a 	strb.w	r3, [sp, #10]
    boolean ReturnValue = FALSE;
    fc78:	2300      	movs	r3, #0
    fc7a:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 u32NumOfFiFoElement = 0U;
    fc7e:	2300      	movs	r3, #0
    fc80:	9306      	str	r3, [sp, #24]
    uint32 u32NumOfMbOccupiedByFiFo = 0U;
    fc82:	2300      	movs	r3, #0
    fc84:	9305      	str	r3, [sp, #20]

    if (u8MbIndex >= (uint8)u32MaxMbNum)
    fc86:	9b01      	ldr	r3, [sp, #4]
    fc88:	b2db      	uxtb	r3, r3
    fc8a:	f89d 200b 	ldrb.w	r2, [sp, #11]
    fc8e:	429a      	cmp	r2, r3
    fc90:	d303      	bcc.n	fc9a <FlexCAN_IsMbOutOfRange+0x34>
    {
       ReturnValue = TRUE;
    fc92:	2301      	movs	r3, #1
    fc94:	f88d 301f 	strb.w	r3, [sp, #31]
    fc98:	e01b      	b.n	fcd2 <FlexCAN_IsMbOutOfRange+0x6c>
    }
    /* Check if RX FIFO is enabled*/
    else if (TRUE == bIsLegacyFifoEn)
    fc9a:	f89d 300a 	ldrb.w	r3, [sp, #10]
    fc9e:	2b00      	cmp	r3, #0
    fca0:	d014      	beq.n	fccc <FlexCAN_IsMbOutOfRange+0x66>
    {
        /* Get the number of RX FIFO Filters*/
        u32NumOfFiFoElement = (((pBase->CTRL2) & FLEXCAN_CTRL2_RFFN_MASK) >> FLEXCAN_CTRL2_RFFN_SHIFT);
    fca2:	9b03      	ldr	r3, [sp, #12]
    fca4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    fca6:	0e1b      	lsrs	r3, r3, #24
    fca8:	f003 030f 	and.w	r3, r3, #15
    fcac:	9306      	str	r3, [sp, #24]
        /* Get the number if MBs occupied by RX FIFO and ID filter table*/
        /* the Rx FIFO occupies the memory space originally reserved for MB0-5*/
        /* Every number of RFFN means 8 number of RX FIFO filters*/
        /* and every 4 number of RX FIFO filters occupied one MB*/
        u32NumOfMbOccupiedByFiFo = 5U + ((((u32NumOfFiFoElement) + 1U) * 8U) / 4U);
    fcae:	9b06      	ldr	r3, [sp, #24]
    fcb0:	3301      	adds	r3, #1
    fcb2:	00db      	lsls	r3, r3, #3
    fcb4:	089b      	lsrs	r3, r3, #2
    fcb6:	3305      	adds	r3, #5
    fcb8:	9305      	str	r3, [sp, #20]
        if (u8MbIndex <= u32NumOfMbOccupiedByFiFo)
    fcba:	f89d 300b 	ldrb.w	r3, [sp, #11]
    fcbe:	9a05      	ldr	r2, [sp, #20]
    fcc0:	429a      	cmp	r2, r3
    fcc2:	d306      	bcc.n	fcd2 <FlexCAN_IsMbOutOfRange+0x6c>
        {
            ReturnValue = TRUE;
    fcc4:	2301      	movs	r3, #1
    fcc6:	f88d 301f 	strb.w	r3, [sp, #31]
    fcca:	e002      	b.n	fcd2 <FlexCAN_IsMbOutOfRange+0x6c>
        }
    }
    else
    {
        ReturnValue = FALSE;
    fccc:	2300      	movs	r3, #0
    fcce:	f88d 301f 	strb.w	r3, [sp, #31]
    }

    return ReturnValue;
    fcd2:	f89d 301f 	ldrb.w	r3, [sp, #31]
}
    fcd6:	4618      	mov	r0, r3
    fcd8:	b008      	add	sp, #32
    fcda:	4770      	bx	lr

0000fcdc <FlexCAN_ConfigCtrlOptions>:
 * Description   : configure controller depending on options
 * note: should be call after FD configuration.
 *
 *END**************************************************************************/
void FlexCAN_ConfigCtrlOptions(FLEXCAN_Type * pBase, uint32 u32Options)
{
    fcdc:	b500      	push	{lr}
    fcde:	b083      	sub	sp, #12
    fce0:	9001      	str	r0, [sp, #4]
    fce2:	9100      	str	r1, [sp, #0]
#if (FLEXCAN_IP_FEATURE_SWITCHINGISOMODE == STD_ON)
    /* If the FD feature is enabled, in order to be ISO-compliant. */
    if ((u32Options & FLEXCAN_IP_ISO_U32) != 0U)
    fce4:	9b00      	ldr	r3, [sp, #0]
    fce6:	f003 0320 	and.w	r3, r3, #32
    fcea:	2b00      	cmp	r3, #0
    fcec:	d004      	beq.n	fcf8 <FlexCAN_ConfigCtrlOptions+0x1c>
    {
        FlexCAN_SetIsoCan(pBase, TRUE);
    fcee:	2101      	movs	r1, #1
    fcf0:	9801      	ldr	r0, [sp, #4]
    fcf2:	f7fe fcd8 	bl	e6a6 <FlexCAN_SetIsoCan>
    fcf6:	e003      	b.n	fd00 <FlexCAN_ConfigCtrlOptions+0x24>
    }
    else
    {
        /* This maybe don't have sense if the Deinit returns the state of registers at init values */
        FlexCAN_SetIsoCan(pBase, FALSE);
    fcf8:	2100      	movs	r1, #0
    fcfa:	9801      	ldr	r0, [sp, #4]
    fcfc:	f7fe fcd3 	bl	e6a6 <FlexCAN_SetIsoCan>
    }
#endif /*(FLEXCAN_IP_FEATURE_SWITCHINGISOMODE == STD_ON) */
    /* Set Entire Frame Arbitration Field Comparison. */
    if ((u32Options & FLEXCAN_IP_EACEN_U32) != 0U)
    fd00:	9b00      	ldr	r3, [sp, #0]
    fd02:	f003 0340 	and.w	r3, r3, #64	; 0x40
    fd06:	2b00      	cmp	r3, #0
    fd08:	d004      	beq.n	fd14 <FlexCAN_ConfigCtrlOptions+0x38>
    {
        FlexCAN_SetEntireFrameArbitrationFieldComparison(pBase, TRUE);
    fd0a:	2101      	movs	r1, #1
    fd0c:	9801      	ldr	r0, [sp, #4]
    fd0e:	f7fe fce1 	bl	e6d4 <FlexCAN_SetEntireFrameArbitrationFieldComparison>
    fd12:	e003      	b.n	fd1c <FlexCAN_ConfigCtrlOptions+0x40>
    }
    else
    {
        FlexCAN_SetEntireFrameArbitrationFieldComparison(pBase, FALSE);
    fd14:	2100      	movs	r1, #0
    fd16:	9801      	ldr	r0, [sp, #4]
    fd18:	f7fe fcdc 	bl	e6d4 <FlexCAN_SetEntireFrameArbitrationFieldComparison>
    }
#if (FLEXCAN_IP_FEATURE_PROTOCOLEXCEPTION == STD_ON)
    /* Set protocol Exception */
    if ((u32Options & FLEXCAN_IP_PROTOCOL_EXCEPTION_U32) != 0U)
    fd1c:	9b00      	ldr	r3, [sp, #0]
    fd1e:	f003 0308 	and.w	r3, r3, #8
    fd22:	2b00      	cmp	r3, #0
    fd24:	d004      	beq.n	fd30 <FlexCAN_ConfigCtrlOptions+0x54>
    {
        FlexCAN_SetProtocolException(pBase, TRUE);
    fd26:	2101      	movs	r1, #1
    fd28:	9801      	ldr	r0, [sp, #4]
    fd2a:	f7fe fcea 	bl	e702 <FlexCAN_SetProtocolException>
    fd2e:	e003      	b.n	fd38 <FlexCAN_ConfigCtrlOptions+0x5c>
    }
    else
    {
        FlexCAN_SetProtocolException(pBase, FALSE);
    fd30:	2100      	movs	r1, #0
    fd32:	9801      	ldr	r0, [sp, #4]
    fd34:	f7fe fce5 	bl	e702 <FlexCAN_SetProtocolException>
    }
#endif /* Endif  (FLEXCAN_IP_FEATURE_PROTOCOLEXCEPTION == STD_ON)  */
    /* Set CAN Bit Sampling */
    if (((u32Options & FLEXCAN_IP_THREE_SAMPLES_U32) != 0U) && (0U == (pBase->MCR & FLEXCAN_MCR_FDEN_MASK)))
    fd38:	9b00      	ldr	r3, [sp, #0]
    fd3a:	f003 0302 	and.w	r3, r3, #2
    fd3e:	2b00      	cmp	r3, #0
    fd40:	d00a      	beq.n	fd58 <FlexCAN_ConfigCtrlOptions+0x7c>
    fd42:	9b01      	ldr	r3, [sp, #4]
    fd44:	681b      	ldr	r3, [r3, #0]
    fd46:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    fd4a:	2b00      	cmp	r3, #0
    fd4c:	d104      	bne.n	fd58 <FlexCAN_ConfigCtrlOptions+0x7c>
    {
        FlexCAN_CanBitSampling(pBase, TRUE);
    fd4e:	2101      	movs	r1, #1
    fd50:	9801      	ldr	r0, [sp, #4]
    fd52:	f7fe fd31 	bl	e7b8 <FlexCAN_CanBitSampling>
    fd56:	e003      	b.n	fd60 <FlexCAN_ConfigCtrlOptions+0x84>
    }
    else
    {
        FlexCAN_CanBitSampling(pBase, FALSE);
    fd58:	2100      	movs	r1, #0
    fd5a:	9801      	ldr	r0, [sp, #4]
    fd5c:	f7fe fd2c 	bl	e7b8 <FlexCAN_CanBitSampling>
    }

    /* Set AutoBusOff Recovery */
    if ((u32Options & FLEXCAN_IP_BUSOFF_RECOVERY_U32) != 0U)
    fd60:	9b00      	ldr	r3, [sp, #0]
    fd62:	f003 0304 	and.w	r3, r3, #4
    fd66:	2b00      	cmp	r3, #0
    fd68:	d004      	beq.n	fd74 <FlexCAN_ConfigCtrlOptions+0x98>
    {
        FlexCAN_SetBusOffAutorecovery(pBase, TRUE);
    fd6a:	2101      	movs	r1, #1
    fd6c:	9801      	ldr	r0, [sp, #4]
    fd6e:	f7fe fcf6 	bl	e75e <FlexCAN_SetBusOffAutorecovery>
    fd72:	e003      	b.n	fd7c <FlexCAN_ConfigCtrlOptions+0xa0>
    }
    else
    {
        FlexCAN_SetBusOffAutorecovery(pBase, FALSE);
    fd74:	2100      	movs	r1, #0
    fd76:	9801      	ldr	r0, [sp, #4]
    fd78:	f7fe fcf1 	bl	e75e <FlexCAN_SetBusOffAutorecovery>
    }
    /* Set Remote Request Store for received of Remote Request Frames */
    if ((u32Options & FLEXCAN_IP_REM_STORE_U32) != 0U)
    fd7c:	9b00      	ldr	r3, [sp, #0]
    fd7e:	f003 0301 	and.w	r3, r3, #1
    fd82:	2b00      	cmp	r3, #0
    fd84:	d004      	beq.n	fd90 <FlexCAN_ConfigCtrlOptions+0xb4>
    {
        FlexCAN_SetRemoteReqStore(pBase, TRUE);
    fd86:	2101      	movs	r1, #1
    fd88:	9801      	ldr	r0, [sp, #4]
    fd8a:	f7fe fcd1 	bl	e730 <FlexCAN_SetRemoteReqStore>
    fd8e:	e003      	b.n	fd98 <FlexCAN_ConfigCtrlOptions+0xbc>
    }
    else
    {
        FlexCAN_SetRemoteReqStore(pBase, FALSE);
    fd90:	2100      	movs	r1, #0
    fd92:	9801      	ldr	r0, [sp, #4]
    fd94:	f7fe fccc 	bl	e730 <FlexCAN_SetRemoteReqStore>
    }
#if (FLEXCAN_IP_FEATURE_EDGEFILTER == STD_ON)
    /* Set Edge Filter */
    if ((u32Options & FLEXCAN_IP_EDGE_FILTER_U32) != 0U)
    fd98:	9b00      	ldr	r3, [sp, #0]
    fd9a:	f003 0310 	and.w	r3, r3, #16
    fd9e:	2b00      	cmp	r3, #0
    fda0:	d004      	beq.n	fdac <FlexCAN_ConfigCtrlOptions+0xd0>
    {
        FlexCAN_SetEdgeFilter(pBase, TRUE);
    fda2:	2101      	movs	r1, #1
    fda4:	9801      	ldr	r0, [sp, #4]
    fda6:	f7fe fcf0 	bl	e78a <FlexCAN_SetEdgeFilter>
    else
    {
        FlexCAN_SetEdgeFilter(pBase, FALSE);
    }
#endif /* End of (FLEXCAN_IP_FEATURE_EDGEFILTER == STD_ON)  */
}
    fdaa:	e003      	b.n	fdb4 <FlexCAN_ConfigCtrlOptions+0xd8>
        FlexCAN_SetEdgeFilter(pBase, FALSE);
    fdac:	2100      	movs	r1, #0
    fdae:	9801      	ldr	r0, [sp, #4]
    fdb0:	f7fe fceb 	bl	e78a <FlexCAN_SetEdgeFilter>
}
    fdb4:	bf00      	nop
    fdb6:	b003      	add	sp, #12
    fdb8:	f85d fb04 	ldr.w	pc, [sp], #4

0000fdbc <FlexCAN_ResetImaskBuff>:
 * Function Name : FlexCAN_ResetImaskBuff (uses in FlexCAN_Ip_Init function only)
 * Description   : Reset Imask Buffers.
 *
 *END**************************************************************************/
void FlexCAN_ResetImaskBuff(uint8 Instance)
{
    fdbc:	b084      	sub	sp, #16
    fdbe:	4603      	mov	r3, r0
    fdc0:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 ImaskCnt = 0U;
    fdc4:	2300      	movs	r3, #0
    fdc6:	f88d 300f 	strb.w	r3, [sp, #15]

    for (ImaskCnt = 0U; ImaskCnt < FLEXCAN_IP_FEATURE_MBDSR_COUNT; ImaskCnt++)
    fdca:	2300      	movs	r3, #0
    fdcc:	f88d 300f 	strb.w	r3, [sp, #15]
    fdd0:	e00d      	b.n	fdee <FlexCAN_ResetImaskBuff+0x32>
    {
        FlexCAN_Ip_au32ImaskBuff[Instance][ImaskCnt] = 0U;
    fdd2:	f89d 2007 	ldrb.w	r2, [sp, #7]
    fdd6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    fdda:	4909      	ldr	r1, [pc, #36]	; (fe00 <FlexCAN_ResetImaskBuff+0x44>)
    fddc:	4413      	add	r3, r2
    fdde:	2200      	movs	r2, #0
    fde0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    for (ImaskCnt = 0U; ImaskCnt < FLEXCAN_IP_FEATURE_MBDSR_COUNT; ImaskCnt++)
    fde4:	f89d 300f 	ldrb.w	r3, [sp, #15]
    fde8:	3301      	adds	r3, #1
    fdea:	f88d 300f 	strb.w	r3, [sp, #15]
    fdee:	f89d 300f 	ldrb.w	r3, [sp, #15]
    fdf2:	2b00      	cmp	r3, #0
    fdf4:	d0ed      	beq.n	fdd2 <FlexCAN_ResetImaskBuff+0x16>
    }
}
    fdf6:	bf00      	nop
    fdf8:	bf00      	nop
    fdfa:	b004      	add	sp, #16
    fdfc:	4770      	bx	lr
    fdfe:	bf00      	nop
    fe00:	1fff936c 	.word	0x1fff936c

0000fe04 <CAN0_ORED_IRQHandler>:

#else

/* Implementation of CAN0 handler named in startup code for processing of Tx\Rx Warning and Bus Off reporting. */
ISR(CAN0_ORED_IRQHandler)
{
    fe04:	b508      	push	{r3, lr}
    FlexCAN_BusOff_IRQHandler(0U);
    fe06:	2000      	movs	r0, #0
    fe08:	f7fd fb2a 	bl	d460 <FlexCAN_BusOff_IRQHandler>
    EXIT_INTERRUPT();
    fe0c:	f3bf 8f4f 	dsb	sy
}
    fe10:	bf00      	nop
    fe12:	bd08      	pop	{r3, pc}

0000fe14 <CAN0_Error_IRQHandler>:

/* Implementation of CAN0 handler named in startup code for processing of Errors reporting. */
ISR(CAN0_Error_IRQHandler)
{
    fe14:	b508      	push	{r3, lr}
    FlexCAN_Error_IRQHandler(0U);
    fe16:	2000      	movs	r0, #0
    fe18:	f7fd fac2 	bl	d3a0 <FlexCAN_Error_IRQHandler>
    EXIT_INTERRUPT();
    fe1c:	f3bf 8f4f 	dsb	sy
}
    fe20:	bf00      	nop
    fe22:	bd08      	pop	{r3, pc}

0000fe24 <CAN0_ORED_0_15_MB_IRQHandler>:
}
#endif
/* Implementation of CAN0 IRQ handler for interrupts indicating a successful
transmission or reception for Message Buffers 0-15. */
ISR(CAN0_ORED_0_15_MB_IRQHandler)
{
    fe24:	b508      	push	{r3, lr}
    FlexCAN_IRQHandler(0U, 0U, 15U);
    fe26:	220f      	movs	r2, #15
    fe28:	2100      	movs	r1, #0
    fe2a:	2000      	movs	r0, #0
    fe2c:	f7fd f9dc 	bl	d1e8 <FlexCAN_IRQHandler>
    EXIT_INTERRUPT();
    fe30:	f3bf 8f4f 	dsb	sy
}
    fe34:	bf00      	nop
    fe36:	bd08      	pop	{r3, pc}

0000fe38 <CAN0_ORED_16_31_MB_IRQHandler>:

/* Implementation of CAN0 IRQ handler for interrupts indicating a successful
transmission or reception for Message Buffers 16-31. */
ISR(CAN0_ORED_16_31_MB_IRQHandler)
{
    fe38:	b508      	push	{r3, lr}
    FlexCAN_IRQHandler(0U, 16U, 31U);
    fe3a:	221f      	movs	r2, #31
    fe3c:	2110      	movs	r1, #16
    fe3e:	2000      	movs	r0, #0
    fe40:	f7fd f9d2 	bl	d1e8 <FlexCAN_IRQHandler>
    EXIT_INTERRUPT();
    fe44:	f3bf 8f4f 	dsb	sy
}
    fe48:	bf00      	nop
    fe4a:	bd08      	pop	{r3, pc}

0000fe4c <CAN1_ORED_IRQHandler>:
#endif /* (defined(S32K142W) || defined(S32K144W) || defined(S32M243) || defined(S32M244)) */

#if (FLEXCAN_INSTANCE_COUNT > 1U)
/* Implementation of CAN1 handler named in startup code for processing of Tx\Rx Warning and Bus Off reporting. */
ISR(CAN1_ORED_IRQHandler)
{
    fe4c:	b508      	push	{r3, lr}
    FlexCAN_BusOff_IRQHandler(1U);
    fe4e:	2001      	movs	r0, #1
    fe50:	f7fd fb06 	bl	d460 <FlexCAN_BusOff_IRQHandler>
    EXIT_INTERRUPT();
    fe54:	f3bf 8f4f 	dsb	sy
}
    fe58:	bf00      	nop
    fe5a:	bd08      	pop	{r3, pc}

0000fe5c <CAN1_Error_IRQHandler>:

/* Implementation of CAN1 handler named in startup code for processing of Errors reporting. */
ISR(CAN1_Error_IRQHandler)
{
    fe5c:	b508      	push	{r3, lr}
    FlexCAN_Error_IRQHandler(1U);
    fe5e:	2001      	movs	r0, #1
    fe60:	f7fd fa9e 	bl	d3a0 <FlexCAN_Error_IRQHandler>
    EXIT_INTERRUPT();
    fe64:	f3bf 8f4f 	dsb	sy
}
    fe68:	bf00      	nop
    fe6a:	bd08      	pop	{r3, pc}

0000fe6c <CAN1_ORED_0_15_MB_IRQHandler>:

/* Implementation of CAN1 IRQ handler for interrupts indicating a successful
transmission or reception for Message Buffers 0-15. */
ISR(CAN1_ORED_0_15_MB_IRQHandler)
{
    fe6c:	b508      	push	{r3, lr}
    FlexCAN_IRQHandler(1U, 0U, 15U);
    fe6e:	220f      	movs	r2, #15
    fe70:	2100      	movs	r1, #0
    fe72:	2001      	movs	r0, #1
    fe74:	f7fd f9b8 	bl	d1e8 <FlexCAN_IRQHandler>
    EXIT_INTERRUPT();
    fe78:	f3bf 8f4f 	dsb	sy
}
    fe7c:	bf00      	nop
    fe7e:	bd08      	pop	{r3, pc}

0000fe80 <CAN1_ORED_16_31_MB_IRQHandler>:

/* Implementation of CAN1 IRQ handler for interrupts indicating a successful
transmission or reception for Message Buffers 16-31. */
ISR(CAN1_ORED_16_31_MB_IRQHandler)
{
    fe80:	b508      	push	{r3, lr}
    FlexCAN_IRQHandler(1U, 16U, 31U);
    fe82:	221f      	movs	r2, #31
    fe84:	2110      	movs	r1, #16
    fe86:	2001      	movs	r0, #1
    fe88:	f7fd f9ae 	bl	d1e8 <FlexCAN_IRQHandler>
    EXIT_INTERRUPT();
    fe8c:	f3bf 8f4f 	dsb	sy
}
    fe90:	bf00      	nop
    fe92:	bd08      	pop	{r3, pc}

0000fe94 <CAN2_ORED_IRQHandler>:
#endif /* (FLEXCAN_INSTANCE_COUNT > 1U) */

#if (FLEXCAN_INSTANCE_COUNT > 2U)
/* Implementation of CAN2 handler named in startup code for processing of Errors and Bus Off reporting. */
ISR(CAN2_ORED_IRQHandler)
{
    fe94:	b508      	push	{r3, lr}
    FlexCAN_BusOff_IRQHandler(2U);
    fe96:	2002      	movs	r0, #2
    fe98:	f7fd fae2 	bl	d460 <FlexCAN_BusOff_IRQHandler>
    EXIT_INTERRUPT();
    fe9c:	f3bf 8f4f 	dsb	sy
}
    fea0:	bf00      	nop
    fea2:	bd08      	pop	{r3, pc}

0000fea4 <CAN2_Error_IRQHandler>:

/* Implementation of CAN1 handler named in startup code for processing of Errors reporting. */
ISR(CAN2_Error_IRQHandler)
{
    fea4:	b508      	push	{r3, lr}
    FlexCAN_Error_IRQHandler(2U);
    fea6:	2002      	movs	r0, #2
    fea8:	f7fd fa7a 	bl	d3a0 <FlexCAN_Error_IRQHandler>
    EXIT_INTERRUPT();
    feac:	f3bf 8f4f 	dsb	sy
}
    feb0:	bf00      	nop
    feb2:	bd08      	pop	{r3, pc}

0000feb4 <CAN2_ORED_0_15_MB_IRQHandler>:

/* Implementation of CAN2 IRQ handler for interrupts indicating a successful
transmission or reception for Message Buffers 0-15. */
ISR(CAN2_ORED_0_15_MB_IRQHandler)
{
    feb4:	b508      	push	{r3, lr}
    FlexCAN_IRQHandler(2U, 0U, 15U);
    feb6:	220f      	movs	r2, #15
    feb8:	2100      	movs	r1, #0
    feba:	2002      	movs	r0, #2
    febc:	f7fd f994 	bl	d1e8 <FlexCAN_IRQHandler>
    EXIT_INTERRUPT();
    fec0:	f3bf 8f4f 	dsb	sy
}
    fec4:	bf00      	nop
    fec6:	bd08      	pop	{r3, pc}

0000fec8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_00(void)
{
    fec8:	b500      	push	{lr}
    feca:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    fecc:	f7f0 ff26 	bl	d1c <Sys_GetCoreID>
    fed0:	4603      	mov	r3, r0
    fed2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_00[u32CoreId])
    fed4:	4a10      	ldr	r2, [pc, #64]	; (ff18 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_00+0x50>)
    fed6:	9b01      	ldr	r3, [sp, #4]
    fed8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fedc:	2b00      	cmp	r3, #0
    fede:	d10d      	bne.n	fefc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    fee0:	f7f0 fd5a 	bl	998 <Adc_schm_read_msr>
    fee4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    fee6:	9b00      	ldr	r3, [sp, #0]
    fee8:	f003 0301 	and.w	r3, r3, #1
    feec:	2b00      	cmp	r3, #0
    feee:	d100      	bne.n	fef2 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    fef0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_00[u32CoreId] = msr;
    fef2:	490a      	ldr	r1, [pc, #40]	; (ff1c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_00+0x54>)
    fef4:	9b01      	ldr	r3, [sp, #4]
    fef6:	9a00      	ldr	r2, [sp, #0]
    fef8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_00[u32CoreId]++;
    fefc:	4a06      	ldr	r2, [pc, #24]	; (ff18 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_00+0x50>)
    fefe:	9b01      	ldr	r3, [sp, #4]
    ff00:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ff04:	1c5a      	adds	r2, r3, #1
    ff06:	4904      	ldr	r1, [pc, #16]	; (ff18 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_00+0x50>)
    ff08:	9b01      	ldr	r3, [sp, #4]
    ff0a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    ff0e:	bf00      	nop
    ff10:	b003      	add	sp, #12
    ff12:	f85d fb04 	ldr.w	pc, [sp], #4
    ff16:	bf00      	nop
    ff18:	1fff937c 	.word	0x1fff937c
    ff1c:	1fff9378 	.word	0x1fff9378

0000ff20 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_00>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_00(void)
{
    ff20:	b500      	push	{lr}
    ff22:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ff24:	f7f0 fefa 	bl	d1c <Sys_GetCoreID>
    ff28:	4603      	mov	r3, r0
    ff2a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_00[u32CoreId]--;
    ff2c:	4a0d      	ldr	r2, [pc, #52]	; (ff64 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_00+0x44>)
    ff2e:	9b01      	ldr	r3, [sp, #4]
    ff30:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ff34:	1e5a      	subs	r2, r3, #1
    ff36:	490b      	ldr	r1, [pc, #44]	; (ff64 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_00+0x44>)
    ff38:	9b01      	ldr	r3, [sp, #4]
    ff3a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
    ff3e:	4a0a      	ldr	r2, [pc, #40]	; (ff68 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_00+0x48>)
    ff40:	9b01      	ldr	r3, [sp, #4]
    ff42:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ff46:	f003 0301 	and.w	r3, r3, #1
    ff4a:	2b00      	cmp	r3, #0
    ff4c:	d106      	bne.n	ff5c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_00+0x3c>
    ff4e:	4a05      	ldr	r2, [pc, #20]	; (ff64 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_00+0x44>)
    ff50:	9b01      	ldr	r3, [sp, #4]
    ff52:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ff56:	2b00      	cmp	r3, #0
    ff58:	d100      	bne.n	ff5c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    ff5a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    ff5c:	bf00      	nop
    ff5e:	b003      	add	sp, #12
    ff60:	f85d fb04 	ldr.w	pc, [sp], #4
    ff64:	1fff937c 	.word	0x1fff937c
    ff68:	1fff9378 	.word	0x1fff9378

0000ff6c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_01>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_01(void)
{
    ff6c:	b500      	push	{lr}
    ff6e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ff70:	f7f0 fed4 	bl	d1c <Sys_GetCoreID>
    ff74:	4603      	mov	r3, r0
    ff76:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_01[u32CoreId])
    ff78:	4a10      	ldr	r2, [pc, #64]	; (ffbc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_01+0x50>)
    ff7a:	9b01      	ldr	r3, [sp, #4]
    ff7c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ff80:	2b00      	cmp	r3, #0
    ff82:	d10d      	bne.n	ffa0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    ff84:	f7f0 fd08 	bl	998 <Adc_schm_read_msr>
    ff88:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    ff8a:	9b00      	ldr	r3, [sp, #0]
    ff8c:	f003 0301 	and.w	r3, r3, #1
    ff90:	2b00      	cmp	r3, #0
    ff92:	d100      	bne.n	ff96 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    ff94:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_01[u32CoreId] = msr;
    ff96:	490a      	ldr	r1, [pc, #40]	; (ffc0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_01+0x54>)
    ff98:	9b01      	ldr	r3, [sp, #4]
    ff9a:	9a00      	ldr	r2, [sp, #0]
    ff9c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_01[u32CoreId]++;
    ffa0:	4a06      	ldr	r2, [pc, #24]	; (ffbc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_01+0x50>)
    ffa2:	9b01      	ldr	r3, [sp, #4]
    ffa4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ffa8:	1c5a      	adds	r2, r3, #1
    ffaa:	4904      	ldr	r1, [pc, #16]	; (ffbc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_01+0x50>)
    ffac:	9b01      	ldr	r3, [sp, #4]
    ffae:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    ffb2:	bf00      	nop
    ffb4:	b003      	add	sp, #12
    ffb6:	f85d fb04 	ldr.w	pc, [sp], #4
    ffba:	bf00      	nop
    ffbc:	1fff9384 	.word	0x1fff9384
    ffc0:	1fff9380 	.word	0x1fff9380

0000ffc4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_01>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_01(void)
{
    ffc4:	b500      	push	{lr}
    ffc6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ffc8:	f7f0 fea8 	bl	d1c <Sys_GetCoreID>
    ffcc:	4603      	mov	r3, r0
    ffce:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_01[u32CoreId]--;
    ffd0:	4a0d      	ldr	r2, [pc, #52]	; (10008 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_01+0x44>)
    ffd2:	9b01      	ldr	r3, [sp, #4]
    ffd4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ffd8:	1e5a      	subs	r2, r3, #1
    ffda:	490b      	ldr	r1, [pc, #44]	; (10008 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_01+0x44>)
    ffdc:	9b01      	ldr	r3, [sp, #4]
    ffde:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
    ffe2:	4a0a      	ldr	r2, [pc, #40]	; (1000c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_01+0x48>)
    ffe4:	9b01      	ldr	r3, [sp, #4]
    ffe6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ffea:	f003 0301 	and.w	r3, r3, #1
    ffee:	2b00      	cmp	r3, #0
    fff0:	d106      	bne.n	10000 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_01+0x3c>
    fff2:	4a05      	ldr	r2, [pc, #20]	; (10008 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_01+0x44>)
    fff4:	9b01      	ldr	r3, [sp, #4]
    fff6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fffa:	2b00      	cmp	r3, #0
    fffc:	d100      	bne.n	10000 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    fffe:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10000:	bf00      	nop
   10002:	b003      	add	sp, #12
   10004:	f85d fb04 	ldr.w	pc, [sp], #4
   10008:	1fff9384 	.word	0x1fff9384
   1000c:	1fff9380 	.word	0x1fff9380

00010010 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_02>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_02(void)
{
   10010:	b500      	push	{lr}
   10012:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10014:	f7f0 fe82 	bl	d1c <Sys_GetCoreID>
   10018:	4603      	mov	r3, r0
   1001a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_02[u32CoreId])
   1001c:	4a10      	ldr	r2, [pc, #64]	; (10060 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_02+0x50>)
   1001e:	9b01      	ldr	r3, [sp, #4]
   10020:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10024:	2b00      	cmp	r3, #0
   10026:	d10d      	bne.n	10044 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_02+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10028:	f7f0 fcb6 	bl	998 <Adc_schm_read_msr>
   1002c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1002e:	9b00      	ldr	r3, [sp, #0]
   10030:	f003 0301 	and.w	r3, r3, #1
   10034:	2b00      	cmp	r3, #0
   10036:	d100      	bne.n	1003a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_02+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10038:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_02[u32CoreId] = msr;
   1003a:	490a      	ldr	r1, [pc, #40]	; (10064 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_02+0x54>)
   1003c:	9b01      	ldr	r3, [sp, #4]
   1003e:	9a00      	ldr	r2, [sp, #0]
   10040:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_02[u32CoreId]++;
   10044:	4a06      	ldr	r2, [pc, #24]	; (10060 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_02+0x50>)
   10046:	9b01      	ldr	r3, [sp, #4]
   10048:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1004c:	1c5a      	adds	r2, r3, #1
   1004e:	4904      	ldr	r1, [pc, #16]	; (10060 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_02+0x50>)
   10050:	9b01      	ldr	r3, [sp, #4]
   10052:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10056:	bf00      	nop
   10058:	b003      	add	sp, #12
   1005a:	f85d fb04 	ldr.w	pc, [sp], #4
   1005e:	bf00      	nop
   10060:	1fff938c 	.word	0x1fff938c
   10064:	1fff9388 	.word	0x1fff9388

00010068 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_02>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_02(void)
{
   10068:	b500      	push	{lr}
   1006a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1006c:	f7f0 fe56 	bl	d1c <Sys_GetCoreID>
   10070:	4603      	mov	r3, r0
   10072:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_02[u32CoreId]--;
   10074:	4a0d      	ldr	r2, [pc, #52]	; (100ac <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_02+0x44>)
   10076:	9b01      	ldr	r3, [sp, #4]
   10078:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1007c:	1e5a      	subs	r2, r3, #1
   1007e:	490b      	ldr	r1, [pc, #44]	; (100ac <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_02+0x44>)
   10080:	9b01      	ldr	r3, [sp, #4]
   10082:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_02[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_02[u32CoreId]))         /*if interrupts were enabled*/
   10086:	4a0a      	ldr	r2, [pc, #40]	; (100b0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_02+0x48>)
   10088:	9b01      	ldr	r3, [sp, #4]
   1008a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1008e:	f003 0301 	and.w	r3, r3, #1
   10092:	2b00      	cmp	r3, #0
   10094:	d106      	bne.n	100a4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_02+0x3c>
   10096:	4a05      	ldr	r2, [pc, #20]	; (100ac <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_02+0x44>)
   10098:	9b01      	ldr	r3, [sp, #4]
   1009a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1009e:	2b00      	cmp	r3, #0
   100a0:	d100      	bne.n	100a4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_02+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   100a2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   100a4:	bf00      	nop
   100a6:	b003      	add	sp, #12
   100a8:	f85d fb04 	ldr.w	pc, [sp], #4
   100ac:	1fff938c 	.word	0x1fff938c
   100b0:	1fff9388 	.word	0x1fff9388

000100b4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_03>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_03(void)
{
   100b4:	b500      	push	{lr}
   100b6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   100b8:	f7f0 fe30 	bl	d1c <Sys_GetCoreID>
   100bc:	4603      	mov	r3, r0
   100be:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_03[u32CoreId])
   100c0:	4a10      	ldr	r2, [pc, #64]	; (10104 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_03+0x50>)
   100c2:	9b01      	ldr	r3, [sp, #4]
   100c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   100c8:	2b00      	cmp	r3, #0
   100ca:	d10d      	bne.n	100e8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_03+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   100cc:	f7f0 fc64 	bl	998 <Adc_schm_read_msr>
   100d0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   100d2:	9b00      	ldr	r3, [sp, #0]
   100d4:	f003 0301 	and.w	r3, r3, #1
   100d8:	2b00      	cmp	r3, #0
   100da:	d100      	bne.n	100de <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_03+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   100dc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_03[u32CoreId] = msr;
   100de:	490a      	ldr	r1, [pc, #40]	; (10108 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_03+0x54>)
   100e0:	9b01      	ldr	r3, [sp, #4]
   100e2:	9a00      	ldr	r2, [sp, #0]
   100e4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_03[u32CoreId]++;
   100e8:	4a06      	ldr	r2, [pc, #24]	; (10104 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_03+0x50>)
   100ea:	9b01      	ldr	r3, [sp, #4]
   100ec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   100f0:	1c5a      	adds	r2, r3, #1
   100f2:	4904      	ldr	r1, [pc, #16]	; (10104 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_03+0x50>)
   100f4:	9b01      	ldr	r3, [sp, #4]
   100f6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   100fa:	bf00      	nop
   100fc:	b003      	add	sp, #12
   100fe:	f85d fb04 	ldr.w	pc, [sp], #4
   10102:	bf00      	nop
   10104:	1fff9394 	.word	0x1fff9394
   10108:	1fff9390 	.word	0x1fff9390

0001010c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_03>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_03(void)
{
   1010c:	b500      	push	{lr}
   1010e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10110:	f7f0 fe04 	bl	d1c <Sys_GetCoreID>
   10114:	4603      	mov	r3, r0
   10116:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_03[u32CoreId]--;
   10118:	4a0d      	ldr	r2, [pc, #52]	; (10150 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_03+0x44>)
   1011a:	9b01      	ldr	r3, [sp, #4]
   1011c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10120:	1e5a      	subs	r2, r3, #1
   10122:	490b      	ldr	r1, [pc, #44]	; (10150 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_03+0x44>)
   10124:	9b01      	ldr	r3, [sp, #4]
   10126:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_03[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_03[u32CoreId]))         /*if interrupts were enabled*/
   1012a:	4a0a      	ldr	r2, [pc, #40]	; (10154 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_03+0x48>)
   1012c:	9b01      	ldr	r3, [sp, #4]
   1012e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10132:	f003 0301 	and.w	r3, r3, #1
   10136:	2b00      	cmp	r3, #0
   10138:	d106      	bne.n	10148 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_03+0x3c>
   1013a:	4a05      	ldr	r2, [pc, #20]	; (10150 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_03+0x44>)
   1013c:	9b01      	ldr	r3, [sp, #4]
   1013e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10142:	2b00      	cmp	r3, #0
   10144:	d100      	bne.n	10148 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_03+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   10146:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10148:	bf00      	nop
   1014a:	b003      	add	sp, #12
   1014c:	f85d fb04 	ldr.w	pc, [sp], #4
   10150:	1fff9394 	.word	0x1fff9394
   10154:	1fff9390 	.word	0x1fff9390

00010158 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_04>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_04(void)
{
   10158:	b500      	push	{lr}
   1015a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1015c:	f7f0 fdde 	bl	d1c <Sys_GetCoreID>
   10160:	4603      	mov	r3, r0
   10162:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_04[u32CoreId])
   10164:	4a10      	ldr	r2, [pc, #64]	; (101a8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_04+0x50>)
   10166:	9b01      	ldr	r3, [sp, #4]
   10168:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1016c:	2b00      	cmp	r3, #0
   1016e:	d10d      	bne.n	1018c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_04+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10170:	f7f0 fc12 	bl	998 <Adc_schm_read_msr>
   10174:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   10176:	9b00      	ldr	r3, [sp, #0]
   10178:	f003 0301 	and.w	r3, r3, #1
   1017c:	2b00      	cmp	r3, #0
   1017e:	d100      	bne.n	10182 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_04+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10180:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_04[u32CoreId] = msr;
   10182:	490a      	ldr	r1, [pc, #40]	; (101ac <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_04+0x54>)
   10184:	9b01      	ldr	r3, [sp, #4]
   10186:	9a00      	ldr	r2, [sp, #0]
   10188:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_04[u32CoreId]++;
   1018c:	4a06      	ldr	r2, [pc, #24]	; (101a8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_04+0x50>)
   1018e:	9b01      	ldr	r3, [sp, #4]
   10190:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10194:	1c5a      	adds	r2, r3, #1
   10196:	4904      	ldr	r1, [pc, #16]	; (101a8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_04+0x50>)
   10198:	9b01      	ldr	r3, [sp, #4]
   1019a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1019e:	bf00      	nop
   101a0:	b003      	add	sp, #12
   101a2:	f85d fb04 	ldr.w	pc, [sp], #4
   101a6:	bf00      	nop
   101a8:	1fff939c 	.word	0x1fff939c
   101ac:	1fff9398 	.word	0x1fff9398

000101b0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_04>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_04(void)
{
   101b0:	b500      	push	{lr}
   101b2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   101b4:	f7f0 fdb2 	bl	d1c <Sys_GetCoreID>
   101b8:	4603      	mov	r3, r0
   101ba:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_04[u32CoreId]--;
   101bc:	4a0d      	ldr	r2, [pc, #52]	; (101f4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_04+0x44>)
   101be:	9b01      	ldr	r3, [sp, #4]
   101c0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   101c4:	1e5a      	subs	r2, r3, #1
   101c6:	490b      	ldr	r1, [pc, #44]	; (101f4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_04+0x44>)
   101c8:	9b01      	ldr	r3, [sp, #4]
   101ca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_04[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_04[u32CoreId]))         /*if interrupts were enabled*/
   101ce:	4a0a      	ldr	r2, [pc, #40]	; (101f8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_04+0x48>)
   101d0:	9b01      	ldr	r3, [sp, #4]
   101d2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   101d6:	f003 0301 	and.w	r3, r3, #1
   101da:	2b00      	cmp	r3, #0
   101dc:	d106      	bne.n	101ec <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_04+0x3c>
   101de:	4a05      	ldr	r2, [pc, #20]	; (101f4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_04+0x44>)
   101e0:	9b01      	ldr	r3, [sp, #4]
   101e2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   101e6:	2b00      	cmp	r3, #0
   101e8:	d100      	bne.n	101ec <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_04+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   101ea:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   101ec:	bf00      	nop
   101ee:	b003      	add	sp, #12
   101f0:	f85d fb04 	ldr.w	pc, [sp], #4
   101f4:	1fff939c 	.word	0x1fff939c
   101f8:	1fff9398 	.word	0x1fff9398

000101fc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_05>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_05(void)
{
   101fc:	b500      	push	{lr}
   101fe:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10200:	f7f0 fd8c 	bl	d1c <Sys_GetCoreID>
   10204:	4603      	mov	r3, r0
   10206:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_05[u32CoreId])
   10208:	4a10      	ldr	r2, [pc, #64]	; (1024c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_05+0x50>)
   1020a:	9b01      	ldr	r3, [sp, #4]
   1020c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10210:	2b00      	cmp	r3, #0
   10212:	d10d      	bne.n	10230 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_05+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10214:	f7f0 fbc0 	bl	998 <Adc_schm_read_msr>
   10218:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1021a:	9b00      	ldr	r3, [sp, #0]
   1021c:	f003 0301 	and.w	r3, r3, #1
   10220:	2b00      	cmp	r3, #0
   10222:	d100      	bne.n	10226 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_05+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10224:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_05[u32CoreId] = msr;
   10226:	490a      	ldr	r1, [pc, #40]	; (10250 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_05+0x54>)
   10228:	9b01      	ldr	r3, [sp, #4]
   1022a:	9a00      	ldr	r2, [sp, #0]
   1022c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_05[u32CoreId]++;
   10230:	4a06      	ldr	r2, [pc, #24]	; (1024c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_05+0x50>)
   10232:	9b01      	ldr	r3, [sp, #4]
   10234:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10238:	1c5a      	adds	r2, r3, #1
   1023a:	4904      	ldr	r1, [pc, #16]	; (1024c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_05+0x50>)
   1023c:	9b01      	ldr	r3, [sp, #4]
   1023e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10242:	bf00      	nop
   10244:	b003      	add	sp, #12
   10246:	f85d fb04 	ldr.w	pc, [sp], #4
   1024a:	bf00      	nop
   1024c:	1fff93a4 	.word	0x1fff93a4
   10250:	1fff93a0 	.word	0x1fff93a0

00010254 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_05>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_05(void)
{
   10254:	b500      	push	{lr}
   10256:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10258:	f7f0 fd60 	bl	d1c <Sys_GetCoreID>
   1025c:	4603      	mov	r3, r0
   1025e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_05[u32CoreId]--;
   10260:	4a0d      	ldr	r2, [pc, #52]	; (10298 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_05+0x44>)
   10262:	9b01      	ldr	r3, [sp, #4]
   10264:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10268:	1e5a      	subs	r2, r3, #1
   1026a:	490b      	ldr	r1, [pc, #44]	; (10298 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_05+0x44>)
   1026c:	9b01      	ldr	r3, [sp, #4]
   1026e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_05[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_05[u32CoreId]))         /*if interrupts were enabled*/
   10272:	4a0a      	ldr	r2, [pc, #40]	; (1029c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_05+0x48>)
   10274:	9b01      	ldr	r3, [sp, #4]
   10276:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1027a:	f003 0301 	and.w	r3, r3, #1
   1027e:	2b00      	cmp	r3, #0
   10280:	d106      	bne.n	10290 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_05+0x3c>
   10282:	4a05      	ldr	r2, [pc, #20]	; (10298 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_05+0x44>)
   10284:	9b01      	ldr	r3, [sp, #4]
   10286:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1028a:	2b00      	cmp	r3, #0
   1028c:	d100      	bne.n	10290 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_05+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1028e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10290:	bf00      	nop
   10292:	b003      	add	sp, #12
   10294:	f85d fb04 	ldr.w	pc, [sp], #4
   10298:	1fff93a4 	.word	0x1fff93a4
   1029c:	1fff93a0 	.word	0x1fff93a0

000102a0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_10>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_10(void)
{
   102a0:	b500      	push	{lr}
   102a2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   102a4:	f7f0 fd3a 	bl	d1c <Sys_GetCoreID>
   102a8:	4603      	mov	r3, r0
   102aa:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_10[u32CoreId])
   102ac:	4a10      	ldr	r2, [pc, #64]	; (102f0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_10+0x50>)
   102ae:	9b01      	ldr	r3, [sp, #4]
   102b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   102b4:	2b00      	cmp	r3, #0
   102b6:	d10d      	bne.n	102d4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_10+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   102b8:	f7f0 fb6e 	bl	998 <Adc_schm_read_msr>
   102bc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   102be:	9b00      	ldr	r3, [sp, #0]
   102c0:	f003 0301 	and.w	r3, r3, #1
   102c4:	2b00      	cmp	r3, #0
   102c6:	d100      	bne.n	102ca <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_10+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   102c8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_10[u32CoreId] = msr;
   102ca:	490a      	ldr	r1, [pc, #40]	; (102f4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_10+0x54>)
   102cc:	9b01      	ldr	r3, [sp, #4]
   102ce:	9a00      	ldr	r2, [sp, #0]
   102d0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_10[u32CoreId]++;
   102d4:	4a06      	ldr	r2, [pc, #24]	; (102f0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_10+0x50>)
   102d6:	9b01      	ldr	r3, [sp, #4]
   102d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   102dc:	1c5a      	adds	r2, r3, #1
   102de:	4904      	ldr	r1, [pc, #16]	; (102f0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_10+0x50>)
   102e0:	9b01      	ldr	r3, [sp, #4]
   102e2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   102e6:	bf00      	nop
   102e8:	b003      	add	sp, #12
   102ea:	f85d fb04 	ldr.w	pc, [sp], #4
   102ee:	bf00      	nop
   102f0:	1fff93ac 	.word	0x1fff93ac
   102f4:	1fff93a8 	.word	0x1fff93a8

000102f8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_10>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_10(void)
{
   102f8:	b500      	push	{lr}
   102fa:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   102fc:	f7f0 fd0e 	bl	d1c <Sys_GetCoreID>
   10300:	4603      	mov	r3, r0
   10302:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_10[u32CoreId]--;
   10304:	4a0d      	ldr	r2, [pc, #52]	; (1033c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_10+0x44>)
   10306:	9b01      	ldr	r3, [sp, #4]
   10308:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1030c:	1e5a      	subs	r2, r3, #1
   1030e:	490b      	ldr	r1, [pc, #44]	; (1033c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_10+0x44>)
   10310:	9b01      	ldr	r3, [sp, #4]
   10312:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_10[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_10[u32CoreId]))         /*if interrupts were enabled*/
   10316:	4a0a      	ldr	r2, [pc, #40]	; (10340 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_10+0x48>)
   10318:	9b01      	ldr	r3, [sp, #4]
   1031a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1031e:	f003 0301 	and.w	r3, r3, #1
   10322:	2b00      	cmp	r3, #0
   10324:	d106      	bne.n	10334 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_10+0x3c>
   10326:	4a05      	ldr	r2, [pc, #20]	; (1033c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_10+0x44>)
   10328:	9b01      	ldr	r3, [sp, #4]
   1032a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1032e:	2b00      	cmp	r3, #0
   10330:	d100      	bne.n	10334 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_10+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   10332:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10334:	bf00      	nop
   10336:	b003      	add	sp, #12
   10338:	f85d fb04 	ldr.w	pc, [sp], #4
   1033c:	1fff93ac 	.word	0x1fff93ac
   10340:	1fff93a8 	.word	0x1fff93a8

00010344 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_100>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_100(void)
{
   10344:	b500      	push	{lr}
   10346:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10348:	f7f0 fce8 	bl	d1c <Sys_GetCoreID>
   1034c:	4603      	mov	r3, r0
   1034e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_100[u32CoreId])
   10350:	4a10      	ldr	r2, [pc, #64]	; (10394 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_100+0x50>)
   10352:	9b01      	ldr	r3, [sp, #4]
   10354:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10358:	2b00      	cmp	r3, #0
   1035a:	d10d      	bne.n	10378 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_100+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   1035c:	f7f0 fb1c 	bl	998 <Adc_schm_read_msr>
   10360:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   10362:	9b00      	ldr	r3, [sp, #0]
   10364:	f003 0301 	and.w	r3, r3, #1
   10368:	2b00      	cmp	r3, #0
   1036a:	d100      	bne.n	1036e <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_100+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   1036c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_100[u32CoreId] = msr;
   1036e:	490a      	ldr	r1, [pc, #40]	; (10398 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_100+0x54>)
   10370:	9b01      	ldr	r3, [sp, #4]
   10372:	9a00      	ldr	r2, [sp, #0]
   10374:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_100[u32CoreId]++;
   10378:	4a06      	ldr	r2, [pc, #24]	; (10394 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_100+0x50>)
   1037a:	9b01      	ldr	r3, [sp, #4]
   1037c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10380:	1c5a      	adds	r2, r3, #1
   10382:	4904      	ldr	r1, [pc, #16]	; (10394 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_100+0x50>)
   10384:	9b01      	ldr	r3, [sp, #4]
   10386:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1038a:	bf00      	nop
   1038c:	b003      	add	sp, #12
   1038e:	f85d fb04 	ldr.w	pc, [sp], #4
   10392:	bf00      	nop
   10394:	1fff93b4 	.word	0x1fff93b4
   10398:	1fff93b0 	.word	0x1fff93b0

0001039c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_100>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_100(void)
{
   1039c:	b500      	push	{lr}
   1039e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   103a0:	f7f0 fcbc 	bl	d1c <Sys_GetCoreID>
   103a4:	4603      	mov	r3, r0
   103a6:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_100[u32CoreId]--;
   103a8:	4a0d      	ldr	r2, [pc, #52]	; (103e0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_100+0x44>)
   103aa:	9b01      	ldr	r3, [sp, #4]
   103ac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   103b0:	1e5a      	subs	r2, r3, #1
   103b2:	490b      	ldr	r1, [pc, #44]	; (103e0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_100+0x44>)
   103b4:	9b01      	ldr	r3, [sp, #4]
   103b6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_100[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_100[u32CoreId]))         /*if interrupts were enabled*/
   103ba:	4a0a      	ldr	r2, [pc, #40]	; (103e4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_100+0x48>)
   103bc:	9b01      	ldr	r3, [sp, #4]
   103be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   103c2:	f003 0301 	and.w	r3, r3, #1
   103c6:	2b00      	cmp	r3, #0
   103c8:	d106      	bne.n	103d8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_100+0x3c>
   103ca:	4a05      	ldr	r2, [pc, #20]	; (103e0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_100+0x44>)
   103cc:	9b01      	ldr	r3, [sp, #4]
   103ce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   103d2:	2b00      	cmp	r3, #0
   103d4:	d100      	bne.n	103d8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_100+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   103d6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   103d8:	bf00      	nop
   103da:	b003      	add	sp, #12
   103dc:	f85d fb04 	ldr.w	pc, [sp], #4
   103e0:	1fff93b4 	.word	0x1fff93b4
   103e4:	1fff93b0 	.word	0x1fff93b0

000103e8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_101>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_101(void)
{
   103e8:	b500      	push	{lr}
   103ea:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   103ec:	f7f0 fc96 	bl	d1c <Sys_GetCoreID>
   103f0:	4603      	mov	r3, r0
   103f2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_101[u32CoreId])
   103f4:	4a10      	ldr	r2, [pc, #64]	; (10438 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_101+0x50>)
   103f6:	9b01      	ldr	r3, [sp, #4]
   103f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   103fc:	2b00      	cmp	r3, #0
   103fe:	d10d      	bne.n	1041c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_101+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10400:	f7f0 faca 	bl	998 <Adc_schm_read_msr>
   10404:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   10406:	9b00      	ldr	r3, [sp, #0]
   10408:	f003 0301 	and.w	r3, r3, #1
   1040c:	2b00      	cmp	r3, #0
   1040e:	d100      	bne.n	10412 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_101+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10410:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_101[u32CoreId] = msr;
   10412:	490a      	ldr	r1, [pc, #40]	; (1043c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_101+0x54>)
   10414:	9b01      	ldr	r3, [sp, #4]
   10416:	9a00      	ldr	r2, [sp, #0]
   10418:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_101[u32CoreId]++;
   1041c:	4a06      	ldr	r2, [pc, #24]	; (10438 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_101+0x50>)
   1041e:	9b01      	ldr	r3, [sp, #4]
   10420:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10424:	1c5a      	adds	r2, r3, #1
   10426:	4904      	ldr	r1, [pc, #16]	; (10438 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_101+0x50>)
   10428:	9b01      	ldr	r3, [sp, #4]
   1042a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1042e:	bf00      	nop
   10430:	b003      	add	sp, #12
   10432:	f85d fb04 	ldr.w	pc, [sp], #4
   10436:	bf00      	nop
   10438:	1fff93bc 	.word	0x1fff93bc
   1043c:	1fff93b8 	.word	0x1fff93b8

00010440 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_101>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_101(void)
{
   10440:	b500      	push	{lr}
   10442:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10444:	f7f0 fc6a 	bl	d1c <Sys_GetCoreID>
   10448:	4603      	mov	r3, r0
   1044a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_101[u32CoreId]--;
   1044c:	4a0d      	ldr	r2, [pc, #52]	; (10484 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_101+0x44>)
   1044e:	9b01      	ldr	r3, [sp, #4]
   10450:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10454:	1e5a      	subs	r2, r3, #1
   10456:	490b      	ldr	r1, [pc, #44]	; (10484 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_101+0x44>)
   10458:	9b01      	ldr	r3, [sp, #4]
   1045a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_101[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_101[u32CoreId]))         /*if interrupts were enabled*/
   1045e:	4a0a      	ldr	r2, [pc, #40]	; (10488 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_101+0x48>)
   10460:	9b01      	ldr	r3, [sp, #4]
   10462:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10466:	f003 0301 	and.w	r3, r3, #1
   1046a:	2b00      	cmp	r3, #0
   1046c:	d106      	bne.n	1047c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_101+0x3c>
   1046e:	4a05      	ldr	r2, [pc, #20]	; (10484 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_101+0x44>)
   10470:	9b01      	ldr	r3, [sp, #4]
   10472:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10476:	2b00      	cmp	r3, #0
   10478:	d100      	bne.n	1047c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_101+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1047a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   1047c:	bf00      	nop
   1047e:	b003      	add	sp, #12
   10480:	f85d fb04 	ldr.w	pc, [sp], #4
   10484:	1fff93bc 	.word	0x1fff93bc
   10488:	1fff93b8 	.word	0x1fff93b8

0001048c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_102>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_102(void)
{
   1048c:	b500      	push	{lr}
   1048e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10490:	f7f0 fc44 	bl	d1c <Sys_GetCoreID>
   10494:	4603      	mov	r3, r0
   10496:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_102[u32CoreId])
   10498:	4a10      	ldr	r2, [pc, #64]	; (104dc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_102+0x50>)
   1049a:	9b01      	ldr	r3, [sp, #4]
   1049c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   104a0:	2b00      	cmp	r3, #0
   104a2:	d10d      	bne.n	104c0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_102+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   104a4:	f7f0 fa78 	bl	998 <Adc_schm_read_msr>
   104a8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   104aa:	9b00      	ldr	r3, [sp, #0]
   104ac:	f003 0301 	and.w	r3, r3, #1
   104b0:	2b00      	cmp	r3, #0
   104b2:	d100      	bne.n	104b6 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_102+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   104b4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_102[u32CoreId] = msr;
   104b6:	490a      	ldr	r1, [pc, #40]	; (104e0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_102+0x54>)
   104b8:	9b01      	ldr	r3, [sp, #4]
   104ba:	9a00      	ldr	r2, [sp, #0]
   104bc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_102[u32CoreId]++;
   104c0:	4a06      	ldr	r2, [pc, #24]	; (104dc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_102+0x50>)
   104c2:	9b01      	ldr	r3, [sp, #4]
   104c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   104c8:	1c5a      	adds	r2, r3, #1
   104ca:	4904      	ldr	r1, [pc, #16]	; (104dc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_102+0x50>)
   104cc:	9b01      	ldr	r3, [sp, #4]
   104ce:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   104d2:	bf00      	nop
   104d4:	b003      	add	sp, #12
   104d6:	f85d fb04 	ldr.w	pc, [sp], #4
   104da:	bf00      	nop
   104dc:	1fff93c4 	.word	0x1fff93c4
   104e0:	1fff93c0 	.word	0x1fff93c0

000104e4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_102>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_102(void)
{
   104e4:	b500      	push	{lr}
   104e6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   104e8:	f7f0 fc18 	bl	d1c <Sys_GetCoreID>
   104ec:	4603      	mov	r3, r0
   104ee:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_102[u32CoreId]--;
   104f0:	4a0d      	ldr	r2, [pc, #52]	; (10528 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_102+0x44>)
   104f2:	9b01      	ldr	r3, [sp, #4]
   104f4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   104f8:	1e5a      	subs	r2, r3, #1
   104fa:	490b      	ldr	r1, [pc, #44]	; (10528 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_102+0x44>)
   104fc:	9b01      	ldr	r3, [sp, #4]
   104fe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_102[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_102[u32CoreId]))         /*if interrupts were enabled*/
   10502:	4a0a      	ldr	r2, [pc, #40]	; (1052c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_102+0x48>)
   10504:	9b01      	ldr	r3, [sp, #4]
   10506:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1050a:	f003 0301 	and.w	r3, r3, #1
   1050e:	2b00      	cmp	r3, #0
   10510:	d106      	bne.n	10520 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_102+0x3c>
   10512:	4a05      	ldr	r2, [pc, #20]	; (10528 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_102+0x44>)
   10514:	9b01      	ldr	r3, [sp, #4]
   10516:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1051a:	2b00      	cmp	r3, #0
   1051c:	d100      	bne.n	10520 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_102+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1051e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10520:	bf00      	nop
   10522:	b003      	add	sp, #12
   10524:	f85d fb04 	ldr.w	pc, [sp], #4
   10528:	1fff93c4 	.word	0x1fff93c4
   1052c:	1fff93c0 	.word	0x1fff93c0

00010530 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_103>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_103(void)
{
   10530:	b500      	push	{lr}
   10532:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10534:	f7f0 fbf2 	bl	d1c <Sys_GetCoreID>
   10538:	4603      	mov	r3, r0
   1053a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_103[u32CoreId])
   1053c:	4a10      	ldr	r2, [pc, #64]	; (10580 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_103+0x50>)
   1053e:	9b01      	ldr	r3, [sp, #4]
   10540:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10544:	2b00      	cmp	r3, #0
   10546:	d10d      	bne.n	10564 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_103+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10548:	f7f0 fa26 	bl	998 <Adc_schm_read_msr>
   1054c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1054e:	9b00      	ldr	r3, [sp, #0]
   10550:	f003 0301 	and.w	r3, r3, #1
   10554:	2b00      	cmp	r3, #0
   10556:	d100      	bne.n	1055a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_103+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10558:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_103[u32CoreId] = msr;
   1055a:	490a      	ldr	r1, [pc, #40]	; (10584 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_103+0x54>)
   1055c:	9b01      	ldr	r3, [sp, #4]
   1055e:	9a00      	ldr	r2, [sp, #0]
   10560:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_103[u32CoreId]++;
   10564:	4a06      	ldr	r2, [pc, #24]	; (10580 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_103+0x50>)
   10566:	9b01      	ldr	r3, [sp, #4]
   10568:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1056c:	1c5a      	adds	r2, r3, #1
   1056e:	4904      	ldr	r1, [pc, #16]	; (10580 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_103+0x50>)
   10570:	9b01      	ldr	r3, [sp, #4]
   10572:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10576:	bf00      	nop
   10578:	b003      	add	sp, #12
   1057a:	f85d fb04 	ldr.w	pc, [sp], #4
   1057e:	bf00      	nop
   10580:	1fff93cc 	.word	0x1fff93cc
   10584:	1fff93c8 	.word	0x1fff93c8

00010588 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_103>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_103(void)
{
   10588:	b500      	push	{lr}
   1058a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1058c:	f7f0 fbc6 	bl	d1c <Sys_GetCoreID>
   10590:	4603      	mov	r3, r0
   10592:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_103[u32CoreId]--;
   10594:	4a0d      	ldr	r2, [pc, #52]	; (105cc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_103+0x44>)
   10596:	9b01      	ldr	r3, [sp, #4]
   10598:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1059c:	1e5a      	subs	r2, r3, #1
   1059e:	490b      	ldr	r1, [pc, #44]	; (105cc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_103+0x44>)
   105a0:	9b01      	ldr	r3, [sp, #4]
   105a2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_103[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_103[u32CoreId]))         /*if interrupts were enabled*/
   105a6:	4a0a      	ldr	r2, [pc, #40]	; (105d0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_103+0x48>)
   105a8:	9b01      	ldr	r3, [sp, #4]
   105aa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   105ae:	f003 0301 	and.w	r3, r3, #1
   105b2:	2b00      	cmp	r3, #0
   105b4:	d106      	bne.n	105c4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_103+0x3c>
   105b6:	4a05      	ldr	r2, [pc, #20]	; (105cc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_103+0x44>)
   105b8:	9b01      	ldr	r3, [sp, #4]
   105ba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   105be:	2b00      	cmp	r3, #0
   105c0:	d100      	bne.n	105c4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_103+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   105c2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   105c4:	bf00      	nop
   105c6:	b003      	add	sp, #12
   105c8:	f85d fb04 	ldr.w	pc, [sp], #4
   105cc:	1fff93cc 	.word	0x1fff93cc
   105d0:	1fff93c8 	.word	0x1fff93c8

000105d4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_11>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_11(void)
{
   105d4:	b500      	push	{lr}
   105d6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   105d8:	f7f0 fba0 	bl	d1c <Sys_GetCoreID>
   105dc:	4603      	mov	r3, r0
   105de:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_11[u32CoreId])
   105e0:	4a10      	ldr	r2, [pc, #64]	; (10624 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_11+0x50>)
   105e2:	9b01      	ldr	r3, [sp, #4]
   105e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   105e8:	2b00      	cmp	r3, #0
   105ea:	d10d      	bne.n	10608 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_11+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   105ec:	f7f0 f9d4 	bl	998 <Adc_schm_read_msr>
   105f0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   105f2:	9b00      	ldr	r3, [sp, #0]
   105f4:	f003 0301 	and.w	r3, r3, #1
   105f8:	2b00      	cmp	r3, #0
   105fa:	d100      	bne.n	105fe <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_11+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   105fc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_11[u32CoreId] = msr;
   105fe:	490a      	ldr	r1, [pc, #40]	; (10628 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_11+0x54>)
   10600:	9b01      	ldr	r3, [sp, #4]
   10602:	9a00      	ldr	r2, [sp, #0]
   10604:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_11[u32CoreId]++;
   10608:	4a06      	ldr	r2, [pc, #24]	; (10624 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_11+0x50>)
   1060a:	9b01      	ldr	r3, [sp, #4]
   1060c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10610:	1c5a      	adds	r2, r3, #1
   10612:	4904      	ldr	r1, [pc, #16]	; (10624 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_11+0x50>)
   10614:	9b01      	ldr	r3, [sp, #4]
   10616:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1061a:	bf00      	nop
   1061c:	b003      	add	sp, #12
   1061e:	f85d fb04 	ldr.w	pc, [sp], #4
   10622:	bf00      	nop
   10624:	1fff93d4 	.word	0x1fff93d4
   10628:	1fff93d0 	.word	0x1fff93d0

0001062c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_11>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_11(void)
{
   1062c:	b500      	push	{lr}
   1062e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10630:	f7f0 fb74 	bl	d1c <Sys_GetCoreID>
   10634:	4603      	mov	r3, r0
   10636:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_11[u32CoreId]--;
   10638:	4a0d      	ldr	r2, [pc, #52]	; (10670 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_11+0x44>)
   1063a:	9b01      	ldr	r3, [sp, #4]
   1063c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10640:	1e5a      	subs	r2, r3, #1
   10642:	490b      	ldr	r1, [pc, #44]	; (10670 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_11+0x44>)
   10644:	9b01      	ldr	r3, [sp, #4]
   10646:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_11[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_11[u32CoreId]))         /*if interrupts were enabled*/
   1064a:	4a0a      	ldr	r2, [pc, #40]	; (10674 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_11+0x48>)
   1064c:	9b01      	ldr	r3, [sp, #4]
   1064e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10652:	f003 0301 	and.w	r3, r3, #1
   10656:	2b00      	cmp	r3, #0
   10658:	d106      	bne.n	10668 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_11+0x3c>
   1065a:	4a05      	ldr	r2, [pc, #20]	; (10670 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_11+0x44>)
   1065c:	9b01      	ldr	r3, [sp, #4]
   1065e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10662:	2b00      	cmp	r3, #0
   10664:	d100      	bne.n	10668 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_11+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   10666:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10668:	bf00      	nop
   1066a:	b003      	add	sp, #12
   1066c:	f85d fb04 	ldr.w	pc, [sp], #4
   10670:	1fff93d4 	.word	0x1fff93d4
   10674:	1fff93d0 	.word	0x1fff93d0

00010678 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_12>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_12(void)
{
   10678:	b500      	push	{lr}
   1067a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1067c:	f7f0 fb4e 	bl	d1c <Sys_GetCoreID>
   10680:	4603      	mov	r3, r0
   10682:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_12[u32CoreId])
   10684:	4a10      	ldr	r2, [pc, #64]	; (106c8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_12+0x50>)
   10686:	9b01      	ldr	r3, [sp, #4]
   10688:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1068c:	2b00      	cmp	r3, #0
   1068e:	d10d      	bne.n	106ac <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_12+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10690:	f7f0 f982 	bl	998 <Adc_schm_read_msr>
   10694:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   10696:	9b00      	ldr	r3, [sp, #0]
   10698:	f003 0301 	and.w	r3, r3, #1
   1069c:	2b00      	cmp	r3, #0
   1069e:	d100      	bne.n	106a2 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_12+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   106a0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_12[u32CoreId] = msr;
   106a2:	490a      	ldr	r1, [pc, #40]	; (106cc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_12+0x54>)
   106a4:	9b01      	ldr	r3, [sp, #4]
   106a6:	9a00      	ldr	r2, [sp, #0]
   106a8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_12[u32CoreId]++;
   106ac:	4a06      	ldr	r2, [pc, #24]	; (106c8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_12+0x50>)
   106ae:	9b01      	ldr	r3, [sp, #4]
   106b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   106b4:	1c5a      	adds	r2, r3, #1
   106b6:	4904      	ldr	r1, [pc, #16]	; (106c8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_12+0x50>)
   106b8:	9b01      	ldr	r3, [sp, #4]
   106ba:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   106be:	bf00      	nop
   106c0:	b003      	add	sp, #12
   106c2:	f85d fb04 	ldr.w	pc, [sp], #4
   106c6:	bf00      	nop
   106c8:	1fff93dc 	.word	0x1fff93dc
   106cc:	1fff93d8 	.word	0x1fff93d8

000106d0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_12>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_12(void)
{
   106d0:	b500      	push	{lr}
   106d2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   106d4:	f7f0 fb22 	bl	d1c <Sys_GetCoreID>
   106d8:	4603      	mov	r3, r0
   106da:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_12[u32CoreId]--;
   106dc:	4a0d      	ldr	r2, [pc, #52]	; (10714 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_12+0x44>)
   106de:	9b01      	ldr	r3, [sp, #4]
   106e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   106e4:	1e5a      	subs	r2, r3, #1
   106e6:	490b      	ldr	r1, [pc, #44]	; (10714 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_12+0x44>)
   106e8:	9b01      	ldr	r3, [sp, #4]
   106ea:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_12[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_12[u32CoreId]))         /*if interrupts were enabled*/
   106ee:	4a0a      	ldr	r2, [pc, #40]	; (10718 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_12+0x48>)
   106f0:	9b01      	ldr	r3, [sp, #4]
   106f2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   106f6:	f003 0301 	and.w	r3, r3, #1
   106fa:	2b00      	cmp	r3, #0
   106fc:	d106      	bne.n	1070c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_12+0x3c>
   106fe:	4a05      	ldr	r2, [pc, #20]	; (10714 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_12+0x44>)
   10700:	9b01      	ldr	r3, [sp, #4]
   10702:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10706:	2b00      	cmp	r3, #0
   10708:	d100      	bne.n	1070c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_12+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1070a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   1070c:	bf00      	nop
   1070e:	b003      	add	sp, #12
   10710:	f85d fb04 	ldr.w	pc, [sp], #4
   10714:	1fff93dc 	.word	0x1fff93dc
   10718:	1fff93d8 	.word	0x1fff93d8

0001071c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_13>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_13(void)
{
   1071c:	b500      	push	{lr}
   1071e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10720:	f7f0 fafc 	bl	d1c <Sys_GetCoreID>
   10724:	4603      	mov	r3, r0
   10726:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_13[u32CoreId])
   10728:	4a10      	ldr	r2, [pc, #64]	; (1076c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_13+0x50>)
   1072a:	9b01      	ldr	r3, [sp, #4]
   1072c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10730:	2b00      	cmp	r3, #0
   10732:	d10d      	bne.n	10750 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_13+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10734:	f7f0 f930 	bl	998 <Adc_schm_read_msr>
   10738:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1073a:	9b00      	ldr	r3, [sp, #0]
   1073c:	f003 0301 	and.w	r3, r3, #1
   10740:	2b00      	cmp	r3, #0
   10742:	d100      	bne.n	10746 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_13+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10744:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_13[u32CoreId] = msr;
   10746:	490a      	ldr	r1, [pc, #40]	; (10770 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_13+0x54>)
   10748:	9b01      	ldr	r3, [sp, #4]
   1074a:	9a00      	ldr	r2, [sp, #0]
   1074c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_13[u32CoreId]++;
   10750:	4a06      	ldr	r2, [pc, #24]	; (1076c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_13+0x50>)
   10752:	9b01      	ldr	r3, [sp, #4]
   10754:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10758:	1c5a      	adds	r2, r3, #1
   1075a:	4904      	ldr	r1, [pc, #16]	; (1076c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_13+0x50>)
   1075c:	9b01      	ldr	r3, [sp, #4]
   1075e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10762:	bf00      	nop
   10764:	b003      	add	sp, #12
   10766:	f85d fb04 	ldr.w	pc, [sp], #4
   1076a:	bf00      	nop
   1076c:	1fff93e4 	.word	0x1fff93e4
   10770:	1fff93e0 	.word	0x1fff93e0

00010774 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_13>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_13(void)
{
   10774:	b500      	push	{lr}
   10776:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10778:	f7f0 fad0 	bl	d1c <Sys_GetCoreID>
   1077c:	4603      	mov	r3, r0
   1077e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_13[u32CoreId]--;
   10780:	4a0d      	ldr	r2, [pc, #52]	; (107b8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_13+0x44>)
   10782:	9b01      	ldr	r3, [sp, #4]
   10784:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10788:	1e5a      	subs	r2, r3, #1
   1078a:	490b      	ldr	r1, [pc, #44]	; (107b8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_13+0x44>)
   1078c:	9b01      	ldr	r3, [sp, #4]
   1078e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_13[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_13[u32CoreId]))         /*if interrupts were enabled*/
   10792:	4a0a      	ldr	r2, [pc, #40]	; (107bc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_13+0x48>)
   10794:	9b01      	ldr	r3, [sp, #4]
   10796:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1079a:	f003 0301 	and.w	r3, r3, #1
   1079e:	2b00      	cmp	r3, #0
   107a0:	d106      	bne.n	107b0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_13+0x3c>
   107a2:	4a05      	ldr	r2, [pc, #20]	; (107b8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_13+0x44>)
   107a4:	9b01      	ldr	r3, [sp, #4]
   107a6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   107aa:	2b00      	cmp	r3, #0
   107ac:	d100      	bne.n	107b0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_13+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   107ae:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   107b0:	bf00      	nop
   107b2:	b003      	add	sp, #12
   107b4:	f85d fb04 	ldr.w	pc, [sp], #4
   107b8:	1fff93e4 	.word	0x1fff93e4
   107bc:	1fff93e0 	.word	0x1fff93e0

000107c0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_14>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_14(void)
{
   107c0:	b500      	push	{lr}
   107c2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   107c4:	f7f0 faaa 	bl	d1c <Sys_GetCoreID>
   107c8:	4603      	mov	r3, r0
   107ca:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_14[u32CoreId])
   107cc:	4a10      	ldr	r2, [pc, #64]	; (10810 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_14+0x50>)
   107ce:	9b01      	ldr	r3, [sp, #4]
   107d0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   107d4:	2b00      	cmp	r3, #0
   107d6:	d10d      	bne.n	107f4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_14+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   107d8:	f7f0 f8de 	bl	998 <Adc_schm_read_msr>
   107dc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   107de:	9b00      	ldr	r3, [sp, #0]
   107e0:	f003 0301 	and.w	r3, r3, #1
   107e4:	2b00      	cmp	r3, #0
   107e6:	d100      	bne.n	107ea <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_14+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   107e8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_14[u32CoreId] = msr;
   107ea:	490a      	ldr	r1, [pc, #40]	; (10814 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_14+0x54>)
   107ec:	9b01      	ldr	r3, [sp, #4]
   107ee:	9a00      	ldr	r2, [sp, #0]
   107f0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_14[u32CoreId]++;
   107f4:	4a06      	ldr	r2, [pc, #24]	; (10810 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_14+0x50>)
   107f6:	9b01      	ldr	r3, [sp, #4]
   107f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   107fc:	1c5a      	adds	r2, r3, #1
   107fe:	4904      	ldr	r1, [pc, #16]	; (10810 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_14+0x50>)
   10800:	9b01      	ldr	r3, [sp, #4]
   10802:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10806:	bf00      	nop
   10808:	b003      	add	sp, #12
   1080a:	f85d fb04 	ldr.w	pc, [sp], #4
   1080e:	bf00      	nop
   10810:	1fff93ec 	.word	0x1fff93ec
   10814:	1fff93e8 	.word	0x1fff93e8

00010818 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_14>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_14(void)
{
   10818:	b500      	push	{lr}
   1081a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1081c:	f7f0 fa7e 	bl	d1c <Sys_GetCoreID>
   10820:	4603      	mov	r3, r0
   10822:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_14[u32CoreId]--;
   10824:	4a0d      	ldr	r2, [pc, #52]	; (1085c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_14+0x44>)
   10826:	9b01      	ldr	r3, [sp, #4]
   10828:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1082c:	1e5a      	subs	r2, r3, #1
   1082e:	490b      	ldr	r1, [pc, #44]	; (1085c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_14+0x44>)
   10830:	9b01      	ldr	r3, [sp, #4]
   10832:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_14[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_14[u32CoreId]))         /*if interrupts were enabled*/
   10836:	4a0a      	ldr	r2, [pc, #40]	; (10860 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_14+0x48>)
   10838:	9b01      	ldr	r3, [sp, #4]
   1083a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1083e:	f003 0301 	and.w	r3, r3, #1
   10842:	2b00      	cmp	r3, #0
   10844:	d106      	bne.n	10854 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_14+0x3c>
   10846:	4a05      	ldr	r2, [pc, #20]	; (1085c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_14+0x44>)
   10848:	9b01      	ldr	r3, [sp, #4]
   1084a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1084e:	2b00      	cmp	r3, #0
   10850:	d100      	bne.n	10854 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_14+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   10852:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10854:	bf00      	nop
   10856:	b003      	add	sp, #12
   10858:	f85d fb04 	ldr.w	pc, [sp], #4
   1085c:	1fff93ec 	.word	0x1fff93ec
   10860:	1fff93e8 	.word	0x1fff93e8

00010864 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_15>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_15(void)
{
   10864:	b500      	push	{lr}
   10866:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10868:	f7f0 fa58 	bl	d1c <Sys_GetCoreID>
   1086c:	4603      	mov	r3, r0
   1086e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_15[u32CoreId])
   10870:	4a10      	ldr	r2, [pc, #64]	; (108b4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_15+0x50>)
   10872:	9b01      	ldr	r3, [sp, #4]
   10874:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10878:	2b00      	cmp	r3, #0
   1087a:	d10d      	bne.n	10898 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_15+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   1087c:	f7f0 f88c 	bl	998 <Adc_schm_read_msr>
   10880:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   10882:	9b00      	ldr	r3, [sp, #0]
   10884:	f003 0301 	and.w	r3, r3, #1
   10888:	2b00      	cmp	r3, #0
   1088a:	d100      	bne.n	1088e <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_15+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   1088c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_15[u32CoreId] = msr;
   1088e:	490a      	ldr	r1, [pc, #40]	; (108b8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_15+0x54>)
   10890:	9b01      	ldr	r3, [sp, #4]
   10892:	9a00      	ldr	r2, [sp, #0]
   10894:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_15[u32CoreId]++;
   10898:	4a06      	ldr	r2, [pc, #24]	; (108b4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_15+0x50>)
   1089a:	9b01      	ldr	r3, [sp, #4]
   1089c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   108a0:	1c5a      	adds	r2, r3, #1
   108a2:	4904      	ldr	r1, [pc, #16]	; (108b4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_15+0x50>)
   108a4:	9b01      	ldr	r3, [sp, #4]
   108a6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   108aa:	bf00      	nop
   108ac:	b003      	add	sp, #12
   108ae:	f85d fb04 	ldr.w	pc, [sp], #4
   108b2:	bf00      	nop
   108b4:	1fff93f4 	.word	0x1fff93f4
   108b8:	1fff93f0 	.word	0x1fff93f0

000108bc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_15>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_15(void)
{
   108bc:	b500      	push	{lr}
   108be:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   108c0:	f7f0 fa2c 	bl	d1c <Sys_GetCoreID>
   108c4:	4603      	mov	r3, r0
   108c6:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_15[u32CoreId]--;
   108c8:	4a0d      	ldr	r2, [pc, #52]	; (10900 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_15+0x44>)
   108ca:	9b01      	ldr	r3, [sp, #4]
   108cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   108d0:	1e5a      	subs	r2, r3, #1
   108d2:	490b      	ldr	r1, [pc, #44]	; (10900 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_15+0x44>)
   108d4:	9b01      	ldr	r3, [sp, #4]
   108d6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_15[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_15[u32CoreId]))         /*if interrupts were enabled*/
   108da:	4a0a      	ldr	r2, [pc, #40]	; (10904 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_15+0x48>)
   108dc:	9b01      	ldr	r3, [sp, #4]
   108de:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   108e2:	f003 0301 	and.w	r3, r3, #1
   108e6:	2b00      	cmp	r3, #0
   108e8:	d106      	bne.n	108f8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_15+0x3c>
   108ea:	4a05      	ldr	r2, [pc, #20]	; (10900 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_15+0x44>)
   108ec:	9b01      	ldr	r3, [sp, #4]
   108ee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   108f2:	2b00      	cmp	r3, #0
   108f4:	d100      	bne.n	108f8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_15+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   108f6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   108f8:	bf00      	nop
   108fa:	b003      	add	sp, #12
   108fc:	f85d fb04 	ldr.w	pc, [sp], #4
   10900:	1fff93f4 	.word	0x1fff93f4
   10904:	1fff93f0 	.word	0x1fff93f0

00010908 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_16>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_16(void)
{
   10908:	b500      	push	{lr}
   1090a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1090c:	f7f0 fa06 	bl	d1c <Sys_GetCoreID>
   10910:	4603      	mov	r3, r0
   10912:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_16[u32CoreId])
   10914:	4a10      	ldr	r2, [pc, #64]	; (10958 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_16+0x50>)
   10916:	9b01      	ldr	r3, [sp, #4]
   10918:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1091c:	2b00      	cmp	r3, #0
   1091e:	d10d      	bne.n	1093c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_16+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10920:	f7f0 f83a 	bl	998 <Adc_schm_read_msr>
   10924:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   10926:	9b00      	ldr	r3, [sp, #0]
   10928:	f003 0301 	and.w	r3, r3, #1
   1092c:	2b00      	cmp	r3, #0
   1092e:	d100      	bne.n	10932 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_16+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10930:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_16[u32CoreId] = msr;
   10932:	490a      	ldr	r1, [pc, #40]	; (1095c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_16+0x54>)
   10934:	9b01      	ldr	r3, [sp, #4]
   10936:	9a00      	ldr	r2, [sp, #0]
   10938:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_16[u32CoreId]++;
   1093c:	4a06      	ldr	r2, [pc, #24]	; (10958 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_16+0x50>)
   1093e:	9b01      	ldr	r3, [sp, #4]
   10940:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10944:	1c5a      	adds	r2, r3, #1
   10946:	4904      	ldr	r1, [pc, #16]	; (10958 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_16+0x50>)
   10948:	9b01      	ldr	r3, [sp, #4]
   1094a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1094e:	bf00      	nop
   10950:	b003      	add	sp, #12
   10952:	f85d fb04 	ldr.w	pc, [sp], #4
   10956:	bf00      	nop
   10958:	1fff93fc 	.word	0x1fff93fc
   1095c:	1fff93f8 	.word	0x1fff93f8

00010960 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_16>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_16(void)
{
   10960:	b500      	push	{lr}
   10962:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10964:	f7f0 f9da 	bl	d1c <Sys_GetCoreID>
   10968:	4603      	mov	r3, r0
   1096a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_16[u32CoreId]--;
   1096c:	4a0d      	ldr	r2, [pc, #52]	; (109a4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_16+0x44>)
   1096e:	9b01      	ldr	r3, [sp, #4]
   10970:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10974:	1e5a      	subs	r2, r3, #1
   10976:	490b      	ldr	r1, [pc, #44]	; (109a4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_16+0x44>)
   10978:	9b01      	ldr	r3, [sp, #4]
   1097a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_16[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_16[u32CoreId]))         /*if interrupts were enabled*/
   1097e:	4a0a      	ldr	r2, [pc, #40]	; (109a8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_16+0x48>)
   10980:	9b01      	ldr	r3, [sp, #4]
   10982:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10986:	f003 0301 	and.w	r3, r3, #1
   1098a:	2b00      	cmp	r3, #0
   1098c:	d106      	bne.n	1099c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_16+0x3c>
   1098e:	4a05      	ldr	r2, [pc, #20]	; (109a4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_16+0x44>)
   10990:	9b01      	ldr	r3, [sp, #4]
   10992:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10996:	2b00      	cmp	r3, #0
   10998:	d100      	bne.n	1099c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_16+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1099a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   1099c:	bf00      	nop
   1099e:	b003      	add	sp, #12
   109a0:	f85d fb04 	ldr.w	pc, [sp], #4
   109a4:	1fff93fc 	.word	0x1fff93fc
   109a8:	1fff93f8 	.word	0x1fff93f8

000109ac <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_17>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_17(void)
{
   109ac:	b500      	push	{lr}
   109ae:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   109b0:	f7f0 f9b4 	bl	d1c <Sys_GetCoreID>
   109b4:	4603      	mov	r3, r0
   109b6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_17[u32CoreId])
   109b8:	4a10      	ldr	r2, [pc, #64]	; (109fc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_17+0x50>)
   109ba:	9b01      	ldr	r3, [sp, #4]
   109bc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   109c0:	2b00      	cmp	r3, #0
   109c2:	d10d      	bne.n	109e0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_17+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   109c4:	f7ef ffe8 	bl	998 <Adc_schm_read_msr>
   109c8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   109ca:	9b00      	ldr	r3, [sp, #0]
   109cc:	f003 0301 	and.w	r3, r3, #1
   109d0:	2b00      	cmp	r3, #0
   109d2:	d100      	bne.n	109d6 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_17+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   109d4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_17[u32CoreId] = msr;
   109d6:	490a      	ldr	r1, [pc, #40]	; (10a00 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_17+0x54>)
   109d8:	9b01      	ldr	r3, [sp, #4]
   109da:	9a00      	ldr	r2, [sp, #0]
   109dc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_17[u32CoreId]++;
   109e0:	4a06      	ldr	r2, [pc, #24]	; (109fc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_17+0x50>)
   109e2:	9b01      	ldr	r3, [sp, #4]
   109e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   109e8:	1c5a      	adds	r2, r3, #1
   109ea:	4904      	ldr	r1, [pc, #16]	; (109fc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_17+0x50>)
   109ec:	9b01      	ldr	r3, [sp, #4]
   109ee:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   109f2:	bf00      	nop
   109f4:	b003      	add	sp, #12
   109f6:	f85d fb04 	ldr.w	pc, [sp], #4
   109fa:	bf00      	nop
   109fc:	1fff9404 	.word	0x1fff9404
   10a00:	1fff9400 	.word	0x1fff9400

00010a04 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_17>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_17(void)
{
   10a04:	b500      	push	{lr}
   10a06:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10a08:	f7f0 f988 	bl	d1c <Sys_GetCoreID>
   10a0c:	4603      	mov	r3, r0
   10a0e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_17[u32CoreId]--;
   10a10:	4a0d      	ldr	r2, [pc, #52]	; (10a48 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_17+0x44>)
   10a12:	9b01      	ldr	r3, [sp, #4]
   10a14:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10a18:	1e5a      	subs	r2, r3, #1
   10a1a:	490b      	ldr	r1, [pc, #44]	; (10a48 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_17+0x44>)
   10a1c:	9b01      	ldr	r3, [sp, #4]
   10a1e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_17[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_17[u32CoreId]))         /*if interrupts were enabled*/
   10a22:	4a0a      	ldr	r2, [pc, #40]	; (10a4c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_17+0x48>)
   10a24:	9b01      	ldr	r3, [sp, #4]
   10a26:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10a2a:	f003 0301 	and.w	r3, r3, #1
   10a2e:	2b00      	cmp	r3, #0
   10a30:	d106      	bne.n	10a40 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_17+0x3c>
   10a32:	4a05      	ldr	r2, [pc, #20]	; (10a48 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_17+0x44>)
   10a34:	9b01      	ldr	r3, [sp, #4]
   10a36:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10a3a:	2b00      	cmp	r3, #0
   10a3c:	d100      	bne.n	10a40 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_17+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   10a3e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10a40:	bf00      	nop
   10a42:	b003      	add	sp, #12
   10a44:	f85d fb04 	ldr.w	pc, [sp], #4
   10a48:	1fff9404 	.word	0x1fff9404
   10a4c:	1fff9400 	.word	0x1fff9400

00010a50 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_18>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_18(void)
{
   10a50:	b500      	push	{lr}
   10a52:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10a54:	f7f0 f962 	bl	d1c <Sys_GetCoreID>
   10a58:	4603      	mov	r3, r0
   10a5a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_18[u32CoreId])
   10a5c:	4a10      	ldr	r2, [pc, #64]	; (10aa0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_18+0x50>)
   10a5e:	9b01      	ldr	r3, [sp, #4]
   10a60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10a64:	2b00      	cmp	r3, #0
   10a66:	d10d      	bne.n	10a84 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_18+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10a68:	f7ef ff96 	bl	998 <Adc_schm_read_msr>
   10a6c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   10a6e:	9b00      	ldr	r3, [sp, #0]
   10a70:	f003 0301 	and.w	r3, r3, #1
   10a74:	2b00      	cmp	r3, #0
   10a76:	d100      	bne.n	10a7a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_18+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10a78:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_18[u32CoreId] = msr;
   10a7a:	490a      	ldr	r1, [pc, #40]	; (10aa4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_18+0x54>)
   10a7c:	9b01      	ldr	r3, [sp, #4]
   10a7e:	9a00      	ldr	r2, [sp, #0]
   10a80:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_18[u32CoreId]++;
   10a84:	4a06      	ldr	r2, [pc, #24]	; (10aa0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_18+0x50>)
   10a86:	9b01      	ldr	r3, [sp, #4]
   10a88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10a8c:	1c5a      	adds	r2, r3, #1
   10a8e:	4904      	ldr	r1, [pc, #16]	; (10aa0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_18+0x50>)
   10a90:	9b01      	ldr	r3, [sp, #4]
   10a92:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10a96:	bf00      	nop
   10a98:	b003      	add	sp, #12
   10a9a:	f85d fb04 	ldr.w	pc, [sp], #4
   10a9e:	bf00      	nop
   10aa0:	1fff940c 	.word	0x1fff940c
   10aa4:	1fff9408 	.word	0x1fff9408

00010aa8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_18>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_18(void)
{
   10aa8:	b500      	push	{lr}
   10aaa:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10aac:	f7f0 f936 	bl	d1c <Sys_GetCoreID>
   10ab0:	4603      	mov	r3, r0
   10ab2:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_18[u32CoreId]--;
   10ab4:	4a0d      	ldr	r2, [pc, #52]	; (10aec <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_18+0x44>)
   10ab6:	9b01      	ldr	r3, [sp, #4]
   10ab8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10abc:	1e5a      	subs	r2, r3, #1
   10abe:	490b      	ldr	r1, [pc, #44]	; (10aec <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_18+0x44>)
   10ac0:	9b01      	ldr	r3, [sp, #4]
   10ac2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_18[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_18[u32CoreId]))         /*if interrupts were enabled*/
   10ac6:	4a0a      	ldr	r2, [pc, #40]	; (10af0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_18+0x48>)
   10ac8:	9b01      	ldr	r3, [sp, #4]
   10aca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10ace:	f003 0301 	and.w	r3, r3, #1
   10ad2:	2b00      	cmp	r3, #0
   10ad4:	d106      	bne.n	10ae4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_18+0x3c>
   10ad6:	4a05      	ldr	r2, [pc, #20]	; (10aec <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_18+0x44>)
   10ad8:	9b01      	ldr	r3, [sp, #4]
   10ada:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10ade:	2b00      	cmp	r3, #0
   10ae0:	d100      	bne.n	10ae4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_18+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   10ae2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10ae4:	bf00      	nop
   10ae6:	b003      	add	sp, #12
   10ae8:	f85d fb04 	ldr.w	pc, [sp], #4
   10aec:	1fff940c 	.word	0x1fff940c
   10af0:	1fff9408 	.word	0x1fff9408

00010af4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_19>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_19(void)
{
   10af4:	b500      	push	{lr}
   10af6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10af8:	f7f0 f910 	bl	d1c <Sys_GetCoreID>
   10afc:	4603      	mov	r3, r0
   10afe:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_19[u32CoreId])
   10b00:	4a10      	ldr	r2, [pc, #64]	; (10b44 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_19+0x50>)
   10b02:	9b01      	ldr	r3, [sp, #4]
   10b04:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10b08:	2b00      	cmp	r3, #0
   10b0a:	d10d      	bne.n	10b28 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_19+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10b0c:	f7ef ff44 	bl	998 <Adc_schm_read_msr>
   10b10:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   10b12:	9b00      	ldr	r3, [sp, #0]
   10b14:	f003 0301 	and.w	r3, r3, #1
   10b18:	2b00      	cmp	r3, #0
   10b1a:	d100      	bne.n	10b1e <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_19+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10b1c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_19[u32CoreId] = msr;
   10b1e:	490a      	ldr	r1, [pc, #40]	; (10b48 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_19+0x54>)
   10b20:	9b01      	ldr	r3, [sp, #4]
   10b22:	9a00      	ldr	r2, [sp, #0]
   10b24:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_19[u32CoreId]++;
   10b28:	4a06      	ldr	r2, [pc, #24]	; (10b44 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_19+0x50>)
   10b2a:	9b01      	ldr	r3, [sp, #4]
   10b2c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10b30:	1c5a      	adds	r2, r3, #1
   10b32:	4904      	ldr	r1, [pc, #16]	; (10b44 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_19+0x50>)
   10b34:	9b01      	ldr	r3, [sp, #4]
   10b36:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10b3a:	bf00      	nop
   10b3c:	b003      	add	sp, #12
   10b3e:	f85d fb04 	ldr.w	pc, [sp], #4
   10b42:	bf00      	nop
   10b44:	1fff9414 	.word	0x1fff9414
   10b48:	1fff9410 	.word	0x1fff9410

00010b4c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_19>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_19(void)
{
   10b4c:	b500      	push	{lr}
   10b4e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10b50:	f7f0 f8e4 	bl	d1c <Sys_GetCoreID>
   10b54:	4603      	mov	r3, r0
   10b56:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_19[u32CoreId]--;
   10b58:	4a0d      	ldr	r2, [pc, #52]	; (10b90 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_19+0x44>)
   10b5a:	9b01      	ldr	r3, [sp, #4]
   10b5c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10b60:	1e5a      	subs	r2, r3, #1
   10b62:	490b      	ldr	r1, [pc, #44]	; (10b90 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_19+0x44>)
   10b64:	9b01      	ldr	r3, [sp, #4]
   10b66:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_19[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_19[u32CoreId]))         /*if interrupts were enabled*/
   10b6a:	4a0a      	ldr	r2, [pc, #40]	; (10b94 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_19+0x48>)
   10b6c:	9b01      	ldr	r3, [sp, #4]
   10b6e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10b72:	f003 0301 	and.w	r3, r3, #1
   10b76:	2b00      	cmp	r3, #0
   10b78:	d106      	bne.n	10b88 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_19+0x3c>
   10b7a:	4a05      	ldr	r2, [pc, #20]	; (10b90 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_19+0x44>)
   10b7c:	9b01      	ldr	r3, [sp, #4]
   10b7e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10b82:	2b00      	cmp	r3, #0
   10b84:	d100      	bne.n	10b88 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_19+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   10b86:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10b88:	bf00      	nop
   10b8a:	b003      	add	sp, #12
   10b8c:	f85d fb04 	ldr.w	pc, [sp], #4
   10b90:	1fff9414 	.word	0x1fff9414
   10b94:	1fff9410 	.word	0x1fff9410

00010b98 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_20>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_20(void)
{
   10b98:	b500      	push	{lr}
   10b9a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10b9c:	f7f0 f8be 	bl	d1c <Sys_GetCoreID>
   10ba0:	4603      	mov	r3, r0
   10ba2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_20[u32CoreId])
   10ba4:	4a10      	ldr	r2, [pc, #64]	; (10be8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_20+0x50>)
   10ba6:	9b01      	ldr	r3, [sp, #4]
   10ba8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10bac:	2b00      	cmp	r3, #0
   10bae:	d10d      	bne.n	10bcc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_20+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10bb0:	f7ef fef2 	bl	998 <Adc_schm_read_msr>
   10bb4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   10bb6:	9b00      	ldr	r3, [sp, #0]
   10bb8:	f003 0301 	and.w	r3, r3, #1
   10bbc:	2b00      	cmp	r3, #0
   10bbe:	d100      	bne.n	10bc2 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_20+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10bc0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_20[u32CoreId] = msr;
   10bc2:	490a      	ldr	r1, [pc, #40]	; (10bec <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_20+0x54>)
   10bc4:	9b01      	ldr	r3, [sp, #4]
   10bc6:	9a00      	ldr	r2, [sp, #0]
   10bc8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_20[u32CoreId]++;
   10bcc:	4a06      	ldr	r2, [pc, #24]	; (10be8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_20+0x50>)
   10bce:	9b01      	ldr	r3, [sp, #4]
   10bd0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10bd4:	1c5a      	adds	r2, r3, #1
   10bd6:	4904      	ldr	r1, [pc, #16]	; (10be8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_20+0x50>)
   10bd8:	9b01      	ldr	r3, [sp, #4]
   10bda:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10bde:	bf00      	nop
   10be0:	b003      	add	sp, #12
   10be2:	f85d fb04 	ldr.w	pc, [sp], #4
   10be6:	bf00      	nop
   10be8:	1fff941c 	.word	0x1fff941c
   10bec:	1fff9418 	.word	0x1fff9418

00010bf0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_20>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_20(void)
{
   10bf0:	b500      	push	{lr}
   10bf2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10bf4:	f7f0 f892 	bl	d1c <Sys_GetCoreID>
   10bf8:	4603      	mov	r3, r0
   10bfa:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_20[u32CoreId]--;
   10bfc:	4a0d      	ldr	r2, [pc, #52]	; (10c34 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_20+0x44>)
   10bfe:	9b01      	ldr	r3, [sp, #4]
   10c00:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10c04:	1e5a      	subs	r2, r3, #1
   10c06:	490b      	ldr	r1, [pc, #44]	; (10c34 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_20+0x44>)
   10c08:	9b01      	ldr	r3, [sp, #4]
   10c0a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_20[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_20[u32CoreId]))         /*if interrupts were enabled*/
   10c0e:	4a0a      	ldr	r2, [pc, #40]	; (10c38 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_20+0x48>)
   10c10:	9b01      	ldr	r3, [sp, #4]
   10c12:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10c16:	f003 0301 	and.w	r3, r3, #1
   10c1a:	2b00      	cmp	r3, #0
   10c1c:	d106      	bne.n	10c2c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_20+0x3c>
   10c1e:	4a05      	ldr	r2, [pc, #20]	; (10c34 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_20+0x44>)
   10c20:	9b01      	ldr	r3, [sp, #4]
   10c22:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10c26:	2b00      	cmp	r3, #0
   10c28:	d100      	bne.n	10c2c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_20+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   10c2a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10c2c:	bf00      	nop
   10c2e:	b003      	add	sp, #12
   10c30:	f85d fb04 	ldr.w	pc, [sp], #4
   10c34:	1fff941c 	.word	0x1fff941c
   10c38:	1fff9418 	.word	0x1fff9418

00010c3c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_21>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_21(void)
{
   10c3c:	b500      	push	{lr}
   10c3e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10c40:	f7f0 f86c 	bl	d1c <Sys_GetCoreID>
   10c44:	4603      	mov	r3, r0
   10c46:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_21[u32CoreId])
   10c48:	4a10      	ldr	r2, [pc, #64]	; (10c8c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_21+0x50>)
   10c4a:	9b01      	ldr	r3, [sp, #4]
   10c4c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10c50:	2b00      	cmp	r3, #0
   10c52:	d10d      	bne.n	10c70 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_21+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10c54:	f7ef fea0 	bl	998 <Adc_schm_read_msr>
   10c58:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   10c5a:	9b00      	ldr	r3, [sp, #0]
   10c5c:	f003 0301 	and.w	r3, r3, #1
   10c60:	2b00      	cmp	r3, #0
   10c62:	d100      	bne.n	10c66 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_21+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10c64:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_21[u32CoreId] = msr;
   10c66:	490a      	ldr	r1, [pc, #40]	; (10c90 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_21+0x54>)
   10c68:	9b01      	ldr	r3, [sp, #4]
   10c6a:	9a00      	ldr	r2, [sp, #0]
   10c6c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_21[u32CoreId]++;
   10c70:	4a06      	ldr	r2, [pc, #24]	; (10c8c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_21+0x50>)
   10c72:	9b01      	ldr	r3, [sp, #4]
   10c74:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10c78:	1c5a      	adds	r2, r3, #1
   10c7a:	4904      	ldr	r1, [pc, #16]	; (10c8c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_21+0x50>)
   10c7c:	9b01      	ldr	r3, [sp, #4]
   10c7e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10c82:	bf00      	nop
   10c84:	b003      	add	sp, #12
   10c86:	f85d fb04 	ldr.w	pc, [sp], #4
   10c8a:	bf00      	nop
   10c8c:	1fff9424 	.word	0x1fff9424
   10c90:	1fff9420 	.word	0x1fff9420

00010c94 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_21>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_21(void)
{
   10c94:	b500      	push	{lr}
   10c96:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10c98:	f7f0 f840 	bl	d1c <Sys_GetCoreID>
   10c9c:	4603      	mov	r3, r0
   10c9e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_21[u32CoreId]--;
   10ca0:	4a0d      	ldr	r2, [pc, #52]	; (10cd8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_21+0x44>)
   10ca2:	9b01      	ldr	r3, [sp, #4]
   10ca4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10ca8:	1e5a      	subs	r2, r3, #1
   10caa:	490b      	ldr	r1, [pc, #44]	; (10cd8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_21+0x44>)
   10cac:	9b01      	ldr	r3, [sp, #4]
   10cae:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_21[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_21[u32CoreId]))         /*if interrupts were enabled*/
   10cb2:	4a0a      	ldr	r2, [pc, #40]	; (10cdc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_21+0x48>)
   10cb4:	9b01      	ldr	r3, [sp, #4]
   10cb6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10cba:	f003 0301 	and.w	r3, r3, #1
   10cbe:	2b00      	cmp	r3, #0
   10cc0:	d106      	bne.n	10cd0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_21+0x3c>
   10cc2:	4a05      	ldr	r2, [pc, #20]	; (10cd8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_21+0x44>)
   10cc4:	9b01      	ldr	r3, [sp, #4]
   10cc6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10cca:	2b00      	cmp	r3, #0
   10ccc:	d100      	bne.n	10cd0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_21+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   10cce:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10cd0:	bf00      	nop
   10cd2:	b003      	add	sp, #12
   10cd4:	f85d fb04 	ldr.w	pc, [sp], #4
   10cd8:	1fff9424 	.word	0x1fff9424
   10cdc:	1fff9420 	.word	0x1fff9420

00010ce0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_22>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_22(void)
{
   10ce0:	b500      	push	{lr}
   10ce2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10ce4:	f7f0 f81a 	bl	d1c <Sys_GetCoreID>
   10ce8:	4603      	mov	r3, r0
   10cea:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_22[u32CoreId])
   10cec:	4a10      	ldr	r2, [pc, #64]	; (10d30 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_22+0x50>)
   10cee:	9b01      	ldr	r3, [sp, #4]
   10cf0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10cf4:	2b00      	cmp	r3, #0
   10cf6:	d10d      	bne.n	10d14 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_22+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10cf8:	f7ef fe4e 	bl	998 <Adc_schm_read_msr>
   10cfc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   10cfe:	9b00      	ldr	r3, [sp, #0]
   10d00:	f003 0301 	and.w	r3, r3, #1
   10d04:	2b00      	cmp	r3, #0
   10d06:	d100      	bne.n	10d0a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_22+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10d08:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_22[u32CoreId] = msr;
   10d0a:	490a      	ldr	r1, [pc, #40]	; (10d34 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_22+0x54>)
   10d0c:	9b01      	ldr	r3, [sp, #4]
   10d0e:	9a00      	ldr	r2, [sp, #0]
   10d10:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_22[u32CoreId]++;
   10d14:	4a06      	ldr	r2, [pc, #24]	; (10d30 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_22+0x50>)
   10d16:	9b01      	ldr	r3, [sp, #4]
   10d18:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10d1c:	1c5a      	adds	r2, r3, #1
   10d1e:	4904      	ldr	r1, [pc, #16]	; (10d30 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_22+0x50>)
   10d20:	9b01      	ldr	r3, [sp, #4]
   10d22:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10d26:	bf00      	nop
   10d28:	b003      	add	sp, #12
   10d2a:	f85d fb04 	ldr.w	pc, [sp], #4
   10d2e:	bf00      	nop
   10d30:	1fff942c 	.word	0x1fff942c
   10d34:	1fff9428 	.word	0x1fff9428

00010d38 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_22>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_22(void)
{
   10d38:	b500      	push	{lr}
   10d3a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10d3c:	f7ef ffee 	bl	d1c <Sys_GetCoreID>
   10d40:	4603      	mov	r3, r0
   10d42:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_22[u32CoreId]--;
   10d44:	4a0d      	ldr	r2, [pc, #52]	; (10d7c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_22+0x44>)
   10d46:	9b01      	ldr	r3, [sp, #4]
   10d48:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10d4c:	1e5a      	subs	r2, r3, #1
   10d4e:	490b      	ldr	r1, [pc, #44]	; (10d7c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_22+0x44>)
   10d50:	9b01      	ldr	r3, [sp, #4]
   10d52:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_22[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_22[u32CoreId]))         /*if interrupts were enabled*/
   10d56:	4a0a      	ldr	r2, [pc, #40]	; (10d80 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_22+0x48>)
   10d58:	9b01      	ldr	r3, [sp, #4]
   10d5a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10d5e:	f003 0301 	and.w	r3, r3, #1
   10d62:	2b00      	cmp	r3, #0
   10d64:	d106      	bne.n	10d74 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_22+0x3c>
   10d66:	4a05      	ldr	r2, [pc, #20]	; (10d7c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_22+0x44>)
   10d68:	9b01      	ldr	r3, [sp, #4]
   10d6a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10d6e:	2b00      	cmp	r3, #0
   10d70:	d100      	bne.n	10d74 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_22+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   10d72:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10d74:	bf00      	nop
   10d76:	b003      	add	sp, #12
   10d78:	f85d fb04 	ldr.w	pc, [sp], #4
   10d7c:	1fff942c 	.word	0x1fff942c
   10d80:	1fff9428 	.word	0x1fff9428

00010d84 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_23>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_23(void)
{
   10d84:	b500      	push	{lr}
   10d86:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10d88:	f7ef ffc8 	bl	d1c <Sys_GetCoreID>
   10d8c:	4603      	mov	r3, r0
   10d8e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_23[u32CoreId])
   10d90:	4a10      	ldr	r2, [pc, #64]	; (10dd4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_23+0x50>)
   10d92:	9b01      	ldr	r3, [sp, #4]
   10d94:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10d98:	2b00      	cmp	r3, #0
   10d9a:	d10d      	bne.n	10db8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_23+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10d9c:	f7ef fdfc 	bl	998 <Adc_schm_read_msr>
   10da0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   10da2:	9b00      	ldr	r3, [sp, #0]
   10da4:	f003 0301 	and.w	r3, r3, #1
   10da8:	2b00      	cmp	r3, #0
   10daa:	d100      	bne.n	10dae <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_23+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10dac:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_23[u32CoreId] = msr;
   10dae:	490a      	ldr	r1, [pc, #40]	; (10dd8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_23+0x54>)
   10db0:	9b01      	ldr	r3, [sp, #4]
   10db2:	9a00      	ldr	r2, [sp, #0]
   10db4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_23[u32CoreId]++;
   10db8:	4a06      	ldr	r2, [pc, #24]	; (10dd4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_23+0x50>)
   10dba:	9b01      	ldr	r3, [sp, #4]
   10dbc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10dc0:	1c5a      	adds	r2, r3, #1
   10dc2:	4904      	ldr	r1, [pc, #16]	; (10dd4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_23+0x50>)
   10dc4:	9b01      	ldr	r3, [sp, #4]
   10dc6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10dca:	bf00      	nop
   10dcc:	b003      	add	sp, #12
   10dce:	f85d fb04 	ldr.w	pc, [sp], #4
   10dd2:	bf00      	nop
   10dd4:	1fff9434 	.word	0x1fff9434
   10dd8:	1fff9430 	.word	0x1fff9430

00010ddc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_23>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_23(void)
{
   10ddc:	b500      	push	{lr}
   10dde:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10de0:	f7ef ff9c 	bl	d1c <Sys_GetCoreID>
   10de4:	4603      	mov	r3, r0
   10de6:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_23[u32CoreId]--;
   10de8:	4a0d      	ldr	r2, [pc, #52]	; (10e20 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_23+0x44>)
   10dea:	9b01      	ldr	r3, [sp, #4]
   10dec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10df0:	1e5a      	subs	r2, r3, #1
   10df2:	490b      	ldr	r1, [pc, #44]	; (10e20 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_23+0x44>)
   10df4:	9b01      	ldr	r3, [sp, #4]
   10df6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_23[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_23[u32CoreId]))         /*if interrupts were enabled*/
   10dfa:	4a0a      	ldr	r2, [pc, #40]	; (10e24 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_23+0x48>)
   10dfc:	9b01      	ldr	r3, [sp, #4]
   10dfe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10e02:	f003 0301 	and.w	r3, r3, #1
   10e06:	2b00      	cmp	r3, #0
   10e08:	d106      	bne.n	10e18 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_23+0x3c>
   10e0a:	4a05      	ldr	r2, [pc, #20]	; (10e20 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_23+0x44>)
   10e0c:	9b01      	ldr	r3, [sp, #4]
   10e0e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10e12:	2b00      	cmp	r3, #0
   10e14:	d100      	bne.n	10e18 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_23+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   10e16:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10e18:	bf00      	nop
   10e1a:	b003      	add	sp, #12
   10e1c:	f85d fb04 	ldr.w	pc, [sp], #4
   10e20:	1fff9434 	.word	0x1fff9434
   10e24:	1fff9430 	.word	0x1fff9430

00010e28 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_24>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_24(void)
{
   10e28:	b500      	push	{lr}
   10e2a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10e2c:	f7ef ff76 	bl	d1c <Sys_GetCoreID>
   10e30:	4603      	mov	r3, r0
   10e32:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_24[u32CoreId])
   10e34:	4a10      	ldr	r2, [pc, #64]	; (10e78 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_24+0x50>)
   10e36:	9b01      	ldr	r3, [sp, #4]
   10e38:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10e3c:	2b00      	cmp	r3, #0
   10e3e:	d10d      	bne.n	10e5c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_24+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10e40:	f7ef fdaa 	bl	998 <Adc_schm_read_msr>
   10e44:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   10e46:	9b00      	ldr	r3, [sp, #0]
   10e48:	f003 0301 	and.w	r3, r3, #1
   10e4c:	2b00      	cmp	r3, #0
   10e4e:	d100      	bne.n	10e52 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_24+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10e50:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_24[u32CoreId] = msr;
   10e52:	490a      	ldr	r1, [pc, #40]	; (10e7c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_24+0x54>)
   10e54:	9b01      	ldr	r3, [sp, #4]
   10e56:	9a00      	ldr	r2, [sp, #0]
   10e58:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_24[u32CoreId]++;
   10e5c:	4a06      	ldr	r2, [pc, #24]	; (10e78 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_24+0x50>)
   10e5e:	9b01      	ldr	r3, [sp, #4]
   10e60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10e64:	1c5a      	adds	r2, r3, #1
   10e66:	4904      	ldr	r1, [pc, #16]	; (10e78 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_24+0x50>)
   10e68:	9b01      	ldr	r3, [sp, #4]
   10e6a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10e6e:	bf00      	nop
   10e70:	b003      	add	sp, #12
   10e72:	f85d fb04 	ldr.w	pc, [sp], #4
   10e76:	bf00      	nop
   10e78:	1fff943c 	.word	0x1fff943c
   10e7c:	1fff9438 	.word	0x1fff9438

00010e80 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_24>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_24(void)
{
   10e80:	b500      	push	{lr}
   10e82:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10e84:	f7ef ff4a 	bl	d1c <Sys_GetCoreID>
   10e88:	4603      	mov	r3, r0
   10e8a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_24[u32CoreId]--;
   10e8c:	4a0d      	ldr	r2, [pc, #52]	; (10ec4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_24+0x44>)
   10e8e:	9b01      	ldr	r3, [sp, #4]
   10e90:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10e94:	1e5a      	subs	r2, r3, #1
   10e96:	490b      	ldr	r1, [pc, #44]	; (10ec4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_24+0x44>)
   10e98:	9b01      	ldr	r3, [sp, #4]
   10e9a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_24[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_24[u32CoreId]))         /*if interrupts were enabled*/
   10e9e:	4a0a      	ldr	r2, [pc, #40]	; (10ec8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_24+0x48>)
   10ea0:	9b01      	ldr	r3, [sp, #4]
   10ea2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10ea6:	f003 0301 	and.w	r3, r3, #1
   10eaa:	2b00      	cmp	r3, #0
   10eac:	d106      	bne.n	10ebc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_24+0x3c>
   10eae:	4a05      	ldr	r2, [pc, #20]	; (10ec4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_24+0x44>)
   10eb0:	9b01      	ldr	r3, [sp, #4]
   10eb2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10eb6:	2b00      	cmp	r3, #0
   10eb8:	d100      	bne.n	10ebc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_24+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   10eba:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10ebc:	bf00      	nop
   10ebe:	b003      	add	sp, #12
   10ec0:	f85d fb04 	ldr.w	pc, [sp], #4
   10ec4:	1fff943c 	.word	0x1fff943c
   10ec8:	1fff9438 	.word	0x1fff9438

00010ecc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_25>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_25(void)
{
   10ecc:	b500      	push	{lr}
   10ece:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10ed0:	f7ef ff24 	bl	d1c <Sys_GetCoreID>
   10ed4:	4603      	mov	r3, r0
   10ed6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_25[u32CoreId])
   10ed8:	4a10      	ldr	r2, [pc, #64]	; (10f1c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_25+0x50>)
   10eda:	9b01      	ldr	r3, [sp, #4]
   10edc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10ee0:	2b00      	cmp	r3, #0
   10ee2:	d10d      	bne.n	10f00 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_25+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10ee4:	f7ef fd58 	bl	998 <Adc_schm_read_msr>
   10ee8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   10eea:	9b00      	ldr	r3, [sp, #0]
   10eec:	f003 0301 	and.w	r3, r3, #1
   10ef0:	2b00      	cmp	r3, #0
   10ef2:	d100      	bne.n	10ef6 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_25+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10ef4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_25[u32CoreId] = msr;
   10ef6:	490a      	ldr	r1, [pc, #40]	; (10f20 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_25+0x54>)
   10ef8:	9b01      	ldr	r3, [sp, #4]
   10efa:	9a00      	ldr	r2, [sp, #0]
   10efc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_25[u32CoreId]++;
   10f00:	4a06      	ldr	r2, [pc, #24]	; (10f1c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_25+0x50>)
   10f02:	9b01      	ldr	r3, [sp, #4]
   10f04:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10f08:	1c5a      	adds	r2, r3, #1
   10f0a:	4904      	ldr	r1, [pc, #16]	; (10f1c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_25+0x50>)
   10f0c:	9b01      	ldr	r3, [sp, #4]
   10f0e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10f12:	bf00      	nop
   10f14:	b003      	add	sp, #12
   10f16:	f85d fb04 	ldr.w	pc, [sp], #4
   10f1a:	bf00      	nop
   10f1c:	1fff9444 	.word	0x1fff9444
   10f20:	1fff9440 	.word	0x1fff9440

00010f24 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_25>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_25(void)
{
   10f24:	b500      	push	{lr}
   10f26:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10f28:	f7ef fef8 	bl	d1c <Sys_GetCoreID>
   10f2c:	4603      	mov	r3, r0
   10f2e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_25[u32CoreId]--;
   10f30:	4a0d      	ldr	r2, [pc, #52]	; (10f68 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_25+0x44>)
   10f32:	9b01      	ldr	r3, [sp, #4]
   10f34:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10f38:	1e5a      	subs	r2, r3, #1
   10f3a:	490b      	ldr	r1, [pc, #44]	; (10f68 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_25+0x44>)
   10f3c:	9b01      	ldr	r3, [sp, #4]
   10f3e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_25[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_25[u32CoreId]))         /*if interrupts were enabled*/
   10f42:	4a0a      	ldr	r2, [pc, #40]	; (10f6c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_25+0x48>)
   10f44:	9b01      	ldr	r3, [sp, #4]
   10f46:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10f4a:	f003 0301 	and.w	r3, r3, #1
   10f4e:	2b00      	cmp	r3, #0
   10f50:	d106      	bne.n	10f60 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_25+0x3c>
   10f52:	4a05      	ldr	r2, [pc, #20]	; (10f68 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_25+0x44>)
   10f54:	9b01      	ldr	r3, [sp, #4]
   10f56:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10f5a:	2b00      	cmp	r3, #0
   10f5c:	d100      	bne.n	10f60 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_25+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   10f5e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10f60:	bf00      	nop
   10f62:	b003      	add	sp, #12
   10f64:	f85d fb04 	ldr.w	pc, [sp], #4
   10f68:	1fff9444 	.word	0x1fff9444
   10f6c:	1fff9440 	.word	0x1fff9440

00010f70 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_26>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_26(void)
{
   10f70:	b500      	push	{lr}
   10f72:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10f74:	f7ef fed2 	bl	d1c <Sys_GetCoreID>
   10f78:	4603      	mov	r3, r0
   10f7a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_26[u32CoreId])
   10f7c:	4a10      	ldr	r2, [pc, #64]	; (10fc0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_26+0x50>)
   10f7e:	9b01      	ldr	r3, [sp, #4]
   10f80:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10f84:	2b00      	cmp	r3, #0
   10f86:	d10d      	bne.n	10fa4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_26+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10f88:	f7ef fd06 	bl	998 <Adc_schm_read_msr>
   10f8c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   10f8e:	9b00      	ldr	r3, [sp, #0]
   10f90:	f003 0301 	and.w	r3, r3, #1
   10f94:	2b00      	cmp	r3, #0
   10f96:	d100      	bne.n	10f9a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_26+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10f98:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_26[u32CoreId] = msr;
   10f9a:	490a      	ldr	r1, [pc, #40]	; (10fc4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_26+0x54>)
   10f9c:	9b01      	ldr	r3, [sp, #4]
   10f9e:	9a00      	ldr	r2, [sp, #0]
   10fa0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_26[u32CoreId]++;
   10fa4:	4a06      	ldr	r2, [pc, #24]	; (10fc0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_26+0x50>)
   10fa6:	9b01      	ldr	r3, [sp, #4]
   10fa8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10fac:	1c5a      	adds	r2, r3, #1
   10fae:	4904      	ldr	r1, [pc, #16]	; (10fc0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_26+0x50>)
   10fb0:	9b01      	ldr	r3, [sp, #4]
   10fb2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10fb6:	bf00      	nop
   10fb8:	b003      	add	sp, #12
   10fba:	f85d fb04 	ldr.w	pc, [sp], #4
   10fbe:	bf00      	nop
   10fc0:	1fff944c 	.word	0x1fff944c
   10fc4:	1fff9448 	.word	0x1fff9448

00010fc8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_26>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_26(void)
{
   10fc8:	b500      	push	{lr}
   10fca:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10fcc:	f7ef fea6 	bl	d1c <Sys_GetCoreID>
   10fd0:	4603      	mov	r3, r0
   10fd2:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_26[u32CoreId]--;
   10fd4:	4a0d      	ldr	r2, [pc, #52]	; (1100c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_26+0x44>)
   10fd6:	9b01      	ldr	r3, [sp, #4]
   10fd8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10fdc:	1e5a      	subs	r2, r3, #1
   10fde:	490b      	ldr	r1, [pc, #44]	; (1100c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_26+0x44>)
   10fe0:	9b01      	ldr	r3, [sp, #4]
   10fe2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_26[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_26[u32CoreId]))         /*if interrupts were enabled*/
   10fe6:	4a0a      	ldr	r2, [pc, #40]	; (11010 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_26+0x48>)
   10fe8:	9b01      	ldr	r3, [sp, #4]
   10fea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10fee:	f003 0301 	and.w	r3, r3, #1
   10ff2:	2b00      	cmp	r3, #0
   10ff4:	d106      	bne.n	11004 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_26+0x3c>
   10ff6:	4a05      	ldr	r2, [pc, #20]	; (1100c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_26+0x44>)
   10ff8:	9b01      	ldr	r3, [sp, #4]
   10ffa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10ffe:	2b00      	cmp	r3, #0
   11000:	d100      	bne.n	11004 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_26+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   11002:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11004:	bf00      	nop
   11006:	b003      	add	sp, #12
   11008:	f85d fb04 	ldr.w	pc, [sp], #4
   1100c:	1fff944c 	.word	0x1fff944c
   11010:	1fff9448 	.word	0x1fff9448

00011014 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_27>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_27(void)
{
   11014:	b500      	push	{lr}
   11016:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11018:	f7ef fe80 	bl	d1c <Sys_GetCoreID>
   1101c:	4603      	mov	r3, r0
   1101e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_27[u32CoreId])
   11020:	4a10      	ldr	r2, [pc, #64]	; (11064 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_27+0x50>)
   11022:	9b01      	ldr	r3, [sp, #4]
   11024:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11028:	2b00      	cmp	r3, #0
   1102a:	d10d      	bne.n	11048 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_27+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   1102c:	f7ef fcb4 	bl	998 <Adc_schm_read_msr>
   11030:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   11032:	9b00      	ldr	r3, [sp, #0]
   11034:	f003 0301 	and.w	r3, r3, #1
   11038:	2b00      	cmp	r3, #0
   1103a:	d100      	bne.n	1103e <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_27+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   1103c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_27[u32CoreId] = msr;
   1103e:	490a      	ldr	r1, [pc, #40]	; (11068 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_27+0x54>)
   11040:	9b01      	ldr	r3, [sp, #4]
   11042:	9a00      	ldr	r2, [sp, #0]
   11044:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_27[u32CoreId]++;
   11048:	4a06      	ldr	r2, [pc, #24]	; (11064 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_27+0x50>)
   1104a:	9b01      	ldr	r3, [sp, #4]
   1104c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11050:	1c5a      	adds	r2, r3, #1
   11052:	4904      	ldr	r1, [pc, #16]	; (11064 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_27+0x50>)
   11054:	9b01      	ldr	r3, [sp, #4]
   11056:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1105a:	bf00      	nop
   1105c:	b003      	add	sp, #12
   1105e:	f85d fb04 	ldr.w	pc, [sp], #4
   11062:	bf00      	nop
   11064:	1fff9454 	.word	0x1fff9454
   11068:	1fff9450 	.word	0x1fff9450

0001106c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_27>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_27(void)
{
   1106c:	b500      	push	{lr}
   1106e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11070:	f7ef fe54 	bl	d1c <Sys_GetCoreID>
   11074:	4603      	mov	r3, r0
   11076:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_27[u32CoreId]--;
   11078:	4a0d      	ldr	r2, [pc, #52]	; (110b0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_27+0x44>)
   1107a:	9b01      	ldr	r3, [sp, #4]
   1107c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11080:	1e5a      	subs	r2, r3, #1
   11082:	490b      	ldr	r1, [pc, #44]	; (110b0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_27+0x44>)
   11084:	9b01      	ldr	r3, [sp, #4]
   11086:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_27[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_27[u32CoreId]))         /*if interrupts were enabled*/
   1108a:	4a0a      	ldr	r2, [pc, #40]	; (110b4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_27+0x48>)
   1108c:	9b01      	ldr	r3, [sp, #4]
   1108e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11092:	f003 0301 	and.w	r3, r3, #1
   11096:	2b00      	cmp	r3, #0
   11098:	d106      	bne.n	110a8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_27+0x3c>
   1109a:	4a05      	ldr	r2, [pc, #20]	; (110b0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_27+0x44>)
   1109c:	9b01      	ldr	r3, [sp, #4]
   1109e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   110a2:	2b00      	cmp	r3, #0
   110a4:	d100      	bne.n	110a8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_27+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   110a6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   110a8:	bf00      	nop
   110aa:	b003      	add	sp, #12
   110ac:	f85d fb04 	ldr.w	pc, [sp], #4
   110b0:	1fff9454 	.word	0x1fff9454
   110b4:	1fff9450 	.word	0x1fff9450

000110b8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_28>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_28(void)
{
   110b8:	b500      	push	{lr}
   110ba:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   110bc:	f7ef fe2e 	bl	d1c <Sys_GetCoreID>
   110c0:	4603      	mov	r3, r0
   110c2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_28[u32CoreId])
   110c4:	4a10      	ldr	r2, [pc, #64]	; (11108 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_28+0x50>)
   110c6:	9b01      	ldr	r3, [sp, #4]
   110c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   110cc:	2b00      	cmp	r3, #0
   110ce:	d10d      	bne.n	110ec <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_28+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   110d0:	f7ef fc62 	bl	998 <Adc_schm_read_msr>
   110d4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   110d6:	9b00      	ldr	r3, [sp, #0]
   110d8:	f003 0301 	and.w	r3, r3, #1
   110dc:	2b00      	cmp	r3, #0
   110de:	d100      	bne.n	110e2 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_28+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   110e0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_28[u32CoreId] = msr;
   110e2:	490a      	ldr	r1, [pc, #40]	; (1110c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_28+0x54>)
   110e4:	9b01      	ldr	r3, [sp, #4]
   110e6:	9a00      	ldr	r2, [sp, #0]
   110e8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_28[u32CoreId]++;
   110ec:	4a06      	ldr	r2, [pc, #24]	; (11108 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_28+0x50>)
   110ee:	9b01      	ldr	r3, [sp, #4]
   110f0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   110f4:	1c5a      	adds	r2, r3, #1
   110f6:	4904      	ldr	r1, [pc, #16]	; (11108 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_28+0x50>)
   110f8:	9b01      	ldr	r3, [sp, #4]
   110fa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   110fe:	bf00      	nop
   11100:	b003      	add	sp, #12
   11102:	f85d fb04 	ldr.w	pc, [sp], #4
   11106:	bf00      	nop
   11108:	1fff945c 	.word	0x1fff945c
   1110c:	1fff9458 	.word	0x1fff9458

00011110 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_28>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_28(void)
{
   11110:	b500      	push	{lr}
   11112:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11114:	f7ef fe02 	bl	d1c <Sys_GetCoreID>
   11118:	4603      	mov	r3, r0
   1111a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_28[u32CoreId]--;
   1111c:	4a0d      	ldr	r2, [pc, #52]	; (11154 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_28+0x44>)
   1111e:	9b01      	ldr	r3, [sp, #4]
   11120:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11124:	1e5a      	subs	r2, r3, #1
   11126:	490b      	ldr	r1, [pc, #44]	; (11154 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_28+0x44>)
   11128:	9b01      	ldr	r3, [sp, #4]
   1112a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_28[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_28[u32CoreId]))         /*if interrupts were enabled*/
   1112e:	4a0a      	ldr	r2, [pc, #40]	; (11158 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_28+0x48>)
   11130:	9b01      	ldr	r3, [sp, #4]
   11132:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11136:	f003 0301 	and.w	r3, r3, #1
   1113a:	2b00      	cmp	r3, #0
   1113c:	d106      	bne.n	1114c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_28+0x3c>
   1113e:	4a05      	ldr	r2, [pc, #20]	; (11154 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_28+0x44>)
   11140:	9b01      	ldr	r3, [sp, #4]
   11142:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11146:	2b00      	cmp	r3, #0
   11148:	d100      	bne.n	1114c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_28+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1114a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   1114c:	bf00      	nop
   1114e:	b003      	add	sp, #12
   11150:	f85d fb04 	ldr.w	pc, [sp], #4
   11154:	1fff945c 	.word	0x1fff945c
   11158:	1fff9458 	.word	0x1fff9458

0001115c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_29>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_29(void)
{
   1115c:	b500      	push	{lr}
   1115e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11160:	f7ef fddc 	bl	d1c <Sys_GetCoreID>
   11164:	4603      	mov	r3, r0
   11166:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_29[u32CoreId])
   11168:	4a10      	ldr	r2, [pc, #64]	; (111ac <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_29+0x50>)
   1116a:	9b01      	ldr	r3, [sp, #4]
   1116c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11170:	2b00      	cmp	r3, #0
   11172:	d10d      	bne.n	11190 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_29+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11174:	f7ef fc10 	bl	998 <Adc_schm_read_msr>
   11178:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1117a:	9b00      	ldr	r3, [sp, #0]
   1117c:	f003 0301 	and.w	r3, r3, #1
   11180:	2b00      	cmp	r3, #0
   11182:	d100      	bne.n	11186 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_29+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11184:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_29[u32CoreId] = msr;
   11186:	490a      	ldr	r1, [pc, #40]	; (111b0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_29+0x54>)
   11188:	9b01      	ldr	r3, [sp, #4]
   1118a:	9a00      	ldr	r2, [sp, #0]
   1118c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_29[u32CoreId]++;
   11190:	4a06      	ldr	r2, [pc, #24]	; (111ac <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_29+0x50>)
   11192:	9b01      	ldr	r3, [sp, #4]
   11194:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11198:	1c5a      	adds	r2, r3, #1
   1119a:	4904      	ldr	r1, [pc, #16]	; (111ac <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_29+0x50>)
   1119c:	9b01      	ldr	r3, [sp, #4]
   1119e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   111a2:	bf00      	nop
   111a4:	b003      	add	sp, #12
   111a6:	f85d fb04 	ldr.w	pc, [sp], #4
   111aa:	bf00      	nop
   111ac:	1fff9464 	.word	0x1fff9464
   111b0:	1fff9460 	.word	0x1fff9460

000111b4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_29>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_29(void)
{
   111b4:	b500      	push	{lr}
   111b6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   111b8:	f7ef fdb0 	bl	d1c <Sys_GetCoreID>
   111bc:	4603      	mov	r3, r0
   111be:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_29[u32CoreId]--;
   111c0:	4a0d      	ldr	r2, [pc, #52]	; (111f8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_29+0x44>)
   111c2:	9b01      	ldr	r3, [sp, #4]
   111c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   111c8:	1e5a      	subs	r2, r3, #1
   111ca:	490b      	ldr	r1, [pc, #44]	; (111f8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_29+0x44>)
   111cc:	9b01      	ldr	r3, [sp, #4]
   111ce:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_29[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_29[u32CoreId]))         /*if interrupts were enabled*/
   111d2:	4a0a      	ldr	r2, [pc, #40]	; (111fc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_29+0x48>)
   111d4:	9b01      	ldr	r3, [sp, #4]
   111d6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   111da:	f003 0301 	and.w	r3, r3, #1
   111de:	2b00      	cmp	r3, #0
   111e0:	d106      	bne.n	111f0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_29+0x3c>
   111e2:	4a05      	ldr	r2, [pc, #20]	; (111f8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_29+0x44>)
   111e4:	9b01      	ldr	r3, [sp, #4]
   111e6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   111ea:	2b00      	cmp	r3, #0
   111ec:	d100      	bne.n	111f0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_29+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   111ee:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   111f0:	bf00      	nop
   111f2:	b003      	add	sp, #12
   111f4:	f85d fb04 	ldr.w	pc, [sp], #4
   111f8:	1fff9464 	.word	0x1fff9464
   111fc:	1fff9460 	.word	0x1fff9460

00011200 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_30>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_30(void)
{
   11200:	b500      	push	{lr}
   11202:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11204:	f7ef fd8a 	bl	d1c <Sys_GetCoreID>
   11208:	4603      	mov	r3, r0
   1120a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_30[u32CoreId])
   1120c:	4a10      	ldr	r2, [pc, #64]	; (11250 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_30+0x50>)
   1120e:	9b01      	ldr	r3, [sp, #4]
   11210:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11214:	2b00      	cmp	r3, #0
   11216:	d10d      	bne.n	11234 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_30+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11218:	f7ef fbbe 	bl	998 <Adc_schm_read_msr>
   1121c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1121e:	9b00      	ldr	r3, [sp, #0]
   11220:	f003 0301 	and.w	r3, r3, #1
   11224:	2b00      	cmp	r3, #0
   11226:	d100      	bne.n	1122a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_30+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11228:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_30[u32CoreId] = msr;
   1122a:	490a      	ldr	r1, [pc, #40]	; (11254 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_30+0x54>)
   1122c:	9b01      	ldr	r3, [sp, #4]
   1122e:	9a00      	ldr	r2, [sp, #0]
   11230:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_30[u32CoreId]++;
   11234:	4a06      	ldr	r2, [pc, #24]	; (11250 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_30+0x50>)
   11236:	9b01      	ldr	r3, [sp, #4]
   11238:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1123c:	1c5a      	adds	r2, r3, #1
   1123e:	4904      	ldr	r1, [pc, #16]	; (11250 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_30+0x50>)
   11240:	9b01      	ldr	r3, [sp, #4]
   11242:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11246:	bf00      	nop
   11248:	b003      	add	sp, #12
   1124a:	f85d fb04 	ldr.w	pc, [sp], #4
   1124e:	bf00      	nop
   11250:	1fff946c 	.word	0x1fff946c
   11254:	1fff9468 	.word	0x1fff9468

00011258 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_30>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_30(void)
{
   11258:	b500      	push	{lr}
   1125a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1125c:	f7ef fd5e 	bl	d1c <Sys_GetCoreID>
   11260:	4603      	mov	r3, r0
   11262:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_30[u32CoreId]--;
   11264:	4a0d      	ldr	r2, [pc, #52]	; (1129c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_30+0x44>)
   11266:	9b01      	ldr	r3, [sp, #4]
   11268:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1126c:	1e5a      	subs	r2, r3, #1
   1126e:	490b      	ldr	r1, [pc, #44]	; (1129c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_30+0x44>)
   11270:	9b01      	ldr	r3, [sp, #4]
   11272:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_30[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_30[u32CoreId]))         /*if interrupts were enabled*/
   11276:	4a0a      	ldr	r2, [pc, #40]	; (112a0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_30+0x48>)
   11278:	9b01      	ldr	r3, [sp, #4]
   1127a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1127e:	f003 0301 	and.w	r3, r3, #1
   11282:	2b00      	cmp	r3, #0
   11284:	d106      	bne.n	11294 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_30+0x3c>
   11286:	4a05      	ldr	r2, [pc, #20]	; (1129c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_30+0x44>)
   11288:	9b01      	ldr	r3, [sp, #4]
   1128a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1128e:	2b00      	cmp	r3, #0
   11290:	d100      	bne.n	11294 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_30+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   11292:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11294:	bf00      	nop
   11296:	b003      	add	sp, #12
   11298:	f85d fb04 	ldr.w	pc, [sp], #4
   1129c:	1fff946c 	.word	0x1fff946c
   112a0:	1fff9468 	.word	0x1fff9468

000112a4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_31>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_31(void)
{
   112a4:	b500      	push	{lr}
   112a6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   112a8:	f7ef fd38 	bl	d1c <Sys_GetCoreID>
   112ac:	4603      	mov	r3, r0
   112ae:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_31[u32CoreId])
   112b0:	4a10      	ldr	r2, [pc, #64]	; (112f4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_31+0x50>)
   112b2:	9b01      	ldr	r3, [sp, #4]
   112b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   112b8:	2b00      	cmp	r3, #0
   112ba:	d10d      	bne.n	112d8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_31+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   112bc:	f7ef fb6c 	bl	998 <Adc_schm_read_msr>
   112c0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   112c2:	9b00      	ldr	r3, [sp, #0]
   112c4:	f003 0301 	and.w	r3, r3, #1
   112c8:	2b00      	cmp	r3, #0
   112ca:	d100      	bne.n	112ce <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_31+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   112cc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_31[u32CoreId] = msr;
   112ce:	490a      	ldr	r1, [pc, #40]	; (112f8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_31+0x54>)
   112d0:	9b01      	ldr	r3, [sp, #4]
   112d2:	9a00      	ldr	r2, [sp, #0]
   112d4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_31[u32CoreId]++;
   112d8:	4a06      	ldr	r2, [pc, #24]	; (112f4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_31+0x50>)
   112da:	9b01      	ldr	r3, [sp, #4]
   112dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   112e0:	1c5a      	adds	r2, r3, #1
   112e2:	4904      	ldr	r1, [pc, #16]	; (112f4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_31+0x50>)
   112e4:	9b01      	ldr	r3, [sp, #4]
   112e6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   112ea:	bf00      	nop
   112ec:	b003      	add	sp, #12
   112ee:	f85d fb04 	ldr.w	pc, [sp], #4
   112f2:	bf00      	nop
   112f4:	1fff9474 	.word	0x1fff9474
   112f8:	1fff9470 	.word	0x1fff9470

000112fc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_31>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_31(void)
{
   112fc:	b500      	push	{lr}
   112fe:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11300:	f7ef fd0c 	bl	d1c <Sys_GetCoreID>
   11304:	4603      	mov	r3, r0
   11306:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_31[u32CoreId]--;
   11308:	4a0d      	ldr	r2, [pc, #52]	; (11340 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_31+0x44>)
   1130a:	9b01      	ldr	r3, [sp, #4]
   1130c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11310:	1e5a      	subs	r2, r3, #1
   11312:	490b      	ldr	r1, [pc, #44]	; (11340 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_31+0x44>)
   11314:	9b01      	ldr	r3, [sp, #4]
   11316:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_31[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_31[u32CoreId]))         /*if interrupts were enabled*/
   1131a:	4a0a      	ldr	r2, [pc, #40]	; (11344 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_31+0x48>)
   1131c:	9b01      	ldr	r3, [sp, #4]
   1131e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11322:	f003 0301 	and.w	r3, r3, #1
   11326:	2b00      	cmp	r3, #0
   11328:	d106      	bne.n	11338 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_31+0x3c>
   1132a:	4a05      	ldr	r2, [pc, #20]	; (11340 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_31+0x44>)
   1132c:	9b01      	ldr	r3, [sp, #4]
   1132e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11332:	2b00      	cmp	r3, #0
   11334:	d100      	bne.n	11338 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_31+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   11336:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11338:	bf00      	nop
   1133a:	b003      	add	sp, #12
   1133c:	f85d fb04 	ldr.w	pc, [sp], #4
   11340:	1fff9474 	.word	0x1fff9474
   11344:	1fff9470 	.word	0x1fff9470

00011348 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_32>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_32(void)
{
   11348:	b500      	push	{lr}
   1134a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1134c:	f7ef fce6 	bl	d1c <Sys_GetCoreID>
   11350:	4603      	mov	r3, r0
   11352:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_32[u32CoreId])
   11354:	4a10      	ldr	r2, [pc, #64]	; (11398 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_32+0x50>)
   11356:	9b01      	ldr	r3, [sp, #4]
   11358:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1135c:	2b00      	cmp	r3, #0
   1135e:	d10d      	bne.n	1137c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_32+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11360:	f7ef fb1a 	bl	998 <Adc_schm_read_msr>
   11364:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   11366:	9b00      	ldr	r3, [sp, #0]
   11368:	f003 0301 	and.w	r3, r3, #1
   1136c:	2b00      	cmp	r3, #0
   1136e:	d100      	bne.n	11372 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_32+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11370:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_32[u32CoreId] = msr;
   11372:	490a      	ldr	r1, [pc, #40]	; (1139c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_32+0x54>)
   11374:	9b01      	ldr	r3, [sp, #4]
   11376:	9a00      	ldr	r2, [sp, #0]
   11378:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_32[u32CoreId]++;
   1137c:	4a06      	ldr	r2, [pc, #24]	; (11398 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_32+0x50>)
   1137e:	9b01      	ldr	r3, [sp, #4]
   11380:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11384:	1c5a      	adds	r2, r3, #1
   11386:	4904      	ldr	r1, [pc, #16]	; (11398 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_32+0x50>)
   11388:	9b01      	ldr	r3, [sp, #4]
   1138a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1138e:	bf00      	nop
   11390:	b003      	add	sp, #12
   11392:	f85d fb04 	ldr.w	pc, [sp], #4
   11396:	bf00      	nop
   11398:	1fff947c 	.word	0x1fff947c
   1139c:	1fff9478 	.word	0x1fff9478

000113a0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_32>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_32(void)
{
   113a0:	b500      	push	{lr}
   113a2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   113a4:	f7ef fcba 	bl	d1c <Sys_GetCoreID>
   113a8:	4603      	mov	r3, r0
   113aa:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_32[u32CoreId]--;
   113ac:	4a0d      	ldr	r2, [pc, #52]	; (113e4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_32+0x44>)
   113ae:	9b01      	ldr	r3, [sp, #4]
   113b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   113b4:	1e5a      	subs	r2, r3, #1
   113b6:	490b      	ldr	r1, [pc, #44]	; (113e4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_32+0x44>)
   113b8:	9b01      	ldr	r3, [sp, #4]
   113ba:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_32[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_32[u32CoreId]))         /*if interrupts were enabled*/
   113be:	4a0a      	ldr	r2, [pc, #40]	; (113e8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_32+0x48>)
   113c0:	9b01      	ldr	r3, [sp, #4]
   113c2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   113c6:	f003 0301 	and.w	r3, r3, #1
   113ca:	2b00      	cmp	r3, #0
   113cc:	d106      	bne.n	113dc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_32+0x3c>
   113ce:	4a05      	ldr	r2, [pc, #20]	; (113e4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_32+0x44>)
   113d0:	9b01      	ldr	r3, [sp, #4]
   113d2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   113d6:	2b00      	cmp	r3, #0
   113d8:	d100      	bne.n	113dc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_32+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   113da:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   113dc:	bf00      	nop
   113de:	b003      	add	sp, #12
   113e0:	f85d fb04 	ldr.w	pc, [sp], #4
   113e4:	1fff947c 	.word	0x1fff947c
   113e8:	1fff9478 	.word	0x1fff9478

000113ec <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_33>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_33(void)
{
   113ec:	b500      	push	{lr}
   113ee:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   113f0:	f7ef fc94 	bl	d1c <Sys_GetCoreID>
   113f4:	4603      	mov	r3, r0
   113f6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_33[u32CoreId])
   113f8:	4a10      	ldr	r2, [pc, #64]	; (1143c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_33+0x50>)
   113fa:	9b01      	ldr	r3, [sp, #4]
   113fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11400:	2b00      	cmp	r3, #0
   11402:	d10d      	bne.n	11420 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_33+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11404:	f7ef fac8 	bl	998 <Adc_schm_read_msr>
   11408:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1140a:	9b00      	ldr	r3, [sp, #0]
   1140c:	f003 0301 	and.w	r3, r3, #1
   11410:	2b00      	cmp	r3, #0
   11412:	d100      	bne.n	11416 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_33+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11414:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_33[u32CoreId] = msr;
   11416:	490a      	ldr	r1, [pc, #40]	; (11440 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_33+0x54>)
   11418:	9b01      	ldr	r3, [sp, #4]
   1141a:	9a00      	ldr	r2, [sp, #0]
   1141c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_33[u32CoreId]++;
   11420:	4a06      	ldr	r2, [pc, #24]	; (1143c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_33+0x50>)
   11422:	9b01      	ldr	r3, [sp, #4]
   11424:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11428:	1c5a      	adds	r2, r3, #1
   1142a:	4904      	ldr	r1, [pc, #16]	; (1143c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_33+0x50>)
   1142c:	9b01      	ldr	r3, [sp, #4]
   1142e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11432:	bf00      	nop
   11434:	b003      	add	sp, #12
   11436:	f85d fb04 	ldr.w	pc, [sp], #4
   1143a:	bf00      	nop
   1143c:	1fff9484 	.word	0x1fff9484
   11440:	1fff9480 	.word	0x1fff9480

00011444 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_33>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_33(void)
{
   11444:	b500      	push	{lr}
   11446:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11448:	f7ef fc68 	bl	d1c <Sys_GetCoreID>
   1144c:	4603      	mov	r3, r0
   1144e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_33[u32CoreId]--;
   11450:	4a0d      	ldr	r2, [pc, #52]	; (11488 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_33+0x44>)
   11452:	9b01      	ldr	r3, [sp, #4]
   11454:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11458:	1e5a      	subs	r2, r3, #1
   1145a:	490b      	ldr	r1, [pc, #44]	; (11488 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_33+0x44>)
   1145c:	9b01      	ldr	r3, [sp, #4]
   1145e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_33[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_33[u32CoreId]))         /*if interrupts were enabled*/
   11462:	4a0a      	ldr	r2, [pc, #40]	; (1148c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_33+0x48>)
   11464:	9b01      	ldr	r3, [sp, #4]
   11466:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1146a:	f003 0301 	and.w	r3, r3, #1
   1146e:	2b00      	cmp	r3, #0
   11470:	d106      	bne.n	11480 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_33+0x3c>
   11472:	4a05      	ldr	r2, [pc, #20]	; (11488 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_33+0x44>)
   11474:	9b01      	ldr	r3, [sp, #4]
   11476:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1147a:	2b00      	cmp	r3, #0
   1147c:	d100      	bne.n	11480 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_33+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1147e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11480:	bf00      	nop
   11482:	b003      	add	sp, #12
   11484:	f85d fb04 	ldr.w	pc, [sp], #4
   11488:	1fff9484 	.word	0x1fff9484
   1148c:	1fff9480 	.word	0x1fff9480

00011490 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_34>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_34(void)
{
   11490:	b500      	push	{lr}
   11492:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11494:	f7ef fc42 	bl	d1c <Sys_GetCoreID>
   11498:	4603      	mov	r3, r0
   1149a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_34[u32CoreId])
   1149c:	4a10      	ldr	r2, [pc, #64]	; (114e0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_34+0x50>)
   1149e:	9b01      	ldr	r3, [sp, #4]
   114a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   114a4:	2b00      	cmp	r3, #0
   114a6:	d10d      	bne.n	114c4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_34+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   114a8:	f7ef fa76 	bl	998 <Adc_schm_read_msr>
   114ac:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   114ae:	9b00      	ldr	r3, [sp, #0]
   114b0:	f003 0301 	and.w	r3, r3, #1
   114b4:	2b00      	cmp	r3, #0
   114b6:	d100      	bne.n	114ba <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_34+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   114b8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_34[u32CoreId] = msr;
   114ba:	490a      	ldr	r1, [pc, #40]	; (114e4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_34+0x54>)
   114bc:	9b01      	ldr	r3, [sp, #4]
   114be:	9a00      	ldr	r2, [sp, #0]
   114c0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_34[u32CoreId]++;
   114c4:	4a06      	ldr	r2, [pc, #24]	; (114e0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_34+0x50>)
   114c6:	9b01      	ldr	r3, [sp, #4]
   114c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   114cc:	1c5a      	adds	r2, r3, #1
   114ce:	4904      	ldr	r1, [pc, #16]	; (114e0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_34+0x50>)
   114d0:	9b01      	ldr	r3, [sp, #4]
   114d2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   114d6:	bf00      	nop
   114d8:	b003      	add	sp, #12
   114da:	f85d fb04 	ldr.w	pc, [sp], #4
   114de:	bf00      	nop
   114e0:	1fff948c 	.word	0x1fff948c
   114e4:	1fff9488 	.word	0x1fff9488

000114e8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_34>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_34(void)
{
   114e8:	b500      	push	{lr}
   114ea:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   114ec:	f7ef fc16 	bl	d1c <Sys_GetCoreID>
   114f0:	4603      	mov	r3, r0
   114f2:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_34[u32CoreId]--;
   114f4:	4a0d      	ldr	r2, [pc, #52]	; (1152c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_34+0x44>)
   114f6:	9b01      	ldr	r3, [sp, #4]
   114f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   114fc:	1e5a      	subs	r2, r3, #1
   114fe:	490b      	ldr	r1, [pc, #44]	; (1152c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_34+0x44>)
   11500:	9b01      	ldr	r3, [sp, #4]
   11502:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_34[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_34[u32CoreId]))         /*if interrupts were enabled*/
   11506:	4a0a      	ldr	r2, [pc, #40]	; (11530 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_34+0x48>)
   11508:	9b01      	ldr	r3, [sp, #4]
   1150a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1150e:	f003 0301 	and.w	r3, r3, #1
   11512:	2b00      	cmp	r3, #0
   11514:	d106      	bne.n	11524 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_34+0x3c>
   11516:	4a05      	ldr	r2, [pc, #20]	; (1152c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_34+0x44>)
   11518:	9b01      	ldr	r3, [sp, #4]
   1151a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1151e:	2b00      	cmp	r3, #0
   11520:	d100      	bne.n	11524 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_34+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   11522:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11524:	bf00      	nop
   11526:	b003      	add	sp, #12
   11528:	f85d fb04 	ldr.w	pc, [sp], #4
   1152c:	1fff948c 	.word	0x1fff948c
   11530:	1fff9488 	.word	0x1fff9488

00011534 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_35>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_35(void)
{
   11534:	b500      	push	{lr}
   11536:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11538:	f7ef fbf0 	bl	d1c <Sys_GetCoreID>
   1153c:	4603      	mov	r3, r0
   1153e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_35[u32CoreId])
   11540:	4a10      	ldr	r2, [pc, #64]	; (11584 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_35+0x50>)
   11542:	9b01      	ldr	r3, [sp, #4]
   11544:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11548:	2b00      	cmp	r3, #0
   1154a:	d10d      	bne.n	11568 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_35+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   1154c:	f7ef fa24 	bl	998 <Adc_schm_read_msr>
   11550:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   11552:	9b00      	ldr	r3, [sp, #0]
   11554:	f003 0301 	and.w	r3, r3, #1
   11558:	2b00      	cmp	r3, #0
   1155a:	d100      	bne.n	1155e <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_35+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   1155c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_35[u32CoreId] = msr;
   1155e:	490a      	ldr	r1, [pc, #40]	; (11588 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_35+0x54>)
   11560:	9b01      	ldr	r3, [sp, #4]
   11562:	9a00      	ldr	r2, [sp, #0]
   11564:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_35[u32CoreId]++;
   11568:	4a06      	ldr	r2, [pc, #24]	; (11584 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_35+0x50>)
   1156a:	9b01      	ldr	r3, [sp, #4]
   1156c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11570:	1c5a      	adds	r2, r3, #1
   11572:	4904      	ldr	r1, [pc, #16]	; (11584 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_35+0x50>)
   11574:	9b01      	ldr	r3, [sp, #4]
   11576:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1157a:	bf00      	nop
   1157c:	b003      	add	sp, #12
   1157e:	f85d fb04 	ldr.w	pc, [sp], #4
   11582:	bf00      	nop
   11584:	1fff9494 	.word	0x1fff9494
   11588:	1fff9490 	.word	0x1fff9490

0001158c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_35>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_35(void)
{
   1158c:	b500      	push	{lr}
   1158e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11590:	f7ef fbc4 	bl	d1c <Sys_GetCoreID>
   11594:	4603      	mov	r3, r0
   11596:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_35[u32CoreId]--;
   11598:	4a0d      	ldr	r2, [pc, #52]	; (115d0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_35+0x44>)
   1159a:	9b01      	ldr	r3, [sp, #4]
   1159c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   115a0:	1e5a      	subs	r2, r3, #1
   115a2:	490b      	ldr	r1, [pc, #44]	; (115d0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_35+0x44>)
   115a4:	9b01      	ldr	r3, [sp, #4]
   115a6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_35[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_35[u32CoreId]))         /*if interrupts were enabled*/
   115aa:	4a0a      	ldr	r2, [pc, #40]	; (115d4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_35+0x48>)
   115ac:	9b01      	ldr	r3, [sp, #4]
   115ae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   115b2:	f003 0301 	and.w	r3, r3, #1
   115b6:	2b00      	cmp	r3, #0
   115b8:	d106      	bne.n	115c8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_35+0x3c>
   115ba:	4a05      	ldr	r2, [pc, #20]	; (115d0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_35+0x44>)
   115bc:	9b01      	ldr	r3, [sp, #4]
   115be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   115c2:	2b00      	cmp	r3, #0
   115c4:	d100      	bne.n	115c8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_35+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   115c6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   115c8:	bf00      	nop
   115ca:	b003      	add	sp, #12
   115cc:	f85d fb04 	ldr.w	pc, [sp], #4
   115d0:	1fff9494 	.word	0x1fff9494
   115d4:	1fff9490 	.word	0x1fff9490

000115d8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_36>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_36(void)
{
   115d8:	b500      	push	{lr}
   115da:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   115dc:	f7ef fb9e 	bl	d1c <Sys_GetCoreID>
   115e0:	4603      	mov	r3, r0
   115e2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_36[u32CoreId])
   115e4:	4a10      	ldr	r2, [pc, #64]	; (11628 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_36+0x50>)
   115e6:	9b01      	ldr	r3, [sp, #4]
   115e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   115ec:	2b00      	cmp	r3, #0
   115ee:	d10d      	bne.n	1160c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_36+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   115f0:	f7ef f9d2 	bl	998 <Adc_schm_read_msr>
   115f4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   115f6:	9b00      	ldr	r3, [sp, #0]
   115f8:	f003 0301 	and.w	r3, r3, #1
   115fc:	2b00      	cmp	r3, #0
   115fe:	d100      	bne.n	11602 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_36+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11600:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_36[u32CoreId] = msr;
   11602:	490a      	ldr	r1, [pc, #40]	; (1162c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_36+0x54>)
   11604:	9b01      	ldr	r3, [sp, #4]
   11606:	9a00      	ldr	r2, [sp, #0]
   11608:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_36[u32CoreId]++;
   1160c:	4a06      	ldr	r2, [pc, #24]	; (11628 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_36+0x50>)
   1160e:	9b01      	ldr	r3, [sp, #4]
   11610:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11614:	1c5a      	adds	r2, r3, #1
   11616:	4904      	ldr	r1, [pc, #16]	; (11628 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_36+0x50>)
   11618:	9b01      	ldr	r3, [sp, #4]
   1161a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1161e:	bf00      	nop
   11620:	b003      	add	sp, #12
   11622:	f85d fb04 	ldr.w	pc, [sp], #4
   11626:	bf00      	nop
   11628:	1fff949c 	.word	0x1fff949c
   1162c:	1fff9498 	.word	0x1fff9498

00011630 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_36>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_36(void)
{
   11630:	b500      	push	{lr}
   11632:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11634:	f7ef fb72 	bl	d1c <Sys_GetCoreID>
   11638:	4603      	mov	r3, r0
   1163a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_36[u32CoreId]--;
   1163c:	4a0d      	ldr	r2, [pc, #52]	; (11674 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_36+0x44>)
   1163e:	9b01      	ldr	r3, [sp, #4]
   11640:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11644:	1e5a      	subs	r2, r3, #1
   11646:	490b      	ldr	r1, [pc, #44]	; (11674 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_36+0x44>)
   11648:	9b01      	ldr	r3, [sp, #4]
   1164a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_36[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_36[u32CoreId]))         /*if interrupts were enabled*/
   1164e:	4a0a      	ldr	r2, [pc, #40]	; (11678 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_36+0x48>)
   11650:	9b01      	ldr	r3, [sp, #4]
   11652:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11656:	f003 0301 	and.w	r3, r3, #1
   1165a:	2b00      	cmp	r3, #0
   1165c:	d106      	bne.n	1166c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_36+0x3c>
   1165e:	4a05      	ldr	r2, [pc, #20]	; (11674 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_36+0x44>)
   11660:	9b01      	ldr	r3, [sp, #4]
   11662:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11666:	2b00      	cmp	r3, #0
   11668:	d100      	bne.n	1166c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_36+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1166a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   1166c:	bf00      	nop
   1166e:	b003      	add	sp, #12
   11670:	f85d fb04 	ldr.w	pc, [sp], #4
   11674:	1fff949c 	.word	0x1fff949c
   11678:	1fff9498 	.word	0x1fff9498

0001167c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_37>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_37(void)
{
   1167c:	b500      	push	{lr}
   1167e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11680:	f7ef fb4c 	bl	d1c <Sys_GetCoreID>
   11684:	4603      	mov	r3, r0
   11686:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_37[u32CoreId])
   11688:	4a10      	ldr	r2, [pc, #64]	; (116cc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_37+0x50>)
   1168a:	9b01      	ldr	r3, [sp, #4]
   1168c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11690:	2b00      	cmp	r3, #0
   11692:	d10d      	bne.n	116b0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_37+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11694:	f7ef f980 	bl	998 <Adc_schm_read_msr>
   11698:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1169a:	9b00      	ldr	r3, [sp, #0]
   1169c:	f003 0301 	and.w	r3, r3, #1
   116a0:	2b00      	cmp	r3, #0
   116a2:	d100      	bne.n	116a6 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_37+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   116a4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_37[u32CoreId] = msr;
   116a6:	490a      	ldr	r1, [pc, #40]	; (116d0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_37+0x54>)
   116a8:	9b01      	ldr	r3, [sp, #4]
   116aa:	9a00      	ldr	r2, [sp, #0]
   116ac:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_37[u32CoreId]++;
   116b0:	4a06      	ldr	r2, [pc, #24]	; (116cc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_37+0x50>)
   116b2:	9b01      	ldr	r3, [sp, #4]
   116b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   116b8:	1c5a      	adds	r2, r3, #1
   116ba:	4904      	ldr	r1, [pc, #16]	; (116cc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_37+0x50>)
   116bc:	9b01      	ldr	r3, [sp, #4]
   116be:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   116c2:	bf00      	nop
   116c4:	b003      	add	sp, #12
   116c6:	f85d fb04 	ldr.w	pc, [sp], #4
   116ca:	bf00      	nop
   116cc:	1fff94a4 	.word	0x1fff94a4
   116d0:	1fff94a0 	.word	0x1fff94a0

000116d4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_37>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_37(void)
{
   116d4:	b500      	push	{lr}
   116d6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   116d8:	f7ef fb20 	bl	d1c <Sys_GetCoreID>
   116dc:	4603      	mov	r3, r0
   116de:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_37[u32CoreId]--;
   116e0:	4a0d      	ldr	r2, [pc, #52]	; (11718 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_37+0x44>)
   116e2:	9b01      	ldr	r3, [sp, #4]
   116e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   116e8:	1e5a      	subs	r2, r3, #1
   116ea:	490b      	ldr	r1, [pc, #44]	; (11718 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_37+0x44>)
   116ec:	9b01      	ldr	r3, [sp, #4]
   116ee:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_37[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_37[u32CoreId]))         /*if interrupts were enabled*/
   116f2:	4a0a      	ldr	r2, [pc, #40]	; (1171c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_37+0x48>)
   116f4:	9b01      	ldr	r3, [sp, #4]
   116f6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   116fa:	f003 0301 	and.w	r3, r3, #1
   116fe:	2b00      	cmp	r3, #0
   11700:	d106      	bne.n	11710 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_37+0x3c>
   11702:	4a05      	ldr	r2, [pc, #20]	; (11718 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_37+0x44>)
   11704:	9b01      	ldr	r3, [sp, #4]
   11706:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1170a:	2b00      	cmp	r3, #0
   1170c:	d100      	bne.n	11710 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_37+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1170e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11710:	bf00      	nop
   11712:	b003      	add	sp, #12
   11714:	f85d fb04 	ldr.w	pc, [sp], #4
   11718:	1fff94a4 	.word	0x1fff94a4
   1171c:	1fff94a0 	.word	0x1fff94a0

00011720 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_38>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_38(void)
{
   11720:	b500      	push	{lr}
   11722:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11724:	f7ef fafa 	bl	d1c <Sys_GetCoreID>
   11728:	4603      	mov	r3, r0
   1172a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_38[u32CoreId])
   1172c:	4a10      	ldr	r2, [pc, #64]	; (11770 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_38+0x50>)
   1172e:	9b01      	ldr	r3, [sp, #4]
   11730:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11734:	2b00      	cmp	r3, #0
   11736:	d10d      	bne.n	11754 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_38+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11738:	f7ef f92e 	bl	998 <Adc_schm_read_msr>
   1173c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1173e:	9b00      	ldr	r3, [sp, #0]
   11740:	f003 0301 	and.w	r3, r3, #1
   11744:	2b00      	cmp	r3, #0
   11746:	d100      	bne.n	1174a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_38+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11748:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_38[u32CoreId] = msr;
   1174a:	490a      	ldr	r1, [pc, #40]	; (11774 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_38+0x54>)
   1174c:	9b01      	ldr	r3, [sp, #4]
   1174e:	9a00      	ldr	r2, [sp, #0]
   11750:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_38[u32CoreId]++;
   11754:	4a06      	ldr	r2, [pc, #24]	; (11770 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_38+0x50>)
   11756:	9b01      	ldr	r3, [sp, #4]
   11758:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1175c:	1c5a      	adds	r2, r3, #1
   1175e:	4904      	ldr	r1, [pc, #16]	; (11770 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_38+0x50>)
   11760:	9b01      	ldr	r3, [sp, #4]
   11762:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11766:	bf00      	nop
   11768:	b003      	add	sp, #12
   1176a:	f85d fb04 	ldr.w	pc, [sp], #4
   1176e:	bf00      	nop
   11770:	1fff94ac 	.word	0x1fff94ac
   11774:	1fff94a8 	.word	0x1fff94a8

00011778 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_38>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_38(void)
{
   11778:	b500      	push	{lr}
   1177a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1177c:	f7ef face 	bl	d1c <Sys_GetCoreID>
   11780:	4603      	mov	r3, r0
   11782:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_38[u32CoreId]--;
   11784:	4a0d      	ldr	r2, [pc, #52]	; (117bc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_38+0x44>)
   11786:	9b01      	ldr	r3, [sp, #4]
   11788:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1178c:	1e5a      	subs	r2, r3, #1
   1178e:	490b      	ldr	r1, [pc, #44]	; (117bc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_38+0x44>)
   11790:	9b01      	ldr	r3, [sp, #4]
   11792:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_38[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_38[u32CoreId]))         /*if interrupts were enabled*/
   11796:	4a0a      	ldr	r2, [pc, #40]	; (117c0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_38+0x48>)
   11798:	9b01      	ldr	r3, [sp, #4]
   1179a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1179e:	f003 0301 	and.w	r3, r3, #1
   117a2:	2b00      	cmp	r3, #0
   117a4:	d106      	bne.n	117b4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_38+0x3c>
   117a6:	4a05      	ldr	r2, [pc, #20]	; (117bc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_38+0x44>)
   117a8:	9b01      	ldr	r3, [sp, #4]
   117aa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   117ae:	2b00      	cmp	r3, #0
   117b0:	d100      	bne.n	117b4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_38+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   117b2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   117b4:	bf00      	nop
   117b6:	b003      	add	sp, #12
   117b8:	f85d fb04 	ldr.w	pc, [sp], #4
   117bc:	1fff94ac 	.word	0x1fff94ac
   117c0:	1fff94a8 	.word	0x1fff94a8

000117c4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_39>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_39(void)
{
   117c4:	b500      	push	{lr}
   117c6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   117c8:	f7ef faa8 	bl	d1c <Sys_GetCoreID>
   117cc:	4603      	mov	r3, r0
   117ce:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_39[u32CoreId])
   117d0:	4a10      	ldr	r2, [pc, #64]	; (11814 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_39+0x50>)
   117d2:	9b01      	ldr	r3, [sp, #4]
   117d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   117d8:	2b00      	cmp	r3, #0
   117da:	d10d      	bne.n	117f8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_39+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   117dc:	f7ef f8dc 	bl	998 <Adc_schm_read_msr>
   117e0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   117e2:	9b00      	ldr	r3, [sp, #0]
   117e4:	f003 0301 	and.w	r3, r3, #1
   117e8:	2b00      	cmp	r3, #0
   117ea:	d100      	bne.n	117ee <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_39+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   117ec:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_39[u32CoreId] = msr;
   117ee:	490a      	ldr	r1, [pc, #40]	; (11818 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_39+0x54>)
   117f0:	9b01      	ldr	r3, [sp, #4]
   117f2:	9a00      	ldr	r2, [sp, #0]
   117f4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_39[u32CoreId]++;
   117f8:	4a06      	ldr	r2, [pc, #24]	; (11814 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_39+0x50>)
   117fa:	9b01      	ldr	r3, [sp, #4]
   117fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11800:	1c5a      	adds	r2, r3, #1
   11802:	4904      	ldr	r1, [pc, #16]	; (11814 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_39+0x50>)
   11804:	9b01      	ldr	r3, [sp, #4]
   11806:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1180a:	bf00      	nop
   1180c:	b003      	add	sp, #12
   1180e:	f85d fb04 	ldr.w	pc, [sp], #4
   11812:	bf00      	nop
   11814:	1fff94b4 	.word	0x1fff94b4
   11818:	1fff94b0 	.word	0x1fff94b0

0001181c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_39>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_39(void)
{
   1181c:	b500      	push	{lr}
   1181e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11820:	f7ef fa7c 	bl	d1c <Sys_GetCoreID>
   11824:	4603      	mov	r3, r0
   11826:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_39[u32CoreId]--;
   11828:	4a0d      	ldr	r2, [pc, #52]	; (11860 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_39+0x44>)
   1182a:	9b01      	ldr	r3, [sp, #4]
   1182c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11830:	1e5a      	subs	r2, r3, #1
   11832:	490b      	ldr	r1, [pc, #44]	; (11860 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_39+0x44>)
   11834:	9b01      	ldr	r3, [sp, #4]
   11836:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_39[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_39[u32CoreId]))         /*if interrupts were enabled*/
   1183a:	4a0a      	ldr	r2, [pc, #40]	; (11864 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_39+0x48>)
   1183c:	9b01      	ldr	r3, [sp, #4]
   1183e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11842:	f003 0301 	and.w	r3, r3, #1
   11846:	2b00      	cmp	r3, #0
   11848:	d106      	bne.n	11858 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_39+0x3c>
   1184a:	4a05      	ldr	r2, [pc, #20]	; (11860 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_39+0x44>)
   1184c:	9b01      	ldr	r3, [sp, #4]
   1184e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11852:	2b00      	cmp	r3, #0
   11854:	d100      	bne.n	11858 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_39+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   11856:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11858:	bf00      	nop
   1185a:	b003      	add	sp, #12
   1185c:	f85d fb04 	ldr.w	pc, [sp], #4
   11860:	1fff94b4 	.word	0x1fff94b4
   11864:	1fff94b0 	.word	0x1fff94b0

00011868 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_40>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_40(void)
{
   11868:	b500      	push	{lr}
   1186a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1186c:	f7ef fa56 	bl	d1c <Sys_GetCoreID>
   11870:	4603      	mov	r3, r0
   11872:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_40[u32CoreId])
   11874:	4a10      	ldr	r2, [pc, #64]	; (118b8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_40+0x50>)
   11876:	9b01      	ldr	r3, [sp, #4]
   11878:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1187c:	2b00      	cmp	r3, #0
   1187e:	d10d      	bne.n	1189c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_40+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11880:	f7ef f88a 	bl	998 <Adc_schm_read_msr>
   11884:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   11886:	9b00      	ldr	r3, [sp, #0]
   11888:	f003 0301 	and.w	r3, r3, #1
   1188c:	2b00      	cmp	r3, #0
   1188e:	d100      	bne.n	11892 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_40+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11890:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_40[u32CoreId] = msr;
   11892:	490a      	ldr	r1, [pc, #40]	; (118bc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_40+0x54>)
   11894:	9b01      	ldr	r3, [sp, #4]
   11896:	9a00      	ldr	r2, [sp, #0]
   11898:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_40[u32CoreId]++;
   1189c:	4a06      	ldr	r2, [pc, #24]	; (118b8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_40+0x50>)
   1189e:	9b01      	ldr	r3, [sp, #4]
   118a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   118a4:	1c5a      	adds	r2, r3, #1
   118a6:	4904      	ldr	r1, [pc, #16]	; (118b8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_40+0x50>)
   118a8:	9b01      	ldr	r3, [sp, #4]
   118aa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   118ae:	bf00      	nop
   118b0:	b003      	add	sp, #12
   118b2:	f85d fb04 	ldr.w	pc, [sp], #4
   118b6:	bf00      	nop
   118b8:	1fff94bc 	.word	0x1fff94bc
   118bc:	1fff94b8 	.word	0x1fff94b8

000118c0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_40>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_40(void)
{
   118c0:	b500      	push	{lr}
   118c2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   118c4:	f7ef fa2a 	bl	d1c <Sys_GetCoreID>
   118c8:	4603      	mov	r3, r0
   118ca:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_40[u32CoreId]--;
   118cc:	4a0d      	ldr	r2, [pc, #52]	; (11904 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_40+0x44>)
   118ce:	9b01      	ldr	r3, [sp, #4]
   118d0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   118d4:	1e5a      	subs	r2, r3, #1
   118d6:	490b      	ldr	r1, [pc, #44]	; (11904 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_40+0x44>)
   118d8:	9b01      	ldr	r3, [sp, #4]
   118da:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_40[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_40[u32CoreId]))         /*if interrupts were enabled*/
   118de:	4a0a      	ldr	r2, [pc, #40]	; (11908 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_40+0x48>)
   118e0:	9b01      	ldr	r3, [sp, #4]
   118e2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   118e6:	f003 0301 	and.w	r3, r3, #1
   118ea:	2b00      	cmp	r3, #0
   118ec:	d106      	bne.n	118fc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_40+0x3c>
   118ee:	4a05      	ldr	r2, [pc, #20]	; (11904 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_40+0x44>)
   118f0:	9b01      	ldr	r3, [sp, #4]
   118f2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   118f6:	2b00      	cmp	r3, #0
   118f8:	d100      	bne.n	118fc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_40+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   118fa:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   118fc:	bf00      	nop
   118fe:	b003      	add	sp, #12
   11900:	f85d fb04 	ldr.w	pc, [sp], #4
   11904:	1fff94bc 	.word	0x1fff94bc
   11908:	1fff94b8 	.word	0x1fff94b8

0001190c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_41>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_41(void)
{
   1190c:	b500      	push	{lr}
   1190e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11910:	f7ef fa04 	bl	d1c <Sys_GetCoreID>
   11914:	4603      	mov	r3, r0
   11916:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_41[u32CoreId])
   11918:	4a10      	ldr	r2, [pc, #64]	; (1195c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_41+0x50>)
   1191a:	9b01      	ldr	r3, [sp, #4]
   1191c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11920:	2b00      	cmp	r3, #0
   11922:	d10d      	bne.n	11940 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_41+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11924:	f7ef f838 	bl	998 <Adc_schm_read_msr>
   11928:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1192a:	9b00      	ldr	r3, [sp, #0]
   1192c:	f003 0301 	and.w	r3, r3, #1
   11930:	2b00      	cmp	r3, #0
   11932:	d100      	bne.n	11936 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_41+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11934:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_41[u32CoreId] = msr;
   11936:	490a      	ldr	r1, [pc, #40]	; (11960 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_41+0x54>)
   11938:	9b01      	ldr	r3, [sp, #4]
   1193a:	9a00      	ldr	r2, [sp, #0]
   1193c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_41[u32CoreId]++;
   11940:	4a06      	ldr	r2, [pc, #24]	; (1195c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_41+0x50>)
   11942:	9b01      	ldr	r3, [sp, #4]
   11944:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11948:	1c5a      	adds	r2, r3, #1
   1194a:	4904      	ldr	r1, [pc, #16]	; (1195c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_41+0x50>)
   1194c:	9b01      	ldr	r3, [sp, #4]
   1194e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11952:	bf00      	nop
   11954:	b003      	add	sp, #12
   11956:	f85d fb04 	ldr.w	pc, [sp], #4
   1195a:	bf00      	nop
   1195c:	1fff94c4 	.word	0x1fff94c4
   11960:	1fff94c0 	.word	0x1fff94c0

00011964 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_41>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_41(void)
{
   11964:	b500      	push	{lr}
   11966:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11968:	f7ef f9d8 	bl	d1c <Sys_GetCoreID>
   1196c:	4603      	mov	r3, r0
   1196e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_41[u32CoreId]--;
   11970:	4a0d      	ldr	r2, [pc, #52]	; (119a8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_41+0x44>)
   11972:	9b01      	ldr	r3, [sp, #4]
   11974:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11978:	1e5a      	subs	r2, r3, #1
   1197a:	490b      	ldr	r1, [pc, #44]	; (119a8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_41+0x44>)
   1197c:	9b01      	ldr	r3, [sp, #4]
   1197e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_41[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_41[u32CoreId]))         /*if interrupts were enabled*/
   11982:	4a0a      	ldr	r2, [pc, #40]	; (119ac <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_41+0x48>)
   11984:	9b01      	ldr	r3, [sp, #4]
   11986:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1198a:	f003 0301 	and.w	r3, r3, #1
   1198e:	2b00      	cmp	r3, #0
   11990:	d106      	bne.n	119a0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_41+0x3c>
   11992:	4a05      	ldr	r2, [pc, #20]	; (119a8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_41+0x44>)
   11994:	9b01      	ldr	r3, [sp, #4]
   11996:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1199a:	2b00      	cmp	r3, #0
   1199c:	d100      	bne.n	119a0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_41+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1199e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   119a0:	bf00      	nop
   119a2:	b003      	add	sp, #12
   119a4:	f85d fb04 	ldr.w	pc, [sp], #4
   119a8:	1fff94c4 	.word	0x1fff94c4
   119ac:	1fff94c0 	.word	0x1fff94c0

000119b0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_42>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_42(void)
{
   119b0:	b500      	push	{lr}
   119b2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   119b4:	f7ef f9b2 	bl	d1c <Sys_GetCoreID>
   119b8:	4603      	mov	r3, r0
   119ba:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_42[u32CoreId])
   119bc:	4a10      	ldr	r2, [pc, #64]	; (11a00 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_42+0x50>)
   119be:	9b01      	ldr	r3, [sp, #4]
   119c0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   119c4:	2b00      	cmp	r3, #0
   119c6:	d10d      	bne.n	119e4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_42+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   119c8:	f7ee ffe6 	bl	998 <Adc_schm_read_msr>
   119cc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   119ce:	9b00      	ldr	r3, [sp, #0]
   119d0:	f003 0301 	and.w	r3, r3, #1
   119d4:	2b00      	cmp	r3, #0
   119d6:	d100      	bne.n	119da <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_42+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   119d8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_42[u32CoreId] = msr;
   119da:	490a      	ldr	r1, [pc, #40]	; (11a04 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_42+0x54>)
   119dc:	9b01      	ldr	r3, [sp, #4]
   119de:	9a00      	ldr	r2, [sp, #0]
   119e0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_42[u32CoreId]++;
   119e4:	4a06      	ldr	r2, [pc, #24]	; (11a00 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_42+0x50>)
   119e6:	9b01      	ldr	r3, [sp, #4]
   119e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   119ec:	1c5a      	adds	r2, r3, #1
   119ee:	4904      	ldr	r1, [pc, #16]	; (11a00 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_42+0x50>)
   119f0:	9b01      	ldr	r3, [sp, #4]
   119f2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   119f6:	bf00      	nop
   119f8:	b003      	add	sp, #12
   119fa:	f85d fb04 	ldr.w	pc, [sp], #4
   119fe:	bf00      	nop
   11a00:	1fff94cc 	.word	0x1fff94cc
   11a04:	1fff94c8 	.word	0x1fff94c8

00011a08 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_42>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_42(void)
{
   11a08:	b500      	push	{lr}
   11a0a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11a0c:	f7ef f986 	bl	d1c <Sys_GetCoreID>
   11a10:	4603      	mov	r3, r0
   11a12:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_42[u32CoreId]--;
   11a14:	4a0d      	ldr	r2, [pc, #52]	; (11a4c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_42+0x44>)
   11a16:	9b01      	ldr	r3, [sp, #4]
   11a18:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11a1c:	1e5a      	subs	r2, r3, #1
   11a1e:	490b      	ldr	r1, [pc, #44]	; (11a4c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_42+0x44>)
   11a20:	9b01      	ldr	r3, [sp, #4]
   11a22:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_42[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_42[u32CoreId]))         /*if interrupts were enabled*/
   11a26:	4a0a      	ldr	r2, [pc, #40]	; (11a50 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_42+0x48>)
   11a28:	9b01      	ldr	r3, [sp, #4]
   11a2a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11a2e:	f003 0301 	and.w	r3, r3, #1
   11a32:	2b00      	cmp	r3, #0
   11a34:	d106      	bne.n	11a44 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_42+0x3c>
   11a36:	4a05      	ldr	r2, [pc, #20]	; (11a4c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_42+0x44>)
   11a38:	9b01      	ldr	r3, [sp, #4]
   11a3a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11a3e:	2b00      	cmp	r3, #0
   11a40:	d100      	bne.n	11a44 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_42+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   11a42:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11a44:	bf00      	nop
   11a46:	b003      	add	sp, #12
   11a48:	f85d fb04 	ldr.w	pc, [sp], #4
   11a4c:	1fff94cc 	.word	0x1fff94cc
   11a50:	1fff94c8 	.word	0x1fff94c8

00011a54 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_43>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_43(void)
{
   11a54:	b500      	push	{lr}
   11a56:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11a58:	f7ef f960 	bl	d1c <Sys_GetCoreID>
   11a5c:	4603      	mov	r3, r0
   11a5e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_43[u32CoreId])
   11a60:	4a10      	ldr	r2, [pc, #64]	; (11aa4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_43+0x50>)
   11a62:	9b01      	ldr	r3, [sp, #4]
   11a64:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11a68:	2b00      	cmp	r3, #0
   11a6a:	d10d      	bne.n	11a88 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_43+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11a6c:	f7ee ff94 	bl	998 <Adc_schm_read_msr>
   11a70:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   11a72:	9b00      	ldr	r3, [sp, #0]
   11a74:	f003 0301 	and.w	r3, r3, #1
   11a78:	2b00      	cmp	r3, #0
   11a7a:	d100      	bne.n	11a7e <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_43+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11a7c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_43[u32CoreId] = msr;
   11a7e:	490a      	ldr	r1, [pc, #40]	; (11aa8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_43+0x54>)
   11a80:	9b01      	ldr	r3, [sp, #4]
   11a82:	9a00      	ldr	r2, [sp, #0]
   11a84:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_43[u32CoreId]++;
   11a88:	4a06      	ldr	r2, [pc, #24]	; (11aa4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_43+0x50>)
   11a8a:	9b01      	ldr	r3, [sp, #4]
   11a8c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11a90:	1c5a      	adds	r2, r3, #1
   11a92:	4904      	ldr	r1, [pc, #16]	; (11aa4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_43+0x50>)
   11a94:	9b01      	ldr	r3, [sp, #4]
   11a96:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11a9a:	bf00      	nop
   11a9c:	b003      	add	sp, #12
   11a9e:	f85d fb04 	ldr.w	pc, [sp], #4
   11aa2:	bf00      	nop
   11aa4:	1fff94d4 	.word	0x1fff94d4
   11aa8:	1fff94d0 	.word	0x1fff94d0

00011aac <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_43>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_43(void)
{
   11aac:	b500      	push	{lr}
   11aae:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11ab0:	f7ef f934 	bl	d1c <Sys_GetCoreID>
   11ab4:	4603      	mov	r3, r0
   11ab6:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_43[u32CoreId]--;
   11ab8:	4a0d      	ldr	r2, [pc, #52]	; (11af0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_43+0x44>)
   11aba:	9b01      	ldr	r3, [sp, #4]
   11abc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11ac0:	1e5a      	subs	r2, r3, #1
   11ac2:	490b      	ldr	r1, [pc, #44]	; (11af0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_43+0x44>)
   11ac4:	9b01      	ldr	r3, [sp, #4]
   11ac6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_43[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_43[u32CoreId]))         /*if interrupts were enabled*/
   11aca:	4a0a      	ldr	r2, [pc, #40]	; (11af4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_43+0x48>)
   11acc:	9b01      	ldr	r3, [sp, #4]
   11ace:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11ad2:	f003 0301 	and.w	r3, r3, #1
   11ad6:	2b00      	cmp	r3, #0
   11ad8:	d106      	bne.n	11ae8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_43+0x3c>
   11ada:	4a05      	ldr	r2, [pc, #20]	; (11af0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_43+0x44>)
   11adc:	9b01      	ldr	r3, [sp, #4]
   11ade:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11ae2:	2b00      	cmp	r3, #0
   11ae4:	d100      	bne.n	11ae8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_43+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   11ae6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11ae8:	bf00      	nop
   11aea:	b003      	add	sp, #12
   11aec:	f85d fb04 	ldr.w	pc, [sp], #4
   11af0:	1fff94d4 	.word	0x1fff94d4
   11af4:	1fff94d0 	.word	0x1fff94d0

00011af8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_44>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_44(void)
{
   11af8:	b500      	push	{lr}
   11afa:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11afc:	f7ef f90e 	bl	d1c <Sys_GetCoreID>
   11b00:	4603      	mov	r3, r0
   11b02:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_44[u32CoreId])
   11b04:	4a10      	ldr	r2, [pc, #64]	; (11b48 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_44+0x50>)
   11b06:	9b01      	ldr	r3, [sp, #4]
   11b08:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11b0c:	2b00      	cmp	r3, #0
   11b0e:	d10d      	bne.n	11b2c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_44+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11b10:	f7ee ff42 	bl	998 <Adc_schm_read_msr>
   11b14:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   11b16:	9b00      	ldr	r3, [sp, #0]
   11b18:	f003 0301 	and.w	r3, r3, #1
   11b1c:	2b00      	cmp	r3, #0
   11b1e:	d100      	bne.n	11b22 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_44+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11b20:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_44[u32CoreId] = msr;
   11b22:	490a      	ldr	r1, [pc, #40]	; (11b4c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_44+0x54>)
   11b24:	9b01      	ldr	r3, [sp, #4]
   11b26:	9a00      	ldr	r2, [sp, #0]
   11b28:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_44[u32CoreId]++;
   11b2c:	4a06      	ldr	r2, [pc, #24]	; (11b48 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_44+0x50>)
   11b2e:	9b01      	ldr	r3, [sp, #4]
   11b30:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11b34:	1c5a      	adds	r2, r3, #1
   11b36:	4904      	ldr	r1, [pc, #16]	; (11b48 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_44+0x50>)
   11b38:	9b01      	ldr	r3, [sp, #4]
   11b3a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11b3e:	bf00      	nop
   11b40:	b003      	add	sp, #12
   11b42:	f85d fb04 	ldr.w	pc, [sp], #4
   11b46:	bf00      	nop
   11b48:	1fff94dc 	.word	0x1fff94dc
   11b4c:	1fff94d8 	.word	0x1fff94d8

00011b50 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_44>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_44(void)
{
   11b50:	b500      	push	{lr}
   11b52:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11b54:	f7ef f8e2 	bl	d1c <Sys_GetCoreID>
   11b58:	4603      	mov	r3, r0
   11b5a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_44[u32CoreId]--;
   11b5c:	4a0d      	ldr	r2, [pc, #52]	; (11b94 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_44+0x44>)
   11b5e:	9b01      	ldr	r3, [sp, #4]
   11b60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11b64:	1e5a      	subs	r2, r3, #1
   11b66:	490b      	ldr	r1, [pc, #44]	; (11b94 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_44+0x44>)
   11b68:	9b01      	ldr	r3, [sp, #4]
   11b6a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_44[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_44[u32CoreId]))         /*if interrupts were enabled*/
   11b6e:	4a0a      	ldr	r2, [pc, #40]	; (11b98 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_44+0x48>)
   11b70:	9b01      	ldr	r3, [sp, #4]
   11b72:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11b76:	f003 0301 	and.w	r3, r3, #1
   11b7a:	2b00      	cmp	r3, #0
   11b7c:	d106      	bne.n	11b8c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_44+0x3c>
   11b7e:	4a05      	ldr	r2, [pc, #20]	; (11b94 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_44+0x44>)
   11b80:	9b01      	ldr	r3, [sp, #4]
   11b82:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11b86:	2b00      	cmp	r3, #0
   11b88:	d100      	bne.n	11b8c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_44+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   11b8a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11b8c:	bf00      	nop
   11b8e:	b003      	add	sp, #12
   11b90:	f85d fb04 	ldr.w	pc, [sp], #4
   11b94:	1fff94dc 	.word	0x1fff94dc
   11b98:	1fff94d8 	.word	0x1fff94d8

00011b9c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_45>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_45(void)
{
   11b9c:	b500      	push	{lr}
   11b9e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11ba0:	f7ef f8bc 	bl	d1c <Sys_GetCoreID>
   11ba4:	4603      	mov	r3, r0
   11ba6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_45[u32CoreId])
   11ba8:	4a10      	ldr	r2, [pc, #64]	; (11bec <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_45+0x50>)
   11baa:	9b01      	ldr	r3, [sp, #4]
   11bac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11bb0:	2b00      	cmp	r3, #0
   11bb2:	d10d      	bne.n	11bd0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_45+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11bb4:	f7ee fef0 	bl	998 <Adc_schm_read_msr>
   11bb8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   11bba:	9b00      	ldr	r3, [sp, #0]
   11bbc:	f003 0301 	and.w	r3, r3, #1
   11bc0:	2b00      	cmp	r3, #0
   11bc2:	d100      	bne.n	11bc6 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_45+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11bc4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_45[u32CoreId] = msr;
   11bc6:	490a      	ldr	r1, [pc, #40]	; (11bf0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_45+0x54>)
   11bc8:	9b01      	ldr	r3, [sp, #4]
   11bca:	9a00      	ldr	r2, [sp, #0]
   11bcc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_45[u32CoreId]++;
   11bd0:	4a06      	ldr	r2, [pc, #24]	; (11bec <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_45+0x50>)
   11bd2:	9b01      	ldr	r3, [sp, #4]
   11bd4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11bd8:	1c5a      	adds	r2, r3, #1
   11bda:	4904      	ldr	r1, [pc, #16]	; (11bec <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_45+0x50>)
   11bdc:	9b01      	ldr	r3, [sp, #4]
   11bde:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11be2:	bf00      	nop
   11be4:	b003      	add	sp, #12
   11be6:	f85d fb04 	ldr.w	pc, [sp], #4
   11bea:	bf00      	nop
   11bec:	1fff94e4 	.word	0x1fff94e4
   11bf0:	1fff94e0 	.word	0x1fff94e0

00011bf4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_45>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_45(void)
{
   11bf4:	b500      	push	{lr}
   11bf6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11bf8:	f7ef f890 	bl	d1c <Sys_GetCoreID>
   11bfc:	4603      	mov	r3, r0
   11bfe:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_45[u32CoreId]--;
   11c00:	4a0d      	ldr	r2, [pc, #52]	; (11c38 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_45+0x44>)
   11c02:	9b01      	ldr	r3, [sp, #4]
   11c04:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11c08:	1e5a      	subs	r2, r3, #1
   11c0a:	490b      	ldr	r1, [pc, #44]	; (11c38 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_45+0x44>)
   11c0c:	9b01      	ldr	r3, [sp, #4]
   11c0e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_45[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_45[u32CoreId]))         /*if interrupts were enabled*/
   11c12:	4a0a      	ldr	r2, [pc, #40]	; (11c3c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_45+0x48>)
   11c14:	9b01      	ldr	r3, [sp, #4]
   11c16:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11c1a:	f003 0301 	and.w	r3, r3, #1
   11c1e:	2b00      	cmp	r3, #0
   11c20:	d106      	bne.n	11c30 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_45+0x3c>
   11c22:	4a05      	ldr	r2, [pc, #20]	; (11c38 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_45+0x44>)
   11c24:	9b01      	ldr	r3, [sp, #4]
   11c26:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11c2a:	2b00      	cmp	r3, #0
   11c2c:	d100      	bne.n	11c30 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_45+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   11c2e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11c30:	bf00      	nop
   11c32:	b003      	add	sp, #12
   11c34:	f85d fb04 	ldr.w	pc, [sp], #4
   11c38:	1fff94e4 	.word	0x1fff94e4
   11c3c:	1fff94e0 	.word	0x1fff94e0

00011c40 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_46>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_46(void)
{
   11c40:	b500      	push	{lr}
   11c42:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11c44:	f7ef f86a 	bl	d1c <Sys_GetCoreID>
   11c48:	4603      	mov	r3, r0
   11c4a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_46[u32CoreId])
   11c4c:	4a10      	ldr	r2, [pc, #64]	; (11c90 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_46+0x50>)
   11c4e:	9b01      	ldr	r3, [sp, #4]
   11c50:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11c54:	2b00      	cmp	r3, #0
   11c56:	d10d      	bne.n	11c74 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_46+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11c58:	f7ee fe9e 	bl	998 <Adc_schm_read_msr>
   11c5c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   11c5e:	9b00      	ldr	r3, [sp, #0]
   11c60:	f003 0301 	and.w	r3, r3, #1
   11c64:	2b00      	cmp	r3, #0
   11c66:	d100      	bne.n	11c6a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_46+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11c68:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_46[u32CoreId] = msr;
   11c6a:	490a      	ldr	r1, [pc, #40]	; (11c94 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_46+0x54>)
   11c6c:	9b01      	ldr	r3, [sp, #4]
   11c6e:	9a00      	ldr	r2, [sp, #0]
   11c70:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_46[u32CoreId]++;
   11c74:	4a06      	ldr	r2, [pc, #24]	; (11c90 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_46+0x50>)
   11c76:	9b01      	ldr	r3, [sp, #4]
   11c78:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11c7c:	1c5a      	adds	r2, r3, #1
   11c7e:	4904      	ldr	r1, [pc, #16]	; (11c90 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_46+0x50>)
   11c80:	9b01      	ldr	r3, [sp, #4]
   11c82:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11c86:	bf00      	nop
   11c88:	b003      	add	sp, #12
   11c8a:	f85d fb04 	ldr.w	pc, [sp], #4
   11c8e:	bf00      	nop
   11c90:	1fff94ec 	.word	0x1fff94ec
   11c94:	1fff94e8 	.word	0x1fff94e8

00011c98 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_46>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_46(void)
{
   11c98:	b500      	push	{lr}
   11c9a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11c9c:	f7ef f83e 	bl	d1c <Sys_GetCoreID>
   11ca0:	4603      	mov	r3, r0
   11ca2:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_46[u32CoreId]--;
   11ca4:	4a0d      	ldr	r2, [pc, #52]	; (11cdc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_46+0x44>)
   11ca6:	9b01      	ldr	r3, [sp, #4]
   11ca8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11cac:	1e5a      	subs	r2, r3, #1
   11cae:	490b      	ldr	r1, [pc, #44]	; (11cdc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_46+0x44>)
   11cb0:	9b01      	ldr	r3, [sp, #4]
   11cb2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_46[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_46[u32CoreId]))         /*if interrupts were enabled*/
   11cb6:	4a0a      	ldr	r2, [pc, #40]	; (11ce0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_46+0x48>)
   11cb8:	9b01      	ldr	r3, [sp, #4]
   11cba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11cbe:	f003 0301 	and.w	r3, r3, #1
   11cc2:	2b00      	cmp	r3, #0
   11cc4:	d106      	bne.n	11cd4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_46+0x3c>
   11cc6:	4a05      	ldr	r2, [pc, #20]	; (11cdc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_46+0x44>)
   11cc8:	9b01      	ldr	r3, [sp, #4]
   11cca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11cce:	2b00      	cmp	r3, #0
   11cd0:	d100      	bne.n	11cd4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_46+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   11cd2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11cd4:	bf00      	nop
   11cd6:	b003      	add	sp, #12
   11cd8:	f85d fb04 	ldr.w	pc, [sp], #4
   11cdc:	1fff94ec 	.word	0x1fff94ec
   11ce0:	1fff94e8 	.word	0x1fff94e8

00011ce4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_47>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_47(void)
{
   11ce4:	b500      	push	{lr}
   11ce6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11ce8:	f7ef f818 	bl	d1c <Sys_GetCoreID>
   11cec:	4603      	mov	r3, r0
   11cee:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_47[u32CoreId])
   11cf0:	4a10      	ldr	r2, [pc, #64]	; (11d34 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_47+0x50>)
   11cf2:	9b01      	ldr	r3, [sp, #4]
   11cf4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11cf8:	2b00      	cmp	r3, #0
   11cfa:	d10d      	bne.n	11d18 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_47+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11cfc:	f7ee fe4c 	bl	998 <Adc_schm_read_msr>
   11d00:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   11d02:	9b00      	ldr	r3, [sp, #0]
   11d04:	f003 0301 	and.w	r3, r3, #1
   11d08:	2b00      	cmp	r3, #0
   11d0a:	d100      	bne.n	11d0e <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_47+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11d0c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_47[u32CoreId] = msr;
   11d0e:	490a      	ldr	r1, [pc, #40]	; (11d38 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_47+0x54>)
   11d10:	9b01      	ldr	r3, [sp, #4]
   11d12:	9a00      	ldr	r2, [sp, #0]
   11d14:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_47[u32CoreId]++;
   11d18:	4a06      	ldr	r2, [pc, #24]	; (11d34 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_47+0x50>)
   11d1a:	9b01      	ldr	r3, [sp, #4]
   11d1c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11d20:	1c5a      	adds	r2, r3, #1
   11d22:	4904      	ldr	r1, [pc, #16]	; (11d34 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_47+0x50>)
   11d24:	9b01      	ldr	r3, [sp, #4]
   11d26:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11d2a:	bf00      	nop
   11d2c:	b003      	add	sp, #12
   11d2e:	f85d fb04 	ldr.w	pc, [sp], #4
   11d32:	bf00      	nop
   11d34:	1fff94f4 	.word	0x1fff94f4
   11d38:	1fff94f0 	.word	0x1fff94f0

00011d3c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_47>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_47(void)
{
   11d3c:	b500      	push	{lr}
   11d3e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11d40:	f7ee ffec 	bl	d1c <Sys_GetCoreID>
   11d44:	4603      	mov	r3, r0
   11d46:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_47[u32CoreId]--;
   11d48:	4a0d      	ldr	r2, [pc, #52]	; (11d80 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_47+0x44>)
   11d4a:	9b01      	ldr	r3, [sp, #4]
   11d4c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11d50:	1e5a      	subs	r2, r3, #1
   11d52:	490b      	ldr	r1, [pc, #44]	; (11d80 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_47+0x44>)
   11d54:	9b01      	ldr	r3, [sp, #4]
   11d56:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_47[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_47[u32CoreId]))         /*if interrupts were enabled*/
   11d5a:	4a0a      	ldr	r2, [pc, #40]	; (11d84 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_47+0x48>)
   11d5c:	9b01      	ldr	r3, [sp, #4]
   11d5e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11d62:	f003 0301 	and.w	r3, r3, #1
   11d66:	2b00      	cmp	r3, #0
   11d68:	d106      	bne.n	11d78 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_47+0x3c>
   11d6a:	4a05      	ldr	r2, [pc, #20]	; (11d80 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_47+0x44>)
   11d6c:	9b01      	ldr	r3, [sp, #4]
   11d6e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11d72:	2b00      	cmp	r3, #0
   11d74:	d100      	bne.n	11d78 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_47+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   11d76:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11d78:	bf00      	nop
   11d7a:	b003      	add	sp, #12
   11d7c:	f85d fb04 	ldr.w	pc, [sp], #4
   11d80:	1fff94f4 	.word	0x1fff94f4
   11d84:	1fff94f0 	.word	0x1fff94f0

00011d88 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_48>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_48(void)
{
   11d88:	b500      	push	{lr}
   11d8a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11d8c:	f7ee ffc6 	bl	d1c <Sys_GetCoreID>
   11d90:	4603      	mov	r3, r0
   11d92:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_48[u32CoreId])
   11d94:	4a10      	ldr	r2, [pc, #64]	; (11dd8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_48+0x50>)
   11d96:	9b01      	ldr	r3, [sp, #4]
   11d98:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11d9c:	2b00      	cmp	r3, #0
   11d9e:	d10d      	bne.n	11dbc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_48+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11da0:	f7ee fdfa 	bl	998 <Adc_schm_read_msr>
   11da4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   11da6:	9b00      	ldr	r3, [sp, #0]
   11da8:	f003 0301 	and.w	r3, r3, #1
   11dac:	2b00      	cmp	r3, #0
   11dae:	d100      	bne.n	11db2 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_48+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11db0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_48[u32CoreId] = msr;
   11db2:	490a      	ldr	r1, [pc, #40]	; (11ddc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_48+0x54>)
   11db4:	9b01      	ldr	r3, [sp, #4]
   11db6:	9a00      	ldr	r2, [sp, #0]
   11db8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_48[u32CoreId]++;
   11dbc:	4a06      	ldr	r2, [pc, #24]	; (11dd8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_48+0x50>)
   11dbe:	9b01      	ldr	r3, [sp, #4]
   11dc0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11dc4:	1c5a      	adds	r2, r3, #1
   11dc6:	4904      	ldr	r1, [pc, #16]	; (11dd8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_48+0x50>)
   11dc8:	9b01      	ldr	r3, [sp, #4]
   11dca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11dce:	bf00      	nop
   11dd0:	b003      	add	sp, #12
   11dd2:	f85d fb04 	ldr.w	pc, [sp], #4
   11dd6:	bf00      	nop
   11dd8:	1fff94fc 	.word	0x1fff94fc
   11ddc:	1fff94f8 	.word	0x1fff94f8

00011de0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_48>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_48(void)
{
   11de0:	b500      	push	{lr}
   11de2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11de4:	f7ee ff9a 	bl	d1c <Sys_GetCoreID>
   11de8:	4603      	mov	r3, r0
   11dea:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_48[u32CoreId]--;
   11dec:	4a0d      	ldr	r2, [pc, #52]	; (11e24 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_48+0x44>)
   11dee:	9b01      	ldr	r3, [sp, #4]
   11df0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11df4:	1e5a      	subs	r2, r3, #1
   11df6:	490b      	ldr	r1, [pc, #44]	; (11e24 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_48+0x44>)
   11df8:	9b01      	ldr	r3, [sp, #4]
   11dfa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_48[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_48[u32CoreId]))         /*if interrupts were enabled*/
   11dfe:	4a0a      	ldr	r2, [pc, #40]	; (11e28 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_48+0x48>)
   11e00:	9b01      	ldr	r3, [sp, #4]
   11e02:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11e06:	f003 0301 	and.w	r3, r3, #1
   11e0a:	2b00      	cmp	r3, #0
   11e0c:	d106      	bne.n	11e1c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_48+0x3c>
   11e0e:	4a05      	ldr	r2, [pc, #20]	; (11e24 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_48+0x44>)
   11e10:	9b01      	ldr	r3, [sp, #4]
   11e12:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11e16:	2b00      	cmp	r3, #0
   11e18:	d100      	bne.n	11e1c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_48+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   11e1a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11e1c:	bf00      	nop
   11e1e:	b003      	add	sp, #12
   11e20:	f85d fb04 	ldr.w	pc, [sp], #4
   11e24:	1fff94fc 	.word	0x1fff94fc
   11e28:	1fff94f8 	.word	0x1fff94f8

00011e2c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_49>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_49(void)
{
   11e2c:	b500      	push	{lr}
   11e2e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11e30:	f7ee ff74 	bl	d1c <Sys_GetCoreID>
   11e34:	4603      	mov	r3, r0
   11e36:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_49[u32CoreId])
   11e38:	4a10      	ldr	r2, [pc, #64]	; (11e7c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_49+0x50>)
   11e3a:	9b01      	ldr	r3, [sp, #4]
   11e3c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11e40:	2b00      	cmp	r3, #0
   11e42:	d10d      	bne.n	11e60 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_49+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11e44:	f7ee fda8 	bl	998 <Adc_schm_read_msr>
   11e48:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   11e4a:	9b00      	ldr	r3, [sp, #0]
   11e4c:	f003 0301 	and.w	r3, r3, #1
   11e50:	2b00      	cmp	r3, #0
   11e52:	d100      	bne.n	11e56 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_49+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11e54:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_49[u32CoreId] = msr;
   11e56:	490a      	ldr	r1, [pc, #40]	; (11e80 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_49+0x54>)
   11e58:	9b01      	ldr	r3, [sp, #4]
   11e5a:	9a00      	ldr	r2, [sp, #0]
   11e5c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_49[u32CoreId]++;
   11e60:	4a06      	ldr	r2, [pc, #24]	; (11e7c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_49+0x50>)
   11e62:	9b01      	ldr	r3, [sp, #4]
   11e64:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11e68:	1c5a      	adds	r2, r3, #1
   11e6a:	4904      	ldr	r1, [pc, #16]	; (11e7c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_49+0x50>)
   11e6c:	9b01      	ldr	r3, [sp, #4]
   11e6e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11e72:	bf00      	nop
   11e74:	b003      	add	sp, #12
   11e76:	f85d fb04 	ldr.w	pc, [sp], #4
   11e7a:	bf00      	nop
   11e7c:	1fff9504 	.word	0x1fff9504
   11e80:	1fff9500 	.word	0x1fff9500

00011e84 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_49>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_49(void)
{
   11e84:	b500      	push	{lr}
   11e86:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11e88:	f7ee ff48 	bl	d1c <Sys_GetCoreID>
   11e8c:	4603      	mov	r3, r0
   11e8e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_49[u32CoreId]--;
   11e90:	4a0d      	ldr	r2, [pc, #52]	; (11ec8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_49+0x44>)
   11e92:	9b01      	ldr	r3, [sp, #4]
   11e94:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11e98:	1e5a      	subs	r2, r3, #1
   11e9a:	490b      	ldr	r1, [pc, #44]	; (11ec8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_49+0x44>)
   11e9c:	9b01      	ldr	r3, [sp, #4]
   11e9e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_49[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_49[u32CoreId]))         /*if interrupts were enabled*/
   11ea2:	4a0a      	ldr	r2, [pc, #40]	; (11ecc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_49+0x48>)
   11ea4:	9b01      	ldr	r3, [sp, #4]
   11ea6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11eaa:	f003 0301 	and.w	r3, r3, #1
   11eae:	2b00      	cmp	r3, #0
   11eb0:	d106      	bne.n	11ec0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_49+0x3c>
   11eb2:	4a05      	ldr	r2, [pc, #20]	; (11ec8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_49+0x44>)
   11eb4:	9b01      	ldr	r3, [sp, #4]
   11eb6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11eba:	2b00      	cmp	r3, #0
   11ebc:	d100      	bne.n	11ec0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_49+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   11ebe:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11ec0:	bf00      	nop
   11ec2:	b003      	add	sp, #12
   11ec4:	f85d fb04 	ldr.w	pc, [sp], #4
   11ec8:	1fff9504 	.word	0x1fff9504
   11ecc:	1fff9500 	.word	0x1fff9500

00011ed0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_50>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_50(void)
{
   11ed0:	b500      	push	{lr}
   11ed2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11ed4:	f7ee ff22 	bl	d1c <Sys_GetCoreID>
   11ed8:	4603      	mov	r3, r0
   11eda:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_50[u32CoreId])
   11edc:	4a10      	ldr	r2, [pc, #64]	; (11f20 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_50+0x50>)
   11ede:	9b01      	ldr	r3, [sp, #4]
   11ee0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11ee4:	2b00      	cmp	r3, #0
   11ee6:	d10d      	bne.n	11f04 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_50+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11ee8:	f7ee fd56 	bl	998 <Adc_schm_read_msr>
   11eec:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   11eee:	9b00      	ldr	r3, [sp, #0]
   11ef0:	f003 0301 	and.w	r3, r3, #1
   11ef4:	2b00      	cmp	r3, #0
   11ef6:	d100      	bne.n	11efa <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_50+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11ef8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_50[u32CoreId] = msr;
   11efa:	490a      	ldr	r1, [pc, #40]	; (11f24 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_50+0x54>)
   11efc:	9b01      	ldr	r3, [sp, #4]
   11efe:	9a00      	ldr	r2, [sp, #0]
   11f00:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_50[u32CoreId]++;
   11f04:	4a06      	ldr	r2, [pc, #24]	; (11f20 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_50+0x50>)
   11f06:	9b01      	ldr	r3, [sp, #4]
   11f08:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11f0c:	1c5a      	adds	r2, r3, #1
   11f0e:	4904      	ldr	r1, [pc, #16]	; (11f20 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_50+0x50>)
   11f10:	9b01      	ldr	r3, [sp, #4]
   11f12:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11f16:	bf00      	nop
   11f18:	b003      	add	sp, #12
   11f1a:	f85d fb04 	ldr.w	pc, [sp], #4
   11f1e:	bf00      	nop
   11f20:	1fff950c 	.word	0x1fff950c
   11f24:	1fff9508 	.word	0x1fff9508

00011f28 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_50>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_50(void)
{
   11f28:	b500      	push	{lr}
   11f2a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11f2c:	f7ee fef6 	bl	d1c <Sys_GetCoreID>
   11f30:	4603      	mov	r3, r0
   11f32:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_50[u32CoreId]--;
   11f34:	4a0d      	ldr	r2, [pc, #52]	; (11f6c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_50+0x44>)
   11f36:	9b01      	ldr	r3, [sp, #4]
   11f38:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11f3c:	1e5a      	subs	r2, r3, #1
   11f3e:	490b      	ldr	r1, [pc, #44]	; (11f6c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_50+0x44>)
   11f40:	9b01      	ldr	r3, [sp, #4]
   11f42:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_50[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_50[u32CoreId]))         /*if interrupts were enabled*/
   11f46:	4a0a      	ldr	r2, [pc, #40]	; (11f70 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_50+0x48>)
   11f48:	9b01      	ldr	r3, [sp, #4]
   11f4a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11f4e:	f003 0301 	and.w	r3, r3, #1
   11f52:	2b00      	cmp	r3, #0
   11f54:	d106      	bne.n	11f64 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_50+0x3c>
   11f56:	4a05      	ldr	r2, [pc, #20]	; (11f6c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_50+0x44>)
   11f58:	9b01      	ldr	r3, [sp, #4]
   11f5a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11f5e:	2b00      	cmp	r3, #0
   11f60:	d100      	bne.n	11f64 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_50+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   11f62:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11f64:	bf00      	nop
   11f66:	b003      	add	sp, #12
   11f68:	f85d fb04 	ldr.w	pc, [sp], #4
   11f6c:	1fff950c 	.word	0x1fff950c
   11f70:	1fff9508 	.word	0x1fff9508

00011f74 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_51>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_51(void)
{
   11f74:	b500      	push	{lr}
   11f76:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11f78:	f7ee fed0 	bl	d1c <Sys_GetCoreID>
   11f7c:	4603      	mov	r3, r0
   11f7e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_51[u32CoreId])
   11f80:	4a10      	ldr	r2, [pc, #64]	; (11fc4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_51+0x50>)
   11f82:	9b01      	ldr	r3, [sp, #4]
   11f84:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11f88:	2b00      	cmp	r3, #0
   11f8a:	d10d      	bne.n	11fa8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_51+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11f8c:	f7ee fd04 	bl	998 <Adc_schm_read_msr>
   11f90:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   11f92:	9b00      	ldr	r3, [sp, #0]
   11f94:	f003 0301 	and.w	r3, r3, #1
   11f98:	2b00      	cmp	r3, #0
   11f9a:	d100      	bne.n	11f9e <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_51+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11f9c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_51[u32CoreId] = msr;
   11f9e:	490a      	ldr	r1, [pc, #40]	; (11fc8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_51+0x54>)
   11fa0:	9b01      	ldr	r3, [sp, #4]
   11fa2:	9a00      	ldr	r2, [sp, #0]
   11fa4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_51[u32CoreId]++;
   11fa8:	4a06      	ldr	r2, [pc, #24]	; (11fc4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_51+0x50>)
   11faa:	9b01      	ldr	r3, [sp, #4]
   11fac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11fb0:	1c5a      	adds	r2, r3, #1
   11fb2:	4904      	ldr	r1, [pc, #16]	; (11fc4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_51+0x50>)
   11fb4:	9b01      	ldr	r3, [sp, #4]
   11fb6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11fba:	bf00      	nop
   11fbc:	b003      	add	sp, #12
   11fbe:	f85d fb04 	ldr.w	pc, [sp], #4
   11fc2:	bf00      	nop
   11fc4:	1fff9514 	.word	0x1fff9514
   11fc8:	1fff9510 	.word	0x1fff9510

00011fcc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_51>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_51(void)
{
   11fcc:	b500      	push	{lr}
   11fce:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11fd0:	f7ee fea4 	bl	d1c <Sys_GetCoreID>
   11fd4:	4603      	mov	r3, r0
   11fd6:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_51[u32CoreId]--;
   11fd8:	4a0d      	ldr	r2, [pc, #52]	; (12010 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_51+0x44>)
   11fda:	9b01      	ldr	r3, [sp, #4]
   11fdc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11fe0:	1e5a      	subs	r2, r3, #1
   11fe2:	490b      	ldr	r1, [pc, #44]	; (12010 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_51+0x44>)
   11fe4:	9b01      	ldr	r3, [sp, #4]
   11fe6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_51[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_51[u32CoreId]))         /*if interrupts were enabled*/
   11fea:	4a0a      	ldr	r2, [pc, #40]	; (12014 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_51+0x48>)
   11fec:	9b01      	ldr	r3, [sp, #4]
   11fee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11ff2:	f003 0301 	and.w	r3, r3, #1
   11ff6:	2b00      	cmp	r3, #0
   11ff8:	d106      	bne.n	12008 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_51+0x3c>
   11ffa:	4a05      	ldr	r2, [pc, #20]	; (12010 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_51+0x44>)
   11ffc:	9b01      	ldr	r3, [sp, #4]
   11ffe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12002:	2b00      	cmp	r3, #0
   12004:	d100      	bne.n	12008 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_51+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   12006:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12008:	bf00      	nop
   1200a:	b003      	add	sp, #12
   1200c:	f85d fb04 	ldr.w	pc, [sp], #4
   12010:	1fff9514 	.word	0x1fff9514
   12014:	1fff9510 	.word	0x1fff9510

00012018 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_54>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_54(void)
{
   12018:	b500      	push	{lr}
   1201a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1201c:	f7ee fe7e 	bl	d1c <Sys_GetCoreID>
   12020:	4603      	mov	r3, r0
   12022:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_54[u32CoreId])
   12024:	4a10      	ldr	r2, [pc, #64]	; (12068 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_54+0x50>)
   12026:	9b01      	ldr	r3, [sp, #4]
   12028:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1202c:	2b00      	cmp	r3, #0
   1202e:	d10d      	bne.n	1204c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_54+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12030:	f7ee fcb2 	bl	998 <Adc_schm_read_msr>
   12034:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   12036:	9b00      	ldr	r3, [sp, #0]
   12038:	f003 0301 	and.w	r3, r3, #1
   1203c:	2b00      	cmp	r3, #0
   1203e:	d100      	bne.n	12042 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_54+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12040:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_54[u32CoreId] = msr;
   12042:	490a      	ldr	r1, [pc, #40]	; (1206c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_54+0x54>)
   12044:	9b01      	ldr	r3, [sp, #4]
   12046:	9a00      	ldr	r2, [sp, #0]
   12048:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_54[u32CoreId]++;
   1204c:	4a06      	ldr	r2, [pc, #24]	; (12068 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_54+0x50>)
   1204e:	9b01      	ldr	r3, [sp, #4]
   12050:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12054:	1c5a      	adds	r2, r3, #1
   12056:	4904      	ldr	r1, [pc, #16]	; (12068 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_54+0x50>)
   12058:	9b01      	ldr	r3, [sp, #4]
   1205a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1205e:	bf00      	nop
   12060:	b003      	add	sp, #12
   12062:	f85d fb04 	ldr.w	pc, [sp], #4
   12066:	bf00      	nop
   12068:	1fff951c 	.word	0x1fff951c
   1206c:	1fff9518 	.word	0x1fff9518

00012070 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_54>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_54(void)
{
   12070:	b500      	push	{lr}
   12072:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12074:	f7ee fe52 	bl	d1c <Sys_GetCoreID>
   12078:	4603      	mov	r3, r0
   1207a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_54[u32CoreId]--;
   1207c:	4a0d      	ldr	r2, [pc, #52]	; (120b4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_54+0x44>)
   1207e:	9b01      	ldr	r3, [sp, #4]
   12080:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12084:	1e5a      	subs	r2, r3, #1
   12086:	490b      	ldr	r1, [pc, #44]	; (120b4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_54+0x44>)
   12088:	9b01      	ldr	r3, [sp, #4]
   1208a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_54[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_54[u32CoreId]))         /*if interrupts were enabled*/
   1208e:	4a0a      	ldr	r2, [pc, #40]	; (120b8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_54+0x48>)
   12090:	9b01      	ldr	r3, [sp, #4]
   12092:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12096:	f003 0301 	and.w	r3, r3, #1
   1209a:	2b00      	cmp	r3, #0
   1209c:	d106      	bne.n	120ac <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_54+0x3c>
   1209e:	4a05      	ldr	r2, [pc, #20]	; (120b4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_54+0x44>)
   120a0:	9b01      	ldr	r3, [sp, #4]
   120a2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   120a6:	2b00      	cmp	r3, #0
   120a8:	d100      	bne.n	120ac <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_54+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   120aa:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   120ac:	bf00      	nop
   120ae:	b003      	add	sp, #12
   120b0:	f85d fb04 	ldr.w	pc, [sp], #4
   120b4:	1fff951c 	.word	0x1fff951c
   120b8:	1fff9518 	.word	0x1fff9518

000120bc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_55>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_55(void)
{
   120bc:	b500      	push	{lr}
   120be:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   120c0:	f7ee fe2c 	bl	d1c <Sys_GetCoreID>
   120c4:	4603      	mov	r3, r0
   120c6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_55[u32CoreId])
   120c8:	4a10      	ldr	r2, [pc, #64]	; (1210c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_55+0x50>)
   120ca:	9b01      	ldr	r3, [sp, #4]
   120cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   120d0:	2b00      	cmp	r3, #0
   120d2:	d10d      	bne.n	120f0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_55+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   120d4:	f7ee fc60 	bl	998 <Adc_schm_read_msr>
   120d8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   120da:	9b00      	ldr	r3, [sp, #0]
   120dc:	f003 0301 	and.w	r3, r3, #1
   120e0:	2b00      	cmp	r3, #0
   120e2:	d100      	bne.n	120e6 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_55+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   120e4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_55[u32CoreId] = msr;
   120e6:	490a      	ldr	r1, [pc, #40]	; (12110 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_55+0x54>)
   120e8:	9b01      	ldr	r3, [sp, #4]
   120ea:	9a00      	ldr	r2, [sp, #0]
   120ec:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_55[u32CoreId]++;
   120f0:	4a06      	ldr	r2, [pc, #24]	; (1210c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_55+0x50>)
   120f2:	9b01      	ldr	r3, [sp, #4]
   120f4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   120f8:	1c5a      	adds	r2, r3, #1
   120fa:	4904      	ldr	r1, [pc, #16]	; (1210c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_55+0x50>)
   120fc:	9b01      	ldr	r3, [sp, #4]
   120fe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   12102:	bf00      	nop
   12104:	b003      	add	sp, #12
   12106:	f85d fb04 	ldr.w	pc, [sp], #4
   1210a:	bf00      	nop
   1210c:	1fff9524 	.word	0x1fff9524
   12110:	1fff9520 	.word	0x1fff9520

00012114 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_55>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_55(void)
{
   12114:	b500      	push	{lr}
   12116:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12118:	f7ee fe00 	bl	d1c <Sys_GetCoreID>
   1211c:	4603      	mov	r3, r0
   1211e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_55[u32CoreId]--;
   12120:	4a0d      	ldr	r2, [pc, #52]	; (12158 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_55+0x44>)
   12122:	9b01      	ldr	r3, [sp, #4]
   12124:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12128:	1e5a      	subs	r2, r3, #1
   1212a:	490b      	ldr	r1, [pc, #44]	; (12158 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_55+0x44>)
   1212c:	9b01      	ldr	r3, [sp, #4]
   1212e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_55[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_55[u32CoreId]))         /*if interrupts were enabled*/
   12132:	4a0a      	ldr	r2, [pc, #40]	; (1215c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_55+0x48>)
   12134:	9b01      	ldr	r3, [sp, #4]
   12136:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1213a:	f003 0301 	and.w	r3, r3, #1
   1213e:	2b00      	cmp	r3, #0
   12140:	d106      	bne.n	12150 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_55+0x3c>
   12142:	4a05      	ldr	r2, [pc, #20]	; (12158 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_55+0x44>)
   12144:	9b01      	ldr	r3, [sp, #4]
   12146:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1214a:	2b00      	cmp	r3, #0
   1214c:	d100      	bne.n	12150 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_55+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1214e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12150:	bf00      	nop
   12152:	b003      	add	sp, #12
   12154:	f85d fb04 	ldr.w	pc, [sp], #4
   12158:	1fff9524 	.word	0x1fff9524
   1215c:	1fff9520 	.word	0x1fff9520

00012160 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_56>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_56(void)
{
   12160:	b500      	push	{lr}
   12162:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12164:	f7ee fdda 	bl	d1c <Sys_GetCoreID>
   12168:	4603      	mov	r3, r0
   1216a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_56[u32CoreId])
   1216c:	4a10      	ldr	r2, [pc, #64]	; (121b0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_56+0x50>)
   1216e:	9b01      	ldr	r3, [sp, #4]
   12170:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12174:	2b00      	cmp	r3, #0
   12176:	d10d      	bne.n	12194 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_56+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12178:	f7ee fc0e 	bl	998 <Adc_schm_read_msr>
   1217c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1217e:	9b00      	ldr	r3, [sp, #0]
   12180:	f003 0301 	and.w	r3, r3, #1
   12184:	2b00      	cmp	r3, #0
   12186:	d100      	bne.n	1218a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_56+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12188:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_56[u32CoreId] = msr;
   1218a:	490a      	ldr	r1, [pc, #40]	; (121b4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_56+0x54>)
   1218c:	9b01      	ldr	r3, [sp, #4]
   1218e:	9a00      	ldr	r2, [sp, #0]
   12190:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_56[u32CoreId]++;
   12194:	4a06      	ldr	r2, [pc, #24]	; (121b0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_56+0x50>)
   12196:	9b01      	ldr	r3, [sp, #4]
   12198:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1219c:	1c5a      	adds	r2, r3, #1
   1219e:	4904      	ldr	r1, [pc, #16]	; (121b0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_56+0x50>)
   121a0:	9b01      	ldr	r3, [sp, #4]
   121a2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   121a6:	bf00      	nop
   121a8:	b003      	add	sp, #12
   121aa:	f85d fb04 	ldr.w	pc, [sp], #4
   121ae:	bf00      	nop
   121b0:	1fff952c 	.word	0x1fff952c
   121b4:	1fff9528 	.word	0x1fff9528

000121b8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_56>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_56(void)
{
   121b8:	b500      	push	{lr}
   121ba:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   121bc:	f7ee fdae 	bl	d1c <Sys_GetCoreID>
   121c0:	4603      	mov	r3, r0
   121c2:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_56[u32CoreId]--;
   121c4:	4a0d      	ldr	r2, [pc, #52]	; (121fc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_56+0x44>)
   121c6:	9b01      	ldr	r3, [sp, #4]
   121c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   121cc:	1e5a      	subs	r2, r3, #1
   121ce:	490b      	ldr	r1, [pc, #44]	; (121fc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_56+0x44>)
   121d0:	9b01      	ldr	r3, [sp, #4]
   121d2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_56[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_56[u32CoreId]))         /*if interrupts were enabled*/
   121d6:	4a0a      	ldr	r2, [pc, #40]	; (12200 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_56+0x48>)
   121d8:	9b01      	ldr	r3, [sp, #4]
   121da:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   121de:	f003 0301 	and.w	r3, r3, #1
   121e2:	2b00      	cmp	r3, #0
   121e4:	d106      	bne.n	121f4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_56+0x3c>
   121e6:	4a05      	ldr	r2, [pc, #20]	; (121fc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_56+0x44>)
   121e8:	9b01      	ldr	r3, [sp, #4]
   121ea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   121ee:	2b00      	cmp	r3, #0
   121f0:	d100      	bne.n	121f4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_56+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   121f2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   121f4:	bf00      	nop
   121f6:	b003      	add	sp, #12
   121f8:	f85d fb04 	ldr.w	pc, [sp], #4
   121fc:	1fff952c 	.word	0x1fff952c
   12200:	1fff9528 	.word	0x1fff9528

00012204 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_57>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_57(void)
{
   12204:	b500      	push	{lr}
   12206:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12208:	f7ee fd88 	bl	d1c <Sys_GetCoreID>
   1220c:	4603      	mov	r3, r0
   1220e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_57[u32CoreId])
   12210:	4a10      	ldr	r2, [pc, #64]	; (12254 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_57+0x50>)
   12212:	9b01      	ldr	r3, [sp, #4]
   12214:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12218:	2b00      	cmp	r3, #0
   1221a:	d10d      	bne.n	12238 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_57+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   1221c:	f7ee fbbc 	bl	998 <Adc_schm_read_msr>
   12220:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   12222:	9b00      	ldr	r3, [sp, #0]
   12224:	f003 0301 	and.w	r3, r3, #1
   12228:	2b00      	cmp	r3, #0
   1222a:	d100      	bne.n	1222e <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_57+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   1222c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_57[u32CoreId] = msr;
   1222e:	490a      	ldr	r1, [pc, #40]	; (12258 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_57+0x54>)
   12230:	9b01      	ldr	r3, [sp, #4]
   12232:	9a00      	ldr	r2, [sp, #0]
   12234:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_57[u32CoreId]++;
   12238:	4a06      	ldr	r2, [pc, #24]	; (12254 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_57+0x50>)
   1223a:	9b01      	ldr	r3, [sp, #4]
   1223c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12240:	1c5a      	adds	r2, r3, #1
   12242:	4904      	ldr	r1, [pc, #16]	; (12254 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_57+0x50>)
   12244:	9b01      	ldr	r3, [sp, #4]
   12246:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1224a:	bf00      	nop
   1224c:	b003      	add	sp, #12
   1224e:	f85d fb04 	ldr.w	pc, [sp], #4
   12252:	bf00      	nop
   12254:	1fff9534 	.word	0x1fff9534
   12258:	1fff9530 	.word	0x1fff9530

0001225c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_57>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_57(void)
{
   1225c:	b500      	push	{lr}
   1225e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12260:	f7ee fd5c 	bl	d1c <Sys_GetCoreID>
   12264:	4603      	mov	r3, r0
   12266:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_57[u32CoreId]--;
   12268:	4a0d      	ldr	r2, [pc, #52]	; (122a0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_57+0x44>)
   1226a:	9b01      	ldr	r3, [sp, #4]
   1226c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12270:	1e5a      	subs	r2, r3, #1
   12272:	490b      	ldr	r1, [pc, #44]	; (122a0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_57+0x44>)
   12274:	9b01      	ldr	r3, [sp, #4]
   12276:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_57[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_57[u32CoreId]))         /*if interrupts were enabled*/
   1227a:	4a0a      	ldr	r2, [pc, #40]	; (122a4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_57+0x48>)
   1227c:	9b01      	ldr	r3, [sp, #4]
   1227e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12282:	f003 0301 	and.w	r3, r3, #1
   12286:	2b00      	cmp	r3, #0
   12288:	d106      	bne.n	12298 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_57+0x3c>
   1228a:	4a05      	ldr	r2, [pc, #20]	; (122a0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_57+0x44>)
   1228c:	9b01      	ldr	r3, [sp, #4]
   1228e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12292:	2b00      	cmp	r3, #0
   12294:	d100      	bne.n	12298 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_57+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   12296:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12298:	bf00      	nop
   1229a:	b003      	add	sp, #12
   1229c:	f85d fb04 	ldr.w	pc, [sp], #4
   122a0:	1fff9534 	.word	0x1fff9534
   122a4:	1fff9530 	.word	0x1fff9530

000122a8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_58>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_58(void)
{
   122a8:	b500      	push	{lr}
   122aa:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   122ac:	f7ee fd36 	bl	d1c <Sys_GetCoreID>
   122b0:	4603      	mov	r3, r0
   122b2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_58[u32CoreId])
   122b4:	4a10      	ldr	r2, [pc, #64]	; (122f8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_58+0x50>)
   122b6:	9b01      	ldr	r3, [sp, #4]
   122b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   122bc:	2b00      	cmp	r3, #0
   122be:	d10d      	bne.n	122dc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_58+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   122c0:	f7ee fb6a 	bl	998 <Adc_schm_read_msr>
   122c4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   122c6:	9b00      	ldr	r3, [sp, #0]
   122c8:	f003 0301 	and.w	r3, r3, #1
   122cc:	2b00      	cmp	r3, #0
   122ce:	d100      	bne.n	122d2 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_58+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   122d0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_58[u32CoreId] = msr;
   122d2:	490a      	ldr	r1, [pc, #40]	; (122fc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_58+0x54>)
   122d4:	9b01      	ldr	r3, [sp, #4]
   122d6:	9a00      	ldr	r2, [sp, #0]
   122d8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_58[u32CoreId]++;
   122dc:	4a06      	ldr	r2, [pc, #24]	; (122f8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_58+0x50>)
   122de:	9b01      	ldr	r3, [sp, #4]
   122e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   122e4:	1c5a      	adds	r2, r3, #1
   122e6:	4904      	ldr	r1, [pc, #16]	; (122f8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_58+0x50>)
   122e8:	9b01      	ldr	r3, [sp, #4]
   122ea:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   122ee:	bf00      	nop
   122f0:	b003      	add	sp, #12
   122f2:	f85d fb04 	ldr.w	pc, [sp], #4
   122f6:	bf00      	nop
   122f8:	1fff953c 	.word	0x1fff953c
   122fc:	1fff9538 	.word	0x1fff9538

00012300 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_58>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_58(void)
{
   12300:	b500      	push	{lr}
   12302:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12304:	f7ee fd0a 	bl	d1c <Sys_GetCoreID>
   12308:	4603      	mov	r3, r0
   1230a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_58[u32CoreId]--;
   1230c:	4a0d      	ldr	r2, [pc, #52]	; (12344 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_58+0x44>)
   1230e:	9b01      	ldr	r3, [sp, #4]
   12310:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12314:	1e5a      	subs	r2, r3, #1
   12316:	490b      	ldr	r1, [pc, #44]	; (12344 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_58+0x44>)
   12318:	9b01      	ldr	r3, [sp, #4]
   1231a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_58[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_58[u32CoreId]))         /*if interrupts were enabled*/
   1231e:	4a0a      	ldr	r2, [pc, #40]	; (12348 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_58+0x48>)
   12320:	9b01      	ldr	r3, [sp, #4]
   12322:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12326:	f003 0301 	and.w	r3, r3, #1
   1232a:	2b00      	cmp	r3, #0
   1232c:	d106      	bne.n	1233c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_58+0x3c>
   1232e:	4a05      	ldr	r2, [pc, #20]	; (12344 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_58+0x44>)
   12330:	9b01      	ldr	r3, [sp, #4]
   12332:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12336:	2b00      	cmp	r3, #0
   12338:	d100      	bne.n	1233c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_58+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1233a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   1233c:	bf00      	nop
   1233e:	b003      	add	sp, #12
   12340:	f85d fb04 	ldr.w	pc, [sp], #4
   12344:	1fff953c 	.word	0x1fff953c
   12348:	1fff9538 	.word	0x1fff9538

0001234c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_59>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_59(void)
{
   1234c:	b500      	push	{lr}
   1234e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12350:	f7ee fce4 	bl	d1c <Sys_GetCoreID>
   12354:	4603      	mov	r3, r0
   12356:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_59[u32CoreId])
   12358:	4a10      	ldr	r2, [pc, #64]	; (1239c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_59+0x50>)
   1235a:	9b01      	ldr	r3, [sp, #4]
   1235c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12360:	2b00      	cmp	r3, #0
   12362:	d10d      	bne.n	12380 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_59+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12364:	f7ee fb18 	bl	998 <Adc_schm_read_msr>
   12368:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1236a:	9b00      	ldr	r3, [sp, #0]
   1236c:	f003 0301 	and.w	r3, r3, #1
   12370:	2b00      	cmp	r3, #0
   12372:	d100      	bne.n	12376 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_59+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12374:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_59[u32CoreId] = msr;
   12376:	490a      	ldr	r1, [pc, #40]	; (123a0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_59+0x54>)
   12378:	9b01      	ldr	r3, [sp, #4]
   1237a:	9a00      	ldr	r2, [sp, #0]
   1237c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_59[u32CoreId]++;
   12380:	4a06      	ldr	r2, [pc, #24]	; (1239c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_59+0x50>)
   12382:	9b01      	ldr	r3, [sp, #4]
   12384:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12388:	1c5a      	adds	r2, r3, #1
   1238a:	4904      	ldr	r1, [pc, #16]	; (1239c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_59+0x50>)
   1238c:	9b01      	ldr	r3, [sp, #4]
   1238e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   12392:	bf00      	nop
   12394:	b003      	add	sp, #12
   12396:	f85d fb04 	ldr.w	pc, [sp], #4
   1239a:	bf00      	nop
   1239c:	1fff9544 	.word	0x1fff9544
   123a0:	1fff9540 	.word	0x1fff9540

000123a4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_59>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_59(void)
{
   123a4:	b500      	push	{lr}
   123a6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   123a8:	f7ee fcb8 	bl	d1c <Sys_GetCoreID>
   123ac:	4603      	mov	r3, r0
   123ae:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_59[u32CoreId]--;
   123b0:	4a0d      	ldr	r2, [pc, #52]	; (123e8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_59+0x44>)
   123b2:	9b01      	ldr	r3, [sp, #4]
   123b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   123b8:	1e5a      	subs	r2, r3, #1
   123ba:	490b      	ldr	r1, [pc, #44]	; (123e8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_59+0x44>)
   123bc:	9b01      	ldr	r3, [sp, #4]
   123be:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_59[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_59[u32CoreId]))         /*if interrupts were enabled*/
   123c2:	4a0a      	ldr	r2, [pc, #40]	; (123ec <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_59+0x48>)
   123c4:	9b01      	ldr	r3, [sp, #4]
   123c6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   123ca:	f003 0301 	and.w	r3, r3, #1
   123ce:	2b00      	cmp	r3, #0
   123d0:	d106      	bne.n	123e0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_59+0x3c>
   123d2:	4a05      	ldr	r2, [pc, #20]	; (123e8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_59+0x44>)
   123d4:	9b01      	ldr	r3, [sp, #4]
   123d6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   123da:	2b00      	cmp	r3, #0
   123dc:	d100      	bne.n	123e0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_59+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   123de:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   123e0:	bf00      	nop
   123e2:	b003      	add	sp, #12
   123e4:	f85d fb04 	ldr.w	pc, [sp], #4
   123e8:	1fff9544 	.word	0x1fff9544
   123ec:	1fff9540 	.word	0x1fff9540

000123f0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_60>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_60(void)
{
   123f0:	b500      	push	{lr}
   123f2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   123f4:	f7ee fc92 	bl	d1c <Sys_GetCoreID>
   123f8:	4603      	mov	r3, r0
   123fa:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_60[u32CoreId])
   123fc:	4a10      	ldr	r2, [pc, #64]	; (12440 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_60+0x50>)
   123fe:	9b01      	ldr	r3, [sp, #4]
   12400:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12404:	2b00      	cmp	r3, #0
   12406:	d10d      	bne.n	12424 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_60+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12408:	f7ee fac6 	bl	998 <Adc_schm_read_msr>
   1240c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1240e:	9b00      	ldr	r3, [sp, #0]
   12410:	f003 0301 	and.w	r3, r3, #1
   12414:	2b00      	cmp	r3, #0
   12416:	d100      	bne.n	1241a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_60+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12418:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_60[u32CoreId] = msr;
   1241a:	490a      	ldr	r1, [pc, #40]	; (12444 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_60+0x54>)
   1241c:	9b01      	ldr	r3, [sp, #4]
   1241e:	9a00      	ldr	r2, [sp, #0]
   12420:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_60[u32CoreId]++;
   12424:	4a06      	ldr	r2, [pc, #24]	; (12440 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_60+0x50>)
   12426:	9b01      	ldr	r3, [sp, #4]
   12428:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1242c:	1c5a      	adds	r2, r3, #1
   1242e:	4904      	ldr	r1, [pc, #16]	; (12440 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_60+0x50>)
   12430:	9b01      	ldr	r3, [sp, #4]
   12432:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   12436:	bf00      	nop
   12438:	b003      	add	sp, #12
   1243a:	f85d fb04 	ldr.w	pc, [sp], #4
   1243e:	bf00      	nop
   12440:	1fff954c 	.word	0x1fff954c
   12444:	1fff9548 	.word	0x1fff9548

00012448 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_60>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_60(void)
{
   12448:	b500      	push	{lr}
   1244a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1244c:	f7ee fc66 	bl	d1c <Sys_GetCoreID>
   12450:	4603      	mov	r3, r0
   12452:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_60[u32CoreId]--;
   12454:	4a0d      	ldr	r2, [pc, #52]	; (1248c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_60+0x44>)
   12456:	9b01      	ldr	r3, [sp, #4]
   12458:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1245c:	1e5a      	subs	r2, r3, #1
   1245e:	490b      	ldr	r1, [pc, #44]	; (1248c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_60+0x44>)
   12460:	9b01      	ldr	r3, [sp, #4]
   12462:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_60[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_60[u32CoreId]))         /*if interrupts were enabled*/
   12466:	4a0a      	ldr	r2, [pc, #40]	; (12490 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_60+0x48>)
   12468:	9b01      	ldr	r3, [sp, #4]
   1246a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1246e:	f003 0301 	and.w	r3, r3, #1
   12472:	2b00      	cmp	r3, #0
   12474:	d106      	bne.n	12484 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_60+0x3c>
   12476:	4a05      	ldr	r2, [pc, #20]	; (1248c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_60+0x44>)
   12478:	9b01      	ldr	r3, [sp, #4]
   1247a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1247e:	2b00      	cmp	r3, #0
   12480:	d100      	bne.n	12484 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_60+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   12482:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12484:	bf00      	nop
   12486:	b003      	add	sp, #12
   12488:	f85d fb04 	ldr.w	pc, [sp], #4
   1248c:	1fff954c 	.word	0x1fff954c
   12490:	1fff9548 	.word	0x1fff9548

00012494 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_61>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_61(void)
{
   12494:	b500      	push	{lr}
   12496:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12498:	f7ee fc40 	bl	d1c <Sys_GetCoreID>
   1249c:	4603      	mov	r3, r0
   1249e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_61[u32CoreId])
   124a0:	4a10      	ldr	r2, [pc, #64]	; (124e4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_61+0x50>)
   124a2:	9b01      	ldr	r3, [sp, #4]
   124a4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   124a8:	2b00      	cmp	r3, #0
   124aa:	d10d      	bne.n	124c8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_61+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   124ac:	f7ee fa74 	bl	998 <Adc_schm_read_msr>
   124b0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   124b2:	9b00      	ldr	r3, [sp, #0]
   124b4:	f003 0301 	and.w	r3, r3, #1
   124b8:	2b00      	cmp	r3, #0
   124ba:	d100      	bne.n	124be <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_61+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   124bc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_61[u32CoreId] = msr;
   124be:	490a      	ldr	r1, [pc, #40]	; (124e8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_61+0x54>)
   124c0:	9b01      	ldr	r3, [sp, #4]
   124c2:	9a00      	ldr	r2, [sp, #0]
   124c4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_61[u32CoreId]++;
   124c8:	4a06      	ldr	r2, [pc, #24]	; (124e4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_61+0x50>)
   124ca:	9b01      	ldr	r3, [sp, #4]
   124cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   124d0:	1c5a      	adds	r2, r3, #1
   124d2:	4904      	ldr	r1, [pc, #16]	; (124e4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_61+0x50>)
   124d4:	9b01      	ldr	r3, [sp, #4]
   124d6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   124da:	bf00      	nop
   124dc:	b003      	add	sp, #12
   124de:	f85d fb04 	ldr.w	pc, [sp], #4
   124e2:	bf00      	nop
   124e4:	1fff9554 	.word	0x1fff9554
   124e8:	1fff9550 	.word	0x1fff9550

000124ec <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_61>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_61(void)
{
   124ec:	b500      	push	{lr}
   124ee:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   124f0:	f7ee fc14 	bl	d1c <Sys_GetCoreID>
   124f4:	4603      	mov	r3, r0
   124f6:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_61[u32CoreId]--;
   124f8:	4a0d      	ldr	r2, [pc, #52]	; (12530 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_61+0x44>)
   124fa:	9b01      	ldr	r3, [sp, #4]
   124fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12500:	1e5a      	subs	r2, r3, #1
   12502:	490b      	ldr	r1, [pc, #44]	; (12530 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_61+0x44>)
   12504:	9b01      	ldr	r3, [sp, #4]
   12506:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_61[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_61[u32CoreId]))         /*if interrupts were enabled*/
   1250a:	4a0a      	ldr	r2, [pc, #40]	; (12534 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_61+0x48>)
   1250c:	9b01      	ldr	r3, [sp, #4]
   1250e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12512:	f003 0301 	and.w	r3, r3, #1
   12516:	2b00      	cmp	r3, #0
   12518:	d106      	bne.n	12528 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_61+0x3c>
   1251a:	4a05      	ldr	r2, [pc, #20]	; (12530 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_61+0x44>)
   1251c:	9b01      	ldr	r3, [sp, #4]
   1251e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12522:	2b00      	cmp	r3, #0
   12524:	d100      	bne.n	12528 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_61+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   12526:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12528:	bf00      	nop
   1252a:	b003      	add	sp, #12
   1252c:	f85d fb04 	ldr.w	pc, [sp], #4
   12530:	1fff9554 	.word	0x1fff9554
   12534:	1fff9550 	.word	0x1fff9550

00012538 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_62>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_62(void)
{
   12538:	b500      	push	{lr}
   1253a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1253c:	f7ee fbee 	bl	d1c <Sys_GetCoreID>
   12540:	4603      	mov	r3, r0
   12542:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_62[u32CoreId])
   12544:	4a10      	ldr	r2, [pc, #64]	; (12588 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_62+0x50>)
   12546:	9b01      	ldr	r3, [sp, #4]
   12548:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1254c:	2b00      	cmp	r3, #0
   1254e:	d10d      	bne.n	1256c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_62+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12550:	f7ee fa22 	bl	998 <Adc_schm_read_msr>
   12554:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   12556:	9b00      	ldr	r3, [sp, #0]
   12558:	f003 0301 	and.w	r3, r3, #1
   1255c:	2b00      	cmp	r3, #0
   1255e:	d100      	bne.n	12562 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_62+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12560:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_62[u32CoreId] = msr;
   12562:	490a      	ldr	r1, [pc, #40]	; (1258c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_62+0x54>)
   12564:	9b01      	ldr	r3, [sp, #4]
   12566:	9a00      	ldr	r2, [sp, #0]
   12568:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_62[u32CoreId]++;
   1256c:	4a06      	ldr	r2, [pc, #24]	; (12588 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_62+0x50>)
   1256e:	9b01      	ldr	r3, [sp, #4]
   12570:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12574:	1c5a      	adds	r2, r3, #1
   12576:	4904      	ldr	r1, [pc, #16]	; (12588 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_62+0x50>)
   12578:	9b01      	ldr	r3, [sp, #4]
   1257a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1257e:	bf00      	nop
   12580:	b003      	add	sp, #12
   12582:	f85d fb04 	ldr.w	pc, [sp], #4
   12586:	bf00      	nop
   12588:	1fff955c 	.word	0x1fff955c
   1258c:	1fff9558 	.word	0x1fff9558

00012590 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_62>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_62(void)
{
   12590:	b500      	push	{lr}
   12592:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12594:	f7ee fbc2 	bl	d1c <Sys_GetCoreID>
   12598:	4603      	mov	r3, r0
   1259a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_62[u32CoreId]--;
   1259c:	4a0d      	ldr	r2, [pc, #52]	; (125d4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_62+0x44>)
   1259e:	9b01      	ldr	r3, [sp, #4]
   125a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   125a4:	1e5a      	subs	r2, r3, #1
   125a6:	490b      	ldr	r1, [pc, #44]	; (125d4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_62+0x44>)
   125a8:	9b01      	ldr	r3, [sp, #4]
   125aa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_62[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_62[u32CoreId]))         /*if interrupts were enabled*/
   125ae:	4a0a      	ldr	r2, [pc, #40]	; (125d8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_62+0x48>)
   125b0:	9b01      	ldr	r3, [sp, #4]
   125b2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   125b6:	f003 0301 	and.w	r3, r3, #1
   125ba:	2b00      	cmp	r3, #0
   125bc:	d106      	bne.n	125cc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_62+0x3c>
   125be:	4a05      	ldr	r2, [pc, #20]	; (125d4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_62+0x44>)
   125c0:	9b01      	ldr	r3, [sp, #4]
   125c2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   125c6:	2b00      	cmp	r3, #0
   125c8:	d100      	bne.n	125cc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_62+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   125ca:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   125cc:	bf00      	nop
   125ce:	b003      	add	sp, #12
   125d0:	f85d fb04 	ldr.w	pc, [sp], #4
   125d4:	1fff955c 	.word	0x1fff955c
   125d8:	1fff9558 	.word	0x1fff9558

000125dc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_63>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_63(void)
{
   125dc:	b500      	push	{lr}
   125de:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   125e0:	f7ee fb9c 	bl	d1c <Sys_GetCoreID>
   125e4:	4603      	mov	r3, r0
   125e6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_63[u32CoreId])
   125e8:	4a10      	ldr	r2, [pc, #64]	; (1262c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_63+0x50>)
   125ea:	9b01      	ldr	r3, [sp, #4]
   125ec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   125f0:	2b00      	cmp	r3, #0
   125f2:	d10d      	bne.n	12610 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_63+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   125f4:	f7ee f9d0 	bl	998 <Adc_schm_read_msr>
   125f8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   125fa:	9b00      	ldr	r3, [sp, #0]
   125fc:	f003 0301 	and.w	r3, r3, #1
   12600:	2b00      	cmp	r3, #0
   12602:	d100      	bne.n	12606 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_63+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12604:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_63[u32CoreId] = msr;
   12606:	490a      	ldr	r1, [pc, #40]	; (12630 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_63+0x54>)
   12608:	9b01      	ldr	r3, [sp, #4]
   1260a:	9a00      	ldr	r2, [sp, #0]
   1260c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_63[u32CoreId]++;
   12610:	4a06      	ldr	r2, [pc, #24]	; (1262c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_63+0x50>)
   12612:	9b01      	ldr	r3, [sp, #4]
   12614:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12618:	1c5a      	adds	r2, r3, #1
   1261a:	4904      	ldr	r1, [pc, #16]	; (1262c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_63+0x50>)
   1261c:	9b01      	ldr	r3, [sp, #4]
   1261e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   12622:	bf00      	nop
   12624:	b003      	add	sp, #12
   12626:	f85d fb04 	ldr.w	pc, [sp], #4
   1262a:	bf00      	nop
   1262c:	1fff9564 	.word	0x1fff9564
   12630:	1fff9560 	.word	0x1fff9560

00012634 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_63>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_63(void)
{
   12634:	b500      	push	{lr}
   12636:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12638:	f7ee fb70 	bl	d1c <Sys_GetCoreID>
   1263c:	4603      	mov	r3, r0
   1263e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_63[u32CoreId]--;
   12640:	4a0d      	ldr	r2, [pc, #52]	; (12678 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_63+0x44>)
   12642:	9b01      	ldr	r3, [sp, #4]
   12644:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12648:	1e5a      	subs	r2, r3, #1
   1264a:	490b      	ldr	r1, [pc, #44]	; (12678 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_63+0x44>)
   1264c:	9b01      	ldr	r3, [sp, #4]
   1264e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_63[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_63[u32CoreId]))         /*if interrupts were enabled*/
   12652:	4a0a      	ldr	r2, [pc, #40]	; (1267c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_63+0x48>)
   12654:	9b01      	ldr	r3, [sp, #4]
   12656:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1265a:	f003 0301 	and.w	r3, r3, #1
   1265e:	2b00      	cmp	r3, #0
   12660:	d106      	bne.n	12670 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_63+0x3c>
   12662:	4a05      	ldr	r2, [pc, #20]	; (12678 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_63+0x44>)
   12664:	9b01      	ldr	r3, [sp, #4]
   12666:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1266a:	2b00      	cmp	r3, #0
   1266c:	d100      	bne.n	12670 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_63+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1266e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12670:	bf00      	nop
   12672:	b003      	add	sp, #12
   12674:	f85d fb04 	ldr.w	pc, [sp], #4
   12678:	1fff9564 	.word	0x1fff9564
   1267c:	1fff9560 	.word	0x1fff9560

00012680 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_64>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_64(void)
{
   12680:	b500      	push	{lr}
   12682:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12684:	f7ee fb4a 	bl	d1c <Sys_GetCoreID>
   12688:	4603      	mov	r3, r0
   1268a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_64[u32CoreId])
   1268c:	4a10      	ldr	r2, [pc, #64]	; (126d0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_64+0x50>)
   1268e:	9b01      	ldr	r3, [sp, #4]
   12690:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12694:	2b00      	cmp	r3, #0
   12696:	d10d      	bne.n	126b4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_64+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12698:	f7ee f97e 	bl	998 <Adc_schm_read_msr>
   1269c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1269e:	9b00      	ldr	r3, [sp, #0]
   126a0:	f003 0301 	and.w	r3, r3, #1
   126a4:	2b00      	cmp	r3, #0
   126a6:	d100      	bne.n	126aa <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_64+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   126a8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_64[u32CoreId] = msr;
   126aa:	490a      	ldr	r1, [pc, #40]	; (126d4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_64+0x54>)
   126ac:	9b01      	ldr	r3, [sp, #4]
   126ae:	9a00      	ldr	r2, [sp, #0]
   126b0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_64[u32CoreId]++;
   126b4:	4a06      	ldr	r2, [pc, #24]	; (126d0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_64+0x50>)
   126b6:	9b01      	ldr	r3, [sp, #4]
   126b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   126bc:	1c5a      	adds	r2, r3, #1
   126be:	4904      	ldr	r1, [pc, #16]	; (126d0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_64+0x50>)
   126c0:	9b01      	ldr	r3, [sp, #4]
   126c2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   126c6:	bf00      	nop
   126c8:	b003      	add	sp, #12
   126ca:	f85d fb04 	ldr.w	pc, [sp], #4
   126ce:	bf00      	nop
   126d0:	1fff956c 	.word	0x1fff956c
   126d4:	1fff9568 	.word	0x1fff9568

000126d8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_64>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_64(void)
{
   126d8:	b500      	push	{lr}
   126da:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   126dc:	f7ee fb1e 	bl	d1c <Sys_GetCoreID>
   126e0:	4603      	mov	r3, r0
   126e2:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_64[u32CoreId]--;
   126e4:	4a0d      	ldr	r2, [pc, #52]	; (1271c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_64+0x44>)
   126e6:	9b01      	ldr	r3, [sp, #4]
   126e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   126ec:	1e5a      	subs	r2, r3, #1
   126ee:	490b      	ldr	r1, [pc, #44]	; (1271c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_64+0x44>)
   126f0:	9b01      	ldr	r3, [sp, #4]
   126f2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_64[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_64[u32CoreId]))         /*if interrupts were enabled*/
   126f6:	4a0a      	ldr	r2, [pc, #40]	; (12720 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_64+0x48>)
   126f8:	9b01      	ldr	r3, [sp, #4]
   126fa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   126fe:	f003 0301 	and.w	r3, r3, #1
   12702:	2b00      	cmp	r3, #0
   12704:	d106      	bne.n	12714 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_64+0x3c>
   12706:	4a05      	ldr	r2, [pc, #20]	; (1271c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_64+0x44>)
   12708:	9b01      	ldr	r3, [sp, #4]
   1270a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1270e:	2b00      	cmp	r3, #0
   12710:	d100      	bne.n	12714 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_64+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   12712:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12714:	bf00      	nop
   12716:	b003      	add	sp, #12
   12718:	f85d fb04 	ldr.w	pc, [sp], #4
   1271c:	1fff956c 	.word	0x1fff956c
   12720:	1fff9568 	.word	0x1fff9568

00012724 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_65>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_65(void)
{
   12724:	b500      	push	{lr}
   12726:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12728:	f7ee faf8 	bl	d1c <Sys_GetCoreID>
   1272c:	4603      	mov	r3, r0
   1272e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_65[u32CoreId])
   12730:	4a10      	ldr	r2, [pc, #64]	; (12774 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_65+0x50>)
   12732:	9b01      	ldr	r3, [sp, #4]
   12734:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12738:	2b00      	cmp	r3, #0
   1273a:	d10d      	bne.n	12758 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_65+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   1273c:	f7ee f92c 	bl	998 <Adc_schm_read_msr>
   12740:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   12742:	9b00      	ldr	r3, [sp, #0]
   12744:	f003 0301 	and.w	r3, r3, #1
   12748:	2b00      	cmp	r3, #0
   1274a:	d100      	bne.n	1274e <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_65+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   1274c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_65[u32CoreId] = msr;
   1274e:	490a      	ldr	r1, [pc, #40]	; (12778 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_65+0x54>)
   12750:	9b01      	ldr	r3, [sp, #4]
   12752:	9a00      	ldr	r2, [sp, #0]
   12754:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_65[u32CoreId]++;
   12758:	4a06      	ldr	r2, [pc, #24]	; (12774 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_65+0x50>)
   1275a:	9b01      	ldr	r3, [sp, #4]
   1275c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12760:	1c5a      	adds	r2, r3, #1
   12762:	4904      	ldr	r1, [pc, #16]	; (12774 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_65+0x50>)
   12764:	9b01      	ldr	r3, [sp, #4]
   12766:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1276a:	bf00      	nop
   1276c:	b003      	add	sp, #12
   1276e:	f85d fb04 	ldr.w	pc, [sp], #4
   12772:	bf00      	nop
   12774:	1fff9574 	.word	0x1fff9574
   12778:	1fff9570 	.word	0x1fff9570

0001277c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_65>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_65(void)
{
   1277c:	b500      	push	{lr}
   1277e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12780:	f7ee facc 	bl	d1c <Sys_GetCoreID>
   12784:	4603      	mov	r3, r0
   12786:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_65[u32CoreId]--;
   12788:	4a0d      	ldr	r2, [pc, #52]	; (127c0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_65+0x44>)
   1278a:	9b01      	ldr	r3, [sp, #4]
   1278c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12790:	1e5a      	subs	r2, r3, #1
   12792:	490b      	ldr	r1, [pc, #44]	; (127c0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_65+0x44>)
   12794:	9b01      	ldr	r3, [sp, #4]
   12796:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_65[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_65[u32CoreId]))         /*if interrupts were enabled*/
   1279a:	4a0a      	ldr	r2, [pc, #40]	; (127c4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_65+0x48>)
   1279c:	9b01      	ldr	r3, [sp, #4]
   1279e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   127a2:	f003 0301 	and.w	r3, r3, #1
   127a6:	2b00      	cmp	r3, #0
   127a8:	d106      	bne.n	127b8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_65+0x3c>
   127aa:	4a05      	ldr	r2, [pc, #20]	; (127c0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_65+0x44>)
   127ac:	9b01      	ldr	r3, [sp, #4]
   127ae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   127b2:	2b00      	cmp	r3, #0
   127b4:	d100      	bne.n	127b8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_65+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   127b6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   127b8:	bf00      	nop
   127ba:	b003      	add	sp, #12
   127bc:	f85d fb04 	ldr.w	pc, [sp], #4
   127c0:	1fff9574 	.word	0x1fff9574
   127c4:	1fff9570 	.word	0x1fff9570

000127c8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_66>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_66(void)
{
   127c8:	b500      	push	{lr}
   127ca:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   127cc:	f7ee faa6 	bl	d1c <Sys_GetCoreID>
   127d0:	4603      	mov	r3, r0
   127d2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_66[u32CoreId])
   127d4:	4a10      	ldr	r2, [pc, #64]	; (12818 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_66+0x50>)
   127d6:	9b01      	ldr	r3, [sp, #4]
   127d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   127dc:	2b00      	cmp	r3, #0
   127de:	d10d      	bne.n	127fc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_66+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   127e0:	f7ee f8da 	bl	998 <Adc_schm_read_msr>
   127e4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   127e6:	9b00      	ldr	r3, [sp, #0]
   127e8:	f003 0301 	and.w	r3, r3, #1
   127ec:	2b00      	cmp	r3, #0
   127ee:	d100      	bne.n	127f2 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_66+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   127f0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_66[u32CoreId] = msr;
   127f2:	490a      	ldr	r1, [pc, #40]	; (1281c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_66+0x54>)
   127f4:	9b01      	ldr	r3, [sp, #4]
   127f6:	9a00      	ldr	r2, [sp, #0]
   127f8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_66[u32CoreId]++;
   127fc:	4a06      	ldr	r2, [pc, #24]	; (12818 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_66+0x50>)
   127fe:	9b01      	ldr	r3, [sp, #4]
   12800:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12804:	1c5a      	adds	r2, r3, #1
   12806:	4904      	ldr	r1, [pc, #16]	; (12818 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_66+0x50>)
   12808:	9b01      	ldr	r3, [sp, #4]
   1280a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1280e:	bf00      	nop
   12810:	b003      	add	sp, #12
   12812:	f85d fb04 	ldr.w	pc, [sp], #4
   12816:	bf00      	nop
   12818:	1fff957c 	.word	0x1fff957c
   1281c:	1fff9578 	.word	0x1fff9578

00012820 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_66>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_66(void)
{
   12820:	b500      	push	{lr}
   12822:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12824:	f7ee fa7a 	bl	d1c <Sys_GetCoreID>
   12828:	4603      	mov	r3, r0
   1282a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_66[u32CoreId]--;
   1282c:	4a0d      	ldr	r2, [pc, #52]	; (12864 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_66+0x44>)
   1282e:	9b01      	ldr	r3, [sp, #4]
   12830:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12834:	1e5a      	subs	r2, r3, #1
   12836:	490b      	ldr	r1, [pc, #44]	; (12864 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_66+0x44>)
   12838:	9b01      	ldr	r3, [sp, #4]
   1283a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_66[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_66[u32CoreId]))         /*if interrupts were enabled*/
   1283e:	4a0a      	ldr	r2, [pc, #40]	; (12868 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_66+0x48>)
   12840:	9b01      	ldr	r3, [sp, #4]
   12842:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12846:	f003 0301 	and.w	r3, r3, #1
   1284a:	2b00      	cmp	r3, #0
   1284c:	d106      	bne.n	1285c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_66+0x3c>
   1284e:	4a05      	ldr	r2, [pc, #20]	; (12864 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_66+0x44>)
   12850:	9b01      	ldr	r3, [sp, #4]
   12852:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12856:	2b00      	cmp	r3, #0
   12858:	d100      	bne.n	1285c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_66+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1285a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   1285c:	bf00      	nop
   1285e:	b003      	add	sp, #12
   12860:	f85d fb04 	ldr.w	pc, [sp], #4
   12864:	1fff957c 	.word	0x1fff957c
   12868:	1fff9578 	.word	0x1fff9578

0001286c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_67>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_67(void)
{
   1286c:	b500      	push	{lr}
   1286e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12870:	f7ee fa54 	bl	d1c <Sys_GetCoreID>
   12874:	4603      	mov	r3, r0
   12876:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_67[u32CoreId])
   12878:	4a10      	ldr	r2, [pc, #64]	; (128bc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_67+0x50>)
   1287a:	9b01      	ldr	r3, [sp, #4]
   1287c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12880:	2b00      	cmp	r3, #0
   12882:	d10d      	bne.n	128a0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_67+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12884:	f7ee f888 	bl	998 <Adc_schm_read_msr>
   12888:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1288a:	9b00      	ldr	r3, [sp, #0]
   1288c:	f003 0301 	and.w	r3, r3, #1
   12890:	2b00      	cmp	r3, #0
   12892:	d100      	bne.n	12896 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_67+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12894:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_67[u32CoreId] = msr;
   12896:	490a      	ldr	r1, [pc, #40]	; (128c0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_67+0x54>)
   12898:	9b01      	ldr	r3, [sp, #4]
   1289a:	9a00      	ldr	r2, [sp, #0]
   1289c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_67[u32CoreId]++;
   128a0:	4a06      	ldr	r2, [pc, #24]	; (128bc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_67+0x50>)
   128a2:	9b01      	ldr	r3, [sp, #4]
   128a4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   128a8:	1c5a      	adds	r2, r3, #1
   128aa:	4904      	ldr	r1, [pc, #16]	; (128bc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_67+0x50>)
   128ac:	9b01      	ldr	r3, [sp, #4]
   128ae:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   128b2:	bf00      	nop
   128b4:	b003      	add	sp, #12
   128b6:	f85d fb04 	ldr.w	pc, [sp], #4
   128ba:	bf00      	nop
   128bc:	1fff9584 	.word	0x1fff9584
   128c0:	1fff9580 	.word	0x1fff9580

000128c4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_67>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_67(void)
{
   128c4:	b500      	push	{lr}
   128c6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   128c8:	f7ee fa28 	bl	d1c <Sys_GetCoreID>
   128cc:	4603      	mov	r3, r0
   128ce:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_67[u32CoreId]--;
   128d0:	4a0d      	ldr	r2, [pc, #52]	; (12908 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_67+0x44>)
   128d2:	9b01      	ldr	r3, [sp, #4]
   128d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   128d8:	1e5a      	subs	r2, r3, #1
   128da:	490b      	ldr	r1, [pc, #44]	; (12908 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_67+0x44>)
   128dc:	9b01      	ldr	r3, [sp, #4]
   128de:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_67[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_67[u32CoreId]))         /*if interrupts were enabled*/
   128e2:	4a0a      	ldr	r2, [pc, #40]	; (1290c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_67+0x48>)
   128e4:	9b01      	ldr	r3, [sp, #4]
   128e6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   128ea:	f003 0301 	and.w	r3, r3, #1
   128ee:	2b00      	cmp	r3, #0
   128f0:	d106      	bne.n	12900 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_67+0x3c>
   128f2:	4a05      	ldr	r2, [pc, #20]	; (12908 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_67+0x44>)
   128f4:	9b01      	ldr	r3, [sp, #4]
   128f6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   128fa:	2b00      	cmp	r3, #0
   128fc:	d100      	bne.n	12900 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_67+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   128fe:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12900:	bf00      	nop
   12902:	b003      	add	sp, #12
   12904:	f85d fb04 	ldr.w	pc, [sp], #4
   12908:	1fff9584 	.word	0x1fff9584
   1290c:	1fff9580 	.word	0x1fff9580

00012910 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_68>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_68(void)
{
   12910:	b500      	push	{lr}
   12912:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12914:	f7ee fa02 	bl	d1c <Sys_GetCoreID>
   12918:	4603      	mov	r3, r0
   1291a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_68[u32CoreId])
   1291c:	4a10      	ldr	r2, [pc, #64]	; (12960 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_68+0x50>)
   1291e:	9b01      	ldr	r3, [sp, #4]
   12920:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12924:	2b00      	cmp	r3, #0
   12926:	d10d      	bne.n	12944 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_68+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12928:	f7ee f836 	bl	998 <Adc_schm_read_msr>
   1292c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1292e:	9b00      	ldr	r3, [sp, #0]
   12930:	f003 0301 	and.w	r3, r3, #1
   12934:	2b00      	cmp	r3, #0
   12936:	d100      	bne.n	1293a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_68+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12938:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_68[u32CoreId] = msr;
   1293a:	490a      	ldr	r1, [pc, #40]	; (12964 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_68+0x54>)
   1293c:	9b01      	ldr	r3, [sp, #4]
   1293e:	9a00      	ldr	r2, [sp, #0]
   12940:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_68[u32CoreId]++;
   12944:	4a06      	ldr	r2, [pc, #24]	; (12960 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_68+0x50>)
   12946:	9b01      	ldr	r3, [sp, #4]
   12948:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1294c:	1c5a      	adds	r2, r3, #1
   1294e:	4904      	ldr	r1, [pc, #16]	; (12960 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_68+0x50>)
   12950:	9b01      	ldr	r3, [sp, #4]
   12952:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   12956:	bf00      	nop
   12958:	b003      	add	sp, #12
   1295a:	f85d fb04 	ldr.w	pc, [sp], #4
   1295e:	bf00      	nop
   12960:	1fff958c 	.word	0x1fff958c
   12964:	1fff9588 	.word	0x1fff9588

00012968 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_68>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_68(void)
{
   12968:	b500      	push	{lr}
   1296a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1296c:	f7ee f9d6 	bl	d1c <Sys_GetCoreID>
   12970:	4603      	mov	r3, r0
   12972:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_68[u32CoreId]--;
   12974:	4a0d      	ldr	r2, [pc, #52]	; (129ac <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_68+0x44>)
   12976:	9b01      	ldr	r3, [sp, #4]
   12978:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1297c:	1e5a      	subs	r2, r3, #1
   1297e:	490b      	ldr	r1, [pc, #44]	; (129ac <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_68+0x44>)
   12980:	9b01      	ldr	r3, [sp, #4]
   12982:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_68[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_68[u32CoreId]))         /*if interrupts were enabled*/
   12986:	4a0a      	ldr	r2, [pc, #40]	; (129b0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_68+0x48>)
   12988:	9b01      	ldr	r3, [sp, #4]
   1298a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1298e:	f003 0301 	and.w	r3, r3, #1
   12992:	2b00      	cmp	r3, #0
   12994:	d106      	bne.n	129a4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_68+0x3c>
   12996:	4a05      	ldr	r2, [pc, #20]	; (129ac <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_68+0x44>)
   12998:	9b01      	ldr	r3, [sp, #4]
   1299a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1299e:	2b00      	cmp	r3, #0
   129a0:	d100      	bne.n	129a4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_68+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   129a2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   129a4:	bf00      	nop
   129a6:	b003      	add	sp, #12
   129a8:	f85d fb04 	ldr.w	pc, [sp], #4
   129ac:	1fff958c 	.word	0x1fff958c
   129b0:	1fff9588 	.word	0x1fff9588

000129b4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_69>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_69(void)
{
   129b4:	b500      	push	{lr}
   129b6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   129b8:	f7ee f9b0 	bl	d1c <Sys_GetCoreID>
   129bc:	4603      	mov	r3, r0
   129be:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_69[u32CoreId])
   129c0:	4a10      	ldr	r2, [pc, #64]	; (12a04 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_69+0x50>)
   129c2:	9b01      	ldr	r3, [sp, #4]
   129c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   129c8:	2b00      	cmp	r3, #0
   129ca:	d10d      	bne.n	129e8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_69+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   129cc:	f7ed ffe4 	bl	998 <Adc_schm_read_msr>
   129d0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   129d2:	9b00      	ldr	r3, [sp, #0]
   129d4:	f003 0301 	and.w	r3, r3, #1
   129d8:	2b00      	cmp	r3, #0
   129da:	d100      	bne.n	129de <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_69+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   129dc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_69[u32CoreId] = msr;
   129de:	490a      	ldr	r1, [pc, #40]	; (12a08 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_69+0x54>)
   129e0:	9b01      	ldr	r3, [sp, #4]
   129e2:	9a00      	ldr	r2, [sp, #0]
   129e4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_69[u32CoreId]++;
   129e8:	4a06      	ldr	r2, [pc, #24]	; (12a04 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_69+0x50>)
   129ea:	9b01      	ldr	r3, [sp, #4]
   129ec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   129f0:	1c5a      	adds	r2, r3, #1
   129f2:	4904      	ldr	r1, [pc, #16]	; (12a04 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_69+0x50>)
   129f4:	9b01      	ldr	r3, [sp, #4]
   129f6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   129fa:	bf00      	nop
   129fc:	b003      	add	sp, #12
   129fe:	f85d fb04 	ldr.w	pc, [sp], #4
   12a02:	bf00      	nop
   12a04:	1fff9594 	.word	0x1fff9594
   12a08:	1fff9590 	.word	0x1fff9590

00012a0c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_69>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_69(void)
{
   12a0c:	b500      	push	{lr}
   12a0e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12a10:	f7ee f984 	bl	d1c <Sys_GetCoreID>
   12a14:	4603      	mov	r3, r0
   12a16:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_69[u32CoreId]--;
   12a18:	4a0d      	ldr	r2, [pc, #52]	; (12a50 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_69+0x44>)
   12a1a:	9b01      	ldr	r3, [sp, #4]
   12a1c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12a20:	1e5a      	subs	r2, r3, #1
   12a22:	490b      	ldr	r1, [pc, #44]	; (12a50 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_69+0x44>)
   12a24:	9b01      	ldr	r3, [sp, #4]
   12a26:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_69[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_69[u32CoreId]))         /*if interrupts were enabled*/
   12a2a:	4a0a      	ldr	r2, [pc, #40]	; (12a54 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_69+0x48>)
   12a2c:	9b01      	ldr	r3, [sp, #4]
   12a2e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12a32:	f003 0301 	and.w	r3, r3, #1
   12a36:	2b00      	cmp	r3, #0
   12a38:	d106      	bne.n	12a48 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_69+0x3c>
   12a3a:	4a05      	ldr	r2, [pc, #20]	; (12a50 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_69+0x44>)
   12a3c:	9b01      	ldr	r3, [sp, #4]
   12a3e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12a42:	2b00      	cmp	r3, #0
   12a44:	d100      	bne.n	12a48 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_69+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   12a46:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12a48:	bf00      	nop
   12a4a:	b003      	add	sp, #12
   12a4c:	f85d fb04 	ldr.w	pc, [sp], #4
   12a50:	1fff9594 	.word	0x1fff9594
   12a54:	1fff9590 	.word	0x1fff9590

00012a58 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_70>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_70(void)
{
   12a58:	b500      	push	{lr}
   12a5a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12a5c:	f7ee f95e 	bl	d1c <Sys_GetCoreID>
   12a60:	4603      	mov	r3, r0
   12a62:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_70[u32CoreId])
   12a64:	4a10      	ldr	r2, [pc, #64]	; (12aa8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_70+0x50>)
   12a66:	9b01      	ldr	r3, [sp, #4]
   12a68:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12a6c:	2b00      	cmp	r3, #0
   12a6e:	d10d      	bne.n	12a8c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_70+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12a70:	f7ed ff92 	bl	998 <Adc_schm_read_msr>
   12a74:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   12a76:	9b00      	ldr	r3, [sp, #0]
   12a78:	f003 0301 	and.w	r3, r3, #1
   12a7c:	2b00      	cmp	r3, #0
   12a7e:	d100      	bne.n	12a82 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_70+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12a80:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_70[u32CoreId] = msr;
   12a82:	490a      	ldr	r1, [pc, #40]	; (12aac <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_70+0x54>)
   12a84:	9b01      	ldr	r3, [sp, #4]
   12a86:	9a00      	ldr	r2, [sp, #0]
   12a88:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_70[u32CoreId]++;
   12a8c:	4a06      	ldr	r2, [pc, #24]	; (12aa8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_70+0x50>)
   12a8e:	9b01      	ldr	r3, [sp, #4]
   12a90:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12a94:	1c5a      	adds	r2, r3, #1
   12a96:	4904      	ldr	r1, [pc, #16]	; (12aa8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_70+0x50>)
   12a98:	9b01      	ldr	r3, [sp, #4]
   12a9a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   12a9e:	bf00      	nop
   12aa0:	b003      	add	sp, #12
   12aa2:	f85d fb04 	ldr.w	pc, [sp], #4
   12aa6:	bf00      	nop
   12aa8:	1fff959c 	.word	0x1fff959c
   12aac:	1fff9598 	.word	0x1fff9598

00012ab0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_70>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_70(void)
{
   12ab0:	b500      	push	{lr}
   12ab2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12ab4:	f7ee f932 	bl	d1c <Sys_GetCoreID>
   12ab8:	4603      	mov	r3, r0
   12aba:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_70[u32CoreId]--;
   12abc:	4a0d      	ldr	r2, [pc, #52]	; (12af4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_70+0x44>)
   12abe:	9b01      	ldr	r3, [sp, #4]
   12ac0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12ac4:	1e5a      	subs	r2, r3, #1
   12ac6:	490b      	ldr	r1, [pc, #44]	; (12af4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_70+0x44>)
   12ac8:	9b01      	ldr	r3, [sp, #4]
   12aca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_70[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_70[u32CoreId]))         /*if interrupts were enabled*/
   12ace:	4a0a      	ldr	r2, [pc, #40]	; (12af8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_70+0x48>)
   12ad0:	9b01      	ldr	r3, [sp, #4]
   12ad2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12ad6:	f003 0301 	and.w	r3, r3, #1
   12ada:	2b00      	cmp	r3, #0
   12adc:	d106      	bne.n	12aec <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_70+0x3c>
   12ade:	4a05      	ldr	r2, [pc, #20]	; (12af4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_70+0x44>)
   12ae0:	9b01      	ldr	r3, [sp, #4]
   12ae2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12ae6:	2b00      	cmp	r3, #0
   12ae8:	d100      	bne.n	12aec <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_70+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   12aea:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12aec:	bf00      	nop
   12aee:	b003      	add	sp, #12
   12af0:	f85d fb04 	ldr.w	pc, [sp], #4
   12af4:	1fff959c 	.word	0x1fff959c
   12af8:	1fff9598 	.word	0x1fff9598

00012afc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_71>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_71(void)
{
   12afc:	b500      	push	{lr}
   12afe:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12b00:	f7ee f90c 	bl	d1c <Sys_GetCoreID>
   12b04:	4603      	mov	r3, r0
   12b06:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_71[u32CoreId])
   12b08:	4a10      	ldr	r2, [pc, #64]	; (12b4c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_71+0x50>)
   12b0a:	9b01      	ldr	r3, [sp, #4]
   12b0c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12b10:	2b00      	cmp	r3, #0
   12b12:	d10d      	bne.n	12b30 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_71+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12b14:	f7ed ff40 	bl	998 <Adc_schm_read_msr>
   12b18:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   12b1a:	9b00      	ldr	r3, [sp, #0]
   12b1c:	f003 0301 	and.w	r3, r3, #1
   12b20:	2b00      	cmp	r3, #0
   12b22:	d100      	bne.n	12b26 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_71+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12b24:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_71[u32CoreId] = msr;
   12b26:	490a      	ldr	r1, [pc, #40]	; (12b50 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_71+0x54>)
   12b28:	9b01      	ldr	r3, [sp, #4]
   12b2a:	9a00      	ldr	r2, [sp, #0]
   12b2c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_71[u32CoreId]++;
   12b30:	4a06      	ldr	r2, [pc, #24]	; (12b4c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_71+0x50>)
   12b32:	9b01      	ldr	r3, [sp, #4]
   12b34:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12b38:	1c5a      	adds	r2, r3, #1
   12b3a:	4904      	ldr	r1, [pc, #16]	; (12b4c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_71+0x50>)
   12b3c:	9b01      	ldr	r3, [sp, #4]
   12b3e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   12b42:	bf00      	nop
   12b44:	b003      	add	sp, #12
   12b46:	f85d fb04 	ldr.w	pc, [sp], #4
   12b4a:	bf00      	nop
   12b4c:	1fff95a4 	.word	0x1fff95a4
   12b50:	1fff95a0 	.word	0x1fff95a0

00012b54 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_71>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_71(void)
{
   12b54:	b500      	push	{lr}
   12b56:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12b58:	f7ee f8e0 	bl	d1c <Sys_GetCoreID>
   12b5c:	4603      	mov	r3, r0
   12b5e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_71[u32CoreId]--;
   12b60:	4a0d      	ldr	r2, [pc, #52]	; (12b98 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_71+0x44>)
   12b62:	9b01      	ldr	r3, [sp, #4]
   12b64:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12b68:	1e5a      	subs	r2, r3, #1
   12b6a:	490b      	ldr	r1, [pc, #44]	; (12b98 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_71+0x44>)
   12b6c:	9b01      	ldr	r3, [sp, #4]
   12b6e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_71[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_71[u32CoreId]))         /*if interrupts were enabled*/
   12b72:	4a0a      	ldr	r2, [pc, #40]	; (12b9c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_71+0x48>)
   12b74:	9b01      	ldr	r3, [sp, #4]
   12b76:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12b7a:	f003 0301 	and.w	r3, r3, #1
   12b7e:	2b00      	cmp	r3, #0
   12b80:	d106      	bne.n	12b90 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_71+0x3c>
   12b82:	4a05      	ldr	r2, [pc, #20]	; (12b98 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_71+0x44>)
   12b84:	9b01      	ldr	r3, [sp, #4]
   12b86:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12b8a:	2b00      	cmp	r3, #0
   12b8c:	d100      	bne.n	12b90 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_71+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   12b8e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12b90:	bf00      	nop
   12b92:	b003      	add	sp, #12
   12b94:	f85d fb04 	ldr.w	pc, [sp], #4
   12b98:	1fff95a4 	.word	0x1fff95a4
   12b9c:	1fff95a0 	.word	0x1fff95a0

00012ba0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_72>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_72(void)
{
   12ba0:	b500      	push	{lr}
   12ba2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12ba4:	f7ee f8ba 	bl	d1c <Sys_GetCoreID>
   12ba8:	4603      	mov	r3, r0
   12baa:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_72[u32CoreId])
   12bac:	4a10      	ldr	r2, [pc, #64]	; (12bf0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_72+0x50>)
   12bae:	9b01      	ldr	r3, [sp, #4]
   12bb0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12bb4:	2b00      	cmp	r3, #0
   12bb6:	d10d      	bne.n	12bd4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_72+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12bb8:	f7ed feee 	bl	998 <Adc_schm_read_msr>
   12bbc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   12bbe:	9b00      	ldr	r3, [sp, #0]
   12bc0:	f003 0301 	and.w	r3, r3, #1
   12bc4:	2b00      	cmp	r3, #0
   12bc6:	d100      	bne.n	12bca <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_72+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12bc8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_72[u32CoreId] = msr;
   12bca:	490a      	ldr	r1, [pc, #40]	; (12bf4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_72+0x54>)
   12bcc:	9b01      	ldr	r3, [sp, #4]
   12bce:	9a00      	ldr	r2, [sp, #0]
   12bd0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_72[u32CoreId]++;
   12bd4:	4a06      	ldr	r2, [pc, #24]	; (12bf0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_72+0x50>)
   12bd6:	9b01      	ldr	r3, [sp, #4]
   12bd8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12bdc:	1c5a      	adds	r2, r3, #1
   12bde:	4904      	ldr	r1, [pc, #16]	; (12bf0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_72+0x50>)
   12be0:	9b01      	ldr	r3, [sp, #4]
   12be2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   12be6:	bf00      	nop
   12be8:	b003      	add	sp, #12
   12bea:	f85d fb04 	ldr.w	pc, [sp], #4
   12bee:	bf00      	nop
   12bf0:	1fff95ac 	.word	0x1fff95ac
   12bf4:	1fff95a8 	.word	0x1fff95a8

00012bf8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_72>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_72(void)
{
   12bf8:	b500      	push	{lr}
   12bfa:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12bfc:	f7ee f88e 	bl	d1c <Sys_GetCoreID>
   12c00:	4603      	mov	r3, r0
   12c02:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_72[u32CoreId]--;
   12c04:	4a0d      	ldr	r2, [pc, #52]	; (12c3c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_72+0x44>)
   12c06:	9b01      	ldr	r3, [sp, #4]
   12c08:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12c0c:	1e5a      	subs	r2, r3, #1
   12c0e:	490b      	ldr	r1, [pc, #44]	; (12c3c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_72+0x44>)
   12c10:	9b01      	ldr	r3, [sp, #4]
   12c12:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_72[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_72[u32CoreId]))         /*if interrupts were enabled*/
   12c16:	4a0a      	ldr	r2, [pc, #40]	; (12c40 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_72+0x48>)
   12c18:	9b01      	ldr	r3, [sp, #4]
   12c1a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12c1e:	f003 0301 	and.w	r3, r3, #1
   12c22:	2b00      	cmp	r3, #0
   12c24:	d106      	bne.n	12c34 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_72+0x3c>
   12c26:	4a05      	ldr	r2, [pc, #20]	; (12c3c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_72+0x44>)
   12c28:	9b01      	ldr	r3, [sp, #4]
   12c2a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12c2e:	2b00      	cmp	r3, #0
   12c30:	d100      	bne.n	12c34 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_72+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   12c32:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12c34:	bf00      	nop
   12c36:	b003      	add	sp, #12
   12c38:	f85d fb04 	ldr.w	pc, [sp], #4
   12c3c:	1fff95ac 	.word	0x1fff95ac
   12c40:	1fff95a8 	.word	0x1fff95a8

00012c44 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_73>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_73(void)
{
   12c44:	b500      	push	{lr}
   12c46:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12c48:	f7ee f868 	bl	d1c <Sys_GetCoreID>
   12c4c:	4603      	mov	r3, r0
   12c4e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_73[u32CoreId])
   12c50:	4a10      	ldr	r2, [pc, #64]	; (12c94 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_73+0x50>)
   12c52:	9b01      	ldr	r3, [sp, #4]
   12c54:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12c58:	2b00      	cmp	r3, #0
   12c5a:	d10d      	bne.n	12c78 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_73+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12c5c:	f7ed fe9c 	bl	998 <Adc_schm_read_msr>
   12c60:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   12c62:	9b00      	ldr	r3, [sp, #0]
   12c64:	f003 0301 	and.w	r3, r3, #1
   12c68:	2b00      	cmp	r3, #0
   12c6a:	d100      	bne.n	12c6e <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_73+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12c6c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_73[u32CoreId] = msr;
   12c6e:	490a      	ldr	r1, [pc, #40]	; (12c98 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_73+0x54>)
   12c70:	9b01      	ldr	r3, [sp, #4]
   12c72:	9a00      	ldr	r2, [sp, #0]
   12c74:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_73[u32CoreId]++;
   12c78:	4a06      	ldr	r2, [pc, #24]	; (12c94 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_73+0x50>)
   12c7a:	9b01      	ldr	r3, [sp, #4]
   12c7c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12c80:	1c5a      	adds	r2, r3, #1
   12c82:	4904      	ldr	r1, [pc, #16]	; (12c94 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_73+0x50>)
   12c84:	9b01      	ldr	r3, [sp, #4]
   12c86:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   12c8a:	bf00      	nop
   12c8c:	b003      	add	sp, #12
   12c8e:	f85d fb04 	ldr.w	pc, [sp], #4
   12c92:	bf00      	nop
   12c94:	1fff95b4 	.word	0x1fff95b4
   12c98:	1fff95b0 	.word	0x1fff95b0

00012c9c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_73>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_73(void)
{
   12c9c:	b500      	push	{lr}
   12c9e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12ca0:	f7ee f83c 	bl	d1c <Sys_GetCoreID>
   12ca4:	4603      	mov	r3, r0
   12ca6:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_73[u32CoreId]--;
   12ca8:	4a0d      	ldr	r2, [pc, #52]	; (12ce0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_73+0x44>)
   12caa:	9b01      	ldr	r3, [sp, #4]
   12cac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12cb0:	1e5a      	subs	r2, r3, #1
   12cb2:	490b      	ldr	r1, [pc, #44]	; (12ce0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_73+0x44>)
   12cb4:	9b01      	ldr	r3, [sp, #4]
   12cb6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_73[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_73[u32CoreId]))         /*if interrupts were enabled*/
   12cba:	4a0a      	ldr	r2, [pc, #40]	; (12ce4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_73+0x48>)
   12cbc:	9b01      	ldr	r3, [sp, #4]
   12cbe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12cc2:	f003 0301 	and.w	r3, r3, #1
   12cc6:	2b00      	cmp	r3, #0
   12cc8:	d106      	bne.n	12cd8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_73+0x3c>
   12cca:	4a05      	ldr	r2, [pc, #20]	; (12ce0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_73+0x44>)
   12ccc:	9b01      	ldr	r3, [sp, #4]
   12cce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12cd2:	2b00      	cmp	r3, #0
   12cd4:	d100      	bne.n	12cd8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_73+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   12cd6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12cd8:	bf00      	nop
   12cda:	b003      	add	sp, #12
   12cdc:	f85d fb04 	ldr.w	pc, [sp], #4
   12ce0:	1fff95b4 	.word	0x1fff95b4
   12ce4:	1fff95b0 	.word	0x1fff95b0

00012ce8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_74>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_74(void)
{
   12ce8:	b500      	push	{lr}
   12cea:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12cec:	f7ee f816 	bl	d1c <Sys_GetCoreID>
   12cf0:	4603      	mov	r3, r0
   12cf2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_74[u32CoreId])
   12cf4:	4a10      	ldr	r2, [pc, #64]	; (12d38 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_74+0x50>)
   12cf6:	9b01      	ldr	r3, [sp, #4]
   12cf8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12cfc:	2b00      	cmp	r3, #0
   12cfe:	d10d      	bne.n	12d1c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_74+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12d00:	f7ed fe4a 	bl	998 <Adc_schm_read_msr>
   12d04:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   12d06:	9b00      	ldr	r3, [sp, #0]
   12d08:	f003 0301 	and.w	r3, r3, #1
   12d0c:	2b00      	cmp	r3, #0
   12d0e:	d100      	bne.n	12d12 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_74+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12d10:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_74[u32CoreId] = msr;
   12d12:	490a      	ldr	r1, [pc, #40]	; (12d3c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_74+0x54>)
   12d14:	9b01      	ldr	r3, [sp, #4]
   12d16:	9a00      	ldr	r2, [sp, #0]
   12d18:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_74[u32CoreId]++;
   12d1c:	4a06      	ldr	r2, [pc, #24]	; (12d38 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_74+0x50>)
   12d1e:	9b01      	ldr	r3, [sp, #4]
   12d20:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12d24:	1c5a      	adds	r2, r3, #1
   12d26:	4904      	ldr	r1, [pc, #16]	; (12d38 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_74+0x50>)
   12d28:	9b01      	ldr	r3, [sp, #4]
   12d2a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   12d2e:	bf00      	nop
   12d30:	b003      	add	sp, #12
   12d32:	f85d fb04 	ldr.w	pc, [sp], #4
   12d36:	bf00      	nop
   12d38:	1fff95bc 	.word	0x1fff95bc
   12d3c:	1fff95b8 	.word	0x1fff95b8

00012d40 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_74>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_74(void)
{
   12d40:	b500      	push	{lr}
   12d42:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12d44:	f7ed ffea 	bl	d1c <Sys_GetCoreID>
   12d48:	4603      	mov	r3, r0
   12d4a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_74[u32CoreId]--;
   12d4c:	4a0d      	ldr	r2, [pc, #52]	; (12d84 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_74+0x44>)
   12d4e:	9b01      	ldr	r3, [sp, #4]
   12d50:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12d54:	1e5a      	subs	r2, r3, #1
   12d56:	490b      	ldr	r1, [pc, #44]	; (12d84 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_74+0x44>)
   12d58:	9b01      	ldr	r3, [sp, #4]
   12d5a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_74[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_74[u32CoreId]))         /*if interrupts were enabled*/
   12d5e:	4a0a      	ldr	r2, [pc, #40]	; (12d88 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_74+0x48>)
   12d60:	9b01      	ldr	r3, [sp, #4]
   12d62:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12d66:	f003 0301 	and.w	r3, r3, #1
   12d6a:	2b00      	cmp	r3, #0
   12d6c:	d106      	bne.n	12d7c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_74+0x3c>
   12d6e:	4a05      	ldr	r2, [pc, #20]	; (12d84 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_74+0x44>)
   12d70:	9b01      	ldr	r3, [sp, #4]
   12d72:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12d76:	2b00      	cmp	r3, #0
   12d78:	d100      	bne.n	12d7c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_74+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   12d7a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12d7c:	bf00      	nop
   12d7e:	b003      	add	sp, #12
   12d80:	f85d fb04 	ldr.w	pc, [sp], #4
   12d84:	1fff95bc 	.word	0x1fff95bc
   12d88:	1fff95b8 	.word	0x1fff95b8

00012d8c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_75>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_75(void)
{
   12d8c:	b500      	push	{lr}
   12d8e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12d90:	f7ed ffc4 	bl	d1c <Sys_GetCoreID>
   12d94:	4603      	mov	r3, r0
   12d96:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_75[u32CoreId])
   12d98:	4a10      	ldr	r2, [pc, #64]	; (12ddc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_75+0x50>)
   12d9a:	9b01      	ldr	r3, [sp, #4]
   12d9c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12da0:	2b00      	cmp	r3, #0
   12da2:	d10d      	bne.n	12dc0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_75+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12da4:	f7ed fdf8 	bl	998 <Adc_schm_read_msr>
   12da8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   12daa:	9b00      	ldr	r3, [sp, #0]
   12dac:	f003 0301 	and.w	r3, r3, #1
   12db0:	2b00      	cmp	r3, #0
   12db2:	d100      	bne.n	12db6 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_75+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12db4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_75[u32CoreId] = msr;
   12db6:	490a      	ldr	r1, [pc, #40]	; (12de0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_75+0x54>)
   12db8:	9b01      	ldr	r3, [sp, #4]
   12dba:	9a00      	ldr	r2, [sp, #0]
   12dbc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_75[u32CoreId]++;
   12dc0:	4a06      	ldr	r2, [pc, #24]	; (12ddc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_75+0x50>)
   12dc2:	9b01      	ldr	r3, [sp, #4]
   12dc4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12dc8:	1c5a      	adds	r2, r3, #1
   12dca:	4904      	ldr	r1, [pc, #16]	; (12ddc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_75+0x50>)
   12dcc:	9b01      	ldr	r3, [sp, #4]
   12dce:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   12dd2:	bf00      	nop
   12dd4:	b003      	add	sp, #12
   12dd6:	f85d fb04 	ldr.w	pc, [sp], #4
   12dda:	bf00      	nop
   12ddc:	1fff95c4 	.word	0x1fff95c4
   12de0:	1fff95c0 	.word	0x1fff95c0

00012de4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_75>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_75(void)
{
   12de4:	b500      	push	{lr}
   12de6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12de8:	f7ed ff98 	bl	d1c <Sys_GetCoreID>
   12dec:	4603      	mov	r3, r0
   12dee:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_75[u32CoreId]--;
   12df0:	4a0d      	ldr	r2, [pc, #52]	; (12e28 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_75+0x44>)
   12df2:	9b01      	ldr	r3, [sp, #4]
   12df4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12df8:	1e5a      	subs	r2, r3, #1
   12dfa:	490b      	ldr	r1, [pc, #44]	; (12e28 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_75+0x44>)
   12dfc:	9b01      	ldr	r3, [sp, #4]
   12dfe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_75[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_75[u32CoreId]))         /*if interrupts were enabled*/
   12e02:	4a0a      	ldr	r2, [pc, #40]	; (12e2c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_75+0x48>)
   12e04:	9b01      	ldr	r3, [sp, #4]
   12e06:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12e0a:	f003 0301 	and.w	r3, r3, #1
   12e0e:	2b00      	cmp	r3, #0
   12e10:	d106      	bne.n	12e20 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_75+0x3c>
   12e12:	4a05      	ldr	r2, [pc, #20]	; (12e28 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_75+0x44>)
   12e14:	9b01      	ldr	r3, [sp, #4]
   12e16:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12e1a:	2b00      	cmp	r3, #0
   12e1c:	d100      	bne.n	12e20 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_75+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   12e1e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12e20:	bf00      	nop
   12e22:	b003      	add	sp, #12
   12e24:	f85d fb04 	ldr.w	pc, [sp], #4
   12e28:	1fff95c4 	.word	0x1fff95c4
   12e2c:	1fff95c0 	.word	0x1fff95c0

00012e30 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_76>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_76(void)
{
   12e30:	b500      	push	{lr}
   12e32:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12e34:	f7ed ff72 	bl	d1c <Sys_GetCoreID>
   12e38:	4603      	mov	r3, r0
   12e3a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_76[u32CoreId])
   12e3c:	4a10      	ldr	r2, [pc, #64]	; (12e80 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_76+0x50>)
   12e3e:	9b01      	ldr	r3, [sp, #4]
   12e40:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12e44:	2b00      	cmp	r3, #0
   12e46:	d10d      	bne.n	12e64 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_76+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12e48:	f7ed fda6 	bl	998 <Adc_schm_read_msr>
   12e4c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   12e4e:	9b00      	ldr	r3, [sp, #0]
   12e50:	f003 0301 	and.w	r3, r3, #1
   12e54:	2b00      	cmp	r3, #0
   12e56:	d100      	bne.n	12e5a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_76+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12e58:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_76[u32CoreId] = msr;
   12e5a:	490a      	ldr	r1, [pc, #40]	; (12e84 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_76+0x54>)
   12e5c:	9b01      	ldr	r3, [sp, #4]
   12e5e:	9a00      	ldr	r2, [sp, #0]
   12e60:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_76[u32CoreId]++;
   12e64:	4a06      	ldr	r2, [pc, #24]	; (12e80 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_76+0x50>)
   12e66:	9b01      	ldr	r3, [sp, #4]
   12e68:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12e6c:	1c5a      	adds	r2, r3, #1
   12e6e:	4904      	ldr	r1, [pc, #16]	; (12e80 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_76+0x50>)
   12e70:	9b01      	ldr	r3, [sp, #4]
   12e72:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   12e76:	bf00      	nop
   12e78:	b003      	add	sp, #12
   12e7a:	f85d fb04 	ldr.w	pc, [sp], #4
   12e7e:	bf00      	nop
   12e80:	1fff95cc 	.word	0x1fff95cc
   12e84:	1fff95c8 	.word	0x1fff95c8

00012e88 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_76>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_76(void)
{
   12e88:	b500      	push	{lr}
   12e8a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12e8c:	f7ed ff46 	bl	d1c <Sys_GetCoreID>
   12e90:	4603      	mov	r3, r0
   12e92:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_76[u32CoreId]--;
   12e94:	4a0d      	ldr	r2, [pc, #52]	; (12ecc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_76+0x44>)
   12e96:	9b01      	ldr	r3, [sp, #4]
   12e98:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12e9c:	1e5a      	subs	r2, r3, #1
   12e9e:	490b      	ldr	r1, [pc, #44]	; (12ecc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_76+0x44>)
   12ea0:	9b01      	ldr	r3, [sp, #4]
   12ea2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_76[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_76[u32CoreId]))         /*if interrupts were enabled*/
   12ea6:	4a0a      	ldr	r2, [pc, #40]	; (12ed0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_76+0x48>)
   12ea8:	9b01      	ldr	r3, [sp, #4]
   12eaa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12eae:	f003 0301 	and.w	r3, r3, #1
   12eb2:	2b00      	cmp	r3, #0
   12eb4:	d106      	bne.n	12ec4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_76+0x3c>
   12eb6:	4a05      	ldr	r2, [pc, #20]	; (12ecc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_76+0x44>)
   12eb8:	9b01      	ldr	r3, [sp, #4]
   12eba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12ebe:	2b00      	cmp	r3, #0
   12ec0:	d100      	bne.n	12ec4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_76+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   12ec2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12ec4:	bf00      	nop
   12ec6:	b003      	add	sp, #12
   12ec8:	f85d fb04 	ldr.w	pc, [sp], #4
   12ecc:	1fff95cc 	.word	0x1fff95cc
   12ed0:	1fff95c8 	.word	0x1fff95c8

00012ed4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_77>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_77(void)
{
   12ed4:	b500      	push	{lr}
   12ed6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12ed8:	f7ed ff20 	bl	d1c <Sys_GetCoreID>
   12edc:	4603      	mov	r3, r0
   12ede:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_77[u32CoreId])
   12ee0:	4a10      	ldr	r2, [pc, #64]	; (12f24 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_77+0x50>)
   12ee2:	9b01      	ldr	r3, [sp, #4]
   12ee4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12ee8:	2b00      	cmp	r3, #0
   12eea:	d10d      	bne.n	12f08 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_77+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12eec:	f7ed fd54 	bl	998 <Adc_schm_read_msr>
   12ef0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   12ef2:	9b00      	ldr	r3, [sp, #0]
   12ef4:	f003 0301 	and.w	r3, r3, #1
   12ef8:	2b00      	cmp	r3, #0
   12efa:	d100      	bne.n	12efe <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_77+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12efc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_77[u32CoreId] = msr;
   12efe:	490a      	ldr	r1, [pc, #40]	; (12f28 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_77+0x54>)
   12f00:	9b01      	ldr	r3, [sp, #4]
   12f02:	9a00      	ldr	r2, [sp, #0]
   12f04:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_77[u32CoreId]++;
   12f08:	4a06      	ldr	r2, [pc, #24]	; (12f24 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_77+0x50>)
   12f0a:	9b01      	ldr	r3, [sp, #4]
   12f0c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12f10:	1c5a      	adds	r2, r3, #1
   12f12:	4904      	ldr	r1, [pc, #16]	; (12f24 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_77+0x50>)
   12f14:	9b01      	ldr	r3, [sp, #4]
   12f16:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   12f1a:	bf00      	nop
   12f1c:	b003      	add	sp, #12
   12f1e:	f85d fb04 	ldr.w	pc, [sp], #4
   12f22:	bf00      	nop
   12f24:	1fff95d4 	.word	0x1fff95d4
   12f28:	1fff95d0 	.word	0x1fff95d0

00012f2c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_77>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_77(void)
{
   12f2c:	b500      	push	{lr}
   12f2e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12f30:	f7ed fef4 	bl	d1c <Sys_GetCoreID>
   12f34:	4603      	mov	r3, r0
   12f36:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_77[u32CoreId]--;
   12f38:	4a0d      	ldr	r2, [pc, #52]	; (12f70 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_77+0x44>)
   12f3a:	9b01      	ldr	r3, [sp, #4]
   12f3c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12f40:	1e5a      	subs	r2, r3, #1
   12f42:	490b      	ldr	r1, [pc, #44]	; (12f70 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_77+0x44>)
   12f44:	9b01      	ldr	r3, [sp, #4]
   12f46:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_77[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_77[u32CoreId]))         /*if interrupts were enabled*/
   12f4a:	4a0a      	ldr	r2, [pc, #40]	; (12f74 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_77+0x48>)
   12f4c:	9b01      	ldr	r3, [sp, #4]
   12f4e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12f52:	f003 0301 	and.w	r3, r3, #1
   12f56:	2b00      	cmp	r3, #0
   12f58:	d106      	bne.n	12f68 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_77+0x3c>
   12f5a:	4a05      	ldr	r2, [pc, #20]	; (12f70 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_77+0x44>)
   12f5c:	9b01      	ldr	r3, [sp, #4]
   12f5e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12f62:	2b00      	cmp	r3, #0
   12f64:	d100      	bne.n	12f68 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_77+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   12f66:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12f68:	bf00      	nop
   12f6a:	b003      	add	sp, #12
   12f6c:	f85d fb04 	ldr.w	pc, [sp], #4
   12f70:	1fff95d4 	.word	0x1fff95d4
   12f74:	1fff95d0 	.word	0x1fff95d0

00012f78 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_78>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_78(void)
{
   12f78:	b500      	push	{lr}
   12f7a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12f7c:	f7ed fece 	bl	d1c <Sys_GetCoreID>
   12f80:	4603      	mov	r3, r0
   12f82:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_78[u32CoreId])
   12f84:	4a10      	ldr	r2, [pc, #64]	; (12fc8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_78+0x50>)
   12f86:	9b01      	ldr	r3, [sp, #4]
   12f88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12f8c:	2b00      	cmp	r3, #0
   12f8e:	d10d      	bne.n	12fac <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_78+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12f90:	f7ed fd02 	bl	998 <Adc_schm_read_msr>
   12f94:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   12f96:	9b00      	ldr	r3, [sp, #0]
   12f98:	f003 0301 	and.w	r3, r3, #1
   12f9c:	2b00      	cmp	r3, #0
   12f9e:	d100      	bne.n	12fa2 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_78+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12fa0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_78[u32CoreId] = msr;
   12fa2:	490a      	ldr	r1, [pc, #40]	; (12fcc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_78+0x54>)
   12fa4:	9b01      	ldr	r3, [sp, #4]
   12fa6:	9a00      	ldr	r2, [sp, #0]
   12fa8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_78[u32CoreId]++;
   12fac:	4a06      	ldr	r2, [pc, #24]	; (12fc8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_78+0x50>)
   12fae:	9b01      	ldr	r3, [sp, #4]
   12fb0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12fb4:	1c5a      	adds	r2, r3, #1
   12fb6:	4904      	ldr	r1, [pc, #16]	; (12fc8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_78+0x50>)
   12fb8:	9b01      	ldr	r3, [sp, #4]
   12fba:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   12fbe:	bf00      	nop
   12fc0:	b003      	add	sp, #12
   12fc2:	f85d fb04 	ldr.w	pc, [sp], #4
   12fc6:	bf00      	nop
   12fc8:	1fff95dc 	.word	0x1fff95dc
   12fcc:	1fff95d8 	.word	0x1fff95d8

00012fd0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_78>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_78(void)
{
   12fd0:	b500      	push	{lr}
   12fd2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12fd4:	f7ed fea2 	bl	d1c <Sys_GetCoreID>
   12fd8:	4603      	mov	r3, r0
   12fda:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_78[u32CoreId]--;
   12fdc:	4a0d      	ldr	r2, [pc, #52]	; (13014 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_78+0x44>)
   12fde:	9b01      	ldr	r3, [sp, #4]
   12fe0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12fe4:	1e5a      	subs	r2, r3, #1
   12fe6:	490b      	ldr	r1, [pc, #44]	; (13014 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_78+0x44>)
   12fe8:	9b01      	ldr	r3, [sp, #4]
   12fea:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_78[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_78[u32CoreId]))         /*if interrupts were enabled*/
   12fee:	4a0a      	ldr	r2, [pc, #40]	; (13018 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_78+0x48>)
   12ff0:	9b01      	ldr	r3, [sp, #4]
   12ff2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12ff6:	f003 0301 	and.w	r3, r3, #1
   12ffa:	2b00      	cmp	r3, #0
   12ffc:	d106      	bne.n	1300c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_78+0x3c>
   12ffe:	4a05      	ldr	r2, [pc, #20]	; (13014 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_78+0x44>)
   13000:	9b01      	ldr	r3, [sp, #4]
   13002:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13006:	2b00      	cmp	r3, #0
   13008:	d100      	bne.n	1300c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_78+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1300a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   1300c:	bf00      	nop
   1300e:	b003      	add	sp, #12
   13010:	f85d fb04 	ldr.w	pc, [sp], #4
   13014:	1fff95dc 	.word	0x1fff95dc
   13018:	1fff95d8 	.word	0x1fff95d8

0001301c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_79>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_79(void)
{
   1301c:	b500      	push	{lr}
   1301e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13020:	f7ed fe7c 	bl	d1c <Sys_GetCoreID>
   13024:	4603      	mov	r3, r0
   13026:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_79[u32CoreId])
   13028:	4a10      	ldr	r2, [pc, #64]	; (1306c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_79+0x50>)
   1302a:	9b01      	ldr	r3, [sp, #4]
   1302c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13030:	2b00      	cmp	r3, #0
   13032:	d10d      	bne.n	13050 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_79+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13034:	f7ed fcb0 	bl	998 <Adc_schm_read_msr>
   13038:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1303a:	9b00      	ldr	r3, [sp, #0]
   1303c:	f003 0301 	and.w	r3, r3, #1
   13040:	2b00      	cmp	r3, #0
   13042:	d100      	bne.n	13046 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_79+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13044:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_79[u32CoreId] = msr;
   13046:	490a      	ldr	r1, [pc, #40]	; (13070 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_79+0x54>)
   13048:	9b01      	ldr	r3, [sp, #4]
   1304a:	9a00      	ldr	r2, [sp, #0]
   1304c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_79[u32CoreId]++;
   13050:	4a06      	ldr	r2, [pc, #24]	; (1306c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_79+0x50>)
   13052:	9b01      	ldr	r3, [sp, #4]
   13054:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13058:	1c5a      	adds	r2, r3, #1
   1305a:	4904      	ldr	r1, [pc, #16]	; (1306c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_79+0x50>)
   1305c:	9b01      	ldr	r3, [sp, #4]
   1305e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   13062:	bf00      	nop
   13064:	b003      	add	sp, #12
   13066:	f85d fb04 	ldr.w	pc, [sp], #4
   1306a:	bf00      	nop
   1306c:	1fff95e4 	.word	0x1fff95e4
   13070:	1fff95e0 	.word	0x1fff95e0

00013074 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_79>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_79(void)
{
   13074:	b500      	push	{lr}
   13076:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13078:	f7ed fe50 	bl	d1c <Sys_GetCoreID>
   1307c:	4603      	mov	r3, r0
   1307e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_79[u32CoreId]--;
   13080:	4a0d      	ldr	r2, [pc, #52]	; (130b8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_79+0x44>)
   13082:	9b01      	ldr	r3, [sp, #4]
   13084:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13088:	1e5a      	subs	r2, r3, #1
   1308a:	490b      	ldr	r1, [pc, #44]	; (130b8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_79+0x44>)
   1308c:	9b01      	ldr	r3, [sp, #4]
   1308e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_79[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_79[u32CoreId]))         /*if interrupts were enabled*/
   13092:	4a0a      	ldr	r2, [pc, #40]	; (130bc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_79+0x48>)
   13094:	9b01      	ldr	r3, [sp, #4]
   13096:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1309a:	f003 0301 	and.w	r3, r3, #1
   1309e:	2b00      	cmp	r3, #0
   130a0:	d106      	bne.n	130b0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_79+0x3c>
   130a2:	4a05      	ldr	r2, [pc, #20]	; (130b8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_79+0x44>)
   130a4:	9b01      	ldr	r3, [sp, #4]
   130a6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   130aa:	2b00      	cmp	r3, #0
   130ac:	d100      	bne.n	130b0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_79+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   130ae:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   130b0:	bf00      	nop
   130b2:	b003      	add	sp, #12
   130b4:	f85d fb04 	ldr.w	pc, [sp], #4
   130b8:	1fff95e4 	.word	0x1fff95e4
   130bc:	1fff95e0 	.word	0x1fff95e0

000130c0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_80>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_80(void)
{
   130c0:	b500      	push	{lr}
   130c2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   130c4:	f7ed fe2a 	bl	d1c <Sys_GetCoreID>
   130c8:	4603      	mov	r3, r0
   130ca:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_80[u32CoreId])
   130cc:	4a10      	ldr	r2, [pc, #64]	; (13110 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_80+0x50>)
   130ce:	9b01      	ldr	r3, [sp, #4]
   130d0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   130d4:	2b00      	cmp	r3, #0
   130d6:	d10d      	bne.n	130f4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_80+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   130d8:	f7ed fc5e 	bl	998 <Adc_schm_read_msr>
   130dc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   130de:	9b00      	ldr	r3, [sp, #0]
   130e0:	f003 0301 	and.w	r3, r3, #1
   130e4:	2b00      	cmp	r3, #0
   130e6:	d100      	bne.n	130ea <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_80+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   130e8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_80[u32CoreId] = msr;
   130ea:	490a      	ldr	r1, [pc, #40]	; (13114 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_80+0x54>)
   130ec:	9b01      	ldr	r3, [sp, #4]
   130ee:	9a00      	ldr	r2, [sp, #0]
   130f0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_80[u32CoreId]++;
   130f4:	4a06      	ldr	r2, [pc, #24]	; (13110 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_80+0x50>)
   130f6:	9b01      	ldr	r3, [sp, #4]
   130f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   130fc:	1c5a      	adds	r2, r3, #1
   130fe:	4904      	ldr	r1, [pc, #16]	; (13110 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_80+0x50>)
   13100:	9b01      	ldr	r3, [sp, #4]
   13102:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   13106:	bf00      	nop
   13108:	b003      	add	sp, #12
   1310a:	f85d fb04 	ldr.w	pc, [sp], #4
   1310e:	bf00      	nop
   13110:	1fff95ec 	.word	0x1fff95ec
   13114:	1fff95e8 	.word	0x1fff95e8

00013118 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_80>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_80(void)
{
   13118:	b500      	push	{lr}
   1311a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1311c:	f7ed fdfe 	bl	d1c <Sys_GetCoreID>
   13120:	4603      	mov	r3, r0
   13122:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_80[u32CoreId]--;
   13124:	4a0d      	ldr	r2, [pc, #52]	; (1315c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_80+0x44>)
   13126:	9b01      	ldr	r3, [sp, #4]
   13128:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1312c:	1e5a      	subs	r2, r3, #1
   1312e:	490b      	ldr	r1, [pc, #44]	; (1315c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_80+0x44>)
   13130:	9b01      	ldr	r3, [sp, #4]
   13132:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_80[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_80[u32CoreId]))         /*if interrupts were enabled*/
   13136:	4a0a      	ldr	r2, [pc, #40]	; (13160 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_80+0x48>)
   13138:	9b01      	ldr	r3, [sp, #4]
   1313a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1313e:	f003 0301 	and.w	r3, r3, #1
   13142:	2b00      	cmp	r3, #0
   13144:	d106      	bne.n	13154 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_80+0x3c>
   13146:	4a05      	ldr	r2, [pc, #20]	; (1315c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_80+0x44>)
   13148:	9b01      	ldr	r3, [sp, #4]
   1314a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1314e:	2b00      	cmp	r3, #0
   13150:	d100      	bne.n	13154 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_80+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   13152:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13154:	bf00      	nop
   13156:	b003      	add	sp, #12
   13158:	f85d fb04 	ldr.w	pc, [sp], #4
   1315c:	1fff95ec 	.word	0x1fff95ec
   13160:	1fff95e8 	.word	0x1fff95e8

00013164 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_81>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_81(void)
{
   13164:	b500      	push	{lr}
   13166:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13168:	f7ed fdd8 	bl	d1c <Sys_GetCoreID>
   1316c:	4603      	mov	r3, r0
   1316e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_81[u32CoreId])
   13170:	4a10      	ldr	r2, [pc, #64]	; (131b4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_81+0x50>)
   13172:	9b01      	ldr	r3, [sp, #4]
   13174:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13178:	2b00      	cmp	r3, #0
   1317a:	d10d      	bne.n	13198 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_81+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   1317c:	f7ed fc0c 	bl	998 <Adc_schm_read_msr>
   13180:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   13182:	9b00      	ldr	r3, [sp, #0]
   13184:	f003 0301 	and.w	r3, r3, #1
   13188:	2b00      	cmp	r3, #0
   1318a:	d100      	bne.n	1318e <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_81+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   1318c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_81[u32CoreId] = msr;
   1318e:	490a      	ldr	r1, [pc, #40]	; (131b8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_81+0x54>)
   13190:	9b01      	ldr	r3, [sp, #4]
   13192:	9a00      	ldr	r2, [sp, #0]
   13194:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_81[u32CoreId]++;
   13198:	4a06      	ldr	r2, [pc, #24]	; (131b4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_81+0x50>)
   1319a:	9b01      	ldr	r3, [sp, #4]
   1319c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   131a0:	1c5a      	adds	r2, r3, #1
   131a2:	4904      	ldr	r1, [pc, #16]	; (131b4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_81+0x50>)
   131a4:	9b01      	ldr	r3, [sp, #4]
   131a6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   131aa:	bf00      	nop
   131ac:	b003      	add	sp, #12
   131ae:	f85d fb04 	ldr.w	pc, [sp], #4
   131b2:	bf00      	nop
   131b4:	1fff95f4 	.word	0x1fff95f4
   131b8:	1fff95f0 	.word	0x1fff95f0

000131bc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_81>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_81(void)
{
   131bc:	b500      	push	{lr}
   131be:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   131c0:	f7ed fdac 	bl	d1c <Sys_GetCoreID>
   131c4:	4603      	mov	r3, r0
   131c6:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_81[u32CoreId]--;
   131c8:	4a0d      	ldr	r2, [pc, #52]	; (13200 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_81+0x44>)
   131ca:	9b01      	ldr	r3, [sp, #4]
   131cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   131d0:	1e5a      	subs	r2, r3, #1
   131d2:	490b      	ldr	r1, [pc, #44]	; (13200 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_81+0x44>)
   131d4:	9b01      	ldr	r3, [sp, #4]
   131d6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_81[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_81[u32CoreId]))         /*if interrupts were enabled*/
   131da:	4a0a      	ldr	r2, [pc, #40]	; (13204 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_81+0x48>)
   131dc:	9b01      	ldr	r3, [sp, #4]
   131de:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   131e2:	f003 0301 	and.w	r3, r3, #1
   131e6:	2b00      	cmp	r3, #0
   131e8:	d106      	bne.n	131f8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_81+0x3c>
   131ea:	4a05      	ldr	r2, [pc, #20]	; (13200 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_81+0x44>)
   131ec:	9b01      	ldr	r3, [sp, #4]
   131ee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   131f2:	2b00      	cmp	r3, #0
   131f4:	d100      	bne.n	131f8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_81+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   131f6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   131f8:	bf00      	nop
   131fa:	b003      	add	sp, #12
   131fc:	f85d fb04 	ldr.w	pc, [sp], #4
   13200:	1fff95f4 	.word	0x1fff95f4
   13204:	1fff95f0 	.word	0x1fff95f0

00013208 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_82>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_82(void)
{
   13208:	b500      	push	{lr}
   1320a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1320c:	f7ed fd86 	bl	d1c <Sys_GetCoreID>
   13210:	4603      	mov	r3, r0
   13212:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_82[u32CoreId])
   13214:	4a10      	ldr	r2, [pc, #64]	; (13258 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_82+0x50>)
   13216:	9b01      	ldr	r3, [sp, #4]
   13218:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1321c:	2b00      	cmp	r3, #0
   1321e:	d10d      	bne.n	1323c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_82+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13220:	f7ed fbba 	bl	998 <Adc_schm_read_msr>
   13224:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   13226:	9b00      	ldr	r3, [sp, #0]
   13228:	f003 0301 	and.w	r3, r3, #1
   1322c:	2b00      	cmp	r3, #0
   1322e:	d100      	bne.n	13232 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_82+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13230:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_82[u32CoreId] = msr;
   13232:	490a      	ldr	r1, [pc, #40]	; (1325c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_82+0x54>)
   13234:	9b01      	ldr	r3, [sp, #4]
   13236:	9a00      	ldr	r2, [sp, #0]
   13238:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_82[u32CoreId]++;
   1323c:	4a06      	ldr	r2, [pc, #24]	; (13258 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_82+0x50>)
   1323e:	9b01      	ldr	r3, [sp, #4]
   13240:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13244:	1c5a      	adds	r2, r3, #1
   13246:	4904      	ldr	r1, [pc, #16]	; (13258 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_82+0x50>)
   13248:	9b01      	ldr	r3, [sp, #4]
   1324a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1324e:	bf00      	nop
   13250:	b003      	add	sp, #12
   13252:	f85d fb04 	ldr.w	pc, [sp], #4
   13256:	bf00      	nop
   13258:	1fff95fc 	.word	0x1fff95fc
   1325c:	1fff95f8 	.word	0x1fff95f8

00013260 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_82>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_82(void)
{
   13260:	b500      	push	{lr}
   13262:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13264:	f7ed fd5a 	bl	d1c <Sys_GetCoreID>
   13268:	4603      	mov	r3, r0
   1326a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_82[u32CoreId]--;
   1326c:	4a0d      	ldr	r2, [pc, #52]	; (132a4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_82+0x44>)
   1326e:	9b01      	ldr	r3, [sp, #4]
   13270:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13274:	1e5a      	subs	r2, r3, #1
   13276:	490b      	ldr	r1, [pc, #44]	; (132a4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_82+0x44>)
   13278:	9b01      	ldr	r3, [sp, #4]
   1327a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_82[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_82[u32CoreId]))         /*if interrupts were enabled*/
   1327e:	4a0a      	ldr	r2, [pc, #40]	; (132a8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_82+0x48>)
   13280:	9b01      	ldr	r3, [sp, #4]
   13282:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13286:	f003 0301 	and.w	r3, r3, #1
   1328a:	2b00      	cmp	r3, #0
   1328c:	d106      	bne.n	1329c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_82+0x3c>
   1328e:	4a05      	ldr	r2, [pc, #20]	; (132a4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_82+0x44>)
   13290:	9b01      	ldr	r3, [sp, #4]
   13292:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13296:	2b00      	cmp	r3, #0
   13298:	d100      	bne.n	1329c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_82+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1329a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   1329c:	bf00      	nop
   1329e:	b003      	add	sp, #12
   132a0:	f85d fb04 	ldr.w	pc, [sp], #4
   132a4:	1fff95fc 	.word	0x1fff95fc
   132a8:	1fff95f8 	.word	0x1fff95f8

000132ac <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_83>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_83(void)
{
   132ac:	b500      	push	{lr}
   132ae:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   132b0:	f7ed fd34 	bl	d1c <Sys_GetCoreID>
   132b4:	4603      	mov	r3, r0
   132b6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_83[u32CoreId])
   132b8:	4a10      	ldr	r2, [pc, #64]	; (132fc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_83+0x50>)
   132ba:	9b01      	ldr	r3, [sp, #4]
   132bc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   132c0:	2b00      	cmp	r3, #0
   132c2:	d10d      	bne.n	132e0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_83+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   132c4:	f7ed fb68 	bl	998 <Adc_schm_read_msr>
   132c8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   132ca:	9b00      	ldr	r3, [sp, #0]
   132cc:	f003 0301 	and.w	r3, r3, #1
   132d0:	2b00      	cmp	r3, #0
   132d2:	d100      	bne.n	132d6 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_83+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   132d4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_83[u32CoreId] = msr;
   132d6:	490a      	ldr	r1, [pc, #40]	; (13300 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_83+0x54>)
   132d8:	9b01      	ldr	r3, [sp, #4]
   132da:	9a00      	ldr	r2, [sp, #0]
   132dc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_83[u32CoreId]++;
   132e0:	4a06      	ldr	r2, [pc, #24]	; (132fc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_83+0x50>)
   132e2:	9b01      	ldr	r3, [sp, #4]
   132e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   132e8:	1c5a      	adds	r2, r3, #1
   132ea:	4904      	ldr	r1, [pc, #16]	; (132fc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_83+0x50>)
   132ec:	9b01      	ldr	r3, [sp, #4]
   132ee:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   132f2:	bf00      	nop
   132f4:	b003      	add	sp, #12
   132f6:	f85d fb04 	ldr.w	pc, [sp], #4
   132fa:	bf00      	nop
   132fc:	1fff9604 	.word	0x1fff9604
   13300:	1fff9600 	.word	0x1fff9600

00013304 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_83>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_83(void)
{
   13304:	b500      	push	{lr}
   13306:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13308:	f7ed fd08 	bl	d1c <Sys_GetCoreID>
   1330c:	4603      	mov	r3, r0
   1330e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_83[u32CoreId]--;
   13310:	4a0d      	ldr	r2, [pc, #52]	; (13348 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_83+0x44>)
   13312:	9b01      	ldr	r3, [sp, #4]
   13314:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13318:	1e5a      	subs	r2, r3, #1
   1331a:	490b      	ldr	r1, [pc, #44]	; (13348 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_83+0x44>)
   1331c:	9b01      	ldr	r3, [sp, #4]
   1331e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_83[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_83[u32CoreId]))         /*if interrupts were enabled*/
   13322:	4a0a      	ldr	r2, [pc, #40]	; (1334c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_83+0x48>)
   13324:	9b01      	ldr	r3, [sp, #4]
   13326:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1332a:	f003 0301 	and.w	r3, r3, #1
   1332e:	2b00      	cmp	r3, #0
   13330:	d106      	bne.n	13340 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_83+0x3c>
   13332:	4a05      	ldr	r2, [pc, #20]	; (13348 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_83+0x44>)
   13334:	9b01      	ldr	r3, [sp, #4]
   13336:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1333a:	2b00      	cmp	r3, #0
   1333c:	d100      	bne.n	13340 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_83+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1333e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13340:	bf00      	nop
   13342:	b003      	add	sp, #12
   13344:	f85d fb04 	ldr.w	pc, [sp], #4
   13348:	1fff9604 	.word	0x1fff9604
   1334c:	1fff9600 	.word	0x1fff9600

00013350 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_84>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_84(void)
{
   13350:	b500      	push	{lr}
   13352:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13354:	f7ed fce2 	bl	d1c <Sys_GetCoreID>
   13358:	4603      	mov	r3, r0
   1335a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_84[u32CoreId])
   1335c:	4a10      	ldr	r2, [pc, #64]	; (133a0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_84+0x50>)
   1335e:	9b01      	ldr	r3, [sp, #4]
   13360:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13364:	2b00      	cmp	r3, #0
   13366:	d10d      	bne.n	13384 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_84+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13368:	f7ed fb16 	bl	998 <Adc_schm_read_msr>
   1336c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1336e:	9b00      	ldr	r3, [sp, #0]
   13370:	f003 0301 	and.w	r3, r3, #1
   13374:	2b00      	cmp	r3, #0
   13376:	d100      	bne.n	1337a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_84+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13378:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_84[u32CoreId] = msr;
   1337a:	490a      	ldr	r1, [pc, #40]	; (133a4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_84+0x54>)
   1337c:	9b01      	ldr	r3, [sp, #4]
   1337e:	9a00      	ldr	r2, [sp, #0]
   13380:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_84[u32CoreId]++;
   13384:	4a06      	ldr	r2, [pc, #24]	; (133a0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_84+0x50>)
   13386:	9b01      	ldr	r3, [sp, #4]
   13388:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1338c:	1c5a      	adds	r2, r3, #1
   1338e:	4904      	ldr	r1, [pc, #16]	; (133a0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_84+0x50>)
   13390:	9b01      	ldr	r3, [sp, #4]
   13392:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   13396:	bf00      	nop
   13398:	b003      	add	sp, #12
   1339a:	f85d fb04 	ldr.w	pc, [sp], #4
   1339e:	bf00      	nop
   133a0:	1fff960c 	.word	0x1fff960c
   133a4:	1fff9608 	.word	0x1fff9608

000133a8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_84>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_84(void)
{
   133a8:	b500      	push	{lr}
   133aa:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   133ac:	f7ed fcb6 	bl	d1c <Sys_GetCoreID>
   133b0:	4603      	mov	r3, r0
   133b2:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_84[u32CoreId]--;
   133b4:	4a0d      	ldr	r2, [pc, #52]	; (133ec <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_84+0x44>)
   133b6:	9b01      	ldr	r3, [sp, #4]
   133b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   133bc:	1e5a      	subs	r2, r3, #1
   133be:	490b      	ldr	r1, [pc, #44]	; (133ec <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_84+0x44>)
   133c0:	9b01      	ldr	r3, [sp, #4]
   133c2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_84[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_84[u32CoreId]))         /*if interrupts were enabled*/
   133c6:	4a0a      	ldr	r2, [pc, #40]	; (133f0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_84+0x48>)
   133c8:	9b01      	ldr	r3, [sp, #4]
   133ca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   133ce:	f003 0301 	and.w	r3, r3, #1
   133d2:	2b00      	cmp	r3, #0
   133d4:	d106      	bne.n	133e4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_84+0x3c>
   133d6:	4a05      	ldr	r2, [pc, #20]	; (133ec <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_84+0x44>)
   133d8:	9b01      	ldr	r3, [sp, #4]
   133da:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   133de:	2b00      	cmp	r3, #0
   133e0:	d100      	bne.n	133e4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_84+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   133e2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   133e4:	bf00      	nop
   133e6:	b003      	add	sp, #12
   133e8:	f85d fb04 	ldr.w	pc, [sp], #4
   133ec:	1fff960c 	.word	0x1fff960c
   133f0:	1fff9608 	.word	0x1fff9608

000133f4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_85>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_85(void)
{
   133f4:	b500      	push	{lr}
   133f6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   133f8:	f7ed fc90 	bl	d1c <Sys_GetCoreID>
   133fc:	4603      	mov	r3, r0
   133fe:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_85[u32CoreId])
   13400:	4a10      	ldr	r2, [pc, #64]	; (13444 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_85+0x50>)
   13402:	9b01      	ldr	r3, [sp, #4]
   13404:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13408:	2b00      	cmp	r3, #0
   1340a:	d10d      	bne.n	13428 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_85+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   1340c:	f7ed fac4 	bl	998 <Adc_schm_read_msr>
   13410:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   13412:	9b00      	ldr	r3, [sp, #0]
   13414:	f003 0301 	and.w	r3, r3, #1
   13418:	2b00      	cmp	r3, #0
   1341a:	d100      	bne.n	1341e <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_85+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   1341c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_85[u32CoreId] = msr;
   1341e:	490a      	ldr	r1, [pc, #40]	; (13448 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_85+0x54>)
   13420:	9b01      	ldr	r3, [sp, #4]
   13422:	9a00      	ldr	r2, [sp, #0]
   13424:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_85[u32CoreId]++;
   13428:	4a06      	ldr	r2, [pc, #24]	; (13444 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_85+0x50>)
   1342a:	9b01      	ldr	r3, [sp, #4]
   1342c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13430:	1c5a      	adds	r2, r3, #1
   13432:	4904      	ldr	r1, [pc, #16]	; (13444 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_85+0x50>)
   13434:	9b01      	ldr	r3, [sp, #4]
   13436:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1343a:	bf00      	nop
   1343c:	b003      	add	sp, #12
   1343e:	f85d fb04 	ldr.w	pc, [sp], #4
   13442:	bf00      	nop
   13444:	1fff9614 	.word	0x1fff9614
   13448:	1fff9610 	.word	0x1fff9610

0001344c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_85>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_85(void)
{
   1344c:	b500      	push	{lr}
   1344e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13450:	f7ed fc64 	bl	d1c <Sys_GetCoreID>
   13454:	4603      	mov	r3, r0
   13456:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_85[u32CoreId]--;
   13458:	4a0d      	ldr	r2, [pc, #52]	; (13490 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_85+0x44>)
   1345a:	9b01      	ldr	r3, [sp, #4]
   1345c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13460:	1e5a      	subs	r2, r3, #1
   13462:	490b      	ldr	r1, [pc, #44]	; (13490 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_85+0x44>)
   13464:	9b01      	ldr	r3, [sp, #4]
   13466:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_85[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_85[u32CoreId]))         /*if interrupts were enabled*/
   1346a:	4a0a      	ldr	r2, [pc, #40]	; (13494 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_85+0x48>)
   1346c:	9b01      	ldr	r3, [sp, #4]
   1346e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13472:	f003 0301 	and.w	r3, r3, #1
   13476:	2b00      	cmp	r3, #0
   13478:	d106      	bne.n	13488 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_85+0x3c>
   1347a:	4a05      	ldr	r2, [pc, #20]	; (13490 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_85+0x44>)
   1347c:	9b01      	ldr	r3, [sp, #4]
   1347e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13482:	2b00      	cmp	r3, #0
   13484:	d100      	bne.n	13488 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_85+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   13486:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13488:	bf00      	nop
   1348a:	b003      	add	sp, #12
   1348c:	f85d fb04 	ldr.w	pc, [sp], #4
   13490:	1fff9614 	.word	0x1fff9614
   13494:	1fff9610 	.word	0x1fff9610

00013498 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_86>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_86(void)
{
   13498:	b500      	push	{lr}
   1349a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1349c:	f7ed fc3e 	bl	d1c <Sys_GetCoreID>
   134a0:	4603      	mov	r3, r0
   134a2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_86[u32CoreId])
   134a4:	4a10      	ldr	r2, [pc, #64]	; (134e8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_86+0x50>)
   134a6:	9b01      	ldr	r3, [sp, #4]
   134a8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   134ac:	2b00      	cmp	r3, #0
   134ae:	d10d      	bne.n	134cc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_86+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   134b0:	f7ed fa72 	bl	998 <Adc_schm_read_msr>
   134b4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   134b6:	9b00      	ldr	r3, [sp, #0]
   134b8:	f003 0301 	and.w	r3, r3, #1
   134bc:	2b00      	cmp	r3, #0
   134be:	d100      	bne.n	134c2 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_86+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   134c0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_86[u32CoreId] = msr;
   134c2:	490a      	ldr	r1, [pc, #40]	; (134ec <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_86+0x54>)
   134c4:	9b01      	ldr	r3, [sp, #4]
   134c6:	9a00      	ldr	r2, [sp, #0]
   134c8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_86[u32CoreId]++;
   134cc:	4a06      	ldr	r2, [pc, #24]	; (134e8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_86+0x50>)
   134ce:	9b01      	ldr	r3, [sp, #4]
   134d0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   134d4:	1c5a      	adds	r2, r3, #1
   134d6:	4904      	ldr	r1, [pc, #16]	; (134e8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_86+0x50>)
   134d8:	9b01      	ldr	r3, [sp, #4]
   134da:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   134de:	bf00      	nop
   134e0:	b003      	add	sp, #12
   134e2:	f85d fb04 	ldr.w	pc, [sp], #4
   134e6:	bf00      	nop
   134e8:	1fff961c 	.word	0x1fff961c
   134ec:	1fff9618 	.word	0x1fff9618

000134f0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_86>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_86(void)
{
   134f0:	b500      	push	{lr}
   134f2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   134f4:	f7ed fc12 	bl	d1c <Sys_GetCoreID>
   134f8:	4603      	mov	r3, r0
   134fa:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_86[u32CoreId]--;
   134fc:	4a0d      	ldr	r2, [pc, #52]	; (13534 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_86+0x44>)
   134fe:	9b01      	ldr	r3, [sp, #4]
   13500:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13504:	1e5a      	subs	r2, r3, #1
   13506:	490b      	ldr	r1, [pc, #44]	; (13534 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_86+0x44>)
   13508:	9b01      	ldr	r3, [sp, #4]
   1350a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_86[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_86[u32CoreId]))         /*if interrupts were enabled*/
   1350e:	4a0a      	ldr	r2, [pc, #40]	; (13538 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_86+0x48>)
   13510:	9b01      	ldr	r3, [sp, #4]
   13512:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13516:	f003 0301 	and.w	r3, r3, #1
   1351a:	2b00      	cmp	r3, #0
   1351c:	d106      	bne.n	1352c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_86+0x3c>
   1351e:	4a05      	ldr	r2, [pc, #20]	; (13534 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_86+0x44>)
   13520:	9b01      	ldr	r3, [sp, #4]
   13522:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13526:	2b00      	cmp	r3, #0
   13528:	d100      	bne.n	1352c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_86+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1352a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   1352c:	bf00      	nop
   1352e:	b003      	add	sp, #12
   13530:	f85d fb04 	ldr.w	pc, [sp], #4
   13534:	1fff961c 	.word	0x1fff961c
   13538:	1fff9618 	.word	0x1fff9618

0001353c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_87>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_87(void)
{
   1353c:	b500      	push	{lr}
   1353e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13540:	f7ed fbec 	bl	d1c <Sys_GetCoreID>
   13544:	4603      	mov	r3, r0
   13546:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_87[u32CoreId])
   13548:	4a10      	ldr	r2, [pc, #64]	; (1358c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_87+0x50>)
   1354a:	9b01      	ldr	r3, [sp, #4]
   1354c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13550:	2b00      	cmp	r3, #0
   13552:	d10d      	bne.n	13570 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_87+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13554:	f7ed fa20 	bl	998 <Adc_schm_read_msr>
   13558:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1355a:	9b00      	ldr	r3, [sp, #0]
   1355c:	f003 0301 	and.w	r3, r3, #1
   13560:	2b00      	cmp	r3, #0
   13562:	d100      	bne.n	13566 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_87+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13564:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_87[u32CoreId] = msr;
   13566:	490a      	ldr	r1, [pc, #40]	; (13590 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_87+0x54>)
   13568:	9b01      	ldr	r3, [sp, #4]
   1356a:	9a00      	ldr	r2, [sp, #0]
   1356c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_87[u32CoreId]++;
   13570:	4a06      	ldr	r2, [pc, #24]	; (1358c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_87+0x50>)
   13572:	9b01      	ldr	r3, [sp, #4]
   13574:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13578:	1c5a      	adds	r2, r3, #1
   1357a:	4904      	ldr	r1, [pc, #16]	; (1358c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_87+0x50>)
   1357c:	9b01      	ldr	r3, [sp, #4]
   1357e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   13582:	bf00      	nop
   13584:	b003      	add	sp, #12
   13586:	f85d fb04 	ldr.w	pc, [sp], #4
   1358a:	bf00      	nop
   1358c:	1fff9624 	.word	0x1fff9624
   13590:	1fff9620 	.word	0x1fff9620

00013594 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_87>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_87(void)
{
   13594:	b500      	push	{lr}
   13596:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13598:	f7ed fbc0 	bl	d1c <Sys_GetCoreID>
   1359c:	4603      	mov	r3, r0
   1359e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_87[u32CoreId]--;
   135a0:	4a0d      	ldr	r2, [pc, #52]	; (135d8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_87+0x44>)
   135a2:	9b01      	ldr	r3, [sp, #4]
   135a4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   135a8:	1e5a      	subs	r2, r3, #1
   135aa:	490b      	ldr	r1, [pc, #44]	; (135d8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_87+0x44>)
   135ac:	9b01      	ldr	r3, [sp, #4]
   135ae:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_87[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_87[u32CoreId]))         /*if interrupts were enabled*/
   135b2:	4a0a      	ldr	r2, [pc, #40]	; (135dc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_87+0x48>)
   135b4:	9b01      	ldr	r3, [sp, #4]
   135b6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   135ba:	f003 0301 	and.w	r3, r3, #1
   135be:	2b00      	cmp	r3, #0
   135c0:	d106      	bne.n	135d0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_87+0x3c>
   135c2:	4a05      	ldr	r2, [pc, #20]	; (135d8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_87+0x44>)
   135c4:	9b01      	ldr	r3, [sp, #4]
   135c6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   135ca:	2b00      	cmp	r3, #0
   135cc:	d100      	bne.n	135d0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_87+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   135ce:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   135d0:	bf00      	nop
   135d2:	b003      	add	sp, #12
   135d4:	f85d fb04 	ldr.w	pc, [sp], #4
   135d8:	1fff9624 	.word	0x1fff9624
   135dc:	1fff9620 	.word	0x1fff9620

000135e0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_88>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_88(void)
{
   135e0:	b500      	push	{lr}
   135e2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   135e4:	f7ed fb9a 	bl	d1c <Sys_GetCoreID>
   135e8:	4603      	mov	r3, r0
   135ea:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_88[u32CoreId])
   135ec:	4a10      	ldr	r2, [pc, #64]	; (13630 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_88+0x50>)
   135ee:	9b01      	ldr	r3, [sp, #4]
   135f0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   135f4:	2b00      	cmp	r3, #0
   135f6:	d10d      	bne.n	13614 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_88+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   135f8:	f7ed f9ce 	bl	998 <Adc_schm_read_msr>
   135fc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   135fe:	9b00      	ldr	r3, [sp, #0]
   13600:	f003 0301 	and.w	r3, r3, #1
   13604:	2b00      	cmp	r3, #0
   13606:	d100      	bne.n	1360a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_88+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13608:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_88[u32CoreId] = msr;
   1360a:	490a      	ldr	r1, [pc, #40]	; (13634 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_88+0x54>)
   1360c:	9b01      	ldr	r3, [sp, #4]
   1360e:	9a00      	ldr	r2, [sp, #0]
   13610:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_88[u32CoreId]++;
   13614:	4a06      	ldr	r2, [pc, #24]	; (13630 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_88+0x50>)
   13616:	9b01      	ldr	r3, [sp, #4]
   13618:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1361c:	1c5a      	adds	r2, r3, #1
   1361e:	4904      	ldr	r1, [pc, #16]	; (13630 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_88+0x50>)
   13620:	9b01      	ldr	r3, [sp, #4]
   13622:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   13626:	bf00      	nop
   13628:	b003      	add	sp, #12
   1362a:	f85d fb04 	ldr.w	pc, [sp], #4
   1362e:	bf00      	nop
   13630:	1fff962c 	.word	0x1fff962c
   13634:	1fff9628 	.word	0x1fff9628

00013638 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_88>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_88(void)
{
   13638:	b500      	push	{lr}
   1363a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1363c:	f7ed fb6e 	bl	d1c <Sys_GetCoreID>
   13640:	4603      	mov	r3, r0
   13642:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_88[u32CoreId]--;
   13644:	4a0d      	ldr	r2, [pc, #52]	; (1367c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_88+0x44>)
   13646:	9b01      	ldr	r3, [sp, #4]
   13648:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1364c:	1e5a      	subs	r2, r3, #1
   1364e:	490b      	ldr	r1, [pc, #44]	; (1367c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_88+0x44>)
   13650:	9b01      	ldr	r3, [sp, #4]
   13652:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_88[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_88[u32CoreId]))         /*if interrupts were enabled*/
   13656:	4a0a      	ldr	r2, [pc, #40]	; (13680 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_88+0x48>)
   13658:	9b01      	ldr	r3, [sp, #4]
   1365a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1365e:	f003 0301 	and.w	r3, r3, #1
   13662:	2b00      	cmp	r3, #0
   13664:	d106      	bne.n	13674 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_88+0x3c>
   13666:	4a05      	ldr	r2, [pc, #20]	; (1367c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_88+0x44>)
   13668:	9b01      	ldr	r3, [sp, #4]
   1366a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1366e:	2b00      	cmp	r3, #0
   13670:	d100      	bne.n	13674 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_88+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   13672:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13674:	bf00      	nop
   13676:	b003      	add	sp, #12
   13678:	f85d fb04 	ldr.w	pc, [sp], #4
   1367c:	1fff962c 	.word	0x1fff962c
   13680:	1fff9628 	.word	0x1fff9628

00013684 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_89>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_89(void)
{
   13684:	b500      	push	{lr}
   13686:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13688:	f7ed fb48 	bl	d1c <Sys_GetCoreID>
   1368c:	4603      	mov	r3, r0
   1368e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_89[u32CoreId])
   13690:	4a10      	ldr	r2, [pc, #64]	; (136d4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_89+0x50>)
   13692:	9b01      	ldr	r3, [sp, #4]
   13694:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13698:	2b00      	cmp	r3, #0
   1369a:	d10d      	bne.n	136b8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_89+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   1369c:	f7ed f97c 	bl	998 <Adc_schm_read_msr>
   136a0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   136a2:	9b00      	ldr	r3, [sp, #0]
   136a4:	f003 0301 	and.w	r3, r3, #1
   136a8:	2b00      	cmp	r3, #0
   136aa:	d100      	bne.n	136ae <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_89+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   136ac:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_89[u32CoreId] = msr;
   136ae:	490a      	ldr	r1, [pc, #40]	; (136d8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_89+0x54>)
   136b0:	9b01      	ldr	r3, [sp, #4]
   136b2:	9a00      	ldr	r2, [sp, #0]
   136b4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_89[u32CoreId]++;
   136b8:	4a06      	ldr	r2, [pc, #24]	; (136d4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_89+0x50>)
   136ba:	9b01      	ldr	r3, [sp, #4]
   136bc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   136c0:	1c5a      	adds	r2, r3, #1
   136c2:	4904      	ldr	r1, [pc, #16]	; (136d4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_89+0x50>)
   136c4:	9b01      	ldr	r3, [sp, #4]
   136c6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   136ca:	bf00      	nop
   136cc:	b003      	add	sp, #12
   136ce:	f85d fb04 	ldr.w	pc, [sp], #4
   136d2:	bf00      	nop
   136d4:	1fff9634 	.word	0x1fff9634
   136d8:	1fff9630 	.word	0x1fff9630

000136dc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_89>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_89(void)
{
   136dc:	b500      	push	{lr}
   136de:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   136e0:	f7ed fb1c 	bl	d1c <Sys_GetCoreID>
   136e4:	4603      	mov	r3, r0
   136e6:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_89[u32CoreId]--;
   136e8:	4a0d      	ldr	r2, [pc, #52]	; (13720 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_89+0x44>)
   136ea:	9b01      	ldr	r3, [sp, #4]
   136ec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   136f0:	1e5a      	subs	r2, r3, #1
   136f2:	490b      	ldr	r1, [pc, #44]	; (13720 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_89+0x44>)
   136f4:	9b01      	ldr	r3, [sp, #4]
   136f6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_89[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_89[u32CoreId]))         /*if interrupts were enabled*/
   136fa:	4a0a      	ldr	r2, [pc, #40]	; (13724 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_89+0x48>)
   136fc:	9b01      	ldr	r3, [sp, #4]
   136fe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13702:	f003 0301 	and.w	r3, r3, #1
   13706:	2b00      	cmp	r3, #0
   13708:	d106      	bne.n	13718 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_89+0x3c>
   1370a:	4a05      	ldr	r2, [pc, #20]	; (13720 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_89+0x44>)
   1370c:	9b01      	ldr	r3, [sp, #4]
   1370e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13712:	2b00      	cmp	r3, #0
   13714:	d100      	bne.n	13718 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_89+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   13716:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13718:	bf00      	nop
   1371a:	b003      	add	sp, #12
   1371c:	f85d fb04 	ldr.w	pc, [sp], #4
   13720:	1fff9634 	.word	0x1fff9634
   13724:	1fff9630 	.word	0x1fff9630

00013728 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_90>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_90(void)
{
   13728:	b500      	push	{lr}
   1372a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1372c:	f7ed faf6 	bl	d1c <Sys_GetCoreID>
   13730:	4603      	mov	r3, r0
   13732:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_90[u32CoreId])
   13734:	4a10      	ldr	r2, [pc, #64]	; (13778 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_90+0x50>)
   13736:	9b01      	ldr	r3, [sp, #4]
   13738:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1373c:	2b00      	cmp	r3, #0
   1373e:	d10d      	bne.n	1375c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_90+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13740:	f7ed f92a 	bl	998 <Adc_schm_read_msr>
   13744:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   13746:	9b00      	ldr	r3, [sp, #0]
   13748:	f003 0301 	and.w	r3, r3, #1
   1374c:	2b00      	cmp	r3, #0
   1374e:	d100      	bne.n	13752 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_90+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13750:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_90[u32CoreId] = msr;
   13752:	490a      	ldr	r1, [pc, #40]	; (1377c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_90+0x54>)
   13754:	9b01      	ldr	r3, [sp, #4]
   13756:	9a00      	ldr	r2, [sp, #0]
   13758:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_90[u32CoreId]++;
   1375c:	4a06      	ldr	r2, [pc, #24]	; (13778 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_90+0x50>)
   1375e:	9b01      	ldr	r3, [sp, #4]
   13760:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13764:	1c5a      	adds	r2, r3, #1
   13766:	4904      	ldr	r1, [pc, #16]	; (13778 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_90+0x50>)
   13768:	9b01      	ldr	r3, [sp, #4]
   1376a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1376e:	bf00      	nop
   13770:	b003      	add	sp, #12
   13772:	f85d fb04 	ldr.w	pc, [sp], #4
   13776:	bf00      	nop
   13778:	1fff963c 	.word	0x1fff963c
   1377c:	1fff9638 	.word	0x1fff9638

00013780 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_90>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_90(void)
{
   13780:	b500      	push	{lr}
   13782:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13784:	f7ed faca 	bl	d1c <Sys_GetCoreID>
   13788:	4603      	mov	r3, r0
   1378a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_90[u32CoreId]--;
   1378c:	4a0d      	ldr	r2, [pc, #52]	; (137c4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_90+0x44>)
   1378e:	9b01      	ldr	r3, [sp, #4]
   13790:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13794:	1e5a      	subs	r2, r3, #1
   13796:	490b      	ldr	r1, [pc, #44]	; (137c4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_90+0x44>)
   13798:	9b01      	ldr	r3, [sp, #4]
   1379a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_90[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_90[u32CoreId]))         /*if interrupts were enabled*/
   1379e:	4a0a      	ldr	r2, [pc, #40]	; (137c8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_90+0x48>)
   137a0:	9b01      	ldr	r3, [sp, #4]
   137a2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   137a6:	f003 0301 	and.w	r3, r3, #1
   137aa:	2b00      	cmp	r3, #0
   137ac:	d106      	bne.n	137bc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_90+0x3c>
   137ae:	4a05      	ldr	r2, [pc, #20]	; (137c4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_90+0x44>)
   137b0:	9b01      	ldr	r3, [sp, #4]
   137b2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   137b6:	2b00      	cmp	r3, #0
   137b8:	d100      	bne.n	137bc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_90+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   137ba:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   137bc:	bf00      	nop
   137be:	b003      	add	sp, #12
   137c0:	f85d fb04 	ldr.w	pc, [sp], #4
   137c4:	1fff963c 	.word	0x1fff963c
   137c8:	1fff9638 	.word	0x1fff9638

000137cc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_91>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_91(void)
{
   137cc:	b500      	push	{lr}
   137ce:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   137d0:	f7ed faa4 	bl	d1c <Sys_GetCoreID>
   137d4:	4603      	mov	r3, r0
   137d6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_91[u32CoreId])
   137d8:	4a10      	ldr	r2, [pc, #64]	; (1381c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_91+0x50>)
   137da:	9b01      	ldr	r3, [sp, #4]
   137dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   137e0:	2b00      	cmp	r3, #0
   137e2:	d10d      	bne.n	13800 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_91+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   137e4:	f7ed f8d8 	bl	998 <Adc_schm_read_msr>
   137e8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   137ea:	9b00      	ldr	r3, [sp, #0]
   137ec:	f003 0301 	and.w	r3, r3, #1
   137f0:	2b00      	cmp	r3, #0
   137f2:	d100      	bne.n	137f6 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_91+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   137f4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_91[u32CoreId] = msr;
   137f6:	490a      	ldr	r1, [pc, #40]	; (13820 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_91+0x54>)
   137f8:	9b01      	ldr	r3, [sp, #4]
   137fa:	9a00      	ldr	r2, [sp, #0]
   137fc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_91[u32CoreId]++;
   13800:	4a06      	ldr	r2, [pc, #24]	; (1381c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_91+0x50>)
   13802:	9b01      	ldr	r3, [sp, #4]
   13804:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13808:	1c5a      	adds	r2, r3, #1
   1380a:	4904      	ldr	r1, [pc, #16]	; (1381c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_91+0x50>)
   1380c:	9b01      	ldr	r3, [sp, #4]
   1380e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   13812:	bf00      	nop
   13814:	b003      	add	sp, #12
   13816:	f85d fb04 	ldr.w	pc, [sp], #4
   1381a:	bf00      	nop
   1381c:	1fff9644 	.word	0x1fff9644
   13820:	1fff9640 	.word	0x1fff9640

00013824 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_91>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_91(void)
{
   13824:	b500      	push	{lr}
   13826:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13828:	f7ed fa78 	bl	d1c <Sys_GetCoreID>
   1382c:	4603      	mov	r3, r0
   1382e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_91[u32CoreId]--;
   13830:	4a0d      	ldr	r2, [pc, #52]	; (13868 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_91+0x44>)
   13832:	9b01      	ldr	r3, [sp, #4]
   13834:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13838:	1e5a      	subs	r2, r3, #1
   1383a:	490b      	ldr	r1, [pc, #44]	; (13868 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_91+0x44>)
   1383c:	9b01      	ldr	r3, [sp, #4]
   1383e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_91[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_91[u32CoreId]))         /*if interrupts were enabled*/
   13842:	4a0a      	ldr	r2, [pc, #40]	; (1386c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_91+0x48>)
   13844:	9b01      	ldr	r3, [sp, #4]
   13846:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1384a:	f003 0301 	and.w	r3, r3, #1
   1384e:	2b00      	cmp	r3, #0
   13850:	d106      	bne.n	13860 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_91+0x3c>
   13852:	4a05      	ldr	r2, [pc, #20]	; (13868 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_91+0x44>)
   13854:	9b01      	ldr	r3, [sp, #4]
   13856:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1385a:	2b00      	cmp	r3, #0
   1385c:	d100      	bne.n	13860 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_91+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1385e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13860:	bf00      	nop
   13862:	b003      	add	sp, #12
   13864:	f85d fb04 	ldr.w	pc, [sp], #4
   13868:	1fff9644 	.word	0x1fff9644
   1386c:	1fff9640 	.word	0x1fff9640

00013870 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_92>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_92(void)
{
   13870:	b500      	push	{lr}
   13872:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13874:	f7ed fa52 	bl	d1c <Sys_GetCoreID>
   13878:	4603      	mov	r3, r0
   1387a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_92[u32CoreId])
   1387c:	4a10      	ldr	r2, [pc, #64]	; (138c0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_92+0x50>)
   1387e:	9b01      	ldr	r3, [sp, #4]
   13880:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13884:	2b00      	cmp	r3, #0
   13886:	d10d      	bne.n	138a4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_92+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13888:	f7ed f886 	bl	998 <Adc_schm_read_msr>
   1388c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1388e:	9b00      	ldr	r3, [sp, #0]
   13890:	f003 0301 	and.w	r3, r3, #1
   13894:	2b00      	cmp	r3, #0
   13896:	d100      	bne.n	1389a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_92+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13898:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_92[u32CoreId] = msr;
   1389a:	490a      	ldr	r1, [pc, #40]	; (138c4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_92+0x54>)
   1389c:	9b01      	ldr	r3, [sp, #4]
   1389e:	9a00      	ldr	r2, [sp, #0]
   138a0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_92[u32CoreId]++;
   138a4:	4a06      	ldr	r2, [pc, #24]	; (138c0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_92+0x50>)
   138a6:	9b01      	ldr	r3, [sp, #4]
   138a8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   138ac:	1c5a      	adds	r2, r3, #1
   138ae:	4904      	ldr	r1, [pc, #16]	; (138c0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_92+0x50>)
   138b0:	9b01      	ldr	r3, [sp, #4]
   138b2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   138b6:	bf00      	nop
   138b8:	b003      	add	sp, #12
   138ba:	f85d fb04 	ldr.w	pc, [sp], #4
   138be:	bf00      	nop
   138c0:	1fff964c 	.word	0x1fff964c
   138c4:	1fff9648 	.word	0x1fff9648

000138c8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_92>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_92(void)
{
   138c8:	b500      	push	{lr}
   138ca:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   138cc:	f7ed fa26 	bl	d1c <Sys_GetCoreID>
   138d0:	4603      	mov	r3, r0
   138d2:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_92[u32CoreId]--;
   138d4:	4a0d      	ldr	r2, [pc, #52]	; (1390c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_92+0x44>)
   138d6:	9b01      	ldr	r3, [sp, #4]
   138d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   138dc:	1e5a      	subs	r2, r3, #1
   138de:	490b      	ldr	r1, [pc, #44]	; (1390c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_92+0x44>)
   138e0:	9b01      	ldr	r3, [sp, #4]
   138e2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_92[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_92[u32CoreId]))         /*if interrupts were enabled*/
   138e6:	4a0a      	ldr	r2, [pc, #40]	; (13910 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_92+0x48>)
   138e8:	9b01      	ldr	r3, [sp, #4]
   138ea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   138ee:	f003 0301 	and.w	r3, r3, #1
   138f2:	2b00      	cmp	r3, #0
   138f4:	d106      	bne.n	13904 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_92+0x3c>
   138f6:	4a05      	ldr	r2, [pc, #20]	; (1390c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_92+0x44>)
   138f8:	9b01      	ldr	r3, [sp, #4]
   138fa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   138fe:	2b00      	cmp	r3, #0
   13900:	d100      	bne.n	13904 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_92+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   13902:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13904:	bf00      	nop
   13906:	b003      	add	sp, #12
   13908:	f85d fb04 	ldr.w	pc, [sp], #4
   1390c:	1fff964c 	.word	0x1fff964c
   13910:	1fff9648 	.word	0x1fff9648

00013914 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_93>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_93(void)
{
   13914:	b500      	push	{lr}
   13916:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13918:	f7ed fa00 	bl	d1c <Sys_GetCoreID>
   1391c:	4603      	mov	r3, r0
   1391e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_93[u32CoreId])
   13920:	4a10      	ldr	r2, [pc, #64]	; (13964 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_93+0x50>)
   13922:	9b01      	ldr	r3, [sp, #4]
   13924:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13928:	2b00      	cmp	r3, #0
   1392a:	d10d      	bne.n	13948 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_93+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   1392c:	f7ed f834 	bl	998 <Adc_schm_read_msr>
   13930:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   13932:	9b00      	ldr	r3, [sp, #0]
   13934:	f003 0301 	and.w	r3, r3, #1
   13938:	2b00      	cmp	r3, #0
   1393a:	d100      	bne.n	1393e <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_93+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   1393c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_93[u32CoreId] = msr;
   1393e:	490a      	ldr	r1, [pc, #40]	; (13968 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_93+0x54>)
   13940:	9b01      	ldr	r3, [sp, #4]
   13942:	9a00      	ldr	r2, [sp, #0]
   13944:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_93[u32CoreId]++;
   13948:	4a06      	ldr	r2, [pc, #24]	; (13964 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_93+0x50>)
   1394a:	9b01      	ldr	r3, [sp, #4]
   1394c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13950:	1c5a      	adds	r2, r3, #1
   13952:	4904      	ldr	r1, [pc, #16]	; (13964 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_93+0x50>)
   13954:	9b01      	ldr	r3, [sp, #4]
   13956:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1395a:	bf00      	nop
   1395c:	b003      	add	sp, #12
   1395e:	f85d fb04 	ldr.w	pc, [sp], #4
   13962:	bf00      	nop
   13964:	1fff9654 	.word	0x1fff9654
   13968:	1fff9650 	.word	0x1fff9650

0001396c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_93>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_93(void)
{
   1396c:	b500      	push	{lr}
   1396e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13970:	f7ed f9d4 	bl	d1c <Sys_GetCoreID>
   13974:	4603      	mov	r3, r0
   13976:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_93[u32CoreId]--;
   13978:	4a0d      	ldr	r2, [pc, #52]	; (139b0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_93+0x44>)
   1397a:	9b01      	ldr	r3, [sp, #4]
   1397c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13980:	1e5a      	subs	r2, r3, #1
   13982:	490b      	ldr	r1, [pc, #44]	; (139b0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_93+0x44>)
   13984:	9b01      	ldr	r3, [sp, #4]
   13986:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_93[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_93[u32CoreId]))         /*if interrupts were enabled*/
   1398a:	4a0a      	ldr	r2, [pc, #40]	; (139b4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_93+0x48>)
   1398c:	9b01      	ldr	r3, [sp, #4]
   1398e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13992:	f003 0301 	and.w	r3, r3, #1
   13996:	2b00      	cmp	r3, #0
   13998:	d106      	bne.n	139a8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_93+0x3c>
   1399a:	4a05      	ldr	r2, [pc, #20]	; (139b0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_93+0x44>)
   1399c:	9b01      	ldr	r3, [sp, #4]
   1399e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   139a2:	2b00      	cmp	r3, #0
   139a4:	d100      	bne.n	139a8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_93+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   139a6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   139a8:	bf00      	nop
   139aa:	b003      	add	sp, #12
   139ac:	f85d fb04 	ldr.w	pc, [sp], #4
   139b0:	1fff9654 	.word	0x1fff9654
   139b4:	1fff9650 	.word	0x1fff9650

000139b8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_94>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_94(void)
{
   139b8:	b500      	push	{lr}
   139ba:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   139bc:	f7ed f9ae 	bl	d1c <Sys_GetCoreID>
   139c0:	4603      	mov	r3, r0
   139c2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_94[u32CoreId])
   139c4:	4a10      	ldr	r2, [pc, #64]	; (13a08 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_94+0x50>)
   139c6:	9b01      	ldr	r3, [sp, #4]
   139c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   139cc:	2b00      	cmp	r3, #0
   139ce:	d10d      	bne.n	139ec <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_94+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   139d0:	f7ec ffe2 	bl	998 <Adc_schm_read_msr>
   139d4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   139d6:	9b00      	ldr	r3, [sp, #0]
   139d8:	f003 0301 	and.w	r3, r3, #1
   139dc:	2b00      	cmp	r3, #0
   139de:	d100      	bne.n	139e2 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_94+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   139e0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_94[u32CoreId] = msr;
   139e2:	490a      	ldr	r1, [pc, #40]	; (13a0c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_94+0x54>)
   139e4:	9b01      	ldr	r3, [sp, #4]
   139e6:	9a00      	ldr	r2, [sp, #0]
   139e8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_94[u32CoreId]++;
   139ec:	4a06      	ldr	r2, [pc, #24]	; (13a08 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_94+0x50>)
   139ee:	9b01      	ldr	r3, [sp, #4]
   139f0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   139f4:	1c5a      	adds	r2, r3, #1
   139f6:	4904      	ldr	r1, [pc, #16]	; (13a08 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_94+0x50>)
   139f8:	9b01      	ldr	r3, [sp, #4]
   139fa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   139fe:	bf00      	nop
   13a00:	b003      	add	sp, #12
   13a02:	f85d fb04 	ldr.w	pc, [sp], #4
   13a06:	bf00      	nop
   13a08:	1fff965c 	.word	0x1fff965c
   13a0c:	1fff9658 	.word	0x1fff9658

00013a10 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_94>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_94(void)
{
   13a10:	b500      	push	{lr}
   13a12:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13a14:	f7ed f982 	bl	d1c <Sys_GetCoreID>
   13a18:	4603      	mov	r3, r0
   13a1a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_94[u32CoreId]--;
   13a1c:	4a0d      	ldr	r2, [pc, #52]	; (13a54 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_94+0x44>)
   13a1e:	9b01      	ldr	r3, [sp, #4]
   13a20:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13a24:	1e5a      	subs	r2, r3, #1
   13a26:	490b      	ldr	r1, [pc, #44]	; (13a54 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_94+0x44>)
   13a28:	9b01      	ldr	r3, [sp, #4]
   13a2a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_94[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_94[u32CoreId]))         /*if interrupts were enabled*/
   13a2e:	4a0a      	ldr	r2, [pc, #40]	; (13a58 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_94+0x48>)
   13a30:	9b01      	ldr	r3, [sp, #4]
   13a32:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13a36:	f003 0301 	and.w	r3, r3, #1
   13a3a:	2b00      	cmp	r3, #0
   13a3c:	d106      	bne.n	13a4c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_94+0x3c>
   13a3e:	4a05      	ldr	r2, [pc, #20]	; (13a54 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_94+0x44>)
   13a40:	9b01      	ldr	r3, [sp, #4]
   13a42:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13a46:	2b00      	cmp	r3, #0
   13a48:	d100      	bne.n	13a4c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_94+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   13a4a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13a4c:	bf00      	nop
   13a4e:	b003      	add	sp, #12
   13a50:	f85d fb04 	ldr.w	pc, [sp], #4
   13a54:	1fff965c 	.word	0x1fff965c
   13a58:	1fff9658 	.word	0x1fff9658

00013a5c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_95>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_95(void)
{
   13a5c:	b500      	push	{lr}
   13a5e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13a60:	f7ed f95c 	bl	d1c <Sys_GetCoreID>
   13a64:	4603      	mov	r3, r0
   13a66:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_95[u32CoreId])
   13a68:	4a10      	ldr	r2, [pc, #64]	; (13aac <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_95+0x50>)
   13a6a:	9b01      	ldr	r3, [sp, #4]
   13a6c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13a70:	2b00      	cmp	r3, #0
   13a72:	d10d      	bne.n	13a90 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_95+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13a74:	f7ec ff90 	bl	998 <Adc_schm_read_msr>
   13a78:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   13a7a:	9b00      	ldr	r3, [sp, #0]
   13a7c:	f003 0301 	and.w	r3, r3, #1
   13a80:	2b00      	cmp	r3, #0
   13a82:	d100      	bne.n	13a86 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_95+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13a84:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_95[u32CoreId] = msr;
   13a86:	490a      	ldr	r1, [pc, #40]	; (13ab0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_95+0x54>)
   13a88:	9b01      	ldr	r3, [sp, #4]
   13a8a:	9a00      	ldr	r2, [sp, #0]
   13a8c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_95[u32CoreId]++;
   13a90:	4a06      	ldr	r2, [pc, #24]	; (13aac <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_95+0x50>)
   13a92:	9b01      	ldr	r3, [sp, #4]
   13a94:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13a98:	1c5a      	adds	r2, r3, #1
   13a9a:	4904      	ldr	r1, [pc, #16]	; (13aac <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_95+0x50>)
   13a9c:	9b01      	ldr	r3, [sp, #4]
   13a9e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   13aa2:	bf00      	nop
   13aa4:	b003      	add	sp, #12
   13aa6:	f85d fb04 	ldr.w	pc, [sp], #4
   13aaa:	bf00      	nop
   13aac:	1fff9664 	.word	0x1fff9664
   13ab0:	1fff9660 	.word	0x1fff9660

00013ab4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_95>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_95(void)
{
   13ab4:	b500      	push	{lr}
   13ab6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13ab8:	f7ed f930 	bl	d1c <Sys_GetCoreID>
   13abc:	4603      	mov	r3, r0
   13abe:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_95[u32CoreId]--;
   13ac0:	4a0d      	ldr	r2, [pc, #52]	; (13af8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_95+0x44>)
   13ac2:	9b01      	ldr	r3, [sp, #4]
   13ac4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13ac8:	1e5a      	subs	r2, r3, #1
   13aca:	490b      	ldr	r1, [pc, #44]	; (13af8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_95+0x44>)
   13acc:	9b01      	ldr	r3, [sp, #4]
   13ace:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_95[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_95[u32CoreId]))         /*if interrupts were enabled*/
   13ad2:	4a0a      	ldr	r2, [pc, #40]	; (13afc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_95+0x48>)
   13ad4:	9b01      	ldr	r3, [sp, #4]
   13ad6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13ada:	f003 0301 	and.w	r3, r3, #1
   13ade:	2b00      	cmp	r3, #0
   13ae0:	d106      	bne.n	13af0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_95+0x3c>
   13ae2:	4a05      	ldr	r2, [pc, #20]	; (13af8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_95+0x44>)
   13ae4:	9b01      	ldr	r3, [sp, #4]
   13ae6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13aea:	2b00      	cmp	r3, #0
   13aec:	d100      	bne.n	13af0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_95+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   13aee:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13af0:	bf00      	nop
   13af2:	b003      	add	sp, #12
   13af4:	f85d fb04 	ldr.w	pc, [sp], #4
   13af8:	1fff9664 	.word	0x1fff9664
   13afc:	1fff9660 	.word	0x1fff9660

00013b00 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_96>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_96(void)
{
   13b00:	b500      	push	{lr}
   13b02:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13b04:	f7ed f90a 	bl	d1c <Sys_GetCoreID>
   13b08:	4603      	mov	r3, r0
   13b0a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_96[u32CoreId])
   13b0c:	4a10      	ldr	r2, [pc, #64]	; (13b50 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_96+0x50>)
   13b0e:	9b01      	ldr	r3, [sp, #4]
   13b10:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13b14:	2b00      	cmp	r3, #0
   13b16:	d10d      	bne.n	13b34 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_96+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13b18:	f7ec ff3e 	bl	998 <Adc_schm_read_msr>
   13b1c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   13b1e:	9b00      	ldr	r3, [sp, #0]
   13b20:	f003 0301 	and.w	r3, r3, #1
   13b24:	2b00      	cmp	r3, #0
   13b26:	d100      	bne.n	13b2a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_96+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13b28:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_96[u32CoreId] = msr;
   13b2a:	490a      	ldr	r1, [pc, #40]	; (13b54 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_96+0x54>)
   13b2c:	9b01      	ldr	r3, [sp, #4]
   13b2e:	9a00      	ldr	r2, [sp, #0]
   13b30:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_96[u32CoreId]++;
   13b34:	4a06      	ldr	r2, [pc, #24]	; (13b50 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_96+0x50>)
   13b36:	9b01      	ldr	r3, [sp, #4]
   13b38:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13b3c:	1c5a      	adds	r2, r3, #1
   13b3e:	4904      	ldr	r1, [pc, #16]	; (13b50 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_96+0x50>)
   13b40:	9b01      	ldr	r3, [sp, #4]
   13b42:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   13b46:	bf00      	nop
   13b48:	b003      	add	sp, #12
   13b4a:	f85d fb04 	ldr.w	pc, [sp], #4
   13b4e:	bf00      	nop
   13b50:	1fff966c 	.word	0x1fff966c
   13b54:	1fff9668 	.word	0x1fff9668

00013b58 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_96>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_96(void)
{
   13b58:	b500      	push	{lr}
   13b5a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13b5c:	f7ed f8de 	bl	d1c <Sys_GetCoreID>
   13b60:	4603      	mov	r3, r0
   13b62:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_96[u32CoreId]--;
   13b64:	4a0d      	ldr	r2, [pc, #52]	; (13b9c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_96+0x44>)
   13b66:	9b01      	ldr	r3, [sp, #4]
   13b68:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13b6c:	1e5a      	subs	r2, r3, #1
   13b6e:	490b      	ldr	r1, [pc, #44]	; (13b9c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_96+0x44>)
   13b70:	9b01      	ldr	r3, [sp, #4]
   13b72:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_96[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_96[u32CoreId]))         /*if interrupts were enabled*/
   13b76:	4a0a      	ldr	r2, [pc, #40]	; (13ba0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_96+0x48>)
   13b78:	9b01      	ldr	r3, [sp, #4]
   13b7a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13b7e:	f003 0301 	and.w	r3, r3, #1
   13b82:	2b00      	cmp	r3, #0
   13b84:	d106      	bne.n	13b94 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_96+0x3c>
   13b86:	4a05      	ldr	r2, [pc, #20]	; (13b9c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_96+0x44>)
   13b88:	9b01      	ldr	r3, [sp, #4]
   13b8a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13b8e:	2b00      	cmp	r3, #0
   13b90:	d100      	bne.n	13b94 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_96+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   13b92:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13b94:	bf00      	nop
   13b96:	b003      	add	sp, #12
   13b98:	f85d fb04 	ldr.w	pc, [sp], #4
   13b9c:	1fff966c 	.word	0x1fff966c
   13ba0:	1fff9668 	.word	0x1fff9668

00013ba4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_97>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_97(void)
{
   13ba4:	b500      	push	{lr}
   13ba6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13ba8:	f7ed f8b8 	bl	d1c <Sys_GetCoreID>
   13bac:	4603      	mov	r3, r0
   13bae:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_97[u32CoreId])
   13bb0:	4a10      	ldr	r2, [pc, #64]	; (13bf4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_97+0x50>)
   13bb2:	9b01      	ldr	r3, [sp, #4]
   13bb4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13bb8:	2b00      	cmp	r3, #0
   13bba:	d10d      	bne.n	13bd8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_97+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13bbc:	f7ec feec 	bl	998 <Adc_schm_read_msr>
   13bc0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   13bc2:	9b00      	ldr	r3, [sp, #0]
   13bc4:	f003 0301 	and.w	r3, r3, #1
   13bc8:	2b00      	cmp	r3, #0
   13bca:	d100      	bne.n	13bce <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_97+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13bcc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_97[u32CoreId] = msr;
   13bce:	490a      	ldr	r1, [pc, #40]	; (13bf8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_97+0x54>)
   13bd0:	9b01      	ldr	r3, [sp, #4]
   13bd2:	9a00      	ldr	r2, [sp, #0]
   13bd4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_97[u32CoreId]++;
   13bd8:	4a06      	ldr	r2, [pc, #24]	; (13bf4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_97+0x50>)
   13bda:	9b01      	ldr	r3, [sp, #4]
   13bdc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13be0:	1c5a      	adds	r2, r3, #1
   13be2:	4904      	ldr	r1, [pc, #16]	; (13bf4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_97+0x50>)
   13be4:	9b01      	ldr	r3, [sp, #4]
   13be6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   13bea:	bf00      	nop
   13bec:	b003      	add	sp, #12
   13bee:	f85d fb04 	ldr.w	pc, [sp], #4
   13bf2:	bf00      	nop
   13bf4:	1fff9674 	.word	0x1fff9674
   13bf8:	1fff9670 	.word	0x1fff9670

00013bfc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_97>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_97(void)
{
   13bfc:	b500      	push	{lr}
   13bfe:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13c00:	f7ed f88c 	bl	d1c <Sys_GetCoreID>
   13c04:	4603      	mov	r3, r0
   13c06:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_97[u32CoreId]--;
   13c08:	4a0d      	ldr	r2, [pc, #52]	; (13c40 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_97+0x44>)
   13c0a:	9b01      	ldr	r3, [sp, #4]
   13c0c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13c10:	1e5a      	subs	r2, r3, #1
   13c12:	490b      	ldr	r1, [pc, #44]	; (13c40 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_97+0x44>)
   13c14:	9b01      	ldr	r3, [sp, #4]
   13c16:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_97[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_97[u32CoreId]))         /*if interrupts were enabled*/
   13c1a:	4a0a      	ldr	r2, [pc, #40]	; (13c44 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_97+0x48>)
   13c1c:	9b01      	ldr	r3, [sp, #4]
   13c1e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13c22:	f003 0301 	and.w	r3, r3, #1
   13c26:	2b00      	cmp	r3, #0
   13c28:	d106      	bne.n	13c38 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_97+0x3c>
   13c2a:	4a05      	ldr	r2, [pc, #20]	; (13c40 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_97+0x44>)
   13c2c:	9b01      	ldr	r3, [sp, #4]
   13c2e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13c32:	2b00      	cmp	r3, #0
   13c34:	d100      	bne.n	13c38 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_97+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   13c36:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13c38:	bf00      	nop
   13c3a:	b003      	add	sp, #12
   13c3c:	f85d fb04 	ldr.w	pc, [sp], #4
   13c40:	1fff9674 	.word	0x1fff9674
   13c44:	1fff9670 	.word	0x1fff9670

00013c48 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_98>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_98(void)
{
   13c48:	b500      	push	{lr}
   13c4a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13c4c:	f7ed f866 	bl	d1c <Sys_GetCoreID>
   13c50:	4603      	mov	r3, r0
   13c52:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_98[u32CoreId])
   13c54:	4a10      	ldr	r2, [pc, #64]	; (13c98 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_98+0x50>)
   13c56:	9b01      	ldr	r3, [sp, #4]
   13c58:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13c5c:	2b00      	cmp	r3, #0
   13c5e:	d10d      	bne.n	13c7c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_98+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13c60:	f7ec fe9a 	bl	998 <Adc_schm_read_msr>
   13c64:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   13c66:	9b00      	ldr	r3, [sp, #0]
   13c68:	f003 0301 	and.w	r3, r3, #1
   13c6c:	2b00      	cmp	r3, #0
   13c6e:	d100      	bne.n	13c72 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_98+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13c70:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_98[u32CoreId] = msr;
   13c72:	490a      	ldr	r1, [pc, #40]	; (13c9c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_98+0x54>)
   13c74:	9b01      	ldr	r3, [sp, #4]
   13c76:	9a00      	ldr	r2, [sp, #0]
   13c78:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_98[u32CoreId]++;
   13c7c:	4a06      	ldr	r2, [pc, #24]	; (13c98 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_98+0x50>)
   13c7e:	9b01      	ldr	r3, [sp, #4]
   13c80:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13c84:	1c5a      	adds	r2, r3, #1
   13c86:	4904      	ldr	r1, [pc, #16]	; (13c98 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_98+0x50>)
   13c88:	9b01      	ldr	r3, [sp, #4]
   13c8a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   13c8e:	bf00      	nop
   13c90:	b003      	add	sp, #12
   13c92:	f85d fb04 	ldr.w	pc, [sp], #4
   13c96:	bf00      	nop
   13c98:	1fff967c 	.word	0x1fff967c
   13c9c:	1fff9678 	.word	0x1fff9678

00013ca0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_98>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_98(void)
{
   13ca0:	b500      	push	{lr}
   13ca2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13ca4:	f7ed f83a 	bl	d1c <Sys_GetCoreID>
   13ca8:	4603      	mov	r3, r0
   13caa:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_98[u32CoreId]--;
   13cac:	4a0d      	ldr	r2, [pc, #52]	; (13ce4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_98+0x44>)
   13cae:	9b01      	ldr	r3, [sp, #4]
   13cb0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13cb4:	1e5a      	subs	r2, r3, #1
   13cb6:	490b      	ldr	r1, [pc, #44]	; (13ce4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_98+0x44>)
   13cb8:	9b01      	ldr	r3, [sp, #4]
   13cba:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_98[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_98[u32CoreId]))         /*if interrupts were enabled*/
   13cbe:	4a0a      	ldr	r2, [pc, #40]	; (13ce8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_98+0x48>)
   13cc0:	9b01      	ldr	r3, [sp, #4]
   13cc2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13cc6:	f003 0301 	and.w	r3, r3, #1
   13cca:	2b00      	cmp	r3, #0
   13ccc:	d106      	bne.n	13cdc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_98+0x3c>
   13cce:	4a05      	ldr	r2, [pc, #20]	; (13ce4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_98+0x44>)
   13cd0:	9b01      	ldr	r3, [sp, #4]
   13cd2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13cd6:	2b00      	cmp	r3, #0
   13cd8:	d100      	bne.n	13cdc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_98+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   13cda:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13cdc:	bf00      	nop
   13cde:	b003      	add	sp, #12
   13ce0:	f85d fb04 	ldr.w	pc, [sp], #4
   13ce4:	1fff967c 	.word	0x1fff967c
   13ce8:	1fff9678 	.word	0x1fff9678

00013cec <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_99>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_99(void)
{
   13cec:	b500      	push	{lr}
   13cee:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13cf0:	f7ed f814 	bl	d1c <Sys_GetCoreID>
   13cf4:	4603      	mov	r3, r0
   13cf6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_99[u32CoreId])
   13cf8:	4a10      	ldr	r2, [pc, #64]	; (13d3c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_99+0x50>)
   13cfa:	9b01      	ldr	r3, [sp, #4]
   13cfc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13d00:	2b00      	cmp	r3, #0
   13d02:	d10d      	bne.n	13d20 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_99+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13d04:	f7ec fe48 	bl	998 <Adc_schm_read_msr>
   13d08:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   13d0a:	9b00      	ldr	r3, [sp, #0]
   13d0c:	f003 0301 	and.w	r3, r3, #1
   13d10:	2b00      	cmp	r3, #0
   13d12:	d100      	bne.n	13d16 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_99+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13d14:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_99[u32CoreId] = msr;
   13d16:	490a      	ldr	r1, [pc, #40]	; (13d40 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_99+0x54>)
   13d18:	9b01      	ldr	r3, [sp, #4]
   13d1a:	9a00      	ldr	r2, [sp, #0]
   13d1c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_99[u32CoreId]++;
   13d20:	4a06      	ldr	r2, [pc, #24]	; (13d3c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_99+0x50>)
   13d22:	9b01      	ldr	r3, [sp, #4]
   13d24:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13d28:	1c5a      	adds	r2, r3, #1
   13d2a:	4904      	ldr	r1, [pc, #16]	; (13d3c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_99+0x50>)
   13d2c:	9b01      	ldr	r3, [sp, #4]
   13d2e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   13d32:	bf00      	nop
   13d34:	b003      	add	sp, #12
   13d36:	f85d fb04 	ldr.w	pc, [sp], #4
   13d3a:	bf00      	nop
   13d3c:	1fff9684 	.word	0x1fff9684
   13d40:	1fff9680 	.word	0x1fff9680

00013d44 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_99>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_99(void)
{
   13d44:	b500      	push	{lr}
   13d46:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13d48:	f7ec ffe8 	bl	d1c <Sys_GetCoreID>
   13d4c:	4603      	mov	r3, r0
   13d4e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_99[u32CoreId]--;
   13d50:	4a0d      	ldr	r2, [pc, #52]	; (13d88 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_99+0x44>)
   13d52:	9b01      	ldr	r3, [sp, #4]
   13d54:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13d58:	1e5a      	subs	r2, r3, #1
   13d5a:	490b      	ldr	r1, [pc, #44]	; (13d88 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_99+0x44>)
   13d5c:	9b01      	ldr	r3, [sp, #4]
   13d5e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_99[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_99[u32CoreId]))         /*if interrupts were enabled*/
   13d62:	4a0a      	ldr	r2, [pc, #40]	; (13d8c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_99+0x48>)
   13d64:	9b01      	ldr	r3, [sp, #4]
   13d66:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13d6a:	f003 0301 	and.w	r3, r3, #1
   13d6e:	2b00      	cmp	r3, #0
   13d70:	d106      	bne.n	13d80 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_99+0x3c>
   13d72:	4a05      	ldr	r2, [pc, #20]	; (13d88 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_99+0x44>)
   13d74:	9b01      	ldr	r3, [sp, #4]
   13d76:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13d7a:	2b00      	cmp	r3, #0
   13d7c:	d100      	bne.n	13d80 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_99+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   13d7e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13d80:	bf00      	nop
   13d82:	b003      	add	sp, #12
   13d84:	f85d fb04 	ldr.w	pc, [sp], #4
   13d88:	1fff9684 	.word	0x1fff9684
   13d8c:	1fff9680 	.word	0x1fff9680

00013d90 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00(void)
{
   13d90:	b500      	push	{lr}
   13d92:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13d94:	f7ec ffc2 	bl	d1c <Sys_GetCoreID>
   13d98:	4603      	mov	r3, r0
   13d9a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_00[u32CoreId])
   13d9c:	4a10      	ldr	r2, [pc, #64]	; (13de0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x50>)
   13d9e:	9b01      	ldr	r3, [sp, #4]
   13da0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13da4:	2b00      	cmp	r3, #0
   13da6:	d10d      	bne.n	13dc4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13da8:	f7ec fdff 	bl	9aa <Can_43_FLEXCAN_schm_read_msr>
   13dac:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   13dae:	9b00      	ldr	r3, [sp, #0]
   13db0:	f003 0301 	and.w	r3, r3, #1
   13db4:	2b00      	cmp	r3, #0
   13db6:	d100      	bne.n	13dba <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13db8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_00[u32CoreId] = msr;
   13dba:	490a      	ldr	r1, [pc, #40]	; (13de4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x54>)
   13dbc:	9b01      	ldr	r3, [sp, #4]
   13dbe:	9a00      	ldr	r2, [sp, #0]
   13dc0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_00[u32CoreId]++;
   13dc4:	4a06      	ldr	r2, [pc, #24]	; (13de0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x50>)
   13dc6:	9b01      	ldr	r3, [sp, #4]
   13dc8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13dcc:	1c5a      	adds	r2, r3, #1
   13dce:	4904      	ldr	r1, [pc, #16]	; (13de0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x50>)
   13dd0:	9b01      	ldr	r3, [sp, #4]
   13dd2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   13dd6:	bf00      	nop
   13dd8:	b003      	add	sp, #12
   13dda:	f85d fb04 	ldr.w	pc, [sp], #4
   13dde:	bf00      	nop
   13de0:	1fff968c 	.word	0x1fff968c
   13de4:	1fff9688 	.word	0x1fff9688

00013de8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00(void)
{
   13de8:	b500      	push	{lr}
   13dea:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13dec:	f7ec ff96 	bl	d1c <Sys_GetCoreID>
   13df0:	4603      	mov	r3, r0
   13df2:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_00[u32CoreId]--;
   13df4:	4a0d      	ldr	r2, [pc, #52]	; (13e2c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x44>)
   13df6:	9b01      	ldr	r3, [sp, #4]
   13df8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13dfc:	1e5a      	subs	r2, r3, #1
   13dfe:	490b      	ldr	r1, [pc, #44]	; (13e2c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x44>)
   13e00:	9b01      	ldr	r3, [sp, #4]
   13e02:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
   13e06:	4a0a      	ldr	r2, [pc, #40]	; (13e30 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x48>)
   13e08:	9b01      	ldr	r3, [sp, #4]
   13e0a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13e0e:	f003 0301 	and.w	r3, r3, #1
   13e12:	2b00      	cmp	r3, #0
   13e14:	d106      	bne.n	13e24 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x3c>
   13e16:	4a05      	ldr	r2, [pc, #20]	; (13e2c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x44>)
   13e18:	9b01      	ldr	r3, [sp, #4]
   13e1a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13e1e:	2b00      	cmp	r3, #0
   13e20:	d100      	bne.n	13e24 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   13e22:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13e24:	bf00      	nop
   13e26:	b003      	add	sp, #12
   13e28:	f85d fb04 	ldr.w	pc, [sp], #4
   13e2c:	1fff968c 	.word	0x1fff968c
   13e30:	1fff9688 	.word	0x1fff9688

00013e34 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01(void)
{
   13e34:	b500      	push	{lr}
   13e36:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13e38:	f7ec ff70 	bl	d1c <Sys_GetCoreID>
   13e3c:	4603      	mov	r3, r0
   13e3e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_01[u32CoreId])
   13e40:	4a10      	ldr	r2, [pc, #64]	; (13e84 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x50>)
   13e42:	9b01      	ldr	r3, [sp, #4]
   13e44:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13e48:	2b00      	cmp	r3, #0
   13e4a:	d10d      	bne.n	13e68 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13e4c:	f7ec fdad 	bl	9aa <Can_43_FLEXCAN_schm_read_msr>
   13e50:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   13e52:	9b00      	ldr	r3, [sp, #0]
   13e54:	f003 0301 	and.w	r3, r3, #1
   13e58:	2b00      	cmp	r3, #0
   13e5a:	d100      	bne.n	13e5e <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13e5c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_01[u32CoreId] = msr;
   13e5e:	490a      	ldr	r1, [pc, #40]	; (13e88 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x54>)
   13e60:	9b01      	ldr	r3, [sp, #4]
   13e62:	9a00      	ldr	r2, [sp, #0]
   13e64:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_01[u32CoreId]++;
   13e68:	4a06      	ldr	r2, [pc, #24]	; (13e84 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x50>)
   13e6a:	9b01      	ldr	r3, [sp, #4]
   13e6c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13e70:	1c5a      	adds	r2, r3, #1
   13e72:	4904      	ldr	r1, [pc, #16]	; (13e84 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x50>)
   13e74:	9b01      	ldr	r3, [sp, #4]
   13e76:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   13e7a:	bf00      	nop
   13e7c:	b003      	add	sp, #12
   13e7e:	f85d fb04 	ldr.w	pc, [sp], #4
   13e82:	bf00      	nop
   13e84:	1fff9694 	.word	0x1fff9694
   13e88:	1fff9690 	.word	0x1fff9690

00013e8c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01(void)
{
   13e8c:	b500      	push	{lr}
   13e8e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13e90:	f7ec ff44 	bl	d1c <Sys_GetCoreID>
   13e94:	4603      	mov	r3, r0
   13e96:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_01[u32CoreId]--;
   13e98:	4a0d      	ldr	r2, [pc, #52]	; (13ed0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x44>)
   13e9a:	9b01      	ldr	r3, [sp, #4]
   13e9c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13ea0:	1e5a      	subs	r2, r3, #1
   13ea2:	490b      	ldr	r1, [pc, #44]	; (13ed0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x44>)
   13ea4:	9b01      	ldr	r3, [sp, #4]
   13ea6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
   13eaa:	4a0a      	ldr	r2, [pc, #40]	; (13ed4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x48>)
   13eac:	9b01      	ldr	r3, [sp, #4]
   13eae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13eb2:	f003 0301 	and.w	r3, r3, #1
   13eb6:	2b00      	cmp	r3, #0
   13eb8:	d106      	bne.n	13ec8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x3c>
   13eba:	4a05      	ldr	r2, [pc, #20]	; (13ed0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x44>)
   13ebc:	9b01      	ldr	r3, [sp, #4]
   13ebe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13ec2:	2b00      	cmp	r3, #0
   13ec4:	d100      	bne.n	13ec8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   13ec6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13ec8:	bf00      	nop
   13eca:	b003      	add	sp, #12
   13ecc:	f85d fb04 	ldr.w	pc, [sp], #4
   13ed0:	1fff9694 	.word	0x1fff9694
   13ed4:	1fff9690 	.word	0x1fff9690

00013ed8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02(void)
{
   13ed8:	b500      	push	{lr}
   13eda:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13edc:	f7ec ff1e 	bl	d1c <Sys_GetCoreID>
   13ee0:	4603      	mov	r3, r0
   13ee2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_02[u32CoreId])
   13ee4:	4a10      	ldr	r2, [pc, #64]	; (13f28 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x50>)
   13ee6:	9b01      	ldr	r3, [sp, #4]
   13ee8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13eec:	2b00      	cmp	r3, #0
   13eee:	d10d      	bne.n	13f0c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13ef0:	f7ec fd5b 	bl	9aa <Can_43_FLEXCAN_schm_read_msr>
   13ef4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   13ef6:	9b00      	ldr	r3, [sp, #0]
   13ef8:	f003 0301 	and.w	r3, r3, #1
   13efc:	2b00      	cmp	r3, #0
   13efe:	d100      	bne.n	13f02 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13f00:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_02[u32CoreId] = msr;
   13f02:	490a      	ldr	r1, [pc, #40]	; (13f2c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x54>)
   13f04:	9b01      	ldr	r3, [sp, #4]
   13f06:	9a00      	ldr	r2, [sp, #0]
   13f08:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_02[u32CoreId]++;
   13f0c:	4a06      	ldr	r2, [pc, #24]	; (13f28 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x50>)
   13f0e:	9b01      	ldr	r3, [sp, #4]
   13f10:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13f14:	1c5a      	adds	r2, r3, #1
   13f16:	4904      	ldr	r1, [pc, #16]	; (13f28 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x50>)
   13f18:	9b01      	ldr	r3, [sp, #4]
   13f1a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   13f1e:	bf00      	nop
   13f20:	b003      	add	sp, #12
   13f22:	f85d fb04 	ldr.w	pc, [sp], #4
   13f26:	bf00      	nop
   13f28:	1fff969c 	.word	0x1fff969c
   13f2c:	1fff9698 	.word	0x1fff9698

00013f30 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02(void)
{
   13f30:	b500      	push	{lr}
   13f32:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13f34:	f7ec fef2 	bl	d1c <Sys_GetCoreID>
   13f38:	4603      	mov	r3, r0
   13f3a:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_02[u32CoreId]--;
   13f3c:	4a0d      	ldr	r2, [pc, #52]	; (13f74 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x44>)
   13f3e:	9b01      	ldr	r3, [sp, #4]
   13f40:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13f44:	1e5a      	subs	r2, r3, #1
   13f46:	490b      	ldr	r1, [pc, #44]	; (13f74 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x44>)
   13f48:	9b01      	ldr	r3, [sp, #4]
   13f4a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_02[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_02[u32CoreId]))         /*if interrupts were enabled*/
   13f4e:	4a0a      	ldr	r2, [pc, #40]	; (13f78 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x48>)
   13f50:	9b01      	ldr	r3, [sp, #4]
   13f52:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13f56:	f003 0301 	and.w	r3, r3, #1
   13f5a:	2b00      	cmp	r3, #0
   13f5c:	d106      	bne.n	13f6c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x3c>
   13f5e:	4a05      	ldr	r2, [pc, #20]	; (13f74 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x44>)
   13f60:	9b01      	ldr	r3, [sp, #4]
   13f62:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13f66:	2b00      	cmp	r3, #0
   13f68:	d100      	bne.n	13f6c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   13f6a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13f6c:	bf00      	nop
   13f6e:	b003      	add	sp, #12
   13f70:	f85d fb04 	ldr.w	pc, [sp], #4
   13f74:	1fff969c 	.word	0x1fff969c
   13f78:	1fff9698 	.word	0x1fff9698

00013f7c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03(void)
{
   13f7c:	b500      	push	{lr}
   13f7e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13f80:	f7ec fecc 	bl	d1c <Sys_GetCoreID>
   13f84:	4603      	mov	r3, r0
   13f86:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_03[u32CoreId])
   13f88:	4a10      	ldr	r2, [pc, #64]	; (13fcc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x50>)
   13f8a:	9b01      	ldr	r3, [sp, #4]
   13f8c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13f90:	2b00      	cmp	r3, #0
   13f92:	d10d      	bne.n	13fb0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13f94:	f7ec fd09 	bl	9aa <Can_43_FLEXCAN_schm_read_msr>
   13f98:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   13f9a:	9b00      	ldr	r3, [sp, #0]
   13f9c:	f003 0301 	and.w	r3, r3, #1
   13fa0:	2b00      	cmp	r3, #0
   13fa2:	d100      	bne.n	13fa6 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13fa4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_03[u32CoreId] = msr;
   13fa6:	490a      	ldr	r1, [pc, #40]	; (13fd0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x54>)
   13fa8:	9b01      	ldr	r3, [sp, #4]
   13faa:	9a00      	ldr	r2, [sp, #0]
   13fac:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_03[u32CoreId]++;
   13fb0:	4a06      	ldr	r2, [pc, #24]	; (13fcc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x50>)
   13fb2:	9b01      	ldr	r3, [sp, #4]
   13fb4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13fb8:	1c5a      	adds	r2, r3, #1
   13fba:	4904      	ldr	r1, [pc, #16]	; (13fcc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x50>)
   13fbc:	9b01      	ldr	r3, [sp, #4]
   13fbe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   13fc2:	bf00      	nop
   13fc4:	b003      	add	sp, #12
   13fc6:	f85d fb04 	ldr.w	pc, [sp], #4
   13fca:	bf00      	nop
   13fcc:	1fff96a4 	.word	0x1fff96a4
   13fd0:	1fff96a0 	.word	0x1fff96a0

00013fd4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03(void)
{
   13fd4:	b500      	push	{lr}
   13fd6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13fd8:	f7ec fea0 	bl	d1c <Sys_GetCoreID>
   13fdc:	4603      	mov	r3, r0
   13fde:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_03[u32CoreId]--;
   13fe0:	4a0d      	ldr	r2, [pc, #52]	; (14018 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x44>)
   13fe2:	9b01      	ldr	r3, [sp, #4]
   13fe4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13fe8:	1e5a      	subs	r2, r3, #1
   13fea:	490b      	ldr	r1, [pc, #44]	; (14018 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x44>)
   13fec:	9b01      	ldr	r3, [sp, #4]
   13fee:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_03[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_03[u32CoreId]))         /*if interrupts were enabled*/
   13ff2:	4a0a      	ldr	r2, [pc, #40]	; (1401c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x48>)
   13ff4:	9b01      	ldr	r3, [sp, #4]
   13ff6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13ffa:	f003 0301 	and.w	r3, r3, #1
   13ffe:	2b00      	cmp	r3, #0
   14000:	d106      	bne.n	14010 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x3c>
   14002:	4a05      	ldr	r2, [pc, #20]	; (14018 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x44>)
   14004:	9b01      	ldr	r3, [sp, #4]
   14006:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1400a:	2b00      	cmp	r3, #0
   1400c:	d100      	bne.n	14010 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1400e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   14010:	bf00      	nop
   14012:	b003      	add	sp, #12
   14014:	f85d fb04 	ldr.w	pc, [sp], #4
   14018:	1fff96a4 	.word	0x1fff96a4
   1401c:	1fff96a0 	.word	0x1fff96a0

00014020 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04(void)
{
   14020:	b500      	push	{lr}
   14022:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14024:	f7ec fe7a 	bl	d1c <Sys_GetCoreID>
   14028:	4603      	mov	r3, r0
   1402a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_04[u32CoreId])
   1402c:	4a10      	ldr	r2, [pc, #64]	; (14070 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x50>)
   1402e:	9b01      	ldr	r3, [sp, #4]
   14030:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14034:	2b00      	cmp	r3, #0
   14036:	d10d      	bne.n	14054 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   14038:	f7ec fcb7 	bl	9aa <Can_43_FLEXCAN_schm_read_msr>
   1403c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1403e:	9b00      	ldr	r3, [sp, #0]
   14040:	f003 0301 	and.w	r3, r3, #1
   14044:	2b00      	cmp	r3, #0
   14046:	d100      	bne.n	1404a <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   14048:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_04[u32CoreId] = msr;
   1404a:	490a      	ldr	r1, [pc, #40]	; (14074 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x54>)
   1404c:	9b01      	ldr	r3, [sp, #4]
   1404e:	9a00      	ldr	r2, [sp, #0]
   14050:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_04[u32CoreId]++;
   14054:	4a06      	ldr	r2, [pc, #24]	; (14070 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x50>)
   14056:	9b01      	ldr	r3, [sp, #4]
   14058:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1405c:	1c5a      	adds	r2, r3, #1
   1405e:	4904      	ldr	r1, [pc, #16]	; (14070 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x50>)
   14060:	9b01      	ldr	r3, [sp, #4]
   14062:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   14066:	bf00      	nop
   14068:	b003      	add	sp, #12
   1406a:	f85d fb04 	ldr.w	pc, [sp], #4
   1406e:	bf00      	nop
   14070:	1fff96ac 	.word	0x1fff96ac
   14074:	1fff96a8 	.word	0x1fff96a8

00014078 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04(void)
{
   14078:	b500      	push	{lr}
   1407a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1407c:	f7ec fe4e 	bl	d1c <Sys_GetCoreID>
   14080:	4603      	mov	r3, r0
   14082:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_04[u32CoreId]--;
   14084:	4a0d      	ldr	r2, [pc, #52]	; (140bc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x44>)
   14086:	9b01      	ldr	r3, [sp, #4]
   14088:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1408c:	1e5a      	subs	r2, r3, #1
   1408e:	490b      	ldr	r1, [pc, #44]	; (140bc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x44>)
   14090:	9b01      	ldr	r3, [sp, #4]
   14092:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_04[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_04[u32CoreId]))         /*if interrupts were enabled*/
   14096:	4a0a      	ldr	r2, [pc, #40]	; (140c0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x48>)
   14098:	9b01      	ldr	r3, [sp, #4]
   1409a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1409e:	f003 0301 	and.w	r3, r3, #1
   140a2:	2b00      	cmp	r3, #0
   140a4:	d106      	bne.n	140b4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x3c>
   140a6:	4a05      	ldr	r2, [pc, #20]	; (140bc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x44>)
   140a8:	9b01      	ldr	r3, [sp, #4]
   140aa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   140ae:	2b00      	cmp	r3, #0
   140b0:	d100      	bne.n	140b4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   140b2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   140b4:	bf00      	nop
   140b6:	b003      	add	sp, #12
   140b8:	f85d fb04 	ldr.w	pc, [sp], #4
   140bc:	1fff96ac 	.word	0x1fff96ac
   140c0:	1fff96a8 	.word	0x1fff96a8

000140c4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05(void)
{
   140c4:	b500      	push	{lr}
   140c6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   140c8:	f7ec fe28 	bl	d1c <Sys_GetCoreID>
   140cc:	4603      	mov	r3, r0
   140ce:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_05[u32CoreId])
   140d0:	4a10      	ldr	r2, [pc, #64]	; (14114 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x50>)
   140d2:	9b01      	ldr	r3, [sp, #4]
   140d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   140d8:	2b00      	cmp	r3, #0
   140da:	d10d      	bne.n	140f8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   140dc:	f7ec fc65 	bl	9aa <Can_43_FLEXCAN_schm_read_msr>
   140e0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   140e2:	9b00      	ldr	r3, [sp, #0]
   140e4:	f003 0301 	and.w	r3, r3, #1
   140e8:	2b00      	cmp	r3, #0
   140ea:	d100      	bne.n	140ee <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   140ec:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_05[u32CoreId] = msr;
   140ee:	490a      	ldr	r1, [pc, #40]	; (14118 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x54>)
   140f0:	9b01      	ldr	r3, [sp, #4]
   140f2:	9a00      	ldr	r2, [sp, #0]
   140f4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_05[u32CoreId]++;
   140f8:	4a06      	ldr	r2, [pc, #24]	; (14114 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x50>)
   140fa:	9b01      	ldr	r3, [sp, #4]
   140fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14100:	1c5a      	adds	r2, r3, #1
   14102:	4904      	ldr	r1, [pc, #16]	; (14114 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x50>)
   14104:	9b01      	ldr	r3, [sp, #4]
   14106:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1410a:	bf00      	nop
   1410c:	b003      	add	sp, #12
   1410e:	f85d fb04 	ldr.w	pc, [sp], #4
   14112:	bf00      	nop
   14114:	1fff96b4 	.word	0x1fff96b4
   14118:	1fff96b0 	.word	0x1fff96b0

0001411c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05(void)
{
   1411c:	b500      	push	{lr}
   1411e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14120:	f7ec fdfc 	bl	d1c <Sys_GetCoreID>
   14124:	4603      	mov	r3, r0
   14126:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_05[u32CoreId]--;
   14128:	4a0d      	ldr	r2, [pc, #52]	; (14160 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x44>)
   1412a:	9b01      	ldr	r3, [sp, #4]
   1412c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14130:	1e5a      	subs	r2, r3, #1
   14132:	490b      	ldr	r1, [pc, #44]	; (14160 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x44>)
   14134:	9b01      	ldr	r3, [sp, #4]
   14136:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_05[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_05[u32CoreId]))         /*if interrupts were enabled*/
   1413a:	4a0a      	ldr	r2, [pc, #40]	; (14164 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x48>)
   1413c:	9b01      	ldr	r3, [sp, #4]
   1413e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14142:	f003 0301 	and.w	r3, r3, #1
   14146:	2b00      	cmp	r3, #0
   14148:	d106      	bne.n	14158 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x3c>
   1414a:	4a05      	ldr	r2, [pc, #20]	; (14160 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x44>)
   1414c:	9b01      	ldr	r3, [sp, #4]
   1414e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14152:	2b00      	cmp	r3, #0
   14154:	d100      	bne.n	14158 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   14156:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   14158:	bf00      	nop
   1415a:	b003      	add	sp, #12
   1415c:	f85d fb04 	ldr.w	pc, [sp], #4
   14160:	1fff96b4 	.word	0x1fff96b4
   14164:	1fff96b0 	.word	0x1fff96b0

00014168 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06(void)
{
   14168:	b500      	push	{lr}
   1416a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1416c:	f7ec fdd6 	bl	d1c <Sys_GetCoreID>
   14170:	4603      	mov	r3, r0
   14172:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_06[u32CoreId])
   14174:	4a10      	ldr	r2, [pc, #64]	; (141b8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x50>)
   14176:	9b01      	ldr	r3, [sp, #4]
   14178:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1417c:	2b00      	cmp	r3, #0
   1417e:	d10d      	bne.n	1419c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   14180:	f7ec fc13 	bl	9aa <Can_43_FLEXCAN_schm_read_msr>
   14184:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   14186:	9b00      	ldr	r3, [sp, #0]
   14188:	f003 0301 	and.w	r3, r3, #1
   1418c:	2b00      	cmp	r3, #0
   1418e:	d100      	bne.n	14192 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   14190:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_06[u32CoreId] = msr;
   14192:	490a      	ldr	r1, [pc, #40]	; (141bc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x54>)
   14194:	9b01      	ldr	r3, [sp, #4]
   14196:	9a00      	ldr	r2, [sp, #0]
   14198:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_06[u32CoreId]++;
   1419c:	4a06      	ldr	r2, [pc, #24]	; (141b8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x50>)
   1419e:	9b01      	ldr	r3, [sp, #4]
   141a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   141a4:	1c5a      	adds	r2, r3, #1
   141a6:	4904      	ldr	r1, [pc, #16]	; (141b8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x50>)
   141a8:	9b01      	ldr	r3, [sp, #4]
   141aa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   141ae:	bf00      	nop
   141b0:	b003      	add	sp, #12
   141b2:	f85d fb04 	ldr.w	pc, [sp], #4
   141b6:	bf00      	nop
   141b8:	1fff96bc 	.word	0x1fff96bc
   141bc:	1fff96b8 	.word	0x1fff96b8

000141c0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06(void)
{
   141c0:	b500      	push	{lr}
   141c2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   141c4:	f7ec fdaa 	bl	d1c <Sys_GetCoreID>
   141c8:	4603      	mov	r3, r0
   141ca:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_06[u32CoreId]--;
   141cc:	4a0d      	ldr	r2, [pc, #52]	; (14204 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x44>)
   141ce:	9b01      	ldr	r3, [sp, #4]
   141d0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   141d4:	1e5a      	subs	r2, r3, #1
   141d6:	490b      	ldr	r1, [pc, #44]	; (14204 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x44>)
   141d8:	9b01      	ldr	r3, [sp, #4]
   141da:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_06[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_06[u32CoreId]))         /*if interrupts were enabled*/
   141de:	4a0a      	ldr	r2, [pc, #40]	; (14208 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x48>)
   141e0:	9b01      	ldr	r3, [sp, #4]
   141e2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   141e6:	f003 0301 	and.w	r3, r3, #1
   141ea:	2b00      	cmp	r3, #0
   141ec:	d106      	bne.n	141fc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x3c>
   141ee:	4a05      	ldr	r2, [pc, #20]	; (14204 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x44>)
   141f0:	9b01      	ldr	r3, [sp, #4]
   141f2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   141f6:	2b00      	cmp	r3, #0
   141f8:	d100      	bne.n	141fc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   141fa:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   141fc:	bf00      	nop
   141fe:	b003      	add	sp, #12
   14200:	f85d fb04 	ldr.w	pc, [sp], #4
   14204:	1fff96bc 	.word	0x1fff96bc
   14208:	1fff96b8 	.word	0x1fff96b8

0001420c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07(void)
{
   1420c:	b500      	push	{lr}
   1420e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14210:	f7ec fd84 	bl	d1c <Sys_GetCoreID>
   14214:	4603      	mov	r3, r0
   14216:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_07[u32CoreId])
   14218:	4a10      	ldr	r2, [pc, #64]	; (1425c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x50>)
   1421a:	9b01      	ldr	r3, [sp, #4]
   1421c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14220:	2b00      	cmp	r3, #0
   14222:	d10d      	bne.n	14240 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   14224:	f7ec fbc1 	bl	9aa <Can_43_FLEXCAN_schm_read_msr>
   14228:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1422a:	9b00      	ldr	r3, [sp, #0]
   1422c:	f003 0301 	and.w	r3, r3, #1
   14230:	2b00      	cmp	r3, #0
   14232:	d100      	bne.n	14236 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   14234:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_07[u32CoreId] = msr;
   14236:	490a      	ldr	r1, [pc, #40]	; (14260 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x54>)
   14238:	9b01      	ldr	r3, [sp, #4]
   1423a:	9a00      	ldr	r2, [sp, #0]
   1423c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_07[u32CoreId]++;
   14240:	4a06      	ldr	r2, [pc, #24]	; (1425c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x50>)
   14242:	9b01      	ldr	r3, [sp, #4]
   14244:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14248:	1c5a      	adds	r2, r3, #1
   1424a:	4904      	ldr	r1, [pc, #16]	; (1425c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x50>)
   1424c:	9b01      	ldr	r3, [sp, #4]
   1424e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   14252:	bf00      	nop
   14254:	b003      	add	sp, #12
   14256:	f85d fb04 	ldr.w	pc, [sp], #4
   1425a:	bf00      	nop
   1425c:	1fff96c4 	.word	0x1fff96c4
   14260:	1fff96c0 	.word	0x1fff96c0

00014264 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07(void)
{
   14264:	b500      	push	{lr}
   14266:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14268:	f7ec fd58 	bl	d1c <Sys_GetCoreID>
   1426c:	4603      	mov	r3, r0
   1426e:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_07[u32CoreId]--;
   14270:	4a0d      	ldr	r2, [pc, #52]	; (142a8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x44>)
   14272:	9b01      	ldr	r3, [sp, #4]
   14274:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14278:	1e5a      	subs	r2, r3, #1
   1427a:	490b      	ldr	r1, [pc, #44]	; (142a8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x44>)
   1427c:	9b01      	ldr	r3, [sp, #4]
   1427e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_07[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_07[u32CoreId]))         /*if interrupts were enabled*/
   14282:	4a0a      	ldr	r2, [pc, #40]	; (142ac <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x48>)
   14284:	9b01      	ldr	r3, [sp, #4]
   14286:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1428a:	f003 0301 	and.w	r3, r3, #1
   1428e:	2b00      	cmp	r3, #0
   14290:	d106      	bne.n	142a0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x3c>
   14292:	4a05      	ldr	r2, [pc, #20]	; (142a8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x44>)
   14294:	9b01      	ldr	r3, [sp, #4]
   14296:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1429a:	2b00      	cmp	r3, #0
   1429c:	d100      	bne.n	142a0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1429e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   142a0:	bf00      	nop
   142a2:	b003      	add	sp, #12
   142a4:	f85d fb04 	ldr.w	pc, [sp], #4
   142a8:	1fff96c4 	.word	0x1fff96c4
   142ac:	1fff96c0 	.word	0x1fff96c0

000142b0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08(void)
{
   142b0:	b500      	push	{lr}
   142b2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   142b4:	f7ec fd32 	bl	d1c <Sys_GetCoreID>
   142b8:	4603      	mov	r3, r0
   142ba:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_08[u32CoreId])
   142bc:	4a10      	ldr	r2, [pc, #64]	; (14300 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x50>)
   142be:	9b01      	ldr	r3, [sp, #4]
   142c0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   142c4:	2b00      	cmp	r3, #0
   142c6:	d10d      	bne.n	142e4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   142c8:	f7ec fb6f 	bl	9aa <Can_43_FLEXCAN_schm_read_msr>
   142cc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   142ce:	9b00      	ldr	r3, [sp, #0]
   142d0:	f003 0301 	and.w	r3, r3, #1
   142d4:	2b00      	cmp	r3, #0
   142d6:	d100      	bne.n	142da <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   142d8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_08[u32CoreId] = msr;
   142da:	490a      	ldr	r1, [pc, #40]	; (14304 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x54>)
   142dc:	9b01      	ldr	r3, [sp, #4]
   142de:	9a00      	ldr	r2, [sp, #0]
   142e0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_08[u32CoreId]++;
   142e4:	4a06      	ldr	r2, [pc, #24]	; (14300 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x50>)
   142e6:	9b01      	ldr	r3, [sp, #4]
   142e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   142ec:	1c5a      	adds	r2, r3, #1
   142ee:	4904      	ldr	r1, [pc, #16]	; (14300 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x50>)
   142f0:	9b01      	ldr	r3, [sp, #4]
   142f2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   142f6:	bf00      	nop
   142f8:	b003      	add	sp, #12
   142fa:	f85d fb04 	ldr.w	pc, [sp], #4
   142fe:	bf00      	nop
   14300:	1fff96cc 	.word	0x1fff96cc
   14304:	1fff96c8 	.word	0x1fff96c8

00014308 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08(void)
{
   14308:	b500      	push	{lr}
   1430a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1430c:	f7ec fd06 	bl	d1c <Sys_GetCoreID>
   14310:	4603      	mov	r3, r0
   14312:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_08[u32CoreId]--;
   14314:	4a0d      	ldr	r2, [pc, #52]	; (1434c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x44>)
   14316:	9b01      	ldr	r3, [sp, #4]
   14318:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1431c:	1e5a      	subs	r2, r3, #1
   1431e:	490b      	ldr	r1, [pc, #44]	; (1434c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x44>)
   14320:	9b01      	ldr	r3, [sp, #4]
   14322:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_08[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_08[u32CoreId]))         /*if interrupts were enabled*/
   14326:	4a0a      	ldr	r2, [pc, #40]	; (14350 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x48>)
   14328:	9b01      	ldr	r3, [sp, #4]
   1432a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1432e:	f003 0301 	and.w	r3, r3, #1
   14332:	2b00      	cmp	r3, #0
   14334:	d106      	bne.n	14344 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x3c>
   14336:	4a05      	ldr	r2, [pc, #20]	; (1434c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x44>)
   14338:	9b01      	ldr	r3, [sp, #4]
   1433a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1433e:	2b00      	cmp	r3, #0
   14340:	d100      	bne.n	14344 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   14342:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   14344:	bf00      	nop
   14346:	b003      	add	sp, #12
   14348:	f85d fb04 	ldr.w	pc, [sp], #4
   1434c:	1fff96cc 	.word	0x1fff96cc
   14350:	1fff96c8 	.word	0x1fff96c8

00014354 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09(void)
{
   14354:	b500      	push	{lr}
   14356:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14358:	f7ec fce0 	bl	d1c <Sys_GetCoreID>
   1435c:	4603      	mov	r3, r0
   1435e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_09[u32CoreId])
   14360:	4a10      	ldr	r2, [pc, #64]	; (143a4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x50>)
   14362:	9b01      	ldr	r3, [sp, #4]
   14364:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14368:	2b00      	cmp	r3, #0
   1436a:	d10d      	bne.n	14388 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   1436c:	f7ec fb1d 	bl	9aa <Can_43_FLEXCAN_schm_read_msr>
   14370:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   14372:	9b00      	ldr	r3, [sp, #0]
   14374:	f003 0301 	and.w	r3, r3, #1
   14378:	2b00      	cmp	r3, #0
   1437a:	d100      	bne.n	1437e <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   1437c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_09[u32CoreId] = msr;
   1437e:	490a      	ldr	r1, [pc, #40]	; (143a8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x54>)
   14380:	9b01      	ldr	r3, [sp, #4]
   14382:	9a00      	ldr	r2, [sp, #0]
   14384:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_09[u32CoreId]++;
   14388:	4a06      	ldr	r2, [pc, #24]	; (143a4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x50>)
   1438a:	9b01      	ldr	r3, [sp, #4]
   1438c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14390:	1c5a      	adds	r2, r3, #1
   14392:	4904      	ldr	r1, [pc, #16]	; (143a4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x50>)
   14394:	9b01      	ldr	r3, [sp, #4]
   14396:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1439a:	bf00      	nop
   1439c:	b003      	add	sp, #12
   1439e:	f85d fb04 	ldr.w	pc, [sp], #4
   143a2:	bf00      	nop
   143a4:	1fff96d4 	.word	0x1fff96d4
   143a8:	1fff96d0 	.word	0x1fff96d0

000143ac <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09(void)
{
   143ac:	b500      	push	{lr}
   143ae:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   143b0:	f7ec fcb4 	bl	d1c <Sys_GetCoreID>
   143b4:	4603      	mov	r3, r0
   143b6:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_09[u32CoreId]--;
   143b8:	4a0d      	ldr	r2, [pc, #52]	; (143f0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x44>)
   143ba:	9b01      	ldr	r3, [sp, #4]
   143bc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   143c0:	1e5a      	subs	r2, r3, #1
   143c2:	490b      	ldr	r1, [pc, #44]	; (143f0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x44>)
   143c4:	9b01      	ldr	r3, [sp, #4]
   143c6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_09[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_09[u32CoreId]))         /*if interrupts were enabled*/
   143ca:	4a0a      	ldr	r2, [pc, #40]	; (143f4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x48>)
   143cc:	9b01      	ldr	r3, [sp, #4]
   143ce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   143d2:	f003 0301 	and.w	r3, r3, #1
   143d6:	2b00      	cmp	r3, #0
   143d8:	d106      	bne.n	143e8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x3c>
   143da:	4a05      	ldr	r2, [pc, #20]	; (143f0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x44>)
   143dc:	9b01      	ldr	r3, [sp, #4]
   143de:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   143e2:	2b00      	cmp	r3, #0
   143e4:	d100      	bne.n	143e8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   143e6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   143e8:	bf00      	nop
   143ea:	b003      	add	sp, #12
   143ec:	f85d fb04 	ldr.w	pc, [sp], #4
   143f0:	1fff96d4 	.word	0x1fff96d4
   143f4:	1fff96d0 	.word	0x1fff96d0

000143f8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10(void)
{
   143f8:	b500      	push	{lr}
   143fa:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   143fc:	f7ec fc8e 	bl	d1c <Sys_GetCoreID>
   14400:	4603      	mov	r3, r0
   14402:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_10[u32CoreId])
   14404:	4a10      	ldr	r2, [pc, #64]	; (14448 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x50>)
   14406:	9b01      	ldr	r3, [sp, #4]
   14408:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1440c:	2b00      	cmp	r3, #0
   1440e:	d10d      	bne.n	1442c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   14410:	f7ec facb 	bl	9aa <Can_43_FLEXCAN_schm_read_msr>
   14414:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   14416:	9b00      	ldr	r3, [sp, #0]
   14418:	f003 0301 	and.w	r3, r3, #1
   1441c:	2b00      	cmp	r3, #0
   1441e:	d100      	bne.n	14422 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   14420:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_10[u32CoreId] = msr;
   14422:	490a      	ldr	r1, [pc, #40]	; (1444c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x54>)
   14424:	9b01      	ldr	r3, [sp, #4]
   14426:	9a00      	ldr	r2, [sp, #0]
   14428:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_10[u32CoreId]++;
   1442c:	4a06      	ldr	r2, [pc, #24]	; (14448 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x50>)
   1442e:	9b01      	ldr	r3, [sp, #4]
   14430:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14434:	1c5a      	adds	r2, r3, #1
   14436:	4904      	ldr	r1, [pc, #16]	; (14448 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x50>)
   14438:	9b01      	ldr	r3, [sp, #4]
   1443a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1443e:	bf00      	nop
   14440:	b003      	add	sp, #12
   14442:	f85d fb04 	ldr.w	pc, [sp], #4
   14446:	bf00      	nop
   14448:	1fff96dc 	.word	0x1fff96dc
   1444c:	1fff96d8 	.word	0x1fff96d8

00014450 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10(void)
{
   14450:	b500      	push	{lr}
   14452:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14454:	f7ec fc62 	bl	d1c <Sys_GetCoreID>
   14458:	4603      	mov	r3, r0
   1445a:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_10[u32CoreId]--;
   1445c:	4a0d      	ldr	r2, [pc, #52]	; (14494 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x44>)
   1445e:	9b01      	ldr	r3, [sp, #4]
   14460:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14464:	1e5a      	subs	r2, r3, #1
   14466:	490b      	ldr	r1, [pc, #44]	; (14494 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x44>)
   14468:	9b01      	ldr	r3, [sp, #4]
   1446a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_10[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_10[u32CoreId]))         /*if interrupts were enabled*/
   1446e:	4a0a      	ldr	r2, [pc, #40]	; (14498 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x48>)
   14470:	9b01      	ldr	r3, [sp, #4]
   14472:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14476:	f003 0301 	and.w	r3, r3, #1
   1447a:	2b00      	cmp	r3, #0
   1447c:	d106      	bne.n	1448c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x3c>
   1447e:	4a05      	ldr	r2, [pc, #20]	; (14494 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x44>)
   14480:	9b01      	ldr	r3, [sp, #4]
   14482:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14486:	2b00      	cmp	r3, #0
   14488:	d100      	bne.n	1448c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1448a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   1448c:	bf00      	nop
   1448e:	b003      	add	sp, #12
   14490:	f85d fb04 	ldr.w	pc, [sp], #4
   14494:	1fff96dc 	.word	0x1fff96dc
   14498:	1fff96d8 	.word	0x1fff96d8

0001449c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11(void)
{
   1449c:	b500      	push	{lr}
   1449e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   144a0:	f7ec fc3c 	bl	d1c <Sys_GetCoreID>
   144a4:	4603      	mov	r3, r0
   144a6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_11[u32CoreId])
   144a8:	4a10      	ldr	r2, [pc, #64]	; (144ec <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x50>)
   144aa:	9b01      	ldr	r3, [sp, #4]
   144ac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   144b0:	2b00      	cmp	r3, #0
   144b2:	d10d      	bne.n	144d0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   144b4:	f7ec fa79 	bl	9aa <Can_43_FLEXCAN_schm_read_msr>
   144b8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   144ba:	9b00      	ldr	r3, [sp, #0]
   144bc:	f003 0301 	and.w	r3, r3, #1
   144c0:	2b00      	cmp	r3, #0
   144c2:	d100      	bne.n	144c6 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   144c4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_11[u32CoreId] = msr;
   144c6:	490a      	ldr	r1, [pc, #40]	; (144f0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x54>)
   144c8:	9b01      	ldr	r3, [sp, #4]
   144ca:	9a00      	ldr	r2, [sp, #0]
   144cc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_11[u32CoreId]++;
   144d0:	4a06      	ldr	r2, [pc, #24]	; (144ec <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x50>)
   144d2:	9b01      	ldr	r3, [sp, #4]
   144d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   144d8:	1c5a      	adds	r2, r3, #1
   144da:	4904      	ldr	r1, [pc, #16]	; (144ec <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x50>)
   144dc:	9b01      	ldr	r3, [sp, #4]
   144de:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   144e2:	bf00      	nop
   144e4:	b003      	add	sp, #12
   144e6:	f85d fb04 	ldr.w	pc, [sp], #4
   144ea:	bf00      	nop
   144ec:	1fff96e4 	.word	0x1fff96e4
   144f0:	1fff96e0 	.word	0x1fff96e0

000144f4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11(void)
{
   144f4:	b500      	push	{lr}
   144f6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   144f8:	f7ec fc10 	bl	d1c <Sys_GetCoreID>
   144fc:	4603      	mov	r3, r0
   144fe:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_11[u32CoreId]--;
   14500:	4a0d      	ldr	r2, [pc, #52]	; (14538 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x44>)
   14502:	9b01      	ldr	r3, [sp, #4]
   14504:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14508:	1e5a      	subs	r2, r3, #1
   1450a:	490b      	ldr	r1, [pc, #44]	; (14538 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x44>)
   1450c:	9b01      	ldr	r3, [sp, #4]
   1450e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_11[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_11[u32CoreId]))         /*if interrupts were enabled*/
   14512:	4a0a      	ldr	r2, [pc, #40]	; (1453c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x48>)
   14514:	9b01      	ldr	r3, [sp, #4]
   14516:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1451a:	f003 0301 	and.w	r3, r3, #1
   1451e:	2b00      	cmp	r3, #0
   14520:	d106      	bne.n	14530 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x3c>
   14522:	4a05      	ldr	r2, [pc, #20]	; (14538 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x44>)
   14524:	9b01      	ldr	r3, [sp, #4]
   14526:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1452a:	2b00      	cmp	r3, #0
   1452c:	d100      	bne.n	14530 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1452e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   14530:	bf00      	nop
   14532:	b003      	add	sp, #12
   14534:	f85d fb04 	ldr.w	pc, [sp], #4
   14538:	1fff96e4 	.word	0x1fff96e4
   1453c:	1fff96e0 	.word	0x1fff96e0

00014540 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12(void)
{
   14540:	b500      	push	{lr}
   14542:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14544:	f7ec fbea 	bl	d1c <Sys_GetCoreID>
   14548:	4603      	mov	r3, r0
   1454a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_12[u32CoreId])
   1454c:	4a10      	ldr	r2, [pc, #64]	; (14590 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x50>)
   1454e:	9b01      	ldr	r3, [sp, #4]
   14550:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14554:	2b00      	cmp	r3, #0
   14556:	d10d      	bne.n	14574 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   14558:	f7ec fa27 	bl	9aa <Can_43_FLEXCAN_schm_read_msr>
   1455c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1455e:	9b00      	ldr	r3, [sp, #0]
   14560:	f003 0301 	and.w	r3, r3, #1
   14564:	2b00      	cmp	r3, #0
   14566:	d100      	bne.n	1456a <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   14568:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_12[u32CoreId] = msr;
   1456a:	490a      	ldr	r1, [pc, #40]	; (14594 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x54>)
   1456c:	9b01      	ldr	r3, [sp, #4]
   1456e:	9a00      	ldr	r2, [sp, #0]
   14570:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_12[u32CoreId]++;
   14574:	4a06      	ldr	r2, [pc, #24]	; (14590 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x50>)
   14576:	9b01      	ldr	r3, [sp, #4]
   14578:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1457c:	1c5a      	adds	r2, r3, #1
   1457e:	4904      	ldr	r1, [pc, #16]	; (14590 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x50>)
   14580:	9b01      	ldr	r3, [sp, #4]
   14582:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   14586:	bf00      	nop
   14588:	b003      	add	sp, #12
   1458a:	f85d fb04 	ldr.w	pc, [sp], #4
   1458e:	bf00      	nop
   14590:	1fff96ec 	.word	0x1fff96ec
   14594:	1fff96e8 	.word	0x1fff96e8

00014598 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12(void)
{
   14598:	b500      	push	{lr}
   1459a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1459c:	f7ec fbbe 	bl	d1c <Sys_GetCoreID>
   145a0:	4603      	mov	r3, r0
   145a2:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_12[u32CoreId]--;
   145a4:	4a0d      	ldr	r2, [pc, #52]	; (145dc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x44>)
   145a6:	9b01      	ldr	r3, [sp, #4]
   145a8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   145ac:	1e5a      	subs	r2, r3, #1
   145ae:	490b      	ldr	r1, [pc, #44]	; (145dc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x44>)
   145b0:	9b01      	ldr	r3, [sp, #4]
   145b2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_12[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_12[u32CoreId]))         /*if interrupts were enabled*/
   145b6:	4a0a      	ldr	r2, [pc, #40]	; (145e0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x48>)
   145b8:	9b01      	ldr	r3, [sp, #4]
   145ba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   145be:	f003 0301 	and.w	r3, r3, #1
   145c2:	2b00      	cmp	r3, #0
   145c4:	d106      	bne.n	145d4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x3c>
   145c6:	4a05      	ldr	r2, [pc, #20]	; (145dc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x44>)
   145c8:	9b01      	ldr	r3, [sp, #4]
   145ca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   145ce:	2b00      	cmp	r3, #0
   145d0:	d100      	bne.n	145d4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   145d2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   145d4:	bf00      	nop
   145d6:	b003      	add	sp, #12
   145d8:	f85d fb04 	ldr.w	pc, [sp], #4
   145dc:	1fff96ec 	.word	0x1fff96ec
   145e0:	1fff96e8 	.word	0x1fff96e8

000145e4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13(void)
{
   145e4:	b500      	push	{lr}
   145e6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   145e8:	f7ec fb98 	bl	d1c <Sys_GetCoreID>
   145ec:	4603      	mov	r3, r0
   145ee:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_13[u32CoreId])
   145f0:	4a10      	ldr	r2, [pc, #64]	; (14634 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x50>)
   145f2:	9b01      	ldr	r3, [sp, #4]
   145f4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   145f8:	2b00      	cmp	r3, #0
   145fa:	d10d      	bne.n	14618 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   145fc:	f7ec f9d5 	bl	9aa <Can_43_FLEXCAN_schm_read_msr>
   14600:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   14602:	9b00      	ldr	r3, [sp, #0]
   14604:	f003 0301 	and.w	r3, r3, #1
   14608:	2b00      	cmp	r3, #0
   1460a:	d100      	bne.n	1460e <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   1460c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_13[u32CoreId] = msr;
   1460e:	490a      	ldr	r1, [pc, #40]	; (14638 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x54>)
   14610:	9b01      	ldr	r3, [sp, #4]
   14612:	9a00      	ldr	r2, [sp, #0]
   14614:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_13[u32CoreId]++;
   14618:	4a06      	ldr	r2, [pc, #24]	; (14634 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x50>)
   1461a:	9b01      	ldr	r3, [sp, #4]
   1461c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14620:	1c5a      	adds	r2, r3, #1
   14622:	4904      	ldr	r1, [pc, #16]	; (14634 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x50>)
   14624:	9b01      	ldr	r3, [sp, #4]
   14626:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1462a:	bf00      	nop
   1462c:	b003      	add	sp, #12
   1462e:	f85d fb04 	ldr.w	pc, [sp], #4
   14632:	bf00      	nop
   14634:	1fff96f4 	.word	0x1fff96f4
   14638:	1fff96f0 	.word	0x1fff96f0

0001463c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13(void)
{
   1463c:	b500      	push	{lr}
   1463e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14640:	f7ec fb6c 	bl	d1c <Sys_GetCoreID>
   14644:	4603      	mov	r3, r0
   14646:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_13[u32CoreId]--;
   14648:	4a0d      	ldr	r2, [pc, #52]	; (14680 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x44>)
   1464a:	9b01      	ldr	r3, [sp, #4]
   1464c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14650:	1e5a      	subs	r2, r3, #1
   14652:	490b      	ldr	r1, [pc, #44]	; (14680 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x44>)
   14654:	9b01      	ldr	r3, [sp, #4]
   14656:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_13[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_13[u32CoreId]))         /*if interrupts were enabled*/
   1465a:	4a0a      	ldr	r2, [pc, #40]	; (14684 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x48>)
   1465c:	9b01      	ldr	r3, [sp, #4]
   1465e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14662:	f003 0301 	and.w	r3, r3, #1
   14666:	2b00      	cmp	r3, #0
   14668:	d106      	bne.n	14678 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x3c>
   1466a:	4a05      	ldr	r2, [pc, #20]	; (14680 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x44>)
   1466c:	9b01      	ldr	r3, [sp, #4]
   1466e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14672:	2b00      	cmp	r3, #0
   14674:	d100      	bne.n	14678 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   14676:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   14678:	bf00      	nop
   1467a:	b003      	add	sp, #12
   1467c:	f85d fb04 	ldr.w	pc, [sp], #4
   14680:	1fff96f4 	.word	0x1fff96f4
   14684:	1fff96f0 	.word	0x1fff96f0

00014688 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14(void)
{
   14688:	b500      	push	{lr}
   1468a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1468c:	f7ec fb46 	bl	d1c <Sys_GetCoreID>
   14690:	4603      	mov	r3, r0
   14692:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_14[u32CoreId])
   14694:	4a10      	ldr	r2, [pc, #64]	; (146d8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x50>)
   14696:	9b01      	ldr	r3, [sp, #4]
   14698:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1469c:	2b00      	cmp	r3, #0
   1469e:	d10d      	bne.n	146bc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   146a0:	f7ec f983 	bl	9aa <Can_43_FLEXCAN_schm_read_msr>
   146a4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   146a6:	9b00      	ldr	r3, [sp, #0]
   146a8:	f003 0301 	and.w	r3, r3, #1
   146ac:	2b00      	cmp	r3, #0
   146ae:	d100      	bne.n	146b2 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   146b0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_14[u32CoreId] = msr;
   146b2:	490a      	ldr	r1, [pc, #40]	; (146dc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x54>)
   146b4:	9b01      	ldr	r3, [sp, #4]
   146b6:	9a00      	ldr	r2, [sp, #0]
   146b8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_14[u32CoreId]++;
   146bc:	4a06      	ldr	r2, [pc, #24]	; (146d8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x50>)
   146be:	9b01      	ldr	r3, [sp, #4]
   146c0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   146c4:	1c5a      	adds	r2, r3, #1
   146c6:	4904      	ldr	r1, [pc, #16]	; (146d8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x50>)
   146c8:	9b01      	ldr	r3, [sp, #4]
   146ca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   146ce:	bf00      	nop
   146d0:	b003      	add	sp, #12
   146d2:	f85d fb04 	ldr.w	pc, [sp], #4
   146d6:	bf00      	nop
   146d8:	1fff96fc 	.word	0x1fff96fc
   146dc:	1fff96f8 	.word	0x1fff96f8

000146e0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14(void)
{
   146e0:	b500      	push	{lr}
   146e2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   146e4:	f7ec fb1a 	bl	d1c <Sys_GetCoreID>
   146e8:	4603      	mov	r3, r0
   146ea:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_14[u32CoreId]--;
   146ec:	4a0d      	ldr	r2, [pc, #52]	; (14724 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x44>)
   146ee:	9b01      	ldr	r3, [sp, #4]
   146f0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   146f4:	1e5a      	subs	r2, r3, #1
   146f6:	490b      	ldr	r1, [pc, #44]	; (14724 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x44>)
   146f8:	9b01      	ldr	r3, [sp, #4]
   146fa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_14[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_14[u32CoreId]))         /*if interrupts were enabled*/
   146fe:	4a0a      	ldr	r2, [pc, #40]	; (14728 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x48>)
   14700:	9b01      	ldr	r3, [sp, #4]
   14702:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14706:	f003 0301 	and.w	r3, r3, #1
   1470a:	2b00      	cmp	r3, #0
   1470c:	d106      	bne.n	1471c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x3c>
   1470e:	4a05      	ldr	r2, [pc, #20]	; (14724 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x44>)
   14710:	9b01      	ldr	r3, [sp, #4]
   14712:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14716:	2b00      	cmp	r3, #0
   14718:	d100      	bne.n	1471c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1471a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   1471c:	bf00      	nop
   1471e:	b003      	add	sp, #12
   14720:	f85d fb04 	ldr.w	pc, [sp], #4
   14724:	1fff96fc 	.word	0x1fff96fc
   14728:	1fff96f8 	.word	0x1fff96f8

0001472c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15(void)
{
   1472c:	b500      	push	{lr}
   1472e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14730:	f7ec faf4 	bl	d1c <Sys_GetCoreID>
   14734:	4603      	mov	r3, r0
   14736:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_15[u32CoreId])
   14738:	4a10      	ldr	r2, [pc, #64]	; (1477c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x50>)
   1473a:	9b01      	ldr	r3, [sp, #4]
   1473c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14740:	2b00      	cmp	r3, #0
   14742:	d10d      	bne.n	14760 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   14744:	f7ec f931 	bl	9aa <Can_43_FLEXCAN_schm_read_msr>
   14748:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1474a:	9b00      	ldr	r3, [sp, #0]
   1474c:	f003 0301 	and.w	r3, r3, #1
   14750:	2b00      	cmp	r3, #0
   14752:	d100      	bne.n	14756 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   14754:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_15[u32CoreId] = msr;
   14756:	490a      	ldr	r1, [pc, #40]	; (14780 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x54>)
   14758:	9b01      	ldr	r3, [sp, #4]
   1475a:	9a00      	ldr	r2, [sp, #0]
   1475c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_15[u32CoreId]++;
   14760:	4a06      	ldr	r2, [pc, #24]	; (1477c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x50>)
   14762:	9b01      	ldr	r3, [sp, #4]
   14764:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14768:	1c5a      	adds	r2, r3, #1
   1476a:	4904      	ldr	r1, [pc, #16]	; (1477c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x50>)
   1476c:	9b01      	ldr	r3, [sp, #4]
   1476e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   14772:	bf00      	nop
   14774:	b003      	add	sp, #12
   14776:	f85d fb04 	ldr.w	pc, [sp], #4
   1477a:	bf00      	nop
   1477c:	1fff9704 	.word	0x1fff9704
   14780:	1fff9700 	.word	0x1fff9700

00014784 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15(void)
{
   14784:	b500      	push	{lr}
   14786:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14788:	f7ec fac8 	bl	d1c <Sys_GetCoreID>
   1478c:	4603      	mov	r3, r0
   1478e:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_15[u32CoreId]--;
   14790:	4a0d      	ldr	r2, [pc, #52]	; (147c8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x44>)
   14792:	9b01      	ldr	r3, [sp, #4]
   14794:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14798:	1e5a      	subs	r2, r3, #1
   1479a:	490b      	ldr	r1, [pc, #44]	; (147c8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x44>)
   1479c:	9b01      	ldr	r3, [sp, #4]
   1479e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_15[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_15[u32CoreId]))         /*if interrupts were enabled*/
   147a2:	4a0a      	ldr	r2, [pc, #40]	; (147cc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x48>)
   147a4:	9b01      	ldr	r3, [sp, #4]
   147a6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   147aa:	f003 0301 	and.w	r3, r3, #1
   147ae:	2b00      	cmp	r3, #0
   147b0:	d106      	bne.n	147c0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x3c>
   147b2:	4a05      	ldr	r2, [pc, #20]	; (147c8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x44>)
   147b4:	9b01      	ldr	r3, [sp, #4]
   147b6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   147ba:	2b00      	cmp	r3, #0
   147bc:	d100      	bne.n	147c0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   147be:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   147c0:	bf00      	nop
   147c2:	b003      	add	sp, #12
   147c4:	f85d fb04 	ldr.w	pc, [sp], #4
   147c8:	1fff9704 	.word	0x1fff9704
   147cc:	1fff9700 	.word	0x1fff9700

000147d0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16(void)
{
   147d0:	b500      	push	{lr}
   147d2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   147d4:	f7ec faa2 	bl	d1c <Sys_GetCoreID>
   147d8:	4603      	mov	r3, r0
   147da:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_16[u32CoreId])
   147dc:	4a10      	ldr	r2, [pc, #64]	; (14820 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x50>)
   147de:	9b01      	ldr	r3, [sp, #4]
   147e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   147e4:	2b00      	cmp	r3, #0
   147e6:	d10d      	bne.n	14804 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   147e8:	f7ec f8df 	bl	9aa <Can_43_FLEXCAN_schm_read_msr>
   147ec:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   147ee:	9b00      	ldr	r3, [sp, #0]
   147f0:	f003 0301 	and.w	r3, r3, #1
   147f4:	2b00      	cmp	r3, #0
   147f6:	d100      	bne.n	147fa <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   147f8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_16[u32CoreId] = msr;
   147fa:	490a      	ldr	r1, [pc, #40]	; (14824 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x54>)
   147fc:	9b01      	ldr	r3, [sp, #4]
   147fe:	9a00      	ldr	r2, [sp, #0]
   14800:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_16[u32CoreId]++;
   14804:	4a06      	ldr	r2, [pc, #24]	; (14820 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x50>)
   14806:	9b01      	ldr	r3, [sp, #4]
   14808:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1480c:	1c5a      	adds	r2, r3, #1
   1480e:	4904      	ldr	r1, [pc, #16]	; (14820 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x50>)
   14810:	9b01      	ldr	r3, [sp, #4]
   14812:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   14816:	bf00      	nop
   14818:	b003      	add	sp, #12
   1481a:	f85d fb04 	ldr.w	pc, [sp], #4
   1481e:	bf00      	nop
   14820:	1fff970c 	.word	0x1fff970c
   14824:	1fff9708 	.word	0x1fff9708

00014828 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16(void)
{
   14828:	b500      	push	{lr}
   1482a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1482c:	f7ec fa76 	bl	d1c <Sys_GetCoreID>
   14830:	4603      	mov	r3, r0
   14832:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_16[u32CoreId]--;
   14834:	4a0d      	ldr	r2, [pc, #52]	; (1486c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x44>)
   14836:	9b01      	ldr	r3, [sp, #4]
   14838:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1483c:	1e5a      	subs	r2, r3, #1
   1483e:	490b      	ldr	r1, [pc, #44]	; (1486c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x44>)
   14840:	9b01      	ldr	r3, [sp, #4]
   14842:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_16[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_16[u32CoreId]))         /*if interrupts were enabled*/
   14846:	4a0a      	ldr	r2, [pc, #40]	; (14870 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x48>)
   14848:	9b01      	ldr	r3, [sp, #4]
   1484a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1484e:	f003 0301 	and.w	r3, r3, #1
   14852:	2b00      	cmp	r3, #0
   14854:	d106      	bne.n	14864 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x3c>
   14856:	4a05      	ldr	r2, [pc, #20]	; (1486c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x44>)
   14858:	9b01      	ldr	r3, [sp, #4]
   1485a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1485e:	2b00      	cmp	r3, #0
   14860:	d100      	bne.n	14864 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   14862:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   14864:	bf00      	nop
   14866:	b003      	add	sp, #12
   14868:	f85d fb04 	ldr.w	pc, [sp], #4
   1486c:	1fff970c 	.word	0x1fff970c
   14870:	1fff9708 	.word	0x1fff9708

00014874 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17(void)
{
   14874:	b500      	push	{lr}
   14876:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14878:	f7ec fa50 	bl	d1c <Sys_GetCoreID>
   1487c:	4603      	mov	r3, r0
   1487e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_17[u32CoreId])
   14880:	4a10      	ldr	r2, [pc, #64]	; (148c4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x50>)
   14882:	9b01      	ldr	r3, [sp, #4]
   14884:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14888:	2b00      	cmp	r3, #0
   1488a:	d10d      	bne.n	148a8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   1488c:	f7ec f88d 	bl	9aa <Can_43_FLEXCAN_schm_read_msr>
   14890:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   14892:	9b00      	ldr	r3, [sp, #0]
   14894:	f003 0301 	and.w	r3, r3, #1
   14898:	2b00      	cmp	r3, #0
   1489a:	d100      	bne.n	1489e <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   1489c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_17[u32CoreId] = msr;
   1489e:	490a      	ldr	r1, [pc, #40]	; (148c8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x54>)
   148a0:	9b01      	ldr	r3, [sp, #4]
   148a2:	9a00      	ldr	r2, [sp, #0]
   148a4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_17[u32CoreId]++;
   148a8:	4a06      	ldr	r2, [pc, #24]	; (148c4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x50>)
   148aa:	9b01      	ldr	r3, [sp, #4]
   148ac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   148b0:	1c5a      	adds	r2, r3, #1
   148b2:	4904      	ldr	r1, [pc, #16]	; (148c4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x50>)
   148b4:	9b01      	ldr	r3, [sp, #4]
   148b6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   148ba:	bf00      	nop
   148bc:	b003      	add	sp, #12
   148be:	f85d fb04 	ldr.w	pc, [sp], #4
   148c2:	bf00      	nop
   148c4:	1fff9714 	.word	0x1fff9714
   148c8:	1fff9710 	.word	0x1fff9710

000148cc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17(void)
{
   148cc:	b500      	push	{lr}
   148ce:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   148d0:	f7ec fa24 	bl	d1c <Sys_GetCoreID>
   148d4:	4603      	mov	r3, r0
   148d6:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_17[u32CoreId]--;
   148d8:	4a0d      	ldr	r2, [pc, #52]	; (14910 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x44>)
   148da:	9b01      	ldr	r3, [sp, #4]
   148dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   148e0:	1e5a      	subs	r2, r3, #1
   148e2:	490b      	ldr	r1, [pc, #44]	; (14910 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x44>)
   148e4:	9b01      	ldr	r3, [sp, #4]
   148e6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_17[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_17[u32CoreId]))         /*if interrupts were enabled*/
   148ea:	4a0a      	ldr	r2, [pc, #40]	; (14914 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x48>)
   148ec:	9b01      	ldr	r3, [sp, #4]
   148ee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   148f2:	f003 0301 	and.w	r3, r3, #1
   148f6:	2b00      	cmp	r3, #0
   148f8:	d106      	bne.n	14908 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x3c>
   148fa:	4a05      	ldr	r2, [pc, #20]	; (14910 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x44>)
   148fc:	9b01      	ldr	r3, [sp, #4]
   148fe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14902:	2b00      	cmp	r3, #0
   14904:	d100      	bne.n	14908 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   14906:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   14908:	bf00      	nop
   1490a:	b003      	add	sp, #12
   1490c:	f85d fb04 	ldr.w	pc, [sp], #4
   14910:	1fff9714 	.word	0x1fff9714
   14914:	1fff9710 	.word	0x1fff9710

00014918 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18(void)
{
   14918:	b500      	push	{lr}
   1491a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1491c:	f7ec f9fe 	bl	d1c <Sys_GetCoreID>
   14920:	4603      	mov	r3, r0
   14922:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_18[u32CoreId])
   14924:	4a10      	ldr	r2, [pc, #64]	; (14968 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x50>)
   14926:	9b01      	ldr	r3, [sp, #4]
   14928:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1492c:	2b00      	cmp	r3, #0
   1492e:	d10d      	bne.n	1494c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   14930:	f7ec f83b 	bl	9aa <Can_43_FLEXCAN_schm_read_msr>
   14934:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   14936:	9b00      	ldr	r3, [sp, #0]
   14938:	f003 0301 	and.w	r3, r3, #1
   1493c:	2b00      	cmp	r3, #0
   1493e:	d100      	bne.n	14942 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   14940:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_18[u32CoreId] = msr;
   14942:	490a      	ldr	r1, [pc, #40]	; (1496c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x54>)
   14944:	9b01      	ldr	r3, [sp, #4]
   14946:	9a00      	ldr	r2, [sp, #0]
   14948:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_18[u32CoreId]++;
   1494c:	4a06      	ldr	r2, [pc, #24]	; (14968 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x50>)
   1494e:	9b01      	ldr	r3, [sp, #4]
   14950:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14954:	1c5a      	adds	r2, r3, #1
   14956:	4904      	ldr	r1, [pc, #16]	; (14968 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x50>)
   14958:	9b01      	ldr	r3, [sp, #4]
   1495a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1495e:	bf00      	nop
   14960:	b003      	add	sp, #12
   14962:	f85d fb04 	ldr.w	pc, [sp], #4
   14966:	bf00      	nop
   14968:	1fff971c 	.word	0x1fff971c
   1496c:	1fff9718 	.word	0x1fff9718

00014970 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18(void)
{
   14970:	b500      	push	{lr}
   14972:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14974:	f7ec f9d2 	bl	d1c <Sys_GetCoreID>
   14978:	4603      	mov	r3, r0
   1497a:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_18[u32CoreId]--;
   1497c:	4a0d      	ldr	r2, [pc, #52]	; (149b4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x44>)
   1497e:	9b01      	ldr	r3, [sp, #4]
   14980:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14984:	1e5a      	subs	r2, r3, #1
   14986:	490b      	ldr	r1, [pc, #44]	; (149b4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x44>)
   14988:	9b01      	ldr	r3, [sp, #4]
   1498a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_18[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_18[u32CoreId]))         /*if interrupts were enabled*/
   1498e:	4a0a      	ldr	r2, [pc, #40]	; (149b8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x48>)
   14990:	9b01      	ldr	r3, [sp, #4]
   14992:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14996:	f003 0301 	and.w	r3, r3, #1
   1499a:	2b00      	cmp	r3, #0
   1499c:	d106      	bne.n	149ac <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x3c>
   1499e:	4a05      	ldr	r2, [pc, #20]	; (149b4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x44>)
   149a0:	9b01      	ldr	r3, [sp, #4]
   149a2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   149a6:	2b00      	cmp	r3, #0
   149a8:	d100      	bne.n	149ac <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   149aa:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   149ac:	bf00      	nop
   149ae:	b003      	add	sp, #12
   149b0:	f85d fb04 	ldr.w	pc, [sp], #4
   149b4:	1fff971c 	.word	0x1fff971c
   149b8:	1fff9718 	.word	0x1fff9718

000149bc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19(void)
{
   149bc:	b500      	push	{lr}
   149be:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   149c0:	f7ec f9ac 	bl	d1c <Sys_GetCoreID>
   149c4:	4603      	mov	r3, r0
   149c6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_19[u32CoreId])
   149c8:	4a10      	ldr	r2, [pc, #64]	; (14a0c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x50>)
   149ca:	9b01      	ldr	r3, [sp, #4]
   149cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   149d0:	2b00      	cmp	r3, #0
   149d2:	d10d      	bne.n	149f0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   149d4:	f7eb ffe9 	bl	9aa <Can_43_FLEXCAN_schm_read_msr>
   149d8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   149da:	9b00      	ldr	r3, [sp, #0]
   149dc:	f003 0301 	and.w	r3, r3, #1
   149e0:	2b00      	cmp	r3, #0
   149e2:	d100      	bne.n	149e6 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   149e4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_19[u32CoreId] = msr;
   149e6:	490a      	ldr	r1, [pc, #40]	; (14a10 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x54>)
   149e8:	9b01      	ldr	r3, [sp, #4]
   149ea:	9a00      	ldr	r2, [sp, #0]
   149ec:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_19[u32CoreId]++;
   149f0:	4a06      	ldr	r2, [pc, #24]	; (14a0c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x50>)
   149f2:	9b01      	ldr	r3, [sp, #4]
   149f4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   149f8:	1c5a      	adds	r2, r3, #1
   149fa:	4904      	ldr	r1, [pc, #16]	; (14a0c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x50>)
   149fc:	9b01      	ldr	r3, [sp, #4]
   149fe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   14a02:	bf00      	nop
   14a04:	b003      	add	sp, #12
   14a06:	f85d fb04 	ldr.w	pc, [sp], #4
   14a0a:	bf00      	nop
   14a0c:	1fff9724 	.word	0x1fff9724
   14a10:	1fff9720 	.word	0x1fff9720

00014a14 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19(void)
{
   14a14:	b500      	push	{lr}
   14a16:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14a18:	f7ec f980 	bl	d1c <Sys_GetCoreID>
   14a1c:	4603      	mov	r3, r0
   14a1e:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_19[u32CoreId]--;
   14a20:	4a0d      	ldr	r2, [pc, #52]	; (14a58 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x44>)
   14a22:	9b01      	ldr	r3, [sp, #4]
   14a24:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14a28:	1e5a      	subs	r2, r3, #1
   14a2a:	490b      	ldr	r1, [pc, #44]	; (14a58 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x44>)
   14a2c:	9b01      	ldr	r3, [sp, #4]
   14a2e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_19[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_19[u32CoreId]))         /*if interrupts were enabled*/
   14a32:	4a0a      	ldr	r2, [pc, #40]	; (14a5c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x48>)
   14a34:	9b01      	ldr	r3, [sp, #4]
   14a36:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14a3a:	f003 0301 	and.w	r3, r3, #1
   14a3e:	2b00      	cmp	r3, #0
   14a40:	d106      	bne.n	14a50 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x3c>
   14a42:	4a05      	ldr	r2, [pc, #20]	; (14a58 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x44>)
   14a44:	9b01      	ldr	r3, [sp, #4]
   14a46:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14a4a:	2b00      	cmp	r3, #0
   14a4c:	d100      	bne.n	14a50 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   14a4e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   14a50:	bf00      	nop
   14a52:	b003      	add	sp, #12
   14a54:	f85d fb04 	ldr.w	pc, [sp], #4
   14a58:	1fff9724 	.word	0x1fff9724
   14a5c:	1fff9720 	.word	0x1fff9720

00014a60 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20(void)
{
   14a60:	b500      	push	{lr}
   14a62:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14a64:	f7ec f95a 	bl	d1c <Sys_GetCoreID>
   14a68:	4603      	mov	r3, r0
   14a6a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_20[u32CoreId])
   14a6c:	4a10      	ldr	r2, [pc, #64]	; (14ab0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x50>)
   14a6e:	9b01      	ldr	r3, [sp, #4]
   14a70:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14a74:	2b00      	cmp	r3, #0
   14a76:	d10d      	bne.n	14a94 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   14a78:	f7eb ff97 	bl	9aa <Can_43_FLEXCAN_schm_read_msr>
   14a7c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   14a7e:	9b00      	ldr	r3, [sp, #0]
   14a80:	f003 0301 	and.w	r3, r3, #1
   14a84:	2b00      	cmp	r3, #0
   14a86:	d100      	bne.n	14a8a <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   14a88:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_20[u32CoreId] = msr;
   14a8a:	490a      	ldr	r1, [pc, #40]	; (14ab4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x54>)
   14a8c:	9b01      	ldr	r3, [sp, #4]
   14a8e:	9a00      	ldr	r2, [sp, #0]
   14a90:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_20[u32CoreId]++;
   14a94:	4a06      	ldr	r2, [pc, #24]	; (14ab0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x50>)
   14a96:	9b01      	ldr	r3, [sp, #4]
   14a98:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14a9c:	1c5a      	adds	r2, r3, #1
   14a9e:	4904      	ldr	r1, [pc, #16]	; (14ab0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x50>)
   14aa0:	9b01      	ldr	r3, [sp, #4]
   14aa2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   14aa6:	bf00      	nop
   14aa8:	b003      	add	sp, #12
   14aaa:	f85d fb04 	ldr.w	pc, [sp], #4
   14aae:	bf00      	nop
   14ab0:	1fff972c 	.word	0x1fff972c
   14ab4:	1fff9728 	.word	0x1fff9728

00014ab8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20(void)
{
   14ab8:	b500      	push	{lr}
   14aba:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14abc:	f7ec f92e 	bl	d1c <Sys_GetCoreID>
   14ac0:	4603      	mov	r3, r0
   14ac2:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_20[u32CoreId]--;
   14ac4:	4a0d      	ldr	r2, [pc, #52]	; (14afc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x44>)
   14ac6:	9b01      	ldr	r3, [sp, #4]
   14ac8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14acc:	1e5a      	subs	r2, r3, #1
   14ace:	490b      	ldr	r1, [pc, #44]	; (14afc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x44>)
   14ad0:	9b01      	ldr	r3, [sp, #4]
   14ad2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_20[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_20[u32CoreId]))         /*if interrupts were enabled*/
   14ad6:	4a0a      	ldr	r2, [pc, #40]	; (14b00 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x48>)
   14ad8:	9b01      	ldr	r3, [sp, #4]
   14ada:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14ade:	f003 0301 	and.w	r3, r3, #1
   14ae2:	2b00      	cmp	r3, #0
   14ae4:	d106      	bne.n	14af4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x3c>
   14ae6:	4a05      	ldr	r2, [pc, #20]	; (14afc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x44>)
   14ae8:	9b01      	ldr	r3, [sp, #4]
   14aea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14aee:	2b00      	cmp	r3, #0
   14af0:	d100      	bne.n	14af4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   14af2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   14af4:	bf00      	nop
   14af6:	b003      	add	sp, #12
   14af8:	f85d fb04 	ldr.w	pc, [sp], #4
   14afc:	1fff972c 	.word	0x1fff972c
   14b00:	1fff9728 	.word	0x1fff9728

00014b04 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00(void)
{
   14b04:	b500      	push	{lr}
   14b06:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14b08:	f7ec f908 	bl	d1c <Sys_GetCoreID>
   14b0c:	4603      	mov	r3, r0
   14b0e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId])
   14b10:	4a10      	ldr	r2, [pc, #64]	; (14b54 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x50>)
   14b12:	9b01      	ldr	r3, [sp, #4]
   14b14:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14b18:	2b00      	cmp	r3, #0
   14b1a:	d10d      	bne.n	14b38 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Mcu_schm_read_msr);
#else
        msr = Mcu_schm_read_msr();  /*read MSR (to store interrupts state)*/
   14b1c:	f7eb ff4e 	bl	9bc <Mcu_schm_read_msr>
   14b20:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   14b22:	9b00      	ldr	r3, [sp, #0]
   14b24:	f003 0301 	and.w	r3, r3, #1
   14b28:	2b00      	cmp	r3, #0
   14b2a:	d100      	bne.n	14b2e <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   14b2c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_MCU_EXCLUSIVE_AREA_00[u32CoreId] = msr;
   14b2e:	490a      	ldr	r1, [pc, #40]	; (14b58 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x54>)
   14b30:	9b01      	ldr	r3, [sp, #4]
   14b32:	9a00      	ldr	r2, [sp, #0]
   14b34:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId]++;
   14b38:	4a06      	ldr	r2, [pc, #24]	; (14b54 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x50>)
   14b3a:	9b01      	ldr	r3, [sp, #4]
   14b3c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14b40:	1c5a      	adds	r2, r3, #1
   14b42:	4904      	ldr	r1, [pc, #16]	; (14b54 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x50>)
   14b44:	9b01      	ldr	r3, [sp, #4]
   14b46:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   14b4a:	bf00      	nop
   14b4c:	b003      	add	sp, #12
   14b4e:	f85d fb04 	ldr.w	pc, [sp], #4
   14b52:	bf00      	nop
   14b54:	1fff9734 	.word	0x1fff9734
   14b58:	1fff9730 	.word	0x1fff9730

00014b5c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00>:

void SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00(void)
{
   14b5c:	b500      	push	{lr}
   14b5e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14b60:	f7ec f8dc 	bl	d1c <Sys_GetCoreID>
   14b64:	4603      	mov	r3, r0
   14b66:	9301      	str	r3, [sp, #4]

    reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId]--;
   14b68:	4a0d      	ldr	r2, [pc, #52]	; (14ba0 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x44>)
   14b6a:	9b01      	ldr	r3, [sp, #4]
   14b6c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14b70:	1e5a      	subs	r2, r3, #1
   14b72:	490b      	ldr	r1, [pc, #44]	; (14ba0 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x44>)
   14b74:	9b01      	ldr	r3, [sp, #4]
   14b76:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_MCU_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
   14b7a:	4a0a      	ldr	r2, [pc, #40]	; (14ba4 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x48>)
   14b7c:	9b01      	ldr	r3, [sp, #4]
   14b7e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14b82:	f003 0301 	and.w	r3, r3, #1
   14b86:	2b00      	cmp	r3, #0
   14b88:	d106      	bne.n	14b98 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x3c>
   14b8a:	4a05      	ldr	r2, [pc, #20]	; (14ba0 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x44>)
   14b8c:	9b01      	ldr	r3, [sp, #4]
   14b8e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14b92:	2b00      	cmp	r3, #0
   14b94:	d100      	bne.n	14b98 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   14b96:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   14b98:	bf00      	nop
   14b9a:	b003      	add	sp, #12
   14b9c:	f85d fb04 	ldr.w	pc, [sp], #4
   14ba0:	1fff9734 	.word	0x1fff9734
   14ba4:	1fff9730 	.word	0x1fff9730

00014ba8 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01>:

void SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01(void)
{
   14ba8:	b500      	push	{lr}
   14baa:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14bac:	f7ec f8b6 	bl	d1c <Sys_GetCoreID>
   14bb0:	4603      	mov	r3, r0
   14bb2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId])
   14bb4:	4a10      	ldr	r2, [pc, #64]	; (14bf8 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x50>)
   14bb6:	9b01      	ldr	r3, [sp, #4]
   14bb8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14bbc:	2b00      	cmp	r3, #0
   14bbe:	d10d      	bne.n	14bdc <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Mcu_schm_read_msr);
#else
        msr = Mcu_schm_read_msr();  /*read MSR (to store interrupts state)*/
   14bc0:	f7eb fefc 	bl	9bc <Mcu_schm_read_msr>
   14bc4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   14bc6:	9b00      	ldr	r3, [sp, #0]
   14bc8:	f003 0301 	and.w	r3, r3, #1
   14bcc:	2b00      	cmp	r3, #0
   14bce:	d100      	bne.n	14bd2 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   14bd0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_MCU_EXCLUSIVE_AREA_01[u32CoreId] = msr;
   14bd2:	490a      	ldr	r1, [pc, #40]	; (14bfc <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x54>)
   14bd4:	9b01      	ldr	r3, [sp, #4]
   14bd6:	9a00      	ldr	r2, [sp, #0]
   14bd8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId]++;
   14bdc:	4a06      	ldr	r2, [pc, #24]	; (14bf8 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x50>)
   14bde:	9b01      	ldr	r3, [sp, #4]
   14be0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14be4:	1c5a      	adds	r2, r3, #1
   14be6:	4904      	ldr	r1, [pc, #16]	; (14bf8 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x50>)
   14be8:	9b01      	ldr	r3, [sp, #4]
   14bea:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   14bee:	bf00      	nop
   14bf0:	b003      	add	sp, #12
   14bf2:	f85d fb04 	ldr.w	pc, [sp], #4
   14bf6:	bf00      	nop
   14bf8:	1fff973c 	.word	0x1fff973c
   14bfc:	1fff9738 	.word	0x1fff9738

00014c00 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01>:

void SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01(void)
{
   14c00:	b500      	push	{lr}
   14c02:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14c04:	f7ec f88a 	bl	d1c <Sys_GetCoreID>
   14c08:	4603      	mov	r3, r0
   14c0a:	9301      	str	r3, [sp, #4]

    reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId]--;
   14c0c:	4a0d      	ldr	r2, [pc, #52]	; (14c44 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x44>)
   14c0e:	9b01      	ldr	r3, [sp, #4]
   14c10:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14c14:	1e5a      	subs	r2, r3, #1
   14c16:	490b      	ldr	r1, [pc, #44]	; (14c44 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x44>)
   14c18:	9b01      	ldr	r3, [sp, #4]
   14c1a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_MCU_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
   14c1e:	4a0a      	ldr	r2, [pc, #40]	; (14c48 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x48>)
   14c20:	9b01      	ldr	r3, [sp, #4]
   14c22:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14c26:	f003 0301 	and.w	r3, r3, #1
   14c2a:	2b00      	cmp	r3, #0
   14c2c:	d106      	bne.n	14c3c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x3c>
   14c2e:	4a05      	ldr	r2, [pc, #20]	; (14c44 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x44>)
   14c30:	9b01      	ldr	r3, [sp, #4]
   14c32:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14c36:	2b00      	cmp	r3, #0
   14c38:	d100      	bne.n	14c3c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   14c3a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   14c3c:	bf00      	nop
   14c3e:	b003      	add	sp, #12
   14c40:	f85d fb04 	ldr.w	pc, [sp], #4
   14c44:	1fff973c 	.word	0x1fff973c
   14c48:	1fff9738 	.word	0x1fff9738

00014c4c <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02>:

void SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02(void)
{
   14c4c:	b500      	push	{lr}
   14c4e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14c50:	f7ec f864 	bl	d1c <Sys_GetCoreID>
   14c54:	4603      	mov	r3, r0
   14c56:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId])
   14c58:	4a10      	ldr	r2, [pc, #64]	; (14c9c <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x50>)
   14c5a:	9b01      	ldr	r3, [sp, #4]
   14c5c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14c60:	2b00      	cmp	r3, #0
   14c62:	d10d      	bne.n	14c80 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Mcu_schm_read_msr);
#else
        msr = Mcu_schm_read_msr();  /*read MSR (to store interrupts state)*/
   14c64:	f7eb feaa 	bl	9bc <Mcu_schm_read_msr>
   14c68:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   14c6a:	9b00      	ldr	r3, [sp, #0]
   14c6c:	f003 0301 	and.w	r3, r3, #1
   14c70:	2b00      	cmp	r3, #0
   14c72:	d100      	bne.n	14c76 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   14c74:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_MCU_EXCLUSIVE_AREA_02[u32CoreId] = msr;
   14c76:	490a      	ldr	r1, [pc, #40]	; (14ca0 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x54>)
   14c78:	9b01      	ldr	r3, [sp, #4]
   14c7a:	9a00      	ldr	r2, [sp, #0]
   14c7c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId]++;
   14c80:	4a06      	ldr	r2, [pc, #24]	; (14c9c <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x50>)
   14c82:	9b01      	ldr	r3, [sp, #4]
   14c84:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14c88:	1c5a      	adds	r2, r3, #1
   14c8a:	4904      	ldr	r1, [pc, #16]	; (14c9c <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x50>)
   14c8c:	9b01      	ldr	r3, [sp, #4]
   14c8e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   14c92:	bf00      	nop
   14c94:	b003      	add	sp, #12
   14c96:	f85d fb04 	ldr.w	pc, [sp], #4
   14c9a:	bf00      	nop
   14c9c:	1fff9744 	.word	0x1fff9744
   14ca0:	1fff9740 	.word	0x1fff9740

00014ca4 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02>:

void SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02(void)
{
   14ca4:	b500      	push	{lr}
   14ca6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14ca8:	f7ec f838 	bl	d1c <Sys_GetCoreID>
   14cac:	4603      	mov	r3, r0
   14cae:	9301      	str	r3, [sp, #4]

    reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId]--;
   14cb0:	4a0d      	ldr	r2, [pc, #52]	; (14ce8 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x44>)
   14cb2:	9b01      	ldr	r3, [sp, #4]
   14cb4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14cb8:	1e5a      	subs	r2, r3, #1
   14cba:	490b      	ldr	r1, [pc, #44]	; (14ce8 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x44>)
   14cbc:	9b01      	ldr	r3, [sp, #4]
   14cbe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_MCU_EXCLUSIVE_AREA_02[u32CoreId]))&&(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId]))         /*if interrupts were enabled*/
   14cc2:	4a0a      	ldr	r2, [pc, #40]	; (14cec <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x48>)
   14cc4:	9b01      	ldr	r3, [sp, #4]
   14cc6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14cca:	f003 0301 	and.w	r3, r3, #1
   14cce:	2b00      	cmp	r3, #0
   14cd0:	d106      	bne.n	14ce0 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x3c>
   14cd2:	4a05      	ldr	r2, [pc, #20]	; (14ce8 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x44>)
   14cd4:	9b01      	ldr	r3, [sp, #4]
   14cd6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14cda:	2b00      	cmp	r3, #0
   14cdc:	d100      	bne.n	14ce0 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   14cde:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   14ce0:	bf00      	nop
   14ce2:	b003      	add	sp, #12
   14ce4:	f85d fb04 	ldr.w	pc, [sp], #4
   14ce8:	1fff9744 	.word	0x1fff9744
   14cec:	1fff9740 	.word	0x1fff9740

00014cf0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00(void)
{
   14cf0:	b500      	push	{lr}
   14cf2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14cf4:	f7ec f812 	bl	d1c <Sys_GetCoreID>
   14cf8:	4603      	mov	r3, r0
   14cfa:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId])
   14cfc:	4a10      	ldr	r2, [pc, #64]	; (14d40 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x50>)
   14cfe:	9b01      	ldr	r3, [sp, #4]
   14d00:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14d04:	2b00      	cmp	r3, #0
   14d06:	d10d      	bne.n	14d24 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   14d08:	f7eb fe61 	bl	9ce <Port_schm_read_msr>
   14d0c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   14d0e:	9b00      	ldr	r3, [sp, #0]
   14d10:	f003 0301 	and.w	r3, r3, #1
   14d14:	2b00      	cmp	r3, #0
   14d16:	d100      	bne.n	14d1a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   14d18:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_00[u32CoreId] = msr;
   14d1a:	490a      	ldr	r1, [pc, #40]	; (14d44 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x54>)
   14d1c:	9b01      	ldr	r3, [sp, #4]
   14d1e:	9a00      	ldr	r2, [sp, #0]
   14d20:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId]++;
   14d24:	4a06      	ldr	r2, [pc, #24]	; (14d40 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x50>)
   14d26:	9b01      	ldr	r3, [sp, #4]
   14d28:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14d2c:	1c5a      	adds	r2, r3, #1
   14d2e:	4904      	ldr	r1, [pc, #16]	; (14d40 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x50>)
   14d30:	9b01      	ldr	r3, [sp, #4]
   14d32:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   14d36:	bf00      	nop
   14d38:	b003      	add	sp, #12
   14d3a:	f85d fb04 	ldr.w	pc, [sp], #4
   14d3e:	bf00      	nop
   14d40:	1fff974c 	.word	0x1fff974c
   14d44:	1fff9748 	.word	0x1fff9748

00014d48 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00(void)
{
   14d48:	b500      	push	{lr}
   14d4a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14d4c:	f7eb ffe6 	bl	d1c <Sys_GetCoreID>
   14d50:	4603      	mov	r3, r0
   14d52:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId]--;
   14d54:	4a0d      	ldr	r2, [pc, #52]	; (14d8c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x44>)
   14d56:	9b01      	ldr	r3, [sp, #4]
   14d58:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14d5c:	1e5a      	subs	r2, r3, #1
   14d5e:	490b      	ldr	r1, [pc, #44]	; (14d8c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x44>)
   14d60:	9b01      	ldr	r3, [sp, #4]
   14d62:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
   14d66:	4a0a      	ldr	r2, [pc, #40]	; (14d90 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x48>)
   14d68:	9b01      	ldr	r3, [sp, #4]
   14d6a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14d6e:	f003 0301 	and.w	r3, r3, #1
   14d72:	2b00      	cmp	r3, #0
   14d74:	d106      	bne.n	14d84 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x3c>
   14d76:	4a05      	ldr	r2, [pc, #20]	; (14d8c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x44>)
   14d78:	9b01      	ldr	r3, [sp, #4]
   14d7a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14d7e:	2b00      	cmp	r3, #0
   14d80:	d100      	bne.n	14d84 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   14d82:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   14d84:	bf00      	nop
   14d86:	b003      	add	sp, #12
   14d88:	f85d fb04 	ldr.w	pc, [sp], #4
   14d8c:	1fff974c 	.word	0x1fff974c
   14d90:	1fff9748 	.word	0x1fff9748

00014d94 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01(void)
{
   14d94:	b500      	push	{lr}
   14d96:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14d98:	f7eb ffc0 	bl	d1c <Sys_GetCoreID>
   14d9c:	4603      	mov	r3, r0
   14d9e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId])
   14da0:	4a10      	ldr	r2, [pc, #64]	; (14de4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x50>)
   14da2:	9b01      	ldr	r3, [sp, #4]
   14da4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14da8:	2b00      	cmp	r3, #0
   14daa:	d10d      	bne.n	14dc8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   14dac:	f7eb fe0f 	bl	9ce <Port_schm_read_msr>
   14db0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   14db2:	9b00      	ldr	r3, [sp, #0]
   14db4:	f003 0301 	and.w	r3, r3, #1
   14db8:	2b00      	cmp	r3, #0
   14dba:	d100      	bne.n	14dbe <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   14dbc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_01[u32CoreId] = msr;
   14dbe:	490a      	ldr	r1, [pc, #40]	; (14de8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x54>)
   14dc0:	9b01      	ldr	r3, [sp, #4]
   14dc2:	9a00      	ldr	r2, [sp, #0]
   14dc4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId]++;
   14dc8:	4a06      	ldr	r2, [pc, #24]	; (14de4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x50>)
   14dca:	9b01      	ldr	r3, [sp, #4]
   14dcc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14dd0:	1c5a      	adds	r2, r3, #1
   14dd2:	4904      	ldr	r1, [pc, #16]	; (14de4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x50>)
   14dd4:	9b01      	ldr	r3, [sp, #4]
   14dd6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   14dda:	bf00      	nop
   14ddc:	b003      	add	sp, #12
   14dde:	f85d fb04 	ldr.w	pc, [sp], #4
   14de2:	bf00      	nop
   14de4:	1fff9754 	.word	0x1fff9754
   14de8:	1fff9750 	.word	0x1fff9750

00014dec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01(void)
{
   14dec:	b500      	push	{lr}
   14dee:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14df0:	f7eb ff94 	bl	d1c <Sys_GetCoreID>
   14df4:	4603      	mov	r3, r0
   14df6:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId]--;
   14df8:	4a0d      	ldr	r2, [pc, #52]	; (14e30 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x44>)
   14dfa:	9b01      	ldr	r3, [sp, #4]
   14dfc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14e00:	1e5a      	subs	r2, r3, #1
   14e02:	490b      	ldr	r1, [pc, #44]	; (14e30 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x44>)
   14e04:	9b01      	ldr	r3, [sp, #4]
   14e06:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
   14e0a:	4a0a      	ldr	r2, [pc, #40]	; (14e34 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x48>)
   14e0c:	9b01      	ldr	r3, [sp, #4]
   14e0e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14e12:	f003 0301 	and.w	r3, r3, #1
   14e16:	2b00      	cmp	r3, #0
   14e18:	d106      	bne.n	14e28 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x3c>
   14e1a:	4a05      	ldr	r2, [pc, #20]	; (14e30 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x44>)
   14e1c:	9b01      	ldr	r3, [sp, #4]
   14e1e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14e22:	2b00      	cmp	r3, #0
   14e24:	d100      	bne.n	14e28 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   14e26:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   14e28:	bf00      	nop
   14e2a:	b003      	add	sp, #12
   14e2c:	f85d fb04 	ldr.w	pc, [sp], #4
   14e30:	1fff9754 	.word	0x1fff9754
   14e34:	1fff9750 	.word	0x1fff9750

00014e38 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02(void)
{
   14e38:	b500      	push	{lr}
   14e3a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14e3c:	f7eb ff6e 	bl	d1c <Sys_GetCoreID>
   14e40:	4603      	mov	r3, r0
   14e42:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId])
   14e44:	4a10      	ldr	r2, [pc, #64]	; (14e88 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x50>)
   14e46:	9b01      	ldr	r3, [sp, #4]
   14e48:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14e4c:	2b00      	cmp	r3, #0
   14e4e:	d10d      	bne.n	14e6c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   14e50:	f7eb fdbd 	bl	9ce <Port_schm_read_msr>
   14e54:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   14e56:	9b00      	ldr	r3, [sp, #0]
   14e58:	f003 0301 	and.w	r3, r3, #1
   14e5c:	2b00      	cmp	r3, #0
   14e5e:	d100      	bne.n	14e62 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   14e60:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_02[u32CoreId] = msr;
   14e62:	490a      	ldr	r1, [pc, #40]	; (14e8c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x54>)
   14e64:	9b01      	ldr	r3, [sp, #4]
   14e66:	9a00      	ldr	r2, [sp, #0]
   14e68:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId]++;
   14e6c:	4a06      	ldr	r2, [pc, #24]	; (14e88 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x50>)
   14e6e:	9b01      	ldr	r3, [sp, #4]
   14e70:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14e74:	1c5a      	adds	r2, r3, #1
   14e76:	4904      	ldr	r1, [pc, #16]	; (14e88 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x50>)
   14e78:	9b01      	ldr	r3, [sp, #4]
   14e7a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   14e7e:	bf00      	nop
   14e80:	b003      	add	sp, #12
   14e82:	f85d fb04 	ldr.w	pc, [sp], #4
   14e86:	bf00      	nop
   14e88:	1fff975c 	.word	0x1fff975c
   14e8c:	1fff9758 	.word	0x1fff9758

00014e90 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02(void)
{
   14e90:	b500      	push	{lr}
   14e92:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14e94:	f7eb ff42 	bl	d1c <Sys_GetCoreID>
   14e98:	4603      	mov	r3, r0
   14e9a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId]--;
   14e9c:	4a0d      	ldr	r2, [pc, #52]	; (14ed4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x44>)
   14e9e:	9b01      	ldr	r3, [sp, #4]
   14ea0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14ea4:	1e5a      	subs	r2, r3, #1
   14ea6:	490b      	ldr	r1, [pc, #44]	; (14ed4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x44>)
   14ea8:	9b01      	ldr	r3, [sp, #4]
   14eaa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_02[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId]))         /*if interrupts were enabled*/
   14eae:	4a0a      	ldr	r2, [pc, #40]	; (14ed8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x48>)
   14eb0:	9b01      	ldr	r3, [sp, #4]
   14eb2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14eb6:	f003 0301 	and.w	r3, r3, #1
   14eba:	2b00      	cmp	r3, #0
   14ebc:	d106      	bne.n	14ecc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x3c>
   14ebe:	4a05      	ldr	r2, [pc, #20]	; (14ed4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x44>)
   14ec0:	9b01      	ldr	r3, [sp, #4]
   14ec2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14ec6:	2b00      	cmp	r3, #0
   14ec8:	d100      	bne.n	14ecc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   14eca:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   14ecc:	bf00      	nop
   14ece:	b003      	add	sp, #12
   14ed0:	f85d fb04 	ldr.w	pc, [sp], #4
   14ed4:	1fff975c 	.word	0x1fff975c
   14ed8:	1fff9758 	.word	0x1fff9758

00014edc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03(void)
{
   14edc:	b500      	push	{lr}
   14ede:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14ee0:	f7eb ff1c 	bl	d1c <Sys_GetCoreID>
   14ee4:	4603      	mov	r3, r0
   14ee6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId])
   14ee8:	4a10      	ldr	r2, [pc, #64]	; (14f2c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x50>)
   14eea:	9b01      	ldr	r3, [sp, #4]
   14eec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14ef0:	2b00      	cmp	r3, #0
   14ef2:	d10d      	bne.n	14f10 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   14ef4:	f7eb fd6b 	bl	9ce <Port_schm_read_msr>
   14ef8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   14efa:	9b00      	ldr	r3, [sp, #0]
   14efc:	f003 0301 	and.w	r3, r3, #1
   14f00:	2b00      	cmp	r3, #0
   14f02:	d100      	bne.n	14f06 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   14f04:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_03[u32CoreId] = msr;
   14f06:	490a      	ldr	r1, [pc, #40]	; (14f30 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x54>)
   14f08:	9b01      	ldr	r3, [sp, #4]
   14f0a:	9a00      	ldr	r2, [sp, #0]
   14f0c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId]++;
   14f10:	4a06      	ldr	r2, [pc, #24]	; (14f2c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x50>)
   14f12:	9b01      	ldr	r3, [sp, #4]
   14f14:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14f18:	1c5a      	adds	r2, r3, #1
   14f1a:	4904      	ldr	r1, [pc, #16]	; (14f2c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x50>)
   14f1c:	9b01      	ldr	r3, [sp, #4]
   14f1e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   14f22:	bf00      	nop
   14f24:	b003      	add	sp, #12
   14f26:	f85d fb04 	ldr.w	pc, [sp], #4
   14f2a:	bf00      	nop
   14f2c:	1fff9764 	.word	0x1fff9764
   14f30:	1fff9760 	.word	0x1fff9760

00014f34 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03(void)
{
   14f34:	b500      	push	{lr}
   14f36:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14f38:	f7eb fef0 	bl	d1c <Sys_GetCoreID>
   14f3c:	4603      	mov	r3, r0
   14f3e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId]--;
   14f40:	4a0d      	ldr	r2, [pc, #52]	; (14f78 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x44>)
   14f42:	9b01      	ldr	r3, [sp, #4]
   14f44:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14f48:	1e5a      	subs	r2, r3, #1
   14f4a:	490b      	ldr	r1, [pc, #44]	; (14f78 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x44>)
   14f4c:	9b01      	ldr	r3, [sp, #4]
   14f4e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_03[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId]))         /*if interrupts were enabled*/
   14f52:	4a0a      	ldr	r2, [pc, #40]	; (14f7c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x48>)
   14f54:	9b01      	ldr	r3, [sp, #4]
   14f56:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14f5a:	f003 0301 	and.w	r3, r3, #1
   14f5e:	2b00      	cmp	r3, #0
   14f60:	d106      	bne.n	14f70 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x3c>
   14f62:	4a05      	ldr	r2, [pc, #20]	; (14f78 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x44>)
   14f64:	9b01      	ldr	r3, [sp, #4]
   14f66:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14f6a:	2b00      	cmp	r3, #0
   14f6c:	d100      	bne.n	14f70 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   14f6e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   14f70:	bf00      	nop
   14f72:	b003      	add	sp, #12
   14f74:	f85d fb04 	ldr.w	pc, [sp], #4
   14f78:	1fff9764 	.word	0x1fff9764
   14f7c:	1fff9760 	.word	0x1fff9760

00014f80 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04(void)
{
   14f80:	b500      	push	{lr}
   14f82:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14f84:	f7eb feca 	bl	d1c <Sys_GetCoreID>
   14f88:	4603      	mov	r3, r0
   14f8a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId])
   14f8c:	4a10      	ldr	r2, [pc, #64]	; (14fd0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x50>)
   14f8e:	9b01      	ldr	r3, [sp, #4]
   14f90:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14f94:	2b00      	cmp	r3, #0
   14f96:	d10d      	bne.n	14fb4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   14f98:	f7eb fd19 	bl	9ce <Port_schm_read_msr>
   14f9c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   14f9e:	9b00      	ldr	r3, [sp, #0]
   14fa0:	f003 0301 	and.w	r3, r3, #1
   14fa4:	2b00      	cmp	r3, #0
   14fa6:	d100      	bne.n	14faa <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   14fa8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_04[u32CoreId] = msr;
   14faa:	490a      	ldr	r1, [pc, #40]	; (14fd4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x54>)
   14fac:	9b01      	ldr	r3, [sp, #4]
   14fae:	9a00      	ldr	r2, [sp, #0]
   14fb0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId]++;
   14fb4:	4a06      	ldr	r2, [pc, #24]	; (14fd0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x50>)
   14fb6:	9b01      	ldr	r3, [sp, #4]
   14fb8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14fbc:	1c5a      	adds	r2, r3, #1
   14fbe:	4904      	ldr	r1, [pc, #16]	; (14fd0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x50>)
   14fc0:	9b01      	ldr	r3, [sp, #4]
   14fc2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   14fc6:	bf00      	nop
   14fc8:	b003      	add	sp, #12
   14fca:	f85d fb04 	ldr.w	pc, [sp], #4
   14fce:	bf00      	nop
   14fd0:	1fff976c 	.word	0x1fff976c
   14fd4:	1fff9768 	.word	0x1fff9768

00014fd8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04(void)
{
   14fd8:	b500      	push	{lr}
   14fda:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14fdc:	f7eb fe9e 	bl	d1c <Sys_GetCoreID>
   14fe0:	4603      	mov	r3, r0
   14fe2:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId]--;
   14fe4:	4a0d      	ldr	r2, [pc, #52]	; (1501c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x44>)
   14fe6:	9b01      	ldr	r3, [sp, #4]
   14fe8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14fec:	1e5a      	subs	r2, r3, #1
   14fee:	490b      	ldr	r1, [pc, #44]	; (1501c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x44>)
   14ff0:	9b01      	ldr	r3, [sp, #4]
   14ff2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_04[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId]))         /*if interrupts were enabled*/
   14ff6:	4a0a      	ldr	r2, [pc, #40]	; (15020 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x48>)
   14ff8:	9b01      	ldr	r3, [sp, #4]
   14ffa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14ffe:	f003 0301 	and.w	r3, r3, #1
   15002:	2b00      	cmp	r3, #0
   15004:	d106      	bne.n	15014 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x3c>
   15006:	4a05      	ldr	r2, [pc, #20]	; (1501c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x44>)
   15008:	9b01      	ldr	r3, [sp, #4]
   1500a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1500e:	2b00      	cmp	r3, #0
   15010:	d100      	bne.n	15014 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   15012:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   15014:	bf00      	nop
   15016:	b003      	add	sp, #12
   15018:	f85d fb04 	ldr.w	pc, [sp], #4
   1501c:	1fff976c 	.word	0x1fff976c
   15020:	1fff9768 	.word	0x1fff9768

00015024 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05(void)
{
   15024:	b500      	push	{lr}
   15026:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15028:	f7eb fe78 	bl	d1c <Sys_GetCoreID>
   1502c:	4603      	mov	r3, r0
   1502e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId])
   15030:	4a10      	ldr	r2, [pc, #64]	; (15074 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x50>)
   15032:	9b01      	ldr	r3, [sp, #4]
   15034:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15038:	2b00      	cmp	r3, #0
   1503a:	d10d      	bne.n	15058 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   1503c:	f7eb fcc7 	bl	9ce <Port_schm_read_msr>
   15040:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   15042:	9b00      	ldr	r3, [sp, #0]
   15044:	f003 0301 	and.w	r3, r3, #1
   15048:	2b00      	cmp	r3, #0
   1504a:	d100      	bne.n	1504e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   1504c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_05[u32CoreId] = msr;
   1504e:	490a      	ldr	r1, [pc, #40]	; (15078 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x54>)
   15050:	9b01      	ldr	r3, [sp, #4]
   15052:	9a00      	ldr	r2, [sp, #0]
   15054:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId]++;
   15058:	4a06      	ldr	r2, [pc, #24]	; (15074 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x50>)
   1505a:	9b01      	ldr	r3, [sp, #4]
   1505c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15060:	1c5a      	adds	r2, r3, #1
   15062:	4904      	ldr	r1, [pc, #16]	; (15074 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x50>)
   15064:	9b01      	ldr	r3, [sp, #4]
   15066:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1506a:	bf00      	nop
   1506c:	b003      	add	sp, #12
   1506e:	f85d fb04 	ldr.w	pc, [sp], #4
   15072:	bf00      	nop
   15074:	1fff9774 	.word	0x1fff9774
   15078:	1fff9770 	.word	0x1fff9770

0001507c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05(void)
{
   1507c:	b500      	push	{lr}
   1507e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15080:	f7eb fe4c 	bl	d1c <Sys_GetCoreID>
   15084:	4603      	mov	r3, r0
   15086:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId]--;
   15088:	4a0d      	ldr	r2, [pc, #52]	; (150c0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x44>)
   1508a:	9b01      	ldr	r3, [sp, #4]
   1508c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15090:	1e5a      	subs	r2, r3, #1
   15092:	490b      	ldr	r1, [pc, #44]	; (150c0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x44>)
   15094:	9b01      	ldr	r3, [sp, #4]
   15096:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_05[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId]))         /*if interrupts were enabled*/
   1509a:	4a0a      	ldr	r2, [pc, #40]	; (150c4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x48>)
   1509c:	9b01      	ldr	r3, [sp, #4]
   1509e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   150a2:	f003 0301 	and.w	r3, r3, #1
   150a6:	2b00      	cmp	r3, #0
   150a8:	d106      	bne.n	150b8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x3c>
   150aa:	4a05      	ldr	r2, [pc, #20]	; (150c0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x44>)
   150ac:	9b01      	ldr	r3, [sp, #4]
   150ae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   150b2:	2b00      	cmp	r3, #0
   150b4:	d100      	bne.n	150b8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   150b6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   150b8:	bf00      	nop
   150ba:	b003      	add	sp, #12
   150bc:	f85d fb04 	ldr.w	pc, [sp], #4
   150c0:	1fff9774 	.word	0x1fff9774
   150c4:	1fff9770 	.word	0x1fff9770

000150c8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06(void)
{
   150c8:	b500      	push	{lr}
   150ca:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   150cc:	f7eb fe26 	bl	d1c <Sys_GetCoreID>
   150d0:	4603      	mov	r3, r0
   150d2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId])
   150d4:	4a10      	ldr	r2, [pc, #64]	; (15118 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x50>)
   150d6:	9b01      	ldr	r3, [sp, #4]
   150d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   150dc:	2b00      	cmp	r3, #0
   150de:	d10d      	bne.n	150fc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   150e0:	f7eb fc75 	bl	9ce <Port_schm_read_msr>
   150e4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   150e6:	9b00      	ldr	r3, [sp, #0]
   150e8:	f003 0301 	and.w	r3, r3, #1
   150ec:	2b00      	cmp	r3, #0
   150ee:	d100      	bne.n	150f2 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   150f0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_06[u32CoreId] = msr;
   150f2:	490a      	ldr	r1, [pc, #40]	; (1511c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x54>)
   150f4:	9b01      	ldr	r3, [sp, #4]
   150f6:	9a00      	ldr	r2, [sp, #0]
   150f8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId]++;
   150fc:	4a06      	ldr	r2, [pc, #24]	; (15118 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x50>)
   150fe:	9b01      	ldr	r3, [sp, #4]
   15100:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15104:	1c5a      	adds	r2, r3, #1
   15106:	4904      	ldr	r1, [pc, #16]	; (15118 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x50>)
   15108:	9b01      	ldr	r3, [sp, #4]
   1510a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1510e:	bf00      	nop
   15110:	b003      	add	sp, #12
   15112:	f85d fb04 	ldr.w	pc, [sp], #4
   15116:	bf00      	nop
   15118:	1fff977c 	.word	0x1fff977c
   1511c:	1fff9778 	.word	0x1fff9778

00015120 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06(void)
{
   15120:	b500      	push	{lr}
   15122:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15124:	f7eb fdfa 	bl	d1c <Sys_GetCoreID>
   15128:	4603      	mov	r3, r0
   1512a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId]--;
   1512c:	4a0d      	ldr	r2, [pc, #52]	; (15164 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x44>)
   1512e:	9b01      	ldr	r3, [sp, #4]
   15130:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15134:	1e5a      	subs	r2, r3, #1
   15136:	490b      	ldr	r1, [pc, #44]	; (15164 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x44>)
   15138:	9b01      	ldr	r3, [sp, #4]
   1513a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_06[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId]))         /*if interrupts were enabled*/
   1513e:	4a0a      	ldr	r2, [pc, #40]	; (15168 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x48>)
   15140:	9b01      	ldr	r3, [sp, #4]
   15142:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15146:	f003 0301 	and.w	r3, r3, #1
   1514a:	2b00      	cmp	r3, #0
   1514c:	d106      	bne.n	1515c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x3c>
   1514e:	4a05      	ldr	r2, [pc, #20]	; (15164 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x44>)
   15150:	9b01      	ldr	r3, [sp, #4]
   15152:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15156:	2b00      	cmp	r3, #0
   15158:	d100      	bne.n	1515c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1515a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   1515c:	bf00      	nop
   1515e:	b003      	add	sp, #12
   15160:	f85d fb04 	ldr.w	pc, [sp], #4
   15164:	1fff977c 	.word	0x1fff977c
   15168:	1fff9778 	.word	0x1fff9778

0001516c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07(void)
{
   1516c:	b500      	push	{lr}
   1516e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15170:	f7eb fdd4 	bl	d1c <Sys_GetCoreID>
   15174:	4603      	mov	r3, r0
   15176:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId])
   15178:	4a10      	ldr	r2, [pc, #64]	; (151bc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x50>)
   1517a:	9b01      	ldr	r3, [sp, #4]
   1517c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15180:	2b00      	cmp	r3, #0
   15182:	d10d      	bne.n	151a0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   15184:	f7eb fc23 	bl	9ce <Port_schm_read_msr>
   15188:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1518a:	9b00      	ldr	r3, [sp, #0]
   1518c:	f003 0301 	and.w	r3, r3, #1
   15190:	2b00      	cmp	r3, #0
   15192:	d100      	bne.n	15196 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   15194:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_07[u32CoreId] = msr;
   15196:	490a      	ldr	r1, [pc, #40]	; (151c0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x54>)
   15198:	9b01      	ldr	r3, [sp, #4]
   1519a:	9a00      	ldr	r2, [sp, #0]
   1519c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId]++;
   151a0:	4a06      	ldr	r2, [pc, #24]	; (151bc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x50>)
   151a2:	9b01      	ldr	r3, [sp, #4]
   151a4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   151a8:	1c5a      	adds	r2, r3, #1
   151aa:	4904      	ldr	r1, [pc, #16]	; (151bc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x50>)
   151ac:	9b01      	ldr	r3, [sp, #4]
   151ae:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   151b2:	bf00      	nop
   151b4:	b003      	add	sp, #12
   151b6:	f85d fb04 	ldr.w	pc, [sp], #4
   151ba:	bf00      	nop
   151bc:	1fff9784 	.word	0x1fff9784
   151c0:	1fff9780 	.word	0x1fff9780

000151c4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07(void)
{
   151c4:	b500      	push	{lr}
   151c6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   151c8:	f7eb fda8 	bl	d1c <Sys_GetCoreID>
   151cc:	4603      	mov	r3, r0
   151ce:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId]--;
   151d0:	4a0d      	ldr	r2, [pc, #52]	; (15208 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x44>)
   151d2:	9b01      	ldr	r3, [sp, #4]
   151d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   151d8:	1e5a      	subs	r2, r3, #1
   151da:	490b      	ldr	r1, [pc, #44]	; (15208 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x44>)
   151dc:	9b01      	ldr	r3, [sp, #4]
   151de:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_07[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId]))         /*if interrupts were enabled*/
   151e2:	4a0a      	ldr	r2, [pc, #40]	; (1520c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x48>)
   151e4:	9b01      	ldr	r3, [sp, #4]
   151e6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   151ea:	f003 0301 	and.w	r3, r3, #1
   151ee:	2b00      	cmp	r3, #0
   151f0:	d106      	bne.n	15200 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x3c>
   151f2:	4a05      	ldr	r2, [pc, #20]	; (15208 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x44>)
   151f4:	9b01      	ldr	r3, [sp, #4]
   151f6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   151fa:	2b00      	cmp	r3, #0
   151fc:	d100      	bne.n	15200 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   151fe:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   15200:	bf00      	nop
   15202:	b003      	add	sp, #12
   15204:	f85d fb04 	ldr.w	pc, [sp], #4
   15208:	1fff9784 	.word	0x1fff9784
   1520c:	1fff9780 	.word	0x1fff9780

00015210 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08(void)
{
   15210:	b500      	push	{lr}
   15212:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15214:	f7eb fd82 	bl	d1c <Sys_GetCoreID>
   15218:	4603      	mov	r3, r0
   1521a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId])
   1521c:	4a10      	ldr	r2, [pc, #64]	; (15260 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x50>)
   1521e:	9b01      	ldr	r3, [sp, #4]
   15220:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15224:	2b00      	cmp	r3, #0
   15226:	d10d      	bne.n	15244 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   15228:	f7eb fbd1 	bl	9ce <Port_schm_read_msr>
   1522c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1522e:	9b00      	ldr	r3, [sp, #0]
   15230:	f003 0301 	and.w	r3, r3, #1
   15234:	2b00      	cmp	r3, #0
   15236:	d100      	bne.n	1523a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   15238:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_08[u32CoreId] = msr;
   1523a:	490a      	ldr	r1, [pc, #40]	; (15264 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x54>)
   1523c:	9b01      	ldr	r3, [sp, #4]
   1523e:	9a00      	ldr	r2, [sp, #0]
   15240:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId]++;
   15244:	4a06      	ldr	r2, [pc, #24]	; (15260 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x50>)
   15246:	9b01      	ldr	r3, [sp, #4]
   15248:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1524c:	1c5a      	adds	r2, r3, #1
   1524e:	4904      	ldr	r1, [pc, #16]	; (15260 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x50>)
   15250:	9b01      	ldr	r3, [sp, #4]
   15252:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   15256:	bf00      	nop
   15258:	b003      	add	sp, #12
   1525a:	f85d fb04 	ldr.w	pc, [sp], #4
   1525e:	bf00      	nop
   15260:	1fff978c 	.word	0x1fff978c
   15264:	1fff9788 	.word	0x1fff9788

00015268 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08(void)
{
   15268:	b500      	push	{lr}
   1526a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1526c:	f7eb fd56 	bl	d1c <Sys_GetCoreID>
   15270:	4603      	mov	r3, r0
   15272:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId]--;
   15274:	4a0d      	ldr	r2, [pc, #52]	; (152ac <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x44>)
   15276:	9b01      	ldr	r3, [sp, #4]
   15278:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1527c:	1e5a      	subs	r2, r3, #1
   1527e:	490b      	ldr	r1, [pc, #44]	; (152ac <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x44>)
   15280:	9b01      	ldr	r3, [sp, #4]
   15282:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_08[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId]))         /*if interrupts were enabled*/
   15286:	4a0a      	ldr	r2, [pc, #40]	; (152b0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x48>)
   15288:	9b01      	ldr	r3, [sp, #4]
   1528a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1528e:	f003 0301 	and.w	r3, r3, #1
   15292:	2b00      	cmp	r3, #0
   15294:	d106      	bne.n	152a4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x3c>
   15296:	4a05      	ldr	r2, [pc, #20]	; (152ac <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x44>)
   15298:	9b01      	ldr	r3, [sp, #4]
   1529a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1529e:	2b00      	cmp	r3, #0
   152a0:	d100      	bne.n	152a4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   152a2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   152a4:	bf00      	nop
   152a6:	b003      	add	sp, #12
   152a8:	f85d fb04 	ldr.w	pc, [sp], #4
   152ac:	1fff978c 	.word	0x1fff978c
   152b0:	1fff9788 	.word	0x1fff9788

000152b4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09(void)
{
   152b4:	b500      	push	{lr}
   152b6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   152b8:	f7eb fd30 	bl	d1c <Sys_GetCoreID>
   152bc:	4603      	mov	r3, r0
   152be:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId])
   152c0:	4a10      	ldr	r2, [pc, #64]	; (15304 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x50>)
   152c2:	9b01      	ldr	r3, [sp, #4]
   152c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   152c8:	2b00      	cmp	r3, #0
   152ca:	d10d      	bne.n	152e8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   152cc:	f7eb fb7f 	bl	9ce <Port_schm_read_msr>
   152d0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   152d2:	9b00      	ldr	r3, [sp, #0]
   152d4:	f003 0301 	and.w	r3, r3, #1
   152d8:	2b00      	cmp	r3, #0
   152da:	d100      	bne.n	152de <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   152dc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_09[u32CoreId] = msr;
   152de:	490a      	ldr	r1, [pc, #40]	; (15308 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x54>)
   152e0:	9b01      	ldr	r3, [sp, #4]
   152e2:	9a00      	ldr	r2, [sp, #0]
   152e4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId]++;
   152e8:	4a06      	ldr	r2, [pc, #24]	; (15304 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x50>)
   152ea:	9b01      	ldr	r3, [sp, #4]
   152ec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   152f0:	1c5a      	adds	r2, r3, #1
   152f2:	4904      	ldr	r1, [pc, #16]	; (15304 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x50>)
   152f4:	9b01      	ldr	r3, [sp, #4]
   152f6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   152fa:	bf00      	nop
   152fc:	b003      	add	sp, #12
   152fe:	f85d fb04 	ldr.w	pc, [sp], #4
   15302:	bf00      	nop
   15304:	1fff9794 	.word	0x1fff9794
   15308:	1fff9790 	.word	0x1fff9790

0001530c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09(void)
{
   1530c:	b500      	push	{lr}
   1530e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15310:	f7eb fd04 	bl	d1c <Sys_GetCoreID>
   15314:	4603      	mov	r3, r0
   15316:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId]--;
   15318:	4a0d      	ldr	r2, [pc, #52]	; (15350 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x44>)
   1531a:	9b01      	ldr	r3, [sp, #4]
   1531c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15320:	1e5a      	subs	r2, r3, #1
   15322:	490b      	ldr	r1, [pc, #44]	; (15350 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x44>)
   15324:	9b01      	ldr	r3, [sp, #4]
   15326:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_09[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId]))         /*if interrupts were enabled*/
   1532a:	4a0a      	ldr	r2, [pc, #40]	; (15354 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x48>)
   1532c:	9b01      	ldr	r3, [sp, #4]
   1532e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15332:	f003 0301 	and.w	r3, r3, #1
   15336:	2b00      	cmp	r3, #0
   15338:	d106      	bne.n	15348 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x3c>
   1533a:	4a05      	ldr	r2, [pc, #20]	; (15350 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x44>)
   1533c:	9b01      	ldr	r3, [sp, #4]
   1533e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15342:	2b00      	cmp	r3, #0
   15344:	d100      	bne.n	15348 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   15346:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   15348:	bf00      	nop
   1534a:	b003      	add	sp, #12
   1534c:	f85d fb04 	ldr.w	pc, [sp], #4
   15350:	1fff9794 	.word	0x1fff9794
   15354:	1fff9790 	.word	0x1fff9790

00015358 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10(void)
{
   15358:	b500      	push	{lr}
   1535a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1535c:	f7eb fcde 	bl	d1c <Sys_GetCoreID>
   15360:	4603      	mov	r3, r0
   15362:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId])
   15364:	4a10      	ldr	r2, [pc, #64]	; (153a8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x50>)
   15366:	9b01      	ldr	r3, [sp, #4]
   15368:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1536c:	2b00      	cmp	r3, #0
   1536e:	d10d      	bne.n	1538c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   15370:	f7eb fb2d 	bl	9ce <Port_schm_read_msr>
   15374:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   15376:	9b00      	ldr	r3, [sp, #0]
   15378:	f003 0301 	and.w	r3, r3, #1
   1537c:	2b00      	cmp	r3, #0
   1537e:	d100      	bne.n	15382 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   15380:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_10[u32CoreId] = msr;
   15382:	490a      	ldr	r1, [pc, #40]	; (153ac <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x54>)
   15384:	9b01      	ldr	r3, [sp, #4]
   15386:	9a00      	ldr	r2, [sp, #0]
   15388:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId]++;
   1538c:	4a06      	ldr	r2, [pc, #24]	; (153a8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x50>)
   1538e:	9b01      	ldr	r3, [sp, #4]
   15390:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15394:	1c5a      	adds	r2, r3, #1
   15396:	4904      	ldr	r1, [pc, #16]	; (153a8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x50>)
   15398:	9b01      	ldr	r3, [sp, #4]
   1539a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1539e:	bf00      	nop
   153a0:	b003      	add	sp, #12
   153a2:	f85d fb04 	ldr.w	pc, [sp], #4
   153a6:	bf00      	nop
   153a8:	1fff979c 	.word	0x1fff979c
   153ac:	1fff9798 	.word	0x1fff9798

000153b0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10(void)
{
   153b0:	b500      	push	{lr}
   153b2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   153b4:	f7eb fcb2 	bl	d1c <Sys_GetCoreID>
   153b8:	4603      	mov	r3, r0
   153ba:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId]--;
   153bc:	4a0d      	ldr	r2, [pc, #52]	; (153f4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x44>)
   153be:	9b01      	ldr	r3, [sp, #4]
   153c0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   153c4:	1e5a      	subs	r2, r3, #1
   153c6:	490b      	ldr	r1, [pc, #44]	; (153f4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x44>)
   153c8:	9b01      	ldr	r3, [sp, #4]
   153ca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_10[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId]))         /*if interrupts were enabled*/
   153ce:	4a0a      	ldr	r2, [pc, #40]	; (153f8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x48>)
   153d0:	9b01      	ldr	r3, [sp, #4]
   153d2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   153d6:	f003 0301 	and.w	r3, r3, #1
   153da:	2b00      	cmp	r3, #0
   153dc:	d106      	bne.n	153ec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x3c>
   153de:	4a05      	ldr	r2, [pc, #20]	; (153f4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x44>)
   153e0:	9b01      	ldr	r3, [sp, #4]
   153e2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   153e6:	2b00      	cmp	r3, #0
   153e8:	d100      	bne.n	153ec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   153ea:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   153ec:	bf00      	nop
   153ee:	b003      	add	sp, #12
   153f0:	f85d fb04 	ldr.w	pc, [sp], #4
   153f4:	1fff979c 	.word	0x1fff979c
   153f8:	1fff9798 	.word	0x1fff9798

000153fc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11(void)
{
   153fc:	b500      	push	{lr}
   153fe:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15400:	f7eb fc8c 	bl	d1c <Sys_GetCoreID>
   15404:	4603      	mov	r3, r0
   15406:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId])
   15408:	4a10      	ldr	r2, [pc, #64]	; (1544c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x50>)
   1540a:	9b01      	ldr	r3, [sp, #4]
   1540c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15410:	2b00      	cmp	r3, #0
   15412:	d10d      	bne.n	15430 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   15414:	f7eb fadb 	bl	9ce <Port_schm_read_msr>
   15418:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1541a:	9b00      	ldr	r3, [sp, #0]
   1541c:	f003 0301 	and.w	r3, r3, #1
   15420:	2b00      	cmp	r3, #0
   15422:	d100      	bne.n	15426 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   15424:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_11[u32CoreId] = msr;
   15426:	490a      	ldr	r1, [pc, #40]	; (15450 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x54>)
   15428:	9b01      	ldr	r3, [sp, #4]
   1542a:	9a00      	ldr	r2, [sp, #0]
   1542c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId]++;
   15430:	4a06      	ldr	r2, [pc, #24]	; (1544c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x50>)
   15432:	9b01      	ldr	r3, [sp, #4]
   15434:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15438:	1c5a      	adds	r2, r3, #1
   1543a:	4904      	ldr	r1, [pc, #16]	; (1544c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x50>)
   1543c:	9b01      	ldr	r3, [sp, #4]
   1543e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   15442:	bf00      	nop
   15444:	b003      	add	sp, #12
   15446:	f85d fb04 	ldr.w	pc, [sp], #4
   1544a:	bf00      	nop
   1544c:	1fff97a4 	.word	0x1fff97a4
   15450:	1fff97a0 	.word	0x1fff97a0

00015454 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11(void)
{
   15454:	b500      	push	{lr}
   15456:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15458:	f7eb fc60 	bl	d1c <Sys_GetCoreID>
   1545c:	4603      	mov	r3, r0
   1545e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId]--;
   15460:	4a0d      	ldr	r2, [pc, #52]	; (15498 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x44>)
   15462:	9b01      	ldr	r3, [sp, #4]
   15464:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15468:	1e5a      	subs	r2, r3, #1
   1546a:	490b      	ldr	r1, [pc, #44]	; (15498 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x44>)
   1546c:	9b01      	ldr	r3, [sp, #4]
   1546e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_11[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId]))         /*if interrupts were enabled*/
   15472:	4a0a      	ldr	r2, [pc, #40]	; (1549c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x48>)
   15474:	9b01      	ldr	r3, [sp, #4]
   15476:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1547a:	f003 0301 	and.w	r3, r3, #1
   1547e:	2b00      	cmp	r3, #0
   15480:	d106      	bne.n	15490 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x3c>
   15482:	4a05      	ldr	r2, [pc, #20]	; (15498 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x44>)
   15484:	9b01      	ldr	r3, [sp, #4]
   15486:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1548a:	2b00      	cmp	r3, #0
   1548c:	d100      	bne.n	15490 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1548e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   15490:	bf00      	nop
   15492:	b003      	add	sp, #12
   15494:	f85d fb04 	ldr.w	pc, [sp], #4
   15498:	1fff97a4 	.word	0x1fff97a4
   1549c:	1fff97a0 	.word	0x1fff97a0

000154a0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12(void)
{
   154a0:	b500      	push	{lr}
   154a2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   154a4:	f7eb fc3a 	bl	d1c <Sys_GetCoreID>
   154a8:	4603      	mov	r3, r0
   154aa:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId])
   154ac:	4a10      	ldr	r2, [pc, #64]	; (154f0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x50>)
   154ae:	9b01      	ldr	r3, [sp, #4]
   154b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   154b4:	2b00      	cmp	r3, #0
   154b6:	d10d      	bne.n	154d4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   154b8:	f7eb fa89 	bl	9ce <Port_schm_read_msr>
   154bc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   154be:	9b00      	ldr	r3, [sp, #0]
   154c0:	f003 0301 	and.w	r3, r3, #1
   154c4:	2b00      	cmp	r3, #0
   154c6:	d100      	bne.n	154ca <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   154c8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_12[u32CoreId] = msr;
   154ca:	490a      	ldr	r1, [pc, #40]	; (154f4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x54>)
   154cc:	9b01      	ldr	r3, [sp, #4]
   154ce:	9a00      	ldr	r2, [sp, #0]
   154d0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId]++;
   154d4:	4a06      	ldr	r2, [pc, #24]	; (154f0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x50>)
   154d6:	9b01      	ldr	r3, [sp, #4]
   154d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   154dc:	1c5a      	adds	r2, r3, #1
   154de:	4904      	ldr	r1, [pc, #16]	; (154f0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x50>)
   154e0:	9b01      	ldr	r3, [sp, #4]
   154e2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   154e6:	bf00      	nop
   154e8:	b003      	add	sp, #12
   154ea:	f85d fb04 	ldr.w	pc, [sp], #4
   154ee:	bf00      	nop
   154f0:	1fff97ac 	.word	0x1fff97ac
   154f4:	1fff97a8 	.word	0x1fff97a8

000154f8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12(void)
{
   154f8:	b500      	push	{lr}
   154fa:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   154fc:	f7eb fc0e 	bl	d1c <Sys_GetCoreID>
   15500:	4603      	mov	r3, r0
   15502:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId]--;
   15504:	4a0d      	ldr	r2, [pc, #52]	; (1553c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x44>)
   15506:	9b01      	ldr	r3, [sp, #4]
   15508:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1550c:	1e5a      	subs	r2, r3, #1
   1550e:	490b      	ldr	r1, [pc, #44]	; (1553c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x44>)
   15510:	9b01      	ldr	r3, [sp, #4]
   15512:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_12[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId]))         /*if interrupts were enabled*/
   15516:	4a0a      	ldr	r2, [pc, #40]	; (15540 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x48>)
   15518:	9b01      	ldr	r3, [sp, #4]
   1551a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1551e:	f003 0301 	and.w	r3, r3, #1
   15522:	2b00      	cmp	r3, #0
   15524:	d106      	bne.n	15534 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x3c>
   15526:	4a05      	ldr	r2, [pc, #20]	; (1553c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x44>)
   15528:	9b01      	ldr	r3, [sp, #4]
   1552a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1552e:	2b00      	cmp	r3, #0
   15530:	d100      	bne.n	15534 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   15532:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   15534:	bf00      	nop
   15536:	b003      	add	sp, #12
   15538:	f85d fb04 	ldr.w	pc, [sp], #4
   1553c:	1fff97ac 	.word	0x1fff97ac
   15540:	1fff97a8 	.word	0x1fff97a8

00015544 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13(void)
{
   15544:	b500      	push	{lr}
   15546:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15548:	f7eb fbe8 	bl	d1c <Sys_GetCoreID>
   1554c:	4603      	mov	r3, r0
   1554e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId])
   15550:	4a10      	ldr	r2, [pc, #64]	; (15594 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x50>)
   15552:	9b01      	ldr	r3, [sp, #4]
   15554:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15558:	2b00      	cmp	r3, #0
   1555a:	d10d      	bne.n	15578 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   1555c:	f7eb fa37 	bl	9ce <Port_schm_read_msr>
   15560:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   15562:	9b00      	ldr	r3, [sp, #0]
   15564:	f003 0301 	and.w	r3, r3, #1
   15568:	2b00      	cmp	r3, #0
   1556a:	d100      	bne.n	1556e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   1556c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_13[u32CoreId] = msr;
   1556e:	490a      	ldr	r1, [pc, #40]	; (15598 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x54>)
   15570:	9b01      	ldr	r3, [sp, #4]
   15572:	9a00      	ldr	r2, [sp, #0]
   15574:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId]++;
   15578:	4a06      	ldr	r2, [pc, #24]	; (15594 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x50>)
   1557a:	9b01      	ldr	r3, [sp, #4]
   1557c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15580:	1c5a      	adds	r2, r3, #1
   15582:	4904      	ldr	r1, [pc, #16]	; (15594 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x50>)
   15584:	9b01      	ldr	r3, [sp, #4]
   15586:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1558a:	bf00      	nop
   1558c:	b003      	add	sp, #12
   1558e:	f85d fb04 	ldr.w	pc, [sp], #4
   15592:	bf00      	nop
   15594:	1fff97b4 	.word	0x1fff97b4
   15598:	1fff97b0 	.word	0x1fff97b0

0001559c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13(void)
{
   1559c:	b500      	push	{lr}
   1559e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   155a0:	f7eb fbbc 	bl	d1c <Sys_GetCoreID>
   155a4:	4603      	mov	r3, r0
   155a6:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId]--;
   155a8:	4a0d      	ldr	r2, [pc, #52]	; (155e0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x44>)
   155aa:	9b01      	ldr	r3, [sp, #4]
   155ac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   155b0:	1e5a      	subs	r2, r3, #1
   155b2:	490b      	ldr	r1, [pc, #44]	; (155e0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x44>)
   155b4:	9b01      	ldr	r3, [sp, #4]
   155b6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_13[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId]))         /*if interrupts were enabled*/
   155ba:	4a0a      	ldr	r2, [pc, #40]	; (155e4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x48>)
   155bc:	9b01      	ldr	r3, [sp, #4]
   155be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   155c2:	f003 0301 	and.w	r3, r3, #1
   155c6:	2b00      	cmp	r3, #0
   155c8:	d106      	bne.n	155d8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x3c>
   155ca:	4a05      	ldr	r2, [pc, #20]	; (155e0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x44>)
   155cc:	9b01      	ldr	r3, [sp, #4]
   155ce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   155d2:	2b00      	cmp	r3, #0
   155d4:	d100      	bne.n	155d8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   155d6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   155d8:	bf00      	nop
   155da:	b003      	add	sp, #12
   155dc:	f85d fb04 	ldr.w	pc, [sp], #4
   155e0:	1fff97b4 	.word	0x1fff97b4
   155e4:	1fff97b0 	.word	0x1fff97b0

000155e8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14(void)
{
   155e8:	b500      	push	{lr}
   155ea:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   155ec:	f7eb fb96 	bl	d1c <Sys_GetCoreID>
   155f0:	4603      	mov	r3, r0
   155f2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId])
   155f4:	4a10      	ldr	r2, [pc, #64]	; (15638 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x50>)
   155f6:	9b01      	ldr	r3, [sp, #4]
   155f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   155fc:	2b00      	cmp	r3, #0
   155fe:	d10d      	bne.n	1561c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   15600:	f7eb f9e5 	bl	9ce <Port_schm_read_msr>
   15604:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   15606:	9b00      	ldr	r3, [sp, #0]
   15608:	f003 0301 	and.w	r3, r3, #1
   1560c:	2b00      	cmp	r3, #0
   1560e:	d100      	bne.n	15612 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   15610:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_14[u32CoreId] = msr;
   15612:	490a      	ldr	r1, [pc, #40]	; (1563c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x54>)
   15614:	9b01      	ldr	r3, [sp, #4]
   15616:	9a00      	ldr	r2, [sp, #0]
   15618:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId]++;
   1561c:	4a06      	ldr	r2, [pc, #24]	; (15638 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x50>)
   1561e:	9b01      	ldr	r3, [sp, #4]
   15620:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15624:	1c5a      	adds	r2, r3, #1
   15626:	4904      	ldr	r1, [pc, #16]	; (15638 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x50>)
   15628:	9b01      	ldr	r3, [sp, #4]
   1562a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1562e:	bf00      	nop
   15630:	b003      	add	sp, #12
   15632:	f85d fb04 	ldr.w	pc, [sp], #4
   15636:	bf00      	nop
   15638:	1fff97bc 	.word	0x1fff97bc
   1563c:	1fff97b8 	.word	0x1fff97b8

00015640 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14(void)
{
   15640:	b500      	push	{lr}
   15642:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15644:	f7eb fb6a 	bl	d1c <Sys_GetCoreID>
   15648:	4603      	mov	r3, r0
   1564a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId]--;
   1564c:	4a0d      	ldr	r2, [pc, #52]	; (15684 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x44>)
   1564e:	9b01      	ldr	r3, [sp, #4]
   15650:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15654:	1e5a      	subs	r2, r3, #1
   15656:	490b      	ldr	r1, [pc, #44]	; (15684 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x44>)
   15658:	9b01      	ldr	r3, [sp, #4]
   1565a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_14[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId]))         /*if interrupts were enabled*/
   1565e:	4a0a      	ldr	r2, [pc, #40]	; (15688 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x48>)
   15660:	9b01      	ldr	r3, [sp, #4]
   15662:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15666:	f003 0301 	and.w	r3, r3, #1
   1566a:	2b00      	cmp	r3, #0
   1566c:	d106      	bne.n	1567c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x3c>
   1566e:	4a05      	ldr	r2, [pc, #20]	; (15684 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x44>)
   15670:	9b01      	ldr	r3, [sp, #4]
   15672:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15676:	2b00      	cmp	r3, #0
   15678:	d100      	bne.n	1567c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1567a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   1567c:	bf00      	nop
   1567e:	b003      	add	sp, #12
   15680:	f85d fb04 	ldr.w	pc, [sp], #4
   15684:	1fff97bc 	.word	0x1fff97bc
   15688:	1fff97b8 	.word	0x1fff97b8

0001568c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15(void)
{
   1568c:	b500      	push	{lr}
   1568e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15690:	f7eb fb44 	bl	d1c <Sys_GetCoreID>
   15694:	4603      	mov	r3, r0
   15696:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId])
   15698:	4a10      	ldr	r2, [pc, #64]	; (156dc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x50>)
   1569a:	9b01      	ldr	r3, [sp, #4]
   1569c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   156a0:	2b00      	cmp	r3, #0
   156a2:	d10d      	bne.n	156c0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   156a4:	f7eb f993 	bl	9ce <Port_schm_read_msr>
   156a8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   156aa:	9b00      	ldr	r3, [sp, #0]
   156ac:	f003 0301 	and.w	r3, r3, #1
   156b0:	2b00      	cmp	r3, #0
   156b2:	d100      	bne.n	156b6 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   156b4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_15[u32CoreId] = msr;
   156b6:	490a      	ldr	r1, [pc, #40]	; (156e0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x54>)
   156b8:	9b01      	ldr	r3, [sp, #4]
   156ba:	9a00      	ldr	r2, [sp, #0]
   156bc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId]++;
   156c0:	4a06      	ldr	r2, [pc, #24]	; (156dc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x50>)
   156c2:	9b01      	ldr	r3, [sp, #4]
   156c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   156c8:	1c5a      	adds	r2, r3, #1
   156ca:	4904      	ldr	r1, [pc, #16]	; (156dc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x50>)
   156cc:	9b01      	ldr	r3, [sp, #4]
   156ce:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   156d2:	bf00      	nop
   156d4:	b003      	add	sp, #12
   156d6:	f85d fb04 	ldr.w	pc, [sp], #4
   156da:	bf00      	nop
   156dc:	1fff97c4 	.word	0x1fff97c4
   156e0:	1fff97c0 	.word	0x1fff97c0

000156e4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15(void)
{
   156e4:	b500      	push	{lr}
   156e6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   156e8:	f7eb fb18 	bl	d1c <Sys_GetCoreID>
   156ec:	4603      	mov	r3, r0
   156ee:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId]--;
   156f0:	4a0d      	ldr	r2, [pc, #52]	; (15728 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x44>)
   156f2:	9b01      	ldr	r3, [sp, #4]
   156f4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   156f8:	1e5a      	subs	r2, r3, #1
   156fa:	490b      	ldr	r1, [pc, #44]	; (15728 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x44>)
   156fc:	9b01      	ldr	r3, [sp, #4]
   156fe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_15[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId]))         /*if interrupts were enabled*/
   15702:	4a0a      	ldr	r2, [pc, #40]	; (1572c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x48>)
   15704:	9b01      	ldr	r3, [sp, #4]
   15706:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1570a:	f003 0301 	and.w	r3, r3, #1
   1570e:	2b00      	cmp	r3, #0
   15710:	d106      	bne.n	15720 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x3c>
   15712:	4a05      	ldr	r2, [pc, #20]	; (15728 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x44>)
   15714:	9b01      	ldr	r3, [sp, #4]
   15716:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1571a:	2b00      	cmp	r3, #0
   1571c:	d100      	bne.n	15720 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1571e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   15720:	bf00      	nop
   15722:	b003      	add	sp, #12
   15724:	f85d fb04 	ldr.w	pc, [sp], #4
   15728:	1fff97c4 	.word	0x1fff97c4
   1572c:	1fff97c0 	.word	0x1fff97c0

00015730 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16(void)
{
   15730:	b500      	push	{lr}
   15732:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15734:	f7eb faf2 	bl	d1c <Sys_GetCoreID>
   15738:	4603      	mov	r3, r0
   1573a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId])
   1573c:	4a10      	ldr	r2, [pc, #64]	; (15780 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x50>)
   1573e:	9b01      	ldr	r3, [sp, #4]
   15740:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15744:	2b00      	cmp	r3, #0
   15746:	d10d      	bne.n	15764 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   15748:	f7eb f941 	bl	9ce <Port_schm_read_msr>
   1574c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1574e:	9b00      	ldr	r3, [sp, #0]
   15750:	f003 0301 	and.w	r3, r3, #1
   15754:	2b00      	cmp	r3, #0
   15756:	d100      	bne.n	1575a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   15758:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_16[u32CoreId] = msr;
   1575a:	490a      	ldr	r1, [pc, #40]	; (15784 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x54>)
   1575c:	9b01      	ldr	r3, [sp, #4]
   1575e:	9a00      	ldr	r2, [sp, #0]
   15760:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId]++;
   15764:	4a06      	ldr	r2, [pc, #24]	; (15780 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x50>)
   15766:	9b01      	ldr	r3, [sp, #4]
   15768:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1576c:	1c5a      	adds	r2, r3, #1
   1576e:	4904      	ldr	r1, [pc, #16]	; (15780 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x50>)
   15770:	9b01      	ldr	r3, [sp, #4]
   15772:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   15776:	bf00      	nop
   15778:	b003      	add	sp, #12
   1577a:	f85d fb04 	ldr.w	pc, [sp], #4
   1577e:	bf00      	nop
   15780:	1fff97cc 	.word	0x1fff97cc
   15784:	1fff97c8 	.word	0x1fff97c8

00015788 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16(void)
{
   15788:	b500      	push	{lr}
   1578a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1578c:	f7eb fac6 	bl	d1c <Sys_GetCoreID>
   15790:	4603      	mov	r3, r0
   15792:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId]--;
   15794:	4a0d      	ldr	r2, [pc, #52]	; (157cc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x44>)
   15796:	9b01      	ldr	r3, [sp, #4]
   15798:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1579c:	1e5a      	subs	r2, r3, #1
   1579e:	490b      	ldr	r1, [pc, #44]	; (157cc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x44>)
   157a0:	9b01      	ldr	r3, [sp, #4]
   157a2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_16[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId]))         /*if interrupts were enabled*/
   157a6:	4a0a      	ldr	r2, [pc, #40]	; (157d0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x48>)
   157a8:	9b01      	ldr	r3, [sp, #4]
   157aa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   157ae:	f003 0301 	and.w	r3, r3, #1
   157b2:	2b00      	cmp	r3, #0
   157b4:	d106      	bne.n	157c4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x3c>
   157b6:	4a05      	ldr	r2, [pc, #20]	; (157cc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x44>)
   157b8:	9b01      	ldr	r3, [sp, #4]
   157ba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   157be:	2b00      	cmp	r3, #0
   157c0:	d100      	bne.n	157c4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   157c2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   157c4:	bf00      	nop
   157c6:	b003      	add	sp, #12
   157c8:	f85d fb04 	ldr.w	pc, [sp], #4
   157cc:	1fff97cc 	.word	0x1fff97cc
   157d0:	1fff97c8 	.word	0x1fff97c8

000157d4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17(void)
{
   157d4:	b500      	push	{lr}
   157d6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   157d8:	f7eb faa0 	bl	d1c <Sys_GetCoreID>
   157dc:	4603      	mov	r3, r0
   157de:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId])
   157e0:	4a10      	ldr	r2, [pc, #64]	; (15824 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x50>)
   157e2:	9b01      	ldr	r3, [sp, #4]
   157e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   157e8:	2b00      	cmp	r3, #0
   157ea:	d10d      	bne.n	15808 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   157ec:	f7eb f8ef 	bl	9ce <Port_schm_read_msr>
   157f0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   157f2:	9b00      	ldr	r3, [sp, #0]
   157f4:	f003 0301 	and.w	r3, r3, #1
   157f8:	2b00      	cmp	r3, #0
   157fa:	d100      	bne.n	157fe <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   157fc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_17[u32CoreId] = msr;
   157fe:	490a      	ldr	r1, [pc, #40]	; (15828 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x54>)
   15800:	9b01      	ldr	r3, [sp, #4]
   15802:	9a00      	ldr	r2, [sp, #0]
   15804:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId]++;
   15808:	4a06      	ldr	r2, [pc, #24]	; (15824 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x50>)
   1580a:	9b01      	ldr	r3, [sp, #4]
   1580c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15810:	1c5a      	adds	r2, r3, #1
   15812:	4904      	ldr	r1, [pc, #16]	; (15824 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x50>)
   15814:	9b01      	ldr	r3, [sp, #4]
   15816:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1581a:	bf00      	nop
   1581c:	b003      	add	sp, #12
   1581e:	f85d fb04 	ldr.w	pc, [sp], #4
   15822:	bf00      	nop
   15824:	1fff97d4 	.word	0x1fff97d4
   15828:	1fff97d0 	.word	0x1fff97d0

0001582c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17(void)
{
   1582c:	b500      	push	{lr}
   1582e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15830:	f7eb fa74 	bl	d1c <Sys_GetCoreID>
   15834:	4603      	mov	r3, r0
   15836:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId]--;
   15838:	4a0d      	ldr	r2, [pc, #52]	; (15870 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x44>)
   1583a:	9b01      	ldr	r3, [sp, #4]
   1583c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15840:	1e5a      	subs	r2, r3, #1
   15842:	490b      	ldr	r1, [pc, #44]	; (15870 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x44>)
   15844:	9b01      	ldr	r3, [sp, #4]
   15846:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_17[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId]))         /*if interrupts were enabled*/
   1584a:	4a0a      	ldr	r2, [pc, #40]	; (15874 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x48>)
   1584c:	9b01      	ldr	r3, [sp, #4]
   1584e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15852:	f003 0301 	and.w	r3, r3, #1
   15856:	2b00      	cmp	r3, #0
   15858:	d106      	bne.n	15868 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x3c>
   1585a:	4a05      	ldr	r2, [pc, #20]	; (15870 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x44>)
   1585c:	9b01      	ldr	r3, [sp, #4]
   1585e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15862:	2b00      	cmp	r3, #0
   15864:	d100      	bne.n	15868 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   15866:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   15868:	bf00      	nop
   1586a:	b003      	add	sp, #12
   1586c:	f85d fb04 	ldr.w	pc, [sp], #4
   15870:	1fff97d4 	.word	0x1fff97d4
   15874:	1fff97d0 	.word	0x1fff97d0

00015878 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18(void)
{
   15878:	b500      	push	{lr}
   1587a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1587c:	f7eb fa4e 	bl	d1c <Sys_GetCoreID>
   15880:	4603      	mov	r3, r0
   15882:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId])
   15884:	4a10      	ldr	r2, [pc, #64]	; (158c8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x50>)
   15886:	9b01      	ldr	r3, [sp, #4]
   15888:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1588c:	2b00      	cmp	r3, #0
   1588e:	d10d      	bne.n	158ac <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   15890:	f7eb f89d 	bl	9ce <Port_schm_read_msr>
   15894:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   15896:	9b00      	ldr	r3, [sp, #0]
   15898:	f003 0301 	and.w	r3, r3, #1
   1589c:	2b00      	cmp	r3, #0
   1589e:	d100      	bne.n	158a2 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   158a0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_18[u32CoreId] = msr;
   158a2:	490a      	ldr	r1, [pc, #40]	; (158cc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x54>)
   158a4:	9b01      	ldr	r3, [sp, #4]
   158a6:	9a00      	ldr	r2, [sp, #0]
   158a8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId]++;
   158ac:	4a06      	ldr	r2, [pc, #24]	; (158c8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x50>)
   158ae:	9b01      	ldr	r3, [sp, #4]
   158b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   158b4:	1c5a      	adds	r2, r3, #1
   158b6:	4904      	ldr	r1, [pc, #16]	; (158c8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x50>)
   158b8:	9b01      	ldr	r3, [sp, #4]
   158ba:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   158be:	bf00      	nop
   158c0:	b003      	add	sp, #12
   158c2:	f85d fb04 	ldr.w	pc, [sp], #4
   158c6:	bf00      	nop
   158c8:	1fff97dc 	.word	0x1fff97dc
   158cc:	1fff97d8 	.word	0x1fff97d8

000158d0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18(void)
{
   158d0:	b500      	push	{lr}
   158d2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   158d4:	f7eb fa22 	bl	d1c <Sys_GetCoreID>
   158d8:	4603      	mov	r3, r0
   158da:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId]--;
   158dc:	4a0d      	ldr	r2, [pc, #52]	; (15914 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x44>)
   158de:	9b01      	ldr	r3, [sp, #4]
   158e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   158e4:	1e5a      	subs	r2, r3, #1
   158e6:	490b      	ldr	r1, [pc, #44]	; (15914 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x44>)
   158e8:	9b01      	ldr	r3, [sp, #4]
   158ea:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_18[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId]))         /*if interrupts were enabled*/
   158ee:	4a0a      	ldr	r2, [pc, #40]	; (15918 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x48>)
   158f0:	9b01      	ldr	r3, [sp, #4]
   158f2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   158f6:	f003 0301 	and.w	r3, r3, #1
   158fa:	2b00      	cmp	r3, #0
   158fc:	d106      	bne.n	1590c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x3c>
   158fe:	4a05      	ldr	r2, [pc, #20]	; (15914 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x44>)
   15900:	9b01      	ldr	r3, [sp, #4]
   15902:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15906:	2b00      	cmp	r3, #0
   15908:	d100      	bne.n	1590c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1590a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   1590c:	bf00      	nop
   1590e:	b003      	add	sp, #12
   15910:	f85d fb04 	ldr.w	pc, [sp], #4
   15914:	1fff97dc 	.word	0x1fff97dc
   15918:	1fff97d8 	.word	0x1fff97d8

0001591c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19(void)
{
   1591c:	b500      	push	{lr}
   1591e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15920:	f7eb f9fc 	bl	d1c <Sys_GetCoreID>
   15924:	4603      	mov	r3, r0
   15926:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId])
   15928:	4a10      	ldr	r2, [pc, #64]	; (1596c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x50>)
   1592a:	9b01      	ldr	r3, [sp, #4]
   1592c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15930:	2b00      	cmp	r3, #0
   15932:	d10d      	bne.n	15950 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   15934:	f7eb f84b 	bl	9ce <Port_schm_read_msr>
   15938:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1593a:	9b00      	ldr	r3, [sp, #0]
   1593c:	f003 0301 	and.w	r3, r3, #1
   15940:	2b00      	cmp	r3, #0
   15942:	d100      	bne.n	15946 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   15944:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_19[u32CoreId] = msr;
   15946:	490a      	ldr	r1, [pc, #40]	; (15970 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x54>)
   15948:	9b01      	ldr	r3, [sp, #4]
   1594a:	9a00      	ldr	r2, [sp, #0]
   1594c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId]++;
   15950:	4a06      	ldr	r2, [pc, #24]	; (1596c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x50>)
   15952:	9b01      	ldr	r3, [sp, #4]
   15954:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15958:	1c5a      	adds	r2, r3, #1
   1595a:	4904      	ldr	r1, [pc, #16]	; (1596c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x50>)
   1595c:	9b01      	ldr	r3, [sp, #4]
   1595e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   15962:	bf00      	nop
   15964:	b003      	add	sp, #12
   15966:	f85d fb04 	ldr.w	pc, [sp], #4
   1596a:	bf00      	nop
   1596c:	1fff97e4 	.word	0x1fff97e4
   15970:	1fff97e0 	.word	0x1fff97e0

00015974 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19(void)
{
   15974:	b500      	push	{lr}
   15976:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15978:	f7eb f9d0 	bl	d1c <Sys_GetCoreID>
   1597c:	4603      	mov	r3, r0
   1597e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId]--;
   15980:	4a0d      	ldr	r2, [pc, #52]	; (159b8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x44>)
   15982:	9b01      	ldr	r3, [sp, #4]
   15984:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15988:	1e5a      	subs	r2, r3, #1
   1598a:	490b      	ldr	r1, [pc, #44]	; (159b8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x44>)
   1598c:	9b01      	ldr	r3, [sp, #4]
   1598e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_19[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId]))         /*if interrupts were enabled*/
   15992:	4a0a      	ldr	r2, [pc, #40]	; (159bc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x48>)
   15994:	9b01      	ldr	r3, [sp, #4]
   15996:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1599a:	f003 0301 	and.w	r3, r3, #1
   1599e:	2b00      	cmp	r3, #0
   159a0:	d106      	bne.n	159b0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x3c>
   159a2:	4a05      	ldr	r2, [pc, #20]	; (159b8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x44>)
   159a4:	9b01      	ldr	r3, [sp, #4]
   159a6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   159aa:	2b00      	cmp	r3, #0
   159ac:	d100      	bne.n	159b0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   159ae:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   159b0:	bf00      	nop
   159b2:	b003      	add	sp, #12
   159b4:	f85d fb04 	ldr.w	pc, [sp], #4
   159b8:	1fff97e4 	.word	0x1fff97e4
   159bc:	1fff97e0 	.word	0x1fff97e0

000159c0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20(void)
{
   159c0:	b500      	push	{lr}
   159c2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   159c4:	f7eb f9aa 	bl	d1c <Sys_GetCoreID>
   159c8:	4603      	mov	r3, r0
   159ca:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId])
   159cc:	4a10      	ldr	r2, [pc, #64]	; (15a10 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x50>)
   159ce:	9b01      	ldr	r3, [sp, #4]
   159d0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   159d4:	2b00      	cmp	r3, #0
   159d6:	d10d      	bne.n	159f4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   159d8:	f7ea fff9 	bl	9ce <Port_schm_read_msr>
   159dc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   159de:	9b00      	ldr	r3, [sp, #0]
   159e0:	f003 0301 	and.w	r3, r3, #1
   159e4:	2b00      	cmp	r3, #0
   159e6:	d100      	bne.n	159ea <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   159e8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_20[u32CoreId] = msr;
   159ea:	490a      	ldr	r1, [pc, #40]	; (15a14 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x54>)
   159ec:	9b01      	ldr	r3, [sp, #4]
   159ee:	9a00      	ldr	r2, [sp, #0]
   159f0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId]++;
   159f4:	4a06      	ldr	r2, [pc, #24]	; (15a10 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x50>)
   159f6:	9b01      	ldr	r3, [sp, #4]
   159f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   159fc:	1c5a      	adds	r2, r3, #1
   159fe:	4904      	ldr	r1, [pc, #16]	; (15a10 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x50>)
   15a00:	9b01      	ldr	r3, [sp, #4]
   15a02:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   15a06:	bf00      	nop
   15a08:	b003      	add	sp, #12
   15a0a:	f85d fb04 	ldr.w	pc, [sp], #4
   15a0e:	bf00      	nop
   15a10:	1fff97ec 	.word	0x1fff97ec
   15a14:	1fff97e8 	.word	0x1fff97e8

00015a18 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20(void)
{
   15a18:	b500      	push	{lr}
   15a1a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15a1c:	f7eb f97e 	bl	d1c <Sys_GetCoreID>
   15a20:	4603      	mov	r3, r0
   15a22:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId]--;
   15a24:	4a0d      	ldr	r2, [pc, #52]	; (15a5c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x44>)
   15a26:	9b01      	ldr	r3, [sp, #4]
   15a28:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15a2c:	1e5a      	subs	r2, r3, #1
   15a2e:	490b      	ldr	r1, [pc, #44]	; (15a5c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x44>)
   15a30:	9b01      	ldr	r3, [sp, #4]
   15a32:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_20[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId]))         /*if interrupts were enabled*/
   15a36:	4a0a      	ldr	r2, [pc, #40]	; (15a60 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x48>)
   15a38:	9b01      	ldr	r3, [sp, #4]
   15a3a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15a3e:	f003 0301 	and.w	r3, r3, #1
   15a42:	2b00      	cmp	r3, #0
   15a44:	d106      	bne.n	15a54 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x3c>
   15a46:	4a05      	ldr	r2, [pc, #20]	; (15a5c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x44>)
   15a48:	9b01      	ldr	r3, [sp, #4]
   15a4a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15a4e:	2b00      	cmp	r3, #0
   15a50:	d100      	bne.n	15a54 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   15a52:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   15a54:	bf00      	nop
   15a56:	b003      	add	sp, #12
   15a58:	f85d fb04 	ldr.w	pc, [sp], #4
   15a5c:	1fff97ec 	.word	0x1fff97ec
   15a60:	1fff97e8 	.word	0x1fff97e8

00015a64 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21(void)
{
   15a64:	b500      	push	{lr}
   15a66:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15a68:	f7eb f958 	bl	d1c <Sys_GetCoreID>
   15a6c:	4603      	mov	r3, r0
   15a6e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId])
   15a70:	4a10      	ldr	r2, [pc, #64]	; (15ab4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x50>)
   15a72:	9b01      	ldr	r3, [sp, #4]
   15a74:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15a78:	2b00      	cmp	r3, #0
   15a7a:	d10d      	bne.n	15a98 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   15a7c:	f7ea ffa7 	bl	9ce <Port_schm_read_msr>
   15a80:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   15a82:	9b00      	ldr	r3, [sp, #0]
   15a84:	f003 0301 	and.w	r3, r3, #1
   15a88:	2b00      	cmp	r3, #0
   15a8a:	d100      	bne.n	15a8e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   15a8c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_21[u32CoreId] = msr;
   15a8e:	490a      	ldr	r1, [pc, #40]	; (15ab8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x54>)
   15a90:	9b01      	ldr	r3, [sp, #4]
   15a92:	9a00      	ldr	r2, [sp, #0]
   15a94:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId]++;
   15a98:	4a06      	ldr	r2, [pc, #24]	; (15ab4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x50>)
   15a9a:	9b01      	ldr	r3, [sp, #4]
   15a9c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15aa0:	1c5a      	adds	r2, r3, #1
   15aa2:	4904      	ldr	r1, [pc, #16]	; (15ab4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x50>)
   15aa4:	9b01      	ldr	r3, [sp, #4]
   15aa6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   15aaa:	bf00      	nop
   15aac:	b003      	add	sp, #12
   15aae:	f85d fb04 	ldr.w	pc, [sp], #4
   15ab2:	bf00      	nop
   15ab4:	1fff97f4 	.word	0x1fff97f4
   15ab8:	1fff97f0 	.word	0x1fff97f0

00015abc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21(void)
{
   15abc:	b500      	push	{lr}
   15abe:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15ac0:	f7eb f92c 	bl	d1c <Sys_GetCoreID>
   15ac4:	4603      	mov	r3, r0
   15ac6:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId]--;
   15ac8:	4a0d      	ldr	r2, [pc, #52]	; (15b00 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x44>)
   15aca:	9b01      	ldr	r3, [sp, #4]
   15acc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15ad0:	1e5a      	subs	r2, r3, #1
   15ad2:	490b      	ldr	r1, [pc, #44]	; (15b00 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x44>)
   15ad4:	9b01      	ldr	r3, [sp, #4]
   15ad6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_21[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId]))         /*if interrupts were enabled*/
   15ada:	4a0a      	ldr	r2, [pc, #40]	; (15b04 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x48>)
   15adc:	9b01      	ldr	r3, [sp, #4]
   15ade:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15ae2:	f003 0301 	and.w	r3, r3, #1
   15ae6:	2b00      	cmp	r3, #0
   15ae8:	d106      	bne.n	15af8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x3c>
   15aea:	4a05      	ldr	r2, [pc, #20]	; (15b00 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x44>)
   15aec:	9b01      	ldr	r3, [sp, #4]
   15aee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15af2:	2b00      	cmp	r3, #0
   15af4:	d100      	bne.n	15af8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   15af6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   15af8:	bf00      	nop
   15afa:	b003      	add	sp, #12
   15afc:	f85d fb04 	ldr.w	pc, [sp], #4
   15b00:	1fff97f4 	.word	0x1fff97f4
   15b04:	1fff97f0 	.word	0x1fff97f0

00015b08 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22(void)
{
   15b08:	b500      	push	{lr}
   15b0a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15b0c:	f7eb f906 	bl	d1c <Sys_GetCoreID>
   15b10:	4603      	mov	r3, r0
   15b12:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId])
   15b14:	4a10      	ldr	r2, [pc, #64]	; (15b58 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x50>)
   15b16:	9b01      	ldr	r3, [sp, #4]
   15b18:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15b1c:	2b00      	cmp	r3, #0
   15b1e:	d10d      	bne.n	15b3c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   15b20:	f7ea ff55 	bl	9ce <Port_schm_read_msr>
   15b24:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   15b26:	9b00      	ldr	r3, [sp, #0]
   15b28:	f003 0301 	and.w	r3, r3, #1
   15b2c:	2b00      	cmp	r3, #0
   15b2e:	d100      	bne.n	15b32 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   15b30:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_22[u32CoreId] = msr;
   15b32:	490a      	ldr	r1, [pc, #40]	; (15b5c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x54>)
   15b34:	9b01      	ldr	r3, [sp, #4]
   15b36:	9a00      	ldr	r2, [sp, #0]
   15b38:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId]++;
   15b3c:	4a06      	ldr	r2, [pc, #24]	; (15b58 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x50>)
   15b3e:	9b01      	ldr	r3, [sp, #4]
   15b40:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15b44:	1c5a      	adds	r2, r3, #1
   15b46:	4904      	ldr	r1, [pc, #16]	; (15b58 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x50>)
   15b48:	9b01      	ldr	r3, [sp, #4]
   15b4a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   15b4e:	bf00      	nop
   15b50:	b003      	add	sp, #12
   15b52:	f85d fb04 	ldr.w	pc, [sp], #4
   15b56:	bf00      	nop
   15b58:	1fff97fc 	.word	0x1fff97fc
   15b5c:	1fff97f8 	.word	0x1fff97f8

00015b60 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22(void)
{
   15b60:	b500      	push	{lr}
   15b62:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15b64:	f7eb f8da 	bl	d1c <Sys_GetCoreID>
   15b68:	4603      	mov	r3, r0
   15b6a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId]--;
   15b6c:	4a0d      	ldr	r2, [pc, #52]	; (15ba4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x44>)
   15b6e:	9b01      	ldr	r3, [sp, #4]
   15b70:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15b74:	1e5a      	subs	r2, r3, #1
   15b76:	490b      	ldr	r1, [pc, #44]	; (15ba4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x44>)
   15b78:	9b01      	ldr	r3, [sp, #4]
   15b7a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_22[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId]))         /*if interrupts were enabled*/
   15b7e:	4a0a      	ldr	r2, [pc, #40]	; (15ba8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x48>)
   15b80:	9b01      	ldr	r3, [sp, #4]
   15b82:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15b86:	f003 0301 	and.w	r3, r3, #1
   15b8a:	2b00      	cmp	r3, #0
   15b8c:	d106      	bne.n	15b9c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x3c>
   15b8e:	4a05      	ldr	r2, [pc, #20]	; (15ba4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x44>)
   15b90:	9b01      	ldr	r3, [sp, #4]
   15b92:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15b96:	2b00      	cmp	r3, #0
   15b98:	d100      	bne.n	15b9c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   15b9a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   15b9c:	bf00      	nop
   15b9e:	b003      	add	sp, #12
   15ba0:	f85d fb04 	ldr.w	pc, [sp], #4
   15ba4:	1fff97fc 	.word	0x1fff97fc
   15ba8:	1fff97f8 	.word	0x1fff97f8

00015bac <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23(void)
{
   15bac:	b500      	push	{lr}
   15bae:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15bb0:	f7eb f8b4 	bl	d1c <Sys_GetCoreID>
   15bb4:	4603      	mov	r3, r0
   15bb6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId])
   15bb8:	4a10      	ldr	r2, [pc, #64]	; (15bfc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x50>)
   15bba:	9b01      	ldr	r3, [sp, #4]
   15bbc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15bc0:	2b00      	cmp	r3, #0
   15bc2:	d10d      	bne.n	15be0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   15bc4:	f7ea ff03 	bl	9ce <Port_schm_read_msr>
   15bc8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   15bca:	9b00      	ldr	r3, [sp, #0]
   15bcc:	f003 0301 	and.w	r3, r3, #1
   15bd0:	2b00      	cmp	r3, #0
   15bd2:	d100      	bne.n	15bd6 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   15bd4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_23[u32CoreId] = msr;
   15bd6:	490a      	ldr	r1, [pc, #40]	; (15c00 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x54>)
   15bd8:	9b01      	ldr	r3, [sp, #4]
   15bda:	9a00      	ldr	r2, [sp, #0]
   15bdc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId]++;
   15be0:	4a06      	ldr	r2, [pc, #24]	; (15bfc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x50>)
   15be2:	9b01      	ldr	r3, [sp, #4]
   15be4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15be8:	1c5a      	adds	r2, r3, #1
   15bea:	4904      	ldr	r1, [pc, #16]	; (15bfc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x50>)
   15bec:	9b01      	ldr	r3, [sp, #4]
   15bee:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   15bf2:	bf00      	nop
   15bf4:	b003      	add	sp, #12
   15bf6:	f85d fb04 	ldr.w	pc, [sp], #4
   15bfa:	bf00      	nop
   15bfc:	1fff9804 	.word	0x1fff9804
   15c00:	1fff9800 	.word	0x1fff9800

00015c04 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23(void)
{
   15c04:	b500      	push	{lr}
   15c06:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15c08:	f7eb f888 	bl	d1c <Sys_GetCoreID>
   15c0c:	4603      	mov	r3, r0
   15c0e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId]--;
   15c10:	4a0d      	ldr	r2, [pc, #52]	; (15c48 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x44>)
   15c12:	9b01      	ldr	r3, [sp, #4]
   15c14:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15c18:	1e5a      	subs	r2, r3, #1
   15c1a:	490b      	ldr	r1, [pc, #44]	; (15c48 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x44>)
   15c1c:	9b01      	ldr	r3, [sp, #4]
   15c1e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_23[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId]))         /*if interrupts were enabled*/
   15c22:	4a0a      	ldr	r2, [pc, #40]	; (15c4c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x48>)
   15c24:	9b01      	ldr	r3, [sp, #4]
   15c26:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15c2a:	f003 0301 	and.w	r3, r3, #1
   15c2e:	2b00      	cmp	r3, #0
   15c30:	d106      	bne.n	15c40 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x3c>
   15c32:	4a05      	ldr	r2, [pc, #20]	; (15c48 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x44>)
   15c34:	9b01      	ldr	r3, [sp, #4]
   15c36:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15c3a:	2b00      	cmp	r3, #0
   15c3c:	d100      	bne.n	15c40 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   15c3e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   15c40:	bf00      	nop
   15c42:	b003      	add	sp, #12
   15c44:	f85d fb04 	ldr.w	pc, [sp], #4
   15c48:	1fff9804 	.word	0x1fff9804
   15c4c:	1fff9800 	.word	0x1fff9800

00015c50 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24(void)
{
   15c50:	b500      	push	{lr}
   15c52:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15c54:	f7eb f862 	bl	d1c <Sys_GetCoreID>
   15c58:	4603      	mov	r3, r0
   15c5a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId])
   15c5c:	4a10      	ldr	r2, [pc, #64]	; (15ca0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x50>)
   15c5e:	9b01      	ldr	r3, [sp, #4]
   15c60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15c64:	2b00      	cmp	r3, #0
   15c66:	d10d      	bne.n	15c84 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   15c68:	f7ea feb1 	bl	9ce <Port_schm_read_msr>
   15c6c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   15c6e:	9b00      	ldr	r3, [sp, #0]
   15c70:	f003 0301 	and.w	r3, r3, #1
   15c74:	2b00      	cmp	r3, #0
   15c76:	d100      	bne.n	15c7a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   15c78:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_24[u32CoreId] = msr;
   15c7a:	490a      	ldr	r1, [pc, #40]	; (15ca4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x54>)
   15c7c:	9b01      	ldr	r3, [sp, #4]
   15c7e:	9a00      	ldr	r2, [sp, #0]
   15c80:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId]++;
   15c84:	4a06      	ldr	r2, [pc, #24]	; (15ca0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x50>)
   15c86:	9b01      	ldr	r3, [sp, #4]
   15c88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15c8c:	1c5a      	adds	r2, r3, #1
   15c8e:	4904      	ldr	r1, [pc, #16]	; (15ca0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x50>)
   15c90:	9b01      	ldr	r3, [sp, #4]
   15c92:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   15c96:	bf00      	nop
   15c98:	b003      	add	sp, #12
   15c9a:	f85d fb04 	ldr.w	pc, [sp], #4
   15c9e:	bf00      	nop
   15ca0:	1fff980c 	.word	0x1fff980c
   15ca4:	1fff9808 	.word	0x1fff9808

00015ca8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24(void)
{
   15ca8:	b500      	push	{lr}
   15caa:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15cac:	f7eb f836 	bl	d1c <Sys_GetCoreID>
   15cb0:	4603      	mov	r3, r0
   15cb2:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId]--;
   15cb4:	4a0d      	ldr	r2, [pc, #52]	; (15cec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x44>)
   15cb6:	9b01      	ldr	r3, [sp, #4]
   15cb8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15cbc:	1e5a      	subs	r2, r3, #1
   15cbe:	490b      	ldr	r1, [pc, #44]	; (15cec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x44>)
   15cc0:	9b01      	ldr	r3, [sp, #4]
   15cc2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_24[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId]))         /*if interrupts were enabled*/
   15cc6:	4a0a      	ldr	r2, [pc, #40]	; (15cf0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x48>)
   15cc8:	9b01      	ldr	r3, [sp, #4]
   15cca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15cce:	f003 0301 	and.w	r3, r3, #1
   15cd2:	2b00      	cmp	r3, #0
   15cd4:	d106      	bne.n	15ce4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x3c>
   15cd6:	4a05      	ldr	r2, [pc, #20]	; (15cec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x44>)
   15cd8:	9b01      	ldr	r3, [sp, #4]
   15cda:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15cde:	2b00      	cmp	r3, #0
   15ce0:	d100      	bne.n	15ce4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   15ce2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   15ce4:	bf00      	nop
   15ce6:	b003      	add	sp, #12
   15ce8:	f85d fb04 	ldr.w	pc, [sp], #4
   15cec:	1fff980c 	.word	0x1fff980c
   15cf0:	1fff9808 	.word	0x1fff9808

00015cf4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25(void)
{
   15cf4:	b500      	push	{lr}
   15cf6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15cf8:	f7eb f810 	bl	d1c <Sys_GetCoreID>
   15cfc:	4603      	mov	r3, r0
   15cfe:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId])
   15d00:	4a10      	ldr	r2, [pc, #64]	; (15d44 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x50>)
   15d02:	9b01      	ldr	r3, [sp, #4]
   15d04:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15d08:	2b00      	cmp	r3, #0
   15d0a:	d10d      	bne.n	15d28 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   15d0c:	f7ea fe5f 	bl	9ce <Port_schm_read_msr>
   15d10:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   15d12:	9b00      	ldr	r3, [sp, #0]
   15d14:	f003 0301 	and.w	r3, r3, #1
   15d18:	2b00      	cmp	r3, #0
   15d1a:	d100      	bne.n	15d1e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   15d1c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_25[u32CoreId] = msr;
   15d1e:	490a      	ldr	r1, [pc, #40]	; (15d48 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x54>)
   15d20:	9b01      	ldr	r3, [sp, #4]
   15d22:	9a00      	ldr	r2, [sp, #0]
   15d24:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId]++;
   15d28:	4a06      	ldr	r2, [pc, #24]	; (15d44 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x50>)
   15d2a:	9b01      	ldr	r3, [sp, #4]
   15d2c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15d30:	1c5a      	adds	r2, r3, #1
   15d32:	4904      	ldr	r1, [pc, #16]	; (15d44 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x50>)
   15d34:	9b01      	ldr	r3, [sp, #4]
   15d36:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   15d3a:	bf00      	nop
   15d3c:	b003      	add	sp, #12
   15d3e:	f85d fb04 	ldr.w	pc, [sp], #4
   15d42:	bf00      	nop
   15d44:	1fff9814 	.word	0x1fff9814
   15d48:	1fff9810 	.word	0x1fff9810

00015d4c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25(void)
{
   15d4c:	b500      	push	{lr}
   15d4e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15d50:	f7ea ffe4 	bl	d1c <Sys_GetCoreID>
   15d54:	4603      	mov	r3, r0
   15d56:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId]--;
   15d58:	4a0d      	ldr	r2, [pc, #52]	; (15d90 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x44>)
   15d5a:	9b01      	ldr	r3, [sp, #4]
   15d5c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15d60:	1e5a      	subs	r2, r3, #1
   15d62:	490b      	ldr	r1, [pc, #44]	; (15d90 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x44>)
   15d64:	9b01      	ldr	r3, [sp, #4]
   15d66:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_25[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId]))         /*if interrupts were enabled*/
   15d6a:	4a0a      	ldr	r2, [pc, #40]	; (15d94 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x48>)
   15d6c:	9b01      	ldr	r3, [sp, #4]
   15d6e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15d72:	f003 0301 	and.w	r3, r3, #1
   15d76:	2b00      	cmp	r3, #0
   15d78:	d106      	bne.n	15d88 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x3c>
   15d7a:	4a05      	ldr	r2, [pc, #20]	; (15d90 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x44>)
   15d7c:	9b01      	ldr	r3, [sp, #4]
   15d7e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15d82:	2b00      	cmp	r3, #0
   15d84:	d100      	bne.n	15d88 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   15d86:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   15d88:	bf00      	nop
   15d8a:	b003      	add	sp, #12
   15d8c:	f85d fb04 	ldr.w	pc, [sp], #4
   15d90:	1fff9814 	.word	0x1fff9814
   15d94:	1fff9810 	.word	0x1fff9810

00015d98 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26(void)
{
   15d98:	b500      	push	{lr}
   15d9a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15d9c:	f7ea ffbe 	bl	d1c <Sys_GetCoreID>
   15da0:	4603      	mov	r3, r0
   15da2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId])
   15da4:	4a10      	ldr	r2, [pc, #64]	; (15de8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x50>)
   15da6:	9b01      	ldr	r3, [sp, #4]
   15da8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15dac:	2b00      	cmp	r3, #0
   15dae:	d10d      	bne.n	15dcc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   15db0:	f7ea fe0d 	bl	9ce <Port_schm_read_msr>
   15db4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   15db6:	9b00      	ldr	r3, [sp, #0]
   15db8:	f003 0301 	and.w	r3, r3, #1
   15dbc:	2b00      	cmp	r3, #0
   15dbe:	d100      	bne.n	15dc2 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   15dc0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_26[u32CoreId] = msr;
   15dc2:	490a      	ldr	r1, [pc, #40]	; (15dec <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x54>)
   15dc4:	9b01      	ldr	r3, [sp, #4]
   15dc6:	9a00      	ldr	r2, [sp, #0]
   15dc8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId]++;
   15dcc:	4a06      	ldr	r2, [pc, #24]	; (15de8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x50>)
   15dce:	9b01      	ldr	r3, [sp, #4]
   15dd0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15dd4:	1c5a      	adds	r2, r3, #1
   15dd6:	4904      	ldr	r1, [pc, #16]	; (15de8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x50>)
   15dd8:	9b01      	ldr	r3, [sp, #4]
   15dda:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   15dde:	bf00      	nop
   15de0:	b003      	add	sp, #12
   15de2:	f85d fb04 	ldr.w	pc, [sp], #4
   15de6:	bf00      	nop
   15de8:	1fff981c 	.word	0x1fff981c
   15dec:	1fff9818 	.word	0x1fff9818

00015df0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26(void)
{
   15df0:	b500      	push	{lr}
   15df2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15df4:	f7ea ff92 	bl	d1c <Sys_GetCoreID>
   15df8:	4603      	mov	r3, r0
   15dfa:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId]--;
   15dfc:	4a0d      	ldr	r2, [pc, #52]	; (15e34 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x44>)
   15dfe:	9b01      	ldr	r3, [sp, #4]
   15e00:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15e04:	1e5a      	subs	r2, r3, #1
   15e06:	490b      	ldr	r1, [pc, #44]	; (15e34 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x44>)
   15e08:	9b01      	ldr	r3, [sp, #4]
   15e0a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_26[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId]))         /*if interrupts were enabled*/
   15e0e:	4a0a      	ldr	r2, [pc, #40]	; (15e38 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x48>)
   15e10:	9b01      	ldr	r3, [sp, #4]
   15e12:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15e16:	f003 0301 	and.w	r3, r3, #1
   15e1a:	2b00      	cmp	r3, #0
   15e1c:	d106      	bne.n	15e2c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x3c>
   15e1e:	4a05      	ldr	r2, [pc, #20]	; (15e34 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x44>)
   15e20:	9b01      	ldr	r3, [sp, #4]
   15e22:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15e26:	2b00      	cmp	r3, #0
   15e28:	d100      	bne.n	15e2c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   15e2a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   15e2c:	bf00      	nop
   15e2e:	b003      	add	sp, #12
   15e30:	f85d fb04 	ldr.w	pc, [sp], #4
   15e34:	1fff981c 	.word	0x1fff981c
   15e38:	1fff9818 	.word	0x1fff9818

00015e3c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27(void)
{
   15e3c:	b500      	push	{lr}
   15e3e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15e40:	f7ea ff6c 	bl	d1c <Sys_GetCoreID>
   15e44:	4603      	mov	r3, r0
   15e46:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId])
   15e48:	4a10      	ldr	r2, [pc, #64]	; (15e8c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x50>)
   15e4a:	9b01      	ldr	r3, [sp, #4]
   15e4c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15e50:	2b00      	cmp	r3, #0
   15e52:	d10d      	bne.n	15e70 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   15e54:	f7ea fdbb 	bl	9ce <Port_schm_read_msr>
   15e58:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   15e5a:	9b00      	ldr	r3, [sp, #0]
   15e5c:	f003 0301 	and.w	r3, r3, #1
   15e60:	2b00      	cmp	r3, #0
   15e62:	d100      	bne.n	15e66 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   15e64:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_27[u32CoreId] = msr;
   15e66:	490a      	ldr	r1, [pc, #40]	; (15e90 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x54>)
   15e68:	9b01      	ldr	r3, [sp, #4]
   15e6a:	9a00      	ldr	r2, [sp, #0]
   15e6c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId]++;
   15e70:	4a06      	ldr	r2, [pc, #24]	; (15e8c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x50>)
   15e72:	9b01      	ldr	r3, [sp, #4]
   15e74:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15e78:	1c5a      	adds	r2, r3, #1
   15e7a:	4904      	ldr	r1, [pc, #16]	; (15e8c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x50>)
   15e7c:	9b01      	ldr	r3, [sp, #4]
   15e7e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   15e82:	bf00      	nop
   15e84:	b003      	add	sp, #12
   15e86:	f85d fb04 	ldr.w	pc, [sp], #4
   15e8a:	bf00      	nop
   15e8c:	1fff9824 	.word	0x1fff9824
   15e90:	1fff9820 	.word	0x1fff9820

00015e94 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27(void)
{
   15e94:	b500      	push	{lr}
   15e96:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15e98:	f7ea ff40 	bl	d1c <Sys_GetCoreID>
   15e9c:	4603      	mov	r3, r0
   15e9e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId]--;
   15ea0:	4a0d      	ldr	r2, [pc, #52]	; (15ed8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x44>)
   15ea2:	9b01      	ldr	r3, [sp, #4]
   15ea4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15ea8:	1e5a      	subs	r2, r3, #1
   15eaa:	490b      	ldr	r1, [pc, #44]	; (15ed8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x44>)
   15eac:	9b01      	ldr	r3, [sp, #4]
   15eae:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_27[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId]))         /*if interrupts were enabled*/
   15eb2:	4a0a      	ldr	r2, [pc, #40]	; (15edc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x48>)
   15eb4:	9b01      	ldr	r3, [sp, #4]
   15eb6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15eba:	f003 0301 	and.w	r3, r3, #1
   15ebe:	2b00      	cmp	r3, #0
   15ec0:	d106      	bne.n	15ed0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x3c>
   15ec2:	4a05      	ldr	r2, [pc, #20]	; (15ed8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x44>)
   15ec4:	9b01      	ldr	r3, [sp, #4]
   15ec6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15eca:	2b00      	cmp	r3, #0
   15ecc:	d100      	bne.n	15ed0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   15ece:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   15ed0:	bf00      	nop
   15ed2:	b003      	add	sp, #12
   15ed4:	f85d fb04 	ldr.w	pc, [sp], #4
   15ed8:	1fff9824 	.word	0x1fff9824
   15edc:	1fff9820 	.word	0x1fff9820

00015ee0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_00(void)
{
   15ee0:	b500      	push	{lr}
   15ee2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15ee4:	f7ea ff1a 	bl	d1c <Sys_GetCoreID>
   15ee8:	4603      	mov	r3, r0
   15eea:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_00[u32CoreId])
   15eec:	4a10      	ldr	r2, [pc, #64]	; (15f30 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_00+0x50>)
   15eee:	9b01      	ldr	r3, [sp, #4]
   15ef0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15ef4:	2b00      	cmp	r3, #0
   15ef6:	d10d      	bne.n	15f14 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
   15ef8:	f7ea fd72 	bl	9e0 <Spi_schm_read_msr>
   15efc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   15efe:	9b00      	ldr	r3, [sp, #0]
   15f00:	f003 0301 	and.w	r3, r3, #1
   15f04:	2b00      	cmp	r3, #0
   15f06:	d100      	bne.n	15f0a <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   15f08:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_00[u32CoreId] = msr;
   15f0a:	490a      	ldr	r1, [pc, #40]	; (15f34 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_00+0x54>)
   15f0c:	9b01      	ldr	r3, [sp, #4]
   15f0e:	9a00      	ldr	r2, [sp, #0]
   15f10:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_00[u32CoreId]++;
   15f14:	4a06      	ldr	r2, [pc, #24]	; (15f30 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_00+0x50>)
   15f16:	9b01      	ldr	r3, [sp, #4]
   15f18:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15f1c:	1c5a      	adds	r2, r3, #1
   15f1e:	4904      	ldr	r1, [pc, #16]	; (15f30 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_00+0x50>)
   15f20:	9b01      	ldr	r3, [sp, #4]
   15f22:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   15f26:	bf00      	nop
   15f28:	b003      	add	sp, #12
   15f2a:	f85d fb04 	ldr.w	pc, [sp], #4
   15f2e:	bf00      	nop
   15f30:	1fff982c 	.word	0x1fff982c
   15f34:	1fff9828 	.word	0x1fff9828

00015f38 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_00>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_00(void)
{
   15f38:	b500      	push	{lr}
   15f3a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15f3c:	f7ea feee 	bl	d1c <Sys_GetCoreID>
   15f40:	4603      	mov	r3, r0
   15f42:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_00[u32CoreId]--;
   15f44:	4a0d      	ldr	r2, [pc, #52]	; (15f7c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_00+0x44>)
   15f46:	9b01      	ldr	r3, [sp, #4]
   15f48:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15f4c:	1e5a      	subs	r2, r3, #1
   15f4e:	490b      	ldr	r1, [pc, #44]	; (15f7c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_00+0x44>)
   15f50:	9b01      	ldr	r3, [sp, #4]
   15f52:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
   15f56:	4a0a      	ldr	r2, [pc, #40]	; (15f80 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_00+0x48>)
   15f58:	9b01      	ldr	r3, [sp, #4]
   15f5a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15f5e:	f003 0301 	and.w	r3, r3, #1
   15f62:	2b00      	cmp	r3, #0
   15f64:	d106      	bne.n	15f74 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_00+0x3c>
   15f66:	4a05      	ldr	r2, [pc, #20]	; (15f7c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_00+0x44>)
   15f68:	9b01      	ldr	r3, [sp, #4]
   15f6a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15f6e:	2b00      	cmp	r3, #0
   15f70:	d100      	bne.n	15f74 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   15f72:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   15f74:	bf00      	nop
   15f76:	b003      	add	sp, #12
   15f78:	f85d fb04 	ldr.w	pc, [sp], #4
   15f7c:	1fff982c 	.word	0x1fff982c
   15f80:	1fff9828 	.word	0x1fff9828

00015f84 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_01>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_01(void)
{
   15f84:	b500      	push	{lr}
   15f86:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15f88:	f7ea fec8 	bl	d1c <Sys_GetCoreID>
   15f8c:	4603      	mov	r3, r0
   15f8e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_01[u32CoreId])
   15f90:	4a10      	ldr	r2, [pc, #64]	; (15fd4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_01+0x50>)
   15f92:	9b01      	ldr	r3, [sp, #4]
   15f94:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15f98:	2b00      	cmp	r3, #0
   15f9a:	d10d      	bne.n	15fb8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
   15f9c:	f7ea fd20 	bl	9e0 <Spi_schm_read_msr>
   15fa0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   15fa2:	9b00      	ldr	r3, [sp, #0]
   15fa4:	f003 0301 	and.w	r3, r3, #1
   15fa8:	2b00      	cmp	r3, #0
   15faa:	d100      	bne.n	15fae <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   15fac:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_01[u32CoreId] = msr;
   15fae:	490a      	ldr	r1, [pc, #40]	; (15fd8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_01+0x54>)
   15fb0:	9b01      	ldr	r3, [sp, #4]
   15fb2:	9a00      	ldr	r2, [sp, #0]
   15fb4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_01[u32CoreId]++;
   15fb8:	4a06      	ldr	r2, [pc, #24]	; (15fd4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_01+0x50>)
   15fba:	9b01      	ldr	r3, [sp, #4]
   15fbc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15fc0:	1c5a      	adds	r2, r3, #1
   15fc2:	4904      	ldr	r1, [pc, #16]	; (15fd4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_01+0x50>)
   15fc4:	9b01      	ldr	r3, [sp, #4]
   15fc6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   15fca:	bf00      	nop
   15fcc:	b003      	add	sp, #12
   15fce:	f85d fb04 	ldr.w	pc, [sp], #4
   15fd2:	bf00      	nop
   15fd4:	1fff9834 	.word	0x1fff9834
   15fd8:	1fff9830 	.word	0x1fff9830

00015fdc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_01>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_01(void)
{
   15fdc:	b500      	push	{lr}
   15fde:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   15fe0:	f7ea fe9c 	bl	d1c <Sys_GetCoreID>
   15fe4:	4603      	mov	r3, r0
   15fe6:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_01[u32CoreId]--;
   15fe8:	4a0d      	ldr	r2, [pc, #52]	; (16020 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_01+0x44>)
   15fea:	9b01      	ldr	r3, [sp, #4]
   15fec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   15ff0:	1e5a      	subs	r2, r3, #1
   15ff2:	490b      	ldr	r1, [pc, #44]	; (16020 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_01+0x44>)
   15ff4:	9b01      	ldr	r3, [sp, #4]
   15ff6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
   15ffa:	4a0a      	ldr	r2, [pc, #40]	; (16024 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_01+0x48>)
   15ffc:	9b01      	ldr	r3, [sp, #4]
   15ffe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16002:	f003 0301 	and.w	r3, r3, #1
   16006:	2b00      	cmp	r3, #0
   16008:	d106      	bne.n	16018 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_01+0x3c>
   1600a:	4a05      	ldr	r2, [pc, #20]	; (16020 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_01+0x44>)
   1600c:	9b01      	ldr	r3, [sp, #4]
   1600e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16012:	2b00      	cmp	r3, #0
   16014:	d100      	bne.n	16018 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   16016:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   16018:	bf00      	nop
   1601a:	b003      	add	sp, #12
   1601c:	f85d fb04 	ldr.w	pc, [sp], #4
   16020:	1fff9834 	.word	0x1fff9834
   16024:	1fff9830 	.word	0x1fff9830

00016028 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_02>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_02(void)
{
   16028:	b500      	push	{lr}
   1602a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1602c:	f7ea fe76 	bl	d1c <Sys_GetCoreID>
   16030:	4603      	mov	r3, r0
   16032:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_02[u32CoreId])
   16034:	4a10      	ldr	r2, [pc, #64]	; (16078 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_02+0x50>)
   16036:	9b01      	ldr	r3, [sp, #4]
   16038:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1603c:	2b00      	cmp	r3, #0
   1603e:	d10d      	bne.n	1605c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_02+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
   16040:	f7ea fcce 	bl	9e0 <Spi_schm_read_msr>
   16044:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   16046:	9b00      	ldr	r3, [sp, #0]
   16048:	f003 0301 	and.w	r3, r3, #1
   1604c:	2b00      	cmp	r3, #0
   1604e:	d100      	bne.n	16052 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_02+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   16050:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_02[u32CoreId] = msr;
   16052:	490a      	ldr	r1, [pc, #40]	; (1607c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_02+0x54>)
   16054:	9b01      	ldr	r3, [sp, #4]
   16056:	9a00      	ldr	r2, [sp, #0]
   16058:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_02[u32CoreId]++;
   1605c:	4a06      	ldr	r2, [pc, #24]	; (16078 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_02+0x50>)
   1605e:	9b01      	ldr	r3, [sp, #4]
   16060:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16064:	1c5a      	adds	r2, r3, #1
   16066:	4904      	ldr	r1, [pc, #16]	; (16078 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_02+0x50>)
   16068:	9b01      	ldr	r3, [sp, #4]
   1606a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1606e:	bf00      	nop
   16070:	b003      	add	sp, #12
   16072:	f85d fb04 	ldr.w	pc, [sp], #4
   16076:	bf00      	nop
   16078:	1fff983c 	.word	0x1fff983c
   1607c:	1fff9838 	.word	0x1fff9838

00016080 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_02>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_02(void)
{
   16080:	b500      	push	{lr}
   16082:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   16084:	f7ea fe4a 	bl	d1c <Sys_GetCoreID>
   16088:	4603      	mov	r3, r0
   1608a:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_02[u32CoreId]--;
   1608c:	4a0d      	ldr	r2, [pc, #52]	; (160c4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_02+0x44>)
   1608e:	9b01      	ldr	r3, [sp, #4]
   16090:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16094:	1e5a      	subs	r2, r3, #1
   16096:	490b      	ldr	r1, [pc, #44]	; (160c4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_02+0x44>)
   16098:	9b01      	ldr	r3, [sp, #4]
   1609a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_02[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_02[u32CoreId]))         /*if interrupts were enabled*/
   1609e:	4a0a      	ldr	r2, [pc, #40]	; (160c8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_02+0x48>)
   160a0:	9b01      	ldr	r3, [sp, #4]
   160a2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   160a6:	f003 0301 	and.w	r3, r3, #1
   160aa:	2b00      	cmp	r3, #0
   160ac:	d106      	bne.n	160bc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_02+0x3c>
   160ae:	4a05      	ldr	r2, [pc, #20]	; (160c4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_02+0x44>)
   160b0:	9b01      	ldr	r3, [sp, #4]
   160b2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   160b6:	2b00      	cmp	r3, #0
   160b8:	d100      	bne.n	160bc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_02+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   160ba:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   160bc:	bf00      	nop
   160be:	b003      	add	sp, #12
   160c0:	f85d fb04 	ldr.w	pc, [sp], #4
   160c4:	1fff983c 	.word	0x1fff983c
   160c8:	1fff9838 	.word	0x1fff9838

000160cc <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_03>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_03(void)
{
   160cc:	b500      	push	{lr}
   160ce:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   160d0:	f7ea fe24 	bl	d1c <Sys_GetCoreID>
   160d4:	4603      	mov	r3, r0
   160d6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_03[u32CoreId])
   160d8:	4a10      	ldr	r2, [pc, #64]	; (1611c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_03+0x50>)
   160da:	9b01      	ldr	r3, [sp, #4]
   160dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   160e0:	2b00      	cmp	r3, #0
   160e2:	d10d      	bne.n	16100 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_03+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
   160e4:	f7ea fc7c 	bl	9e0 <Spi_schm_read_msr>
   160e8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   160ea:	9b00      	ldr	r3, [sp, #0]
   160ec:	f003 0301 	and.w	r3, r3, #1
   160f0:	2b00      	cmp	r3, #0
   160f2:	d100      	bne.n	160f6 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_03+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   160f4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_03[u32CoreId] = msr;
   160f6:	490a      	ldr	r1, [pc, #40]	; (16120 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_03+0x54>)
   160f8:	9b01      	ldr	r3, [sp, #4]
   160fa:	9a00      	ldr	r2, [sp, #0]
   160fc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_03[u32CoreId]++;
   16100:	4a06      	ldr	r2, [pc, #24]	; (1611c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_03+0x50>)
   16102:	9b01      	ldr	r3, [sp, #4]
   16104:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16108:	1c5a      	adds	r2, r3, #1
   1610a:	4904      	ldr	r1, [pc, #16]	; (1611c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_03+0x50>)
   1610c:	9b01      	ldr	r3, [sp, #4]
   1610e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   16112:	bf00      	nop
   16114:	b003      	add	sp, #12
   16116:	f85d fb04 	ldr.w	pc, [sp], #4
   1611a:	bf00      	nop
   1611c:	1fff9844 	.word	0x1fff9844
   16120:	1fff9840 	.word	0x1fff9840

00016124 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_03>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_03(void)
{
   16124:	b500      	push	{lr}
   16126:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   16128:	f7ea fdf8 	bl	d1c <Sys_GetCoreID>
   1612c:	4603      	mov	r3, r0
   1612e:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_03[u32CoreId]--;
   16130:	4a0d      	ldr	r2, [pc, #52]	; (16168 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_03+0x44>)
   16132:	9b01      	ldr	r3, [sp, #4]
   16134:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16138:	1e5a      	subs	r2, r3, #1
   1613a:	490b      	ldr	r1, [pc, #44]	; (16168 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_03+0x44>)
   1613c:	9b01      	ldr	r3, [sp, #4]
   1613e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_03[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_03[u32CoreId]))         /*if interrupts were enabled*/
   16142:	4a0a      	ldr	r2, [pc, #40]	; (1616c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_03+0x48>)
   16144:	9b01      	ldr	r3, [sp, #4]
   16146:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1614a:	f003 0301 	and.w	r3, r3, #1
   1614e:	2b00      	cmp	r3, #0
   16150:	d106      	bne.n	16160 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_03+0x3c>
   16152:	4a05      	ldr	r2, [pc, #20]	; (16168 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_03+0x44>)
   16154:	9b01      	ldr	r3, [sp, #4]
   16156:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1615a:	2b00      	cmp	r3, #0
   1615c:	d100      	bne.n	16160 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_03+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1615e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   16160:	bf00      	nop
   16162:	b003      	add	sp, #12
   16164:	f85d fb04 	ldr.w	pc, [sp], #4
   16168:	1fff9844 	.word	0x1fff9844
   1616c:	1fff9840 	.word	0x1fff9840

00016170 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_04>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_04(void)
{
   16170:	b500      	push	{lr}
   16172:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   16174:	f7ea fdd2 	bl	d1c <Sys_GetCoreID>
   16178:	4603      	mov	r3, r0
   1617a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_04[u32CoreId])
   1617c:	4a10      	ldr	r2, [pc, #64]	; (161c0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_04+0x50>)
   1617e:	9b01      	ldr	r3, [sp, #4]
   16180:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16184:	2b00      	cmp	r3, #0
   16186:	d10d      	bne.n	161a4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_04+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
   16188:	f7ea fc2a 	bl	9e0 <Spi_schm_read_msr>
   1618c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1618e:	9b00      	ldr	r3, [sp, #0]
   16190:	f003 0301 	and.w	r3, r3, #1
   16194:	2b00      	cmp	r3, #0
   16196:	d100      	bne.n	1619a <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_04+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   16198:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_04[u32CoreId] = msr;
   1619a:	490a      	ldr	r1, [pc, #40]	; (161c4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_04+0x54>)
   1619c:	9b01      	ldr	r3, [sp, #4]
   1619e:	9a00      	ldr	r2, [sp, #0]
   161a0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_04[u32CoreId]++;
   161a4:	4a06      	ldr	r2, [pc, #24]	; (161c0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_04+0x50>)
   161a6:	9b01      	ldr	r3, [sp, #4]
   161a8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   161ac:	1c5a      	adds	r2, r3, #1
   161ae:	4904      	ldr	r1, [pc, #16]	; (161c0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_04+0x50>)
   161b0:	9b01      	ldr	r3, [sp, #4]
   161b2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   161b6:	bf00      	nop
   161b8:	b003      	add	sp, #12
   161ba:	f85d fb04 	ldr.w	pc, [sp], #4
   161be:	bf00      	nop
   161c0:	1fff984c 	.word	0x1fff984c
   161c4:	1fff9848 	.word	0x1fff9848

000161c8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_04>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_04(void)
{
   161c8:	b500      	push	{lr}
   161ca:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   161cc:	f7ea fda6 	bl	d1c <Sys_GetCoreID>
   161d0:	4603      	mov	r3, r0
   161d2:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_04[u32CoreId]--;
   161d4:	4a0d      	ldr	r2, [pc, #52]	; (1620c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_04+0x44>)
   161d6:	9b01      	ldr	r3, [sp, #4]
   161d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   161dc:	1e5a      	subs	r2, r3, #1
   161de:	490b      	ldr	r1, [pc, #44]	; (1620c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_04+0x44>)
   161e0:	9b01      	ldr	r3, [sp, #4]
   161e2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_04[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_04[u32CoreId]))         /*if interrupts were enabled*/
   161e6:	4a0a      	ldr	r2, [pc, #40]	; (16210 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_04+0x48>)
   161e8:	9b01      	ldr	r3, [sp, #4]
   161ea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   161ee:	f003 0301 	and.w	r3, r3, #1
   161f2:	2b00      	cmp	r3, #0
   161f4:	d106      	bne.n	16204 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_04+0x3c>
   161f6:	4a05      	ldr	r2, [pc, #20]	; (1620c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_04+0x44>)
   161f8:	9b01      	ldr	r3, [sp, #4]
   161fa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   161fe:	2b00      	cmp	r3, #0
   16200:	d100      	bne.n	16204 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_04+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   16202:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   16204:	bf00      	nop
   16206:	b003      	add	sp, #12
   16208:	f85d fb04 	ldr.w	pc, [sp], #4
   1620c:	1fff984c 	.word	0x1fff984c
   16210:	1fff9848 	.word	0x1fff9848

00016214 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05(void)
{
   16214:	b500      	push	{lr}
   16216:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   16218:	f7ea fd80 	bl	d1c <Sys_GetCoreID>
   1621c:	4603      	mov	r3, r0
   1621e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_05[u32CoreId])
   16220:	4a10      	ldr	r2, [pc, #64]	; (16264 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05+0x50>)
   16222:	9b01      	ldr	r3, [sp, #4]
   16224:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16228:	2b00      	cmp	r3, #0
   1622a:	d10d      	bne.n	16248 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
   1622c:	f7ea fbd8 	bl	9e0 <Spi_schm_read_msr>
   16230:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   16232:	9b00      	ldr	r3, [sp, #0]
   16234:	f003 0301 	and.w	r3, r3, #1
   16238:	2b00      	cmp	r3, #0
   1623a:	d100      	bne.n	1623e <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   1623c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_05[u32CoreId] = msr;
   1623e:	490a      	ldr	r1, [pc, #40]	; (16268 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05+0x54>)
   16240:	9b01      	ldr	r3, [sp, #4]
   16242:	9a00      	ldr	r2, [sp, #0]
   16244:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_05[u32CoreId]++;
   16248:	4a06      	ldr	r2, [pc, #24]	; (16264 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05+0x50>)
   1624a:	9b01      	ldr	r3, [sp, #4]
   1624c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16250:	1c5a      	adds	r2, r3, #1
   16252:	4904      	ldr	r1, [pc, #16]	; (16264 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_05+0x50>)
   16254:	9b01      	ldr	r3, [sp, #4]
   16256:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1625a:	bf00      	nop
   1625c:	b003      	add	sp, #12
   1625e:	f85d fb04 	ldr.w	pc, [sp], #4
   16262:	bf00      	nop
   16264:	1fff9854 	.word	0x1fff9854
   16268:	1fff9850 	.word	0x1fff9850

0001626c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05(void)
{
   1626c:	b500      	push	{lr}
   1626e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   16270:	f7ea fd54 	bl	d1c <Sys_GetCoreID>
   16274:	4603      	mov	r3, r0
   16276:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_05[u32CoreId]--;
   16278:	4a0d      	ldr	r2, [pc, #52]	; (162b0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05+0x44>)
   1627a:	9b01      	ldr	r3, [sp, #4]
   1627c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16280:	1e5a      	subs	r2, r3, #1
   16282:	490b      	ldr	r1, [pc, #44]	; (162b0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05+0x44>)
   16284:	9b01      	ldr	r3, [sp, #4]
   16286:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_05[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_05[u32CoreId]))         /*if interrupts were enabled*/
   1628a:	4a0a      	ldr	r2, [pc, #40]	; (162b4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05+0x48>)
   1628c:	9b01      	ldr	r3, [sp, #4]
   1628e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16292:	f003 0301 	and.w	r3, r3, #1
   16296:	2b00      	cmp	r3, #0
   16298:	d106      	bne.n	162a8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05+0x3c>
   1629a:	4a05      	ldr	r2, [pc, #20]	; (162b0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05+0x44>)
   1629c:	9b01      	ldr	r3, [sp, #4]
   1629e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   162a2:	2b00      	cmp	r3, #0
   162a4:	d100      	bne.n	162a8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_05+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   162a6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   162a8:	bf00      	nop
   162aa:	b003      	add	sp, #12
   162ac:	f85d fb04 	ldr.w	pc, [sp], #4
   162b0:	1fff9854 	.word	0x1fff9854
   162b4:	1fff9850 	.word	0x1fff9850

000162b8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06(void)
{
   162b8:	b500      	push	{lr}
   162ba:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   162bc:	f7ea fd2e 	bl	d1c <Sys_GetCoreID>
   162c0:	4603      	mov	r3, r0
   162c2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_06[u32CoreId])
   162c4:	4a10      	ldr	r2, [pc, #64]	; (16308 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06+0x50>)
   162c6:	9b01      	ldr	r3, [sp, #4]
   162c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   162cc:	2b00      	cmp	r3, #0
   162ce:	d10d      	bne.n	162ec <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
   162d0:	f7ea fb86 	bl	9e0 <Spi_schm_read_msr>
   162d4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   162d6:	9b00      	ldr	r3, [sp, #0]
   162d8:	f003 0301 	and.w	r3, r3, #1
   162dc:	2b00      	cmp	r3, #0
   162de:	d100      	bne.n	162e2 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   162e0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_06[u32CoreId] = msr;
   162e2:	490a      	ldr	r1, [pc, #40]	; (1630c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06+0x54>)
   162e4:	9b01      	ldr	r3, [sp, #4]
   162e6:	9a00      	ldr	r2, [sp, #0]
   162e8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_06[u32CoreId]++;
   162ec:	4a06      	ldr	r2, [pc, #24]	; (16308 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06+0x50>)
   162ee:	9b01      	ldr	r3, [sp, #4]
   162f0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   162f4:	1c5a      	adds	r2, r3, #1
   162f6:	4904      	ldr	r1, [pc, #16]	; (16308 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_06+0x50>)
   162f8:	9b01      	ldr	r3, [sp, #4]
   162fa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   162fe:	bf00      	nop
   16300:	b003      	add	sp, #12
   16302:	f85d fb04 	ldr.w	pc, [sp], #4
   16306:	bf00      	nop
   16308:	1fff985c 	.word	0x1fff985c
   1630c:	1fff9858 	.word	0x1fff9858

00016310 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06(void)
{
   16310:	b500      	push	{lr}
   16312:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   16314:	f7ea fd02 	bl	d1c <Sys_GetCoreID>
   16318:	4603      	mov	r3, r0
   1631a:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_06[u32CoreId]--;
   1631c:	4a0d      	ldr	r2, [pc, #52]	; (16354 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06+0x44>)
   1631e:	9b01      	ldr	r3, [sp, #4]
   16320:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16324:	1e5a      	subs	r2, r3, #1
   16326:	490b      	ldr	r1, [pc, #44]	; (16354 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06+0x44>)
   16328:	9b01      	ldr	r3, [sp, #4]
   1632a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_06[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_06[u32CoreId]))         /*if interrupts were enabled*/
   1632e:	4a0a      	ldr	r2, [pc, #40]	; (16358 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06+0x48>)
   16330:	9b01      	ldr	r3, [sp, #4]
   16332:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16336:	f003 0301 	and.w	r3, r3, #1
   1633a:	2b00      	cmp	r3, #0
   1633c:	d106      	bne.n	1634c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06+0x3c>
   1633e:	4a05      	ldr	r2, [pc, #20]	; (16354 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06+0x44>)
   16340:	9b01      	ldr	r3, [sp, #4]
   16342:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16346:	2b00      	cmp	r3, #0
   16348:	d100      	bne.n	1634c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_06+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1634a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   1634c:	bf00      	nop
   1634e:	b003      	add	sp, #12
   16350:	f85d fb04 	ldr.w	pc, [sp], #4
   16354:	1fff985c 	.word	0x1fff985c
   16358:	1fff9858 	.word	0x1fff9858

0001635c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07(void)
{
   1635c:	b500      	push	{lr}
   1635e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   16360:	f7ea fcdc 	bl	d1c <Sys_GetCoreID>
   16364:	4603      	mov	r3, r0
   16366:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_07[u32CoreId])
   16368:	4a10      	ldr	r2, [pc, #64]	; (163ac <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07+0x50>)
   1636a:	9b01      	ldr	r3, [sp, #4]
   1636c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16370:	2b00      	cmp	r3, #0
   16372:	d10d      	bne.n	16390 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
   16374:	f7ea fb34 	bl	9e0 <Spi_schm_read_msr>
   16378:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1637a:	9b00      	ldr	r3, [sp, #0]
   1637c:	f003 0301 	and.w	r3, r3, #1
   16380:	2b00      	cmp	r3, #0
   16382:	d100      	bne.n	16386 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   16384:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_07[u32CoreId] = msr;
   16386:	490a      	ldr	r1, [pc, #40]	; (163b0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07+0x54>)
   16388:	9b01      	ldr	r3, [sp, #4]
   1638a:	9a00      	ldr	r2, [sp, #0]
   1638c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_07[u32CoreId]++;
   16390:	4a06      	ldr	r2, [pc, #24]	; (163ac <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07+0x50>)
   16392:	9b01      	ldr	r3, [sp, #4]
   16394:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16398:	1c5a      	adds	r2, r3, #1
   1639a:	4904      	ldr	r1, [pc, #16]	; (163ac <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_07+0x50>)
   1639c:	9b01      	ldr	r3, [sp, #4]
   1639e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   163a2:	bf00      	nop
   163a4:	b003      	add	sp, #12
   163a6:	f85d fb04 	ldr.w	pc, [sp], #4
   163aa:	bf00      	nop
   163ac:	1fff9864 	.word	0x1fff9864
   163b0:	1fff9860 	.word	0x1fff9860

000163b4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07(void)
{
   163b4:	b500      	push	{lr}
   163b6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   163b8:	f7ea fcb0 	bl	d1c <Sys_GetCoreID>
   163bc:	4603      	mov	r3, r0
   163be:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_07[u32CoreId]--;
   163c0:	4a0d      	ldr	r2, [pc, #52]	; (163f8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07+0x44>)
   163c2:	9b01      	ldr	r3, [sp, #4]
   163c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   163c8:	1e5a      	subs	r2, r3, #1
   163ca:	490b      	ldr	r1, [pc, #44]	; (163f8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07+0x44>)
   163cc:	9b01      	ldr	r3, [sp, #4]
   163ce:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_07[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_07[u32CoreId]))         /*if interrupts were enabled*/
   163d2:	4a0a      	ldr	r2, [pc, #40]	; (163fc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07+0x48>)
   163d4:	9b01      	ldr	r3, [sp, #4]
   163d6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   163da:	f003 0301 	and.w	r3, r3, #1
   163de:	2b00      	cmp	r3, #0
   163e0:	d106      	bne.n	163f0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07+0x3c>
   163e2:	4a05      	ldr	r2, [pc, #20]	; (163f8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07+0x44>)
   163e4:	9b01      	ldr	r3, [sp, #4]
   163e6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   163ea:	2b00      	cmp	r3, #0
   163ec:	d100      	bne.n	163f0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_07+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   163ee:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   163f0:	bf00      	nop
   163f2:	b003      	add	sp, #12
   163f4:	f85d fb04 	ldr.w	pc, [sp], #4
   163f8:	1fff9864 	.word	0x1fff9864
   163fc:	1fff9860 	.word	0x1fff9860

00016400 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08(void)
{
   16400:	b500      	push	{lr}
   16402:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   16404:	f7ea fc8a 	bl	d1c <Sys_GetCoreID>
   16408:	4603      	mov	r3, r0
   1640a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_08[u32CoreId])
   1640c:	4a10      	ldr	r2, [pc, #64]	; (16450 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08+0x50>)
   1640e:	9b01      	ldr	r3, [sp, #4]
   16410:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16414:	2b00      	cmp	r3, #0
   16416:	d10d      	bne.n	16434 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
   16418:	f7ea fae2 	bl	9e0 <Spi_schm_read_msr>
   1641c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1641e:	9b00      	ldr	r3, [sp, #0]
   16420:	f003 0301 	and.w	r3, r3, #1
   16424:	2b00      	cmp	r3, #0
   16426:	d100      	bne.n	1642a <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   16428:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_08[u32CoreId] = msr;
   1642a:	490a      	ldr	r1, [pc, #40]	; (16454 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08+0x54>)
   1642c:	9b01      	ldr	r3, [sp, #4]
   1642e:	9a00      	ldr	r2, [sp, #0]
   16430:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_08[u32CoreId]++;
   16434:	4a06      	ldr	r2, [pc, #24]	; (16450 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08+0x50>)
   16436:	9b01      	ldr	r3, [sp, #4]
   16438:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1643c:	1c5a      	adds	r2, r3, #1
   1643e:	4904      	ldr	r1, [pc, #16]	; (16450 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_08+0x50>)
   16440:	9b01      	ldr	r3, [sp, #4]
   16442:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   16446:	bf00      	nop
   16448:	b003      	add	sp, #12
   1644a:	f85d fb04 	ldr.w	pc, [sp], #4
   1644e:	bf00      	nop
   16450:	1fff986c 	.word	0x1fff986c
   16454:	1fff9868 	.word	0x1fff9868

00016458 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08(void)
{
   16458:	b500      	push	{lr}
   1645a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1645c:	f7ea fc5e 	bl	d1c <Sys_GetCoreID>
   16460:	4603      	mov	r3, r0
   16462:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_08[u32CoreId]--;
   16464:	4a0d      	ldr	r2, [pc, #52]	; (1649c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08+0x44>)
   16466:	9b01      	ldr	r3, [sp, #4]
   16468:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1646c:	1e5a      	subs	r2, r3, #1
   1646e:	490b      	ldr	r1, [pc, #44]	; (1649c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08+0x44>)
   16470:	9b01      	ldr	r3, [sp, #4]
   16472:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_08[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_08[u32CoreId]))         /*if interrupts were enabled*/
   16476:	4a0a      	ldr	r2, [pc, #40]	; (164a0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08+0x48>)
   16478:	9b01      	ldr	r3, [sp, #4]
   1647a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1647e:	f003 0301 	and.w	r3, r3, #1
   16482:	2b00      	cmp	r3, #0
   16484:	d106      	bne.n	16494 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08+0x3c>
   16486:	4a05      	ldr	r2, [pc, #20]	; (1649c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08+0x44>)
   16488:	9b01      	ldr	r3, [sp, #4]
   1648a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1648e:	2b00      	cmp	r3, #0
   16490:	d100      	bne.n	16494 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_08+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   16492:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   16494:	bf00      	nop
   16496:	b003      	add	sp, #12
   16498:	f85d fb04 	ldr.w	pc, [sp], #4
   1649c:	1fff986c 	.word	0x1fff986c
   164a0:	1fff9868 	.word	0x1fff9868

000164a4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09(void)
{
   164a4:	b500      	push	{lr}
   164a6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   164a8:	f7ea fc38 	bl	d1c <Sys_GetCoreID>
   164ac:	4603      	mov	r3, r0
   164ae:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_09[u32CoreId])
   164b0:	4a10      	ldr	r2, [pc, #64]	; (164f4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09+0x50>)
   164b2:	9b01      	ldr	r3, [sp, #4]
   164b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   164b8:	2b00      	cmp	r3, #0
   164ba:	d10d      	bne.n	164d8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
   164bc:	f7ea fa90 	bl	9e0 <Spi_schm_read_msr>
   164c0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   164c2:	9b00      	ldr	r3, [sp, #0]
   164c4:	f003 0301 	and.w	r3, r3, #1
   164c8:	2b00      	cmp	r3, #0
   164ca:	d100      	bne.n	164ce <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   164cc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_09[u32CoreId] = msr;
   164ce:	490a      	ldr	r1, [pc, #40]	; (164f8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09+0x54>)
   164d0:	9b01      	ldr	r3, [sp, #4]
   164d2:	9a00      	ldr	r2, [sp, #0]
   164d4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_09[u32CoreId]++;
   164d8:	4a06      	ldr	r2, [pc, #24]	; (164f4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09+0x50>)
   164da:	9b01      	ldr	r3, [sp, #4]
   164dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   164e0:	1c5a      	adds	r2, r3, #1
   164e2:	4904      	ldr	r1, [pc, #16]	; (164f4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_09+0x50>)
   164e4:	9b01      	ldr	r3, [sp, #4]
   164e6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   164ea:	bf00      	nop
   164ec:	b003      	add	sp, #12
   164ee:	f85d fb04 	ldr.w	pc, [sp], #4
   164f2:	bf00      	nop
   164f4:	1fff9874 	.word	0x1fff9874
   164f8:	1fff9870 	.word	0x1fff9870

000164fc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09(void)
{
   164fc:	b500      	push	{lr}
   164fe:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   16500:	f7ea fc0c 	bl	d1c <Sys_GetCoreID>
   16504:	4603      	mov	r3, r0
   16506:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_09[u32CoreId]--;
   16508:	4a0d      	ldr	r2, [pc, #52]	; (16540 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09+0x44>)
   1650a:	9b01      	ldr	r3, [sp, #4]
   1650c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16510:	1e5a      	subs	r2, r3, #1
   16512:	490b      	ldr	r1, [pc, #44]	; (16540 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09+0x44>)
   16514:	9b01      	ldr	r3, [sp, #4]
   16516:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_09[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_09[u32CoreId]))         /*if interrupts were enabled*/
   1651a:	4a0a      	ldr	r2, [pc, #40]	; (16544 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09+0x48>)
   1651c:	9b01      	ldr	r3, [sp, #4]
   1651e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16522:	f003 0301 	and.w	r3, r3, #1
   16526:	2b00      	cmp	r3, #0
   16528:	d106      	bne.n	16538 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09+0x3c>
   1652a:	4a05      	ldr	r2, [pc, #20]	; (16540 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09+0x44>)
   1652c:	9b01      	ldr	r3, [sp, #4]
   1652e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16532:	2b00      	cmp	r3, #0
   16534:	d100      	bne.n	16538 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_09+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   16536:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   16538:	bf00      	nop
   1653a:	b003      	add	sp, #12
   1653c:	f85d fb04 	ldr.w	pc, [sp], #4
   16540:	1fff9874 	.word	0x1fff9874
   16544:	1fff9870 	.word	0x1fff9870

00016548 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10(void)
{
   16548:	b500      	push	{lr}
   1654a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1654c:	f7ea fbe6 	bl	d1c <Sys_GetCoreID>
   16550:	4603      	mov	r3, r0
   16552:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_10[u32CoreId])
   16554:	4a10      	ldr	r2, [pc, #64]	; (16598 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10+0x50>)
   16556:	9b01      	ldr	r3, [sp, #4]
   16558:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1655c:	2b00      	cmp	r3, #0
   1655e:	d10d      	bne.n	1657c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
   16560:	f7ea fa3e 	bl	9e0 <Spi_schm_read_msr>
   16564:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   16566:	9b00      	ldr	r3, [sp, #0]
   16568:	f003 0301 	and.w	r3, r3, #1
   1656c:	2b00      	cmp	r3, #0
   1656e:	d100      	bne.n	16572 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   16570:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_10[u32CoreId] = msr;
   16572:	490a      	ldr	r1, [pc, #40]	; (1659c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10+0x54>)
   16574:	9b01      	ldr	r3, [sp, #4]
   16576:	9a00      	ldr	r2, [sp, #0]
   16578:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_10[u32CoreId]++;
   1657c:	4a06      	ldr	r2, [pc, #24]	; (16598 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10+0x50>)
   1657e:	9b01      	ldr	r3, [sp, #4]
   16580:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16584:	1c5a      	adds	r2, r3, #1
   16586:	4904      	ldr	r1, [pc, #16]	; (16598 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_10+0x50>)
   16588:	9b01      	ldr	r3, [sp, #4]
   1658a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1658e:	bf00      	nop
   16590:	b003      	add	sp, #12
   16592:	f85d fb04 	ldr.w	pc, [sp], #4
   16596:	bf00      	nop
   16598:	1fff987c 	.word	0x1fff987c
   1659c:	1fff9878 	.word	0x1fff9878

000165a0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10(void)
{
   165a0:	b500      	push	{lr}
   165a2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   165a4:	f7ea fbba 	bl	d1c <Sys_GetCoreID>
   165a8:	4603      	mov	r3, r0
   165aa:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_10[u32CoreId]--;
   165ac:	4a0d      	ldr	r2, [pc, #52]	; (165e4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10+0x44>)
   165ae:	9b01      	ldr	r3, [sp, #4]
   165b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   165b4:	1e5a      	subs	r2, r3, #1
   165b6:	490b      	ldr	r1, [pc, #44]	; (165e4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10+0x44>)
   165b8:	9b01      	ldr	r3, [sp, #4]
   165ba:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_10[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_10[u32CoreId]))         /*if interrupts were enabled*/
   165be:	4a0a      	ldr	r2, [pc, #40]	; (165e8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10+0x48>)
   165c0:	9b01      	ldr	r3, [sp, #4]
   165c2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   165c6:	f003 0301 	and.w	r3, r3, #1
   165ca:	2b00      	cmp	r3, #0
   165cc:	d106      	bne.n	165dc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10+0x3c>
   165ce:	4a05      	ldr	r2, [pc, #20]	; (165e4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10+0x44>)
   165d0:	9b01      	ldr	r3, [sp, #4]
   165d2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   165d6:	2b00      	cmp	r3, #0
   165d8:	d100      	bne.n	165dc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_10+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   165da:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   165dc:	bf00      	nop
   165de:	b003      	add	sp, #12
   165e0:	f85d fb04 	ldr.w	pc, [sp], #4
   165e4:	1fff987c 	.word	0x1fff987c
   165e8:	1fff9878 	.word	0x1fff9878

000165ec <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11(void)
{
   165ec:	b500      	push	{lr}
   165ee:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   165f0:	f7ea fb94 	bl	d1c <Sys_GetCoreID>
   165f4:	4603      	mov	r3, r0
   165f6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_11[u32CoreId])
   165f8:	4a10      	ldr	r2, [pc, #64]	; (1663c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11+0x50>)
   165fa:	9b01      	ldr	r3, [sp, #4]
   165fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16600:	2b00      	cmp	r3, #0
   16602:	d10d      	bne.n	16620 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
   16604:	f7ea f9ec 	bl	9e0 <Spi_schm_read_msr>
   16608:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1660a:	9b00      	ldr	r3, [sp, #0]
   1660c:	f003 0301 	and.w	r3, r3, #1
   16610:	2b00      	cmp	r3, #0
   16612:	d100      	bne.n	16616 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   16614:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_11[u32CoreId] = msr;
   16616:	490a      	ldr	r1, [pc, #40]	; (16640 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11+0x54>)
   16618:	9b01      	ldr	r3, [sp, #4]
   1661a:	9a00      	ldr	r2, [sp, #0]
   1661c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_11[u32CoreId]++;
   16620:	4a06      	ldr	r2, [pc, #24]	; (1663c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11+0x50>)
   16622:	9b01      	ldr	r3, [sp, #4]
   16624:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16628:	1c5a      	adds	r2, r3, #1
   1662a:	4904      	ldr	r1, [pc, #16]	; (1663c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_11+0x50>)
   1662c:	9b01      	ldr	r3, [sp, #4]
   1662e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   16632:	bf00      	nop
   16634:	b003      	add	sp, #12
   16636:	f85d fb04 	ldr.w	pc, [sp], #4
   1663a:	bf00      	nop
   1663c:	1fff9884 	.word	0x1fff9884
   16640:	1fff9880 	.word	0x1fff9880

00016644 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11(void)
{
   16644:	b500      	push	{lr}
   16646:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   16648:	f7ea fb68 	bl	d1c <Sys_GetCoreID>
   1664c:	4603      	mov	r3, r0
   1664e:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_11[u32CoreId]--;
   16650:	4a0d      	ldr	r2, [pc, #52]	; (16688 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11+0x44>)
   16652:	9b01      	ldr	r3, [sp, #4]
   16654:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16658:	1e5a      	subs	r2, r3, #1
   1665a:	490b      	ldr	r1, [pc, #44]	; (16688 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11+0x44>)
   1665c:	9b01      	ldr	r3, [sp, #4]
   1665e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_11[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_11[u32CoreId]))         /*if interrupts were enabled*/
   16662:	4a0a      	ldr	r2, [pc, #40]	; (1668c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11+0x48>)
   16664:	9b01      	ldr	r3, [sp, #4]
   16666:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1666a:	f003 0301 	and.w	r3, r3, #1
   1666e:	2b00      	cmp	r3, #0
   16670:	d106      	bne.n	16680 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11+0x3c>
   16672:	4a05      	ldr	r2, [pc, #20]	; (16688 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11+0x44>)
   16674:	9b01      	ldr	r3, [sp, #4]
   16676:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1667a:	2b00      	cmp	r3, #0
   1667c:	d100      	bne.n	16680 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_11+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1667e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   16680:	bf00      	nop
   16682:	b003      	add	sp, #12
   16684:	f85d fb04 	ldr.w	pc, [sp], #4
   16688:	1fff9884 	.word	0x1fff9884
   1668c:	1fff9880 	.word	0x1fff9880

00016690 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_12>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_12(void)
{
   16690:	b500      	push	{lr}
   16692:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   16694:	f7ea fb42 	bl	d1c <Sys_GetCoreID>
   16698:	4603      	mov	r3, r0
   1669a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_12[u32CoreId])
   1669c:	4a10      	ldr	r2, [pc, #64]	; (166e0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_12+0x50>)
   1669e:	9b01      	ldr	r3, [sp, #4]
   166a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   166a4:	2b00      	cmp	r3, #0
   166a6:	d10d      	bne.n	166c4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_12+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
   166a8:	f7ea f99a 	bl	9e0 <Spi_schm_read_msr>
   166ac:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   166ae:	9b00      	ldr	r3, [sp, #0]
   166b0:	f003 0301 	and.w	r3, r3, #1
   166b4:	2b00      	cmp	r3, #0
   166b6:	d100      	bne.n	166ba <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_12+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   166b8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_12[u32CoreId] = msr;
   166ba:	490a      	ldr	r1, [pc, #40]	; (166e4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_12+0x54>)
   166bc:	9b01      	ldr	r3, [sp, #4]
   166be:	9a00      	ldr	r2, [sp, #0]
   166c0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_12[u32CoreId]++;
   166c4:	4a06      	ldr	r2, [pc, #24]	; (166e0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_12+0x50>)
   166c6:	9b01      	ldr	r3, [sp, #4]
   166c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   166cc:	1c5a      	adds	r2, r3, #1
   166ce:	4904      	ldr	r1, [pc, #16]	; (166e0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_12+0x50>)
   166d0:	9b01      	ldr	r3, [sp, #4]
   166d2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   166d6:	bf00      	nop
   166d8:	b003      	add	sp, #12
   166da:	f85d fb04 	ldr.w	pc, [sp], #4
   166de:	bf00      	nop
   166e0:	1fff988c 	.word	0x1fff988c
   166e4:	1fff9888 	.word	0x1fff9888

000166e8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_12>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_12(void)
{
   166e8:	b500      	push	{lr}
   166ea:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   166ec:	f7ea fb16 	bl	d1c <Sys_GetCoreID>
   166f0:	4603      	mov	r3, r0
   166f2:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_12[u32CoreId]--;
   166f4:	4a0d      	ldr	r2, [pc, #52]	; (1672c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_12+0x44>)
   166f6:	9b01      	ldr	r3, [sp, #4]
   166f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   166fc:	1e5a      	subs	r2, r3, #1
   166fe:	490b      	ldr	r1, [pc, #44]	; (1672c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_12+0x44>)
   16700:	9b01      	ldr	r3, [sp, #4]
   16702:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_12[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_12[u32CoreId]))         /*if interrupts were enabled*/
   16706:	4a0a      	ldr	r2, [pc, #40]	; (16730 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_12+0x48>)
   16708:	9b01      	ldr	r3, [sp, #4]
   1670a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1670e:	f003 0301 	and.w	r3, r3, #1
   16712:	2b00      	cmp	r3, #0
   16714:	d106      	bne.n	16724 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_12+0x3c>
   16716:	4a05      	ldr	r2, [pc, #20]	; (1672c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_12+0x44>)
   16718:	9b01      	ldr	r3, [sp, #4]
   1671a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1671e:	2b00      	cmp	r3, #0
   16720:	d100      	bne.n	16724 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_12+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   16722:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   16724:	bf00      	nop
   16726:	b003      	add	sp, #12
   16728:	f85d fb04 	ldr.w	pc, [sp], #4
   1672c:	1fff988c 	.word	0x1fff988c
   16730:	1fff9888 	.word	0x1fff9888

00016734 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_13>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_13(void)
{
   16734:	b500      	push	{lr}
   16736:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   16738:	f7ea faf0 	bl	d1c <Sys_GetCoreID>
   1673c:	4603      	mov	r3, r0
   1673e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_13[u32CoreId])
   16740:	4a10      	ldr	r2, [pc, #64]	; (16784 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_13+0x50>)
   16742:	9b01      	ldr	r3, [sp, #4]
   16744:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16748:	2b00      	cmp	r3, #0
   1674a:	d10d      	bne.n	16768 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_13+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
   1674c:	f7ea f948 	bl	9e0 <Spi_schm_read_msr>
   16750:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   16752:	9b00      	ldr	r3, [sp, #0]
   16754:	f003 0301 	and.w	r3, r3, #1
   16758:	2b00      	cmp	r3, #0
   1675a:	d100      	bne.n	1675e <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_13+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   1675c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_13[u32CoreId] = msr;
   1675e:	490a      	ldr	r1, [pc, #40]	; (16788 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_13+0x54>)
   16760:	9b01      	ldr	r3, [sp, #4]
   16762:	9a00      	ldr	r2, [sp, #0]
   16764:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_13[u32CoreId]++;
   16768:	4a06      	ldr	r2, [pc, #24]	; (16784 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_13+0x50>)
   1676a:	9b01      	ldr	r3, [sp, #4]
   1676c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16770:	1c5a      	adds	r2, r3, #1
   16772:	4904      	ldr	r1, [pc, #16]	; (16784 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_13+0x50>)
   16774:	9b01      	ldr	r3, [sp, #4]
   16776:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1677a:	bf00      	nop
   1677c:	b003      	add	sp, #12
   1677e:	f85d fb04 	ldr.w	pc, [sp], #4
   16782:	bf00      	nop
   16784:	1fff9894 	.word	0x1fff9894
   16788:	1fff9890 	.word	0x1fff9890

0001678c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_13>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_13(void)
{
   1678c:	b500      	push	{lr}
   1678e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   16790:	f7ea fac4 	bl	d1c <Sys_GetCoreID>
   16794:	4603      	mov	r3, r0
   16796:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_13[u32CoreId]--;
   16798:	4a0d      	ldr	r2, [pc, #52]	; (167d0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_13+0x44>)
   1679a:	9b01      	ldr	r3, [sp, #4]
   1679c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   167a0:	1e5a      	subs	r2, r3, #1
   167a2:	490b      	ldr	r1, [pc, #44]	; (167d0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_13+0x44>)
   167a4:	9b01      	ldr	r3, [sp, #4]
   167a6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_13[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_13[u32CoreId]))         /*if interrupts were enabled*/
   167aa:	4a0a      	ldr	r2, [pc, #40]	; (167d4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_13+0x48>)
   167ac:	9b01      	ldr	r3, [sp, #4]
   167ae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   167b2:	f003 0301 	and.w	r3, r3, #1
   167b6:	2b00      	cmp	r3, #0
   167b8:	d106      	bne.n	167c8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_13+0x3c>
   167ba:	4a05      	ldr	r2, [pc, #20]	; (167d0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_13+0x44>)
   167bc:	9b01      	ldr	r3, [sp, #4]
   167be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   167c2:	2b00      	cmp	r3, #0
   167c4:	d100      	bne.n	167c8 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_13+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   167c6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   167c8:	bf00      	nop
   167ca:	b003      	add	sp, #12
   167cc:	f85d fb04 	ldr.w	pc, [sp], #4
   167d0:	1fff9894 	.word	0x1fff9894
   167d4:	1fff9890 	.word	0x1fff9890

000167d8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_14>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_14(void)
{
   167d8:	b500      	push	{lr}
   167da:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   167dc:	f7ea fa9e 	bl	d1c <Sys_GetCoreID>
   167e0:	4603      	mov	r3, r0
   167e2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_14[u32CoreId])
   167e4:	4a10      	ldr	r2, [pc, #64]	; (16828 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_14+0x50>)
   167e6:	9b01      	ldr	r3, [sp, #4]
   167e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   167ec:	2b00      	cmp	r3, #0
   167ee:	d10d      	bne.n	1680c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_14+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
   167f0:	f7ea f8f6 	bl	9e0 <Spi_schm_read_msr>
   167f4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   167f6:	9b00      	ldr	r3, [sp, #0]
   167f8:	f003 0301 	and.w	r3, r3, #1
   167fc:	2b00      	cmp	r3, #0
   167fe:	d100      	bne.n	16802 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_14+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   16800:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_14[u32CoreId] = msr;
   16802:	490a      	ldr	r1, [pc, #40]	; (1682c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_14+0x54>)
   16804:	9b01      	ldr	r3, [sp, #4]
   16806:	9a00      	ldr	r2, [sp, #0]
   16808:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_14[u32CoreId]++;
   1680c:	4a06      	ldr	r2, [pc, #24]	; (16828 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_14+0x50>)
   1680e:	9b01      	ldr	r3, [sp, #4]
   16810:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16814:	1c5a      	adds	r2, r3, #1
   16816:	4904      	ldr	r1, [pc, #16]	; (16828 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_14+0x50>)
   16818:	9b01      	ldr	r3, [sp, #4]
   1681a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1681e:	bf00      	nop
   16820:	b003      	add	sp, #12
   16822:	f85d fb04 	ldr.w	pc, [sp], #4
   16826:	bf00      	nop
   16828:	1fff989c 	.word	0x1fff989c
   1682c:	1fff9898 	.word	0x1fff9898

00016830 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_14>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_14(void)
{
   16830:	b500      	push	{lr}
   16832:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   16834:	f7ea fa72 	bl	d1c <Sys_GetCoreID>
   16838:	4603      	mov	r3, r0
   1683a:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_14[u32CoreId]--;
   1683c:	4a0d      	ldr	r2, [pc, #52]	; (16874 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_14+0x44>)
   1683e:	9b01      	ldr	r3, [sp, #4]
   16840:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16844:	1e5a      	subs	r2, r3, #1
   16846:	490b      	ldr	r1, [pc, #44]	; (16874 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_14+0x44>)
   16848:	9b01      	ldr	r3, [sp, #4]
   1684a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_14[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_14[u32CoreId]))         /*if interrupts were enabled*/
   1684e:	4a0a      	ldr	r2, [pc, #40]	; (16878 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_14+0x48>)
   16850:	9b01      	ldr	r3, [sp, #4]
   16852:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16856:	f003 0301 	and.w	r3, r3, #1
   1685a:	2b00      	cmp	r3, #0
   1685c:	d106      	bne.n	1686c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_14+0x3c>
   1685e:	4a05      	ldr	r2, [pc, #20]	; (16874 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_14+0x44>)
   16860:	9b01      	ldr	r3, [sp, #4]
   16862:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16866:	2b00      	cmp	r3, #0
   16868:	d100      	bne.n	1686c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_14+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1686a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   1686c:	bf00      	nop
   1686e:	b003      	add	sp, #12
   16870:	f85d fb04 	ldr.w	pc, [sp], #4
   16874:	1fff989c 	.word	0x1fff989c
   16878:	1fff9898 	.word	0x1fff9898

0001687c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_15>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_15(void)
{
   1687c:	b500      	push	{lr}
   1687e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   16880:	f7ea fa4c 	bl	d1c <Sys_GetCoreID>
   16884:	4603      	mov	r3, r0
   16886:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_15[u32CoreId])
   16888:	4a10      	ldr	r2, [pc, #64]	; (168cc <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_15+0x50>)
   1688a:	9b01      	ldr	r3, [sp, #4]
   1688c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16890:	2b00      	cmp	r3, #0
   16892:	d10d      	bne.n	168b0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_15+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
   16894:	f7ea f8a4 	bl	9e0 <Spi_schm_read_msr>
   16898:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1689a:	9b00      	ldr	r3, [sp, #0]
   1689c:	f003 0301 	and.w	r3, r3, #1
   168a0:	2b00      	cmp	r3, #0
   168a2:	d100      	bne.n	168a6 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_15+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   168a4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_15[u32CoreId] = msr;
   168a6:	490a      	ldr	r1, [pc, #40]	; (168d0 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_15+0x54>)
   168a8:	9b01      	ldr	r3, [sp, #4]
   168aa:	9a00      	ldr	r2, [sp, #0]
   168ac:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_15[u32CoreId]++;
   168b0:	4a06      	ldr	r2, [pc, #24]	; (168cc <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_15+0x50>)
   168b2:	9b01      	ldr	r3, [sp, #4]
   168b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   168b8:	1c5a      	adds	r2, r3, #1
   168ba:	4904      	ldr	r1, [pc, #16]	; (168cc <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_15+0x50>)
   168bc:	9b01      	ldr	r3, [sp, #4]
   168be:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   168c2:	bf00      	nop
   168c4:	b003      	add	sp, #12
   168c6:	f85d fb04 	ldr.w	pc, [sp], #4
   168ca:	bf00      	nop
   168cc:	1fff98a4 	.word	0x1fff98a4
   168d0:	1fff98a0 	.word	0x1fff98a0

000168d4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_15>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_15(void)
{
   168d4:	b500      	push	{lr}
   168d6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   168d8:	f7ea fa20 	bl	d1c <Sys_GetCoreID>
   168dc:	4603      	mov	r3, r0
   168de:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_15[u32CoreId]--;
   168e0:	4a0d      	ldr	r2, [pc, #52]	; (16918 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_15+0x44>)
   168e2:	9b01      	ldr	r3, [sp, #4]
   168e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   168e8:	1e5a      	subs	r2, r3, #1
   168ea:	490b      	ldr	r1, [pc, #44]	; (16918 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_15+0x44>)
   168ec:	9b01      	ldr	r3, [sp, #4]
   168ee:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_15[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_15[u32CoreId]))         /*if interrupts were enabled*/
   168f2:	4a0a      	ldr	r2, [pc, #40]	; (1691c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_15+0x48>)
   168f4:	9b01      	ldr	r3, [sp, #4]
   168f6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   168fa:	f003 0301 	and.w	r3, r3, #1
   168fe:	2b00      	cmp	r3, #0
   16900:	d106      	bne.n	16910 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_15+0x3c>
   16902:	4a05      	ldr	r2, [pc, #20]	; (16918 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_15+0x44>)
   16904:	9b01      	ldr	r3, [sp, #4]
   16906:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1690a:	2b00      	cmp	r3, #0
   1690c:	d100      	bne.n	16910 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_15+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1690e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   16910:	bf00      	nop
   16912:	b003      	add	sp, #12
   16914:	f85d fb04 	ldr.w	pc, [sp], #4
   16918:	1fff98a4 	.word	0x1fff98a4
   1691c:	1fff98a0 	.word	0x1fff98a0

00016920 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_16>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_16(void)
{
   16920:	b500      	push	{lr}
   16922:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   16924:	f7ea f9fa 	bl	d1c <Sys_GetCoreID>
   16928:	4603      	mov	r3, r0
   1692a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_16[u32CoreId])
   1692c:	4a10      	ldr	r2, [pc, #64]	; (16970 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_16+0x50>)
   1692e:	9b01      	ldr	r3, [sp, #4]
   16930:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16934:	2b00      	cmp	r3, #0
   16936:	d10d      	bne.n	16954 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_16+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
   16938:	f7ea f852 	bl	9e0 <Spi_schm_read_msr>
   1693c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1693e:	9b00      	ldr	r3, [sp, #0]
   16940:	f003 0301 	and.w	r3, r3, #1
   16944:	2b00      	cmp	r3, #0
   16946:	d100      	bne.n	1694a <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_16+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   16948:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_16[u32CoreId] = msr;
   1694a:	490a      	ldr	r1, [pc, #40]	; (16974 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_16+0x54>)
   1694c:	9b01      	ldr	r3, [sp, #4]
   1694e:	9a00      	ldr	r2, [sp, #0]
   16950:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_16[u32CoreId]++;
   16954:	4a06      	ldr	r2, [pc, #24]	; (16970 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_16+0x50>)
   16956:	9b01      	ldr	r3, [sp, #4]
   16958:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1695c:	1c5a      	adds	r2, r3, #1
   1695e:	4904      	ldr	r1, [pc, #16]	; (16970 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_16+0x50>)
   16960:	9b01      	ldr	r3, [sp, #4]
   16962:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   16966:	bf00      	nop
   16968:	b003      	add	sp, #12
   1696a:	f85d fb04 	ldr.w	pc, [sp], #4
   1696e:	bf00      	nop
   16970:	1fff98ac 	.word	0x1fff98ac
   16974:	1fff98a8 	.word	0x1fff98a8

00016978 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_16>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_16(void)
{
   16978:	b500      	push	{lr}
   1697a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1697c:	f7ea f9ce 	bl	d1c <Sys_GetCoreID>
   16980:	4603      	mov	r3, r0
   16982:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_16[u32CoreId]--;
   16984:	4a0d      	ldr	r2, [pc, #52]	; (169bc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_16+0x44>)
   16986:	9b01      	ldr	r3, [sp, #4]
   16988:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1698c:	1e5a      	subs	r2, r3, #1
   1698e:	490b      	ldr	r1, [pc, #44]	; (169bc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_16+0x44>)
   16990:	9b01      	ldr	r3, [sp, #4]
   16992:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_16[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_16[u32CoreId]))         /*if interrupts were enabled*/
   16996:	4a0a      	ldr	r2, [pc, #40]	; (169c0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_16+0x48>)
   16998:	9b01      	ldr	r3, [sp, #4]
   1699a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1699e:	f003 0301 	and.w	r3, r3, #1
   169a2:	2b00      	cmp	r3, #0
   169a4:	d106      	bne.n	169b4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_16+0x3c>
   169a6:	4a05      	ldr	r2, [pc, #20]	; (169bc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_16+0x44>)
   169a8:	9b01      	ldr	r3, [sp, #4]
   169aa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   169ae:	2b00      	cmp	r3, #0
   169b0:	d100      	bne.n	169b4 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_16+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   169b2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   169b4:	bf00      	nop
   169b6:	b003      	add	sp, #12
   169b8:	f85d fb04 	ldr.w	pc, [sp], #4
   169bc:	1fff98ac 	.word	0x1fff98ac
   169c0:	1fff98a8 	.word	0x1fff98a8

000169c4 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_17>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_17(void)
{
   169c4:	b500      	push	{lr}
   169c6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   169c8:	f7ea f9a8 	bl	d1c <Sys_GetCoreID>
   169cc:	4603      	mov	r3, r0
   169ce:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_17[u32CoreId])
   169d0:	4a10      	ldr	r2, [pc, #64]	; (16a14 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_17+0x50>)
   169d2:	9b01      	ldr	r3, [sp, #4]
   169d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   169d8:	2b00      	cmp	r3, #0
   169da:	d10d      	bne.n	169f8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_17+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
   169dc:	f7ea f800 	bl	9e0 <Spi_schm_read_msr>
   169e0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   169e2:	9b00      	ldr	r3, [sp, #0]
   169e4:	f003 0301 	and.w	r3, r3, #1
   169e8:	2b00      	cmp	r3, #0
   169ea:	d100      	bne.n	169ee <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_17+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   169ec:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_17[u32CoreId] = msr;
   169ee:	490a      	ldr	r1, [pc, #40]	; (16a18 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_17+0x54>)
   169f0:	9b01      	ldr	r3, [sp, #4]
   169f2:	9a00      	ldr	r2, [sp, #0]
   169f4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_17[u32CoreId]++;
   169f8:	4a06      	ldr	r2, [pc, #24]	; (16a14 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_17+0x50>)
   169fa:	9b01      	ldr	r3, [sp, #4]
   169fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16a00:	1c5a      	adds	r2, r3, #1
   16a02:	4904      	ldr	r1, [pc, #16]	; (16a14 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_17+0x50>)
   16a04:	9b01      	ldr	r3, [sp, #4]
   16a06:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   16a0a:	bf00      	nop
   16a0c:	b003      	add	sp, #12
   16a0e:	f85d fb04 	ldr.w	pc, [sp], #4
   16a12:	bf00      	nop
   16a14:	1fff98b4 	.word	0x1fff98b4
   16a18:	1fff98b0 	.word	0x1fff98b0

00016a1c <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_17>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_17(void)
{
   16a1c:	b500      	push	{lr}
   16a1e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   16a20:	f7ea f97c 	bl	d1c <Sys_GetCoreID>
   16a24:	4603      	mov	r3, r0
   16a26:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_17[u32CoreId]--;
   16a28:	4a0d      	ldr	r2, [pc, #52]	; (16a60 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_17+0x44>)
   16a2a:	9b01      	ldr	r3, [sp, #4]
   16a2c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16a30:	1e5a      	subs	r2, r3, #1
   16a32:	490b      	ldr	r1, [pc, #44]	; (16a60 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_17+0x44>)
   16a34:	9b01      	ldr	r3, [sp, #4]
   16a36:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_17[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_17[u32CoreId]))         /*if interrupts were enabled*/
   16a3a:	4a0a      	ldr	r2, [pc, #40]	; (16a64 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_17+0x48>)
   16a3c:	9b01      	ldr	r3, [sp, #4]
   16a3e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16a42:	f003 0301 	and.w	r3, r3, #1
   16a46:	2b00      	cmp	r3, #0
   16a48:	d106      	bne.n	16a58 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_17+0x3c>
   16a4a:	4a05      	ldr	r2, [pc, #20]	; (16a60 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_17+0x44>)
   16a4c:	9b01      	ldr	r3, [sp, #4]
   16a4e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16a52:	2b00      	cmp	r3, #0
   16a54:	d100      	bne.n	16a58 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_17+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   16a56:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   16a58:	bf00      	nop
   16a5a:	b003      	add	sp, #12
   16a5c:	f85d fb04 	ldr.w	pc, [sp], #4
   16a60:	1fff98b4 	.word	0x1fff98b4
   16a64:	1fff98b0 	.word	0x1fff98b0

00016a68 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_18>:

void SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_18(void)
{
   16a68:	b500      	push	{lr}
   16a6a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   16a6c:	f7ea f956 	bl	d1c <Sys_GetCoreID>
   16a70:	4603      	mov	r3, r0
   16a72:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_18[u32CoreId])
   16a74:	4a10      	ldr	r2, [pc, #64]	; (16ab8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_18+0x50>)
   16a76:	9b01      	ldr	r3, [sp, #4]
   16a78:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16a7c:	2b00      	cmp	r3, #0
   16a7e:	d10d      	bne.n	16a9c <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_18+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Spi_schm_read_msr);
#else
        msr = Spi_schm_read_msr();  /*read MSR (to store interrupts state)*/
   16a80:	f7e9 ffae 	bl	9e0 <Spi_schm_read_msr>
   16a84:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   16a86:	9b00      	ldr	r3, [sp, #0]
   16a88:	f003 0301 	and.w	r3, r3, #1
   16a8c:	2b00      	cmp	r3, #0
   16a8e:	d100      	bne.n	16a92 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_18+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   16a90:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_SPI_EXCLUSIVE_AREA_18[u32CoreId] = msr;
   16a92:	490a      	ldr	r1, [pc, #40]	; (16abc <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_18+0x54>)
   16a94:	9b01      	ldr	r3, [sp, #4]
   16a96:	9a00      	ldr	r2, [sp, #0]
   16a98:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_SPI_EXCLUSIVE_AREA_18[u32CoreId]++;
   16a9c:	4a06      	ldr	r2, [pc, #24]	; (16ab8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_18+0x50>)
   16a9e:	9b01      	ldr	r3, [sp, #4]
   16aa0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16aa4:	1c5a      	adds	r2, r3, #1
   16aa6:	4904      	ldr	r1, [pc, #16]	; (16ab8 <SchM_Enter_Spi_SPI_EXCLUSIVE_AREA_18+0x50>)
   16aa8:	9b01      	ldr	r3, [sp, #4]
   16aaa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   16aae:	bf00      	nop
   16ab0:	b003      	add	sp, #12
   16ab2:	f85d fb04 	ldr.w	pc, [sp], #4
   16ab6:	bf00      	nop
   16ab8:	1fff98bc 	.word	0x1fff98bc
   16abc:	1fff98b8 	.word	0x1fff98b8

00016ac0 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_18>:

void SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_18(void)
{
   16ac0:	b500      	push	{lr}
   16ac2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   16ac4:	f7ea f92a 	bl	d1c <Sys_GetCoreID>
   16ac8:	4603      	mov	r3, r0
   16aca:	9301      	str	r3, [sp, #4]

    reentry_guard_SPI_EXCLUSIVE_AREA_18[u32CoreId]--;
   16acc:	4a0d      	ldr	r2, [pc, #52]	; (16b04 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_18+0x44>)
   16ace:	9b01      	ldr	r3, [sp, #4]
   16ad0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16ad4:	1e5a      	subs	r2, r3, #1
   16ad6:	490b      	ldr	r1, [pc, #44]	; (16b04 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_18+0x44>)
   16ad8:	9b01      	ldr	r3, [sp, #4]
   16ada:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_SPI_EXCLUSIVE_AREA_18[u32CoreId]))&&(0UL == reentry_guard_SPI_EXCLUSIVE_AREA_18[u32CoreId]))         /*if interrupts were enabled*/
   16ade:	4a0a      	ldr	r2, [pc, #40]	; (16b08 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_18+0x48>)
   16ae0:	9b01      	ldr	r3, [sp, #4]
   16ae2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16ae6:	f003 0301 	and.w	r3, r3, #1
   16aea:	2b00      	cmp	r3, #0
   16aec:	d106      	bne.n	16afc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_18+0x3c>
   16aee:	4a05      	ldr	r2, [pc, #20]	; (16b04 <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_18+0x44>)
   16af0:	9b01      	ldr	r3, [sp, #4]
   16af2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   16af6:	2b00      	cmp	r3, #0
   16af8:	d100      	bne.n	16afc <SchM_Exit_Spi_SPI_EXCLUSIVE_AREA_18+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   16afa:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   16afc:	bf00      	nop
   16afe:	b003      	add	sp, #12
   16b00:	f85d fb04 	ldr.w	pc, [sp], #4
   16b04:	1fff98bc 	.word	0x1fff98bc
   16b08:	1fff98b8 	.word	0x1fff98b8

00016b0c <Det_Init>:
*
* @requirements   DET008
*
*/
void Det_Init(void)
{
   16b0c:	b508      	push	{r3, lr}
    SEGGER_RTT_Init();  //Initializing RTT library.
   16b0e:	f7ea faa3 	bl	1058 <SEGGER_RTT_Init>
}
   16b12:	bf00      	nop
   16b14:	bd08      	pop	{r3, pc}

00016b16 <Det_SearchApi>:
 * @param[in] ApiId Api id where error was detected.
 * @return StringPtr Ptr to string of api name.
 * 
 * @note If the Api Id isn´t registered in the hash table it will return NULL; 
 */
const char* Det_SearchApi( uint8 ModuleIndex, uint8 ApiId ) {
   16b16:	b084      	sub	sp, #16
   16b18:	4603      	mov	r3, r0
   16b1a:	460a      	mov	r2, r1
   16b1c:	f88d 3007 	strb.w	r3, [sp, #7]
   16b20:	4613      	mov	r3, r2
   16b22:	f88d 3006 	strb.w	r3, [sp, #6]
    //local data.
    uint8 i = 0;
   16b26:	2300      	movs	r3, #0
   16b28:	f88d 300f 	strb.w	r3, [sp, #15]
    const char *StringPtr = NULL_PTR;
   16b2c:	2300      	movs	r3, #0
   16b2e:	9302      	str	r3, [sp, #8]

    for ( i = 0; i < ModuleStrings_Ptr[ ModuleIndex ].Apis; i++ ) { //Searching for api.
   16b30:	2300      	movs	r3, #0
   16b32:	f88d 300f 	strb.w	r3, [sp, #15]
   16b36:	e026      	b.n	16b86 <Det_SearchApi+0x70>
        if ( ModuleStrings_Ptr[ ModuleIndex ].ApiNames[i].ApiId == ApiId ) {
   16b38:	491b      	ldr	r1, [pc, #108]	; (16ba8 <Det_SearchApi+0x92>)
   16b3a:	f89d 2007 	ldrb.w	r2, [sp, #7]
   16b3e:	4613      	mov	r3, r2
   16b40:	005b      	lsls	r3, r3, #1
   16b42:	4413      	add	r3, r2
   16b44:	00db      	lsls	r3, r3, #3
   16b46:	440b      	add	r3, r1
   16b48:	68da      	ldr	r2, [r3, #12]
   16b4a:	f89d 300f 	ldrb.w	r3, [sp, #15]
   16b4e:	00db      	lsls	r3, r3, #3
   16b50:	4413      	add	r3, r2
   16b52:	781b      	ldrb	r3, [r3, #0]
   16b54:	f89d 2006 	ldrb.w	r2, [sp, #6]
   16b58:	429a      	cmp	r2, r3
   16b5a:	d10f      	bne.n	16b7c <Det_SearchApi+0x66>
            StringPtr = ModuleStrings_Ptr[ ModuleIndex ].ApiNames[i].ApiName;
   16b5c:	4912      	ldr	r1, [pc, #72]	; (16ba8 <Det_SearchApi+0x92>)
   16b5e:	f89d 2007 	ldrb.w	r2, [sp, #7]
   16b62:	4613      	mov	r3, r2
   16b64:	005b      	lsls	r3, r3, #1
   16b66:	4413      	add	r3, r2
   16b68:	00db      	lsls	r3, r3, #3
   16b6a:	440b      	add	r3, r1
   16b6c:	68da      	ldr	r2, [r3, #12]
   16b6e:	f89d 300f 	ldrb.w	r3, [sp, #15]
   16b72:	00db      	lsls	r3, r3, #3
   16b74:	4413      	add	r3, r2
   16b76:	685b      	ldr	r3, [r3, #4]
   16b78:	9302      	str	r3, [sp, #8]
            break;
   16b7a:	e011      	b.n	16ba0 <Det_SearchApi+0x8a>
    for ( i = 0; i < ModuleStrings_Ptr[ ModuleIndex ].Apis; i++ ) { //Searching for api.
   16b7c:	f89d 300f 	ldrb.w	r3, [sp, #15]
   16b80:	3301      	adds	r3, #1
   16b82:	f88d 300f 	strb.w	r3, [sp, #15]
   16b86:	4908      	ldr	r1, [pc, #32]	; (16ba8 <Det_SearchApi+0x92>)
   16b88:	f89d 2007 	ldrb.w	r2, [sp, #7]
   16b8c:	4613      	mov	r3, r2
   16b8e:	005b      	lsls	r3, r3, #1
   16b90:	4413      	add	r3, r2
   16b92:	00db      	lsls	r3, r3, #3
   16b94:	440b      	add	r3, r1
   16b96:	7a1b      	ldrb	r3, [r3, #8]
   16b98:	f89d 200f 	ldrb.w	r2, [sp, #15]
   16b9c:	429a      	cmp	r2, r3
   16b9e:	d3cb      	bcc.n	16b38 <Det_SearchApi+0x22>
        }
    }

    return StringPtr;
   16ba0:	9b02      	ldr	r3, [sp, #8]
}
   16ba2:	4618      	mov	r0, r3
   16ba4:	b004      	add	sp, #16
   16ba6:	4770      	bx	lr
   16ba8:	00018ad4 	.word	0x00018ad4

00016bac <Det_SearchError>:
 * @param[in] ErrorId Error id reported.
 * @return StringPtr Ptr to string of error meaning.
 * 
 * @note If the Error Id isn´t registered in the hash table it will return NULL; 
 */
const char* Det_SearchError( uint8 ModuleIndex, uint8 ErrorId ) {
   16bac:	b084      	sub	sp, #16
   16bae:	4603      	mov	r3, r0
   16bb0:	460a      	mov	r2, r1
   16bb2:	f88d 3007 	strb.w	r3, [sp, #7]
   16bb6:	4613      	mov	r3, r2
   16bb8:	f88d 3006 	strb.w	r3, [sp, #6]
    //local data.
    uint8 i = 0;
   16bbc:	2300      	movs	r3, #0
   16bbe:	f88d 300f 	strb.w	r3, [sp, #15]
    const char *StringPtr = NULL_PTR;
   16bc2:	2300      	movs	r3, #0
   16bc4:	9302      	str	r3, [sp, #8]

    for ( i = 0; i < ModuleStrings_Ptr[ ModuleIndex ].Errors; i++ ) { //Searching for api.
   16bc6:	2300      	movs	r3, #0
   16bc8:	f88d 300f 	strb.w	r3, [sp, #15]
   16bcc:	e026      	b.n	16c1c <Det_SearchError+0x70>
        if ( ModuleStrings_Ptr[ ModuleIndex ].ErrorMeanings[i].ErrorId == ErrorId ) {
   16bce:	491c      	ldr	r1, [pc, #112]	; (16c40 <Det_SearchError+0x94>)
   16bd0:	f89d 2007 	ldrb.w	r2, [sp, #7]
   16bd4:	4613      	mov	r3, r2
   16bd6:	005b      	lsls	r3, r3, #1
   16bd8:	4413      	add	r3, r2
   16bda:	00db      	lsls	r3, r3, #3
   16bdc:	440b      	add	r3, r1
   16bde:	695a      	ldr	r2, [r3, #20]
   16be0:	f89d 300f 	ldrb.w	r3, [sp, #15]
   16be4:	00db      	lsls	r3, r3, #3
   16be6:	4413      	add	r3, r2
   16be8:	781b      	ldrb	r3, [r3, #0]
   16bea:	f89d 2006 	ldrb.w	r2, [sp, #6]
   16bee:	429a      	cmp	r2, r3
   16bf0:	d10f      	bne.n	16c12 <Det_SearchError+0x66>
            StringPtr = ModuleStrings_Ptr[ ModuleIndex ].ErrorMeanings[i].ErrorMeaning;
   16bf2:	4913      	ldr	r1, [pc, #76]	; (16c40 <Det_SearchError+0x94>)
   16bf4:	f89d 2007 	ldrb.w	r2, [sp, #7]
   16bf8:	4613      	mov	r3, r2
   16bfa:	005b      	lsls	r3, r3, #1
   16bfc:	4413      	add	r3, r2
   16bfe:	00db      	lsls	r3, r3, #3
   16c00:	440b      	add	r3, r1
   16c02:	695a      	ldr	r2, [r3, #20]
   16c04:	f89d 300f 	ldrb.w	r3, [sp, #15]
   16c08:	00db      	lsls	r3, r3, #3
   16c0a:	4413      	add	r3, r2
   16c0c:	685b      	ldr	r3, [r3, #4]
   16c0e:	9302      	str	r3, [sp, #8]
            break;
   16c10:	e011      	b.n	16c36 <Det_SearchError+0x8a>
    for ( i = 0; i < ModuleStrings_Ptr[ ModuleIndex ].Errors; i++ ) { //Searching for api.
   16c12:	f89d 300f 	ldrb.w	r3, [sp, #15]
   16c16:	3301      	adds	r3, #1
   16c18:	f88d 300f 	strb.w	r3, [sp, #15]
   16c1c:	4908      	ldr	r1, [pc, #32]	; (16c40 <Det_SearchError+0x94>)
   16c1e:	f89d 2007 	ldrb.w	r2, [sp, #7]
   16c22:	4613      	mov	r3, r2
   16c24:	005b      	lsls	r3, r3, #1
   16c26:	4413      	add	r3, r2
   16c28:	00db      	lsls	r3, r3, #3
   16c2a:	440b      	add	r3, r1
   16c2c:	7c1b      	ldrb	r3, [r3, #16]
   16c2e:	f89d 200f 	ldrb.w	r2, [sp, #15]
   16c32:	429a      	cmp	r2, r3
   16c34:	d3cb      	bcc.n	16bce <Det_SearchError+0x22>
        }
    }

    return StringPtr;
   16c36:	9b02      	ldr	r3, [sp, #8]
}
   16c38:	4618      	mov	r0, r3
   16c3a:	b004      	add	sp, #16
   16c3c:	4770      	bx	lr
   16c3e:	bf00      	nop
   16c40:	00018ad4 	.word	0x00018ad4

00016c44 <Det_GetModuleName>:
 * @param[in] ModuleId Module Id where error was detected.
 * @return StringPtr Pointer to string module name.
 * 
 * @note If the module Id isn´t registered it will return NULL;
 */
const char* Det_GetModuleName( uint16 ModuleId ) {
   16c44:	b084      	sub	sp, #16
   16c46:	4603      	mov	r3, r0
   16c48:	f8ad 3006 	strh.w	r3, [sp, #6]
    //local data 
    uint8 i = 0;
   16c4c:	2300      	movs	r3, #0
   16c4e:	f88d 300f 	strb.w	r3, [sp, #15]
    const char *StringPtr = NULL_PTR;
   16c52:	2300      	movs	r3, #0
   16c54:	9302      	str	r3, [sp, #8]

    for ( i = 0; i < DET_MODULES; i++ ) {  //Searching module name.
   16c56:	2300      	movs	r3, #0
   16c58:	f88d 300f 	strb.w	r3, [sp, #15]
   16c5c:	e01c      	b.n	16c98 <Det_GetModuleName+0x54>
        if ( ModuleStrings_Ptr[i].ModuleId == ModuleId ) {
   16c5e:	4912      	ldr	r1, [pc, #72]	; (16ca8 <Det_GetModuleName+0x64>)
   16c60:	f89d 200f 	ldrb.w	r2, [sp, #15]
   16c64:	4613      	mov	r3, r2
   16c66:	005b      	lsls	r3, r3, #1
   16c68:	4413      	add	r3, r2
   16c6a:	00db      	lsls	r3, r3, #3
   16c6c:	440b      	add	r3, r1
   16c6e:	881b      	ldrh	r3, [r3, #0]
   16c70:	f8bd 2006 	ldrh.w	r2, [sp, #6]
   16c74:	429a      	cmp	r2, r3
   16c76:	d10a      	bne.n	16c8e <Det_GetModuleName+0x4a>
            StringPtr = ModuleStrings_Ptr[i].ModuleName;
   16c78:	490b      	ldr	r1, [pc, #44]	; (16ca8 <Det_GetModuleName+0x64>)
   16c7a:	f89d 200f 	ldrb.w	r2, [sp, #15]
   16c7e:	4613      	mov	r3, r2
   16c80:	005b      	lsls	r3, r3, #1
   16c82:	4413      	add	r3, r2
   16c84:	00db      	lsls	r3, r3, #3
   16c86:	440b      	add	r3, r1
   16c88:	685b      	ldr	r3, [r3, #4]
   16c8a:	9302      	str	r3, [sp, #8]
            break;
   16c8c:	e008      	b.n	16ca0 <Det_GetModuleName+0x5c>
    for ( i = 0; i < DET_MODULES; i++ ) {  //Searching module name.
   16c8e:	f89d 300f 	ldrb.w	r3, [sp, #15]
   16c92:	3301      	adds	r3, #1
   16c94:	f88d 300f 	strb.w	r3, [sp, #15]
   16c98:	f89d 300f 	ldrb.w	r3, [sp, #15]
   16c9c:	2b0a      	cmp	r3, #10
   16c9e:	d9de      	bls.n	16c5e <Det_GetModuleName+0x1a>
        }
    }

    return StringPtr;
   16ca0:	9b02      	ldr	r3, [sp, #8]
}
   16ca2:	4618      	mov	r0, r3
   16ca4:	b004      	add	sp, #16
   16ca6:	4770      	bx	lr
   16ca8:	00018ad4 	.word	0x00018ad4

00016cac <Det_GetApiName>:
 * @param[in] ApiId Api Id where error was detected 
 * @return StringPtr Pointer to string Api name.
 * 
 * @note If the Api Id isn´t registered in the hash table it will return NULL;
 */
const char* Det_GetApiName( uint16 ModuleId, uint8 ApiId ) {
   16cac:	b500      	push	{lr}
   16cae:	b085      	sub	sp, #20
   16cb0:	4603      	mov	r3, r0
   16cb2:	460a      	mov	r2, r1
   16cb4:	f8ad 3006 	strh.w	r3, [sp, #6]
   16cb8:	4613      	mov	r3, r2
   16cba:	f88d 3005 	strb.w	r3, [sp, #5]
    //local data.
    uint8 i = 0;
   16cbe:	2300      	movs	r3, #0
   16cc0:	f88d 300f 	strb.w	r3, [sp, #15]
    const char *StringPtr = NULL_PTR;
   16cc4:	2300      	movs	r3, #0
   16cc6:	9302      	str	r3, [sp, #8]

    for ( i = 0; i < DET_MODULES; i++ ) {  //Searching for module.
   16cc8:	2300      	movs	r3, #0
   16cca:	f88d 300f 	strb.w	r3, [sp, #15]
   16cce:	e01b      	b.n	16d08 <Det_GetApiName+0x5c>
        if ( ModuleStrings_Ptr[i].ModuleId == ModuleId ) {
   16cd0:	4912      	ldr	r1, [pc, #72]	; (16d1c <Det_GetApiName+0x70>)
   16cd2:	f89d 200f 	ldrb.w	r2, [sp, #15]
   16cd6:	4613      	mov	r3, r2
   16cd8:	005b      	lsls	r3, r3, #1
   16cda:	4413      	add	r3, r2
   16cdc:	00db      	lsls	r3, r3, #3
   16cde:	440b      	add	r3, r1
   16ce0:	881b      	ldrh	r3, [r3, #0]
   16ce2:	f8bd 2006 	ldrh.w	r2, [sp, #6]
   16ce6:	429a      	cmp	r2, r3
   16ce8:	d109      	bne.n	16cfe <Det_GetApiName+0x52>
            StringPtr = Det_SearchApi( i , ApiId ); //Searching Api.
   16cea:	f89d 2005 	ldrb.w	r2, [sp, #5]
   16cee:	f89d 300f 	ldrb.w	r3, [sp, #15]
   16cf2:	4611      	mov	r1, r2
   16cf4:	4618      	mov	r0, r3
   16cf6:	f7ff ff0e 	bl	16b16 <Det_SearchApi>
   16cfa:	9002      	str	r0, [sp, #8]
            break;
   16cfc:	e008      	b.n	16d10 <Det_GetApiName+0x64>
    for ( i = 0; i < DET_MODULES; i++ ) {  //Searching for module.
   16cfe:	f89d 300f 	ldrb.w	r3, [sp, #15]
   16d02:	3301      	adds	r3, #1
   16d04:	f88d 300f 	strb.w	r3, [sp, #15]
   16d08:	f89d 300f 	ldrb.w	r3, [sp, #15]
   16d0c:	2b0a      	cmp	r3, #10
   16d0e:	d9df      	bls.n	16cd0 <Det_GetApiName+0x24>
        }
    }

    return StringPtr;
   16d10:	9b02      	ldr	r3, [sp, #8]
}
   16d12:	4618      	mov	r0, r3
   16d14:	b005      	add	sp, #20
   16d16:	f85d fb04 	ldr.w	pc, [sp], #4
   16d1a:	bf00      	nop
   16d1c:	00018ad4 	.word	0x00018ad4

00016d20 <Det_GetErrorMeaning>:
 * @param[in] ErrorId Error Id reported. 
 * @return StringPtr Pointer to string Error meaning.
 * 
 * @note If the Error Id isn´t registered in the hash table it will return NULL;
 */
const char* Det_GetErrorMeaning( uint16 ModuleId, uint8 ErrorId ) {
   16d20:	b500      	push	{lr}
   16d22:	b085      	sub	sp, #20
   16d24:	4603      	mov	r3, r0
   16d26:	460a      	mov	r2, r1
   16d28:	f8ad 3006 	strh.w	r3, [sp, #6]
   16d2c:	4613      	mov	r3, r2
   16d2e:	f88d 3005 	strb.w	r3, [sp, #5]
    //local data.
    uint8 i = 0;
   16d32:	2300      	movs	r3, #0
   16d34:	f88d 300f 	strb.w	r3, [sp, #15]
    const char * StringPtr = NULL_PTR;
   16d38:	2300      	movs	r3, #0
   16d3a:	9302      	str	r3, [sp, #8]

    for ( i = 0; i < DET_MODULES; i++ ) {  //Searching for module.
   16d3c:	2300      	movs	r3, #0
   16d3e:	f88d 300f 	strb.w	r3, [sp, #15]
   16d42:	e01b      	b.n	16d7c <Det_GetErrorMeaning+0x5c>
        if ( ModuleStrings_Ptr[i].ModuleId == ModuleId ) {
   16d44:	4912      	ldr	r1, [pc, #72]	; (16d90 <Det_GetErrorMeaning+0x70>)
   16d46:	f89d 200f 	ldrb.w	r2, [sp, #15]
   16d4a:	4613      	mov	r3, r2
   16d4c:	005b      	lsls	r3, r3, #1
   16d4e:	4413      	add	r3, r2
   16d50:	00db      	lsls	r3, r3, #3
   16d52:	440b      	add	r3, r1
   16d54:	881b      	ldrh	r3, [r3, #0]
   16d56:	f8bd 2006 	ldrh.w	r2, [sp, #6]
   16d5a:	429a      	cmp	r2, r3
   16d5c:	d109      	bne.n	16d72 <Det_GetErrorMeaning+0x52>
            StringPtr = Det_SearchError( i, ErrorId );
   16d5e:	f89d 2005 	ldrb.w	r2, [sp, #5]
   16d62:	f89d 300f 	ldrb.w	r3, [sp, #15]
   16d66:	4611      	mov	r1, r2
   16d68:	4618      	mov	r0, r3
   16d6a:	f7ff ff1f 	bl	16bac <Det_SearchError>
   16d6e:	9002      	str	r0, [sp, #8]
            break;
   16d70:	e008      	b.n	16d84 <Det_GetErrorMeaning+0x64>
    for ( i = 0; i < DET_MODULES; i++ ) {  //Searching for module.
   16d72:	f89d 300f 	ldrb.w	r3, [sp, #15]
   16d76:	3301      	adds	r3, #1
   16d78:	f88d 300f 	strb.w	r3, [sp, #15]
   16d7c:	f89d 300f 	ldrb.w	r3, [sp, #15]
   16d80:	2b0a      	cmp	r3, #10
   16d82:	d9df      	bls.n	16d44 <Det_GetErrorMeaning+0x24>
        }
    }

    return StringPtr;
   16d84:	9b02      	ldr	r3, [sp, #8]
}
   16d86:	4618      	mov	r0, r3
   16d88:	b005      	add	sp, #20
   16d8a:	f85d fb04 	ldr.w	pc, [sp], #4
   16d8e:	bf00      	nop
   16d90:	00018ad4 	.word	0x00018ad4

00016d94 <Det_ReportError>:
*/
Std_ReturnType Det_ReportError(uint16 ModuleId,
                               uint8 InstanceId,
                               uint8 ApiId,
                               uint8 ErrorId)
{
   16d94:	b510      	push	{r4, lr}
   16d96:	b088      	sub	sp, #32
   16d98:	4604      	mov	r4, r0
   16d9a:	4608      	mov	r0, r1
   16d9c:	4611      	mov	r1, r2
   16d9e:	461a      	mov	r2, r3
   16da0:	4623      	mov	r3, r4
   16da2:	f8ad 300e 	strh.w	r3, [sp, #14]
   16da6:	4603      	mov	r3, r0
   16da8:	f88d 300d 	strb.w	r3, [sp, #13]
   16dac:	460b      	mov	r3, r1
   16dae:	f88d 300c 	strb.w	r3, [sp, #12]
   16db2:	4613      	mov	r3, r2
   16db4:	f88d 300b 	strb.w	r3, [sp, #11]
    //local data.
    const char* Strings_error[3]; //Pointer to strings for the error message.

    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   16db8:	f7e9 ffb0 	bl	d1c <Sys_GetCoreID>
   16dbc:	4603      	mov	r3, r0
   16dbe:	9307      	str	r3, [sp, #28]

    Det_ModuleId[u32CoreId] = ModuleId;
   16dc0:	4921      	ldr	r1, [pc, #132]	; (16e48 <Det_ReportError+0xb4>)
   16dc2:	9b07      	ldr	r3, [sp, #28]
   16dc4:	f8bd 200e 	ldrh.w	r2, [sp, #14]
   16dc8:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
    Det_InstanceId[u32CoreId] = InstanceId;
   16dcc:	4a1f      	ldr	r2, [pc, #124]	; (16e4c <Det_ReportError+0xb8>)
   16dce:	9b07      	ldr	r3, [sp, #28]
   16dd0:	4413      	add	r3, r2
   16dd2:	f89d 200d 	ldrb.w	r2, [sp, #13]
   16dd6:	701a      	strb	r2, [r3, #0]
    Det_ApiId[u32CoreId] = ApiId;
   16dd8:	4a1d      	ldr	r2, [pc, #116]	; (16e50 <Det_ReportError+0xbc>)
   16dda:	9b07      	ldr	r3, [sp, #28]
   16ddc:	4413      	add	r3, r2
   16dde:	f89d 200c 	ldrb.w	r2, [sp, #12]
   16de2:	701a      	strb	r2, [r3, #0]
    Det_ErrorId[u32CoreId] = ErrorId;
   16de4:	4a1b      	ldr	r2, [pc, #108]	; (16e54 <Det_ReportError+0xc0>)
   16de6:	9b07      	ldr	r3, [sp, #28]
   16de8:	4413      	add	r3, r2
   16dea:	f89d 200b 	ldrb.w	r2, [sp, #11]
   16dee:	701a      	strb	r2, [r3, #0]

    //Obtaining strings for error message.
    Strings_error[0] = Det_GetModuleName( ModuleId );
   16df0:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   16df4:	4618      	mov	r0, r3
   16df6:	f7ff ff25 	bl	16c44 <Det_GetModuleName>
   16dfa:	4603      	mov	r3, r0
   16dfc:	9304      	str	r3, [sp, #16]
    Strings_error[1] = Det_GetApiName( ModuleId, ApiId );
   16dfe:	f89d 200c 	ldrb.w	r2, [sp, #12]
   16e02:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   16e06:	4611      	mov	r1, r2
   16e08:	4618      	mov	r0, r3
   16e0a:	f7ff ff4f 	bl	16cac <Det_GetApiName>
   16e0e:	4603      	mov	r3, r0
   16e10:	9305      	str	r3, [sp, #20]
    Strings_error[2] = Det_GetErrorMeaning( ModuleId, ErrorId );
   16e12:	f89d 200b 	ldrb.w	r2, [sp, #11]
   16e16:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   16e1a:	4611      	mov	r1, r2
   16e1c:	4618      	mov	r0, r3
   16e1e:	f7ff ff7f 	bl	16d20 <Det_GetErrorMeaning>
   16e22:	4603      	mov	r3, r0
   16e24:	9306      	str	r3, [sp, #24]

    SEGGER_RTT_printf( 0, "Error: Error in %s in function %s with the instance %d, %s\n", 
   16e26:	9904      	ldr	r1, [sp, #16]
   16e28:	9805      	ldr	r0, [sp, #20]
   16e2a:	f89d 300d 	ldrb.w	r3, [sp, #13]
   16e2e:	9a06      	ldr	r2, [sp, #24]
   16e30:	9201      	str	r2, [sp, #4]
   16e32:	9300      	str	r3, [sp, #0]
   16e34:	4603      	mov	r3, r0
   16e36:	460a      	mov	r2, r1
   16e38:	4907      	ldr	r1, [pc, #28]	; (16e58 <Det_ReportError+0xc4>)
   16e3a:	2000      	movs	r0, #0
   16e3c:	f7ea fc74 	bl	1728 <SEGGER_RTT_printf>
    Strings_error[0], Strings_error[1], InstanceId, Strings_error[2] );

    return E_OK;
   16e40:	2300      	movs	r3, #0
}
   16e42:	4618      	mov	r0, r3
   16e44:	b008      	add	sp, #32
   16e46:	bd10      	pop	{r4, pc}
   16e48:	1fff98e8 	.word	0x1fff98e8
   16e4c:	1fff98c0 	.word	0x1fff98c0
   16e50:	1fff98c4 	.word	0x1fff98c4
   16e54:	1fff98c8 	.word	0x1fff98c8
   16e58:	00017ebc 	.word	0x00017ebc

00016e5c <Det_ReportRuntimeError>:
*/
Std_ReturnType Det_ReportRuntimeError(uint16 ModuleId,
                                      uint8 InstanceId,
                                      uint8 ApiId,
                                      uint8 ErrorId)
{
   16e5c:	b510      	push	{r4, lr}
   16e5e:	b084      	sub	sp, #16
   16e60:	4604      	mov	r4, r0
   16e62:	4608      	mov	r0, r1
   16e64:	4611      	mov	r1, r2
   16e66:	461a      	mov	r2, r3
   16e68:	4623      	mov	r3, r4
   16e6a:	f8ad 3006 	strh.w	r3, [sp, #6]
   16e6e:	4603      	mov	r3, r0
   16e70:	f88d 3005 	strb.w	r3, [sp, #5]
   16e74:	460b      	mov	r3, r1
   16e76:	f88d 3004 	strb.w	r3, [sp, #4]
   16e7a:	4613      	mov	r3, r2
   16e7c:	f88d 3003 	strb.w	r3, [sp, #3]
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   16e80:	f7e9 ff4c 	bl	d1c <Sys_GetCoreID>
   16e84:	4603      	mov	r3, r0
   16e86:	9303      	str	r3, [sp, #12]

    Det_RuntimeModuleId[u32CoreId] = ModuleId;
   16e88:	490d      	ldr	r1, [pc, #52]	; (16ec0 <Det_ReportRuntimeError+0x64>)
   16e8a:	9b03      	ldr	r3, [sp, #12]
   16e8c:	f8bd 2006 	ldrh.w	r2, [sp, #6]
   16e90:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
    Det_RuntimeInstanceId[u32CoreId] = InstanceId;
   16e94:	4a0b      	ldr	r2, [pc, #44]	; (16ec4 <Det_ReportRuntimeError+0x68>)
   16e96:	9b03      	ldr	r3, [sp, #12]
   16e98:	4413      	add	r3, r2
   16e9a:	f89d 2005 	ldrb.w	r2, [sp, #5]
   16e9e:	701a      	strb	r2, [r3, #0]
    Det_RuntimeApiId[u32CoreId] = ApiId;
   16ea0:	4a09      	ldr	r2, [pc, #36]	; (16ec8 <Det_ReportRuntimeError+0x6c>)
   16ea2:	9b03      	ldr	r3, [sp, #12]
   16ea4:	4413      	add	r3, r2
   16ea6:	f89d 2004 	ldrb.w	r2, [sp, #4]
   16eaa:	701a      	strb	r2, [r3, #0]
    Det_RuntimeErrorId[u32CoreId] = ErrorId;
   16eac:	4a07      	ldr	r2, [pc, #28]	; (16ecc <Det_ReportRuntimeError+0x70>)
   16eae:	9b03      	ldr	r3, [sp, #12]
   16eb0:	4413      	add	r3, r2
   16eb2:	f89d 2003 	ldrb.w	r2, [sp, #3]
   16eb6:	701a      	strb	r2, [r3, #0]

    return E_OK;
   16eb8:	2300      	movs	r3, #0
}
   16eba:	4618      	mov	r0, r3
   16ebc:	b004      	add	sp, #16
   16ebe:	bd10      	pop	{r4, pc}
   16ec0:	1fff98ec 	.word	0x1fff98ec
   16ec4:	1fff98cc 	.word	0x1fff98cc
   16ec8:	1fff98d0 	.word	0x1fff98d0
   16ecc:	1fff98d4 	.word	0x1fff98d4

00016ed0 <Det_ReportTransientFault>:
*/
Std_ReturnType Det_ReportTransientFault(uint16 ModuleId,
                                        uint8 InstanceId,
                                        uint8 ApiId,
                                        uint8 FaultId)
{
   16ed0:	b510      	push	{r4, lr}
   16ed2:	b084      	sub	sp, #16
   16ed4:	4604      	mov	r4, r0
   16ed6:	4608      	mov	r0, r1
   16ed8:	4611      	mov	r1, r2
   16eda:	461a      	mov	r2, r3
   16edc:	4623      	mov	r3, r4
   16ede:	f8ad 3006 	strh.w	r3, [sp, #6]
   16ee2:	4603      	mov	r3, r0
   16ee4:	f88d 3005 	strb.w	r3, [sp, #5]
   16ee8:	460b      	mov	r3, r1
   16eea:	f88d 3004 	strb.w	r3, [sp, #4]
   16eee:	4613      	mov	r3, r2
   16ef0:	f88d 3003 	strb.w	r3, [sp, #3]
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   16ef4:	f7e9 ff12 	bl	d1c <Sys_GetCoreID>
   16ef8:	4603      	mov	r3, r0
   16efa:	9303      	str	r3, [sp, #12]

    Det_TransientModuleId[u32CoreId] = ModuleId;
   16efc:	490d      	ldr	r1, [pc, #52]	; (16f34 <Det_ReportTransientFault+0x64>)
   16efe:	9b03      	ldr	r3, [sp, #12]
   16f00:	f8bd 2006 	ldrh.w	r2, [sp, #6]
   16f04:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
    Det_TransientInstanceId[u32CoreId] = InstanceId;
   16f08:	4a0b      	ldr	r2, [pc, #44]	; (16f38 <Det_ReportTransientFault+0x68>)
   16f0a:	9b03      	ldr	r3, [sp, #12]
   16f0c:	4413      	add	r3, r2
   16f0e:	f89d 2005 	ldrb.w	r2, [sp, #5]
   16f12:	701a      	strb	r2, [r3, #0]
    Det_TransientApiId[u32CoreId] = ApiId;
   16f14:	4a09      	ldr	r2, [pc, #36]	; (16f3c <Det_ReportTransientFault+0x6c>)
   16f16:	9b03      	ldr	r3, [sp, #12]
   16f18:	4413      	add	r3, r2
   16f1a:	f89d 2004 	ldrb.w	r2, [sp, #4]
   16f1e:	701a      	strb	r2, [r3, #0]
    Det_TransientFaultId[u32CoreId] = FaultId;
   16f20:	4a07      	ldr	r2, [pc, #28]	; (16f40 <Det_ReportTransientFault+0x70>)
   16f22:	9b03      	ldr	r3, [sp, #12]
   16f24:	4413      	add	r3, r2
   16f26:	f89d 2003 	ldrb.w	r2, [sp, #3]
   16f2a:	701a      	strb	r2, [r3, #0]

    return E_OK;
   16f2c:	2300      	movs	r3, #0
}
   16f2e:	4618      	mov	r0, r3
   16f30:	b004      	add	sp, #16
   16f32:	bd10      	pop	{r4, pc}
   16f34:	1fff98e4 	.word	0x1fff98e4
   16f38:	1fff98d8 	.word	0x1fff98d8
   16f3c:	1fff98dc 	.word	0x1fff98dc
   16f40:	1fff98e0 	.word	0x1fff98e0

00016f44 <Det_Start>:
* @requirement DET010
*/
void Det_Start(void)
{
    /* Do nothing */
}
   16f44:	bf00      	nop
   16f46:	4770      	bx	lr

00016f48 <CanIf_Init>:
 * @brief This function initialices the CanIf Driver.
 * 
 * @param ConfigPtr Pointer to driver control structure. 
 */
void CanIf_Init(const CanIf_ConfigType * ConfigPtr)
{
   16f48:	b082      	sub	sp, #8
   16f4a:	9001      	str	r0, [sp, #4]
    #if (STD_ON == CANIF_PRECOMPILE_SUPPORT)
    CanIf_ConfigPtr = &CanIf_Config;
    (void)ConfigPtr;
    #else
    CanIf_ConfigPtr = ConfigPtr;
   16f4c:	4a02      	ldr	r2, [pc, #8]	; (16f58 <CanIf_Init+0x10>)
   16f4e:	9b01      	ldr	r3, [sp, #4]
   16f50:	6013      	str	r3, [r2, #0]
    #endif
}
   16f52:	bf00      	nop
   16f54:	b002      	add	sp, #8
   16f56:	4770      	bx	lr
   16f58:	1fff98f0 	.word	0x1fff98f0

00016f5c <CanIf_Transmit>:
Std_ReturnType CanIf_Transmit
(
    PduIdType CanTxPduId,
    const PduInfoType * PduInfoPtr
)
{
   16f5c:	b500      	push	{lr}
   16f5e:	b08b      	sub	sp, #44	; 0x2c
   16f60:	4603      	mov	r3, r0
   16f62:	9100      	str	r1, [sp, #0]
   16f64:	f8ad 3006 	strh.w	r3, [sp, #6]
    Std_ReturnType RetVal = E_NOT_OK;
   16f68:	2301      	movs	r3, #1
   16f6a:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    Can_HwHandleType CanHth = 0U;
   16f6e:	2300      	movs	r3, #0
   16f70:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    Can_PduType PduInfo;
    const CanIf_TxPduType * TxPduInfo = NULL_PTR;
   16f74:	2300      	movs	r3, #0
   16f76:	9308      	str	r3, [sp, #32]
    uint8 CanIfControllerId = 0U;
   16f78:	2300      	movs	r3, #0
   16f7a:	f88d 301f 	strb.w	r3, [sp, #31]
    const CanIf_CtrlPCConfigType * CanIfController = NULL_PTR;
   16f7e:	2300      	movs	r3, #0
   16f80:	9306      	str	r3, [sp, #24]

    if (NULL_PTR != CanIf_ConfigPtr)
   16f82:	4b31      	ldr	r3, [pc, #196]	; (17048 <CanIf_Transmit+0xec>)
   16f84:	681b      	ldr	r3, [r3, #0]
   16f86:	2b00      	cmp	r3, #0
   16f88:	d057      	beq.n	1703a <CanIf_Transmit+0xde>
    {
        if (CanTxPduId < (CanIf_ConfigPtr->NumTxPdu))
   16f8a:	4b2f      	ldr	r3, [pc, #188]	; (17048 <CanIf_Transmit+0xec>)
   16f8c:	681b      	ldr	r3, [r3, #0]
   16f8e:	785b      	ldrb	r3, [r3, #1]
   16f90:	b29b      	uxth	r3, r3
   16f92:	f8bd 2006 	ldrh.w	r2, [sp, #6]
   16f96:	429a      	cmp	r2, r3
   16f98:	d24f      	bcs.n	1703a <CanIf_Transmit+0xde>
        {
            TxPduInfo = &CanIf_ConfigPtr->CanIf_TxPduConfigPtr[CanTxPduId];
   16f9a:	4b2b      	ldr	r3, [pc, #172]	; (17048 <CanIf_Transmit+0xec>)
   16f9c:	681b      	ldr	r3, [r3, #0]
   16f9e:	68d9      	ldr	r1, [r3, #12]
   16fa0:	f8bd 2006 	ldrh.w	r2, [sp, #6]
   16fa4:	4613      	mov	r3, r2
   16fa6:	009b      	lsls	r3, r3, #2
   16fa8:	4413      	add	r3, r2
   16faa:	009b      	lsls	r3, r3, #2
   16fac:	440b      	add	r3, r1
   16fae:	9308      	str	r3, [sp, #32]
            CanIfControllerId = TxPduInfo->CanIfCtrlId;
   16fb0:	9b08      	ldr	r3, [sp, #32]
   16fb2:	7b9b      	ldrb	r3, [r3, #14]
   16fb4:	f88d 301f 	strb.w	r3, [sp, #31]
            CanIfController = &CanIf_PCConfig.CanIfCtrlConfigPtr[CanIfControllerId];
   16fb8:	4b24      	ldr	r3, [pc, #144]	; (1704c <CanIf_Transmit+0xf0>)
   16fba:	685a      	ldr	r2, [r3, #4]
   16fbc:	f89d 301f 	ldrb.w	r3, [sp, #31]
   16fc0:	00db      	lsls	r3, r3, #3
   16fc2:	4413      	add	r3, r2
   16fc4:	9306      	str	r3, [sp, #24]

            CanHth = TxPduInfo->CanHth;
   16fc6:	9b08      	ldr	r3, [sp, #32]
   16fc8:	899b      	ldrh	r3, [r3, #12]
   16fca:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24

            PduInfo.id = TxPduInfo->CanId;
   16fce:	9b08      	ldr	r3, [sp, #32]
   16fd0:	685b      	ldr	r3, [r3, #4]
   16fd2:	9303      	str	r3, [sp, #12]
            /* Convert Id by adding two most significant bits specify the frame type */
            switch (TxPduInfo->CanFrameType)
   16fd4:	9b08      	ldr	r3, [sp, #32]
   16fd6:	689b      	ldr	r3, [r3, #8]
   16fd8:	2b03      	cmp	r3, #3
   16fda:	d010      	beq.n	16ffe <CanIf_Transmit+0xa2>
   16fdc:	2b03      	cmp	r3, #3
   16fde:	d813      	bhi.n	17008 <CanIf_Transmit+0xac>
   16fe0:	2b00      	cmp	r3, #0
   16fe2:	d002      	beq.n	16fea <CanIf_Transmit+0x8e>
   16fe4:	2b01      	cmp	r3, #1
   16fe6:	d005      	beq.n	16ff4 <CanIf_Transmit+0x98>
                    PduInfo.id |= 0x40000000U;
                    break;
                }
                default:
                {
                    break;
   16fe8:	e00e      	b.n	17008 <CanIf_Transmit+0xac>
                    PduInfo.id |= 0x80000000U;
   16fea:	9b03      	ldr	r3, [sp, #12]
   16fec:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   16ff0:	9303      	str	r3, [sp, #12]
                    break;
   16ff2:	e00a      	b.n	1700a <CanIf_Transmit+0xae>
                    PduInfo.id |= 0xC0000000U;
   16ff4:	9b03      	ldr	r3, [sp, #12]
   16ff6:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
   16ffa:	9303      	str	r3, [sp, #12]
                    break;
   16ffc:	e005      	b.n	1700a <CanIf_Transmit+0xae>
                    PduInfo.id |= 0x40000000U;
   16ffe:	9b03      	ldr	r3, [sp, #12]
   17000:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
   17004:	9303      	str	r3, [sp, #12]
                    break;
   17006:	e000      	b.n	1700a <CanIf_Transmit+0xae>
                    break;
   17008:	bf00      	nop
                }
            }
            
            PduInfo.length = (uint8)(PduInfoPtr->SduLength);
   1700a:	9b00      	ldr	r3, [sp, #0]
   1700c:	689b      	ldr	r3, [r3, #8]
   1700e:	b2db      	uxtb	r3, r3
   17010:	f88d 3012 	strb.w	r3, [sp, #18]
            PduInfo.sdu = PduInfoPtr->SduDataPtr;
   17014:	9b00      	ldr	r3, [sp, #0]
   17016:	681b      	ldr	r3, [r3, #0]
   17018:	9305      	str	r3, [sp, #20]
            PduInfo.swPduHandle = CanTxPduId;
   1701a:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   1701e:	f8ad 3010 	strh.w	r3, [sp, #16]

            RetVal = CanIfController->CanDrvConfigPtr->CanApi->CanWrite(CanHth, &PduInfo); 
   17022:	9b06      	ldr	r3, [sp, #24]
   17024:	685b      	ldr	r3, [r3, #4]
   17026:	685b      	ldr	r3, [r3, #4]
   17028:	681b      	ldr	r3, [r3, #0]
   1702a:	a903      	add	r1, sp, #12
   1702c:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
   17030:	4610      	mov	r0, r2
   17032:	4798      	blx	r3
   17034:	4603      	mov	r3, r0
   17036:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
        }
    }
    return RetVal;
   1703a:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
}
   1703e:	4618      	mov	r0, r3
   17040:	b00b      	add	sp, #44	; 0x2c
   17042:	f85d fb04 	ldr.w	pc, [sp], #4
   17046:	bf00      	nop
   17048:	1fff98f0 	.word	0x1fff98f0
   1704c:	00018c14 	.word	0x00018c14

00017050 <CanIf_TxConfirmation>:

void CanIf_TxConfirmation
(
    PduIdType CanTxPduId
)
{
   17050:	b500      	push	{lr}
   17052:	b085      	sub	sp, #20
   17054:	4603      	mov	r3, r0
   17056:	f8ad 3006 	strh.w	r3, [sp, #6]
    PduIdType UserPduId;
    const CanIf_TxPduType * TxPduInfo = NULL_PTR;
   1705a:	2300      	movs	r3, #0
   1705c:	9303      	str	r3, [sp, #12]

    if (NULL_PTR != CanIf_ConfigPtr)
   1705e:	4b15      	ldr	r3, [pc, #84]	; (170b4 <CanIf_TxConfirmation+0x64>)
   17060:	681b      	ldr	r3, [r3, #0]
   17062:	2b00      	cmp	r3, #0
   17064:	d021      	beq.n	170aa <CanIf_TxConfirmation+0x5a>
    {
        if (CanTxPduId < (CanIf_ConfigPtr->NumTxPdu))
   17066:	4b13      	ldr	r3, [pc, #76]	; (170b4 <CanIf_TxConfirmation+0x64>)
   17068:	681b      	ldr	r3, [r3, #0]
   1706a:	785b      	ldrb	r3, [r3, #1]
   1706c:	b29b      	uxth	r3, r3
   1706e:	f8bd 2006 	ldrh.w	r2, [sp, #6]
   17072:	429a      	cmp	r2, r3
   17074:	d219      	bcs.n	170aa <CanIf_TxConfirmation+0x5a>
        {
            TxPduInfo = &CanIf_ConfigPtr->CanIf_TxPduConfigPtr[CanTxPduId];
   17076:	4b0f      	ldr	r3, [pc, #60]	; (170b4 <CanIf_TxConfirmation+0x64>)
   17078:	681b      	ldr	r3, [r3, #0]
   1707a:	68d9      	ldr	r1, [r3, #12]
   1707c:	f8bd 2006 	ldrh.w	r2, [sp, #6]
   17080:	4613      	mov	r3, r2
   17082:	009b      	lsls	r3, r3, #2
   17084:	4413      	add	r3, r2
   17086:	009b      	lsls	r3, r3, #2
   17088:	440b      	add	r3, r1
   1708a:	9303      	str	r3, [sp, #12]

            if (NULL_PTR != TxPduInfo->UserTxConfirmation)
   1708c:	9b03      	ldr	r3, [sp, #12]
   1708e:	691b      	ldr	r3, [r3, #16]
   17090:	2b00      	cmp	r3, #0
   17092:	d00a      	beq.n	170aa <CanIf_TxConfirmation+0x5a>
            {
                UserPduId = TxPduInfo->PduId;
   17094:	9b03      	ldr	r3, [sp, #12]
   17096:	881b      	ldrh	r3, [r3, #0]
   17098:	f8ad 300a 	strh.w	r3, [sp, #10]
                TxPduInfo->UserTxConfirmation(UserPduId, E_OK);
   1709c:	9b03      	ldr	r3, [sp, #12]
   1709e:	691b      	ldr	r3, [r3, #16]
   170a0:	f8bd 200a 	ldrh.w	r2, [sp, #10]
   170a4:	2100      	movs	r1, #0
   170a6:	4610      	mov	r0, r2
   170a8:	4798      	blx	r3
            }
        }
    }
}
   170aa:	bf00      	nop
   170ac:	b005      	add	sp, #20
   170ae:	f85d fb04 	ldr.w	pc, [sp], #4
   170b2:	bf00      	nop
   170b4:	1fff98f0 	.word	0x1fff98f0

000170b8 <CanIf_RxIndication>:
void CanIf_RxIndication
(
    const Can_HwType * Mailbox,
    const PduInfoType * PduInfoPtr
)
{
   170b8:	b500      	push	{lr}
   170ba:	b089      	sub	sp, #36	; 0x24
   170bc:	9001      	str	r0, [sp, #4]
   170be:	9100      	str	r1, [sp, #0]
    PduIdType UserPduId = 0U;
   170c0:	2300      	movs	r3, #0
   170c2:	f8ad 301e 	strh.w	r3, [sp, #30]
    PduInfoType PduInfo;
    const CanIf_RxPduType * RxPduInfo = NULL_PTR;
   170c6:	2300      	movs	r3, #0
   170c8:	9306      	str	r3, [sp, #24]
    uint8 CanDrvId = 0U;
   170ca:	2300      	movs	r3, #0
   170cc:	f88d 3017 	strb.w	r3, [sp, #23]

    if (NULL_PTR != CanIf_ConfigPtr)
   170d0:	4b2c      	ldr	r3, [pc, #176]	; (17184 <CanIf_RxIndication+0xcc>)
   170d2:	681b      	ldr	r3, [r3, #0]
   170d4:	2b00      	cmp	r3, #0
   170d6:	d050      	beq.n	1717a <CanIf_RxIndication+0xc2>
    {
        if ((Mailbox->ControllerId) < (CanIf_PCConfig.NumOfCtrl))
   170d8:	9b01      	ldr	r3, [sp, #4]
   170da:	799a      	ldrb	r2, [r3, #6]
   170dc:	4b2a      	ldr	r3, [pc, #168]	; (17188 <CanIf_RxIndication+0xd0>)
   170de:	781b      	ldrb	r3, [r3, #0]
   170e0:	429a      	cmp	r2, r3
   170e2:	d24a      	bcs.n	1717a <CanIf_RxIndication+0xc2>
        {
            if ((Mailbox->Hoh) < (CanIf_PCConfig.CanIfCtrlConfigPtr[Mailbox->ControllerId].CanDrvConfigPtr->NumCanHoh))
   170e4:	9b01      	ldr	r3, [sp, #4]
   170e6:	889a      	ldrh	r2, [r3, #4]
   170e8:	4b27      	ldr	r3, [pc, #156]	; (17188 <CanIf_RxIndication+0xd0>)
   170ea:	6859      	ldr	r1, [r3, #4]
   170ec:	9b01      	ldr	r3, [sp, #4]
   170ee:	799b      	ldrb	r3, [r3, #6]
   170f0:	00db      	lsls	r3, r3, #3
   170f2:	440b      	add	r3, r1
   170f4:	685b      	ldr	r3, [r3, #4]
   170f6:	885b      	ldrh	r3, [r3, #2]
   170f8:	429a      	cmp	r2, r3
   170fa:	d23e      	bcs.n	1717a <CanIf_RxIndication+0xc2>
            {
                CanDrvId = CanIf_PCConfig.CanIfCtrlConfigPtr[Mailbox->ControllerId].CanDrvConfigPtr->CanDrvId;
   170fc:	4b22      	ldr	r3, [pc, #136]	; (17188 <CanIf_RxIndication+0xd0>)
   170fe:	685a      	ldr	r2, [r3, #4]
   17100:	9b01      	ldr	r3, [sp, #4]
   17102:	799b      	ldrb	r3, [r3, #6]
   17104:	00db      	lsls	r3, r3, #3
   17106:	4413      	add	r3, r2
   17108:	685b      	ldr	r3, [r3, #4]
   1710a:	781b      	ldrb	r3, [r3, #0]
   1710c:	f88d 3017 	strb.w	r3, [sp, #23]
                RxPduInfo = CanIf_ConfigPtr->CanDrvConfigPtr[CanDrvId]->HohToRxPduMappingPtr[Mailbox->Hoh];
   17110:	4b1c      	ldr	r3, [pc, #112]	; (17184 <CanIf_RxIndication+0xcc>)
   17112:	681b      	ldr	r3, [r3, #0]
   17114:	685a      	ldr	r2, [r3, #4]
   17116:	f89d 3017 	ldrb.w	r3, [sp, #23]
   1711a:	009b      	lsls	r3, r3, #2
   1711c:	4413      	add	r3, r2
   1711e:	681b      	ldr	r3, [r3, #0]
   17120:	681a      	ldr	r2, [r3, #0]
   17122:	9b01      	ldr	r3, [sp, #4]
   17124:	889b      	ldrh	r3, [r3, #4]
   17126:	009b      	lsls	r3, r3, #2
   17128:	4413      	add	r3, r2
   1712a:	681b      	ldr	r3, [r3, #0]
   1712c:	9306      	str	r3, [sp, #24]
                
                /* Will discard the Can HOH if it was not referred by any CanIf RxPDU */
                if (NULL_PTR != RxPduInfo)
   1712e:	9b06      	ldr	r3, [sp, #24]
   17130:	2b00      	cmp	r3, #0
   17132:	d022      	beq.n	1717a <CanIf_RxIndication+0xc2>
                {
                    if (NULL_PTR != RxPduInfo->UserRxIndication)
   17134:	9b06      	ldr	r3, [sp, #24]
   17136:	689b      	ldr	r3, [r3, #8]
   17138:	2b00      	cmp	r3, #0
   1713a:	d01e      	beq.n	1717a <CanIf_RxIndication+0xc2>
                    {
                        UserPduId = RxPduInfo->PduId;
   1713c:	9b06      	ldr	r3, [sp, #24]
   1713e:	881b      	ldrh	r3, [r3, #0]
   17140:	f8ad 301e 	strh.w	r3, [sp, #30]
                        if ((TRUE == RxPduInfo->PduLengthCheck) && (PduInfoPtr->SduLength > (RxPduInfo->PduLength)))
   17144:	9b06      	ldr	r3, [sp, #24]
   17146:	789b      	ldrb	r3, [r3, #2]
   17148:	2b00      	cmp	r3, #0
   1714a:	d009      	beq.n	17160 <CanIf_RxIndication+0xa8>
   1714c:	9b00      	ldr	r3, [sp, #0]
   1714e:	689b      	ldr	r3, [r3, #8]
   17150:	9a06      	ldr	r2, [sp, #24]
   17152:	8892      	ldrh	r2, [r2, #4]
   17154:	4293      	cmp	r3, r2
   17156:	d903      	bls.n	17160 <CanIf_RxIndication+0xa8>
                        {
                            PduInfo.SduLength = RxPduInfo->PduLength; /* Truncates exceeded data as configured on GUI */
   17158:	9b06      	ldr	r3, [sp, #24]
   1715a:	889b      	ldrh	r3, [r3, #4]
   1715c:	9304      	str	r3, [sp, #16]
   1715e:	e002      	b.n	17166 <CanIf_RxIndication+0xae>
                        }
                        else
                        {
                            PduInfo.SduLength = PduInfoPtr->SduLength;
   17160:	9b00      	ldr	r3, [sp, #0]
   17162:	689b      	ldr	r3, [r3, #8]
   17164:	9304      	str	r3, [sp, #16]
                        }
                        PduInfo.SduDataPtr = PduInfoPtr->SduDataPtr;
   17166:	9b00      	ldr	r3, [sp, #0]
   17168:	681b      	ldr	r3, [r3, #0]
   1716a:	9302      	str	r3, [sp, #8]
                        RxPduInfo->UserRxIndication(UserPduId, &PduInfo);
   1716c:	9b06      	ldr	r3, [sp, #24]
   1716e:	689b      	ldr	r3, [r3, #8]
   17170:	a902      	add	r1, sp, #8
   17172:	f8bd 201e 	ldrh.w	r2, [sp, #30]
   17176:	4610      	mov	r0, r2
   17178:	4798      	blx	r3
                    }
                }
            }
        }
    }
}
   1717a:	bf00      	nop
   1717c:	b009      	add	sp, #36	; 0x24
   1717e:	f85d fb04 	ldr.w	pc, [sp], #4
   17182:	bf00      	nop
   17184:	1fff98f0 	.word	0x1fff98f0
   17188:	00018c14 	.word	0x00018c14

0001718c <CanIf_ControllerModeIndication>:
void CanIf_ControllerModeIndication
( 
    uint8 ControllerId, 
    Can_ControllerStateType ControllerMode 
)
{
   1718c:	b082      	sub	sp, #8
   1718e:	4603      	mov	r3, r0
   17190:	9100      	str	r1, [sp, #0]
   17192:	f88d 3007 	strb.w	r3, [sp, #7]
    (void)ControllerId; 
    (void)ControllerMode;
}
   17196:	bf00      	nop
   17198:	b002      	add	sp, #8
   1719a:	4770      	bx	lr

0001719c <CanIf_ControllerBusOff>:

void CanIf_ControllerBusOff ( uint8 ControllerId ) {
   1719c:	b500      	push	{lr}
   1719e:	b083      	sub	sp, #12
   171a0:	4603      	mov	r3, r0
   171a2:	f88d 3007 	strb.w	r3, [sp, #7]
    switch ( ControllerId ) { //Identifying which CAN controller is in bus off state.
   171a6:	f89d 3007 	ldrb.w	r3, [sp, #7]
   171aa:	2b00      	cmp	r3, #0
   171ac:	d002      	beq.n	171b4 <CanIf_ControllerBusOff+0x18>
   171ae:	2b01      	cmp	r3, #1
   171b0:	d007      	beq.n	171c2 <CanIf_ControllerBusOff+0x26>
            CanIf_Can0_bTxFlag = TRUE;  //For restarting transmission routine.
            CanIf_Can0_BusOff_Count++;
        break;
        
        default:
        break;
   171b2:	e018      	b.n	171e6 <CanIf_ControllerBusOff+0x4a>
            CanIf_Can2_BusOff_Count++;
   171b4:	4b0e      	ldr	r3, [pc, #56]	; (171f0 <CanIf_ControllerBusOff+0x54>)
   171b6:	881b      	ldrh	r3, [r3, #0]
   171b8:	3301      	adds	r3, #1
   171ba:	b29a      	uxth	r2, r3
   171bc:	4b0c      	ldr	r3, [pc, #48]	; (171f0 <CanIf_ControllerBusOff+0x54>)
   171be:	801a      	strh	r2, [r3, #0]
        break;
   171c0:	e011      	b.n	171e6 <CanIf_ControllerBusOff+0x4a>
            CanIf_SetControllerMode( CanIfFlexCan0 , CAN_CS_STOPPED );
   171c2:	2102      	movs	r1, #2
   171c4:	2001      	movs	r0, #1
   171c6:	f000 f819 	bl	171fc <CanIf_SetControllerMode>
            CanIf_SetControllerMode( CanIfFlexCan0 , CAN_CS_STARTED );
   171ca:	2101      	movs	r1, #1
   171cc:	2001      	movs	r0, #1
   171ce:	f000 f815 	bl	171fc <CanIf_SetControllerMode>
            CanIf_Can0_bTxFlag = TRUE;  //For restarting transmission routine.
   171d2:	4b08      	ldr	r3, [pc, #32]	; (171f4 <CanIf_ControllerBusOff+0x58>)
   171d4:	2201      	movs	r2, #1
   171d6:	701a      	strb	r2, [r3, #0]
            CanIf_Can0_BusOff_Count++;
   171d8:	4b07      	ldr	r3, [pc, #28]	; (171f8 <CanIf_ControllerBusOff+0x5c>)
   171da:	881b      	ldrh	r3, [r3, #0]
   171dc:	3301      	adds	r3, #1
   171de:	b29a      	uxth	r2, r3
   171e0:	4b05      	ldr	r3, [pc, #20]	; (171f8 <CanIf_ControllerBusOff+0x5c>)
   171e2:	801a      	strh	r2, [r3, #0]
        break;
   171e4:	bf00      	nop
    }
}
   171e6:	bf00      	nop
   171e8:	b003      	add	sp, #12
   171ea:	f85d fb04 	ldr.w	pc, [sp], #4
   171ee:	bf00      	nop
   171f0:	1fff8b36 	.word	0x1fff8b36
   171f4:	1fff8b30 	.word	0x1fff8b30
   171f8:	1fff8b34 	.word	0x1fff8b34

000171fc <CanIf_SetControllerMode>:
 * 
 * @param Controller CanIf controller ID.
 * @param Transition Desired state.
 * @return RetVal Status of the operation.
 */
Std_ReturnType CanIf_SetControllerMode( uint8 Controller, Can_ControllerStateType Transition ) {
   171fc:	b500      	push	{lr}
   171fe:	b087      	sub	sp, #28
   17200:	4603      	mov	r3, r0
   17202:	9100      	str	r1, [sp, #0]
   17204:	f88d 3007 	strb.w	r3, [sp, #7]
    //Local data.
    Std_ReturnType RetVal = E_NOT_OK;
   17208:	2301      	movs	r3, #1
   1720a:	f88d 3017 	strb.w	r3, [sp, #23]
    const CanIf_CtrlPCConfigType * CanIfControllerConf = NULL_PTR;    //Pointer to CanIf controller configuration.
   1720e:	2300      	movs	r3, #0
   17210:	9304      	str	r3, [sp, #16]
    uint8 CanController_ID = 0; //Can controller ID.
   17212:	2300      	movs	r3, #0
   17214:	f88d 300f 	strb.w	r3, [sp, #15]


    if ( CanIf_ConfigPtr != NULL_PTR ) { 
   17218:	4b13      	ldr	r3, [pc, #76]	; (17268 <CanIf_SetControllerMode+0x6c>)
   1721a:	681b      	ldr	r3, [r3, #0]
   1721c:	2b00      	cmp	r3, #0
   1721e:	d01c      	beq.n	1725a <CanIf_SetControllerMode+0x5e>
        if ( Controller < CanIf_PCConfig.NumOfCtrl ) { //Operation can be done as normal.
   17220:	4b12      	ldr	r3, [pc, #72]	; (1726c <CanIf_SetControllerMode+0x70>)
   17222:	781b      	ldrb	r3, [r3, #0]
   17224:	f89d 2007 	ldrb.w	r2, [sp, #7]
   17228:	429a      	cmp	r2, r3
   1722a:	d216      	bcs.n	1725a <CanIf_SetControllerMode+0x5e>
            CanIfControllerConf = &CanIf_PCConfig.CanIfCtrlConfigPtr[ Controller ];
   1722c:	4b0f      	ldr	r3, [pc, #60]	; (1726c <CanIf_SetControllerMode+0x70>)
   1722e:	685a      	ldr	r2, [r3, #4]
   17230:	f89d 3007 	ldrb.w	r3, [sp, #7]
   17234:	00db      	lsls	r3, r3, #3
   17236:	4413      	add	r3, r2
   17238:	9304      	str	r3, [sp, #16]
            CanController_ID = CanIfControllerConf->CanCtrlId;
   1723a:	9b04      	ldr	r3, [sp, #16]
   1723c:	785b      	ldrb	r3, [r3, #1]
   1723e:	f88d 300f 	strb.w	r3, [sp, #15]
            RetVal = CanIfControllerConf->CanDrvConfigPtr->CanApi->CanSetMode( CanController_ID, Transition );   //Calling Can Driver Api.
   17242:	9b04      	ldr	r3, [sp, #16]
   17244:	685b      	ldr	r3, [r3, #4]
   17246:	685b      	ldr	r3, [r3, #4]
   17248:	685b      	ldr	r3, [r3, #4]
   1724a:	f89d 200f 	ldrb.w	r2, [sp, #15]
   1724e:	9900      	ldr	r1, [sp, #0]
   17250:	4610      	mov	r0, r2
   17252:	4798      	blx	r3
   17254:	4603      	mov	r3, r0
   17256:	f88d 3017 	strb.w	r3, [sp, #23]
        }
    }

    return RetVal;
   1725a:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
   1725e:	4618      	mov	r0, r3
   17260:	b007      	add	sp, #28
   17262:	f85d fb04 	ldr.w	pc, [sp], #4
   17266:	bf00      	nop
   17268:	1fff98f0 	.word	0x1fff98f0
   1726c:	00018c14 	.word	0x00018c14

00017270 <CanIf_EnableControllerInterrupts>:
/**
 * @brief This function enables the interrupts of a given CanIf controller.
 * 
 * @param Controller CanIf controller ID.
 */
void CanIf_EnableControllerInterrupts( uint8 Controller ) {
   17270:	b500      	push	{lr}
   17272:	b085      	sub	sp, #20
   17274:	4603      	mov	r3, r0
   17276:	f88d 3007 	strb.w	r3, [sp, #7]
    //local data.
    const CanIf_CtrlPCConfigType * CanIfControllerConf = NULL_PTR;    //Pointer to CanIf controller configuration.
   1727a:	2300      	movs	r3, #0
   1727c:	9303      	str	r3, [sp, #12]
    uint8 CanController_ID = 0; //Can controller ID.
   1727e:	2300      	movs	r3, #0
   17280:	f88d 300b 	strb.w	r3, [sp, #11]

    if ( CanIf_ConfigPtr != NULL_PTR ) { 
   17284:	4b10      	ldr	r3, [pc, #64]	; (172c8 <CanIf_EnableControllerInterrupts+0x58>)
   17286:	681b      	ldr	r3, [r3, #0]
   17288:	2b00      	cmp	r3, #0
   1728a:	d018      	beq.n	172be <CanIf_EnableControllerInterrupts+0x4e>
        if ( Controller < CanIf_PCConfig.NumOfCtrl ) { //Operation can be done as normal.
   1728c:	4b0f      	ldr	r3, [pc, #60]	; (172cc <CanIf_EnableControllerInterrupts+0x5c>)
   1728e:	781b      	ldrb	r3, [r3, #0]
   17290:	f89d 2007 	ldrb.w	r2, [sp, #7]
   17294:	429a      	cmp	r2, r3
   17296:	d212      	bcs.n	172be <CanIf_EnableControllerInterrupts+0x4e>
            CanIfControllerConf = &CanIf_PCConfig.CanIfCtrlConfigPtr[ Controller ];
   17298:	4b0c      	ldr	r3, [pc, #48]	; (172cc <CanIf_EnableControllerInterrupts+0x5c>)
   1729a:	685a      	ldr	r2, [r3, #4]
   1729c:	f89d 3007 	ldrb.w	r3, [sp, #7]
   172a0:	00db      	lsls	r3, r3, #3
   172a2:	4413      	add	r3, r2
   172a4:	9303      	str	r3, [sp, #12]
            CanController_ID = CanIfControllerConf->CanCtrlId;
   172a6:	9b03      	ldr	r3, [sp, #12]
   172a8:	785b      	ldrb	r3, [r3, #1]
   172aa:	f88d 300b 	strb.w	r3, [sp, #11]
            CanIfControllerConf->CanDrvConfigPtr->CanApi->CanEnableInterrupts( CanController_ID );   //Calling Can Driver Api.
   172ae:	9b03      	ldr	r3, [sp, #12]
   172b0:	685b      	ldr	r3, [r3, #4]
   172b2:	685b      	ldr	r3, [r3, #4]
   172b4:	689b      	ldr	r3, [r3, #8]
   172b6:	f89d 200b 	ldrb.w	r2, [sp, #11]
   172ba:	4610      	mov	r0, r2
   172bc:	4798      	blx	r3
        }
    }
}
   172be:	bf00      	nop
   172c0:	b005      	add	sp, #20
   172c2:	f85d fb04 	ldr.w	pc, [sp], #4
   172c6:	bf00      	nop
   172c8:	1fff98f0 	.word	0x1fff98f0
   172cc:	00018c14 	.word	0x00018c14

000172d0 <CanIf_DisableControllerInterrupts>:
/**
 * @brief This function disables the interrupts of a given CanIf controller.
 * 
 * @param Controller CanIf controller ID.
 */
void CanIf_DisableControllerInterrupts( uint8 Controller ) {
   172d0:	b500      	push	{lr}
   172d2:	b085      	sub	sp, #20
   172d4:	4603      	mov	r3, r0
   172d6:	f88d 3007 	strb.w	r3, [sp, #7]
    //local data.
    const CanIf_CtrlPCConfigType * CanIfControllerConf = NULL_PTR;    //Pointer to CanIf controller configuration.
   172da:	2300      	movs	r3, #0
   172dc:	9303      	str	r3, [sp, #12]
    uint8 CanController_ID = 0; //Can controller ID.
   172de:	2300      	movs	r3, #0
   172e0:	f88d 300b 	strb.w	r3, [sp, #11]

    if ( CanIf_ConfigPtr != NULL_PTR ) { 
   172e4:	4b10      	ldr	r3, [pc, #64]	; (17328 <CanIf_DisableControllerInterrupts+0x58>)
   172e6:	681b      	ldr	r3, [r3, #0]
   172e8:	2b00      	cmp	r3, #0
   172ea:	d018      	beq.n	1731e <CanIf_DisableControllerInterrupts+0x4e>
        if ( Controller < CanIf_PCConfig.NumOfCtrl ) { //Operation can be done as normal.
   172ec:	4b0f      	ldr	r3, [pc, #60]	; (1732c <CanIf_DisableControllerInterrupts+0x5c>)
   172ee:	781b      	ldrb	r3, [r3, #0]
   172f0:	f89d 2007 	ldrb.w	r2, [sp, #7]
   172f4:	429a      	cmp	r2, r3
   172f6:	d212      	bcs.n	1731e <CanIf_DisableControllerInterrupts+0x4e>
            CanIfControllerConf = &CanIf_PCConfig.CanIfCtrlConfigPtr[ Controller ];
   172f8:	4b0c      	ldr	r3, [pc, #48]	; (1732c <CanIf_DisableControllerInterrupts+0x5c>)
   172fa:	685a      	ldr	r2, [r3, #4]
   172fc:	f89d 3007 	ldrb.w	r3, [sp, #7]
   17300:	00db      	lsls	r3, r3, #3
   17302:	4413      	add	r3, r2
   17304:	9303      	str	r3, [sp, #12]
            CanController_ID = CanIfControllerConf->CanCtrlId;
   17306:	9b03      	ldr	r3, [sp, #12]
   17308:	785b      	ldrb	r3, [r3, #1]
   1730a:	f88d 300b 	strb.w	r3, [sp, #11]
            CanIfControllerConf->CanDrvConfigPtr->CanApi->CanDisableInterrupts( CanController_ID );   //Calling Can Driver Api.
   1730e:	9b03      	ldr	r3, [sp, #12]
   17310:	685b      	ldr	r3, [r3, #4]
   17312:	685b      	ldr	r3, [r3, #4]
   17314:	68db      	ldr	r3, [r3, #12]
   17316:	f89d 200b 	ldrb.w	r2, [sp, #11]
   1731a:	4610      	mov	r0, r2
   1731c:	4798      	blx	r3
        }
    }
}
   1731e:	bf00      	nop
   17320:	b005      	add	sp, #20
   17322:	f85d fb04 	ldr.w	pc, [sp], #4
   17326:	bf00      	nop
   17328:	1fff98f0 	.word	0x1fff98f0
   1732c:	00018c14 	.word	0x00018c14

00017330 <CanIf_GetControllerErrorState>:
 * 
 * @param ControllerId CanIf controller ID.
 * @param ErrorStatePtr Pointer to variable to store the actual error state of the controller.
 * @return RetVal Status of the operation. 
 */
Std_ReturnType CanIf_GetControllerErrorState( uint8 ControllerId, Can_ErrorStateType *ErrorStatePtr) {
   17330:	b500      	push	{lr}
   17332:	b087      	sub	sp, #28
   17334:	4603      	mov	r3, r0
   17336:	9100      	str	r1, [sp, #0]
   17338:	f88d 3007 	strb.w	r3, [sp, #7]
    //Local data.
    Std_ReturnType RetVal = E_NOT_OK;
   1733c:	2301      	movs	r3, #1
   1733e:	f88d 3017 	strb.w	r3, [sp, #23]
    const CanIf_CtrlPCConfigType * CanIfControllerConf = NULL_PTR;    //Pointer to CanIf controller configuration.
   17342:	2300      	movs	r3, #0
   17344:	9304      	str	r3, [sp, #16]
    uint8 CanController_ID = 0; //Can controller ID.
   17346:	2300      	movs	r3, #0
   17348:	f88d 300f 	strb.w	r3, [sp, #15]

    if ( CanIf_ConfigPtr != NULL_PTR ) { 
   1734c:	4b13      	ldr	r3, [pc, #76]	; (1739c <CanIf_GetControllerErrorState+0x6c>)
   1734e:	681b      	ldr	r3, [r3, #0]
   17350:	2b00      	cmp	r3, #0
   17352:	d01c      	beq.n	1738e <CanIf_GetControllerErrorState+0x5e>
        if ( ControllerId < CanIf_PCConfig.NumOfCtrl ) { //Operation can be done as normal.
   17354:	4b12      	ldr	r3, [pc, #72]	; (173a0 <CanIf_GetControllerErrorState+0x70>)
   17356:	781b      	ldrb	r3, [r3, #0]
   17358:	f89d 2007 	ldrb.w	r2, [sp, #7]
   1735c:	429a      	cmp	r2, r3
   1735e:	d216      	bcs.n	1738e <CanIf_GetControllerErrorState+0x5e>
            CanIfControllerConf = &CanIf_PCConfig.CanIfCtrlConfigPtr[ ControllerId ];
   17360:	4b0f      	ldr	r3, [pc, #60]	; (173a0 <CanIf_GetControllerErrorState+0x70>)
   17362:	685a      	ldr	r2, [r3, #4]
   17364:	f89d 3007 	ldrb.w	r3, [sp, #7]
   17368:	00db      	lsls	r3, r3, #3
   1736a:	4413      	add	r3, r2
   1736c:	9304      	str	r3, [sp, #16]
            CanController_ID = CanIfControllerConf->CanCtrlId;
   1736e:	9b04      	ldr	r3, [sp, #16]
   17370:	785b      	ldrb	r3, [r3, #1]
   17372:	f88d 300f 	strb.w	r3, [sp, #15]
            RetVal = CanIfControllerConf->CanDrvConfigPtr->CanApi->CanGetErrorState( CanController_ID, ErrorStatePtr );   //Calling Can Driver Api.
   17376:	9b04      	ldr	r3, [sp, #16]
   17378:	685b      	ldr	r3, [r3, #4]
   1737a:	685b      	ldr	r3, [r3, #4]
   1737c:	691b      	ldr	r3, [r3, #16]
   1737e:	f89d 200f 	ldrb.w	r2, [sp, #15]
   17382:	9900      	ldr	r1, [sp, #0]
   17384:	4610      	mov	r0, r2
   17386:	4798      	blx	r3
   17388:	4603      	mov	r3, r0
   1738a:	f88d 3017 	strb.w	r3, [sp, #23]
        }
    }

    return RetVal;
   1738e:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
   17392:	4618      	mov	r0, r3
   17394:	b007      	add	sp, #28
   17396:	f85d fb04 	ldr.w	pc, [sp], #4
   1739a:	bf00      	nop
   1739c:	1fff98f0 	.word	0x1fff98f0
   173a0:	00018c14 	.word	0x00018c14

000173a4 <CanIf_GetControllerMode>:
 * 
 * @param Controller CanIf controller ID.
 * @param ControllerModePtr Pointer to variable to store the actual state of the controller.
 * @return RetVal Status of the operation.
 */
Std_ReturnType CanIf_GetControllerMode( uint8 Controller, Can_ControllerStateType *ControllerModePtr ) {
   173a4:	b500      	push	{lr}
   173a6:	b087      	sub	sp, #28
   173a8:	4603      	mov	r3, r0
   173aa:	9100      	str	r1, [sp, #0]
   173ac:	f88d 3007 	strb.w	r3, [sp, #7]
    //Local data.
    Std_ReturnType RetVal = E_NOT_OK;
   173b0:	2301      	movs	r3, #1
   173b2:	f88d 3017 	strb.w	r3, [sp, #23]
    const CanIf_CtrlPCConfigType * CanIfControllerConf = NULL_PTR;    //Pointer to CanIf controller configuration.
   173b6:	2300      	movs	r3, #0
   173b8:	9304      	str	r3, [sp, #16]
    uint8 CanController_ID = 0; //Can controller ID.
   173ba:	2300      	movs	r3, #0
   173bc:	f88d 300f 	strb.w	r3, [sp, #15]

    if ( CanIf_ConfigPtr != NULL_PTR ) { 
   173c0:	4b13      	ldr	r3, [pc, #76]	; (17410 <CanIf_GetControllerMode+0x6c>)
   173c2:	681b      	ldr	r3, [r3, #0]
   173c4:	2b00      	cmp	r3, #0
   173c6:	d01c      	beq.n	17402 <CanIf_GetControllerMode+0x5e>
        if ( Controller < CanIf_PCConfig.NumOfCtrl ) { //Operation can be done as normal.
   173c8:	4b12      	ldr	r3, [pc, #72]	; (17414 <CanIf_GetControllerMode+0x70>)
   173ca:	781b      	ldrb	r3, [r3, #0]
   173cc:	f89d 2007 	ldrb.w	r2, [sp, #7]
   173d0:	429a      	cmp	r2, r3
   173d2:	d216      	bcs.n	17402 <CanIf_GetControllerMode+0x5e>
            CanIfControllerConf = &CanIf_PCConfig.CanIfCtrlConfigPtr[ Controller ];
   173d4:	4b0f      	ldr	r3, [pc, #60]	; (17414 <CanIf_GetControllerMode+0x70>)
   173d6:	685a      	ldr	r2, [r3, #4]
   173d8:	f89d 3007 	ldrb.w	r3, [sp, #7]
   173dc:	00db      	lsls	r3, r3, #3
   173de:	4413      	add	r3, r2
   173e0:	9304      	str	r3, [sp, #16]
            CanController_ID = CanIfControllerConf->CanCtrlId;
   173e2:	9b04      	ldr	r3, [sp, #16]
   173e4:	785b      	ldrb	r3, [r3, #1]
   173e6:	f88d 300f 	strb.w	r3, [sp, #15]
            RetVal = CanIfControllerConf->CanDrvConfigPtr->CanApi->CanGetMode( CanController_ID, ControllerModePtr );   //Calling Can Driver Api.
   173ea:	9b04      	ldr	r3, [sp, #16]
   173ec:	685b      	ldr	r3, [r3, #4]
   173ee:	685b      	ldr	r3, [r3, #4]
   173f0:	695b      	ldr	r3, [r3, #20]
   173f2:	f89d 200f 	ldrb.w	r2, [sp, #15]
   173f6:	9900      	ldr	r1, [sp, #0]
   173f8:	4610      	mov	r0, r2
   173fa:	4798      	blx	r3
   173fc:	4603      	mov	r3, r0
   173fe:	f88d 3017 	strb.w	r3, [sp, #23]
        }
    }

    return RetVal;
   17402:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
   17406:	4618      	mov	r0, r3
   17408:	b007      	add	sp, #28
   1740a:	f85d fb04 	ldr.w	pc, [sp], #4
   1740e:	bf00      	nop
   17410:	1fff98f0 	.word	0x1fff98f0
   17414:	00018c14 	.word	0x00018c14

00017418 <CanIf_GetControllerRxErrorCounter>:
 * 
 * @param ControllerId CanIf controller ID.
 * @param RxErrorCounterPtr Pointer to variable to store the actual value of the rx error counter of the controller.
 * @return RetVal Status of the operation.
 */
Std_ReturnType CanIf_GetControllerRxErrorCounter( uint8 ControllerId, uint8 *RxErrorCounterPtr ) {
   17418:	b500      	push	{lr}
   1741a:	b087      	sub	sp, #28
   1741c:	4603      	mov	r3, r0
   1741e:	9100      	str	r1, [sp, #0]
   17420:	f88d 3007 	strb.w	r3, [sp, #7]
    //Local data.
    Std_ReturnType RetVal = E_NOT_OK;
   17424:	2301      	movs	r3, #1
   17426:	f88d 3017 	strb.w	r3, [sp, #23]
    const CanIf_CtrlPCConfigType * CanIfControllerConf = NULL_PTR;    //Pointer to CanIf controller configuration.
   1742a:	2300      	movs	r3, #0
   1742c:	9304      	str	r3, [sp, #16]
    uint8 CanController_ID = 0; //Can controller ID.
   1742e:	2300      	movs	r3, #0
   17430:	f88d 300f 	strb.w	r3, [sp, #15]

    if ( CanIf_ConfigPtr != NULL_PTR ) { 
   17434:	4b13      	ldr	r3, [pc, #76]	; (17484 <CanIf_GetControllerRxErrorCounter+0x6c>)
   17436:	681b      	ldr	r3, [r3, #0]
   17438:	2b00      	cmp	r3, #0
   1743a:	d01c      	beq.n	17476 <CanIf_GetControllerRxErrorCounter+0x5e>
        if ( ControllerId < CanIf_PCConfig.NumOfCtrl ) { //Operation can be done as normal.
   1743c:	4b12      	ldr	r3, [pc, #72]	; (17488 <CanIf_GetControllerRxErrorCounter+0x70>)
   1743e:	781b      	ldrb	r3, [r3, #0]
   17440:	f89d 2007 	ldrb.w	r2, [sp, #7]
   17444:	429a      	cmp	r2, r3
   17446:	d216      	bcs.n	17476 <CanIf_GetControllerRxErrorCounter+0x5e>
            CanIfControllerConf = &CanIf_PCConfig.CanIfCtrlConfigPtr[ ControllerId ];
   17448:	4b0f      	ldr	r3, [pc, #60]	; (17488 <CanIf_GetControllerRxErrorCounter+0x70>)
   1744a:	685a      	ldr	r2, [r3, #4]
   1744c:	f89d 3007 	ldrb.w	r3, [sp, #7]
   17450:	00db      	lsls	r3, r3, #3
   17452:	4413      	add	r3, r2
   17454:	9304      	str	r3, [sp, #16]
            CanController_ID = CanIfControllerConf->CanCtrlId;
   17456:	9b04      	ldr	r3, [sp, #16]
   17458:	785b      	ldrb	r3, [r3, #1]
   1745a:	f88d 300f 	strb.w	r3, [sp, #15]
            RetVal = CanIfControllerConf->CanDrvConfigPtr->CanApi->CanGetRxErrorCounter( CanController_ID, RxErrorCounterPtr );   //Calling Can Driver Api.
   1745e:	9b04      	ldr	r3, [sp, #16]
   17460:	685b      	ldr	r3, [r3, #4]
   17462:	685b      	ldr	r3, [r3, #4]
   17464:	699b      	ldr	r3, [r3, #24]
   17466:	f89d 200f 	ldrb.w	r2, [sp, #15]
   1746a:	9900      	ldr	r1, [sp, #0]
   1746c:	4610      	mov	r0, r2
   1746e:	4798      	blx	r3
   17470:	4603      	mov	r3, r0
   17472:	f88d 3017 	strb.w	r3, [sp, #23]
        }
    }

    return RetVal;
   17476:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
   1747a:	4618      	mov	r0, r3
   1747c:	b007      	add	sp, #28
   1747e:	f85d fb04 	ldr.w	pc, [sp], #4
   17482:	bf00      	nop
   17484:	1fff98f0 	.word	0x1fff98f0
   17488:	00018c14 	.word	0x00018c14

0001748c <CanIf_GetControllerTxErrorCounter>:
 * 
 * @param ControllerId CanIf controller ID.
 * @param TxErrorCounterPtr Pointer to variable to store the actual value of the tx error counter of the controller.
 * @return RetVal Status of the operation. 
 */
Std_ReturnType CanIf_GetControllerTxErrorCounter( uint8 ControllerId, uint8 *TxErrorCounterPtr ) {
   1748c:	b500      	push	{lr}
   1748e:	b087      	sub	sp, #28
   17490:	4603      	mov	r3, r0
   17492:	9100      	str	r1, [sp, #0]
   17494:	f88d 3007 	strb.w	r3, [sp, #7]
    //Local data.
    Std_ReturnType RetVal = E_NOT_OK;
   17498:	2301      	movs	r3, #1
   1749a:	f88d 3017 	strb.w	r3, [sp, #23]
    const CanIf_CtrlPCConfigType * CanIfControllerConf = NULL_PTR;    //Pointer to CanIf controller configuration.
   1749e:	2300      	movs	r3, #0
   174a0:	9304      	str	r3, [sp, #16]
    uint8 CanController_ID = 0; //Can controller ID.
   174a2:	2300      	movs	r3, #0
   174a4:	f88d 300f 	strb.w	r3, [sp, #15]

    if ( CanIf_ConfigPtr != NULL_PTR ) { 
   174a8:	4b13      	ldr	r3, [pc, #76]	; (174f8 <CanIf_GetControllerTxErrorCounter+0x6c>)
   174aa:	681b      	ldr	r3, [r3, #0]
   174ac:	2b00      	cmp	r3, #0
   174ae:	d01c      	beq.n	174ea <CanIf_GetControllerTxErrorCounter+0x5e>
        if ( ControllerId < CanIf_PCConfig.NumOfCtrl ) { //Operation can be done as normal.
   174b0:	4b12      	ldr	r3, [pc, #72]	; (174fc <CanIf_GetControllerTxErrorCounter+0x70>)
   174b2:	781b      	ldrb	r3, [r3, #0]
   174b4:	f89d 2007 	ldrb.w	r2, [sp, #7]
   174b8:	429a      	cmp	r2, r3
   174ba:	d216      	bcs.n	174ea <CanIf_GetControllerTxErrorCounter+0x5e>
            CanIfControllerConf = &CanIf_PCConfig.CanIfCtrlConfigPtr[ ControllerId ];
   174bc:	4b0f      	ldr	r3, [pc, #60]	; (174fc <CanIf_GetControllerTxErrorCounter+0x70>)
   174be:	685a      	ldr	r2, [r3, #4]
   174c0:	f89d 3007 	ldrb.w	r3, [sp, #7]
   174c4:	00db      	lsls	r3, r3, #3
   174c6:	4413      	add	r3, r2
   174c8:	9304      	str	r3, [sp, #16]
            CanController_ID = CanIfControllerConf->CanCtrlId;
   174ca:	9b04      	ldr	r3, [sp, #16]
   174cc:	785b      	ldrb	r3, [r3, #1]
   174ce:	f88d 300f 	strb.w	r3, [sp, #15]
            RetVal = CanIfControllerConf->CanDrvConfigPtr->CanApi->CanGetTxErrorCounter( CanController_ID, TxErrorCounterPtr );   //Calling Can Driver Api.
   174d2:	9b04      	ldr	r3, [sp, #16]
   174d4:	685b      	ldr	r3, [r3, #4]
   174d6:	685b      	ldr	r3, [r3, #4]
   174d8:	69db      	ldr	r3, [r3, #28]
   174da:	f89d 200f 	ldrb.w	r2, [sp, #15]
   174de:	9900      	ldr	r1, [sp, #0]
   174e0:	4610      	mov	r0, r2
   174e2:	4798      	blx	r3
   174e4:	4603      	mov	r3, r0
   174e6:	f88d 3017 	strb.w	r3, [sp, #23]
        }
    }

    return RetVal;
   174ea:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
   174ee:	4618      	mov	r0, r3
   174f0:	b007      	add	sp, #28
   174f2:	f85d fb04 	ldr.w	pc, [sp], #4
   174f6:	bf00      	nop
   174f8:	1fff98f0 	.word	0x1fff98f0
   174fc:	00018c14 	.word	0x00018c14

00017500 <Fls_ACEraseRomEnd>:
   17500:	00c9f4de 	.word	0x00c9f4de
   17504:	c5f4deaa 	.word	0xc5f4deaa
   17508:	07ccfeb6 	.word	0x07ccfeb6
   1750c:	aaccdebb 	.word	0xaaccdebb
   17510:	05dd3322 	.word	0x05dd3322
   17514:	33ff4509 	.word	0x33ff4509
   17518:	4422ddff 	.word	0x4422ddff
   1751c:	59461153 	.word	0x59461153
   17520:	000000bb 	.word	0x000000bb
   17524:	5f75634d 	.word	0x5f75634d
   17528:	74696e49 	.word	0x74696e49
   1752c:	00002928 	.word	0x00002928
   17530:	5f75634d 	.word	0x5f75634d
   17534:	74696e49 	.word	0x74696e49
   17538:	636f6c43 	.word	0x636f6c43
   1753c:	0029286b 	.word	0x0029286b
   17540:	5f75634d 	.word	0x5f75634d
   17544:	4d746553 	.word	0x4d746553
   17548:	2865646f 	.word	0x2865646f
   1754c:	00000029 	.word	0x00000029
   17550:	5f75634d 	.word	0x5f75634d
   17554:	56746547 	.word	0x56746547
   17558:	69737265 	.word	0x69737265
   1755c:	6e496e6f 	.word	0x6e496e6f
   17560:	29286f66 	.word	0x29286f66
   17564:	00000000 	.word	0x00000000
   17568:	61766e49 	.word	0x61766e49
   1756c:	2064696c 	.word	0x2064696c
   17570:	666e6f63 	.word	0x666e6f63
   17574:	696f7020 	.word	0x696f7020
   17578:	7265746e 	.word	0x7265746e
   1757c:	00000000 	.word	0x00000000
   17580:	76697244 	.word	0x76697244
   17584:	75207265 	.word	0x75207265
   17588:	696e696e 	.word	0x696e696e
   1758c:	6c616974 	.word	0x6c616974
   17590:	64657a69 	.word	0x64657a69
   17594:	00000000 	.word	0x00000000
   17598:	76697244 	.word	0x76697244
   1759c:	61207265 	.word	0x61207265
   175a0:	6165726c 	.word	0x6165726c
   175a4:	69207964 	.word	0x69207964
   175a8:	6974696e 	.word	0x6974696e
   175ac:	7a696c61 	.word	0x7a696c61
   175b0:	00006465 	.word	0x00006465
   175b4:	61766e49 	.word	0x61766e49
   175b8:	2064696c 	.word	0x2064696c
   175bc:	75706e69 	.word	0x75706e69
   175c0:	61702074 	.word	0x61702074
   175c4:	656d6172 	.word	0x656d6172
   175c8:	00726574 	.word	0x00726574
   175cc:	74616c50 	.word	0x74616c50
   175d0:	6d726f66 	.word	0x6d726f66
   175d4:	696e495f 	.word	0x696e495f
   175d8:	00292874 	.word	0x00292874
   175dc:	74616c50 	.word	0x74616c50
   175e0:	6d726f66 	.word	0x6d726f66
   175e4:	7465535f 	.word	0x7465535f
   175e8:	28717249 	.word	0x28717249
   175ec:	00000029 	.word	0x00000029
   175f0:	74616c50 	.word	0x74616c50
   175f4:	6d726f66 	.word	0x6d726f66
   175f8:	7465535f 	.word	0x7465535f
   175fc:	50717249 	.word	0x50717249
   17600:	726f6972 	.word	0x726f6972
   17604:	28797469 	.word	0x28797469
   17608:	00000029 	.word	0x00000029
   1760c:	74616c50 	.word	0x74616c50
   17610:	6d726f66 	.word	0x6d726f66
   17614:	7465475f 	.word	0x7465475f
   17618:	50717249 	.word	0x50717249
   1761c:	726f6972 	.word	0x726f6972
   17620:	28797469 	.word	0x28797469
   17624:	00000029 	.word	0x00000029
   17628:	74616c50 	.word	0x74616c50
   1762c:	6d726f66 	.word	0x6d726f66
   17630:	736e495f 	.word	0x736e495f
   17634:	6c6c6174 	.word	0x6c6c6174
   17638:	48717249 	.word	0x48717249
   1763c:	6c646e61 	.word	0x6c646e61
   17640:	29287265 	.word	0x29287265
   17644:	00000000 	.word	0x00000000
   17648:	61766e49 	.word	0x61766e49
   1764c:	2064696c 	.word	0x2064696c
   17650:	6e696f70 	.word	0x6e696f70
   17654:	00726574 	.word	0x00726574
   17658:	6c6c6143 	.word	0x6c6c6143
   1765c:	6f726620 	.word	0x6f726620
   17660:	7277206d 	.word	0x7277206d
   17664:	20676e6f 	.word	0x20676e6f
   17668:	7070616d 	.word	0x7070616d
   1766c:	70206465 	.word	0x70206465
   17670:	69747261 	.word	0x69747261
   17674:	6e6f6974 	.word	0x6e6f6974
   17678:	00000000 	.word	0x00000000
   1767c:	61726150 	.word	0x61726150
   17680:	6574656d 	.word	0x6574656d
   17684:	756f2072 	.word	0x756f2072
   17688:	666f2074 	.word	0x666f2074
   1768c:	6e617220 	.word	0x6e617220
   17690:	00006567 	.word	0x00006567
   17694:	74726f50 	.word	0x74726f50
   17698:	696e495f 	.word	0x696e495f
   1769c:	00292874 	.word	0x00292874
   176a0:	74726f50 	.word	0x74726f50
   176a4:	7465535f 	.word	0x7465535f
   176a8:	446e6950 	.word	0x446e6950
   176ac:	63657269 	.word	0x63657269
   176b0:	6e6f6974 	.word	0x6e6f6974
   176b4:	00002928 	.word	0x00002928
   176b8:	74726f50 	.word	0x74726f50
   176bc:	7465535f 	.word	0x7465535f
   176c0:	4d6e6950 	.word	0x4d6e6950
   176c4:	2865646f 	.word	0x2865646f
   176c8:	00000029 	.word	0x00000029
   176cc:	74726f50 	.word	0x74726f50
   176d0:	6665525f 	.word	0x6665525f
   176d4:	68736572 	.word	0x68736572
   176d8:	74726f50 	.word	0x74726f50
   176dc:	65726944 	.word	0x65726944
   176e0:	6f697463 	.word	0x6f697463
   176e4:	0029286e 	.word	0x0029286e
   176e8:	74726f50 	.word	0x74726f50
   176ec:	7465475f 	.word	0x7465475f
   176f0:	73726556 	.word	0x73726556
   176f4:	496e6f69 	.word	0x496e6f69
   176f8:	286f666e 	.word	0x286f666e
   176fc:	00000029 	.word	0x00000029
   17700:	61766e49 	.word	0x61766e49
   17704:	2064696c 	.word	0x2064696c
   17708:	74726f50 	.word	0x74726f50
   1770c:	6e695020 	.word	0x6e695020
   17710:	00444920 	.word	0x00444920
   17714:	74726f50 	.word	0x74726f50
   17718:	6e697020 	.word	0x6e697020
   1771c:	646f6d20 	.word	0x646f6d20
   17720:	73692065 	.word	0x73692065
   17724:	636e7520 	.word	0x636e7520
   17728:	676e6168 	.word	0x676e6168
   1772c:	6c626165 	.word	0x6c626165
   17730:	00000065 	.word	0x00000065
   17734:	61766e49 	.word	0x61766e49
   17738:	2064696c 	.word	0x2064696c
   1773c:	74726f70 	.word	0x74726f70
   17740:	6e697020 	.word	0x6e697020
   17744:	646f6d20 	.word	0x646f6d20
   17748:	00000065 	.word	0x00000065
   1774c:	5f6f6944 	.word	0x5f6f6944
   17750:	74697257 	.word	0x74697257
   17754:	61684365 	.word	0x61684365
   17758:	6c656e6e 	.word	0x6c656e6e
   1775c:	00002928 	.word	0x00002928
   17760:	5f6f6944 	.word	0x5f6f6944
   17764:	64616552 	.word	0x64616552
   17768:	6e616843 	.word	0x6e616843
   1776c:	286c656e 	.word	0x286c656e
   17770:	00000029 	.word	0x00000029
   17774:	5f6f6944 	.word	0x5f6f6944
   17778:	70696c46 	.word	0x70696c46
   1777c:	6e616843 	.word	0x6e616843
   17780:	286c656e 	.word	0x286c656e
   17784:	00000029 	.word	0x00000029
   17788:	5f6f6944 	.word	0x5f6f6944
   1778c:	74697257 	.word	0x74697257
   17790:	61684365 	.word	0x61684365
   17794:	6c656e6e 	.word	0x6c656e6e
   17798:	756f7247 	.word	0x756f7247
   1779c:	00292870 	.word	0x00292870
   177a0:	5f6f6944 	.word	0x5f6f6944
   177a4:	64616552 	.word	0x64616552
   177a8:	6e616843 	.word	0x6e616843
   177ac:	476c656e 	.word	0x476c656e
   177b0:	70756f72 	.word	0x70756f72
   177b4:	00002928 	.word	0x00002928
   177b8:	5f6f6944 	.word	0x5f6f6944
   177bc:	74697257 	.word	0x74697257
   177c0:	726f5065 	.word	0x726f5065
   177c4:	00292874 	.word	0x00292874
   177c8:	5f6f6944 	.word	0x5f6f6944
   177cc:	64616552 	.word	0x64616552
   177d0:	74726f50 	.word	0x74726f50
   177d4:	00002928 	.word	0x00002928
   177d8:	5f6f6944 	.word	0x5f6f6944
   177dc:	56746547 	.word	0x56746547
   177e0:	69737265 	.word	0x69737265
   177e4:	6e496e6f 	.word	0x6e496e6f
   177e8:	29286f66 	.word	0x29286f66
   177ec:	00000000 	.word	0x00000000
   177f0:	61766e49 	.word	0x61766e49
   177f4:	2064696c 	.word	0x2064696c
   177f8:	206f6964 	.word	0x206f6964
   177fc:	6e616863 	.word	0x6e616863
   17800:	206c656e 	.word	0x206c656e
   17804:	6576656c 	.word	0x6576656c
   17808:	0000006c 	.word	0x0000006c
   1780c:	61766e49 	.word	0x61766e49
   17810:	2064696c 	.word	0x2064696c
   17814:	206f6964 	.word	0x206f6964
   17818:	6e616863 	.word	0x6e616863
   1781c:	206c656e 	.word	0x206c656e
   17820:	00006469 	.word	0x00006469
   17824:	61766e49 	.word	0x61766e49
   17828:	2064696c 	.word	0x2064696c
   1782c:	74726f70 	.word	0x74726f70
   17830:	00646920 	.word	0x00646920
   17834:	61766e49 	.word	0x61766e49
   17838:	2064696c 	.word	0x2064696c
   1783c:	6e616863 	.word	0x6e616863
   17840:	206c656e 	.word	0x206c656e
   17844:	756f7267 	.word	0x756f7267
   17848:	64692070 	.word	0x64692070
   1784c:	00000000 	.word	0x00000000
   17850:	61766e49 	.word	0x61766e49
   17854:	2064696c 	.word	0x2064696c
   17858:	666e6f63 	.word	0x666e6f63
   1785c:	70206769 	.word	0x70206769
   17860:	6d617261 	.word	0x6d617261
   17864:	72657465 	.word	0x72657465
   17868:	00000000 	.word	0x00000000
   1786c:	5f6d7750 	.word	0x5f6d7750
   17870:	74696e49 	.word	0x74696e49
   17874:	00002928 	.word	0x00002928
   17878:	5f6d7750 	.word	0x5f6d7750
   1787c:	6e496544 	.word	0x6e496544
   17880:	29287469 	.word	0x29287469
   17884:	00000000 	.word	0x00000000
   17888:	5f6d7750 	.word	0x5f6d7750
   1788c:	44746553 	.word	0x44746553
   17890:	43797475 	.word	0x43797475
   17894:	656c6379 	.word	0x656c6379
   17898:	00002928 	.word	0x00002928
   1789c:	5f6d7750 	.word	0x5f6d7750
   178a0:	50746553 	.word	0x50746553
   178a4:	6f697265 	.word	0x6f697265
   178a8:	646e4164 	.word	0x646e4164
   178ac:	79747544 	.word	0x79747544
   178b0:	00002928 	.word	0x00002928
   178b4:	5f6d7750 	.word	0x5f6d7750
   178b8:	4f746553 	.word	0x4f746553
   178bc:	75707475 	.word	0x75707475
   178c0:	496f5474 	.word	0x496f5474
   178c4:	28656c64 	.word	0x28656c64
   178c8:	00000029 	.word	0x00000029
   178cc:	5f6d7750 	.word	0x5f6d7750
   178d0:	56746547 	.word	0x56746547
   178d4:	69737265 	.word	0x69737265
   178d8:	6e496e6f 	.word	0x6e496e6f
   178dc:	29286f66 	.word	0x29286f66
   178e0:	00000000 	.word	0x00000000
   178e4:	61766e49 	.word	0x61766e49
   178e8:	2064696c 	.word	0x2064696c
   178ec:	666e6f63 	.word	0x666e6f63
   178f0:	70206769 	.word	0x70206769
   178f4:	746e696f 	.word	0x746e696f
   178f8:	00007265 	.word	0x00007265
   178fc:	61766e49 	.word	0x61766e49
   17900:	2064696c 	.word	0x2064696c
   17904:	206d7770 	.word	0x206d7770
   17908:	6e616863 	.word	0x6e616863
   1790c:	006c656e 	.word	0x006c656e
   17910:	206d7750 	.word	0x206d7750
   17914:	6e616863 	.word	0x6e616863
   17918:	206c656e 	.word	0x206c656e
   1791c:	69726570 	.word	0x69726570
   17920:	6920646f 	.word	0x6920646f
   17924:	6e752073 	.word	0x6e752073
   17928:	6e616863 	.word	0x6e616863
   1792c:	62616567 	.word	0x62616567
   17930:	0000656c 	.word	0x0000656c
   17934:	5f636441 	.word	0x5f636441
   17938:	74696e49 	.word	0x74696e49
   1793c:	00002928 	.word	0x00002928
   17940:	5f636441 	.word	0x5f636441
   17944:	6e496544 	.word	0x6e496544
   17948:	29287469 	.word	0x29287469
   1794c:	00000000 	.word	0x00000000
   17950:	5f636441 	.word	0x5f636441
   17954:	72617453 	.word	0x72617453
   17958:	6f724774 	.word	0x6f724774
   1795c:	6f437075 	.word	0x6f437075
   17960:	7265766e 	.word	0x7265766e
   17964:	6e6f6973 	.word	0x6e6f6973
   17968:	00002928 	.word	0x00002928
   1796c:	5f636441 	.word	0x5f636441
   17970:	706f7453 	.word	0x706f7453
   17974:	756f7247 	.word	0x756f7247
   17978:	6e6f4370 	.word	0x6e6f4370
   1797c:	73726576 	.word	0x73726576
   17980:	286e6f69 	.word	0x286e6f69
   17984:	00000029 	.word	0x00000029
   17988:	5f636441 	.word	0x5f636441
   1798c:	64616552 	.word	0x64616552
   17990:	756f7247 	.word	0x756f7247
   17994:	00292870 	.word	0x00292870
   17998:	5f636441 	.word	0x5f636441
   1799c:	47746547 	.word	0x47746547
   179a0:	70756f72 	.word	0x70756f72
   179a4:	74617453 	.word	0x74617453
   179a8:	29287375 	.word	0x29287375
   179ac:	00000000 	.word	0x00000000
   179b0:	5f636441 	.word	0x5f636441
   179b4:	696c6143 	.word	0x696c6143
   179b8:	74617262 	.word	0x74617262
   179bc:	00292865 	.word	0x00292865
   179c0:	5f636441 	.word	0x5f636441
   179c4:	75746553 	.word	0x75746553
   179c8:	73655270 	.word	0x73655270
   179cc:	42746c75 	.word	0x42746c75
   179d0:	65666675 	.word	0x65666675
   179d4:	00292872 	.word	0x00292872
   179d8:	5f636441 	.word	0x5f636441
   179dc:	56746547 	.word	0x56746547
   179e0:	69737265 	.word	0x69737265
   179e4:	6e496e6f 	.word	0x6e496e6f
   179e8:	29286f66 	.word	0x29286f66
   179ec:	00000000 	.word	0x00000000
   179f0:	61766e49 	.word	0x61766e49
   179f4:	2064696c 	.word	0x2064696c
   179f8:	20636461 	.word	0x20636461
   179fc:	756f7267 	.word	0x756f7267
   17a00:	00000070 	.word	0x00000070
   17a04:	66667542 	.word	0x66667542
   17a08:	70207265 	.word	0x70207265
   17a0c:	746e696f 	.word	0x746e696f
   17a10:	6e207265 	.word	0x6e207265
   17a14:	6920746f 	.word	0x6920746f
   17a18:	6974696e 	.word	0x6974696e
   17a1c:	7a696c61 	.word	0x7a696c61
   17a20:	00006465 	.word	0x00006465
   17a24:	696c6143 	.word	0x696c6143
   17a28:	74617262 	.word	0x74617262
   17a2c:	206e6f69 	.word	0x206e6f69
   17a30:	7265706f 	.word	0x7265706f
   17a34:	6f697461 	.word	0x6f697461
   17a38:	6974206e 	.word	0x6974206e
   17a3c:	2064656d 	.word	0x2064656d
   17a40:	0074756f 	.word	0x0074756f
   17a44:	65686353 	.word	0x65686353
   17a48:	656c7564 	.word	0x656c7564
   17a4c:	6e495f72 	.word	0x6e495f72
   17a50:	29287469 	.word	0x29287469
   17a54:	00000000 	.word	0x00000000
   17a58:	65686353 	.word	0x65686353
   17a5c:	656c7564 	.word	0x656c7564
   17a60:	65475f72 	.word	0x65475f72
   17a64:	61745374 	.word	0x61745374
   17a68:	51737574 	.word	0x51737574
   17a6c:	65756575 	.word	0x65756575
   17a70:	00002928 	.word	0x00002928
   17a74:	65686353 	.word	0x65686353
   17a78:	656c7564 	.word	0x656c7564
   17a7c:	6c465f72 	.word	0x6c465f72
   17a80:	51687375 	.word	0x51687375
   17a84:	65756575 	.word	0x65756575
   17a88:	00002928 	.word	0x00002928
   17a8c:	65686353 	.word	0x65686353
   17a90:	656c7564 	.word	0x656c7564
   17a94:	72575f72 	.word	0x72575f72
   17a98:	51657469 	.word	0x51657469
   17a9c:	65756575 	.word	0x65756575
   17aa0:	00002928 	.word	0x00002928
   17aa4:	65686353 	.word	0x65686353
   17aa8:	656c7564 	.word	0x656c7564
   17aac:	65525f72 	.word	0x65525f72
   17ab0:	75516461 	.word	0x75516461
   17ab4:	28657565 	.word	0x28657565
   17ab8:	00000029 	.word	0x00000029
   17abc:	65686353 	.word	0x65686353
   17ac0:	656c7564 	.word	0x656c7564
   17ac4:	74535f72 	.word	0x74535f72
   17ac8:	54747261 	.word	0x54747261
   17acc:	286b7361 	.word	0x286b7361
   17ad0:	00000029 	.word	0x00000029
   17ad4:	65686353 	.word	0x65686353
   17ad8:	656c7564 	.word	0x656c7564
   17adc:	74535f72 	.word	0x74535f72
   17ae0:	6154706f 	.word	0x6154706f
   17ae4:	29286b73 	.word	0x29286b73
   17ae8:	00000000 	.word	0x00000000
   17aec:	65686353 	.word	0x65686353
   17af0:	656c7564 	.word	0x656c7564
   17af4:	65505f72 	.word	0x65505f72
   17af8:	646f6972 	.word	0x646f6972
   17afc:	6b736154 	.word	0x6b736154
   17b00:	00002928 	.word	0x00002928
   17b04:	65686353 	.word	0x65686353
   17b08:	656c7564 	.word	0x656c7564
   17b0c:	74535f72 	.word	0x74535f72
   17b10:	54747261 	.word	0x54747261
   17b14:	72656d69 	.word	0x72656d69
   17b18:	00002928 	.word	0x00002928
   17b1c:	65686353 	.word	0x65686353
   17b20:	656c7564 	.word	0x656c7564
   17b24:	74535f72 	.word	0x74535f72
   17b28:	6954706f 	.word	0x6954706f
   17b2c:	2872656d 	.word	0x2872656d
   17b30:	00000029 	.word	0x00000029
   17b34:	65686353 	.word	0x65686353
   17b38:	656c7564 	.word	0x656c7564
   17b3c:	65475f72 	.word	0x65475f72
   17b40:	6d695474 	.word	0x6d695474
   17b44:	29287265 	.word	0x29287265
   17b48:	00000000 	.word	0x00000000
   17b4c:	65686353 	.word	0x65686353
   17b50:	656c7564 	.word	0x656c7564
   17b54:	65525f72 	.word	0x65525f72
   17b58:	64616f6c 	.word	0x64616f6c
   17b5c:	656d6954 	.word	0x656d6954
   17b60:	00292872 	.word	0x00292872
   17b64:	65686353 	.word	0x65686353
   17b68:	656c7564 	.word	0x656c7564
   17b6c:	614d5f72 	.word	0x614d5f72
   17b70:	75466e69 	.word	0x75466e69
   17b74:	6974636e 	.word	0x6974636e
   17b78:	29286e6f 	.word	0x29286e6f
   17b7c:	00000000 	.word	0x00000000
   17b80:	75657551 	.word	0x75657551
   17b84:	64692065 	.word	0x64692065
   17b88:	74756f20 	.word	0x74756f20
   17b8c:	20666f20 	.word	0x20666f20
   17b90:	676e6172 	.word	0x676e6172
   17b94:	00000065 	.word	0x00000065
   17b98:	61766e49 	.word	0x61766e49
   17b9c:	2064696c 	.word	0x2064696c
   17ba0:	75657571 	.word	0x75657571
   17ba4:	74732065 	.word	0x74732065
   17ba8:	73757461 	.word	0x73757461
   17bac:	616c6620 	.word	0x616c6620
   17bb0:	00000067 	.word	0x00000067
   17bb4:	6b736154 	.word	0x6b736154
   17bb8:	20646920 	.word	0x20646920
   17bbc:	2074756f 	.word	0x2074756f
   17bc0:	7220666f 	.word	0x7220666f
   17bc4:	65676e61 	.word	0x65676e61
   17bc8:	00000000 	.word	0x00000000
   17bcc:	61766e49 	.word	0x61766e49
   17bd0:	2064696c 	.word	0x2064696c
   17bd4:	6b736174 	.word	0x6b736174
   17bd8:	20726f20 	.word	0x20726f20
   17bdc:	656d6974 	.word	0x656d6974
   17be0:	65702072 	.word	0x65702072
   17be4:	646f6972 	.word	0x646f6972
   17be8:	74696369 	.word	0x74696369
   17bec:	00000079 	.word	0x00000079
   17bf0:	656d6954 	.word	0x656d6954
   17bf4:	64692072 	.word	0x64692072
   17bf8:	74756f20 	.word	0x74756f20
   17bfc:	20666f20 	.word	0x20666f20
   17c00:	676e6172 	.word	0x676e6172
   17c04:	00000065 	.word	0x00000065
   17c08:	65686353 	.word	0x65686353
   17c0c:	656c7564 	.word	0x656c7564
   17c10:	6e752072 	.word	0x6e752072
   17c14:	74696e69 	.word	0x74696e69
   17c18:	696c6169 	.word	0x696c6169
   17c1c:	0064657a 	.word	0x0064657a
   17c20:	6f497748 	.word	0x6f497748
   17c24:	425f6241 	.word	0x425f6241
   17c28:	6f747475 	.word	0x6f747475
   17c2c:	495f736e 	.word	0x495f736e
   17c30:	2874696e 	.word	0x2874696e
   17c34:	00000029 	.word	0x00000029
   17c38:	6f497748 	.word	0x6f497748
   17c3c:	425f6241 	.word	0x425f6241
   17c40:	6f747475 	.word	0x6f747475
   17c44:	475f736e 	.word	0x475f736e
   17c48:	76457465 	.word	0x76457465
   17c4c:	28746e65 	.word	0x28746e65
   17c50:	00000029 	.word	0x00000029
   17c54:	6f497748 	.word	0x6f497748
   17c58:	425f6241 	.word	0x425f6241
   17c5c:	6f747475 	.word	0x6f747475
   17c60:	4d5f736e 	.word	0x4d5f736e
   17c64:	466e6961 	.word	0x466e6961
   17c68:	74636e75 	.word	0x74636e75
   17c6c:	286e6f69 	.word	0x286e6f69
   17c70:	00000029 	.word	0x00000029
   17c74:	61766e49 	.word	0x61766e49
   17c78:	2064696c 	.word	0x2064696c
   17c7c:	74747562 	.word	0x74747562
   17c80:	69206e6f 	.word	0x69206e6f
   17c84:	00000064 	.word	0x00000064
   17c88:	61766e49 	.word	0x61766e49
   17c8c:	2064696c 	.word	0x2064696c
   17c90:	74747562 	.word	0x74747562
   17c94:	73206e6f 	.word	0x73206e6f
   17c98:	65746174 	.word	0x65746174
   17c9c:	00000000 	.word	0x00000000
   17ca0:	75646f4d 	.word	0x75646f4d
   17ca4:	7520656c 	.word	0x7520656c
   17ca8:	696e696e 	.word	0x696e696e
   17cac:	6c616974 	.word	0x6c616974
   17cb0:	64657a69 	.word	0x64657a69
   17cb4:	00000000 	.word	0x00000000
   17cb8:	6f497748 	.word	0x6f497748
   17cbc:	4c5f6241 	.word	0x4c5f6241
   17cc0:	5f736465 	.word	0x5f736465
   17cc4:	74696e49 	.word	0x74696e49
   17cc8:	00002928 	.word	0x00002928
   17ccc:	6f497748 	.word	0x6f497748
   17cd0:	4c5f6241 	.word	0x4c5f6241
   17cd4:	5f736465 	.word	0x5f736465
   17cd8:	6e727554 	.word	0x6e727554
   17cdc:	29286e4f 	.word	0x29286e4f
   17ce0:	00000000 	.word	0x00000000
   17ce4:	6f497748 	.word	0x6f497748
   17ce8:	4c5f6241 	.word	0x4c5f6241
   17cec:	5f736465 	.word	0x5f736465
   17cf0:	6e727554 	.word	0x6e727554
   17cf4:	2866664f 	.word	0x2866664f
   17cf8:	00000029 	.word	0x00000029
   17cfc:	6f497748 	.word	0x6f497748
   17d00:	4c5f6241 	.word	0x4c5f6241
   17d04:	5f736465 	.word	0x5f736465
   17d08:	6e727554 	.word	0x6e727554
   17d0c:	67676f54 	.word	0x67676f54
   17d10:	2928656c 	.word	0x2928656c
   17d14:	00000000 	.word	0x00000000
   17d18:	61766e49 	.word	0x61766e49
   17d1c:	2064696c 	.word	0x2064696c
   17d20:	2064656c 	.word	0x2064656c
   17d24:	00006469 	.word	0x00006469
   17d28:	6f497748 	.word	0x6f497748
   17d2c:	505f6241 	.word	0x505f6241
   17d30:	5f73746f 	.word	0x5f73746f
   17d34:	74696e49 	.word	0x74696e49
   17d38:	00002928 	.word	0x00002928
   17d3c:	6f497748 	.word	0x6f497748
   17d40:	505f6241 	.word	0x505f6241
   17d44:	5f73746f 	.word	0x5f73746f
   17d48:	56746547 	.word	0x56746547
   17d4c:	65756c61 	.word	0x65756c61
   17d50:	00002928 	.word	0x00002928
   17d54:	6f497748 	.word	0x6f497748
   17d58:	505f6241 	.word	0x505f6241
   17d5c:	5f73746f 	.word	0x5f73746f
   17d60:	41746547 	.word	0x41746547
   17d64:	6156746c 	.word	0x6156746c
   17d68:	2865756c 	.word	0x2865756c
   17d6c:	00000029 	.word	0x00000029
   17d70:	61766e49 	.word	0x61766e49
   17d74:	2064696c 	.word	0x2064696c
   17d78:	75706e69 	.word	0x75706e69
   17d7c:	6f702074 	.word	0x6f702074
   17d80:	65746e69 	.word	0x65746e69
   17d84:	00000072 	.word	0x00000072
   17d88:	6f497748 	.word	0x6f497748
   17d8c:	425f6241 	.word	0x425f6241
   17d90:	657a7a75 	.word	0x657a7a75
   17d94:	6e495f72 	.word	0x6e495f72
   17d98:	29287469 	.word	0x29287469
   17d9c:	00000000 	.word	0x00000000
   17da0:	6f497748 	.word	0x6f497748
   17da4:	425f6241 	.word	0x425f6241
   17da8:	657a7a75 	.word	0x657a7a75
   17dac:	65425f72 	.word	0x65425f72
   17db0:	29287065 	.word	0x29287065
   17db4:	00000000 	.word	0x00000000
   17db8:	6f497748 	.word	0x6f497748
   17dbc:	425f6241 	.word	0x425f6241
   17dc0:	657a7a75 	.word	0x657a7a75
   17dc4:	74535f72 	.word	0x74535f72
   17dc8:	2928706f 	.word	0x2928706f
   17dcc:	00000000 	.word	0x00000000
   17dd0:	61766e49 	.word	0x61766e49
   17dd4:	2064696c 	.word	0x2064696c
   17dd8:	7a7a7562 	.word	0x7a7a7562
   17ddc:	74207265 	.word	0x74207265
   17de0:	00656e6f 	.word	0x00656e6f
   17de4:	2075634d 	.word	0x2075634d
   17de8:	75646f6d 	.word	0x75646f6d
   17dec:	0000656c 	.word	0x0000656c
   17df0:	74616c50 	.word	0x74616c50
   17df4:	6d726f66 	.word	0x6d726f66
   17df8:	646f6d20 	.word	0x646f6d20
   17dfc:	00656c75 	.word	0x00656c75
   17e00:	74726f50 	.word	0x74726f50
   17e04:	646f6d20 	.word	0x646f6d20
   17e08:	00656c75 	.word	0x00656c75
   17e0c:	206f6944 	.word	0x206f6944
   17e10:	75646f6d 	.word	0x75646f6d
   17e14:	0000656c 	.word	0x0000656c
   17e18:	206d7750 	.word	0x206d7750
   17e1c:	75646f6d 	.word	0x75646f6d
   17e20:	0000656c 	.word	0x0000656c
   17e24:	20636441 	.word	0x20636441
   17e28:	75646f6d 	.word	0x75646f6d
   17e2c:	0000656c 	.word	0x0000656c
   17e30:	65686353 	.word	0x65686353
   17e34:	656c7564 	.word	0x656c7564
   17e38:	6f6d2072 	.word	0x6f6d2072
   17e3c:	656c7564 	.word	0x656c7564
   17e40:	00000000 	.word	0x00000000
   17e44:	74747542 	.word	0x74747542
   17e48:	20736e6f 	.word	0x20736e6f
   17e4c:	61204f49 	.word	0x61204f49
   17e50:	72747362 	.word	0x72747362
   17e54:	69746361 	.word	0x69746361
   17e58:	6d206e6f 	.word	0x6d206e6f
   17e5c:	6c75646f 	.word	0x6c75646f
   17e60:	00000065 	.word	0x00000065
   17e64:	7364654c 	.word	0x7364654c
   17e68:	204f4920 	.word	0x204f4920
   17e6c:	74736261 	.word	0x74736261
   17e70:	74636172 	.word	0x74636172
   17e74:	206e6f69 	.word	0x206e6f69
   17e78:	75646f6d 	.word	0x75646f6d
   17e7c:	0000656c 	.word	0x0000656c
   17e80:	73746f50 	.word	0x73746f50
   17e84:	204f4920 	.word	0x204f4920
   17e88:	74736261 	.word	0x74736261
   17e8c:	74636172 	.word	0x74636172
   17e90:	206e6f69 	.word	0x206e6f69
   17e94:	75646f6d 	.word	0x75646f6d
   17e98:	0000656c 	.word	0x0000656c
   17e9c:	7a7a7542 	.word	0x7a7a7542
   17ea0:	49207265 	.word	0x49207265
   17ea4:	6261204f 	.word	0x6261204f
   17ea8:	61727473 	.word	0x61727473
   17eac:	6f697463 	.word	0x6f697463
   17eb0:	6f6d206e 	.word	0x6f6d206e
   17eb4:	656c7564 	.word	0x656c7564
   17eb8:	00000000 	.word	0x00000000
   17ebc:	6f727245 	.word	0x6f727245
   17ec0:	45203a72 	.word	0x45203a72
   17ec4:	726f7272 	.word	0x726f7272
   17ec8:	206e6920 	.word	0x206e6920
   17ecc:	69207325 	.word	0x69207325
   17ed0:	7566206e 	.word	0x7566206e
   17ed4:	6974636e 	.word	0x6974636e
   17ed8:	25206e6f 	.word	0x25206e6f
   17edc:	69772073 	.word	0x69772073
   17ee0:	74206874 	.word	0x74206874
   17ee4:	69206568 	.word	0x69206568
   17ee8:	6174736e 	.word	0x6174736e
   17eec:	2065636e 	.word	0x2065636e
   17ef0:	202c6425 	.word	0x202c6425
   17ef4:	000a7325 	.word	0x000a7325
   17ef8:	6d726554 	.word	0x6d726554
   17efc:	6c616e69 	.word	0x6c616e69
   17f00:	00000000 	.word	0x00000000
   17f04:	4c554e28 	.word	0x4c554e28
   17f08:	0000294c 	.word	0x0000294c

00017f0c <Clock_Ip_au8DividerCallbackIndex>:
   17f0c:	0e0d0c00 06030201 0a070409 000b0805     ................

00017f1c <Clock_Ip_au8DividerTriggerCallbackIndex>:
	...

00017f2c <Clock_Ip_au8XoscCallbackIndex>:
   17f2c:	00000100 00000000 00000000 00000000     ................

00017f3c <Clock_Ip_au8IrcoscCallbackIndex>:
   17f3c:	03020100 00000004 00000000 00000000     ................

00017f4c <Clock_Ip_au8GateCallbackIndex>:
   17f4c:	06010200 01040301 00000500 00000000     ................

00017f5c <Clock_Ip_au8FractionalDividerCallbackIndex>:
	...

00017f6c <Clock_Ip_au8PllCallbackIndex>:
   17f6c:	00000100 00000000 00000000 00000000     ................

00017f7c <Clock_Ip_au8SelectorCallbackIndex>:
   17f7c:	0a090800 03020109 07060504 00000000     ................

00017f8c <Clock_Ip_au8PcfsCallbackIndex>:
	...

00017f9c <Clock_Ip_au8CmuCallbackIndex>:
	...

00017fac <Clock_Ip_au8ClockFeatures>:
	...
   17fbc:	01000000 00000000 00000000 00000002     ................
   17fcc:	00000000 00000300 00000000 00040000     ................
   17fdc:	00000000 05000000 00000000 00000000     ................
   17fec:	00000006 00000000 00000100 00000000     ................
   17ffc:	00010000 00000000 04000000 00000000     ................
   1800c:	00000000 00000005 00000001 00000401     ................
   1801c:	00000200 00050100 00030000 04020000     ................
   1802c:	04000000 02000000 00000005 00000005     ................
   1803c:	00000403 00000600 00050300 00070000     ................
   1804c:	05000000 00000000 00000000 00000006     ................
	...
   1808c:	00050000 00000000 06000000 00000100     ................
   1809c:	00000000 00030007 00000000 00000000     ................
   180ac:	00000000 00060000 00000000 07000000     ................
   180bc:	00000100 00000000 00030008 00000000     ................
	...
   180d4:	00090000 00000000 0a000000 00000100     ................
   180e4:	00000000 0003000b 00000000 00000000     ................
   180f4:	00000000 000c0000 00000000 0d000000     ................
   18104:	00000100 00000000 0003000e 00000000     ................
   18114:	00000800 00000000 00090000 00000000     ................
   18124:	0a000000 00000000 00000000 0000000b     ................
   18134:	00000000 00000b01 00000000 000b0200     ................
   18144:	00000000 0b030000 00000000 00000000     ................
	...
   1815c:	00000400 003b003b 00040000 27002700     ....;.;......'.'
   1816c:	01000000 00000000 00000000 00000007     ................
   1817c:	00007300 00000700 00320000 00090000     .s........2.....
   1818c:	02000000 07000000 00000000 00000021     ............!...
   1819c:	00000009 00000400 00000900 00030000     ................
   181ac:	00070000 61000000 07000000 00000000     .......a........
   181bc:	00000024 00000007 00002500 00000700     $........%......
   181cc:	002b0000 00040000 5a005a00 07000000     ..+......Z.Z....
   181dc:	00000000 00000020 38000004 00003800     .... ......8.8..
   181ec:	00000400 00390039 00040000 3a003a00     ....9.9......:.:
   181fc:	04000000 00260000 00000026 66000004     ......&.&......f
   1820c:	00006600 00000400 00370037 00040000     .f......7.7.....
   1821c:	2c002c00 04000000 002d0000 0000002d     .,.,......-.-...
   1822c:	2e000004 00002e00 00000200 00404040     ............@@@.
   1823c:	00040000 6a006a00 04000000 006b0000     .....j.j......k.
   1824c:	0000006b 6c000004 00006c00 00000900     k......l.l......
   1825c:	00010000 00090000 00000000 07000000     ................
   1826c:	00000000 00000036 00000007 00003100     ....6........1..
   1827c:	00000700 00490000 00070000 4a000000     ......I........J
   1828c:	07000000 00000000 0000004b 00000007     ........K.......
   1829c:	00004c00 00000700 004d0000 00070000     .L........M.....
   182ac:	3d000000 03000000 00000000 00000000     ...=............

000182bc <Clock_Ip_au16SelectorEntryHardwareValue>:
   182bc:	01010a03 01010001 04040002 02000603     ................
   182cc:	00010810 02020100 00000000 00000007     ................
   182dc:	00000009 00000000 00000c0e 00000000     ................
	...

00018314 <Clock_Ip_au8SelectorEntryScsHardwareValue>:
   18314:	00020000 00000300 00000601 00000000     ................
	...

00018344 <Clock_Ip_au8SelectorEntryPcsHardwareValue>:
   18344:	00000700 00000000 02020000 01010303     ................
   18354:	03020606 00000000 00000000 00000000     ................
	...

00018374 <Clock_Ip_au8SelectorEntrySIMHardwareValue>:
   18374:	00000001 00000000 02020000 01010303     ................
   18384:	03020606 00000000 00000000 00000000     ................
	...

000183a4 <Clock_Ip_au8DividerValueHardwareValue>:
   183a4:	00020100 00000003 00000004 00000000     ................
   183b4:	00000005 00000000 00000000 00000000     ................
   183c4:	00000006 00000000 00000000 00000000     ................
	...
   183e4:	00000007                                ....

000183e8 <Clock_Ip_apxScgPeriphAsyncDivs>:
   183e8:	40064204 40064304 40064104 40064604     .B.@.C.@.A.@.F.@

000183f8 <Clock_Ip_aeSourceTypeClockName>:
   183f8:	00000000 00000001 00000001 00000001     ................
   18408:	00000001 00000001 00000001 00000001     ................
   18418:	00000002 00000003 00000001 00000001     ................
   18428:	00000001 00000001 00000002 00000002     ................
   18438:	00000003 00000003 00000001 00000001     ................
   18448:	00000004 00000004 00000004 00000004     ................
	...

000184b4 <Clock_Ip_aeHwPllName>:
   184b4:	00000009                                ....

000184b8 <Clock_Ip_aeHwDfsName>:
   184b8:	00000057                                W...

000184bc <Clock_Ip_axDividerCallbacks>:
   184bc:	00002fed 00002ff7 00003011 0000302b     ./.../...0..+0..
   184cc:	00003045 0000305f 00003079 00003093     E0.._0..y0...0..
   184dc:	000030ad 000030c7 000030e1 000030fb     .0...0...0...0..
   184ec:	00003115 0000312f 00003149              .1../1..I1..

000184f8 <Clock_Ip_axDividerTriggerCallbacks>:
   184f8:	000034bd 000034bd                       .4...4..

00018500 <Clock_Ip_axExtOscCallbacks>:
   18500:	000034c9 000034c9 000034c9 000034d3     .4...4...4...4..
   18510:	000034c9 000034dd 000034f7 00003511     .4...4...4...5..
   18520:	00003595 000035a9                       .5...5..

00018528 <Clock_Ip_axFracDivCallbacks>:
   18528:	00003769 00003769 00003773              i7..i7..s7..

00018534 <Clock_Ip_axGateCallbacks>:
   18534:	0000378d 00003797 00003897 000038b1     .7...7...8...8..
   18544:	00003847 00003861 000037f7 00003811     G8..a8...7...8..
   18554:	000037a7 000037c1 000038e7 00003901     .7...7...8...9..
   18564:	00003937 00003951                       79..Q9..

0001856c <Clock_Ip_axIntOscCallbacks>:
   1856c:	00003afd 00003afd 00003b07 00003b11     .:...:...;...;..
   1857c:	00003b2b 00003b45 00003b59 00003b73     +;..E;..Y;..s;..
   1858c:	00003b8d 00003ba1 00003bbb 00003bd5     .;...;...;...;..
   1859c:	00003c7d 00003c97 00003cb1              }<...<...<..

000185a8 <Clock_Ip_axCmuCallbacks>:
   185a8:	0000424d 00004257 00004263 0000424d     MB..WB..cB..MB..

000185b8 <Clock_Ip_axPllCallbacks>:
   185b8:	0000426d 0000426d 00004277 0000426d     mB..mB..wB..mB..
   185c8:	00004283 0000428d 000042a7 000042c1     .B...B...B...B..
   185d8:	00004365 00004351                       eC..QC..

000185e0 <Clock_Ip_axPcfsCallbacks>:
   185e0:	000044c1                                .D..

000185e4 <Clock_Ip_axSelectorCallbacks>:
   185e4:	000044cd 000044cd 000044d7 000044f1     .D...D...D...D..
   185f4:	000044cd 0000450b 00004525 0000453f     .D...E..%E..?E..
   18604:	00004559 00004573 0000458d 000045a7     YE..sE...E...E..
   18614:	000045c1 000045db 000045f5 0000460f     .E...E...E...F..
   18624:	00004629 00004643 0000465d 00004677     )F..CF..]F..wF..
   18634:	00004691 000046ab                       .F...F..

0001863c <ClockSource>:
   1863c:	00000000 00000008 00000002 00000005     ................
	...
   18654:	00000009                                ....

00018658 <ResetReasonArray>:
   18658:	00000000 00000001 00000002 00000003     ................
   18668:	00000004 00000005 00000006 00000007     ................
   18678:	00000008 00000009 0000000a 0000000b     ................
   18688:	0000000c 0000000d 0000000e              ............

00018694 <Port_au32PortCiPortBaseAddr>:
   18694:	40049000 4004a000 4004b000 4004c000     ...@...@...@...@
   186a4:	4004d000                                ...@

000186a8 <Port_au32PortCiGpioBaseAddr>:
   186a8:	400ff000 400ff040 400ff080 400ff0c0     ...@@..@...@...@
   186b8:	400ff100                                ...@

000186bc <Adc_Ip_apxBase>:
   186bc:	4003b000 40027000                       ...@.p.@

000186c4 <Lpspi_Ip_apxBases>:
   186c4:	4002c000 4002d000 4002e000              ...@...@...@

000186d0 <Can_Ipw_apxStatus>:
   186d0:	1fff8e1c 1fff903c                       ....<...

000186d8 <Flexcan_Ip_apxBase>:
   186d8:	40024000 40025000 4002b000              .@.@.P.@...@

000186e4 <payload_code.3>:
   186e4:	03020100 07060504 09090908 0a0a0a09     ................
   186f4:	0b0b0b0a 0c0c0c0b 0d0d0d0c 0d0d0d0d     ................
   18704:	0e0e0e0d 0e0e0e0e 0e0e0e0e 0e0e0e0e     ................
   18714:	0f0f0f0e 0f0f0f0f 0f0f0f0f 0f0f0f0f     ................
   18724:	0000000f                                ....

00018728 <flexcanBase.2>:
   18728:	40024000 40025000 4002b000              .@.@.P.@...@

00018734 <maxMbNum.1>:
   18734:	00000020 00000010 00000010               ...........

00018740 <flexcanBase.0>:
   18740:	40024000                                .@.@

00018744 <McuApis>:
   18744:	00000000 00017524 00000002 00017530     ....$u......0u..
   18754:	00000008 00017540 00000009 00017550     ....@u......Pu..

00018764 <McuErrors>:
   18764:	00000011 00017568 0000000f 00017580     ....hu.......u..
   18774:	00000013 00017598 0000000b 000175b4     .....u.......u..
   18784:	0000000c 000175b4 00000010 000175b4     .....u.......u..

00018794 <PlatformApis>:
   18794:	00000020 000175cc 00000021 000175dc      ....u..!....u..
   187a4:	00000022 000175f0 00000023 0001760c     "....u..#....v..
   187b4:	00000024 00017628                       $...(v..

000187bc <PlatformErrors>:
   187bc:	00000001 00017648 00000004 00017658     ....Hv......Xv..
   187cc:	00000002 0001767c                       ....|v..

000187d4 <PortApis>:
   187d4:	00000000 00017694 00000001 000176a0     .....v.......v..
   187e4:	00000004 000176b8 00000002 000176cc     .....v.......v..
   187f4:	00000003 000176e8                       .....v..

000187fc <PortErrors>:
   187fc:	0000000a 00017700 0000000e 00017714     .....w.......w..
   1880c:	0000000c 00017568 000000f0 00017568     ....hu......hu..
   1881c:	0000000d 00017734 0000000f 00017580     ....4w.......u..
   1882c:	00000010 000175b4                       .....u..

00018834 <DioApis>:
   18834:	00000001 0001774c 00000000 00017760     ....Lw......`w..
   18844:	00000011 00017774 00000005 00017788     ....tw.......w..
   18854:	00000004 000177a0 00000003 000177b8     .....w.......w..
   18864:	00000002 000177c8 00000012 000177d8     .....w.......w..

00018874 <DioErrors>:
   18874:	00000021 000177f0 00000020 000175b4     !....w.. ....u..
   18884:	0000000a 0001780c 00000014 00017824     .....x......$x..
   18894:	0000001f 00017834 000000f0 00017850     ....4x......Px..

000188a4 <PwmApis>:
   188a4:	00000000 0001786c 00000001 00017878     ....lx......xx..
   188b4:	00000002 00017888 00000003 0001789c     .....x.......x..
   188c4:	00000004 000178b4 00000008 000178cc     .....x.......x..

000188d4 <PwmErrors>:
   188d4:	00000010 000178e4 00000011 00017580     .....x.......u..
   188e4:	00000014 00017598 00000012 000178fc     .....u.......x..
   188f4:	00000013 00017910 00000015 000175b4     .....y.......u..

00018904 <AdcApis>:
   18904:	00000000 00017934 00000001 00017940     ....4y......@y..
   18914:	00000002 00017950 00000003 0001796c     ....Py......ly..
   18924:	00000004 00017988 00000009 00017998     .....y.......y..
   18934:	00000029 000179b0 0000000c 000179c0     )....y.......y..
   18944:	0000000a 000179d8                       .....y..

0001894c <AdcErrors>:
   1894c:	0000000a 00017580 0000000d 00017598     .....u.......u..
   1895c:	00000014 00017648 00000015 000179f0     ....Hv.......y..
   1896c:	00000019 00017a04 0000002b 00017a24     .....z..+...$z..

0001897c <SchedulerApis>:
   1897c:	00000000 00017a44 00000002 00017a58     ....Dz......Xz..
   1898c:	00000003 00017a74 00000004 00017a8c     ....tz.......z..
   1899c:	00000005 00017aa4 00000006 00017abc     .....z.......z..
   189ac:	00000007 00017ad4 00000008 00017aec     .....z.......z..
   189bc:	00000009 00017b04 0000000a 00017b1c     .....{.......{..
   189cc:	0000000b 00017b34 0000000c 00017b4c     ....4{......L{..
   189dc:	0000000d 00017b64                       ....d{..

000189e4 <SchedulerErrors>:
   189e4:	00000000 000178e4 00000001 00017b80     .....x.......{..
   189f4:	00000002 00017b98 00000003 00017bb4     .....{.......{..
   18a04:	00000004 00017bcc 00000005 00017bf0     .....{.......{..
   18a14:	00000006 00017c08                       .....|..

00018a1c <HwIoAb_ButtonsApis>:
   18a1c:	00000000 00017c20 00000001 00017c38     .... |......8|..
   18a2c:	00000002 00017c54                       ....T|..

00018a34 <HwIoAb_ButtonsErrors>:
   18a34:	00000000 000178e4 00000001 00017c74     .....x......t|..
   18a44:	00000002 00017c88 00000003 00017ca0     .....|.......|..

00018a54 <HwIoAb_LedsApis>:
   18a54:	00000000 00017cb8 00000001 00017ccc     .....|.......|..
   18a64:	00000002 00017ce4 00000003 00017cfc     .....|.......|..

00018a74 <HwIoAb_LedsErrors>:
   18a74:	00000000 000178e4 00000001 00017d18     .....x.......}..
   18a84:	00000002 00017ca0                       .....|..

00018a8c <HwIoAb_PotsApis>:
   18a8c:	00000000 00017d28 00000001 00017d3c     ....(}......<}..
   18a9c:	00000002 00017d54                       ....T}..

00018aa4 <HwIoAb_PotsErrors>:
   18aa4:	00000000 00017d70 00000001 00017ca0     ....p}.......|..

00018ab4 <HwIoAb_BuzzerApis>:
   18ab4:	00000000 00017d88 00000001 00017da0     .....}.......}..
   18ac4:	00000002 00017db8                       .....}..

00018acc <HwIoAb_BuzzerErrors>:
   18acc:	00000000 00017dd0                       .....}..

00018ad4 <ModuleStrings>:
   18ad4:	00000065 00017de4 00000004 00018744     e....}......D...
   18ae4:	00000006 00018764 000000ff 00017df0     ....d........}..
   18af4:	00000005 00018794 00000003 000187bc     ................
   18b04:	0000007c 00017e00 00000005 000187d4     |....~..........
   18b14:	00000007 000187fc 00000078 00017e0c     ........x....~..
   18b24:	00000008 00018834 00000006 00018874     ....4.......t...
   18b34:	00000079 00017e18 00000006 000188a4     y....~..........
   18b44:	00000006 000188d4 0000007b 00017e24     ........{...$~..
   18b54:	00000009 00018904 00000006 0001894c     ............L...
   18b64:	0000012c 00017e30 0000000d 0001897c     ,...0~......|...
   18b74:	00000007 000189e4 0000012d 00017e44     ........-...D~..
   18b84:	00000003 00018a1c 00000004 00018a34     ............4...
   18b94:	0000012e 00017e64 00000004 00018a54     ....d~......T...
   18ba4:	00000003 00018a74 0000012f 00017e80     ....t.../....~..
   18bb4:	00000003 00018a8c 00000002 00018aa4     ................
   18bc4:	00000130 00017e9c 00000003 00018ab4     0....~..........
   18bd4:	00000001 00018acc                       ........

00018bdc <Can_43_FLEXCAN_Driver_P2Func>:
   18bdc:	0000a769 0000a3e5 0000a589 0000a529     i...........)...
   18bec:	0000a601 0000a68d 0000a6c1 0000a715     ................

00018bfc <Can_43_FLEXCAN_Driver_Config>:
   18bfc:	00070000 00018bdc                       ........

00018c04 <CanIf_CtrlPCConfig>:
   18c04:	00000000 00018bfc 00000101 00018bfc     ................

00018c14 <CanIf_PCConfig>:
   18c14:	00000002 00018c04                       ........

00018c1c <CanIf_TxPdu>:
   18c1c:	00000000 00000100 00000003 00010005     ................
   18c2c:	000009f5 00000001 00000101 00000003     ................
   18c3c:	00010005 000009f5 00000002 00000102     ................
   18c4c:	00000003 00010005 000009f5 00000003     ................
   18c5c:	00000103 00000003 00010005 000009f5     ................
   18c6c:	00000004 00000300 00000002 00000006     ................
   18c7c:	00000aed                                ....

00018c80 <CanIf_RxPdu>:
   18c80:	00010000 00010003 00000a3d 00010001     ........=.......
   18c90:	00010008 00000a3d 00010002 0001000c     ....=...........
   18ca0:	00000a3d 00010003 00010009 00000a3d     =...........=...
   18cb0:	00010004 00000003 00000b25              ........%...

00018cbc <CanIf_Can_43_FLEXCAN_HohToRxPduMapping>:
   18cbc:	00018c80 00018c8c 00018c98 00018ca4     ................
   18ccc:	00018cb0 00000000 00000000              ............

00018cd8 <CanIf_Can_43_FLEXCAN_DrvConfig>:
   18cd8:	00018cbc                                ....

00018cdc <CanIf_CanDrvConfig>:
   18cdc:	00018cd8                                ....

00018ce0 <CanIf_Config>:
   18ce0:	00000505 00018cdc 00018c80 00018c1c     ................

00018cf0 <Can_43_FLEXCANIpwHwChannelConfig0>:
   18cf0:	00019314                                ....

00018cf4 <Can_43_FLEXCANIpwHwChannelConfig1>:
   18cf4:	00019364                                d...

00018cf8 <Can_au32HwBufferAddr_Ctrl0>:
   18cf8:	4002b080 4002b090                       ...@...@

00018d00 <Can_au32HwBufferAddr_Ctrl1>:
   18d00:	40024080 40024098 400240b0 400240c8     .@.@.@.@.@.@.@.@
   18d10:	400240e0 400240f8 40024110 40024128     .@.@.@.@.A.@(A.@

00018d20 <Can_aHwFilter_Object0>:
   18d20:	00000200 dffc0000                       ........

00018d28 <Can_aHwFilter_Object1>:
   18d28:	00000201 dffc0000                       ........

00018d30 <Can_aHwFilter_Object2>:
   18d30:	00000202 dffc0000                       ........

00018d38 <Can_aHwFilter_Object3>:
   18d38:	00000203 dffc0000                       ........

00018d40 <Can_aHwFilter_Object4>:
   18d40:	00000400 dffc0000                       ........

00018d48 <Can_aCtrlOffsetToCtrlIDMap>:
   18d48:	0000ff01                                ....

00018d4c <Can_aHwObjIDToCtrlIDMap>:
   18d4c:	01010101 00000100                       ........

00018d54 <Can_aHwObjectConfig>:
	...
   18d60:	ff010000 00010008 00018d20 00000000     ........ .......
   18d70:	00000000 00018d00 00000001 00000000     ................
   18d80:	00000000 ff010000 00010008 00018d28     ............(...
   18d90:	00000000 00000001 00018d04 00000002     ................
	...
   18da8:	ff010000 0001000c 00018d30 00000000     ........0.......
   18db8:	00000002 00018d08 00000003 00000000     ................
   18dc8:	00000000 ff010000 0001000c 00018d38     ............8...
   18dd8:	00000000 00000003 00018d0c 00000004     ................
	...
   18df0:	ff010000 00010008 00018d40 00000000     ........@.......
   18e00:	00000000 00018cf8 00000005 00000001     ................
   18e10:	00000000 ff040000 0000000c 00000000     ................
   18e20:	00000003 00000004 00018d10 00000006     ................
   18e30:	00000001 00000000 ff010000 00000008     ................
   18e40:	00000000 00000003 00000001 00018cfc     ................

00018e50 <Can_aBaudrateConfig_Ctrl0>:
   18e50:	06030000 001d0003 00000000 00000000     ................
	...

00018e68 <Can_apHwObject_Ctrl0>:
   18e68:	00018de4 00018e2c                       ....,...

00018e70 <Can_aBaudrateConfig_Ctrl1>:
   18e70:	06030101 00020003 02020000 00020001     ................
	...

00018e88 <Can_apHwObject_Ctrl1>:
   18e88:	00018d54 00018d78 00018d9c 00018dc0     T...x...........
   18e98:	00018e08                                ....

00018e9c <Can_aControllerConfig>:
   18e9c:	00020000 4002b000 00000001 ffffffff     .......@........
	...
   18eb8:	00010000 00018e50 00018cf0 00000002     ....P...........
   18ec8:	00018e68 00000101 40024000 00000001     h........@.@....
   18ed8:	ffffffff 00000000 00000000 00000000     ................
   18ee8:	00010000 00018e70 00018cf4 00000005     ....p...........
   18ef8:	00018e88                                ....

00018efc <Can_apController>:
   18efc:	00018e9c 00018ecc                       ........

00018f04 <Can_43_FLEXCAN_Config>:
   18f04:	00000000 00000005 00018d48 00018d4c     ........H...L...
   18f14:	00018d54 00018efc                       T.......

00018f1c <Mcu_aClockConfigPB>:
	...
   18f24:	14000002 0400000e 01000020 00000002     ........ .......
   18f34:	01000001 00000001 00000005 00000001     ................
   18f44:	00000000 00000057 00000000 00000000     ....W...........
	...
   18f5c:	00000057 00000000 00000057 00000000     W.......W.......
	...
   18f84:	00000019 00000005 0000001a 00000002     ................
   18f94:	0000001b 00000005 0000002a 00000002     ........*.......
   18fa4:	0000003f 0000000a 00000040 0000000a     ?.......@.......
   18fb4:	00000041 00000000 00000042 00000000     A.......B.......
   18fc4:	00000031 0000000b 00000045 00000000     1.......E.......
   18fd4:	00000046 0000000b 00000047 00000000     F.......G.......
   18fe4:	00000044 00000000 00000030 0000000b     D.......0.......
   18ff4:	0000003d 00000000 00000043 00000000     =.......C.......
   19004:	00000049 00000000 0000004a 00000000     I.......J.......
   19014:	0000004b 00000000 00000048 00000000     K.......H.......
   19024:	00000057 00000057 00000057 00000057     W...W...W...W...
   19034:	00000057 00000057 00000057 00000057     W...W...W...W...
   19044:	00000057 00000057 00000057 00000057     W...W...W...W...
   19054:	00000057 00000057 00000057 00000057     W...W...W...W...
   19064:	0000000a 00000001 00000000 0000000b     ................
   19074:	00000001 00000000 0000000c 00000001     ................
   19084:	00000000 0000000d 00000002 00000000     ................
   19094:	0000001d 00000001 00000000 0000001e     ................
   190a4:	00000002 00000000 0000001f 00000001     ................
   190b4:	00000000 00000021 00000001 00000000     ....!...........
   190c4:	00000022 00000002 00000000 00000023     "...........#...
   190d4:	00000001 00000000 00000025 00000002     ........%.......
   190e4:	00000000 00000026 00000004 00000000     ....&...........
   190f4:	00000027 00000002 00000000 00000048     '...........H...
   19104:	00000001 00000001 00000057 00000000     ........W.......
   19114:	00000000 00000057 00000000 00000000     ....W...........
   19124:	00000057 00000000 00000000 00000057     W...........W...
	...
   1913c:	00000057 00000000 00000000 00000057     W...........W...
	...
   19154:	00000057 00000000 00000057 00000057     W.......W...W...
	...
   19170:	00000014 00007d00 00000015 00007d00     .....}.......}..
   19180:	00000016 00007d00 00000017 00008000     .....}..........
   19190:	00000030 00000001 00000031 00000001     0.......1.......
   191a0:	00000033 00000000 00000034 00000000     3.......4.......
   191b0:	00000036 00000000 00000039 00000000     6.......9.......
   191c0:	0000003a 00000001 0000003b 00000000     :.......;.......
   191d0:	0000003c 00000001 0000003d 00000000     <.......=.......
   191e0:	0000003e 00000000 0000003f 00000000     >.......?.......
   191f0:	00000040 00000001 00000041 00000000     @.......A.......
   19200:	00000042 00000000 00000043 00000000     B.......C.......
   19210:	00000044 00000000 00000045 00000000     D.......E.......
   19220:	00000046 00000001 00000047 00000000     F.......G.......
   19230:	00000048 00000000 00000049 00000000     H.......I.......
   19240:	0000004a 00000000 0000004b 00000000     J.......K.......
   19250:	0000004e 00000001 0000004f 00000001     N.......O.......
   19260:	00000050 00000001 00000051 00000001     P.......Q.......
   19270:	00000052 00000001 00000053 00000001     R.......S.......
   19280:	00000054 00000001 00000055 00000000     T.......U.......
   19290:	00000057 00000000 00000057 00000000     W.......W.......
   192a0:	00000057 00000000 00000057 00000000     W.......W.......
   192b0:	00000057 00000000 00000057 00000000     W.......W.......
   192c0:	00000057 00000000 00000057 00000000     W.......W.......
   192d0:	00000057 00000000 00000057 00000000     W.......W.......
   192e0:	00000000 00000057 00000000 00000057     ....W.......W...
	...

00019314 <Flexcan_aCtrlConfigPB>:
   19314:	00000002 00000000 00000000 00000000     ................
   19324:	00000040 00000000 00000100 00000003     @...............
   19334:	00000006 00000003 0000001d 00000000     ................
   19344:	00000004 00000006 00000003 0000001d     ................
	...
   1935c:	0000b969 0000ba15 00000008 00000000     i...............
	...
   19374:	00000060 00000001 01000101 00000003     `...............
   19384:	00000006 00000003 00000002 00000000     ................
   19394:	00000002 00000002 00000001 00000002     ................
	...
   193ac:	0000b969 0000ba15                       i.......

000193b4 <aIrqConfiguration>:
   193b4:	00000027 00000000 0000847d 00000028     '.......}...(...
   193c4:	00000000 0000848d 0000005c 00000f01     ........\.......
   193d4:	0000fe95 0000005d 00000f01 0000fea5     ....]...........
   193e4:	0000005f 00000f01 0000feb5 0000004e     _...........N...
   193f4:	00000f01 0000fe05 0000004f 00000f01     ........O.......
   19404:	0000fe15 00000051 00000f01 0000fe25     ....Q.......%...

00019414 <intCtrlConfig>:
   19414:	00000008 000193b4                       ........

0001941c <Lpspi_Ip_DeviceAttributes_Conf0Spi1Cs3>:
   1941c:	00000001 07070606 43200000 1fff8b28     .......... C(...

0001942c <Lpspi_Ip_PhyUnitConfig_SPI1>:
   1942c:	00000001 00000000 00000001 00000000     ................
   1943c:	00000000                                ....

00019440 <Mcu_Config>:
   19440:	0000005a 00000000 00000001 00000001     Z...............
   19450:	00019adc 00018f1c 00019ae8              ............

0001945c <OsIf_xPredefinedConfig>:
   1945c:	00000000 02dc6c00                       .....l..

00019464 <OsIf_apxPredefinedConfig>:
   19464:	0001945c                                \...

00019468 <Platform_uConfiguration>:
   19468:	00019470                                p...

0001946c <Platform_Config>:
   1946c:	00019468                                h...

00019470 <ipwConfig>:
   19470:	00019414 00000000                       ........

00019478 <Port_au16PinDescription>:
   19478:	0003ffff 0003ffff 0003ffff 0003ffff     ................
   19488:	0001ffff 0003ffff 0003ffff 0003ffff     ................
   19498:	0003ffff 0001ffff 0003ffcf 0003ffff     ................
   194a8:	0003ffff 0003fcff 0001dfef 0003f36f     ............o...
   194b8:	0003fe3f 0003f3ff 00026e3f 0001bebf     ?.......?n......
   194c8:	0002cf9f 0000302f 000030cc 000183ef     ..../0...0......
   194d8:	0001ec7c 00000b1f 00000023 00000010     |.......#.......
   194e8:	0001010c 00000033 000072cf 0000003c     ....3....r..<...
   194f8:	0000cff3 00001b2f 00018c7f 00000433     ..../.......3...
   19508:	00000000 00000030 0000600b 00018c38     ....0....`..8...

00019518 <g_pin_mux_InitConfigArr>:
   19518:	4004b000 400ff080 00000008 00000002     ...@...@........
   19528:	00000001 00000002 00000000 00000000     ................
	...
   19540:	4004b000 400ff080 00000009 00000002     ...@...@........
   19550:	00000001 00000002 00000000 00000000     ................
	...
   19568:	4004b000 400ff080 0000000a 00000002     ...@...@........
   19578:	00000001 00000002 00000000 00000000     ................
	...
   19590:	4004b000 400ff080 0000000b 00000002     ...@...@........
   195a0:	00000001 00000002 00000000 00000000     ................
	...
   195b8:	4004b000 400ff080 0000000d 00000002     ...@...@........
   195c8:	00000001 00000002 00000000 00000000     ................
	...
   195e0:	4004b000 400ff080 0000000e 00000002     ...@...@........
   195f0:	00000001 00000002 00000000 00000000     ................
	...
   19608:	4004b000 00000000 00000010 00000002     ...@............
   19618:	00000003 00000001 00000000 00000000     ................
	...
   19630:	4004b000 00000000 00000011 00000002     ...@............
   19640:	00000003 00000002 00000000 00000000     ................
	...
   19658:	4004d000 400ff100 0000000c 00000002     ...@...@........
   19668:	00000001 00000001 00000000 00000000     ................
	...
   19680:	4004d000 00000000 00000004 00000002     ...@............
   19690:	00000005 00000001 00000000 00000000     ................
	...
   196a8:	4004d000 00000000 00000005 00000002     ...@............
   196b8:	00000005 00000002 00000000 00000000     ................
	...
   196d0:	4004c000 400ff0c0 00000011 00000002     ...@...@........
   196e0:	00000001 00000001 00000000 00000000     ................
	...
   196f8:	40049000 400ff000 0000000c 00000002     ...@...@........
   19708:	00000001 00000001 00000000 00000000     ................
	...
   19720:	40049000 00000000 0000000d 00000002     ...@............
   19730:	00000002 00000002 00000000 00000000     ................
	...
   19748:	4004a000 00000000 00000001 00000002     ...@............
   19758:	00000000 00000001 00000000 00000000     ................
	...
   19770:	4004a000 00000000 0000000d 00000002     ...@............
   19780:	00000000 00000001 00000000 00000000     ................
	...
   19798:	4004a000 00000000 0000000e 00000002     ...@............
   197a8:	00000003 00000002 00000000 00000000     ................
	...
   197c0:	4004a000 00000000 0000000f 00000002     ...@............
   197d0:	00000003 00000001 00000000 00000000     ................
	...
   197e8:	4004a000 00000000 00000010 00000002     ...@............
   197f8:	00000003 00000002 00000000 00000000     ................
	...
   19810:	4004a000 00000000 00000011 00000002     ...@............
   19820:	00000003 00000002 00000000 00000000     ................
	...

00019838 <au8Port_PartitionList>:
   19838:	00000001                                ....

0001983c <au32Port_PinToPartitionMap>:
   1983c:	00000001 00000001 00000001 00000001     ................
   1984c:	00000001 00000001 00000001 00000001     ................
   1985c:	00000001 00000001 00000001 00000001     ................
   1986c:	00000001 00000001 00000001 00000001     ................
   1987c:	00000001 00000001 00000001 00000001     ................

0001988c <Port_au16NoUnUsedPadsArrayDefault>:
   1988c:	00010000 00030002 00070006 00090008     ................
   1989c:	000e000b 0010000f 00200011 00230022     .......... .".#.
   198ac:	00250024 00270026 00290028 002b002a     $.%.&.'.(.).*.+.
   198bc:	0040002c 00420041 00460043 004c0047     ,.@.A.B.C.F.G.L.
   198cc:	0060004f 00620061 00640063 00660065     O.`.a.b.c.d.e.f.
   198dc:	00680067 006a0069 006c006b 006e006d     g.h.i.j.k.l.m.n.
   198ec:	0070006f 00810080 00830082 00870086     o.p.............
   198fc:	00890088 008b008a 008e008d 0090008f     ................

0001990c <Port_UnUsedPin>:
   1990c:	00000000 00000001 00000000              ............

00019918 <Port_aPinConfigDefault>:
   19918:	00000048 00000100 00000000 00000002     H...............
   19928:	00010001 00000049 00000100 00000000     ....I...........
   19938:	00000002 00010101 0000004a 00000100     ........J.......
   19948:	00000000 00000002 00010101 0000008c     ................
   19958:	00000100 00000000 00000001 00010101     ................
   19968:	0000004b 00000100 00000000 00000002     K...............
   19978:	00010101 0000004d 00000100 00000000     ....M...........
   19988:	00000002 00010101 0000004e 00000100     ........N.......
   19998:	00000000 00000002 00010101 00000071     ............q...
   199a8:	00000100 00000000 00000001 00010101     ................
   199b8:	0000000c 00000100 00000000 00000001     ................
   199c8:	00010101 00000021 00000000 00000002     ....!...........
   199d8:	00000000 00010000 0000002d 00000000     ........-.......
   199e8:	00000002 00000000 00010000 0000000d     ................
   199f8:	00000200 00000000 00000002 00010000     ................
   19a08:	00000050 00000300 00000000 00000001     P...............
   19a18:	00010000 00000051 00000300 00000000     ....Q...........
   19a28:	00000002 00010000 0000002e 00000300     ................
   19a38:	00000000 00000002 00010000 0000002f     ............/...
   19a48:	00000300 00000000 00000001 00010000     ................
   19a58:	00000030 00000300 00000000 00000002     0...............
   19a68:	00010000 00000031 00000300 00000000     ....1...........
   19a78:	00000002 00010000 00000084 00000500     ................
   19a88:	00000000 00000001 00010000 00000085     ................
   19a98:	00000500 00000000 00000002 00010000     ................

00019aa8 <Port_Config>:
   19aa8:	00400014 0001988c 0001990c 00019918     ..@.............
	...
   19ac0:	0001983c 00019838 00019518              <...8.......

00019acc <Power_Ip_RCM_ConfigPB>:
	...

00019ad4 <Power_Ip_PMC_ConfigPB>:
   19ad4:	00000000                                ....

00019ad8 <Power_Ip_SMC_ConfigPB>:
   19ad8:	00000000                                ....

00019adc <Power_Ip_aModeConfigPB>:
	...

00019ae8 <Power_Ip_HwIPsConfigPB>:
   19ae8:	00019acc 00019ad4 00019ad8              ............

00019af4 <Spi_ExternalDeviceConfig_Conf0Spi1Cs3>:
   19af4:	00000000 00000001 0001941c 00000000     ................

00019b04 <Spi_aExternalDeviceConfigList>:
   19b04:	00019af4                                ....

00019b08 <Spi_HwUnitConfig_SPI1>:
   19b08:	00000000 00000001 00000000 0001942c     ............,...
   19b18:	00000001                                ....

00019b1c <Spi_aHwUnitConfigList>:
   19b1c:	00019b08                                ....

00019b20 <Spi_ChannelConfig_Spi1Cs3_Control>:
   19b20:	00000001 00000008 00000001 00000004     ................
   19b30:	1fff9904 00000000 1fff8dfc              ............

00019b3c <Spi_ChannelConfig_Spi1Cs3_Data>:
   19b3c:	00000001 00000008 00000001 00000004     ................
   19b4c:	1fff9910 00000000 1fff8e00              ............

00019b58 <Spi_aChannelConfigList>:
   19b58:	00019b20 00019b3c                        ...<...

00019b60 <Spi_Spi1Cs3_W_R_Job_ChannelAssignment>:
   19b60:	00000100                                ....

00019b64 <Spi_JobConfig_Spi1Cs3_W_R_Job>:
   19b64:	00000002 00019b60 00000000 00000000     ....`...........
	...
   19b7c:	1fff8df8 00000000 00019b04              ............

00019b88 <Spi_aJobConfigList>:
   19b88:	00019b64                                d...

00019b8c <Spi_Spi1Cs3_Sequence_W_R_JobAssignment>:
   19b8c:	00000000                                ....

00019b90 <Spi_SequenceConfig_Spi1Cs3_Sequence_W_R>:
   19b90:	00000001 00000000 00019b8c 00000000     ................
   19ba0:	00000000                                ....

00019ba4 <Spi_aSequenceConfigList>:
   19ba4:	00019b90                                ....

00019ba8 <Spi_Config>:
   19ba8:	00010001 00000000 00000000 00019b58     ............X...
   19bb8:	00019b88 00019ba4 00019b04 00019b1c     ................

00019bc8 <_aInitStr.0>:
   19bc8:	00000000 54540000 45522052 53454747     ......TTR REGGES
   19bd8:	00000000                                ....

00019bdc <_aV2C.0>:
   19bdc:	33323130 37363534 42413938 46454443     0123456789ABCDEF

00019bec <__INIT_TABLE>:
   19bec:	00000002 	.word	0x00000002
   19bf0:	1fff8b10 	.word	0x1fff8b10
   19bf4:	00019c14 	.word	0x00019c14
   19bf8:	00019c34 	.word	0x00019c34
   19bfc:	1fff8800 	.word	0x1fff8800
   19c00:	00000000 	.word	0x00000000
   19c04:	00000310 	.word	0x00000310

00019c08 <__ZERO_TABLE>:
   19c08:	00000001 	.word	0x00000001
   19c0c:	1fff8b30 	.word	0x1fff8b30
   19c10:	1fff9de0 	.word	0x1fff9de0
