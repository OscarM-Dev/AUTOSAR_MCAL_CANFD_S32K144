
Build/temp.elf:     file format elf32-littlearm


Disassembly of section .flash_interrupts:

00000000 <VTABLE>:
   0:	20007000 	.word	0x20007000
   4:	00000411 	.word	0x00000411
   8:	000005a3 	.word	0x000005a3
   c:	00000b9f 	.word	0x00000b9f
  10:	00000ba1 	.word	0x00000ba1
  14:	00000ba3 	.word	0x00000ba3
  18:	00000ba5 	.word	0x00000ba5
	...
  2c:	00000ba7 	.word	0x00000ba7
  30:	00000ba9 	.word	0x00000ba9
  34:	00000000 	.word	0x00000000
  38:	00000bab 	.word	0x00000bab
  3c:	00000bad 	.word	0x00000bad
  40:	00000baf 	.word	0x00000baf
  44:	00000baf 	.word	0x00000baf
  48:	00000baf 	.word	0x00000baf
  4c:	00000baf 	.word	0x00000baf
  50:	00000baf 	.word	0x00000baf
  54:	00000baf 	.word	0x00000baf
  58:	00000baf 	.word	0x00000baf
  5c:	00000baf 	.word	0x00000baf
  60:	00000baf 	.word	0x00000baf
  64:	00000baf 	.word	0x00000baf
  68:	00000baf 	.word	0x00000baf
  6c:	00000baf 	.word	0x00000baf
  70:	00000baf 	.word	0x00000baf
  74:	00000baf 	.word	0x00000baf
  78:	00000baf 	.word	0x00000baf
  7c:	00000baf 	.word	0x00000baf
  80:	00000baf 	.word	0x00000baf
  84:	00000baf 	.word	0x00000baf
  88:	00000baf 	.word	0x00000baf
  8c:	00000baf 	.word	0x00000baf
  90:	00000baf 	.word	0x00000baf
  94:	00000baf 	.word	0x00000baf
  98:	00000baf 	.word	0x00000baf
  9c:	00000baf 	.word	0x00000baf
  a0:	00000baf 	.word	0x00000baf
  a4:	00000baf 	.word	0x00000baf
  a8:	00000baf 	.word	0x00000baf
  ac:	00000baf 	.word	0x00000baf
  b0:	00000baf 	.word	0x00000baf
  b4:	00000baf 	.word	0x00000baf
  b8:	00000baf 	.word	0x00000baf
  bc:	00000baf 	.word	0x00000baf
  c0:	00000baf 	.word	0x00000baf
  c4:	00000baf 	.word	0x00000baf
  c8:	00000baf 	.word	0x00000baf
  cc:	00000baf 	.word	0x00000baf
  d0:	00000baf 	.word	0x00000baf
  d4:	00000baf 	.word	0x00000baf
  d8:	00000baf 	.word	0x00000baf
  dc:	00000baf 	.word	0x00000baf
  e0:	00000baf 	.word	0x00000baf
  e4:	00000baf 	.word	0x00000baf
  e8:	00000baf 	.word	0x00000baf
  ec:	00000baf 	.word	0x00000baf
  f0:	00000baf 	.word	0x00000baf
  f4:	00000baf 	.word	0x00000baf
  f8:	00000baf 	.word	0x00000baf
  fc:	00000baf 	.word	0x00000baf
 100:	00000baf 	.word	0x00000baf
 104:	00000baf 	.word	0x00000baf
 108:	00000baf 	.word	0x00000baf
 10c:	00000baf 	.word	0x00000baf
 110:	00000baf 	.word	0x00000baf
 114:	00000baf 	.word	0x00000baf
 118:	00000baf 	.word	0x00000baf
 11c:	00000baf 	.word	0x00000baf
 120:	00000baf 	.word	0x00000baf
 124:	00000baf 	.word	0x00000baf
 128:	00000baf 	.word	0x00000baf
 12c:	00000baf 	.word	0x00000baf
 130:	00000baf 	.word	0x00000baf
 134:	00000baf 	.word	0x00000baf
 138:	00000baf 	.word	0x00000baf
 13c:	00000baf 	.word	0x00000baf
 140:	00000baf 	.word	0x00000baf
 144:	00000baf 	.word	0x00000baf
 148:	00000baf 	.word	0x00000baf
 14c:	00000baf 	.word	0x00000baf
 150:	00000baf 	.word	0x00000baf
 154:	00000baf 	.word	0x00000baf
 158:	00000baf 	.word	0x00000baf
 15c:	00000baf 	.word	0x00000baf
 160:	00000baf 	.word	0x00000baf
 164:	00000baf 	.word	0x00000baf
 168:	00000baf 	.word	0x00000baf
 16c:	00000baf 	.word	0x00000baf
 170:	00000baf 	.word	0x00000baf
 174:	00000baf 	.word	0x00000baf
 178:	00000baf 	.word	0x00000baf
 17c:	00000baf 	.word	0x00000baf
 180:	00000baf 	.word	0x00000baf
 184:	00000baf 	.word	0x00000baf
 188:	00000baf 	.word	0x00000baf
 18c:	00000baf 	.word	0x00000baf
 190:	00000baf 	.word	0x00000baf
 194:	00000baf 	.word	0x00000baf
 198:	00000baf 	.word	0x00000baf
 19c:	00000baf 	.word	0x00000baf
 1a0:	00000baf 	.word	0x00000baf
 1a4:	00000baf 	.word	0x00000baf
 1a8:	00000baf 	.word	0x00000baf
 1ac:	00000baf 	.word	0x00000baf
 1b0:	00000baf 	.word	0x00000baf
 1b4:	00000baf 	.word	0x00000baf
 1b8:	00000baf 	.word	0x00000baf
 1bc:	00000baf 	.word	0x00000baf
 1c0:	00000baf 	.word	0x00000baf
 1c4:	00000baf 	.word	0x00000baf
 1c8:	00000baf 	.word	0x00000baf
 1cc:	00000baf 	.word	0x00000baf
 1d0:	00000baf 	.word	0x00000baf
 1d4:	00000baf 	.word	0x00000baf
 1d8:	00000baf 	.word	0x00000baf
 1dc:	00000baf 	.word	0x00000baf
 1e0:	00000baf 	.word	0x00000baf
 1e4:	00000baf 	.word	0x00000baf
 1e8:	00000baf 	.word	0x00000baf
 1ec:	00000baf 	.word	0x00000baf
 1f0:	00000baf 	.word	0x00000baf
 1f4:	00000baf 	.word	0x00000baf
 1f8:	00000baf 	.word	0x00000baf
 1fc:	00000baf 	.word	0x00000baf
 200:	00000baf 	.word	0x00000baf
 204:	00000baf 	.word	0x00000baf
 208:	00000baf 	.word	0x00000baf
 20c:	00000baf 	.word	0x00000baf
 210:	00000baf 	.word	0x00000baf
 214:	00000baf 	.word	0x00000baf
 218:	00000baf 	.word	0x00000baf
 21c:	00000baf 	.word	0x00000baf
 220:	00000baf 	.word	0x00000baf
 224:	00000baf 	.word	0x00000baf
 228:	00000baf 	.word	0x00000baf
 22c:	00000baf 	.word	0x00000baf
 230:	00000baf 	.word	0x00000baf
 234:	00000baf 	.word	0x00000baf
 238:	00000baf 	.word	0x00000baf
 23c:	00000baf 	.word	0x00000baf
 240:	00000baf 	.word	0x00000baf
 244:	00000baf 	.word	0x00000baf
 248:	00000baf 	.word	0x00000baf
 24c:	00000baf 	.word	0x00000baf
 250:	00000baf 	.word	0x00000baf
 254:	00000baf 	.word	0x00000baf
 258:	00000baf 	.word	0x00000baf
 25c:	00000baf 	.word	0x00000baf
 260:	00000baf 	.word	0x00000baf
 264:	00000baf 	.word	0x00000baf
 268:	00000baf 	.word	0x00000baf
 26c:	00000baf 	.word	0x00000baf
 270:	00000baf 	.word	0x00000baf
 274:	00000baf 	.word	0x00000baf
 278:	00000baf 	.word	0x00000baf
 27c:	00000baf 	.word	0x00000baf
 280:	00000baf 	.word	0x00000baf
 284:	00000baf 	.word	0x00000baf
 288:	00000baf 	.word	0x00000baf
 28c:	00000baf 	.word	0x00000baf
 290:	00000baf 	.word	0x00000baf
 294:	00000baf 	.word	0x00000baf
 298:	00000baf 	.word	0x00000baf
 29c:	00000baf 	.word	0x00000baf
 2a0:	00000baf 	.word	0x00000baf
 2a4:	00000baf 	.word	0x00000baf
 2a8:	00000baf 	.word	0x00000baf
 2ac:	00000baf 	.word	0x00000baf
 2b0:	00000baf 	.word	0x00000baf
 2b4:	00000baf 	.word	0x00000baf
 2b8:	00000baf 	.word	0x00000baf
 2bc:	00000baf 	.word	0x00000baf
 2c0:	00000baf 	.word	0x00000baf
 2c4:	00000baf 	.word	0x00000baf
 2c8:	00000baf 	.word	0x00000baf
 2cc:	00000baf 	.word	0x00000baf
 2d0:	00000baf 	.word	0x00000baf
 2d4:	00000baf 	.word	0x00000baf
 2d8:	00000baf 	.word	0x00000baf
 2dc:	00000baf 	.word	0x00000baf
 2e0:	00000baf 	.word	0x00000baf
 2e4:	00000baf 	.word	0x00000baf
 2e8:	00000baf 	.word	0x00000baf
 2ec:	00000baf 	.word	0x00000baf
 2f0:	00000baf 	.word	0x00000baf
 2f4:	00000baf 	.word	0x00000baf
 2f8:	00000baf 	.word	0x00000baf
 2fc:	00000baf 	.word	0x00000baf
 300:	00000baf 	.word	0x00000baf
 304:	00000baf 	.word	0x00000baf
 308:	00000baf 	.word	0x00000baf
 30c:	00000baf 	.word	0x00000baf

Disassembly of section .flash:

00000410 <_start>:
     410:	b672      	cpsid	i
     412:	f04f 0000 	mov.w	r0, #0
     416:	f04f 0100 	mov.w	r1, #0
     41a:	f04f 0200 	mov.w	r2, #0
     41e:	f04f 0300 	mov.w	r3, #0
     422:	f04f 0400 	mov.w	r4, #0
     426:	f04f 0500 	mov.w	r5, #0
     42a:	f04f 0600 	mov.w	r6, #0
     42e:	f04f 0700 	mov.w	r7, #0
     432:	481b      	ldr	r0, [pc, #108]	; (4a0 <_end_of_eunit_test+0xa>)
     434:	f44f 1140 	mov.w	r1, #3145728	; 0x300000
     438:	6001      	str	r1, [r0, #0]

0000043a <SetVTOR>:
     43a:	481a      	ldr	r0, [pc, #104]	; (4a4 <_end_of_eunit_test+0xe>)
     43c:	491a      	ldr	r1, [pc, #104]	; (4a8 <_end_of_eunit_test+0x12>)
     43e:	6001      	str	r1, [r0, #0]

00000440 <SetCore0Stack>:
     440:	481a      	ldr	r0, [pc, #104]	; (4ac <_end_of_eunit_test+0x16>)
     442:	f380 8808 	msr	MSP, r0
     446:	e7ff      	b.n	448 <DisableSWT0>

00000448 <DisableSWT0>:
     448:	4819      	ldr	r0, [pc, #100]	; (4b0 <_end_of_eunit_test+0x1a>)
     44a:	f242 5120 	movw	r1, #9504	; 0x2520
     44e:	6001      	str	r1, [r0, #0]
     450:	4818      	ldr	r0, [pc, #96]	; (4b4 <_end_of_eunit_test+0x1e>)
     452:	f64f 71ff 	movw	r1, #65535	; 0xffff
     456:	6001      	str	r1, [r0, #0]
     458:	e7ff      	b.n	45a <RamInit>

0000045a <RamInit>:
     45a:	4817      	ldr	r0, [pc, #92]	; (4b8 <_end_of_eunit_test+0x22>)
     45c:	2800      	cmp	r0, #0
     45e:	d009      	beq.n	474 <DebuggerHeldCoreLoop>
     460:	4916      	ldr	r1, [pc, #88]	; (4bc <_end_of_eunit_test+0x26>)
     462:	4a17      	ldr	r2, [pc, #92]	; (4c0 <_end_of_eunit_test+0x2a>)
     464:	1a52      	subs	r2, r2, r1
     466:	3a01      	subs	r2, #1
     468:	dd04      	ble.n	474 <DebuggerHeldCoreLoop>
     46a:	2000      	movs	r0, #0
     46c:	2300      	movs	r3, #0

0000046e <SRAM_LOOP>:
     46e:	c109      	stmia	r1!, {r0, r3}
     470:	3a08      	subs	r2, #8
     472:	dafc      	bge.n	46e <SRAM_LOOP>

00000474 <DebuggerHeldCoreLoop>:
     474:	4813      	ldr	r0, [pc, #76]	; (4c4 <_end_of_eunit_test+0x2e>)
     476:	6800      	ldr	r0, [r0, #0]
     478:	f04f 315a 	mov.w	r1, #1515870810	; 0x5a5a5a5a
     47c:	4288      	cmp	r0, r1
     47e:	d0f9      	beq.n	474 <DebuggerHeldCoreLoop>

00000480 <_DATA_INIT>:
     480:	e7ff      	b.n	482 <_INIT_DATA_BSS>

00000482 <_INIT_DATA_BSS>:
     482:	f000 fac3 	bl	a0c <init_data_bss>

00000486 <__SYSTEM_INIT>:
     486:	f000 f81f 	bl	4c8 <SystemInit>

0000048a <_MAIN>:
     48a:	b662      	cpsie	i
     48c:	f000 fb82 	bl	b94 <startup_go_to_user_mode>
     490:	f000 fa0e 	bl	8b0 <main>

00000494 <MCAL_LTB_TRACE_OFF>:
     494:	bf00      	nop

00000496 <_end_of_eunit_test>:
     496:	e7fe      	b.n	496 <_end_of_eunit_test>
     498:	f3af 8000 	nop.w
     49c:	f3af 8000 	nop.w
     4a0:	40048004 	.word	0x40048004
     4a4:	e000ed08 	.word	0xe000ed08
     4a8:	1fff8800 	.word	0x1fff8800
     4ac:	20007000 	.word	0x20007000
     4b0:	40052000 	.word	0x40052000
     4b4:	40052008 	.word	0x40052008
     4b8:	00000001 	.word	0x00000001
     4bc:	1fff8000 	.word	0x1fff8000
     4c0:	20007000 	.word	0x20007000
     4c4:	1fff9548 	.word	0x1fff9548

000004c8 <SystemInit>:
#else
    __attribute__ ((section (".systeminit")))
#endif 

void SystemInit(void)
{
     4c8:	b508      	push	{r3, lr}
/**************************************************************************/
                      /* FPU ENABLE*/
/**************************************************************************/
#ifdef ENABLE_FPU
    /* Enable CP10 and CP11 coprocessors */
    S32_SCB->CPACR |= (S32_SCB_CPACR_CPx(10U, 3U) | S32_SCB_CPACR_CPx(11U, 3U)); 
     4ca:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     4ce:	f8d3 3d88 	ldr.w	r3, [r3, #3464]	; 0xd88
     4d2:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
     4d6:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
     4da:	f8c2 3d88 	str.w	r3, [r2, #3464]	; 0xd88

    ASM_KEYWORD("dsb");
     4de:	f3bf 8f4f 	dsb	sy
    ASM_KEYWORD("isb");
     4e2:	f3bf 8f6f 	isb	sy
#endif /* ENABLE_FPU */

#ifdef ENABLE_THREAD_MODE_ENTRY_CONFIGURATION
    S32_SCB->CCR    |=  1u;       /**< processor can enter Thread mode from any level under the 
     4e6:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     4ea:	f8d3 3d14 	ldr.w	r3, [r3, #3348]	; 0xd14
     4ee:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
     4f2:	f043 0301 	orr.w	r3, r3, #1
     4f6:	f8c2 3d14 	str.w	r3, [r2, #3348]	; 0xd14
                                   control of an EXC_RETURN value, PendSV priority set to 0*/
#endif
    S32_SCB->SHPR3 &= ~S32_SCB_SHPR3_PRI_14_MASK; 
     4fa:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
     4fe:	f8d3 3d20 	ldr.w	r3, [r3, #3360]	; 0xd20
     502:	f04f 22e0 	mov.w	r2, #3758153728	; 0xe000e000
     506:	f423 037f 	bic.w	r3, r3, #16711680	; 0xff0000
     50a:	f8c2 3d20 	str.w	r3, [r2, #3360]	; 0xd20
    
    /* enable the AIPS */
    IP_AIPS->MPRA = 0x77777777;      
     50e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     512:	f04f 3277 	mov.w	r2, #2004318071	; 0x77777777
     516:	601a      	str	r2, [r3, #0]
    IP_AIPS->PACRA  = 0x0; 
     518:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     51c:	2200      	movs	r2, #0
     51e:	621a      	str	r2, [r3, #32]
    IP_AIPS->PACRB  = 0x0; 
     520:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     524:	2200      	movs	r2, #0
     526:	625a      	str	r2, [r3, #36]	; 0x24
    IP_AIPS->PACRD  = 0x0;
     528:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     52c:	2200      	movs	r2, #0
     52e:	62da      	str	r2, [r3, #44]	; 0x2c
    IP_AIPS->OPACR[0] = 0x0; 
     530:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     534:	2200      	movs	r2, #0
     536:	641a      	str	r2, [r3, #64]	; 0x40
    IP_AIPS->OPACR[1] = 0x0; 
     538:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     53c:	2200      	movs	r2, #0
     53e:	645a      	str	r2, [r3, #68]	; 0x44
    IP_AIPS->OPACR[2] = 0x0; 
     540:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     544:	2200      	movs	r2, #0
     546:	649a      	str	r2, [r3, #72]	; 0x48
    IP_AIPS->OPACR[3] = 0x0; 
     548:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     54c:	2200      	movs	r2, #0
     54e:	64da      	str	r2, [r3, #76]	; 0x4c
    IP_AIPS->OPACR[4] = 0x0; 
     550:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     554:	2200      	movs	r2, #0
     556:	651a      	str	r2, [r3, #80]	; 0x50
    IP_AIPS->OPACR[5] = 0x0; 
     558:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     55c:	2200      	movs	r2, #0
     55e:	655a      	str	r2, [r3, #84]	; 0x54
    IP_AIPS->OPACR[6] = 0x0; 
     560:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     564:	2200      	movs	r2, #0
     566:	659a      	str	r2, [r3, #88]	; 0x58
    IP_AIPS->OPACR[7] = 0x0; 
     568:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     56c:	2200      	movs	r2, #0
     56e:	65da      	str	r2, [r3, #92]	; 0x5c
    IP_AIPS->OPACR[8] = 0x0; 
     570:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     574:	2200      	movs	r2, #0
     576:	661a      	str	r2, [r3, #96]	; 0x60
    IP_AIPS->OPACR[9] = 0x0; 
     578:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     57c:	2200      	movs	r2, #0
     57e:	665a      	str	r2, [r3, #100]	; 0x64
    IP_AIPS->OPACR[10] = 0x0;
     580:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     584:	2200      	movs	r2, #0
     586:	669a      	str	r2, [r3, #104]	; 0x68
    IP_AIPS->OPACR[11] = 0x0;
     588:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
     58c:	2200      	movs	r2, #0
     58e:	66da      	str	r2, [r3, #108]	; 0x6c

/**************************************************************************/
                      /* DEFAULT MEMORY ENABLE*/
/**************************************************************************/
    ASM_KEYWORD("dsb");
     590:	f3bf 8f4f 	dsb	sy
    ASM_KEYWORD("isb");
     594:	f3bf 8f6f 	isb	sy

#ifdef I_CACHE_ENABLE  
/**************************************************************************/
            /* ENABLE CACHE */
/**************************************************************************/
    (void)sys_m4_cache_init(CODE_CACHE);    
     598:	2000      	movs	r0, #0
     59a:	f000 facd 	bl	b38 <sys_m4_cache_init>
#endif
}
     59e:	bf00      	nop
     5a0:	bd08      	pop	{r3, pc}

000005a2 <NMI_Handler>:
#endif


void NMI_Handler(void)
{
    while(TRUE){};
     5a2:	e7fe      	b.n	5a2 <NMI_Handler>

000005a4 <__aeabi_uldivmod>:
     5a4:	b953      	cbnz	r3, 5bc <__aeabi_uldivmod+0x18>
     5a6:	b94a      	cbnz	r2, 5bc <__aeabi_uldivmod+0x18>
     5a8:	2900      	cmp	r1, #0
     5aa:	bf08      	it	eq
     5ac:	2800      	cmpeq	r0, #0
     5ae:	bf1c      	itt	ne
     5b0:	f04f 31ff 	movne.w	r1, #4294967295
     5b4:	f04f 30ff 	movne.w	r0, #4294967295
     5b8:	f000 b978 	b.w	8ac <__aeabi_idiv0>
     5bc:	f1ad 0c08 	sub.w	ip, sp, #8
     5c0:	e96d ce04 	strd	ip, lr, [sp, #-16]!
     5c4:	f000 f806 	bl	5d4 <__udivmoddi4>
     5c8:	f8dd e004 	ldr.w	lr, [sp, #4]
     5cc:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
     5d0:	b004      	add	sp, #16
     5d2:	4770      	bx	lr

000005d4 <__udivmoddi4>:
     5d4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
     5d8:	9d08      	ldr	r5, [sp, #32]
     5da:	460e      	mov	r6, r1
     5dc:	4604      	mov	r4, r0
     5de:	468e      	mov	lr, r1
     5e0:	2b00      	cmp	r3, #0
     5e2:	d14c      	bne.n	67e <__udivmoddi4+0xaa>
     5e4:	428a      	cmp	r2, r1
     5e6:	4694      	mov	ip, r2
     5e8:	d967      	bls.n	6ba <__udivmoddi4+0xe6>
     5ea:	fab2 f282 	clz	r2, r2
     5ee:	b152      	cbz	r2, 606 <__udivmoddi4+0x32>
     5f0:	fa01 f302 	lsl.w	r3, r1, r2
     5f4:	f1c2 0120 	rsb	r1, r2, #32
     5f8:	fa20 f101 	lsr.w	r1, r0, r1
     5fc:	fa0c fc02 	lsl.w	ip, ip, r2
     600:	ea41 0e03 	orr.w	lr, r1, r3
     604:	4094      	lsls	r4, r2
     606:	ea4f 481c 	mov.w	r8, ip, lsr #16
     60a:	0c21      	lsrs	r1, r4, #16
     60c:	fbbe f6f8 	udiv	r6, lr, r8
     610:	fa1f f78c 	uxth.w	r7, ip
     614:	fb08 e316 	mls	r3, r8, r6, lr
     618:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
     61c:	fb06 f107 	mul.w	r1, r6, r7
     620:	4299      	cmp	r1, r3
     622:	d90a      	bls.n	63a <__udivmoddi4+0x66>
     624:	eb1c 0303 	adds.w	r3, ip, r3
     628:	f106 30ff 	add.w	r0, r6, #4294967295
     62c:	f080 811e 	bcs.w	86c <__udivmoddi4+0x298>
     630:	4299      	cmp	r1, r3
     632:	f240 811b 	bls.w	86c <__udivmoddi4+0x298>
     636:	3e02      	subs	r6, #2
     638:	4463      	add	r3, ip
     63a:	1a5b      	subs	r3, r3, r1
     63c:	b2a4      	uxth	r4, r4
     63e:	fbb3 f0f8 	udiv	r0, r3, r8
     642:	fb08 3310 	mls	r3, r8, r0, r3
     646:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
     64a:	fb00 f707 	mul.w	r7, r0, r7
     64e:	42a7      	cmp	r7, r4
     650:	d90a      	bls.n	668 <__udivmoddi4+0x94>
     652:	eb1c 0404 	adds.w	r4, ip, r4
     656:	f100 33ff 	add.w	r3, r0, #4294967295
     65a:	f080 8109 	bcs.w	870 <__udivmoddi4+0x29c>
     65e:	42a7      	cmp	r7, r4
     660:	f240 8106 	bls.w	870 <__udivmoddi4+0x29c>
     664:	4464      	add	r4, ip
     666:	3802      	subs	r0, #2
     668:	1be4      	subs	r4, r4, r7
     66a:	ea40 4006 	orr.w	r0, r0, r6, lsl #16
     66e:	2100      	movs	r1, #0
     670:	b11d      	cbz	r5, 67a <__udivmoddi4+0xa6>
     672:	40d4      	lsrs	r4, r2
     674:	2300      	movs	r3, #0
     676:	e9c5 4300 	strd	r4, r3, [r5]
     67a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     67e:	428b      	cmp	r3, r1
     680:	d908      	bls.n	694 <__udivmoddi4+0xc0>
     682:	2d00      	cmp	r5, #0
     684:	f000 80ef 	beq.w	866 <__udivmoddi4+0x292>
     688:	2100      	movs	r1, #0
     68a:	e9c5 0600 	strd	r0, r6, [r5]
     68e:	4608      	mov	r0, r1
     690:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
     694:	fab3 f183 	clz	r1, r3
     698:	2900      	cmp	r1, #0
     69a:	d149      	bne.n	730 <__udivmoddi4+0x15c>
     69c:	42b3      	cmp	r3, r6
     69e:	d302      	bcc.n	6a6 <__udivmoddi4+0xd2>
     6a0:	4282      	cmp	r2, r0
     6a2:	f200 80ff 	bhi.w	8a4 <__udivmoddi4+0x2d0>
     6a6:	1a84      	subs	r4, r0, r2
     6a8:	eb66 0303 	sbc.w	r3, r6, r3
     6ac:	2001      	movs	r0, #1
     6ae:	469e      	mov	lr, r3
     6b0:	2d00      	cmp	r5, #0
     6b2:	d0e2      	beq.n	67a <__udivmoddi4+0xa6>
     6b4:	e9c5 4e00 	strd	r4, lr, [r5]
     6b8:	e7df      	b.n	67a <__udivmoddi4+0xa6>
     6ba:	b902      	cbnz	r2, 6be <__udivmoddi4+0xea>
     6bc:	deff      	udf	#255	; 0xff
     6be:	fab2 f282 	clz	r2, r2
     6c2:	2a00      	cmp	r2, #0
     6c4:	f040 808e 	bne.w	7e4 <__udivmoddi4+0x210>
     6c8:	eba1 060c 	sub.w	r6, r1, ip
     6cc:	ea4f 471c 	mov.w	r7, ip, lsr #16
     6d0:	fa1f f38c 	uxth.w	r3, ip
     6d4:	2101      	movs	r1, #1
     6d6:	fbb6 fef7 	udiv	lr, r6, r7
     6da:	fb07 601e 	mls	r0, r7, lr, r6
     6de:	0c26      	lsrs	r6, r4, #16
     6e0:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
     6e4:	fb03 f00e 	mul.w	r0, r3, lr
     6e8:	42b0      	cmp	r0, r6
     6ea:	d908      	bls.n	6fe <__udivmoddi4+0x12a>
     6ec:	eb1c 0606 	adds.w	r6, ip, r6
     6f0:	f10e 38ff 	add.w	r8, lr, #4294967295
     6f4:	d202      	bcs.n	6fc <__udivmoddi4+0x128>
     6f6:	42b0      	cmp	r0, r6
     6f8:	f200 80d0 	bhi.w	89c <__udivmoddi4+0x2c8>
     6fc:	46c6      	mov	lr, r8
     6fe:	1a36      	subs	r6, r6, r0
     700:	b2a4      	uxth	r4, r4
     702:	fbb6 f0f7 	udiv	r0, r6, r7
     706:	fb07 6610 	mls	r6, r7, r0, r6
     70a:	ea44 4406 	orr.w	r4, r4, r6, lsl #16
     70e:	fb00 f303 	mul.w	r3, r0, r3
     712:	42a3      	cmp	r3, r4
     714:	d908      	bls.n	728 <__udivmoddi4+0x154>
     716:	eb1c 0404 	adds.w	r4, ip, r4
     71a:	f100 36ff 	add.w	r6, r0, #4294967295
     71e:	d202      	bcs.n	726 <__udivmoddi4+0x152>
     720:	42a3      	cmp	r3, r4
     722:	f200 80b8 	bhi.w	896 <__udivmoddi4+0x2c2>
     726:	4630      	mov	r0, r6
     728:	1ae4      	subs	r4, r4, r3
     72a:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     72e:	e79f      	b.n	670 <__udivmoddi4+0x9c>
     730:	f1c1 0720 	rsb	r7, r1, #32
     734:	fa22 f407 	lsr.w	r4, r2, r7
     738:	408b      	lsls	r3, r1
     73a:	4323      	orrs	r3, r4
     73c:	fa06 fc01 	lsl.w	ip, r6, r1
     740:	fa26 f407 	lsr.w	r4, r6, r7
     744:	fa20 f607 	lsr.w	r6, r0, r7
     748:	ea46 060c 	orr.w	r6, r6, ip
     74c:	ea4f 4913 	mov.w	r9, r3, lsr #16
     750:	fa00 f801 	lsl.w	r8, r0, r1
     754:	fbb4 fef9 	udiv	lr, r4, r9
     758:	0c30      	lsrs	r0, r6, #16
     75a:	fa1f fc83 	uxth.w	ip, r3
     75e:	fb09 441e 	mls	r4, r9, lr, r4
     762:	ea40 4404 	orr.w	r4, r0, r4, lsl #16
     766:	fb0e f00c 	mul.w	r0, lr, ip
     76a:	42a0      	cmp	r0, r4
     76c:	fa02 f201 	lsl.w	r2, r2, r1
     770:	d90a      	bls.n	788 <__udivmoddi4+0x1b4>
     772:	191c      	adds	r4, r3, r4
     774:	f10e 3aff 	add.w	sl, lr, #4294967295
     778:	f080 808b 	bcs.w	892 <__udivmoddi4+0x2be>
     77c:	42a0      	cmp	r0, r4
     77e:	f240 8088 	bls.w	892 <__udivmoddi4+0x2be>
     782:	f1ae 0e02 	sub.w	lr, lr, #2
     786:	441c      	add	r4, r3
     788:	1a24      	subs	r4, r4, r0
     78a:	b2b6      	uxth	r6, r6
     78c:	fbb4 f0f9 	udiv	r0, r4, r9
     790:	fb09 4410 	mls	r4, r9, r0, r4
     794:	ea46 4404 	orr.w	r4, r6, r4, lsl #16
     798:	fb00 fc0c 	mul.w	ip, r0, ip
     79c:	45a4      	cmp	ip, r4
     79e:	d907      	bls.n	7b0 <__udivmoddi4+0x1dc>
     7a0:	191c      	adds	r4, r3, r4
     7a2:	f100 36ff 	add.w	r6, r0, #4294967295
     7a6:	d270      	bcs.n	88a <__udivmoddi4+0x2b6>
     7a8:	45a4      	cmp	ip, r4
     7aa:	d96e      	bls.n	88a <__udivmoddi4+0x2b6>
     7ac:	3802      	subs	r0, #2
     7ae:	441c      	add	r4, r3
     7b0:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     7b4:	fba0 e602 	umull	lr, r6, r0, r2
     7b8:	eba4 040c 	sub.w	r4, r4, ip
     7bc:	42b4      	cmp	r4, r6
     7be:	46f4      	mov	ip, lr
     7c0:	46b1      	mov	r9, r6
     7c2:	d359      	bcc.n	878 <__udivmoddi4+0x2a4>
     7c4:	d056      	beq.n	874 <__udivmoddi4+0x2a0>
     7c6:	2d00      	cmp	r5, #0
     7c8:	d06e      	beq.n	8a8 <__udivmoddi4+0x2d4>
     7ca:	ebb8 030c 	subs.w	r3, r8, ip
     7ce:	eb64 0409 	sbc.w	r4, r4, r9
     7d2:	40cb      	lsrs	r3, r1
     7d4:	fa04 f707 	lsl.w	r7, r4, r7
     7d8:	431f      	orrs	r7, r3
     7da:	40cc      	lsrs	r4, r1
     7dc:	e9c5 7400 	strd	r7, r4, [r5]
     7e0:	2100      	movs	r1, #0
     7e2:	e74a      	b.n	67a <__udivmoddi4+0xa6>
     7e4:	f1c2 0020 	rsb	r0, r2, #32
     7e8:	fa24 f100 	lsr.w	r1, r4, r0
     7ec:	fa0c fc02 	lsl.w	ip, ip, r2
     7f0:	fa06 f302 	lsl.w	r3, r6, r2
     7f4:	fa26 f000 	lsr.w	r0, r6, r0
     7f8:	ea4f 471c 	mov.w	r7, ip, lsr #16
     7fc:	ea41 0603 	orr.w	r6, r1, r3
     800:	fbb0 f1f7 	udiv	r1, r0, r7
     804:	fa1f f38c 	uxth.w	r3, ip
     808:	fb07 0e11 	mls	lr, r7, r1, r0
     80c:	0c30      	lsrs	r0, r6, #16
     80e:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
     812:	fb01 fe03 	mul.w	lr, r1, r3
     816:	4586      	cmp	lr, r0
     818:	fa04 f402 	lsl.w	r4, r4, r2
     81c:	d908      	bls.n	830 <__udivmoddi4+0x25c>
     81e:	eb1c 0000 	adds.w	r0, ip, r0
     822:	f101 38ff 	add.w	r8, r1, #4294967295
     826:	d232      	bcs.n	88e <__udivmoddi4+0x2ba>
     828:	4586      	cmp	lr, r0
     82a:	d930      	bls.n	88e <__udivmoddi4+0x2ba>
     82c:	3902      	subs	r1, #2
     82e:	4460      	add	r0, ip
     830:	eba0 000e 	sub.w	r0, r0, lr
     834:	b2b6      	uxth	r6, r6
     836:	fbb0 fef7 	udiv	lr, r0, r7
     83a:	fb07 001e 	mls	r0, r7, lr, r0
     83e:	ea46 4600 	orr.w	r6, r6, r0, lsl #16
     842:	fb0e f003 	mul.w	r0, lr, r3
     846:	42b0      	cmp	r0, r6
     848:	d909      	bls.n	85e <__udivmoddi4+0x28a>
     84a:	eb1c 0606 	adds.w	r6, ip, r6
     84e:	f10e 38ff 	add.w	r8, lr, #4294967295
     852:	d218      	bcs.n	886 <__udivmoddi4+0x2b2>
     854:	42b0      	cmp	r0, r6
     856:	d916      	bls.n	886 <__udivmoddi4+0x2b2>
     858:	f1ae 0e02 	sub.w	lr, lr, #2
     85c:	4466      	add	r6, ip
     85e:	1a36      	subs	r6, r6, r0
     860:	ea4e 4101 	orr.w	r1, lr, r1, lsl #16
     864:	e737      	b.n	6d6 <__udivmoddi4+0x102>
     866:	4629      	mov	r1, r5
     868:	4628      	mov	r0, r5
     86a:	e706      	b.n	67a <__udivmoddi4+0xa6>
     86c:	4606      	mov	r6, r0
     86e:	e6e4      	b.n	63a <__udivmoddi4+0x66>
     870:	4618      	mov	r0, r3
     872:	e6f9      	b.n	668 <__udivmoddi4+0x94>
     874:	45f0      	cmp	r8, lr
     876:	d2a6      	bcs.n	7c6 <__udivmoddi4+0x1f2>
     878:	ebbe 0c02 	subs.w	ip, lr, r2
     87c:	eb66 0303 	sbc.w	r3, r6, r3
     880:	3801      	subs	r0, #1
     882:	4699      	mov	r9, r3
     884:	e79f      	b.n	7c6 <__udivmoddi4+0x1f2>
     886:	46c6      	mov	lr, r8
     888:	e7e9      	b.n	85e <__udivmoddi4+0x28a>
     88a:	4630      	mov	r0, r6
     88c:	e790      	b.n	7b0 <__udivmoddi4+0x1dc>
     88e:	4641      	mov	r1, r8
     890:	e7ce      	b.n	830 <__udivmoddi4+0x25c>
     892:	46d6      	mov	lr, sl
     894:	e778      	b.n	788 <__udivmoddi4+0x1b4>
     896:	4464      	add	r4, ip
     898:	3802      	subs	r0, #2
     89a:	e745      	b.n	728 <__udivmoddi4+0x154>
     89c:	f1ae 0e02 	sub.w	lr, lr, #2
     8a0:	4466      	add	r6, ip
     8a2:	e72c      	b.n	6fe <__udivmoddi4+0x12a>
     8a4:	4608      	mov	r0, r1
     8a6:	e703      	b.n	6b0 <__udivmoddi4+0xdc>
     8a8:	4629      	mov	r1, r5
     8aa:	e6e6      	b.n	67a <__udivmoddi4+0xa6>

000008ac <__aeabi_idiv0>:
     8ac:	4770      	bx	lr
     8ae:	bf00      	nop

000008b0 <main>:
 * This example transmits 2 8 byte data PDUs every 5s using CAN 2 at a bitrate of 100Kbps.
 * In this case only one HTH is used with two message buffers.
 * 
 * @return Always zero
*/
int main( void ) {
     8b0:	b500      	push	{lr}
     8b2:	b08b      	sub	sp, #44	; 0x2c
    //local data.
    //Transmit message (PDU) 0 (Message ID 0x123) for Can 2 controller.
    uint8 Message0_SDU[8] = { 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08 }; //Data payload for message.
     8b4:	4a27      	ldr	r2, [pc, #156]	; (954 <main+0xa4>)
     8b6:	ab08      	add	r3, sp, #32
     8b8:	e892 0003 	ldmia.w	r2, {r0, r1}
     8bc:	e883 0003 	stmia.w	r3, {r0, r1}
    PduInfoType Message0 = {
     8c0:	ab08      	add	r3, sp, #32
     8c2:	9305      	str	r3, [sp, #20]
     8c4:	2300      	movs	r3, #0
     8c6:	9306      	str	r3, [sp, #24]
     8c8:	2308      	movs	r3, #8
     8ca:	9307      	str	r3, [sp, #28]
        .SduDataPtr = Message0_SDU,
        .MetaDataPtr = NULL_PTR
    };

    //Transmit message (PDU) 1 (Message ID 0x124) for Can 2 controller.
    uint8 Message1_SDU[8] = { 0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70 }; //Data payload for message.
     8cc:	4a22      	ldr	r2, [pc, #136]	; (958 <main+0xa8>)
     8ce:	ab03      	add	r3, sp, #12
     8d0:	e892 0003 	ldmia.w	r2, {r0, r1}
     8d4:	e883 0003 	stmia.w	r3, {r0, r1}
    PduInfoType Message1 = {
     8d8:	ab03      	add	r3, sp, #12
     8da:	9300      	str	r3, [sp, #0]
     8dc:	2300      	movs	r3, #0
     8de:	9301      	str	r3, [sp, #4]
     8e0:	2308      	movs	r3, #8
     8e2:	9302      	str	r3, [sp, #8]
        .SduLength = 8,
        .SduDataPtr = Message1_SDU,
        .MetaDataPtr = NULL_PTR
    };

    EcuM_Init();    //MCU configuration.
     8e4:	f000 fe80 	bl	15e8 <EcuM_Init>
    CanIf_SetControllerMode( CanIfFlexCan2 , CAN_CS_STARTED );   //Can 2 controller active in Can Bus.
     8e8:	2101      	movs	r1, #1
     8ea:	2000      	movs	r0, #0
     8ec:	f013 ff23 	bl	14736 <CanIf_SetControllerMode>

    while( 1u ) {
        //Transmit messages every 5s.
        CanIf_Transmit( CanIfTxPDU_0, &Message0 );   //Writing in Can 2 message buffer 0.
     8f0:	ab05      	add	r3, sp, #20
     8f2:	4619      	mov	r1, r3
     8f4:	2000      	movs	r0, #0
     8f6:	f013 fdf7 	bl	144e8 <CanIf_Transmit>
        CanIf_Transmit( CanIfTxPDU_1, &Message1 );  //Writing in Can 2 message buffer 1.
     8fa:	466b      	mov	r3, sp
     8fc:	4619      	mov	r1, r3
     8fe:	2001      	movs	r0, #1
     900:	f013 fdf2 	bl	144e8 <CanIf_Transmit>

        while( CanIf_Can2_bTxFlag == FALSE ); //Waiting until messages are transmitted.
     904:	bf00      	nop
     906:	4b15      	ldr	r3, [pc, #84]	; (95c <main+0xac>)
     908:	781b      	ldrb	r3, [r3, #0]
     90a:	f083 0301 	eor.w	r3, r3, #1
     90e:	b2db      	uxtb	r3, r3
     910:	2b00      	cmp	r3, #0
     912:	d1f8      	bne.n	906 <main+0x56>
        CanIf_Can2_bTxFlag = FALSE;  //Clearing transmit flag.
     914:	4b11      	ldr	r3, [pc, #68]	; (95c <main+0xac>)
     916:	2200      	movs	r2, #0
     918:	701a      	strb	r2, [r3, #0]

        //Changing SDUs.
        Message0_SDU[0]++;
     91a:	f89d 3020 	ldrb.w	r3, [sp, #32]
     91e:	3301      	adds	r3, #1
     920:	b2db      	uxtb	r3, r3
     922:	f88d 3020 	strb.w	r3, [sp, #32]
        Message0_SDU[7]++;
     926:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
     92a:	3301      	adds	r3, #1
     92c:	b2db      	uxtb	r3, r3
     92e:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
        Message1_SDU[0]++;
     932:	f89d 300c 	ldrb.w	r3, [sp, #12]
     936:	3301      	adds	r3, #1
     938:	b2db      	uxtb	r3, r3
     93a:	f88d 300c 	strb.w	r3, [sp, #12]
        Message1_SDU[7]++;
     93e:	f89d 3013 	ldrb.w	r3, [sp, #19]
     942:	3301      	adds	r3, #1
     944:	b2db      	uxtb	r3, r3
     946:	f88d 3013 	strb.w	r3, [sp, #19]

        Delay( 5000 );  //Waiting 5s for next transmission.
     94a:	f241 3088 	movw	r0, #5000	; 0x1388
     94e:	f000 fe65 	bl	161c <Delay>
        CanIf_Transmit( CanIfTxPDU_0, &Message0 );   //Writing in Can 2 message buffer 0.
     952:	e7cd      	b.n	8f0 <main+0x40>
     954:	00014a38 	.word	0x00014a38
     958:	00014a40 	.word	0x00014a40
     95c:	1fff8b30 	.word	0x1fff8b30

00000960 <DevAssert>:
    #error "Unsupported architecture!"
#endif

/* Implement default assert macro */
static inline void DevAssert(volatile boolean x)
{
     960:	b082      	sub	sp, #8
     962:	4603      	mov	r3, r0
     964:	f88d 3007 	strb.w	r3, [sp, #7]
    if(x) { } else { for(;;) {ASM_KEYWORD(BREAKPOINT_INSTR);} }
     968:	f89d 3007 	ldrb.w	r3, [sp, #7]
     96c:	b2db      	uxtb	r3, r3
     96e:	2b00      	cmp	r3, #0
     970:	d101      	bne.n	976 <DevAssert+0x16>
     972:	be00      	bkpt	0x0000
     974:	e7fd      	b.n	972 <DevAssert+0x12>
}
     976:	bf00      	nop
     978:	b002      	add	sp, #8
     97a:	4770      	bx	lr

0000097c <Adc_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Adc_schm_read_msr(void)
{
     97c:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     97e:	f3ef 8310 	mrs	r3, PRIMASK
     982:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     984:	4623      	mov	r3, r4
}
     986:	4618      	mov	r0, r3
     988:	f85d 4b04 	ldr.w	r4, [sp], #4
     98c:	4770      	bx	lr

0000098e <Can_43_FLEXCAN_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Can_43_FLEXCAN_schm_read_msr(void)
{
     98e:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     990:	f3ef 8310 	mrs	r3, PRIMASK
     994:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     996:	4623      	mov	r3, r4
}
     998:	4618      	mov	r0, r3
     99a:	f85d 4b04 	ldr.w	r4, [sp], #4
     99e:	4770      	bx	lr

000009a0 <Mcu_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Mcu_schm_read_msr(void)
{
     9a0:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     9a2:	f3ef 8310 	mrs	r3, PRIMASK
     9a6:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     9a8:	4623      	mov	r3, r4
}
     9aa:	4618      	mov	r0, r3
     9ac:	f85d 4b04 	ldr.w	r4, [sp], #4
     9b0:	4770      	bx	lr

000009b2 <Port_schm_read_msr>:
* @pre  None
* @post None
* 
*/
uint32 Port_schm_read_msr(void)
{
     9b2:	b410      	push	{r4}
        __asm volatile( " mrs %0, CPSR " : "=r" (reg_tmp) );
    #else
        #if ((defined MCAL_ENABLE_USER_MODE_SUPPORT)&&(!defined MCAL_PLATFORM_ARM_M0PLUS))
        __asm volatile( " mrs %0, basepri " : "=r" (reg_tmp) );
        #else
        __asm volatile( " mrs %0, primask " : "=r" (reg_tmp) );
     9b4:	f3ef 8310 	mrs	r3, PRIMASK
     9b8:	461c      	mov	r4, r3
        #endif
    #endif
    return (uint32)reg_tmp;
     9ba:	4623      	mov	r3, r4
}
     9bc:	4618      	mov	r0, r3
     9be:	f85d 4b04 	ldr.w	r4, [sp], #4
     9c2:	4770      	bx	lr

000009c4 <CDD_UserTxConfirmation_Can_2>:
 * @brief Callback function for the complete transmit of a PDU (registered) from Can2 controller.
 * 
 * @param TxPduId ID (container) of the PDU transmitted.
 * @param result Status of the transmision operation.
 */
void CDD_UserTxConfirmation_Can_2( PduIdType TxPduId, Std_ReturnType result ) {
     9c4:	b082      	sub	sp, #8
     9c6:	4603      	mov	r3, r0
     9c8:	460a      	mov	r2, r1
     9ca:	f8ad 3006 	strh.w	r3, [sp, #6]
     9ce:	4613      	mov	r3, r2
     9d0:	f88d 3005 	strb.w	r3, [sp, #5]
    //local data.
    static uint8 Transmit_count = 0;    //Count of transmitted PDUs.
    (void)TxPduId;

    if ( result == E_OK ) { //Message was transmitted successfully.
     9d4:	f89d 3005 	ldrb.w	r3, [sp, #5]
     9d8:	2b00      	cmp	r3, #0
     9da:	d105      	bne.n	9e8 <CDD_UserTxConfirmation_Can_2+0x24>
        Transmit_count++;
     9dc:	4b09      	ldr	r3, [pc, #36]	; (a04 <CDD_UserTxConfirmation_Can_2+0x40>)
     9de:	781b      	ldrb	r3, [r3, #0]
     9e0:	3301      	adds	r3, #1
     9e2:	b2da      	uxtb	r2, r3
     9e4:	4b07      	ldr	r3, [pc, #28]	; (a04 <CDD_UserTxConfirmation_Can_2+0x40>)
     9e6:	701a      	strb	r2, [r3, #0]
    }

    if ( Transmit_count == 2 ) {    //All PDUs were transmitted successfully.
     9e8:	4b06      	ldr	r3, [pc, #24]	; (a04 <CDD_UserTxConfirmation_Can_2+0x40>)
     9ea:	781b      	ldrb	r3, [r3, #0]
     9ec:	2b02      	cmp	r3, #2
     9ee:	d105      	bne.n	9fc <CDD_UserTxConfirmation_Can_2+0x38>
        CanIf_Can2_bTxFlag = TRUE;
     9f0:	4b05      	ldr	r3, [pc, #20]	; (a08 <CDD_UserTxConfirmation_Can_2+0x44>)
     9f2:	2201      	movs	r2, #1
     9f4:	701a      	strb	r2, [r3, #0]
        Transmit_count = 0;
     9f6:	4b03      	ldr	r3, [pc, #12]	; (a04 <CDD_UserTxConfirmation_Can_2+0x40>)
     9f8:	2200      	movs	r2, #0
     9fa:	701a      	strb	r2, [r3, #0]
    }
}
     9fc:	bf00      	nop
     9fe:	b002      	add	sp, #8
     a00:	4770      	bx	lr
     a02:	bf00      	nop
     a04:	1fff9544 	.word	0x1fff9544
     a08:	1fff8b30 	.word	0x1fff8b30

00000a0c <init_data_bss>:
 * Implements    : init_data_bss_Activity
 *END**************************************************************************/
void init_data_bss(void);

void init_data_bss(void)
{
     a0c:	b08a      	sub	sp, #40	; 0x28
    const Sys_CopyLayoutType * copy_layout;
    const Sys_ZeroLayoutType * zero_layout;
    const uint8 * rom;
    uint8 * ram;
    uint32 len = 0U;
     a0e:	2300      	movs	r3, #0
     a10:	9307      	str	r3, [sp, #28]
    uint32 size = 0U;
     a12:	2300      	movs	r3, #0
     a14:	9306      	str	r3, [sp, #24]
    uint32 i = 0U;
     a16:	2300      	movs	r3, #0
     a18:	9309      	str	r3, [sp, #36]	; 0x24
    uint32 j = 0U;
     a1a:	2300      	movs	r3, #0
     a1c:	9308      	str	r3, [sp, #32]

    const uint32 * initTable_Ptr = (uint32 *)__INIT_TABLE;
     a1e:	4b44      	ldr	r3, [pc, #272]	; (b30 <init_data_bss+0x124>)
     a20:	9305      	str	r3, [sp, #20]
    const uint32 * zeroTable_Ptr = (uint32*)__ZERO_TABLE;
     a22:	4b44      	ldr	r3, [pc, #272]	; (b34 <init_data_bss+0x128>)
     a24:	9304      	str	r3, [sp, #16]

    /* Copy initialized table */
    len = *initTable_Ptr;
     a26:	9b05      	ldr	r3, [sp, #20]
     a28:	681b      	ldr	r3, [r3, #0]
     a2a:	9307      	str	r3, [sp, #28]
    initTable_Ptr++;
     a2c:	9b05      	ldr	r3, [sp, #20]
     a2e:	3304      	adds	r3, #4
     a30:	9305      	str	r3, [sp, #20]
    copy_layout = (const Sys_CopyLayoutType *)initTable_Ptr;
     a32:	9b05      	ldr	r3, [sp, #20]
     a34:	9303      	str	r3, [sp, #12]
    for(i = 0; i < len; i++)
     a36:	2300      	movs	r3, #0
     a38:	9309      	str	r3, [sp, #36]	; 0x24
     a3a:	e03d      	b.n	ab8 <init_data_bss+0xac>
    {
        rom = copy_layout[i].rom_start;
     a3c:	9a09      	ldr	r2, [sp, #36]	; 0x24
     a3e:	4613      	mov	r3, r2
     a40:	005b      	lsls	r3, r3, #1
     a42:	4413      	add	r3, r2
     a44:	009b      	lsls	r3, r3, #2
     a46:	461a      	mov	r2, r3
     a48:	9b03      	ldr	r3, [sp, #12]
     a4a:	4413      	add	r3, r2
     a4c:	685b      	ldr	r3, [r3, #4]
     a4e:	9300      	str	r3, [sp, #0]
        ram = copy_layout[i].ram_start;
     a50:	9a09      	ldr	r2, [sp, #36]	; 0x24
     a52:	4613      	mov	r3, r2
     a54:	005b      	lsls	r3, r3, #1
     a56:	4413      	add	r3, r2
     a58:	009b      	lsls	r3, r3, #2
     a5a:	461a      	mov	r2, r3
     a5c:	9b03      	ldr	r3, [sp, #12]
     a5e:	4413      	add	r3, r2
     a60:	681b      	ldr	r3, [r3, #0]
     a62:	9301      	str	r3, [sp, #4]
        size = (uint32)copy_layout[i].rom_end - (uint32)copy_layout[i].rom_start;
     a64:	9a09      	ldr	r2, [sp, #36]	; 0x24
     a66:	4613      	mov	r3, r2
     a68:	005b      	lsls	r3, r3, #1
     a6a:	4413      	add	r3, r2
     a6c:	009b      	lsls	r3, r3, #2
     a6e:	461a      	mov	r2, r3
     a70:	9b03      	ldr	r3, [sp, #12]
     a72:	4413      	add	r3, r2
     a74:	689b      	ldr	r3, [r3, #8]
     a76:	4619      	mov	r1, r3
     a78:	9a09      	ldr	r2, [sp, #36]	; 0x24
     a7a:	4613      	mov	r3, r2
     a7c:	005b      	lsls	r3, r3, #1
     a7e:	4413      	add	r3, r2
     a80:	009b      	lsls	r3, r3, #2
     a82:	461a      	mov	r2, r3
     a84:	9b03      	ldr	r3, [sp, #12]
     a86:	4413      	add	r3, r2
     a88:	685b      	ldr	r3, [r3, #4]
     a8a:	1acb      	subs	r3, r1, r3
     a8c:	9306      	str	r3, [sp, #24]

        for(j = 0UL; j < size; j++)
     a8e:	2300      	movs	r3, #0
     a90:	9308      	str	r3, [sp, #32]
     a92:	e00a      	b.n	aaa <init_data_bss+0x9e>
        {
            ram[j] = rom[j];
     a94:	9a00      	ldr	r2, [sp, #0]
     a96:	9b08      	ldr	r3, [sp, #32]
     a98:	441a      	add	r2, r3
     a9a:	9901      	ldr	r1, [sp, #4]
     a9c:	9b08      	ldr	r3, [sp, #32]
     a9e:	440b      	add	r3, r1
     aa0:	7812      	ldrb	r2, [r2, #0]
     aa2:	701a      	strb	r2, [r3, #0]
        for(j = 0UL; j < size; j++)
     aa4:	9b08      	ldr	r3, [sp, #32]
     aa6:	3301      	adds	r3, #1
     aa8:	9308      	str	r3, [sp, #32]
     aaa:	9a08      	ldr	r2, [sp, #32]
     aac:	9b06      	ldr	r3, [sp, #24]
     aae:	429a      	cmp	r2, r3
     ab0:	d3f0      	bcc.n	a94 <init_data_bss+0x88>
    for(i = 0; i < len; i++)
     ab2:	9b09      	ldr	r3, [sp, #36]	; 0x24
     ab4:	3301      	adds	r3, #1
     ab6:	9309      	str	r3, [sp, #36]	; 0x24
     ab8:	9a09      	ldr	r2, [sp, #36]	; 0x24
     aba:	9b07      	ldr	r3, [sp, #28]
     abc:	429a      	cmp	r2, r3
     abe:	d3bd      	bcc.n	a3c <init_data_bss+0x30>
        }
    }
    
    /* Clear zero table */
    len = *zeroTable_Ptr;
     ac0:	9b04      	ldr	r3, [sp, #16]
     ac2:	681b      	ldr	r3, [r3, #0]
     ac4:	9307      	str	r3, [sp, #28]
    zeroTable_Ptr++;
     ac6:	9b04      	ldr	r3, [sp, #16]
     ac8:	3304      	adds	r3, #4
     aca:	9304      	str	r3, [sp, #16]
    zero_layout = (const Sys_ZeroLayoutType *)zeroTable_Ptr;
     acc:	9b04      	ldr	r3, [sp, #16]
     ace:	9302      	str	r3, [sp, #8]
    for(i = 0; i < len; i++)
     ad0:	2300      	movs	r3, #0
     ad2:	9309      	str	r3, [sp, #36]	; 0x24
     ad4:	e024      	b.n	b20 <init_data_bss+0x114>
    {
        ram = zero_layout[i].ram_start;
     ad6:	9b09      	ldr	r3, [sp, #36]	; 0x24
     ad8:	00db      	lsls	r3, r3, #3
     ada:	9a02      	ldr	r2, [sp, #8]
     adc:	4413      	add	r3, r2
     ade:	681b      	ldr	r3, [r3, #0]
     ae0:	9301      	str	r3, [sp, #4]
        size = (uint32)zero_layout[i].ram_end - (uint32)zero_layout[i].ram_start;
     ae2:	9b09      	ldr	r3, [sp, #36]	; 0x24
     ae4:	00db      	lsls	r3, r3, #3
     ae6:	9a02      	ldr	r2, [sp, #8]
     ae8:	4413      	add	r3, r2
     aea:	685b      	ldr	r3, [r3, #4]
     aec:	4619      	mov	r1, r3
     aee:	9b09      	ldr	r3, [sp, #36]	; 0x24
     af0:	00db      	lsls	r3, r3, #3
     af2:	9a02      	ldr	r2, [sp, #8]
     af4:	4413      	add	r3, r2
     af6:	681b      	ldr	r3, [r3, #0]
     af8:	1acb      	subs	r3, r1, r3
     afa:	9306      	str	r3, [sp, #24]

        for(j = 0UL; j < size; j++)
     afc:	2300      	movs	r3, #0
     afe:	9308      	str	r3, [sp, #32]
     b00:	e007      	b.n	b12 <init_data_bss+0x106>
        {
            ram[j] = 0U;
     b02:	9a01      	ldr	r2, [sp, #4]
     b04:	9b08      	ldr	r3, [sp, #32]
     b06:	4413      	add	r3, r2
     b08:	2200      	movs	r2, #0
     b0a:	701a      	strb	r2, [r3, #0]
        for(j = 0UL; j < size; j++)
     b0c:	9b08      	ldr	r3, [sp, #32]
     b0e:	3301      	adds	r3, #1
     b10:	9308      	str	r3, [sp, #32]
     b12:	9a08      	ldr	r2, [sp, #32]
     b14:	9b06      	ldr	r3, [sp, #24]
     b16:	429a      	cmp	r2, r3
     b18:	d3f3      	bcc.n	b02 <init_data_bss+0xf6>
    for(i = 0; i < len; i++)
     b1a:	9b09      	ldr	r3, [sp, #36]	; 0x24
     b1c:	3301      	adds	r3, #1
     b1e:	9309      	str	r3, [sp, #36]	; 0x24
     b20:	9a09      	ldr	r2, [sp, #36]	; 0x24
     b22:	9b07      	ldr	r3, [sp, #28]
     b24:	429a      	cmp	r2, r3
     b26:	d3d6      	bcc.n	ad6 <init_data_bss+0xca>
        }
    }
}
     b28:	bf00      	nop
     b2a:	bf00      	nop
     b2c:	b00a      	add	sp, #40	; 0x28
     b2e:	4770      	bx	lr
     b30:	00016bf8 	.word	0x00016bf8
     b34:	00016c14 	.word	0x00016c14

00000b38 <sys_m4_cache_init>:
{
     b38:	b084      	sub	sp, #16
     b3a:	4603      	mov	r3, r0
     b3c:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 RetValue = CACHE_OK;
     b40:	2300      	movs	r3, #0
     b42:	f88d 300f 	strb.w	r3, [sp, #15]
  if (cache == CODE_CACHE)
     b46:	f89d 3007 	ldrb.w	r3, [sp, #7]
     b4a:	2b00      	cmp	r3, #0
     b4c:	d118      	bne.n	b80 <sys_m4_cache_init+0x48>
      IP_LMEM->PCCCR = 0x05000000UL;
     b4e:	4b10      	ldr	r3, [pc, #64]	; (b90 <sys_m4_cache_init+0x58>)
     b50:	f04f 62a0 	mov.w	r2, #83886080	; 0x5000000
     b54:	601a      	str	r2, [r3, #0]
      IP_LMEM->PCCCR |= LMEM_PCCCR_GO(1);
     b56:	4b0e      	ldr	r3, [pc, #56]	; (b90 <sys_m4_cache_init+0x58>)
     b58:	681b      	ldr	r3, [r3, #0]
     b5a:	4a0d      	ldr	r2, [pc, #52]	; (b90 <sys_m4_cache_init+0x58>)
     b5c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
     b60:	6013      	str	r3, [r2, #0]
      while((IP_LMEM->PCCCR & LMEM_PCCCR_GO_MASK) == LMEM_PCCCR_GO_MASK){};
     b62:	bf00      	nop
     b64:	4b0a      	ldr	r3, [pc, #40]	; (b90 <sys_m4_cache_init+0x58>)
     b66:	681b      	ldr	r3, [r3, #0]
     b68:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
     b6c:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
     b70:	d0f8      	beq.n	b64 <sys_m4_cache_init+0x2c>
      IP_LMEM->PCCCR |= LMEM_PCCCR_ENCACHE(1);
     b72:	4b07      	ldr	r3, [pc, #28]	; (b90 <sys_m4_cache_init+0x58>)
     b74:	681b      	ldr	r3, [r3, #0]
     b76:	4a06      	ldr	r2, [pc, #24]	; (b90 <sys_m4_cache_init+0x58>)
     b78:	f043 0301 	orr.w	r3, r3, #1
     b7c:	6013      	str	r3, [r2, #0]
     b7e:	e002      	b.n	b86 <sys_m4_cache_init+0x4e>
     RetValue = CACHE_INVALID_PARAM;
     b80:	2301      	movs	r3, #1
     b82:	f88d 300f 	strb.w	r3, [sp, #15]
  return RetValue;
     b86:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
     b8a:	4618      	mov	r0, r3
     b8c:	b004      	add	sp, #16
     b8e:	4770      	bx	lr
     b90:	e0082000 	.word	0xe0082000

00000b94 <startup_go_to_user_mode>:
}
     b94:	bf00      	nop
     b96:	4770      	bx	lr

00000b98 <Sys_GetCoreID>:
    return 0U;
     b98:	2300      	movs	r3, #0
}
     b9a:	4618      	mov	r0, r3
     b9c:	4770      	bx	lr

00000b9e <HardFault_Handler>:
}
void HardFault_Handler(void)
{
    while(TRUE){};
     b9e:	e7fe      	b.n	b9e <HardFault_Handler>

00000ba0 <MemManage_Handler>:
}
void MemManage_Handler(void)
{
    while(TRUE){};
     ba0:	e7fe      	b.n	ba0 <MemManage_Handler>

00000ba2 <BusFault_Handler>:
}
void BusFault_Handler(void)
{
    while(TRUE){};
     ba2:	e7fe      	b.n	ba2 <BusFault_Handler>

00000ba4 <UsageFault_Handler>:
}
void UsageFault_Handler(void)
{
    while(TRUE){};
     ba4:	e7fe      	b.n	ba4 <UsageFault_Handler>

00000ba6 <SVC_Handler>:

#ifndef MCAL_ENABLE_USER_MODE_SUPPORT
void SVC_Handler(void)  __attribute__ ((weak));               /* SVCall Handler */
void SVC_Handler(void)
{
    while(TRUE){};
     ba6:	e7fe      	b.n	ba6 <SVC_Handler>

00000ba8 <DebugMon_Handler>:
    ASM_KEYWORD("pop {r0}");
}
#endif
void DebugMon_Handler(void)
{
    while(TRUE){};
     ba8:	e7fe      	b.n	ba8 <DebugMon_Handler>

00000baa <PendSV_Handler>:
}
void PendSV_Handler(void)
{
    while(TRUE){};
     baa:	e7fe      	b.n	baa <PendSV_Handler>

00000bac <SysTick_Handler>:
}
void SysTick_Handler(void)
{
    while(TRUE){};
     bac:	e7fe      	b.n	bac <SysTick_Handler>

00000bae <undefined_handler>:
}
void undefined_handler(void)
{
   while(TRUE){};
     bae:	e7fe      	b.n	bae <undefined_handler>

00000bb0 <_DoInit>:
      if (pRTTCBInit->acID[0] != 'S') {                                                      \
        _DoInit();                                                                           \
      }                                                                                      \
    } while (0)

static void _DoInit(void) {
     bb0:	b500      	push	{lr}
     bb2:	b083      	sub	sp, #12
  static const char _aInitStr[] = "\0\0\0\0\0\0TTR REGGES";  // Init complete ID string to make sure that things also work if RTT is linked to a no-init memory area
  unsigned i;
  //
  // Initialize control block
  //
  p                     = (volatile SEGGER_RTT_CB*)((uintptr_t)&_SEGGER_RTT + SEGGER_RTT_UNCACHED_OFF);  // Access control block uncached so that nothing in the cache ever becomes dirty and all changes are visible in HW directly
     bb4:	4b26      	ldr	r3, [pc, #152]	; (c50 <_DoInit+0xa0>)
     bb6:	9300      	str	r3, [sp, #0]
  memset((SEGGER_RTT_CB*)p, 0, sizeof(_SEGGER_RTT));         // Make sure that the RTT CB is always zero initialized.
     bb8:	22a8      	movs	r2, #168	; 0xa8
     bba:	2100      	movs	r1, #0
     bbc:	9800      	ldr	r0, [sp, #0]
     bbe:	f000 fd61 	bl	1684 <memset>
  p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
     bc2:	9b00      	ldr	r3, [sp, #0]
     bc4:	2203      	movs	r2, #3
     bc6:	611a      	str	r2, [r3, #16]
  p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
     bc8:	9b00      	ldr	r3, [sp, #0]
     bca:	2203      	movs	r2, #3
     bcc:	615a      	str	r2, [r3, #20]
  //
  // Initialize up buffer 0
  //
  p->aUp[0].sName         = "Terminal";
     bce:	9b00      	ldr	r3, [sp, #0]
     bd0:	4a20      	ldr	r2, [pc, #128]	; (c54 <_DoInit+0xa4>)
     bd2:	619a      	str	r2, [r3, #24]
  p->aUp[0].pBuffer       = _acUpBuffer;
     bd4:	9b00      	ldr	r3, [sp, #0]
     bd6:	4a20      	ldr	r2, [pc, #128]	; (c58 <_DoInit+0xa8>)
     bd8:	61da      	str	r2, [r3, #28]
  p->aUp[0].SizeOfBuffer  = BUFFER_SIZE_UP;
     bda:	9b00      	ldr	r3, [sp, #0]
     bdc:	f44f 6280 	mov.w	r2, #1024	; 0x400
     be0:	621a      	str	r2, [r3, #32]
  p->aUp[0].RdOff         = 0u;
     be2:	9b00      	ldr	r3, [sp, #0]
     be4:	2200      	movs	r2, #0
     be6:	629a      	str	r2, [r3, #40]	; 0x28
  p->aUp[0].WrOff         = 0u;
     be8:	9b00      	ldr	r3, [sp, #0]
     bea:	2200      	movs	r2, #0
     bec:	625a      	str	r2, [r3, #36]	; 0x24
  p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
     bee:	9b00      	ldr	r3, [sp, #0]
     bf0:	2200      	movs	r2, #0
     bf2:	62da      	str	r2, [r3, #44]	; 0x2c
  //
  // Initialize down buffer 0
  //
  p->aDown[0].sName         = "Terminal";
     bf4:	9b00      	ldr	r3, [sp, #0]
     bf6:	4a17      	ldr	r2, [pc, #92]	; (c54 <_DoInit+0xa4>)
     bf8:	661a      	str	r2, [r3, #96]	; 0x60
  p->aDown[0].pBuffer       = _acDownBuffer;
     bfa:	9b00      	ldr	r3, [sp, #0]
     bfc:	4a17      	ldr	r2, [pc, #92]	; (c5c <_DoInit+0xac>)
     bfe:	665a      	str	r2, [r3, #100]	; 0x64
  p->aDown[0].SizeOfBuffer  = BUFFER_SIZE_DOWN;
     c00:	9b00      	ldr	r3, [sp, #0]
     c02:	2210      	movs	r2, #16
     c04:	669a      	str	r2, [r3, #104]	; 0x68
  p->aDown[0].RdOff         = 0u;
     c06:	9b00      	ldr	r3, [sp, #0]
     c08:	2200      	movs	r2, #0
     c0a:	671a      	str	r2, [r3, #112]	; 0x70
  p->aDown[0].WrOff         = 0u;
     c0c:	9b00      	ldr	r3, [sp, #0]
     c0e:	2200      	movs	r2, #0
     c10:	66da      	str	r2, [r3, #108]	; 0x6c
  p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
     c12:	9b00      	ldr	r3, [sp, #0]
     c14:	2200      	movs	r2, #0
     c16:	675a      	str	r2, [r3, #116]	; 0x74
  //
  // Finish initialization of the control block.
  // Copy Id string backwards to make sure that "SEGGER RTT" is not found in initializer memory (usually flash),
  // as this would cause J-Link to "find" the control block at a wrong address.
  //
  RTT__DMB();                       // Force order of memory accesses for cores that may perform out-of-order memory accesses
     c18:	f3bf 8f5f 	dmb	sy
  for (i = 0; i < sizeof(_aInitStr) - 1; ++i) {
     c1c:	2300      	movs	r3, #0
     c1e:	9301      	str	r3, [sp, #4]
     c20:	e00c      	b.n	c3c <_DoInit+0x8c>
    p->acID[i] = _aInitStr[sizeof(_aInitStr) - 2 - i];  // Skip terminating \0 at the end of the array
     c22:	9b01      	ldr	r3, [sp, #4]
     c24:	f1c3 030f 	rsb	r3, r3, #15
     c28:	4a0d      	ldr	r2, [pc, #52]	; (c60 <_DoInit+0xb0>)
     c2a:	5cd1      	ldrb	r1, [r2, r3]
     c2c:	9a00      	ldr	r2, [sp, #0]
     c2e:	9b01      	ldr	r3, [sp, #4]
     c30:	4413      	add	r3, r2
     c32:	460a      	mov	r2, r1
     c34:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < sizeof(_aInitStr) - 1; ++i) {
     c36:	9b01      	ldr	r3, [sp, #4]
     c38:	3301      	adds	r3, #1
     c3a:	9301      	str	r3, [sp, #4]
     c3c:	9b01      	ldr	r3, [sp, #4]
     c3e:	2b0f      	cmp	r3, #15
     c40:	d9ef      	bls.n	c22 <_DoInit+0x72>
  }
  RTT__DMB();                       // Force order of memory accesses for cores that may perform out-of-order memory accesses
     c42:	f3bf 8f5f 	dmb	sy
}
     c46:	bf00      	nop
     c48:	b003      	add	sp, #12
     c4a:	f85d fb04 	ldr.w	pc, [sp], #4
     c4e:	bf00      	nop
     c50:	1fff954c 	.word	0x1fff954c
     c54:	0001541c 	.word	0x0001541c
     c58:	1fff95f4 	.word	0x1fff95f4
     c5c:	1fff99f4 	.word	0x1fff99f4
     c60:	00016bd4 	.word	0x00016bd4

00000c64 <_WriteBlocking>:
*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
*
*  Return value
*    >= 0 - Number of bytes written into buffer.
*/
static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
     c64:	b500      	push	{lr}
     c66:	b08b      	sub	sp, #44	; 0x2c
     c68:	9003      	str	r0, [sp, #12]
     c6a:	9102      	str	r1, [sp, #8]
     c6c:	9201      	str	r2, [sp, #4]
  unsigned WrOff;
  volatile char* pDst;
  //
  // Write data to buffer and handle wrap-around if necessary
  //
  NumBytesWritten = 0u;
     c6e:	2300      	movs	r3, #0
     c70:	9308      	str	r3, [sp, #32]
  WrOff = pRing->WrOff;
     c72:	9b03      	ldr	r3, [sp, #12]
     c74:	68db      	ldr	r3, [r3, #12]
     c76:	9307      	str	r3, [sp, #28]
  do {
    RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
     c78:	9b03      	ldr	r3, [sp, #12]
     c7a:	691b      	ldr	r3, [r3, #16]
     c7c:	9306      	str	r3, [sp, #24]
    if (RdOff > WrOff) {
     c7e:	9a06      	ldr	r2, [sp, #24]
     c80:	9b07      	ldr	r3, [sp, #28]
     c82:	429a      	cmp	r2, r3
     c84:	d905      	bls.n	c92 <_WriteBlocking+0x2e>
      NumBytesToWrite = RdOff - WrOff - 1u;
     c86:	9a06      	ldr	r2, [sp, #24]
     c88:	9b07      	ldr	r3, [sp, #28]
     c8a:	1ad3      	subs	r3, r2, r3
     c8c:	3b01      	subs	r3, #1
     c8e:	9309      	str	r3, [sp, #36]	; 0x24
     c90:	e007      	b.n	ca2 <_WriteBlocking+0x3e>
    } else {
      NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
     c92:	9b03      	ldr	r3, [sp, #12]
     c94:	689a      	ldr	r2, [r3, #8]
     c96:	9906      	ldr	r1, [sp, #24]
     c98:	9b07      	ldr	r3, [sp, #28]
     c9a:	1acb      	subs	r3, r1, r3
     c9c:	4413      	add	r3, r2
     c9e:	3b01      	subs	r3, #1
     ca0:	9309      	str	r3, [sp, #36]	; 0x24
    }
    NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
     ca2:	9b03      	ldr	r3, [sp, #12]
     ca4:	689a      	ldr	r2, [r3, #8]
     ca6:	9b07      	ldr	r3, [sp, #28]
     ca8:	1ad3      	subs	r3, r2, r3
     caa:	9a09      	ldr	r2, [sp, #36]	; 0x24
     cac:	4293      	cmp	r3, r2
     cae:	bf28      	it	cs
     cb0:	4613      	movcs	r3, r2
     cb2:	9309      	str	r3, [sp, #36]	; 0x24
    NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
     cb4:	9a09      	ldr	r2, [sp, #36]	; 0x24
     cb6:	9b01      	ldr	r3, [sp, #4]
     cb8:	4293      	cmp	r3, r2
     cba:	bf28      	it	cs
     cbc:	4613      	movcs	r3, r2
     cbe:	9309      	str	r3, [sp, #36]	; 0x24
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
     cc0:	9b03      	ldr	r3, [sp, #12]
     cc2:	685a      	ldr	r2, [r3, #4]
     cc4:	9b07      	ldr	r3, [sp, #28]
     cc6:	4413      	add	r3, r2
     cc8:	9305      	str	r3, [sp, #20]
    WrOff           += NumBytesToWrite;
    while (NumBytesToWrite--) {
      *pDst++ = *pBuffer++;
    };
#else
    SEGGER_RTT_MEMCPY((void*)pDst, pBuffer, NumBytesToWrite);
     cca:	9a09      	ldr	r2, [sp, #36]	; 0x24
     ccc:	9902      	ldr	r1, [sp, #8]
     cce:	9805      	ldr	r0, [sp, #20]
     cd0:	f000 fcca 	bl	1668 <memcpy>
    NumBytesWritten += NumBytesToWrite;
     cd4:	9a08      	ldr	r2, [sp, #32]
     cd6:	9b09      	ldr	r3, [sp, #36]	; 0x24
     cd8:	4413      	add	r3, r2
     cda:	9308      	str	r3, [sp, #32]
    pBuffer         += NumBytesToWrite;
     cdc:	9a02      	ldr	r2, [sp, #8]
     cde:	9b09      	ldr	r3, [sp, #36]	; 0x24
     ce0:	4413      	add	r3, r2
     ce2:	9302      	str	r3, [sp, #8]
    NumBytes        -= NumBytesToWrite;
     ce4:	9a01      	ldr	r2, [sp, #4]
     ce6:	9b09      	ldr	r3, [sp, #36]	; 0x24
     ce8:	1ad3      	subs	r3, r2, r3
     cea:	9301      	str	r3, [sp, #4]
    WrOff           += NumBytesToWrite;
     cec:	9a07      	ldr	r2, [sp, #28]
     cee:	9b09      	ldr	r3, [sp, #36]	; 0x24
     cf0:	4413      	add	r3, r2
     cf2:	9307      	str	r3, [sp, #28]
#endif
    if (WrOff == pRing->SizeOfBuffer) {
     cf4:	9b03      	ldr	r3, [sp, #12]
     cf6:	689b      	ldr	r3, [r3, #8]
     cf8:	9a07      	ldr	r2, [sp, #28]
     cfa:	429a      	cmp	r2, r3
     cfc:	d101      	bne.n	d02 <_WriteBlocking+0x9e>
      WrOff = 0u;
     cfe:	2300      	movs	r3, #0
     d00:	9307      	str	r3, [sp, #28]
    }
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
     d02:	f3bf 8f5f 	dmb	sy
    pRing->WrOff = WrOff;
     d06:	9b03      	ldr	r3, [sp, #12]
     d08:	9a07      	ldr	r2, [sp, #28]
     d0a:	60da      	str	r2, [r3, #12]
  } while (NumBytes);
     d0c:	9b01      	ldr	r3, [sp, #4]
     d0e:	2b00      	cmp	r3, #0
     d10:	d1b2      	bne.n	c78 <_WriteBlocking+0x14>
  return NumBytesWritten;
     d12:	9b08      	ldr	r3, [sp, #32]
}
     d14:	4618      	mov	r0, r3
     d16:	b00b      	add	sp, #44	; 0x2c
     d18:	f85d fb04 	ldr.w	pc, [sp], #4

00000d1c <_WriteNoCheck>:
*    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
*
*  Notes
*    (1) If there might not be enough space in the "Up"-buffer, call _WriteBlocking
*/
static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
     d1c:	b500      	push	{lr}
     d1e:	b089      	sub	sp, #36	; 0x24
     d20:	9003      	str	r0, [sp, #12]
     d22:	9102      	str	r1, [sp, #8]
     d24:	9201      	str	r2, [sp, #4]
  unsigned NumBytesAtOnce;
  unsigned WrOff;
  unsigned Rem;
  volatile char* pDst;

  WrOff = pRing->WrOff;
     d26:	9b03      	ldr	r3, [sp, #12]
     d28:	68db      	ldr	r3, [r3, #12]
     d2a:	9307      	str	r3, [sp, #28]
  Rem = pRing->SizeOfBuffer - WrOff;
     d2c:	9b03      	ldr	r3, [sp, #12]
     d2e:	689a      	ldr	r2, [r3, #8]
     d30:	9b07      	ldr	r3, [sp, #28]
     d32:	1ad3      	subs	r3, r2, r3
     d34:	9306      	str	r3, [sp, #24]
  if (Rem > NumBytes) {
     d36:	9a06      	ldr	r2, [sp, #24]
     d38:	9b01      	ldr	r3, [sp, #4]
     d3a:	429a      	cmp	r2, r3
     d3c:	d911      	bls.n	d62 <_WriteNoCheck+0x46>
    //
    // All data fits before wrap around
    //
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
     d3e:	9b03      	ldr	r3, [sp, #12]
     d40:	685a      	ldr	r2, [r3, #4]
     d42:	9b07      	ldr	r3, [sp, #28]
     d44:	4413      	add	r3, r2
     d46:	9304      	str	r3, [sp, #16]
      *pDst++ = *pData++;
    };
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    pRing->WrOff = WrOff;
#else
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytes);
     d48:	9a01      	ldr	r2, [sp, #4]
     d4a:	9902      	ldr	r1, [sp, #8]
     d4c:	9804      	ldr	r0, [sp, #16]
     d4e:	f000 fc8b 	bl	1668 <memcpy>
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
     d52:	f3bf 8f5f 	dmb	sy
    pRing->WrOff = WrOff + NumBytes;
     d56:	9a07      	ldr	r2, [sp, #28]
     d58:	9b01      	ldr	r3, [sp, #4]
     d5a:	441a      	add	r2, r3
     d5c:	9b03      	ldr	r3, [sp, #12]
     d5e:	60da      	str	r2, [r3, #12]
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
    pRing->WrOff = NumBytesAtOnce;
#endif
  }
}
     d60:	e01f      	b.n	da2 <_WriteNoCheck+0x86>
    NumBytesAtOnce = Rem;
     d62:	9b06      	ldr	r3, [sp, #24]
     d64:	9305      	str	r3, [sp, #20]
    pDst = (pRing->pBuffer + WrOff) + SEGGER_RTT_UNCACHED_OFF;
     d66:	9b03      	ldr	r3, [sp, #12]
     d68:	685a      	ldr	r2, [r3, #4]
     d6a:	9b07      	ldr	r3, [sp, #28]
     d6c:	4413      	add	r3, r2
     d6e:	9304      	str	r3, [sp, #16]
    SEGGER_RTT_MEMCPY((void*)pDst, pData, NumBytesAtOnce);
     d70:	9a05      	ldr	r2, [sp, #20]
     d72:	9902      	ldr	r1, [sp, #8]
     d74:	9804      	ldr	r0, [sp, #16]
     d76:	f000 fc77 	bl	1668 <memcpy>
    NumBytesAtOnce = NumBytes - Rem;
     d7a:	9a01      	ldr	r2, [sp, #4]
     d7c:	9b06      	ldr	r3, [sp, #24]
     d7e:	1ad3      	subs	r3, r2, r3
     d80:	9305      	str	r3, [sp, #20]
    pDst = pRing->pBuffer + SEGGER_RTT_UNCACHED_OFF;
     d82:	9b03      	ldr	r3, [sp, #12]
     d84:	685b      	ldr	r3, [r3, #4]
     d86:	9304      	str	r3, [sp, #16]
    SEGGER_RTT_MEMCPY((void*)pDst, pData + Rem, NumBytesAtOnce);
     d88:	9a02      	ldr	r2, [sp, #8]
     d8a:	9b06      	ldr	r3, [sp, #24]
     d8c:	4413      	add	r3, r2
     d8e:	9a05      	ldr	r2, [sp, #20]
     d90:	4619      	mov	r1, r3
     d92:	9804      	ldr	r0, [sp, #16]
     d94:	f000 fc68 	bl	1668 <memcpy>
    RTT__DMB();                     // Force data write to be complete before writing the <WrOff>, in case CPU is allowed to change the order of memory accesses
     d98:	f3bf 8f5f 	dmb	sy
    pRing->WrOff = NumBytesAtOnce;
     d9c:	9b03      	ldr	r3, [sp, #12]
     d9e:	9a05      	ldr	r2, [sp, #20]
     da0:	60da      	str	r2, [r3, #12]
}
     da2:	bf00      	nop
     da4:	b009      	add	sp, #36	; 0x24
     da6:	f85d fb04 	ldr.w	pc, [sp], #4

00000daa <_GetAvailWriteSpace>:
*    pRing        Ring buffer to check.
*
*  Return value
*    Number of bytes that are free in the buffer.
*/
static unsigned _GetAvailWriteSpace(SEGGER_RTT_BUFFER_UP* pRing) {
     daa:	b086      	sub	sp, #24
     dac:	9001      	str	r0, [sp, #4]
  unsigned r;
  //
  // Avoid warnings regarding volatile access order.  It's not a problem
  // in this case, but dampen compiler enthusiasm.
  //
  RdOff = pRing->RdOff;
     dae:	9b01      	ldr	r3, [sp, #4]
     db0:	691b      	ldr	r3, [r3, #16]
     db2:	9304      	str	r3, [sp, #16]
  WrOff = pRing->WrOff;
     db4:	9b01      	ldr	r3, [sp, #4]
     db6:	68db      	ldr	r3, [r3, #12]
     db8:	9303      	str	r3, [sp, #12]
  if (RdOff <= WrOff) {
     dba:	9a04      	ldr	r2, [sp, #16]
     dbc:	9b03      	ldr	r3, [sp, #12]
     dbe:	429a      	cmp	r2, r3
     dc0:	d808      	bhi.n	dd4 <_GetAvailWriteSpace+0x2a>
    r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
     dc2:	9b01      	ldr	r3, [sp, #4]
     dc4:	689a      	ldr	r2, [r3, #8]
     dc6:	9b03      	ldr	r3, [sp, #12]
     dc8:	1ad2      	subs	r2, r2, r3
     dca:	9b04      	ldr	r3, [sp, #16]
     dcc:	4413      	add	r3, r2
     dce:	3b01      	subs	r3, #1
     dd0:	9305      	str	r3, [sp, #20]
     dd2:	e004      	b.n	dde <_GetAvailWriteSpace+0x34>
  } else {
    r = RdOff - WrOff - 1u;
     dd4:	9a04      	ldr	r2, [sp, #16]
     dd6:	9b03      	ldr	r3, [sp, #12]
     dd8:	1ad3      	subs	r3, r2, r3
     dda:	3b01      	subs	r3, #1
     ddc:	9305      	str	r3, [sp, #20]
  }
  return r;
     dde:	9b05      	ldr	r3, [sp, #20]
}
     de0:	4618      	mov	r0, r3
     de2:	b006      	add	sp, #24
     de4:	4770      	bx	lr
	...

00000de8 <SEGGER_RTT_WriteNoLock>:
*    (1) Data is stored according to buffer flags.
*    (2) For performance reasons this function does not call Init()
*        and may only be called after RTT has been initialized.
*        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
*/
unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
     de8:	b500      	push	{lr}
     dea:	b089      	sub	sp, #36	; 0x24
     dec:	9003      	str	r0, [sp, #12]
     dee:	9102      	str	r1, [sp, #8]
     df0:	9201      	str	r2, [sp, #4]
  const char*           pData;
  SEGGER_RTT_BUFFER_UP* pRing;
  //
  // Get "to-host" ring buffer.
  //
  pData = (const char *)pBuffer;
     df2:	9b02      	ldr	r3, [sp, #8]
     df4:	9306      	str	r3, [sp, #24]
  pRing = (SEGGER_RTT_BUFFER_UP*)((uintptr_t)&_SEGGER_RTT.aUp[BufferIndex] + SEGGER_RTT_UNCACHED_OFF);  // Access uncached to make sure we see changes made by the J-Link side and all of our changes go into HW directly
     df6:	9b03      	ldr	r3, [sp, #12]
     df8:	1c5a      	adds	r2, r3, #1
     dfa:	4613      	mov	r3, r2
     dfc:	005b      	lsls	r3, r3, #1
     dfe:	4413      	add	r3, r2
     e00:	00db      	lsls	r3, r3, #3
     e02:	4a20      	ldr	r2, [pc, #128]	; (e84 <SEGGER_RTT_WriteNoLock+0x9c>)
     e04:	4413      	add	r3, r2
     e06:	9305      	str	r3, [sp, #20]
  //
  // How we output depends upon the mode...
  //
  switch (pRing->Flags) {
     e08:	9b05      	ldr	r3, [sp, #20]
     e0a:	695b      	ldr	r3, [r3, #20]
     e0c:	2b02      	cmp	r3, #2
     e0e:	d029      	beq.n	e64 <SEGGER_RTT_WriteNoLock+0x7c>
     e10:	2b02      	cmp	r3, #2
     e12:	d82e      	bhi.n	e72 <SEGGER_RTT_WriteNoLock+0x8a>
     e14:	2b00      	cmp	r3, #0
     e16:	d002      	beq.n	e1e <SEGGER_RTT_WriteNoLock+0x36>
     e18:	2b01      	cmp	r3, #1
     e1a:	d013      	beq.n	e44 <SEGGER_RTT_WriteNoLock+0x5c>
     e1c:	e029      	b.n	e72 <SEGGER_RTT_WriteNoLock+0x8a>
  case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
    //
    // If we are in skip mode and there is no space for the whole
    // of this output, don't bother.
    //
    Avail = _GetAvailWriteSpace(pRing);
     e1e:	9805      	ldr	r0, [sp, #20]
     e20:	f7ff ffc3 	bl	daa <_GetAvailWriteSpace>
     e24:	9004      	str	r0, [sp, #16]
    if (Avail < NumBytes) {
     e26:	9a04      	ldr	r2, [sp, #16]
     e28:	9b01      	ldr	r3, [sp, #4]
     e2a:	429a      	cmp	r2, r3
     e2c:	d202      	bcs.n	e34 <SEGGER_RTT_WriteNoLock+0x4c>
      Status = 0u;
     e2e:	2300      	movs	r3, #0
     e30:	9307      	str	r3, [sp, #28]
    } else {
      Status = NumBytes;
      _WriteNoCheck(pRing, pData, NumBytes);
    }
    break;
     e32:	e021      	b.n	e78 <SEGGER_RTT_WriteNoLock+0x90>
      Status = NumBytes;
     e34:	9b01      	ldr	r3, [sp, #4]
     e36:	9307      	str	r3, [sp, #28]
      _WriteNoCheck(pRing, pData, NumBytes);
     e38:	9a01      	ldr	r2, [sp, #4]
     e3a:	9906      	ldr	r1, [sp, #24]
     e3c:	9805      	ldr	r0, [sp, #20]
     e3e:	f7ff ff6d 	bl	d1c <_WriteNoCheck>
    break;
     e42:	e019      	b.n	e78 <SEGGER_RTT_WriteNoLock+0x90>
  case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
    //
    // If we are in trim mode, trim to what we can output without blocking.
    //
    Avail = _GetAvailWriteSpace(pRing);
     e44:	9805      	ldr	r0, [sp, #20]
     e46:	f7ff ffb0 	bl	daa <_GetAvailWriteSpace>
     e4a:	9004      	str	r0, [sp, #16]
    Status = Avail < NumBytes ? Avail : NumBytes;
     e4c:	9a01      	ldr	r2, [sp, #4]
     e4e:	9b04      	ldr	r3, [sp, #16]
     e50:	4293      	cmp	r3, r2
     e52:	bf28      	it	cs
     e54:	4613      	movcs	r3, r2
     e56:	9307      	str	r3, [sp, #28]
    _WriteNoCheck(pRing, pData, Status);
     e58:	9a07      	ldr	r2, [sp, #28]
     e5a:	9906      	ldr	r1, [sp, #24]
     e5c:	9805      	ldr	r0, [sp, #20]
     e5e:	f7ff ff5d 	bl	d1c <_WriteNoCheck>
    break;
     e62:	e009      	b.n	e78 <SEGGER_RTT_WriteNoLock+0x90>
  case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
    //
    // If we are in blocking mode, output everything.
    //
    Status = _WriteBlocking(pRing, pData, NumBytes);
     e64:	9a01      	ldr	r2, [sp, #4]
     e66:	9906      	ldr	r1, [sp, #24]
     e68:	9805      	ldr	r0, [sp, #20]
     e6a:	f7ff fefb 	bl	c64 <_WriteBlocking>
     e6e:	9007      	str	r0, [sp, #28]
    break;
     e70:	e002      	b.n	e78 <SEGGER_RTT_WriteNoLock+0x90>
  default:
    Status = 0u;
     e72:	2300      	movs	r3, #0
     e74:	9307      	str	r3, [sp, #28]
    break;
     e76:	bf00      	nop
  }
  //
  // Finish up.
  //
  return Status;
     e78:	9b07      	ldr	r3, [sp, #28]
}
     e7a:	4618      	mov	r0, r3
     e7c:	b009      	add	sp, #36	; 0x24
     e7e:	f85d fb04 	ldr.w	pc, [sp], #4
     e82:	bf00      	nop
     e84:	1fff954c 	.word	0x1fff954c

00000e88 <SEGGER_RTT_Write>:
*    Number of bytes which have been stored in the "Up"-buffer.
*
*  Notes
*    (1) Data is stored according to buffer flags.
*/
unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
     e88:	b500      	push	{lr}
     e8a:	b089      	sub	sp, #36	; 0x24
     e8c:	9003      	str	r0, [sp, #12]
     e8e:	9102      	str	r1, [sp, #8]
     e90:	9201      	str	r2, [sp, #4]
  unsigned Status;

  INIT();
     e92:	4b0f      	ldr	r3, [pc, #60]	; (ed0 <SEGGER_RTT_Write+0x48>)
     e94:	9307      	str	r3, [sp, #28]
     e96:	9b07      	ldr	r3, [sp, #28]
     e98:	781b      	ldrb	r3, [r3, #0]
     e9a:	b2db      	uxtb	r3, r3
     e9c:	2b53      	cmp	r3, #83	; 0x53
     e9e:	d001      	beq.n	ea4 <SEGGER_RTT_Write+0x1c>
     ea0:	f7ff fe86 	bl	bb0 <_DoInit>
  SEGGER_RTT_LOCK();
     ea4:	f3ef 8311 	mrs	r3, BASEPRI
     ea8:	f04f 0120 	mov.w	r1, #32
     eac:	f381 8811 	msr	BASEPRI, r1
     eb0:	9306      	str	r3, [sp, #24]
  Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);  // Call the non-locking write function
     eb2:	9a01      	ldr	r2, [sp, #4]
     eb4:	9902      	ldr	r1, [sp, #8]
     eb6:	9803      	ldr	r0, [sp, #12]
     eb8:	f7ff ff96 	bl	de8 <SEGGER_RTT_WriteNoLock>
     ebc:	9005      	str	r0, [sp, #20]
  SEGGER_RTT_UNLOCK();
     ebe:	9b06      	ldr	r3, [sp, #24]
     ec0:	f383 8811 	msr	BASEPRI, r3
  return Status;
     ec4:	9b05      	ldr	r3, [sp, #20]
}
     ec6:	4618      	mov	r0, r3
     ec8:	b009      	add	sp, #36	; 0x24
     eca:	f85d fb04 	ldr.w	pc, [sp], #4
     ece:	bf00      	nop
     ed0:	1fff954c 	.word	0x1fff954c

00000ed4 <SEGGER_RTT_Init>:
*  Function description
*    Initializes the RTT Control Block.
*    Should be used in RAM targets, at start of the application.
*
*/
void SEGGER_RTT_Init (void) {
     ed4:	b508      	push	{r3, lr}
  _DoInit();
     ed6:	f7ff fe6b 	bl	bb0 <_DoInit>
}
     eda:	bf00      	nop
     edc:	bd08      	pop	{r3, pc}

00000ede <_StoreChar>:
*/
/*********************************************************************
*
*       _StoreChar
*/
static void _StoreChar(SEGGER_RTT_PRINTF_DESC * p, char c) {
     ede:	b500      	push	{lr}
     ee0:	b085      	sub	sp, #20
     ee2:	9001      	str	r0, [sp, #4]
     ee4:	460b      	mov	r3, r1
     ee6:	f88d 3003 	strb.w	r3, [sp, #3]
  unsigned Cnt;

  Cnt = p->Cnt;
     eea:	9b01      	ldr	r3, [sp, #4]
     eec:	689b      	ldr	r3, [r3, #8]
     eee:	9303      	str	r3, [sp, #12]
  if ((Cnt + 1u) <= p->BufferSize) {
     ef0:	9b03      	ldr	r3, [sp, #12]
     ef2:	1c5a      	adds	r2, r3, #1
     ef4:	9b01      	ldr	r3, [sp, #4]
     ef6:	685b      	ldr	r3, [r3, #4]
     ef8:	429a      	cmp	r2, r3
     efa:	d80f      	bhi.n	f1c <__BSS_SRAM_SIZE+0x3c>
    *(p->pBuffer + Cnt) = c;
     efc:	9b01      	ldr	r3, [sp, #4]
     efe:	681a      	ldr	r2, [r3, #0]
     f00:	9b03      	ldr	r3, [sp, #12]
     f02:	4413      	add	r3, r2
     f04:	f89d 2003 	ldrb.w	r2, [sp, #3]
     f08:	701a      	strb	r2, [r3, #0]
    p->Cnt = Cnt + 1u;
     f0a:	9b03      	ldr	r3, [sp, #12]
     f0c:	1c5a      	adds	r2, r3, #1
     f0e:	9b01      	ldr	r3, [sp, #4]
     f10:	609a      	str	r2, [r3, #8]
    p->ReturnValue++;
     f12:	9b01      	ldr	r3, [sp, #4]
     f14:	68db      	ldr	r3, [r3, #12]
     f16:	1c5a      	adds	r2, r3, #1
     f18:	9b01      	ldr	r3, [sp, #4]
     f1a:	60da      	str	r2, [r3, #12]
  }
  //
  // Write part of string, when the buffer is full
  //
  if (p->Cnt == p->BufferSize) {
     f1c:	9b01      	ldr	r3, [sp, #4]
     f1e:	689a      	ldr	r2, [r3, #8]
     f20:	9b01      	ldr	r3, [sp, #4]
     f22:	685b      	ldr	r3, [r3, #4]
     f24:	429a      	cmp	r2, r3
     f26:	d115      	bne.n	f54 <__BSS_SRAM_SIZE+0x74>
    if (SEGGER_RTT_Write(p->RTTBufferIndex, p->pBuffer, p->Cnt) != p->Cnt) {
     f28:	9b01      	ldr	r3, [sp, #4]
     f2a:	6918      	ldr	r0, [r3, #16]
     f2c:	9b01      	ldr	r3, [sp, #4]
     f2e:	6819      	ldr	r1, [r3, #0]
     f30:	9b01      	ldr	r3, [sp, #4]
     f32:	689b      	ldr	r3, [r3, #8]
     f34:	461a      	mov	r2, r3
     f36:	f7ff ffa7 	bl	e88 <SEGGER_RTT_Write>
     f3a:	4602      	mov	r2, r0
     f3c:	9b01      	ldr	r3, [sp, #4]
     f3e:	689b      	ldr	r3, [r3, #8]
     f40:	429a      	cmp	r2, r3
     f42:	d004      	beq.n	f4e <__BSS_SRAM_SIZE+0x6e>
      p->ReturnValue = -1;
     f44:	9b01      	ldr	r3, [sp, #4]
     f46:	f04f 32ff 	mov.w	r2, #4294967295
     f4a:	60da      	str	r2, [r3, #12]
    } else {
      p->Cnt = 0u;
    }
  }
}
     f4c:	e002      	b.n	f54 <__BSS_SRAM_SIZE+0x74>
      p->Cnt = 0u;
     f4e:	9b01      	ldr	r3, [sp, #4]
     f50:	2200      	movs	r2, #0
     f52:	609a      	str	r2, [r3, #8]
}
     f54:	bf00      	nop
     f56:	b005      	add	sp, #20
     f58:	f85d fb04 	ldr.w	pc, [sp], #4

00000f5c <_PrintUnsigned>:

/*********************************************************************
*
*       _PrintUnsigned
*/
static void _PrintUnsigned(SEGGER_RTT_PRINTF_DESC * pBufferDesc, unsigned v, unsigned Base, unsigned NumDigits, unsigned FieldWidth, unsigned FormatFlags) {
     f5c:	b500      	push	{lr}
     f5e:	b08b      	sub	sp, #44	; 0x2c
     f60:	9003      	str	r0, [sp, #12]
     f62:	9102      	str	r1, [sp, #8]
     f64:	9201      	str	r2, [sp, #4]
     f66:	9300      	str	r3, [sp, #0]
  unsigned Digit;
  unsigned Number;
  unsigned Width;
  char c;

  Number = v;
     f68:	9b02      	ldr	r3, [sp, #8]
     f6a:	9308      	str	r3, [sp, #32]
  Digit = 1u;
     f6c:	2301      	movs	r3, #1
     f6e:	9309      	str	r3, [sp, #36]	; 0x24
  //
  // Get actual field width
  //
  Width = 1u;
     f70:	2301      	movs	r3, #1
     f72:	9307      	str	r3, [sp, #28]
  while (Number >= Base) {
     f74:	e007      	b.n	f86 <_PrintUnsigned+0x2a>
    Number = (Number / Base);
     f76:	9a08      	ldr	r2, [sp, #32]
     f78:	9b01      	ldr	r3, [sp, #4]
     f7a:	fbb2 f3f3 	udiv	r3, r2, r3
     f7e:	9308      	str	r3, [sp, #32]
    Width++;
     f80:	9b07      	ldr	r3, [sp, #28]
     f82:	3301      	adds	r3, #1
     f84:	9307      	str	r3, [sp, #28]
  while (Number >= Base) {
     f86:	9a08      	ldr	r2, [sp, #32]
     f88:	9b01      	ldr	r3, [sp, #4]
     f8a:	429a      	cmp	r2, r3
     f8c:	d2f3      	bcs.n	f76 <_PrintUnsigned+0x1a>
  }
  if (NumDigits > Width) {
     f8e:	9a00      	ldr	r2, [sp, #0]
     f90:	9b07      	ldr	r3, [sp, #28]
     f92:	429a      	cmp	r2, r3
     f94:	d901      	bls.n	f9a <_PrintUnsigned+0x3e>
    Width = NumDigits;
     f96:	9b00      	ldr	r3, [sp, #0]
     f98:	9307      	str	r3, [sp, #28]
  }
  //
  // Print leading chars if necessary
  //
  if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) {
     f9a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
     f9c:	f003 0301 	and.w	r3, r3, #1
     fa0:	2b00      	cmp	r3, #0
     fa2:	d128      	bne.n	ff6 <_PrintUnsigned+0x9a>
    if (FieldWidth != 0u) {
     fa4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
     fa6:	2b00      	cmp	r3, #0
     fa8:	d025      	beq.n	ff6 <_PrintUnsigned+0x9a>
      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && (NumDigits == 0u)) {
     faa:	9b0d      	ldr	r3, [sp, #52]	; 0x34
     fac:	f003 0302 	and.w	r3, r3, #2
     fb0:	2b00      	cmp	r3, #0
     fb2:	d006      	beq.n	fc2 <_PrintUnsigned+0x66>
     fb4:	9b00      	ldr	r3, [sp, #0]
     fb6:	2b00      	cmp	r3, #0
     fb8:	d103      	bne.n	fc2 <_PrintUnsigned+0x66>
        c = '0';
     fba:	2330      	movs	r3, #48	; 0x30
     fbc:	f88d 301b 	strb.w	r3, [sp, #27]
     fc0:	e002      	b.n	fc8 <_PrintUnsigned+0x6c>
      } else {
        c = ' ';
     fc2:	2320      	movs	r3, #32
     fc4:	f88d 301b 	strb.w	r3, [sp, #27]
      }
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
     fc8:	e00c      	b.n	fe4 <_PrintUnsigned+0x88>
        FieldWidth--;
     fca:	9b0c      	ldr	r3, [sp, #48]	; 0x30
     fcc:	3b01      	subs	r3, #1
     fce:	930c      	str	r3, [sp, #48]	; 0x30
        _StoreChar(pBufferDesc, c);
     fd0:	f89d 301b 	ldrb.w	r3, [sp, #27]
     fd4:	4619      	mov	r1, r3
     fd6:	9803      	ldr	r0, [sp, #12]
     fd8:	f7ff ff81 	bl	ede <_StoreChar>
        if (pBufferDesc->ReturnValue < 0) {
     fdc:	9b03      	ldr	r3, [sp, #12]
     fde:	68db      	ldr	r3, [r3, #12]
     fe0:	2b00      	cmp	r3, #0
     fe2:	db07      	blt.n	ff4 <_PrintUnsigned+0x98>
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
     fe4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
     fe6:	2b00      	cmp	r3, #0
     fe8:	d005      	beq.n	ff6 <_PrintUnsigned+0x9a>
     fea:	9a07      	ldr	r2, [sp, #28]
     fec:	9b0c      	ldr	r3, [sp, #48]	; 0x30
     fee:	429a      	cmp	r2, r3
     ff0:	d3eb      	bcc.n	fca <_PrintUnsigned+0x6e>
     ff2:	e000      	b.n	ff6 <_PrintUnsigned+0x9a>
          break;
     ff4:	bf00      	nop
        }
      }
    }
  }
  if (pBufferDesc->ReturnValue >= 0) {
     ff6:	9b03      	ldr	r3, [sp, #12]
     ff8:	68db      	ldr	r3, [r3, #12]
     ffa:	2b00      	cmp	r3, #0
     ffc:	db55      	blt.n	10aa <_PrintUnsigned+0x14e>
    // Compute Digit.
    // Loop until Digit has the value of the highest digit required.
    // Example: If the output is 345 (Base 10), loop 2 times until Digit is 100.
    //
    while (1) {
      if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
     ffe:	9b00      	ldr	r3, [sp, #0]
    1000:	2b01      	cmp	r3, #1
    1002:	d903      	bls.n	100c <_PrintUnsigned+0xb0>
        NumDigits--;
    1004:	9b00      	ldr	r3, [sp, #0]
    1006:	3b01      	subs	r3, #1
    1008:	9300      	str	r3, [sp, #0]
    100a:	e009      	b.n	1020 <_PrintUnsigned+0xc4>
      } else {
        Div = v / Digit;
    100c:	9a02      	ldr	r2, [sp, #8]
    100e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1010:	fbb2 f3f3 	udiv	r3, r2, r3
    1014:	9305      	str	r3, [sp, #20]
        if (Div < Base) {        // Is our divider big enough to extract the highest digit from value? => Done
    1016:	9a05      	ldr	r2, [sp, #20]
    1018:	9b01      	ldr	r3, [sp, #4]
    101a:	429a      	cmp	r2, r3
    101c:	d200      	bcs.n	1020 <_PrintUnsigned+0xc4>
          break;
    101e:	e005      	b.n	102c <_PrintUnsigned+0xd0>
        }
      }
      Digit *= Base;
    1020:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1022:	9a01      	ldr	r2, [sp, #4]
    1024:	fb02 f303 	mul.w	r3, r2, r3
    1028:	9309      	str	r3, [sp, #36]	; 0x24
      if (NumDigits > 1u) {       // User specified a min number of digits to print? => Make sure we loop at least that often, before checking anything else (> 1 check avoids problems with NumDigits being signed / unsigned)
    102a:	e7e8      	b.n	ffe <_PrintUnsigned+0xa2>
    }
    //
    // Output digits
    //
    do {
      Div = v / Digit;
    102c:	9a02      	ldr	r2, [sp, #8]
    102e:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1030:	fbb2 f3f3 	udiv	r3, r2, r3
    1034:	9305      	str	r3, [sp, #20]
      v -= Div * Digit;
    1036:	9b05      	ldr	r3, [sp, #20]
    1038:	9a09      	ldr	r2, [sp, #36]	; 0x24
    103a:	fb02 f303 	mul.w	r3, r2, r3
    103e:	9a02      	ldr	r2, [sp, #8]
    1040:	1ad3      	subs	r3, r2, r3
    1042:	9302      	str	r3, [sp, #8]
      _StoreChar(pBufferDesc, _aV2C[Div]);
    1044:	4a1b      	ldr	r2, [pc, #108]	; (10b4 <_PrintUnsigned+0x158>)
    1046:	9b05      	ldr	r3, [sp, #20]
    1048:	4413      	add	r3, r2
    104a:	781b      	ldrb	r3, [r3, #0]
    104c:	4619      	mov	r1, r3
    104e:	9803      	ldr	r0, [sp, #12]
    1050:	f7ff ff45 	bl	ede <_StoreChar>
      if (pBufferDesc->ReturnValue < 0) {
    1054:	9b03      	ldr	r3, [sp, #12]
    1056:	68db      	ldr	r3, [r3, #12]
    1058:	2b00      	cmp	r3, #0
    105a:	db08      	blt.n	106e <_PrintUnsigned+0x112>
        break;
      }
      Digit /= Base;
    105c:	9a09      	ldr	r2, [sp, #36]	; 0x24
    105e:	9b01      	ldr	r3, [sp, #4]
    1060:	fbb2 f3f3 	udiv	r3, r2, r3
    1064:	9309      	str	r3, [sp, #36]	; 0x24
    } while (Digit);
    1066:	9b09      	ldr	r3, [sp, #36]	; 0x24
    1068:	2b00      	cmp	r3, #0
    106a:	d1df      	bne.n	102c <_PrintUnsigned+0xd0>
    106c:	e000      	b.n	1070 <_PrintUnsigned+0x114>
        break;
    106e:	bf00      	nop
    //
    // Print trailing spaces if necessary
    //
    if ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == FORMAT_FLAG_LEFT_JUSTIFY) {
    1070:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    1072:	f003 0301 	and.w	r3, r3, #1
    1076:	2b00      	cmp	r3, #0
    1078:	d017      	beq.n	10aa <_PrintUnsigned+0x14e>
      if (FieldWidth != 0u) {
    107a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    107c:	2b00      	cmp	r3, #0
    107e:	d014      	beq.n	10aa <_PrintUnsigned+0x14e>
        while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    1080:	e00a      	b.n	1098 <_PrintUnsigned+0x13c>
          FieldWidth--;
    1082:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    1084:	3b01      	subs	r3, #1
    1086:	930c      	str	r3, [sp, #48]	; 0x30
          _StoreChar(pBufferDesc, ' ');
    1088:	2120      	movs	r1, #32
    108a:	9803      	ldr	r0, [sp, #12]
    108c:	f7ff ff27 	bl	ede <_StoreChar>
          if (pBufferDesc->ReturnValue < 0) {
    1090:	9b03      	ldr	r3, [sp, #12]
    1092:	68db      	ldr	r3, [r3, #12]
    1094:	2b00      	cmp	r3, #0
    1096:	db07      	blt.n	10a8 <_PrintUnsigned+0x14c>
        while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    1098:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    109a:	2b00      	cmp	r3, #0
    109c:	d005      	beq.n	10aa <_PrintUnsigned+0x14e>
    109e:	9a07      	ldr	r2, [sp, #28]
    10a0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    10a2:	429a      	cmp	r2, r3
    10a4:	d3ed      	bcc.n	1082 <_PrintUnsigned+0x126>
          }
        }
      }
    }
  }
}
    10a6:	e000      	b.n	10aa <_PrintUnsigned+0x14e>
            break;
    10a8:	bf00      	nop
}
    10aa:	bf00      	nop
    10ac:	b00b      	add	sp, #44	; 0x2c
    10ae:	f85d fb04 	ldr.w	pc, [sp], #4
    10b2:	bf00      	nop
    10b4:	00016be8 	.word	0x00016be8

000010b8 <_PrintInt>:

/*********************************************************************
*
*       _PrintInt
*/
static void _PrintInt(SEGGER_RTT_PRINTF_DESC * pBufferDesc, int v, unsigned Base, unsigned NumDigits, unsigned FieldWidth, unsigned FormatFlags) {
    10b8:	b500      	push	{lr}
    10ba:	b089      	sub	sp, #36	; 0x24
    10bc:	9005      	str	r0, [sp, #20]
    10be:	9104      	str	r1, [sp, #16]
    10c0:	9203      	str	r2, [sp, #12]
    10c2:	9302      	str	r3, [sp, #8]
  unsigned Width;
  int Number;

  Number = (v < 0) ? -v : v;
    10c4:	9b04      	ldr	r3, [sp, #16]
    10c6:	2b00      	cmp	r3, #0
    10c8:	bfb8      	it	lt
    10ca:	425b      	neglt	r3, r3
    10cc:	9306      	str	r3, [sp, #24]

  //
  // Get actual field width
  //
  Width = 1u;
    10ce:	2301      	movs	r3, #1
    10d0:	9307      	str	r3, [sp, #28]
  while (Number >= (int)Base) {
    10d2:	e007      	b.n	10e4 <_PrintInt+0x2c>
    Number = (Number / (int)Base);
    10d4:	9b03      	ldr	r3, [sp, #12]
    10d6:	9a06      	ldr	r2, [sp, #24]
    10d8:	fb92 f3f3 	sdiv	r3, r2, r3
    10dc:	9306      	str	r3, [sp, #24]
    Width++;
    10de:	9b07      	ldr	r3, [sp, #28]
    10e0:	3301      	adds	r3, #1
    10e2:	9307      	str	r3, [sp, #28]
  while (Number >= (int)Base) {
    10e4:	9b03      	ldr	r3, [sp, #12]
    10e6:	9a06      	ldr	r2, [sp, #24]
    10e8:	429a      	cmp	r2, r3
    10ea:	daf3      	bge.n	10d4 <_PrintInt+0x1c>
  }
  if (NumDigits > Width) {
    10ec:	9a02      	ldr	r2, [sp, #8]
    10ee:	9b07      	ldr	r3, [sp, #28]
    10f0:	429a      	cmp	r2, r3
    10f2:	d901      	bls.n	10f8 <_PrintInt+0x40>
    Width = NumDigits;
    10f4:	9b02      	ldr	r3, [sp, #8]
    10f6:	9307      	str	r3, [sp, #28]
  }
  if ((FieldWidth > 0u) && ((v < 0) || ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN))) {
    10f8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    10fa:	2b00      	cmp	r3, #0
    10fc:	d00a      	beq.n	1114 <_PrintInt+0x5c>
    10fe:	9b04      	ldr	r3, [sp, #16]
    1100:	2b00      	cmp	r3, #0
    1102:	db04      	blt.n	110e <_PrintInt+0x56>
    1104:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1106:	f003 0304 	and.w	r3, r3, #4
    110a:	2b00      	cmp	r3, #0
    110c:	d002      	beq.n	1114 <_PrintInt+0x5c>
    FieldWidth--;
    110e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1110:	3b01      	subs	r3, #1
    1112:	930a      	str	r3, [sp, #40]	; 0x28
  }

  //
  // Print leading spaces if necessary
  //
  if ((((FormatFlags & FORMAT_FLAG_PAD_ZERO) == 0u) || (NumDigits != 0u)) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u)) {
    1114:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1116:	f003 0302 	and.w	r3, r3, #2
    111a:	2b00      	cmp	r3, #0
    111c:	d002      	beq.n	1124 <_PrintInt+0x6c>
    111e:	9b02      	ldr	r3, [sp, #8]
    1120:	2b00      	cmp	r3, #0
    1122:	d01c      	beq.n	115e <_PrintInt+0xa6>
    1124:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1126:	f003 0301 	and.w	r3, r3, #1
    112a:	2b00      	cmp	r3, #0
    112c:	d117      	bne.n	115e <_PrintInt+0xa6>
    if (FieldWidth != 0u) {
    112e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1130:	2b00      	cmp	r3, #0
    1132:	d014      	beq.n	115e <_PrintInt+0xa6>
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    1134:	e00a      	b.n	114c <_PrintInt+0x94>
        FieldWidth--;
    1136:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1138:	3b01      	subs	r3, #1
    113a:	930a      	str	r3, [sp, #40]	; 0x28
        _StoreChar(pBufferDesc, ' ');
    113c:	2120      	movs	r1, #32
    113e:	9805      	ldr	r0, [sp, #20]
    1140:	f7ff fecd 	bl	ede <_StoreChar>
        if (pBufferDesc->ReturnValue < 0) {
    1144:	9b05      	ldr	r3, [sp, #20]
    1146:	68db      	ldr	r3, [r3, #12]
    1148:	2b00      	cmp	r3, #0
    114a:	db07      	blt.n	115c <_PrintInt+0xa4>
      while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    114c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    114e:	2b00      	cmp	r3, #0
    1150:	d005      	beq.n	115e <_PrintInt+0xa6>
    1152:	9a07      	ldr	r2, [sp, #28]
    1154:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    1156:	429a      	cmp	r2, r3
    1158:	d3ed      	bcc.n	1136 <_PrintInt+0x7e>
    115a:	e000      	b.n	115e <_PrintInt+0xa6>
          break;
    115c:	bf00      	nop
    }
  }
  //
  // Print sign if necessary
  //
  if (pBufferDesc->ReturnValue >= 0) {
    115e:	9b05      	ldr	r3, [sp, #20]
    1160:	68db      	ldr	r3, [r3, #12]
    1162:	2b00      	cmp	r3, #0
    1164:	db4a      	blt.n	11fc <_PrintInt+0x144>
    if (v < 0) {
    1166:	9b04      	ldr	r3, [sp, #16]
    1168:	2b00      	cmp	r3, #0
    116a:	da07      	bge.n	117c <_PrintInt+0xc4>
      v = -v;
    116c:	9b04      	ldr	r3, [sp, #16]
    116e:	425b      	negs	r3, r3
    1170:	9304      	str	r3, [sp, #16]
      _StoreChar(pBufferDesc, '-');
    1172:	212d      	movs	r1, #45	; 0x2d
    1174:	9805      	ldr	r0, [sp, #20]
    1176:	f7ff feb2 	bl	ede <_StoreChar>
    117a:	e008      	b.n	118e <_PrintInt+0xd6>
    } else if ((FormatFlags & FORMAT_FLAG_PRINT_SIGN) == FORMAT_FLAG_PRINT_SIGN) {
    117c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    117e:	f003 0304 	and.w	r3, r3, #4
    1182:	2b00      	cmp	r3, #0
    1184:	d003      	beq.n	118e <_PrintInt+0xd6>
      _StoreChar(pBufferDesc, '+');
    1186:	212b      	movs	r1, #43	; 0x2b
    1188:	9805      	ldr	r0, [sp, #20]
    118a:	f7ff fea8 	bl	ede <_StoreChar>
    } else {

    }
    if (pBufferDesc->ReturnValue >= 0) {
    118e:	9b05      	ldr	r3, [sp, #20]
    1190:	68db      	ldr	r3, [r3, #12]
    1192:	2b00      	cmp	r3, #0
    1194:	db32      	blt.n	11fc <_PrintInt+0x144>
      //
      // Print leading zeros if necessary
      //
      if (((FormatFlags & FORMAT_FLAG_PAD_ZERO) == FORMAT_FLAG_PAD_ZERO) && ((FormatFlags & FORMAT_FLAG_LEFT_JUSTIFY) == 0u) && (NumDigits == 0u)) {
    1196:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    1198:	f003 0302 	and.w	r3, r3, #2
    119c:	2b00      	cmp	r3, #0
    119e:	d01f      	beq.n	11e0 <_PrintInt+0x128>
    11a0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    11a2:	f003 0301 	and.w	r3, r3, #1
    11a6:	2b00      	cmp	r3, #0
    11a8:	d11a      	bne.n	11e0 <_PrintInt+0x128>
    11aa:	9b02      	ldr	r3, [sp, #8]
    11ac:	2b00      	cmp	r3, #0
    11ae:	d117      	bne.n	11e0 <_PrintInt+0x128>
        if (FieldWidth != 0u) {
    11b0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    11b2:	2b00      	cmp	r3, #0
    11b4:	d014      	beq.n	11e0 <_PrintInt+0x128>
          while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    11b6:	e00a      	b.n	11ce <_PrintInt+0x116>
            FieldWidth--;
    11b8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    11ba:	3b01      	subs	r3, #1
    11bc:	930a      	str	r3, [sp, #40]	; 0x28
            _StoreChar(pBufferDesc, '0');
    11be:	2130      	movs	r1, #48	; 0x30
    11c0:	9805      	ldr	r0, [sp, #20]
    11c2:	f7ff fe8c 	bl	ede <_StoreChar>
            if (pBufferDesc->ReturnValue < 0) {
    11c6:	9b05      	ldr	r3, [sp, #20]
    11c8:	68db      	ldr	r3, [r3, #12]
    11ca:	2b00      	cmp	r3, #0
    11cc:	db07      	blt.n	11de <_PrintInt+0x126>
          while ((FieldWidth != 0u) && (Width < FieldWidth)) {
    11ce:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    11d0:	2b00      	cmp	r3, #0
    11d2:	d005      	beq.n	11e0 <_PrintInt+0x128>
    11d4:	9a07      	ldr	r2, [sp, #28]
    11d6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    11d8:	429a      	cmp	r2, r3
    11da:	d3ed      	bcc.n	11b8 <_PrintInt+0x100>
    11dc:	e000      	b.n	11e0 <_PrintInt+0x128>
              break;
    11de:	bf00      	nop
            }
          }
        }
      }
      if (pBufferDesc->ReturnValue >= 0) {
    11e0:	9b05      	ldr	r3, [sp, #20]
    11e2:	68db      	ldr	r3, [r3, #12]
    11e4:	2b00      	cmp	r3, #0
    11e6:	db09      	blt.n	11fc <_PrintInt+0x144>
        //
        // Print number without sign
        //
        _PrintUnsigned(pBufferDesc, (unsigned)v, Base, NumDigits, FieldWidth, FormatFlags);
    11e8:	9904      	ldr	r1, [sp, #16]
    11ea:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    11ec:	9301      	str	r3, [sp, #4]
    11ee:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    11f0:	9300      	str	r3, [sp, #0]
    11f2:	9b02      	ldr	r3, [sp, #8]
    11f4:	9a03      	ldr	r2, [sp, #12]
    11f6:	9805      	ldr	r0, [sp, #20]
    11f8:	f7ff feb0 	bl	f5c <_PrintUnsigned>
      }
    }
  }
}
    11fc:	bf00      	nop
    11fe:	b009      	add	sp, #36	; 0x24
    1200:	f85d fb04 	ldr.w	pc, [sp], #4

00001204 <SEGGER_RTT_vprintf>:
*
*  Return values
*    >= 0:  Number of bytes which have been stored in the "Up"-buffer.
*     < 0:  Error
*/
int SEGGER_RTT_vprintf(unsigned BufferIndex, const char * sFormat, va_list * pParamList) {
    1204:	b500      	push	{lr}
    1206:	b0a3      	sub	sp, #140	; 0x8c
    1208:	9005      	str	r0, [sp, #20]
    120a:	9104      	str	r1, [sp, #16]
    120c:	9203      	str	r2, [sp, #12]
  unsigned NumDigits;
  unsigned FormatFlags;
  unsigned FieldWidth;
  char acBuffer[SEGGER_RTT_PRINTF_BUFFER_SIZE];

  BufferDesc.pBuffer        = acBuffer;
    120e:	ab06      	add	r3, sp, #24
    1210:	9316      	str	r3, [sp, #88]	; 0x58
  BufferDesc.BufferSize     = SEGGER_RTT_PRINTF_BUFFER_SIZE;
    1212:	2340      	movs	r3, #64	; 0x40
    1214:	9317      	str	r3, [sp, #92]	; 0x5c
  BufferDesc.Cnt            = 0u;
    1216:	2300      	movs	r3, #0
    1218:	9318      	str	r3, [sp, #96]	; 0x60
  BufferDesc.RTTBufferIndex = BufferIndex;
    121a:	9b05      	ldr	r3, [sp, #20]
    121c:	931a      	str	r3, [sp, #104]	; 0x68
  BufferDesc.ReturnValue    = 0;
    121e:	2300      	movs	r3, #0
    1220:	9319      	str	r3, [sp, #100]	; 0x64

  do {
    c = *sFormat;
    1222:	9b04      	ldr	r3, [sp, #16]
    1224:	781b      	ldrb	r3, [r3, #0]
    1226:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
    sFormat++;
    122a:	9b04      	ldr	r3, [sp, #16]
    122c:	3301      	adds	r3, #1
    122e:	9304      	str	r3, [sp, #16]
    if (c == 0u) {
    1230:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    1234:	2b00      	cmp	r3, #0
    1236:	f000 819c 	beq.w	1572 <SEGGER_RTT_vprintf+0x36e>
      break;
    }
    if (c == '%') {
    123a:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    123e:	2b25      	cmp	r3, #37	; 0x25
    1240:	f040 818b 	bne.w	155a <SEGGER_RTT_vprintf+0x356>
      //
      // Filter out flags
      //
      FormatFlags = 0u;
    1244:	2300      	movs	r3, #0
    1246:	931e      	str	r3, [sp, #120]	; 0x78
      v = 1;
    1248:	2301      	movs	r3, #1
    124a:	9320      	str	r3, [sp, #128]	; 0x80
      do {
        c = *sFormat;
    124c:	9b04      	ldr	r3, [sp, #16]
    124e:	781b      	ldrb	r3, [r3, #0]
    1250:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
        switch (c) {
    1254:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    1258:	3b23      	subs	r3, #35	; 0x23
    125a:	2b0d      	cmp	r3, #13
    125c:	d83e      	bhi.n	12dc <SEGGER_RTT_vprintf+0xd8>
    125e:	a201      	add	r2, pc, #4	; (adr r2, 1264 <SEGGER_RTT_vprintf+0x60>)
    1260:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    1264:	000012cd 	.word	0x000012cd
    1268:	000012dd 	.word	0x000012dd
    126c:	000012dd 	.word	0x000012dd
    1270:	000012dd 	.word	0x000012dd
    1274:	000012dd 	.word	0x000012dd
    1278:	000012dd 	.word	0x000012dd
    127c:	000012dd 	.word	0x000012dd
    1280:	000012dd 	.word	0x000012dd
    1284:	000012bd 	.word	0x000012bd
    1288:	000012dd 	.word	0x000012dd
    128c:	0000129d 	.word	0x0000129d
    1290:	000012dd 	.word	0x000012dd
    1294:	000012dd 	.word	0x000012dd
    1298:	000012ad 	.word	0x000012ad
        case '-': FormatFlags |= FORMAT_FLAG_LEFT_JUSTIFY; sFormat++; break;
    129c:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    129e:	f043 0301 	orr.w	r3, r3, #1
    12a2:	931e      	str	r3, [sp, #120]	; 0x78
    12a4:	9b04      	ldr	r3, [sp, #16]
    12a6:	3301      	adds	r3, #1
    12a8:	9304      	str	r3, [sp, #16]
    12aa:	e01a      	b.n	12e2 <SEGGER_RTT_vprintf+0xde>
        case '0': FormatFlags |= FORMAT_FLAG_PAD_ZERO;     sFormat++; break;
    12ac:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    12ae:	f043 0302 	orr.w	r3, r3, #2
    12b2:	931e      	str	r3, [sp, #120]	; 0x78
    12b4:	9b04      	ldr	r3, [sp, #16]
    12b6:	3301      	adds	r3, #1
    12b8:	9304      	str	r3, [sp, #16]
    12ba:	e012      	b.n	12e2 <SEGGER_RTT_vprintf+0xde>
        case '+': FormatFlags |= FORMAT_FLAG_PRINT_SIGN;   sFormat++; break;
    12bc:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    12be:	f043 0304 	orr.w	r3, r3, #4
    12c2:	931e      	str	r3, [sp, #120]	; 0x78
    12c4:	9b04      	ldr	r3, [sp, #16]
    12c6:	3301      	adds	r3, #1
    12c8:	9304      	str	r3, [sp, #16]
    12ca:	e00a      	b.n	12e2 <SEGGER_RTT_vprintf+0xde>
        case '#': FormatFlags |= FORMAT_FLAG_ALTERNATE;    sFormat++; break;
    12cc:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    12ce:	f043 0308 	orr.w	r3, r3, #8
    12d2:	931e      	str	r3, [sp, #120]	; 0x78
    12d4:	9b04      	ldr	r3, [sp, #16]
    12d6:	3301      	adds	r3, #1
    12d8:	9304      	str	r3, [sp, #16]
    12da:	e002      	b.n	12e2 <SEGGER_RTT_vprintf+0xde>
        default:  v = 0; break;
    12dc:	2300      	movs	r3, #0
    12de:	9320      	str	r3, [sp, #128]	; 0x80
    12e0:	bf00      	nop
        }
      } while (v);
    12e2:	9b20      	ldr	r3, [sp, #128]	; 0x80
    12e4:	2b00      	cmp	r3, #0
    12e6:	d1b1      	bne.n	124c <SEGGER_RTT_vprintf+0x48>
      //
      // filter out field with
      //
      FieldWidth = 0u;
    12e8:	2300      	movs	r3, #0
    12ea:	931d      	str	r3, [sp, #116]	; 0x74
      do {
        c = *sFormat;
    12ec:	9b04      	ldr	r3, [sp, #16]
    12ee:	781b      	ldrb	r3, [r3, #0]
    12f0:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
        if ((c < '0') || (c > '9')) {
    12f4:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    12f8:	2b2f      	cmp	r3, #47	; 0x2f
    12fa:	d912      	bls.n	1322 <SEGGER_RTT_vprintf+0x11e>
    12fc:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    1300:	2b39      	cmp	r3, #57	; 0x39
    1302:	d80e      	bhi.n	1322 <SEGGER_RTT_vprintf+0x11e>
          break;
        }
        sFormat++;
    1304:	9b04      	ldr	r3, [sp, #16]
    1306:	3301      	adds	r3, #1
    1308:	9304      	str	r3, [sp, #16]
        FieldWidth = (FieldWidth * 10u) + ((unsigned)c - '0');
    130a:	9a1d      	ldr	r2, [sp, #116]	; 0x74
    130c:	4613      	mov	r3, r2
    130e:	009b      	lsls	r3, r3, #2
    1310:	4413      	add	r3, r2
    1312:	005b      	lsls	r3, r3, #1
    1314:	461a      	mov	r2, r3
    1316:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    131a:	4413      	add	r3, r2
    131c:	3b30      	subs	r3, #48	; 0x30
    131e:	931d      	str	r3, [sp, #116]	; 0x74
        c = *sFormat;
    1320:	e7e4      	b.n	12ec <SEGGER_RTT_vprintf+0xe8>
      } while (1);

      //
      // Filter out precision (number of digits to display)
      //
      NumDigits = 0u;
    1322:	2300      	movs	r3, #0
    1324:	931f      	str	r3, [sp, #124]	; 0x7c
      c = *sFormat;
    1326:	9b04      	ldr	r3, [sp, #16]
    1328:	781b      	ldrb	r3, [r3, #0]
    132a:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
      if (c == '.') {
    132e:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    1332:	2b2e      	cmp	r3, #46	; 0x2e
    1334:	d11d      	bne.n	1372 <SEGGER_RTT_vprintf+0x16e>
        sFormat++;
    1336:	9b04      	ldr	r3, [sp, #16]
    1338:	3301      	adds	r3, #1
    133a:	9304      	str	r3, [sp, #16]
        do {
          c = *sFormat;
    133c:	9b04      	ldr	r3, [sp, #16]
    133e:	781b      	ldrb	r3, [r3, #0]
    1340:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
          if ((c < '0') || (c > '9')) {
    1344:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    1348:	2b2f      	cmp	r3, #47	; 0x2f
    134a:	d912      	bls.n	1372 <SEGGER_RTT_vprintf+0x16e>
    134c:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    1350:	2b39      	cmp	r3, #57	; 0x39
    1352:	d80e      	bhi.n	1372 <SEGGER_RTT_vprintf+0x16e>
            break;
          }
          sFormat++;
    1354:	9b04      	ldr	r3, [sp, #16]
    1356:	3301      	adds	r3, #1
    1358:	9304      	str	r3, [sp, #16]
          NumDigits = NumDigits * 10u + ((unsigned)c - '0');
    135a:	9a1f      	ldr	r2, [sp, #124]	; 0x7c
    135c:	4613      	mov	r3, r2
    135e:	009b      	lsls	r3, r3, #2
    1360:	4413      	add	r3, r2
    1362:	005b      	lsls	r3, r3, #1
    1364:	461a      	mov	r2, r3
    1366:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    136a:	4413      	add	r3, r2
    136c:	3b30      	subs	r3, #48	; 0x30
    136e:	931f      	str	r3, [sp, #124]	; 0x7c
          c = *sFormat;
    1370:	e7e4      	b.n	133c <SEGGER_RTT_vprintf+0x138>
        } while (1);
      }
      //
      // Filter out length modifier
      //
      c = *sFormat;
    1372:	9b04      	ldr	r3, [sp, #16]
    1374:	781b      	ldrb	r3, [r3, #0]
    1376:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
      do {
        if ((c == 'l') || (c == 'h')) {
    137a:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    137e:	2b6c      	cmp	r3, #108	; 0x6c
    1380:	d003      	beq.n	138a <SEGGER_RTT_vprintf+0x186>
    1382:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    1386:	2b68      	cmp	r3, #104	; 0x68
    1388:	d107      	bne.n	139a <SEGGER_RTT_vprintf+0x196>
          sFormat++;
    138a:	9b04      	ldr	r3, [sp, #16]
    138c:	3301      	adds	r3, #1
    138e:	9304      	str	r3, [sp, #16]
          c = *sFormat;
    1390:	9b04      	ldr	r3, [sp, #16]
    1392:	781b      	ldrb	r3, [r3, #0]
    1394:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
        if ((c == 'l') || (c == 'h')) {
    1398:	e7ef      	b.n	137a <SEGGER_RTT_vprintf+0x176>
        }
      } while (1);
      //
      // Handle specifiers
      //
      switch (c) {
    139a:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    139e:	2b25      	cmp	r3, #37	; 0x25
    13a0:	f000 80d0 	beq.w	1544 <SEGGER_RTT_vprintf+0x340>
    13a4:	2b25      	cmp	r3, #37	; 0x25
    13a6:	f2c0 80d3 	blt.w	1550 <SEGGER_RTT_vprintf+0x34c>
    13aa:	2b78      	cmp	r3, #120	; 0x78
    13ac:	f300 80d0 	bgt.w	1550 <SEGGER_RTT_vprintf+0x34c>
    13b0:	2b58      	cmp	r3, #88	; 0x58
    13b2:	f2c0 80cd 	blt.w	1550 <SEGGER_RTT_vprintf+0x34c>
    13b6:	3b58      	subs	r3, #88	; 0x58
    13b8:	2b20      	cmp	r3, #32
    13ba:	f200 80c9 	bhi.w	1550 <SEGGER_RTT_vprintf+0x34c>
    13be:	a201      	add	r2, pc, #4	; (adr r2, 13c4 <SEGGER_RTT_vprintf+0x1c0>)
    13c0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    13c4:	000014b5 	.word	0x000014b5
    13c8:	00001551 	.word	0x00001551
    13cc:	00001551 	.word	0x00001551
    13d0:	00001551 	.word	0x00001551
    13d4:	00001551 	.word	0x00001551
    13d8:	00001551 	.word	0x00001551
    13dc:	00001551 	.word	0x00001551
    13e0:	00001551 	.word	0x00001551
    13e4:	00001551 	.word	0x00001551
    13e8:	00001551 	.word	0x00001551
    13ec:	00001551 	.word	0x00001551
    13f0:	00001449 	.word	0x00001449
    13f4:	0000146d 	.word	0x0000146d
    13f8:	00001551 	.word	0x00001551
    13fc:	00001551 	.word	0x00001551
    1400:	00001551 	.word	0x00001551
    1404:	00001551 	.word	0x00001551
    1408:	00001551 	.word	0x00001551
    140c:	00001551 	.word	0x00001551
    1410:	00001551 	.word	0x00001551
    1414:	00001551 	.word	0x00001551
    1418:	00001551 	.word	0x00001551
    141c:	00001551 	.word	0x00001551
    1420:	00001551 	.word	0x00001551
    1424:	00001521 	.word	0x00001521
    1428:	00001551 	.word	0x00001551
    142c:	00001551 	.word	0x00001551
    1430:	000014d9 	.word	0x000014d9
    1434:	00001551 	.word	0x00001551
    1438:	00001491 	.word	0x00001491
    143c:	00001551 	.word	0x00001551
    1440:	00001551 	.word	0x00001551
    1444:	000014b5 	.word	0x000014b5
      case 'c': {
        char c0;
        v = va_arg(*pParamList, int);
    1448:	9b03      	ldr	r3, [sp, #12]
    144a:	681b      	ldr	r3, [r3, #0]
    144c:	1d19      	adds	r1, r3, #4
    144e:	9a03      	ldr	r2, [sp, #12]
    1450:	6011      	str	r1, [r2, #0]
    1452:	681b      	ldr	r3, [r3, #0]
    1454:	9320      	str	r3, [sp, #128]	; 0x80
        c0 = (char)v;
    1456:	9b20      	ldr	r3, [sp, #128]	; 0x80
    1458:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
        _StoreChar(&BufferDesc, c0);
    145c:	f89d 206f 	ldrb.w	r2, [sp, #111]	; 0x6f
    1460:	ab16      	add	r3, sp, #88	; 0x58
    1462:	4611      	mov	r1, r2
    1464:	4618      	mov	r0, r3
    1466:	f7ff fd3a 	bl	ede <_StoreChar>
        break;
    146a:	e072      	b.n	1552 <SEGGER_RTT_vprintf+0x34e>
      }
      case 'd':
        v = va_arg(*pParamList, int);
    146c:	9b03      	ldr	r3, [sp, #12]
    146e:	681b      	ldr	r3, [r3, #0]
    1470:	1d19      	adds	r1, r3, #4
    1472:	9a03      	ldr	r2, [sp, #12]
    1474:	6011      	str	r1, [r2, #0]
    1476:	681b      	ldr	r3, [r3, #0]
    1478:	9320      	str	r3, [sp, #128]	; 0x80
        _PrintInt(&BufferDesc, v, 10u, NumDigits, FieldWidth, FormatFlags);
    147a:	a816      	add	r0, sp, #88	; 0x58
    147c:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    147e:	9301      	str	r3, [sp, #4]
    1480:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    1482:	9300      	str	r3, [sp, #0]
    1484:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    1486:	220a      	movs	r2, #10
    1488:	9920      	ldr	r1, [sp, #128]	; 0x80
    148a:	f7ff fe15 	bl	10b8 <_PrintInt>
        break;
    148e:	e060      	b.n	1552 <SEGGER_RTT_vprintf+0x34e>
      case 'u':
        v = va_arg(*pParamList, int);
    1490:	9b03      	ldr	r3, [sp, #12]
    1492:	681b      	ldr	r3, [r3, #0]
    1494:	1d19      	adds	r1, r3, #4
    1496:	9a03      	ldr	r2, [sp, #12]
    1498:	6011      	str	r1, [r2, #0]
    149a:	681b      	ldr	r3, [r3, #0]
    149c:	9320      	str	r3, [sp, #128]	; 0x80
        _PrintUnsigned(&BufferDesc, (unsigned)v, 10u, NumDigits, FieldWidth, FormatFlags);
    149e:	9920      	ldr	r1, [sp, #128]	; 0x80
    14a0:	a816      	add	r0, sp, #88	; 0x58
    14a2:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    14a4:	9301      	str	r3, [sp, #4]
    14a6:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    14a8:	9300      	str	r3, [sp, #0]
    14aa:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    14ac:	220a      	movs	r2, #10
    14ae:	f7ff fd55 	bl	f5c <_PrintUnsigned>
        break;
    14b2:	e04e      	b.n	1552 <SEGGER_RTT_vprintf+0x34e>
      case 'x':
      case 'X':
        v = va_arg(*pParamList, int);
    14b4:	9b03      	ldr	r3, [sp, #12]
    14b6:	681b      	ldr	r3, [r3, #0]
    14b8:	1d19      	adds	r1, r3, #4
    14ba:	9a03      	ldr	r2, [sp, #12]
    14bc:	6011      	str	r1, [r2, #0]
    14be:	681b      	ldr	r3, [r3, #0]
    14c0:	9320      	str	r3, [sp, #128]	; 0x80
        _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, NumDigits, FieldWidth, FormatFlags);
    14c2:	9920      	ldr	r1, [sp, #128]	; 0x80
    14c4:	a816      	add	r0, sp, #88	; 0x58
    14c6:	9b1e      	ldr	r3, [sp, #120]	; 0x78
    14c8:	9301      	str	r3, [sp, #4]
    14ca:	9b1d      	ldr	r3, [sp, #116]	; 0x74
    14cc:	9300      	str	r3, [sp, #0]
    14ce:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
    14d0:	2210      	movs	r2, #16
    14d2:	f7ff fd43 	bl	f5c <_PrintUnsigned>
        break;
    14d6:	e03c      	b.n	1552 <SEGGER_RTT_vprintf+0x34e>
      case 's':
        {
          const char * s = va_arg(*pParamList, const char *);
    14d8:	9b03      	ldr	r3, [sp, #12]
    14da:	681b      	ldr	r3, [r3, #0]
    14dc:	1d19      	adds	r1, r3, #4
    14de:	9a03      	ldr	r2, [sp, #12]
    14e0:	6011      	str	r1, [r2, #0]
    14e2:	681b      	ldr	r3, [r3, #0]
    14e4:	931c      	str	r3, [sp, #112]	; 0x70
          if (s == NULL) {
    14e6:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    14e8:	2b00      	cmp	r3, #0
    14ea:	d101      	bne.n	14f0 <SEGGER_RTT_vprintf+0x2ec>
            s = "(NULL)";  // Print (NULL) instead of crashing or breaking, as it is more informative to the user.
    14ec:	4b2c      	ldr	r3, [pc, #176]	; (15a0 <SEGGER_RTT_vprintf+0x39c>)
    14ee:	931c      	str	r3, [sp, #112]	; 0x70
          }
          do {
            c = *s;
    14f0:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    14f2:	781b      	ldrb	r3, [r3, #0]
    14f4:	f88d 3087 	strb.w	r3, [sp, #135]	; 0x87
            s++;
    14f8:	9b1c      	ldr	r3, [sp, #112]	; 0x70
    14fa:	3301      	adds	r3, #1
    14fc:	931c      	str	r3, [sp, #112]	; 0x70
            if (c == '\0') {
    14fe:	f89d 3087 	ldrb.w	r3, [sp, #135]	; 0x87
    1502:	2b00      	cmp	r3, #0
    1504:	d00a      	beq.n	151c <SEGGER_RTT_vprintf+0x318>
              break;
            }
           _StoreChar(&BufferDesc, c);
    1506:	f89d 2087 	ldrb.w	r2, [sp, #135]	; 0x87
    150a:	ab16      	add	r3, sp, #88	; 0x58
    150c:	4611      	mov	r1, r2
    150e:	4618      	mov	r0, r3
    1510:	f7ff fce5 	bl	ede <_StoreChar>
          } while (BufferDesc.ReturnValue >= 0);
    1514:	9b19      	ldr	r3, [sp, #100]	; 0x64
    1516:	2b00      	cmp	r3, #0
    1518:	daea      	bge.n	14f0 <SEGGER_RTT_vprintf+0x2ec>
        }
        break;
    151a:	e01a      	b.n	1552 <SEGGER_RTT_vprintf+0x34e>
              break;
    151c:	bf00      	nop
        break;
    151e:	e018      	b.n	1552 <SEGGER_RTT_vprintf+0x34e>
      case 'p':
        v = va_arg(*pParamList, int);
    1520:	9b03      	ldr	r3, [sp, #12]
    1522:	681b      	ldr	r3, [r3, #0]
    1524:	1d19      	adds	r1, r3, #4
    1526:	9a03      	ldr	r2, [sp, #12]
    1528:	6011      	str	r1, [r2, #0]
    152a:	681b      	ldr	r3, [r3, #0]
    152c:	9320      	str	r3, [sp, #128]	; 0x80
        _PrintUnsigned(&BufferDesc, (unsigned)v, 16u, 8u, 8u, 0u);
    152e:	9920      	ldr	r1, [sp, #128]	; 0x80
    1530:	a816      	add	r0, sp, #88	; 0x58
    1532:	2300      	movs	r3, #0
    1534:	9301      	str	r3, [sp, #4]
    1536:	2308      	movs	r3, #8
    1538:	9300      	str	r3, [sp, #0]
    153a:	2308      	movs	r3, #8
    153c:	2210      	movs	r2, #16
    153e:	f7ff fd0d 	bl	f5c <_PrintUnsigned>
        break;
    1542:	e006      	b.n	1552 <SEGGER_RTT_vprintf+0x34e>
      case '%':
        _StoreChar(&BufferDesc, '%');
    1544:	ab16      	add	r3, sp, #88	; 0x58
    1546:	2125      	movs	r1, #37	; 0x25
    1548:	4618      	mov	r0, r3
    154a:	f7ff fcc8 	bl	ede <_StoreChar>
        break;
    154e:	e000      	b.n	1552 <SEGGER_RTT_vprintf+0x34e>
      default:
        break;
    1550:	bf00      	nop
      }
      sFormat++;
    1552:	9b04      	ldr	r3, [sp, #16]
    1554:	3301      	adds	r3, #1
    1556:	9304      	str	r3, [sp, #16]
    1558:	e006      	b.n	1568 <SEGGER_RTT_vprintf+0x364>
    } else {
      _StoreChar(&BufferDesc, c);
    155a:	f89d 2087 	ldrb.w	r2, [sp, #135]	; 0x87
    155e:	ab16      	add	r3, sp, #88	; 0x58
    1560:	4611      	mov	r1, r2
    1562:	4618      	mov	r0, r3
    1564:	f7ff fcbb 	bl	ede <_StoreChar>
    }
  } while (BufferDesc.ReturnValue >= 0);
    1568:	9b19      	ldr	r3, [sp, #100]	; 0x64
    156a:	2b00      	cmp	r3, #0
    156c:	f6bf ae59 	bge.w	1222 <SEGGER_RTT_vprintf+0x1e>
    1570:	e000      	b.n	1574 <SEGGER_RTT_vprintf+0x370>
      break;
    1572:	bf00      	nop

  if (BufferDesc.ReturnValue > 0) {
    1574:	9b19      	ldr	r3, [sp, #100]	; 0x64
    1576:	2b00      	cmp	r3, #0
    1578:	dd0c      	ble.n	1594 <SEGGER_RTT_vprintf+0x390>
    //
    // Write remaining data, if any
    //
    if (BufferDesc.Cnt != 0u) {
    157a:	9b18      	ldr	r3, [sp, #96]	; 0x60
    157c:	2b00      	cmp	r3, #0
    157e:	d005      	beq.n	158c <SEGGER_RTT_vprintf+0x388>
      SEGGER_RTT_Write(BufferIndex, acBuffer, BufferDesc.Cnt);
    1580:	9a18      	ldr	r2, [sp, #96]	; 0x60
    1582:	ab06      	add	r3, sp, #24
    1584:	4619      	mov	r1, r3
    1586:	9805      	ldr	r0, [sp, #20]
    1588:	f7ff fc7e 	bl	e88 <SEGGER_RTT_Write>
    }
    BufferDesc.ReturnValue += (int)BufferDesc.Cnt;
    158c:	9b19      	ldr	r3, [sp, #100]	; 0x64
    158e:	9a18      	ldr	r2, [sp, #96]	; 0x60
    1590:	4413      	add	r3, r2
    1592:	9319      	str	r3, [sp, #100]	; 0x64
  }
  return BufferDesc.ReturnValue;
    1594:	9b19      	ldr	r3, [sp, #100]	; 0x64
}
    1596:	4618      	mov	r0, r3
    1598:	b023      	add	sp, #140	; 0x8c
    159a:	f85d fb04 	ldr.w	pc, [sp], #4
    159e:	bf00      	nop
    15a0:	00015428 	.word	0x00015428

000015a4 <SEGGER_RTT_printf>:
*          u: Print the argument as an unsigned integer
*          x: Print the argument as an hexadecimal integer
*          s: Print the string pointed to by the argument
*          p: Print the argument as an 8-digit hexadecimal integer. (Argument shall be a pointer to void.)
*/
int SEGGER_RTT_printf(unsigned BufferIndex, const char * sFormat, ...) {
    15a4:	b40e      	push	{r1, r2, r3}
    15a6:	b500      	push	{lr}
    15a8:	b084      	sub	sp, #16
    15aa:	9001      	str	r0, [sp, #4]
  int r;
  va_list ParamList;

  va_start(ParamList, sFormat);
    15ac:	ab06      	add	r3, sp, #24
    15ae:	9302      	str	r3, [sp, #8]
  r = SEGGER_RTT_vprintf(BufferIndex, sFormat, &ParamList);
    15b0:	ab02      	add	r3, sp, #8
    15b2:	461a      	mov	r2, r3
    15b4:	9905      	ldr	r1, [sp, #20]
    15b6:	9801      	ldr	r0, [sp, #4]
    15b8:	f7ff fe24 	bl	1204 <SEGGER_RTT_vprintf>
    15bc:	9003      	str	r0, [sp, #12]
  va_end(ParamList);
  return r;
    15be:	9b03      	ldr	r3, [sp, #12]
}
    15c0:	4618      	mov	r0, r3
    15c2:	b004      	add	sp, #16
    15c4:	f85d eb04 	ldr.w	lr, [sp], #4
    15c8:	b003      	add	sp, #12
    15ca:	4770      	bx	lr

000015cc <MCU_clocks>:
 *  -SIRCDIV1_CLK -->8 Mhz
 *  -SIRCDIV2_CLK -->8 Mhz
 *  -SOSCDIV1_CLK  -->Disabled
 *  -SOSCDIV2_CLK  -->Disabled
 */
void MCU_clocks( void ) {
    15cc:	b508      	push	{r3, lr}
    /*Init Mcu module, including internal PLL, reference to Mcu Config structure can 
    be found at Mcu_PBcfg.h and PLL defines at Mcu_Cfg.h*/
    Mcu_Init( &Mcu_Config );//Initializing MCU driver
    15ce:	4805      	ldr	r0, [pc, #20]	; (15e4 <MCU_clocks+0x18>)
    15d0:	f004 fa32 	bl	5a38 <Mcu_Init>
    Mcu_SetMode( Run_mode );//MCU on run mode.
    15d4:	2000      	movs	r0, #0
    15d6:	f004 fae3 	bl	5ba0 <Mcu_SetMode>
    Mcu_InitClock( Clocks_conf_0 );//Executing clock configurations established in container.
    15da:	2000      	movs	r0, #0
    15dc:	f004 faaa 	bl	5b34 <Mcu_InitClock>

    //Configuring Pll clock.
    /*while ( Mcu_GetPllStatus() != MCU_PLL_LOCKED );//Waiting until PLL is locked.
    Mcu_DistributePllClock();//Executing pll clock configuration established in container.*/
}
    15e0:	bf00      	nop
    15e2:	bd08      	pop	{r3, pc}
    15e4:	00016694 	.word	0x00016694

000015e8 <EcuM_Init>:
/**
 * @brief This function initialices the microcontroller and the peripherals
 * 
 * 
 */
void EcuM_Init( void ) {   
    15e8:	b508      	push	{r3, lr}
    MCU_clocks();
    15ea:	f7ff ffef 	bl	15cc <MCU_clocks>
    OsIf_Init( NULL_PTR );  //Init Osif timer.
    15ee:	2000      	movs	r0, #0
    15f0:	f000 fbcb 	bl	1d8a <OsIf_Init>
    Platform_Init( NULL_PTR );  //Init platform driver and configuration.
    15f4:	2000      	movs	r0, #0
    15f6:	f000 fa6b 	bl	1ad0 <Platform_Init>
    Port_Init( &Port_Config );  //Init port driver and configuration.
    15fa:	4805      	ldr	r0, [pc, #20]	; (1610 <EcuM_Init+0x28>)
    15fc:	f004 feb4 	bl	6368 <Port_Init>
    Can_43_FLEXCAN_Init( &Can_43_FLEXCAN_Config );  //Init FlexCan driver
    1600:	4804      	ldr	r0, [pc, #16]	; (1614 <EcuM_Init+0x2c>)
    1602:	f006 ff71 	bl	84e8 <Can_43_FLEXCAN_Init>
    CanIf_Init( &CanIf_Config );    //Init CanIf driver.
    1606:	4804      	ldr	r0, [pc, #16]	; (1618 <EcuM_Init+0x30>)
    1608:	f012 ff64 	bl	144d4 <CanIf_Init>
}
    160c:	bf00      	nop
    160e:	bd08      	pop	{r3, pc}
    1610:	00016b88 	.word	0x00016b88
    1614:	000161f0 	.word	0x000161f0
    1618:	00016158 	.word	0x00016158

0000161c <Delay>:
/**
 * @brief This function is a delay in ms using the osif timer.
 * 
 * @param ms Delay in ms.
 */
void Delay( uint32 ms ) {
    161c:	b500      	push	{lr}
    161e:	b087      	sub	sp, #28
    1620:	9001      	str	r0, [sp, #4]
    uint32 Timeout = OsIf_MicrosToTicks( ms * 1000u, OSIF_COUNTER_SYSTEM );
    1622:	9b01      	ldr	r3, [sp, #4]
    1624:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    1628:	fb02 f303 	mul.w	r3, r2, r3
    162c:	2101      	movs	r1, #1
    162e:	4618      	mov	r0, r3
    1630:	f000 fc00 	bl	1e34 <OsIf_MicrosToTicks>
    1634:	9004      	str	r0, [sp, #16]
    uint32 SeedTick = OsIf_GetCounter( OSIF_COUNTER_SYSTEM );
    1636:	2001      	movs	r0, #1
    1638:	f000 fbb0 	bl	1d9c <OsIf_GetCounter>
    163c:	4603      	mov	r3, r0
    163e:	9303      	str	r3, [sp, #12]
    uint32 ElapsedTime = 0u;
    1640:	2300      	movs	r3, #0
    1642:	9305      	str	r3, [sp, #20]

    do {
        ElapsedTime += OsIf_GetElapsed( &SeedTick, OSIF_COUNTER_SYSTEM );
    1644:	ab03      	add	r3, sp, #12
    1646:	2101      	movs	r1, #1
    1648:	4618      	mov	r0, r3
    164a:	f000 fbc0 	bl	1dce <OsIf_GetElapsed>
    164e:	4602      	mov	r2, r0
    1650:	9b05      	ldr	r3, [sp, #20]
    1652:	4413      	add	r3, r2
    1654:	9305      	str	r3, [sp, #20]
    } while( ElapsedTime < Timeout );
    1656:	9a05      	ldr	r2, [sp, #20]
    1658:	9b04      	ldr	r3, [sp, #16]
    165a:	429a      	cmp	r2, r3
    165c:	d3f2      	bcc.n	1644 <Delay+0x28>
    165e:	bf00      	nop
    1660:	bf00      	nop
    1662:	b007      	add	sp, #28
    1664:	f85d fb04 	ldr.w	pc, [sp], #4

00001668 <memcpy>:
    1668:	440a      	add	r2, r1
    166a:	4291      	cmp	r1, r2
    166c:	f100 33ff 	add.w	r3, r0, #4294967295
    1670:	d100      	bne.n	1674 <memcpy+0xc>
    1672:	4770      	bx	lr
    1674:	b510      	push	{r4, lr}
    1676:	f811 4b01 	ldrb.w	r4, [r1], #1
    167a:	f803 4f01 	strb.w	r4, [r3, #1]!
    167e:	4291      	cmp	r1, r2
    1680:	d1f9      	bne.n	1676 <memcpy+0xe>
    1682:	bd10      	pop	{r4, pc}

00001684 <memset>:
    1684:	4402      	add	r2, r0
    1686:	4603      	mov	r3, r0
    1688:	4293      	cmp	r3, r2
    168a:	d100      	bne.n	168e <memset+0xa>
    168c:	4770      	bx	lr
    168e:	f803 1b01 	strb.w	r1, [r3], #1
    1692:	e7f9      	b.n	1688 <memset+0x4>

00001694 <IntCtrl_Ip_InstallHandlerPrivileged>:
#endif

void IntCtrl_Ip_InstallHandlerPrivileged(IRQn_Type eIrqNumber,
                               const IntCtrl_Ip_IrqHandlerType pfNewHandler,
                               IntCtrl_Ip_IrqHandlerType* const pfOldHandler)
{
    1694:	b500      	push	{lr}
    1696:	b087      	sub	sp, #28
    1698:	9003      	str	r0, [sp, #12]
    169a:	9102      	str	r1, [sp, #8]
    169c:	9201      	str	r2, [sp, #4]
#if (INT_CTRL_IP_DEV_ERROR_DETECT == STD_ON)
    /* Check IRQ number - dev_irqNumber is used to avoid compiler warning */
    sint32 dev_irqNumber = (sint32)eIrqNumber;
    169e:	9b03      	ldr	r3, [sp, #12]
    16a0:	9305      	str	r3, [sp, #20]
    DevAssert((sint32)INT_CTRL_IP_IRQ_MIN <= dev_irqNumber);
    16a2:	9b05      	ldr	r3, [sp, #20]
    16a4:	43db      	mvns	r3, r3
    16a6:	0fdb      	lsrs	r3, r3, #31
    16a8:	b2db      	uxtb	r3, r3
    16aa:	4618      	mov	r0, r3
    16ac:	f7ff f958 	bl	960 <DevAssert>
    DevAssert(dev_irqNumber <= (sint32)INT_CTRL_IP_IRQ_MAX);
    16b0:	9b05      	ldr	r3, [sp, #20]
    16b2:	2b7a      	cmp	r3, #122	; 0x7a
    16b4:	bfd4      	ite	le
    16b6:	2301      	movle	r3, #1
    16b8:	2300      	movgt	r3, #0
    16ba:	b2db      	uxtb	r3, r3
    16bc:	4618      	mov	r0, r3
    16be:	f7ff f94f 	bl	960 <DevAssert>
#if (MCAL_PLATFORM_ARM == MCAL_ARM_MARCH)
#if defined(S32K3XX) || defined(SAF85) || defined(S32R41)
    DevAssert(S32_SCB->VTOR >= (uint32)__RAM_INTERRUPT_START);
#else
    DevAssert(S32_SCB->VTOR >= (uint32)__INT_SRAM_START);
    16c2:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    16c6:	f8d3 3d08 	ldr.w	r3, [r3, #3336]	; 0xd08
    16ca:	4a14      	ldr	r2, [pc, #80]	; (171c <IntCtrl_Ip_InstallHandlerPrivileged+0x88>)
    16cc:	4293      	cmp	r3, r2
    16ce:	bf2c      	ite	cs
    16d0:	2301      	movcs	r3, #1
    16d2:	2300      	movcc	r3, #0
    16d4:	b2db      	uxtb	r3, r3
    16d6:	4618      	mov	r0, r3
    16d8:	f7ff f942 	bl	960 <DevAssert>

    /* Set handler into vector table */
    pVectorRam[((sint32)eIrqNumber)] = pfNewHandler;
    OsIf_ResumeAllInterrupts();
#else
    IntCtrl_Ip_IrqHandlerType *pVectorRam = (IntCtrl_Ip_IrqHandlerType *)S32_SCB->VTOR;
    16dc:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    16e0:	f8d3 3d08 	ldr.w	r3, [r3, #3336]	; 0xd08
    16e4:	9304      	str	r3, [sp, #16]

    /* Save the former handler pointer */
    if (pfOldHandler != NULL_PTR)
    16e6:	9b01      	ldr	r3, [sp, #4]
    16e8:	2b00      	cmp	r3, #0
    16ea:	d007      	beq.n	16fc <IntCtrl_Ip_InstallHandlerPrivileged+0x68>
    {
        *pfOldHandler = (IntCtrl_Ip_IrqHandlerType)pVectorRam[((sint32)eIrqNumber) + 16];
    16ec:	9b03      	ldr	r3, [sp, #12]
    16ee:	3310      	adds	r3, #16
    16f0:	009b      	lsls	r3, r3, #2
    16f2:	9a04      	ldr	r2, [sp, #16]
    16f4:	4413      	add	r3, r2
    16f6:	681a      	ldr	r2, [r3, #0]
    16f8:	9b01      	ldr	r3, [sp, #4]
    16fa:	601a      	str	r2, [r3, #0]
    }

    /* Set handler into vector table */
    pVectorRam[((sint32)eIrqNumber) + 16] = pfNewHandler;
    16fc:	9b03      	ldr	r3, [sp, #12]
    16fe:	3310      	adds	r3, #16
    1700:	009b      	lsls	r3, r3, #2
    1702:	9a04      	ldr	r2, [sp, #16]
    1704:	4413      	add	r3, r2
    1706:	9a02      	ldr	r2, [sp, #8]
    1708:	601a      	str	r2, [r3, #0]
    S32_SCB->ICIALLU = 0UL;
#endif
    
#endif /* (INT_CTRL_IP_CORTEXR == STD_ON) || (INT_CTRL_IP_CORTEXA == STD_ON) */
/*LDRA_NOANALYSIS*/
    MCAL_INSTRUCTION_SYNC_BARRIER();
    170a:	f3bf 8f6f 	isb	sy
    MCAL_DATA_SYNC_BARRIER();
    170e:	f3bf 8f4f 	dsb	sy
/*LDRA_ANALYSIS*/    
}
    1712:	bf00      	nop
    1714:	b007      	add	sp, #28
    1716:	f85d fb04 	ldr.w	pc, [sp], #4
    171a:	bf00      	nop
    171c:	1fff8000 	.word	0x1fff8000

00001720 <IntCtrl_Ip_EnableIrqPrivileged>:

void IntCtrl_Ip_EnableIrqPrivileged(IRQn_Type eIrqNumber)
{
    1720:	b500      	push	{lr}
    1722:	b083      	sub	sp, #12
    1724:	9001      	str	r0, [sp, #4]

#if (INT_CTRL_IP_DEV_ERROR_DETECT == STD_ON)
    /* Check IRQ number - dev_irqNumber is used to avoid compiler warning */
    DevAssert(0 <= (sint32)eIrqNumber);
    1726:	9b01      	ldr	r3, [sp, #4]
    1728:	43db      	mvns	r3, r3
    172a:	0fdb      	lsrs	r3, r3, #31
    172c:	b2db      	uxtb	r3, r3
    172e:	4618      	mov	r0, r3
    1730:	f7ff f916 	bl	960 <DevAssert>
    DevAssert((sint32)eIrqNumber <= (sint32)INT_CTRL_IP_IRQ_MAX);
    1734:	9b01      	ldr	r3, [sp, #4]
    1736:	2b7a      	cmp	r3, #122	; 0x7a
    1738:	bfd4      	ite	le
    173a:	2301      	movle	r3, #1
    173c:	2300      	movgt	r3, #0
    173e:	b2db      	uxtb	r3, r3
    1740:	4618      	mov	r0, r3
    1742:	f7ff f90d 	bl	960 <DevAssert>
    {
        S32_GICD->GICD_ISENABLER[((uint32)(eIrqNumber) >> 5U) - 1U] = (uint32)(1UL << ((uint32)(eIrqNumber) & (uint32)0x1FU));
    }
#endif
#else
    S32_NVIC->ISER[(uint32)(eIrqNumber) >> 5U] = (uint32)(1UL << ((uint32)(eIrqNumber) & (uint32)0x1FU));
    1746:	9b01      	ldr	r3, [sp, #4]
    1748:	f003 021f 	and.w	r2, r3, #31
    174c:	4905      	ldr	r1, [pc, #20]	; (1764 <IntCtrl_Ip_EnableIrqPrivileged+0x44>)
    174e:	9b01      	ldr	r3, [sp, #4]
    1750:	095b      	lsrs	r3, r3, #5
    1752:	2001      	movs	r0, #1
    1754:	fa00 f202 	lsl.w	r2, r0, r2
    1758:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif
}
    175c:	bf00      	nop
    175e:	b003      	add	sp, #12
    1760:	f85d fb04 	ldr.w	pc, [sp], #4
    1764:	e000e100 	.word	0xe000e100

00001768 <IntCtrl_Ip_DisableIrqPrivileged>:

void IntCtrl_Ip_DisableIrqPrivileged(IRQn_Type eIrqNumber)
{
    1768:	b500      	push	{lr}
    176a:	b083      	sub	sp, #12
    176c:	9001      	str	r0, [sp, #4]
#if (INT_CTRL_IP_DEV_ERROR_DETECT == STD_ON)
    /* Check IRQ number - dev_irqNumber is used to avoid compiler warning */
    DevAssert(0 <= (sint32)eIrqNumber);
    176e:	9b01      	ldr	r3, [sp, #4]
    1770:	43db      	mvns	r3, r3
    1772:	0fdb      	lsrs	r3, r3, #31
    1774:	b2db      	uxtb	r3, r3
    1776:	4618      	mov	r0, r3
    1778:	f7ff f8f2 	bl	960 <DevAssert>
    DevAssert((sint32)eIrqNumber <= (sint32)INT_CTRL_IP_IRQ_MAX);
    177c:	9b01      	ldr	r3, [sp, #4]
    177e:	2b7a      	cmp	r3, #122	; 0x7a
    1780:	bfd4      	ite	le
    1782:	2301      	movle	r3, #1
    1784:	2300      	movgt	r3, #0
    1786:	b2db      	uxtb	r3, r3
    1788:	4618      	mov	r0, r3
    178a:	f7ff f8e9 	bl	960 <DevAssert>
    {
        S32_GICD->GICD_ICENABLER[((uint32)(eIrqNumber) >> 5U) - 1U] = (uint32)(1UL << ((uint32)(eIrqNumber) & (uint32)0x1FU));
    }
#endif
#else
    S32_NVIC->ICER[(uint32)(eIrqNumber) >> 5U] = (uint32)(1UL << ((uint32)(eIrqNumber) & (uint32)0x1FU));
    178e:	9b01      	ldr	r3, [sp, #4]
    1790:	f003 021f 	and.w	r2, r3, #31
    1794:	4906      	ldr	r1, [pc, #24]	; (17b0 <IntCtrl_Ip_DisableIrqPrivileged+0x48>)
    1796:	9b01      	ldr	r3, [sp, #4]
    1798:	095b      	lsrs	r3, r3, #5
    179a:	2001      	movs	r0, #1
    179c:	fa00 f202 	lsl.w	r2, r0, r2
    17a0:	3320      	adds	r3, #32
    17a2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif
}
    17a6:	bf00      	nop
    17a8:	b003      	add	sp, #12
    17aa:	f85d fb04 	ldr.w	pc, [sp], #4
    17ae:	bf00      	nop
    17b0:	e000e100 	.word	0xe000e100

000017b4 <IntCtrl_Ip_SetPriorityPrivileged>:

void IntCtrl_Ip_SetPriorityPrivileged(IRQn_Type eIrqNumber, uint8 u8Priority)
{
    17b4:	b500      	push	{lr}
    17b6:	b085      	sub	sp, #20
    17b8:	9001      	str	r0, [sp, #4]
    17ba:	460b      	mov	r3, r1
    17bc:	f88d 3003 	strb.w	r3, [sp, #3]

#if (INT_CTRL_IP_DEV_ERROR_DETECT == STD_ON)

    /* Check IRQ number and priority - dev_irqNumber is used to avoid compiler warning */
    DevAssert((sint32)INT_CTRL_IP_IRQ_MIN <= (sint32)eIrqNumber);
    17c0:	9b01      	ldr	r3, [sp, #4]
    17c2:	43db      	mvns	r3, r3
    17c4:	0fdb      	lsrs	r3, r3, #31
    17c6:	b2db      	uxtb	r3, r3
    17c8:	4618      	mov	r0, r3
    17ca:	f7ff f8c9 	bl	960 <DevAssert>
    DevAssert((sint32)eIrqNumber <= (sint32)INT_CTRL_IP_IRQ_MAX);
    17ce:	9b01      	ldr	r3, [sp, #4]
    17d0:	2b7a      	cmp	r3, #122	; 0x7a
    17d2:	bfd4      	ite	le
    17d4:	2301      	movle	r3, #1
    17d6:	2300      	movgt	r3, #0
    17d8:	b2db      	uxtb	r3, r3
    17da:	4618      	mov	r0, r3
    17dc:	f7ff f8c0 	bl	960 <DevAssert>
#if (INT_CTRL_IP_CORTEXM == STD_ON)
    DevAssert(u8Priority < (uint8)(1U << INT_CTRL_IP_NVIC_PRIO_BITS));
    17e0:	f89d 3003 	ldrb.w	r3, [sp, #3]
    17e4:	2b0f      	cmp	r3, #15
    17e6:	bf94      	ite	ls
    17e8:	2301      	movls	r3, #1
    17ea:	2300      	movhi	r3, #0
    17ec:	b2db      	uxtb	r3, r3
    17ee:	4618      	mov	r0, r3
    17f0:	f7ff f8b6 	bl	960 <DevAssert>
#endif

#endif /* (INT_CTRL_IP_DEV_ERROR_DETECT == STD_ON) */

#if (INT_CTRL_IP_CORTEXM == STD_ON)
    uint8 shift = (uint8) (8U - INT_CTRL_IP_NVIC_PRIO_BITS);
    17f4:	2304      	movs	r3, #4
    17f6:	f88d 300f 	strb.w	r3, [sp, #15]
    #if (INT_CTRL_IP_CORTEXM0PLUS == STD_OFF)
        /* Set Priority for device specific Interrupts */
        S32_NVIC->IP[(uint32)(eIrqNumber)] = (uint8)((((uint32)u8Priority) << shift) & 0xFFUL);
    17fa:	f89d 2003 	ldrb.w	r2, [sp, #3]
    17fe:	f89d 300f 	ldrb.w	r3, [sp, #15]
    1802:	fa02 f103 	lsl.w	r1, r2, r3
    1806:	4a05      	ldr	r2, [pc, #20]	; (181c <IntCtrl_Ip_SetPriorityPrivileged+0x68>)
    1808:	9b01      	ldr	r3, [sp, #4]
    180a:	b2c9      	uxtb	r1, r1
    180c:	4413      	add	r3, r2
    180e:	460a      	mov	r2, r1
    1810:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
            IP_GIC500->GICD.IPRIORITYR[iprVectorId] &= ~(0xFFUL << priByteShift);
            IP_GIC500->GICD.IPRIORITYR[iprVectorId] |= ((uint32)(((((uint32)u8Priority) << shift_gic)) & 0xFFUL)) << priByteShift;
        }
    #endif
#endif
}
    1814:	bf00      	nop
    1816:	b005      	add	sp, #20
    1818:	f85d fb04 	ldr.w	pc, [sp], #4
    181c:	e000e100 	.word	0xe000e100

00001820 <IntCtrl_Ip_GetPriorityPrivileged>:

uint8 IntCtrl_Ip_GetPriorityPrivileged(IRQn_Type eIrqNumber)
{
    1820:	b500      	push	{lr}
    1822:	b085      	sub	sp, #20
    1824:	9001      	str	r0, [sp, #4]
#if (INT_CTRL_IP_DEV_ERROR_DETECT == STD_ON)

    /* Check IRQ number */
    DevAssert(INT_CTRL_IP_IRQ_MIN <= eIrqNumber);
    1826:	9b01      	ldr	r3, [sp, #4]
    1828:	43db      	mvns	r3, r3
    182a:	0fdb      	lsrs	r3, r3, #31
    182c:	b2db      	uxtb	r3, r3
    182e:	4618      	mov	r0, r3
    1830:	f7ff f896 	bl	960 <DevAssert>
    DevAssert((sint32)eIrqNumber <= (sint32)INT_CTRL_IP_IRQ_MAX);
    1834:	9b01      	ldr	r3, [sp, #4]
    1836:	2b7a      	cmp	r3, #122	; 0x7a
    1838:	bfd4      	ite	le
    183a:	2301      	movle	r3, #1
    183c:	2300      	movgt	r3, #0
    183e:	b2db      	uxtb	r3, r3
    1840:	4618      	mov	r0, r3
    1842:	f7ff f88d 	bl	960 <DevAssert>

    uint8 priority;


#if (INT_CTRL_IP_CORTEXM == STD_ON)
    uint8 shift = (uint8)(8U - INT_CTRL_IP_NVIC_PRIO_BITS);
    1846:	2304      	movs	r3, #4
    1848:	f88d 300f 	strb.w	r3, [sp, #15]
    #if (INT_CTRL_IP_CORTEXM0PLUS == STD_OFF)
        /* Get Priority for device specific Interrupts  */
        priority = (uint8)(S32_NVIC->IP[(uint32)(eIrqNumber)] >> shift);
    184c:	4a09      	ldr	r2, [pc, #36]	; (1874 <IntCtrl_Ip_GetPriorityPrivileged+0x54>)
    184e:	9b01      	ldr	r3, [sp, #4]
    1850:	4413      	add	r3, r2
    1852:	f893 3300 	ldrb.w	r3, [r3, #768]	; 0x300
    1856:	b2db      	uxtb	r3, r3
    1858:	461a      	mov	r2, r3
    185a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    185e:	fa42 f303 	asr.w	r3, r2, r3
    1862:	f88d 300e 	strb.w	r3, [sp, #14]
            uint8 priByteShift = (uint8)((((uint8)(eIrqNumber)) & 0x3U) << 3U);
            priority = ((uint8)(IP_GIC500->GICD.IPRIORITYR[iprVectorId] >> priByteShift)) >> shift_gic;
        }
    #endif
#endif
    return priority;
    1866:	f89d 300e 	ldrb.w	r3, [sp, #14]
}
    186a:	4618      	mov	r0, r3
    186c:	b005      	add	sp, #20
    186e:	f85d fb04 	ldr.w	pc, [sp], #4
    1872:	bf00      	nop
    1874:	e000e100 	.word	0xe000e100

00001878 <IntCtrl_Ip_ClearPendingPrivileged>:

void IntCtrl_Ip_ClearPendingPrivileged(IRQn_Type eIrqNumber)
{
    1878:	b500      	push	{lr}
    187a:	b083      	sub	sp, #12
    187c:	9001      	str	r0, [sp, #4]

#if (INT_CTRL_IP_DEV_ERROR_DETECT == STD_ON)
    /* Check IRQ number */
    DevAssert(0 <= (sint32)eIrqNumber);
    187e:	9b01      	ldr	r3, [sp, #4]
    1880:	43db      	mvns	r3, r3
    1882:	0fdb      	lsrs	r3, r3, #31
    1884:	b2db      	uxtb	r3, r3
    1886:	4618      	mov	r0, r3
    1888:	f7ff f86a 	bl	960 <DevAssert>
    DevAssert((sint32)eIrqNumber <= (sint32)INT_CTRL_IP_IRQ_MAX);
    188c:	9b01      	ldr	r3, [sp, #4]
    188e:	2b7a      	cmp	r3, #122	; 0x7a
    1890:	bfd4      	ite	le
    1892:	2301      	movle	r3, #1
    1894:	2300      	movgt	r3, #0
    1896:	b2db      	uxtb	r3, r3
    1898:	4618      	mov	r0, r3
    189a:	f7ff f861 	bl	960 <DevAssert>
    }
#endif

#else
    /* Clear Pending Interrupt */
    S32_NVIC->ICPR[(uint32)(eIrqNumber) >> 5U] = (uint32)(1UL << ((uint32)(eIrqNumber) & (uint32)0x1FU));
    189e:	9b01      	ldr	r3, [sp, #4]
    18a0:	f003 021f 	and.w	r2, r3, #31
    18a4:	4906      	ldr	r1, [pc, #24]	; (18c0 <IntCtrl_Ip_ClearPendingPrivileged+0x48>)
    18a6:	9b01      	ldr	r3, [sp, #4]
    18a8:	095b      	lsrs	r3, r3, #5
    18aa:	2001      	movs	r0, #1
    18ac:	fa00 f202 	lsl.w	r2, r0, r2
    18b0:	3360      	adds	r3, #96	; 0x60
    18b2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif

}
    18b6:	bf00      	nop
    18b8:	b003      	add	sp, #12
    18ba:	f85d fb04 	ldr.w	pc, [sp], #4
    18be:	bf00      	nop
    18c0:	e000e100 	.word	0xe000e100

000018c4 <IntCtrl_Ip_Init>:
 * @internal
 * @brief         Initializes the configured interrupts at interrupt controller level.
 * @implements    IntCtrl_Ip_Init_Activity
 */
IntCtrl_Ip_StatusType IntCtrl_Ip_Init(const IntCtrl_Ip_CtrlConfigType *pIntCtrlCtrlConfig)
{
    18c4:	b500      	push	{lr}
    18c6:	b085      	sub	sp, #20
    18c8:	9001      	str	r0, [sp, #4]
#if (INT_CTRL_IP_ENABLE_VTOR_CONFIG == STD_ON)
    S32_SCB->VTOR = pIntCtrlCtrlConfig->u32VectorTableAddress;
#endif

#if (INT_CTRL_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(pIntCtrlCtrlConfig != NULL_PTR);
    18ca:	9b01      	ldr	r3, [sp, #4]
    18cc:	2b00      	cmp	r3, #0
    18ce:	bf14      	ite	ne
    18d0:	2301      	movne	r3, #1
    18d2:	2300      	moveq	r3, #0
    18d4:	b2db      	uxtb	r3, r3
    18d6:	4618      	mov	r0, r3
    18d8:	f7ff f842 	bl	960 <DevAssert>
    DevAssert(pIntCtrlCtrlConfig->u32ConfigIrqCount <= INT_CTRL_IP_IRQ_COUNT);
    18dc:	9b01      	ldr	r3, [sp, #4]
    18de:	681b      	ldr	r3, [r3, #0]
    18e0:	2b59      	cmp	r3, #89	; 0x59
    18e2:	bf94      	ite	ls
    18e4:	2301      	movls	r3, #1
    18e6:	2300      	movhi	r3, #0
    18e8:	b2db      	uxtb	r3, r3
    18ea:	4618      	mov	r0, r3
    18ec:	f7ff f838 	bl	960 <DevAssert>
#endif
    uint32 irqIdx;
    for (irqIdx = 0; irqIdx < pIntCtrlCtrlConfig->u32ConfigIrqCount; irqIdx++)
    18f0:	2300      	movs	r3, #0
    18f2:	9303      	str	r3, [sp, #12]
    18f4:	e05d      	b.n	19b2 <IntCtrl_Ip_Init+0xee>
    {
        IntCtrl_Ip_ClearPending(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
    18f6:	9b01      	ldr	r3, [sp, #4]
    18f8:	6859      	ldr	r1, [r3, #4]
    18fa:	9a03      	ldr	r2, [sp, #12]
    18fc:	4613      	mov	r3, r2
    18fe:	005b      	lsls	r3, r3, #1
    1900:	4413      	add	r3, r2
    1902:	009b      	lsls	r3, r3, #2
    1904:	440b      	add	r3, r1
    1906:	681b      	ldr	r3, [r3, #0]
    1908:	4618      	mov	r0, r3
    190a:	f000 f899 	bl	1a40 <IntCtrl_Ip_ClearPending>
        IntCtrl_Ip_SetPriority(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    190e:	9b01      	ldr	r3, [sp, #4]
    1910:	6859      	ldr	r1, [r3, #4]
    1912:	9a03      	ldr	r2, [sp, #12]
    1914:	4613      	mov	r3, r2
    1916:	005b      	lsls	r3, r3, #1
    1918:	4413      	add	r3, r2
    191a:	009b      	lsls	r3, r3, #2
    191c:	440b      	add	r3, r1
    191e:	6818      	ldr	r0, [r3, #0]
                               pIntCtrlCtrlConfig->aIrqConfig[irqIdx].u8IrqPriority);
    1920:	9b01      	ldr	r3, [sp, #4]
    1922:	6859      	ldr	r1, [r3, #4]
    1924:	9a03      	ldr	r2, [sp, #12]
    1926:	4613      	mov	r3, r2
    1928:	005b      	lsls	r3, r3, #1
    192a:	4413      	add	r3, r2
    192c:	009b      	lsls	r3, r3, #2
    192e:	440b      	add	r3, r1
        IntCtrl_Ip_SetPriority(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    1930:	795b      	ldrb	r3, [r3, #5]
    1932:	4619      	mov	r1, r3
    1934:	f000 f869 	bl	1a0a <IntCtrl_Ip_SetPriority>

        /* Install the configured handler */
        IntCtrl_Ip_InstallHandler(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    1938:	9b01      	ldr	r3, [sp, #4]
    193a:	6859      	ldr	r1, [r3, #4]
    193c:	9a03      	ldr	r2, [sp, #12]
    193e:	4613      	mov	r3, r2
    1940:	005b      	lsls	r3, r3, #1
    1942:	4413      	add	r3, r2
    1944:	009b      	lsls	r3, r3, #2
    1946:	440b      	add	r3, r1
    1948:	6818      	ldr	r0, [r3, #0]
                                  pIntCtrlCtrlConfig->aIrqConfig[irqIdx].pfHandler,
    194a:	9b01      	ldr	r3, [sp, #4]
    194c:	6859      	ldr	r1, [r3, #4]
    194e:	9a03      	ldr	r2, [sp, #12]
    1950:	4613      	mov	r3, r2
    1952:	005b      	lsls	r3, r3, #1
    1954:	4413      	add	r3, r2
    1956:	009b      	lsls	r3, r3, #2
    1958:	440b      	add	r3, r1
        IntCtrl_Ip_InstallHandler(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    195a:	689b      	ldr	r3, [r3, #8]
    195c:	2200      	movs	r2, #0
    195e:	4619      	mov	r1, r3
    1960:	f000 f831 	bl	19c6 <IntCtrl_Ip_InstallHandler>
                                  NULL_PTR);

        if (pIntCtrlCtrlConfig->aIrqConfig[irqIdx].bIrqEnabled)
    1964:	9b01      	ldr	r3, [sp, #4]
    1966:	6859      	ldr	r1, [r3, #4]
    1968:	9a03      	ldr	r2, [sp, #12]
    196a:	4613      	mov	r3, r2
    196c:	005b      	lsls	r3, r3, #1
    196e:	4413      	add	r3, r2
    1970:	009b      	lsls	r3, r3, #2
    1972:	440b      	add	r3, r1
    1974:	791b      	ldrb	r3, [r3, #4]
    1976:	2b00      	cmp	r3, #0
    1978:	d00c      	beq.n	1994 <IntCtrl_Ip_Init+0xd0>
        {
            IntCtrl_Ip_EnableIrq(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
    197a:	9b01      	ldr	r3, [sp, #4]
    197c:	6859      	ldr	r1, [r3, #4]
    197e:	9a03      	ldr	r2, [sp, #12]
    1980:	4613      	mov	r3, r2
    1982:	005b      	lsls	r3, r3, #1
    1984:	4413      	add	r3, r2
    1986:	009b      	lsls	r3, r3, #2
    1988:	440b      	add	r3, r1
    198a:	681b      	ldr	r3, [r3, #0]
    198c:	4618      	mov	r0, r3
    198e:	f000 f828 	bl	19e2 <IntCtrl_Ip_EnableIrq>
    1992:	e00b      	b.n	19ac <IntCtrl_Ip_Init+0xe8>
        }
        else
        {
            IntCtrl_Ip_DisableIrq(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
    1994:	9b01      	ldr	r3, [sp, #4]
    1996:	6859      	ldr	r1, [r3, #4]
    1998:	9a03      	ldr	r2, [sp, #12]
    199a:	4613      	mov	r3, r2
    199c:	005b      	lsls	r3, r3, #1
    199e:	4413      	add	r3, r2
    19a0:	009b      	lsls	r3, r3, #2
    19a2:	440b      	add	r3, r1
    19a4:	681b      	ldr	r3, [r3, #0]
    19a6:	4618      	mov	r0, r3
    19a8:	f000 f825 	bl	19f6 <IntCtrl_Ip_DisableIrq>
    for (irqIdx = 0; irqIdx < pIntCtrlCtrlConfig->u32ConfigIrqCount; irqIdx++)
    19ac:	9b03      	ldr	r3, [sp, #12]
    19ae:	3301      	adds	r3, #1
    19b0:	9303      	str	r3, [sp, #12]
    19b2:	9b01      	ldr	r3, [sp, #4]
    19b4:	681b      	ldr	r3, [r3, #0]
    19b6:	9a03      	ldr	r2, [sp, #12]
    19b8:	429a      	cmp	r2, r3
    19ba:	d39c      	bcc.n	18f6 <IntCtrl_Ip_Init+0x32>
        }
    }

    return INTCTRL_IP_STATUS_SUCCESS;
    19bc:	2300      	movs	r3, #0
}
    19be:	4618      	mov	r0, r3
    19c0:	b005      	add	sp, #20
    19c2:	f85d fb04 	ldr.w	pc, [sp], #4

000019c6 <IntCtrl_Ip_InstallHandler>:
 * @implements    IntCtrl_Ip_InstallHandler_Activity
 */
void IntCtrl_Ip_InstallHandler(IRQn_Type eIrqNumber,
                               const IntCtrl_Ip_IrqHandlerType pfNewHandler,
                               IntCtrl_Ip_IrqHandlerType* const pfOldHandler)
{
    19c6:	b500      	push	{lr}
    19c8:	b085      	sub	sp, #20
    19ca:	9003      	str	r0, [sp, #12]
    19cc:	9102      	str	r1, [sp, #8]
    19ce:	9201      	str	r2, [sp, #4]
    Call_IntCtrl_Ip_InstallHandlerPrivileged(eIrqNumber,pfNewHandler,pfOldHandler);
    19d0:	9a01      	ldr	r2, [sp, #4]
    19d2:	9902      	ldr	r1, [sp, #8]
    19d4:	9803      	ldr	r0, [sp, #12]
    19d6:	f7ff fe5d 	bl	1694 <IntCtrl_Ip_InstallHandlerPrivileged>
}
    19da:	bf00      	nop
    19dc:	b005      	add	sp, #20
    19de:	f85d fb04 	ldr.w	pc, [sp], #4

000019e2 <IntCtrl_Ip_EnableIrq>:
 * @internal
 * @brief         Enables an interrupt request.
 * @implements    IntCtrl_Ip_EnableIrq_Activity
 */
void IntCtrl_Ip_EnableIrq(IRQn_Type eIrqNumber)
{
    19e2:	b500      	push	{lr}
    19e4:	b083      	sub	sp, #12
    19e6:	9001      	str	r0, [sp, #4]
    Call_IntCtrl_Ip_EnableIrqPrivileged(eIrqNumber);
    19e8:	9801      	ldr	r0, [sp, #4]
    19ea:	f7ff fe99 	bl	1720 <IntCtrl_Ip_EnableIrqPrivileged>
}
    19ee:	bf00      	nop
    19f0:	b003      	add	sp, #12
    19f2:	f85d fb04 	ldr.w	pc, [sp], #4

000019f6 <IntCtrl_Ip_DisableIrq>:
 * @internal
 * @brief         Disables an interrupt request.
 * @implements    IntCtrl_Ip_DisableIrq_Activity
 */
void IntCtrl_Ip_DisableIrq(IRQn_Type eIrqNumber)
{
    19f6:	b500      	push	{lr}
    19f8:	b083      	sub	sp, #12
    19fa:	9001      	str	r0, [sp, #4]
    Call_IntCtrl_Ip_DisableIrqPrivileged(eIrqNumber);
    19fc:	9801      	ldr	r0, [sp, #4]
    19fe:	f7ff feb3 	bl	1768 <IntCtrl_Ip_DisableIrqPrivileged>
}
    1a02:	bf00      	nop
    1a04:	b003      	add	sp, #12
    1a06:	f85d fb04 	ldr.w	pc, [sp], #4

00001a0a <IntCtrl_Ip_SetPriority>:
 * @internal
 * @brief         Sets the priority for an interrupt request.
 * @implements    IntCtrl_Ip_SetPriority_Activity
 */
void IntCtrl_Ip_SetPriority(IRQn_Type eIrqNumber, uint8 u8Priority)
{
    1a0a:	b500      	push	{lr}
    1a0c:	b083      	sub	sp, #12
    1a0e:	9001      	str	r0, [sp, #4]
    1a10:	460b      	mov	r3, r1
    1a12:	f88d 3003 	strb.w	r3, [sp, #3]
    Call_IntCtrl_Ip_SetPriorityPrivileged(eIrqNumber,u8Priority);
    1a16:	f89d 3003 	ldrb.w	r3, [sp, #3]
    1a1a:	4619      	mov	r1, r3
    1a1c:	9801      	ldr	r0, [sp, #4]
    1a1e:	f7ff fec9 	bl	17b4 <IntCtrl_Ip_SetPriorityPrivileged>
}
    1a22:	bf00      	nop
    1a24:	b003      	add	sp, #12
    1a26:	f85d fb04 	ldr.w	pc, [sp], #4

00001a2a <IntCtrl_Ip_GetPriority>:
 * @internal
 * @brief         Gets the priority for an interrupt request.
 * @implements    IntCtrl_Ip_GetPriority_Activity
 */
uint8 IntCtrl_Ip_GetPriority(IRQn_Type eIrqNumber)
{
    1a2a:	b500      	push	{lr}
    1a2c:	b083      	sub	sp, #12
    1a2e:	9001      	str	r0, [sp, #4]
    return (uint8)Call_IntCtrl_Ip_GetPriorityPrivileged(eIrqNumber);
    1a30:	9801      	ldr	r0, [sp, #4]
    1a32:	f7ff fef5 	bl	1820 <IntCtrl_Ip_GetPriorityPrivileged>
    1a36:	4603      	mov	r3, r0
}
    1a38:	4618      	mov	r0, r3
    1a3a:	b003      	add	sp, #12
    1a3c:	f85d fb04 	ldr.w	pc, [sp], #4

00001a40 <IntCtrl_Ip_ClearPending>:
 * @internal
 * @brief         Clears the pending flag for an interrupt request.
 * @implements    IntCtrl_Ip_ClearPending_Activity
 */
void IntCtrl_Ip_ClearPending(IRQn_Type eIrqNumber)
{
    1a40:	b500      	push	{lr}
    1a42:	b083      	sub	sp, #12
    1a44:	9001      	str	r0, [sp, #4]
    Call_IntCtrl_Ip_ClearPendingPrivileged(eIrqNumber);
    1a46:	9801      	ldr	r0, [sp, #4]
    1a48:	f7ff ff16 	bl	1878 <IntCtrl_Ip_ClearPendingPrivileged>
}
    1a4c:	bf00      	nop
    1a4e:	b003      	add	sp, #12
    1a50:	f85d fb04 	ldr.w	pc, [sp], #4

00001a54 <Platform_Ipw_SetIrq>:
/**
 * @internal
 * @brief         Enables/disables an interrupt by calling the Interrupt Controller IP layer.
 */
static inline void Platform_Ipw_SetIrq(IRQn_Type eIrqNumber, boolean bEnable)
{
    1a54:	b500      	push	{lr}
    1a56:	b083      	sub	sp, #12
    1a58:	9001      	str	r0, [sp, #4]
    1a5a:	460b      	mov	r3, r1
    1a5c:	f88d 3003 	strb.w	r3, [sp, #3]
    if (bEnable)
    1a60:	f89d 3003 	ldrb.w	r3, [sp, #3]
    1a64:	2b00      	cmp	r3, #0
    1a66:	d003      	beq.n	1a70 <Platform_Ipw_SetIrq+0x1c>
    {
        IntCtrl_Ip_EnableIrq(eIrqNumber);
    1a68:	9801      	ldr	r0, [sp, #4]
    1a6a:	f7ff ffba 	bl	19e2 <IntCtrl_Ip_EnableIrq>
    }
    else
    {
        IntCtrl_Ip_DisableIrq(eIrqNumber);
    }
}
    1a6e:	e002      	b.n	1a76 <Platform_Ipw_SetIrq+0x22>
        IntCtrl_Ip_DisableIrq(eIrqNumber);
    1a70:	9801      	ldr	r0, [sp, #4]
    1a72:	f7ff ffc0 	bl	19f6 <IntCtrl_Ip_DisableIrq>
}
    1a76:	bf00      	nop
    1a78:	b003      	add	sp, #12
    1a7a:	f85d fb04 	ldr.w	pc, [sp], #4

00001a7e <Platform_Ipw_SetIrqPriority>:
/**
 * @internal
 * @brief         Sets the priority of an interrupt by calling the Interrupt Controller IP layer.
 */
static inline void Platform_Ipw_SetIrqPriority(IRQn_Type eIrqNumber, uint8 u8Priority)
{
    1a7e:	b500      	push	{lr}
    1a80:	b083      	sub	sp, #12
    1a82:	9001      	str	r0, [sp, #4]
    1a84:	460b      	mov	r3, r1
    1a86:	f88d 3003 	strb.w	r3, [sp, #3]
    IntCtrl_Ip_SetPriority(eIrqNumber, u8Priority);
    1a8a:	f89d 3003 	ldrb.w	r3, [sp, #3]
    1a8e:	4619      	mov	r1, r3
    1a90:	9801      	ldr	r0, [sp, #4]
    1a92:	f7ff ffba 	bl	1a0a <IntCtrl_Ip_SetPriority>
}
    1a96:	bf00      	nop
    1a98:	b003      	add	sp, #12
    1a9a:	f85d fb04 	ldr.w	pc, [sp], #4

00001a9e <Platform_Ipw_GetIrqPriority>:
/**
 * @internal
 * @brief         Returns the priority of an interrupt by calling the Interrupt Controller IP layer.
 */
static inline uint8 Platform_Ipw_GetIrqPriority(IRQn_Type eIrqNumber)
{
    1a9e:	b500      	push	{lr}
    1aa0:	b083      	sub	sp, #12
    1aa2:	9001      	str	r0, [sp, #4]
    return IntCtrl_Ip_GetPriority(eIrqNumber);
    1aa4:	9801      	ldr	r0, [sp, #4]
    1aa6:	f7ff ffc0 	bl	1a2a <IntCtrl_Ip_GetPriority>
    1aaa:	4603      	mov	r3, r0
}
    1aac:	4618      	mov	r0, r3
    1aae:	b003      	add	sp, #12
    1ab0:	f85d fb04 	ldr.w	pc, [sp], #4

00001ab4 <Platform_Ipw_InstallIrqHandler>:
 * @brief         Installs a new interrupt handler by calling the Interrupt Controller IP layer.
 */
static inline void Platform_Ipw_InstallIrqHandler(IRQn_Type eIrqNumber,
                                                  const IntCtrl_Ip_IrqHandlerType pfNewHandler,
                                                  IntCtrl_Ip_IrqHandlerType* const pfOldHandler)
{
    1ab4:	b500      	push	{lr}
    1ab6:	b085      	sub	sp, #20
    1ab8:	9003      	str	r0, [sp, #12]
    1aba:	9102      	str	r1, [sp, #8]
    1abc:	9201      	str	r2, [sp, #4]
    IntCtrl_Ip_InstallHandler(eIrqNumber, pfNewHandler, pfOldHandler);
    1abe:	9a01      	ldr	r2, [sp, #4]
    1ac0:	9902      	ldr	r1, [sp, #8]
    1ac2:	9803      	ldr	r0, [sp, #12]
    1ac4:	f7ff ff7f 	bl	19c6 <IntCtrl_Ip_InstallHandler>
}
    1ac8:	bf00      	nop
    1aca:	b005      	add	sp, #20
    1acc:	f85d fb04 	ldr.w	pc, [sp], #4

00001ad0 <Platform_Init>:
 * @internal
 * @brief         Initializes the platform settings based on user configuration.
 * @implements    Platform_Init_Activity
 */
void Platform_Init(const Platform_ConfigType *pConfig)
{
    1ad0:	b500      	push	{lr}
    1ad2:	b085      	sub	sp, #20
    1ad4:	9001      	str	r0, [sp, #4]
    uint8 u8CoreId;

    u8CoreId = (uint8)Platform_GetCoreID();
    1ad6:	2300      	movs	r3, #0
    1ad8:	f88d 300f 	strb.w	r3, [sp, #15]
    (void)pConfig;
#if (PLATFORM_DEV_ERROR_DETECT == STD_ON)
    if (NULL_PTR != pConfig)
    1adc:	9b01      	ldr	r3, [sp, #4]
    1ade:	2b00      	cmp	r3, #0
    1ae0:	d006      	beq.n	1af0 <Platform_Init+0x20>
    {
        (void)Det_ReportError((uint16)CDD_PLATFORM_MODULE_ID, 0U, PLATFORM_INIT_ID, PLATFORM_E_PARAM_POINTER);
    1ae2:	2301      	movs	r3, #1
    1ae4:	2220      	movs	r2, #32
    1ae6:	2100      	movs	r1, #0
    1ae8:	20ff      	movs	r0, #255	; 0xff
    1aea:	f012 fc19 	bl	14320 <Det_ReportError>
        }
#endif /*(PLATFORM_MULTICORE_SUPPORT == STD_ON)*/
    }
#endif /* (PLATFORM_DEV_ERROR_DETECT == STD_ON)*/

}
    1aee:	e008      	b.n	1b02 <Platform_Init+0x32>
            Platform_Ipw_Init(Platform_Config[u8CoreId]->pIpwConfig);
    1af0:	f89d 300f 	ldrb.w	r3, [sp, #15]
    1af4:	4a05      	ldr	r2, [pc, #20]	; (1b0c <Platform_Init+0x3c>)
    1af6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    1afa:	681b      	ldr	r3, [r3, #0]
    1afc:	4618      	mov	r0, r3
    1afe:	f000 f917 	bl	1d30 <Platform_Ipw_Init>
}
    1b02:	bf00      	nop
    1b04:	b005      	add	sp, #20
    1b06:	f85d fb04 	ldr.w	pc, [sp], #4
    1b0a:	bf00      	nop
    1b0c:	000166c0 	.word	0x000166c0

00001b10 <Platform_SetIrq>:
 * @internal
 * @brief         Configures (enables/disables) an interrupt request.
 * @implements    Platform_SetIrq_Activity
 */
Std_ReturnType Platform_SetIrq(IRQn_Type eIrqNumber, boolean bEnable)
{
    1b10:	b500      	push	{lr}
    1b12:	b085      	sub	sp, #20
    1b14:	9001      	str	r0, [sp, #4]
    1b16:	460b      	mov	r3, r1
    1b18:	f88d 3003 	strb.w	r3, [sp, #3]
    Std_ReturnType RetValue = (Std_ReturnType)E_OK;
    1b1c:	2300      	movs	r3, #0
    1b1e:	f88d 300f 	strb.w	r3, [sp, #15]

#if (PLATFORM_DEV_ERROR_DETECT == STD_ON)
    if (((sint32)eIrqNumber > (sint32)INT_CTRL_IP_IRQ_MAX) || \
    1b22:	9b01      	ldr	r3, [sp, #4]
    1b24:	2b7a      	cmp	r3, #122	; 0x7a
    1b26:	dc02      	bgt.n	1b2e <Platform_SetIrq+0x1e>
    1b28:	9b01      	ldr	r3, [sp, #4]
    1b2a:	2b00      	cmp	r3, #0
    1b2c:	da09      	bge.n	1b42 <Platform_SetIrq+0x32>
        ((sint32)INT_CTRL_IP_IRQ_MIN > (sint32)eIrqNumber))
    {
        (void)Det_ReportError(CDD_PLATFORM_MODULE_ID, 0U, PLATFORM_SET_IRQ_ID, PLATFORM_E_PARAM_OUT_OF_RANGE);
    1b2e:	2302      	movs	r3, #2
    1b30:	2221      	movs	r2, #33	; 0x21
    1b32:	2100      	movs	r1, #0
    1b34:	20ff      	movs	r0, #255	; 0xff
    1b36:	f012 fbf3 	bl	14320 <Det_ReportError>
        RetValue = (Std_ReturnType)E_NOT_OK;
    1b3a:	2301      	movs	r3, #1
    1b3c:	f88d 300f 	strb.w	r3, [sp, #15]
    1b40:	e005      	b.n	1b4e <Platform_SetIrq+0x3e>
    }
    else
#endif
    {
        Platform_Ipw_SetIrq(eIrqNumber, bEnable);
    1b42:	f89d 3003 	ldrb.w	r3, [sp, #3]
    1b46:	4619      	mov	r1, r3
    1b48:	9801      	ldr	r0, [sp, #4]
    1b4a:	f7ff ff83 	bl	1a54 <Platform_Ipw_SetIrq>
    }
    return RetValue;
    1b4e:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    1b52:	4618      	mov	r0, r3
    1b54:	b005      	add	sp, #20
    1b56:	f85d fb04 	ldr.w	pc, [sp], #4

00001b5a <Platform_SetIrqPriority>:
 * @internal
 * @brief         Configures the priority of an interrupt request.
 * @implements    Platform_SetIrqPriority_Activity
 */
Std_ReturnType Platform_SetIrqPriority(IRQn_Type eIrqNumber, uint8 u8Priority)
{
    1b5a:	b500      	push	{lr}
    1b5c:	b085      	sub	sp, #20
    1b5e:	9001      	str	r0, [sp, #4]
    1b60:	460b      	mov	r3, r1
    1b62:	f88d 3003 	strb.w	r3, [sp, #3]
    Std_ReturnType RetValue = (Std_ReturnType)E_OK;
    1b66:	2300      	movs	r3, #0
    1b68:	f88d 300f 	strb.w	r3, [sp, #15]

#if (PLATFORM_DEV_ERROR_DETECT == STD_ON)
#if (INT_CTRL_IP_CORTEXM == STD_ON)
    if (((sint32)eIrqNumber > (sint32)INT_CTRL_IP_IRQ_MAX) || \
    1b6c:	9b01      	ldr	r3, [sp, #4]
    1b6e:	2b7a      	cmp	r3, #122	; 0x7a
    1b70:	dc06      	bgt.n	1b80 <Platform_SetIrqPriority+0x26>
    1b72:	9b01      	ldr	r3, [sp, #4]
    1b74:	2b00      	cmp	r3, #0
    1b76:	db03      	blt.n	1b80 <Platform_SetIrqPriority+0x26>
        ((sint32)INT_CTRL_IP_IRQ_MIN > (sint32)eIrqNumber) || \
    1b78:	f89d 3003 	ldrb.w	r3, [sp, #3]
    1b7c:	2b0f      	cmp	r3, #15
    1b7e:	d909      	bls.n	1b94 <Platform_SetIrqPriority+0x3a>
    if (((sint32)eIrqNumber > (sint32)INT_CTRL_IP_IRQ_MAX) || \
        ((sint32)INT_CTRL_IP_IRQ_MIN > (sint32)eIrqNumber) || \
        (u8Priority >= (uint8)(1U << INT_CTRL_IP_GIC_PRIO_BITS)))
#endif
    {
        (void)Det_ReportError(CDD_PLATFORM_MODULE_ID, 0U, PLATFORM_SET_IRQ_PRIO_ID, PLATFORM_E_PARAM_OUT_OF_RANGE);
    1b80:	2302      	movs	r3, #2
    1b82:	2222      	movs	r2, #34	; 0x22
    1b84:	2100      	movs	r1, #0
    1b86:	20ff      	movs	r0, #255	; 0xff
    1b88:	f012 fbca 	bl	14320 <Det_ReportError>
        RetValue = (Std_ReturnType)E_NOT_OK;
    1b8c:	2301      	movs	r3, #1
    1b8e:	f88d 300f 	strb.w	r3, [sp, #15]
    1b92:	e005      	b.n	1ba0 <Platform_SetIrqPriority+0x46>
    }
    else
#endif
    {
        Platform_Ipw_SetIrqPriority(eIrqNumber, u8Priority);
    1b94:	f89d 3003 	ldrb.w	r3, [sp, #3]
    1b98:	4619      	mov	r1, r3
    1b9a:	9801      	ldr	r0, [sp, #4]
    1b9c:	f7ff ff6f 	bl	1a7e <Platform_Ipw_SetIrqPriority>
    }
    return RetValue;
    1ba0:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    1ba4:	4618      	mov	r0, r3
    1ba6:	b005      	add	sp, #20
    1ba8:	f85d fb04 	ldr.w	pc, [sp], #4

00001bac <Platform_GetIrqPriority>:
 * @internal
 * @brief         Returns the priority of an interrupt request.
 * @implements    Platform_GetIrqPriority_Activity
 */
Std_ReturnType Platform_GetIrqPriority(IRQn_Type eIrqNumber, uint8 * u8Priority)
{
    1bac:	b500      	push	{lr}
    1bae:	b085      	sub	sp, #20
    1bb0:	9001      	str	r0, [sp, #4]
    1bb2:	9100      	str	r1, [sp, #0]
    Std_ReturnType RetValue = (Std_ReturnType)E_OK;
    1bb4:	2300      	movs	r3, #0
    1bb6:	f88d 300f 	strb.w	r3, [sp, #15]

#if (PLATFORM_DEV_ERROR_DETECT == STD_ON)
    if (((sint32)eIrqNumber > (sint32)INT_CTRL_IP_IRQ_MAX) || \
    1bba:	9b01      	ldr	r3, [sp, #4]
    1bbc:	2b7a      	cmp	r3, #122	; 0x7a
    1bbe:	dc02      	bgt.n	1bc6 <Platform_GetIrqPriority+0x1a>
    1bc0:	9b01      	ldr	r3, [sp, #4]
    1bc2:	2b00      	cmp	r3, #0
    1bc4:	da09      	bge.n	1bda <Platform_GetIrqPriority+0x2e>
        ((sint32)INT_CTRL_IP_IRQ_MIN > (sint32)eIrqNumber))
    {
        (void)Det_ReportError(CDD_PLATFORM_MODULE_ID, 0U, PLATFORM_GET_IRQ_PRIO_ID, PLATFORM_E_PARAM_OUT_OF_RANGE);
    1bc6:	2302      	movs	r3, #2
    1bc8:	2223      	movs	r2, #35	; 0x23
    1bca:	2100      	movs	r1, #0
    1bcc:	20ff      	movs	r0, #255	; 0xff
    1bce:	f012 fba7 	bl	14320 <Det_ReportError>
        RetValue = (Std_ReturnType)E_NOT_OK;
    1bd2:	2301      	movs	r3, #1
    1bd4:	f88d 300f 	strb.w	r3, [sp, #15]
    1bd8:	e013      	b.n	1c02 <Platform_GetIrqPriority+0x56>
    }
    else if (u8Priority == NULL_PTR)
    1bda:	9b00      	ldr	r3, [sp, #0]
    1bdc:	2b00      	cmp	r3, #0
    1bde:	d109      	bne.n	1bf4 <Platform_GetIrqPriority+0x48>
    {
        (void)Det_ReportError(CDD_PLATFORM_MODULE_ID, 0U, PLATFORM_GET_IRQ_PRIO_ID, PLATFORM_E_PARAM_POINTER);
    1be0:	2301      	movs	r3, #1
    1be2:	2223      	movs	r2, #35	; 0x23
    1be4:	2100      	movs	r1, #0
    1be6:	20ff      	movs	r0, #255	; 0xff
    1be8:	f012 fb9a 	bl	14320 <Det_ReportError>
        RetValue = (Std_ReturnType)E_NOT_OK;
    1bec:	2301      	movs	r3, #1
    1bee:	f88d 300f 	strb.w	r3, [sp, #15]
    1bf2:	e006      	b.n	1c02 <Platform_GetIrqPriority+0x56>
    }
    else
#endif
    {
        *u8Priority = Platform_Ipw_GetIrqPriority(eIrqNumber);
    1bf4:	9801      	ldr	r0, [sp, #4]
    1bf6:	f7ff ff52 	bl	1a9e <Platform_Ipw_GetIrqPriority>
    1bfa:	4603      	mov	r3, r0
    1bfc:	461a      	mov	r2, r3
    1bfe:	9b00      	ldr	r3, [sp, #0]
    1c00:	701a      	strb	r2, [r3, #0]
    }

    return RetValue;
    1c02:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    1c06:	4618      	mov	r0, r3
    1c08:	b005      	add	sp, #20
    1c0a:	f85d fb04 	ldr.w	pc, [sp], #4

00001c0e <Platform_InstallIrqHandler>:
 * @implements    Platform_InstallIrqHandler_Activity
 */
Std_ReturnType Platform_InstallIrqHandler(IRQn_Type eIrqNumber,
                                          const Platform_IrqHandlerType pfNewHandler,
                                          Platform_IrqHandlerType* const pfOldHandler)
{
    1c0e:	b500      	push	{lr}
    1c10:	b087      	sub	sp, #28
    1c12:	9003      	str	r0, [sp, #12]
    1c14:	9102      	str	r1, [sp, #8]
    1c16:	9201      	str	r2, [sp, #4]
    Std_ReturnType RetValue = (Std_ReturnType)E_OK;
    1c18:	2300      	movs	r3, #0
    1c1a:	f88d 3017 	strb.w	r3, [sp, #23]

#if (PLATFORM_DEV_ERROR_DETECT == STD_ON)
    if (((sint32)eIrqNumber > (sint32)INT_CTRL_IP_IRQ_MAX) || \
    1c1e:	9b03      	ldr	r3, [sp, #12]
    1c20:	2b7a      	cmp	r3, #122	; 0x7a
    1c22:	dc02      	bgt.n	1c2a <Platform_InstallIrqHandler+0x1c>
    1c24:	9b03      	ldr	r3, [sp, #12]
    1c26:	2b00      	cmp	r3, #0
    1c28:	da09      	bge.n	1c3e <Platform_InstallIrqHandler+0x30>
        ((sint32)INT_CTRL_IP_IRQ_MIN > (sint32)eIrqNumber))
    {
        (void)Det_ReportError(CDD_PLATFORM_MODULE_ID, 0U, PLATFORM_INSTALL_HANDLER_ID, PLATFORM_E_PARAM_OUT_OF_RANGE);
    1c2a:	2302      	movs	r3, #2
    1c2c:	2224      	movs	r2, #36	; 0x24
    1c2e:	2100      	movs	r1, #0
    1c30:	20ff      	movs	r0, #255	; 0xff
    1c32:	f012 fb75 	bl	14320 <Det_ReportError>
        RetValue = (Std_ReturnType)E_NOT_OK;
    1c36:	2301      	movs	r3, #1
    1c38:	f88d 3017 	strb.w	r3, [sp, #23]
    1c3c:	e004      	b.n	1c48 <Platform_InstallIrqHandler+0x3a>
    }
    else
#endif
    {
        Platform_Ipw_InstallIrqHandler(eIrqNumber, pfNewHandler, pfOldHandler);
    1c3e:	9a01      	ldr	r2, [sp, #4]
    1c40:	9902      	ldr	r1, [sp, #8]
    1c42:	9803      	ldr	r0, [sp, #12]
    1c44:	f7ff ff36 	bl	1ab4 <Platform_Ipw_InstallIrqHandler>
    }
    return RetValue;
    1c48:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    1c4c:	4618      	mov	r0, r3
    1c4e:	b007      	add	sp, #28
    1c50:	f85d fb04 	ldr.w	pc, [sp], #4

00001c54 <Platform_Ipw_InitIntCtrl>:
#endif



static Std_ReturnType Platform_Ipw_InitIntCtrl(const IntCtrl_Ip_CtrlConfigType *pIntCtrlCtrlConfig)
{
    1c54:	b500      	push	{lr}
    1c56:	b085      	sub	sp, #20
    1c58:	9001      	str	r0, [sp, #4]
    uint32 irqIdx;
    
    for (irqIdx = 0; irqIdx < pIntCtrlCtrlConfig->u32ConfigIrqCount; irqIdx++)
    1c5a:	2300      	movs	r3, #0
    1c5c:	9303      	str	r3, [sp, #12]
    1c5e:	e05d      	b.n	1d1c <Platform_Ipw_InitIntCtrl+0xc8>
    {   
        IntCtrl_Ip_ClearPending(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
    1c60:	9b01      	ldr	r3, [sp, #4]
    1c62:	6859      	ldr	r1, [r3, #4]
    1c64:	9a03      	ldr	r2, [sp, #12]
    1c66:	4613      	mov	r3, r2
    1c68:	005b      	lsls	r3, r3, #1
    1c6a:	4413      	add	r3, r2
    1c6c:	009b      	lsls	r3, r3, #2
    1c6e:	440b      	add	r3, r1
    1c70:	681b      	ldr	r3, [r3, #0]
    1c72:	4618      	mov	r0, r3
    1c74:	f7ff fee4 	bl	1a40 <IntCtrl_Ip_ClearPending>
        /* interrupt number for which the priority is set */
        IntCtrl_Ip_SetPriority(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    1c78:	9b01      	ldr	r3, [sp, #4]
    1c7a:	6859      	ldr	r1, [r3, #4]
    1c7c:	9a03      	ldr	r2, [sp, #12]
    1c7e:	4613      	mov	r3, r2
    1c80:	005b      	lsls	r3, r3, #1
    1c82:	4413      	add	r3, r2
    1c84:	009b      	lsls	r3, r3, #2
    1c86:	440b      	add	r3, r1
    1c88:	6818      	ldr	r0, [r3, #0]
                               pIntCtrlCtrlConfig->aIrqConfig[irqIdx].u8IrqPriority);
    1c8a:	9b01      	ldr	r3, [sp, #4]
    1c8c:	6859      	ldr	r1, [r3, #4]
    1c8e:	9a03      	ldr	r2, [sp, #12]
    1c90:	4613      	mov	r3, r2
    1c92:	005b      	lsls	r3, r3, #1
    1c94:	4413      	add	r3, r2
    1c96:	009b      	lsls	r3, r3, #2
    1c98:	440b      	add	r3, r1
        IntCtrl_Ip_SetPriority(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    1c9a:	795b      	ldrb	r3, [r3, #5]
    1c9c:	4619      	mov	r1, r3
    1c9e:	f7ff feb4 	bl	1a0a <IntCtrl_Ip_SetPriority>
        /* Install the configured handler */
        IntCtrl_Ip_InstallHandler(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    1ca2:	9b01      	ldr	r3, [sp, #4]
    1ca4:	6859      	ldr	r1, [r3, #4]
    1ca6:	9a03      	ldr	r2, [sp, #12]
    1ca8:	4613      	mov	r3, r2
    1caa:	005b      	lsls	r3, r3, #1
    1cac:	4413      	add	r3, r2
    1cae:	009b      	lsls	r3, r3, #2
    1cb0:	440b      	add	r3, r1
    1cb2:	6818      	ldr	r0, [r3, #0]
                                  pIntCtrlCtrlConfig->aIrqConfig[irqIdx].pfHandler,
    1cb4:	9b01      	ldr	r3, [sp, #4]
    1cb6:	6859      	ldr	r1, [r3, #4]
    1cb8:	9a03      	ldr	r2, [sp, #12]
    1cba:	4613      	mov	r3, r2
    1cbc:	005b      	lsls	r3, r3, #1
    1cbe:	4413      	add	r3, r2
    1cc0:	009b      	lsls	r3, r3, #2
    1cc2:	440b      	add	r3, r1
        IntCtrl_Ip_InstallHandler(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber,
    1cc4:	689b      	ldr	r3, [r3, #8]
    1cc6:	2200      	movs	r2, #0
    1cc8:	4619      	mov	r1, r3
    1cca:	f7ff fe7c 	bl	19c6 <IntCtrl_Ip_InstallHandler>
                                  NULL_PTR);

        /* Enable interrupt */                       
        if (pIntCtrlCtrlConfig->aIrqConfig[irqIdx].bIrqEnabled)
    1cce:	9b01      	ldr	r3, [sp, #4]
    1cd0:	6859      	ldr	r1, [r3, #4]
    1cd2:	9a03      	ldr	r2, [sp, #12]
    1cd4:	4613      	mov	r3, r2
    1cd6:	005b      	lsls	r3, r3, #1
    1cd8:	4413      	add	r3, r2
    1cda:	009b      	lsls	r3, r3, #2
    1cdc:	440b      	add	r3, r1
    1cde:	791b      	ldrb	r3, [r3, #4]
    1ce0:	2b00      	cmp	r3, #0
    1ce2:	d00c      	beq.n	1cfe <Platform_Ipw_InitIntCtrl+0xaa>
        {   
            /* enables the interrupt request at interrupt controller level. */
            IntCtrl_Ip_EnableIrq(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
    1ce4:	9b01      	ldr	r3, [sp, #4]
    1ce6:	6859      	ldr	r1, [r3, #4]
    1ce8:	9a03      	ldr	r2, [sp, #12]
    1cea:	4613      	mov	r3, r2
    1cec:	005b      	lsls	r3, r3, #1
    1cee:	4413      	add	r3, r2
    1cf0:	009b      	lsls	r3, r3, #2
    1cf2:	440b      	add	r3, r1
    1cf4:	681b      	ldr	r3, [r3, #0]
    1cf6:	4618      	mov	r0, r3
    1cf8:	f7ff fe73 	bl	19e2 <IntCtrl_Ip_EnableIrq>
    1cfc:	e00b      	b.n	1d16 <Platform_Ipw_InitIntCtrl+0xc2>
        }
        else
        {   
            /* disables the interrupt request at interrupt controller level.*/
            IntCtrl_Ip_DisableIrq(pIntCtrlCtrlConfig->aIrqConfig[irqIdx].eIrqNumber);
    1cfe:	9b01      	ldr	r3, [sp, #4]
    1d00:	6859      	ldr	r1, [r3, #4]
    1d02:	9a03      	ldr	r2, [sp, #12]
    1d04:	4613      	mov	r3, r2
    1d06:	005b      	lsls	r3, r3, #1
    1d08:	4413      	add	r3, r2
    1d0a:	009b      	lsls	r3, r3, #2
    1d0c:	440b      	add	r3, r1
    1d0e:	681b      	ldr	r3, [r3, #0]
    1d10:	4618      	mov	r0, r3
    1d12:	f7ff fe70 	bl	19f6 <IntCtrl_Ip_DisableIrq>
    for (irqIdx = 0; irqIdx < pIntCtrlCtrlConfig->u32ConfigIrqCount; irqIdx++)
    1d16:	9b03      	ldr	r3, [sp, #12]
    1d18:	3301      	adds	r3, #1
    1d1a:	9303      	str	r3, [sp, #12]
    1d1c:	9b01      	ldr	r3, [sp, #4]
    1d1e:	681b      	ldr	r3, [r3, #0]
    1d20:	9a03      	ldr	r2, [sp, #12]
    1d22:	429a      	cmp	r2, r3
    1d24:	d39c      	bcc.n	1c60 <Platform_Ipw_InitIntCtrl+0xc>
        }
    }

    return E_OK;
    1d26:	2300      	movs	r3, #0
}
    1d28:	4618      	mov	r0, r3
    1d2a:	b005      	add	sp, #20
    1d2c:	f85d fb04 	ldr.w	pc, [sp], #4

00001d30 <Platform_Ipw_Init>:

/**
 * @brief         Initializes the platform settings based on user configuration.
 */
void Platform_Ipw_Init(const Platform_Ipw_ConfigType *pConfig)
{    
    1d30:	b500      	push	{lr}
    1d32:	b085      	sub	sp, #20
    1d34:	9001      	str	r0, [sp, #4]
#if ((PLATFORM_SYS_CFG == STD_ON)&&(INT_CTRL_IP_CORTEXM == STD_ON))
    uint8 irqIdx;
#endif
    Std_ReturnType ret = (Std_ReturnType)E_OK;
    1d36:	2300      	movs	r3, #0
    1d38:	f88d 300f 	strb.w	r3, [sp, #15]

    /* Initialize interrupts at interrupt controller level */
    if (NULL_PTR != pConfig->pIntCtrlConfig)
    1d3c:	9b01      	ldr	r3, [sp, #4]
    1d3e:	681b      	ldr	r3, [r3, #0]
    1d40:	2b00      	cmp	r3, #0
    1d42:	d007      	beq.n	1d54 <Platform_Ipw_Init+0x24>
    {
        ret = Platform_Ipw_InitIntCtrl(pConfig->pIntCtrlConfig);
    1d44:	9b01      	ldr	r3, [sp, #4]
    1d46:	681b      	ldr	r3, [r3, #0]
    1d48:	4618      	mov	r0, r3
    1d4a:	f7ff ff83 	bl	1c54 <Platform_Ipw_InitIntCtrl>
    1d4e:	4603      	mov	r3, r0
    1d50:	f88d 300f 	strb.w	r3, [sp, #15]
    }

    if(ret == (Std_ReturnType)E_OK)
    1d54:	f89d 300f 	ldrb.w	r3, [sp, #15]
    1d58:	2b00      	cmp	r3, #0
            /* Call_System_Ip_SetAhbSlavePriority((pConfig->aSystemConfig)->bAhbSlavePriority); */
#endif
        }  
#endif
    }
}
    1d5a:	bf00      	nop
    1d5c:	b005      	add	sp, #20
    1d5e:	f85d fb04 	ldr.w	pc, [sp], #4

00001d62 <OsIf_Timer_Dummy_GetCounter>:
 * Description   : Get counter value.
 * 
 *END**************************************************************************/
static inline uint32 OsIf_Timer_Dummy_GetCounter(void)
{
    return 0U;
    1d62:	2300      	movs	r3, #0
}
    1d64:	4618      	mov	r0, r3
    1d66:	4770      	bx	lr

00001d68 <OsIf_Timer_Dummy_GetElapsed>:
 * Function Name : OsIf_Timer_Dummy_GetElapsed.
 * Description   : Get elapsed value.
 * 
 *END**************************************************************************/
static inline uint32 OsIf_Timer_Dummy_GetElapsed(const uint32 * const CurrentRef)
{
    1d68:	b082      	sub	sp, #8
    1d6a:	9001      	str	r0, [sp, #4]
    (void)CurrentRef;
    return 1U;
    1d6c:	2301      	movs	r3, #1
}
    1d6e:	4618      	mov	r0, r3
    1d70:	b002      	add	sp, #8
    1d72:	4770      	bx	lr

00001d74 <OsIf_Timer_Dummy_SetTimerFrequency>:
 * Function Name : OsIf_Timer_Dummy_SetTimerFrequency.
 * Description   : Set timer frequency.
 * 
 *END**************************************************************************/
static inline void OsIf_Timer_Dummy_SetTimerFrequency(uint32 Freq)
{
    1d74:	b082      	sub	sp, #8
    1d76:	9001      	str	r0, [sp, #4]
    (void)Freq;
}
    1d78:	bf00      	nop
    1d7a:	b002      	add	sp, #8
    1d7c:	4770      	bx	lr

00001d7e <OsIf_Timer_Dummy_MicrosToTicks>:
 * Function Name : OsIf_Timer_Dummy_MicrosToTicks.
 * Description   : Convert micro second to ticks.
 * 
 *END**************************************************************************/
static inline uint32 OsIf_Timer_Dummy_MicrosToTicks(uint32 Micros)
{
    1d7e:	b082      	sub	sp, #8
    1d80:	9001      	str	r0, [sp, #4]
    return Micros;
    1d82:	9b01      	ldr	r3, [sp, #4]
}
    1d84:	4618      	mov	r0, r3
    1d86:	b002      	add	sp, #8
    1d88:	4770      	bx	lr

00001d8a <OsIf_Init>:
 * Description   : OsIf initialization.
 * @implements OsIf_Init_Activity
 * 
 *END**************************************************************************/
void OsIf_Init(const void* Config)
{
    1d8a:	b500      	push	{lr}
    1d8c:	b083      	sub	sp, #12
    1d8e:	9001      	str	r0, [sp, #4]
#else
    (void)Config;
#endif /* (STD_ON == OSIF_DEV_ERROR_DETECT) */

#if (OSIF_USE_SYSTEM_TIMER == STD_ON)
    OsIf_Timer_System_Init();
    1d90:	f000 f86c 	bl	1e6c <OsIf_Timer_System_Init>
#endif /* (OSIF_USE_SYSTEM_TIMER == STD_ON) */
#if (OSIF_USE_CUSTOM_TIMER == STD_ON)
    OsIf_Timer_Custom_Init();
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
}
    1d94:	bf00      	nop
    1d96:	b003      	add	sp, #12
    1d98:	f85d fb04 	ldr.w	pc, [sp], #4

00001d9c <OsIf_GetCounter>:
 * Description   : Get counter value.
 * @implements OsIf_GetCounter_Activity
 * 
 *END**************************************************************************/
uint32 OsIf_GetCounter(OsIf_CounterType SelectedCounter)
{
    1d9c:	b500      	push	{lr}
    1d9e:	b085      	sub	sp, #20
    1da0:	9001      	str	r0, [sp, #4]
    uint32 Value = 0U;
    1da2:	2300      	movs	r3, #0
    1da4:	9303      	str	r3, [sp, #12]

    switch (SelectedCounter){
    1da6:	9b01      	ldr	r3, [sp, #4]
    1da8:	2b00      	cmp	r3, #0
    1daa:	d003      	beq.n	1db4 <OsIf_GetCounter+0x18>
    1dac:	9b01      	ldr	r3, [sp, #4]
    1dae:	2b01      	cmp	r3, #1
    1db0:	d004      	beq.n	1dbc <OsIf_GetCounter+0x20>
            Value = OsIf_Timer_Custom_GetCounter();
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
    1db2:	e007      	b.n	1dc4 <OsIf_GetCounter+0x28>
            Value = OsIf_Timer_Dummy_GetCounter();
    1db4:	f7ff ffd5 	bl	1d62 <OsIf_Timer_Dummy_GetCounter>
    1db8:	9003      	str	r0, [sp, #12]
            break;
    1dba:	e003      	b.n	1dc4 <OsIf_GetCounter+0x28>
            Value = OsIf_Timer_System_GetCounter();
    1dbc:	f000 f872 	bl	1ea4 <OsIf_Timer_System_GetCounter>
    1dc0:	9003      	str	r0, [sp, #12]
            break;
    1dc2:	bf00      	nop
    }

    return Value;
    1dc4:	9b03      	ldr	r3, [sp, #12]
}
    1dc6:	4618      	mov	r0, r3
    1dc8:	b005      	add	sp, #20
    1dca:	f85d fb04 	ldr.w	pc, [sp], #4

00001dce <OsIf_GetElapsed>:
 * Description   : Get elapsed value.
 * @implements OsIf_GetElapsed_Activity
 * 
 *END**************************************************************************/
uint32 OsIf_GetElapsed(uint32 * const CurrentRef, OsIf_CounterType SelectedCounter)
{
    1dce:	b500      	push	{lr}
    1dd0:	b085      	sub	sp, #20
    1dd2:	9001      	str	r0, [sp, #4]
    1dd4:	9100      	str	r1, [sp, #0]
    uint32 Value = 0U;
    1dd6:	2300      	movs	r3, #0
    1dd8:	9303      	str	r3, [sp, #12]

    switch (SelectedCounter){
    1dda:	9b00      	ldr	r3, [sp, #0]
    1ddc:	2b00      	cmp	r3, #0
    1dde:	d003      	beq.n	1de8 <OsIf_GetElapsed+0x1a>
    1de0:	9b00      	ldr	r3, [sp, #0]
    1de2:	2b01      	cmp	r3, #1
    1de4:	d005      	beq.n	1df2 <OsIf_GetElapsed+0x24>
            Value = OsIf_Timer_Custom_GetElapsed(CurrentRef);
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
    1de6:	e009      	b.n	1dfc <OsIf_GetElapsed+0x2e>
            Value = OsIf_Timer_Dummy_GetElapsed(CurrentRef);
    1de8:	9801      	ldr	r0, [sp, #4]
    1dea:	f7ff ffbd 	bl	1d68 <OsIf_Timer_Dummy_GetElapsed>
    1dee:	9003      	str	r0, [sp, #12]
            break;
    1df0:	e004      	b.n	1dfc <OsIf_GetElapsed+0x2e>
            Value = OsIf_Timer_System_GetElapsed(CurrentRef);
    1df2:	9801      	ldr	r0, [sp, #4]
    1df4:	f000 f864 	bl	1ec0 <OsIf_Timer_System_GetElapsed>
    1df8:	9003      	str	r0, [sp, #12]
            break;
    1dfa:	bf00      	nop
    }

    return Value;
    1dfc:	9b03      	ldr	r3, [sp, #12]
}
    1dfe:	4618      	mov	r0, r3
    1e00:	b005      	add	sp, #20
    1e02:	f85d fb04 	ldr.w	pc, [sp], #4

00001e06 <OsIf_SetTimerFrequency>:
 * @implements OsIf_SetTimerFrequency_Activity
 * 
 *END**************************************************************************/
/* @implements OsIf_SetTimerFrequency_Activity */
void OsIf_SetTimerFrequency(uint32 Freq, OsIf_CounterType SelectedCounter)
{
    1e06:	b500      	push	{lr}
    1e08:	b083      	sub	sp, #12
    1e0a:	9001      	str	r0, [sp, #4]
    1e0c:	9100      	str	r1, [sp, #0]
    switch (SelectedCounter){
    1e0e:	9b00      	ldr	r3, [sp, #0]
    1e10:	2b00      	cmp	r3, #0
    1e12:	d003      	beq.n	1e1c <OsIf_SetTimerFrequency+0x16>
    1e14:	9b00      	ldr	r3, [sp, #0]
    1e16:	2b01      	cmp	r3, #1
    1e18:	d004      	beq.n	1e24 <OsIf_SetTimerFrequency+0x1e>
            OsIf_Timer_Custom_SetTimerFrequency(Freq);
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
    1e1a:	e007      	b.n	1e2c <OsIf_SetTimerFrequency+0x26>
            OsIf_Timer_Dummy_SetTimerFrequency(Freq);
    1e1c:	9801      	ldr	r0, [sp, #4]
    1e1e:	f7ff ffa9 	bl	1d74 <OsIf_Timer_Dummy_SetTimerFrequency>
            break;
    1e22:	e003      	b.n	1e2c <OsIf_SetTimerFrequency+0x26>
            OsIf_Timer_System_SetTimerFrequency(Freq);
    1e24:	9801      	ldr	r0, [sp, #4]
    1e26:	f000 f85b 	bl	1ee0 <OsIf_Timer_System_SetTimerFrequency>
            break;
    1e2a:	bf00      	nop
    }
}
    1e2c:	bf00      	nop
    1e2e:	b003      	add	sp, #12
    1e30:	f85d fb04 	ldr.w	pc, [sp], #4

00001e34 <OsIf_MicrosToTicks>:
 * Description   : Convert micro second to ticks.
 * @implements OsIf_MicrosToTicks_Activity
 * 
 *END**************************************************************************/
uint32 OsIf_MicrosToTicks(uint32 Micros, OsIf_CounterType SelectedCounter)
{
    1e34:	b500      	push	{lr}
    1e36:	b085      	sub	sp, #20
    1e38:	9001      	str	r0, [sp, #4]
    1e3a:	9100      	str	r1, [sp, #0]
    uint32 Value = 0U;
    1e3c:	2300      	movs	r3, #0
    1e3e:	9303      	str	r3, [sp, #12]

    switch (SelectedCounter){
    1e40:	9b00      	ldr	r3, [sp, #0]
    1e42:	2b00      	cmp	r3, #0
    1e44:	d003      	beq.n	1e4e <OsIf_MicrosToTicks+0x1a>
    1e46:	9b00      	ldr	r3, [sp, #0]
    1e48:	2b01      	cmp	r3, #1
    1e4a:	d005      	beq.n	1e58 <OsIf_MicrosToTicks+0x24>
            Value = OsIf_Timer_Custom_MicrosToTicks(Micros);
            break;
#endif /* (OSIF_USE_CUSTOM_TIMER == STD_ON) */
        default:
            /* impossible */
            break;
    1e4c:	e009      	b.n	1e62 <OsIf_MicrosToTicks+0x2e>
            Value = OsIf_Timer_Dummy_MicrosToTicks(Micros);
    1e4e:	9801      	ldr	r0, [sp, #4]
    1e50:	f7ff ff95 	bl	1d7e <OsIf_Timer_Dummy_MicrosToTicks>
    1e54:	9003      	str	r0, [sp, #12]
            break;
    1e56:	e004      	b.n	1e62 <OsIf_MicrosToTicks+0x2e>
            Value = OsIf_Timer_System_MicrosToTicks(Micros);
    1e58:	9801      	ldr	r0, [sp, #4]
    1e5a:	f000 f84f 	bl	1efc <OsIf_Timer_System_MicrosToTicks>
    1e5e:	9003      	str	r0, [sp, #12]
            break;
    1e60:	bf00      	nop
    }

    return Value;
    1e62:	9b03      	ldr	r3, [sp, #12]
}
    1e64:	4618      	mov	r0, r3
    1e66:	b005      	add	sp, #20
    1e68:	f85d fb04 	ldr.w	pc, [sp], #4

00001e6c <OsIf_Timer_System_Init>:
 * Function Name : OsIf_Timer_System_Init.
 * Description   : Initialize system timer.
 * 
 *END**************************************************************************/
void OsIf_Timer_System_Init(void)
{
    1e6c:	b500      	push	{lr}
    1e6e:	b083      	sub	sp, #12
    uint32 CoreId = OsIfCoreID();
    1e70:	2300      	movs	r3, #0
    1e72:	9301      	str	r3, [sp, #4]

#if (defined(USING_OS_AUTOSAROS) || (STD_ON == OSIF_DEV_ERROR_DETECT))
    OsIf_apxInternalCfg[CoreId] = OsIf_apxPredefinedConfig[CoreId];
#endif /* (defined(USING_OS_AUTOSAROS) || (STD_ON == OSIF_DEV_ERROR_DETECT)) */
#if (!defined(USING_OS_FREERTOS) && !defined(USING_OS_ZEPHYR))
    OsIf_au32InternalFrequencies[CoreId] = OsIf_apxPredefinedConfig[CoreId]->counterFrequency;
    1e74:	4a09      	ldr	r2, [pc, #36]	; (1e9c <OsIf_Timer_System_Init+0x30>)
    1e76:	9b01      	ldr	r3, [sp, #4]
    1e78:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    1e7c:	685a      	ldr	r2, [r3, #4]
    1e7e:	4908      	ldr	r1, [pc, #32]	; (1ea0 <OsIf_Timer_System_Init+0x34>)
    1e80:	9b01      	ldr	r3, [sp, #4]
    1e82:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#elif defined(USING_OS_ZEPHYR)
    /* ZephyrOS */
    OsIf_au32InternalFrequencies[CoreId] = sys_clock_hw_cycles_per_sec();
#elif defined(USING_OS_BAREMETAL)
    /* Baremetal */
    Trusted_OsIf_Timer_System_Internal_Init(OsIf_au32InternalFrequencies[CoreId]);
    1e86:	4a06      	ldr	r2, [pc, #24]	; (1ea0 <OsIf_Timer_System_Init+0x34>)
    1e88:	9b01      	ldr	r3, [sp, #4]
    1e8a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    1e8e:	4618      	mov	r0, r3
    1e90:	f000 f868 	bl	1f64 <OsIf_Timer_System_Internal_Init>
#endif
#if (STD_ON == OSIF_DEV_ERROR_DETECT)
    }
#endif /* (STD_ON == OSIF_DEV_ERROR_DETECT) */
}
    1e94:	bf00      	nop
    1e96:	b003      	add	sp, #12
    1e98:	f85d fb04 	ldr.w	pc, [sp], #4
    1e9c:	000166b8 	.word	0x000166b8
    1ea0:	1fff8b34 	.word	0x1fff8b34

00001ea4 <OsIf_Timer_System_GetCounter>:
 * Function Name : OsIf_Timer_System_GetCounter.
 * Description   : Get counter value from system timer.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_GetCounter(void)
{
    1ea4:	b500      	push	{lr}
    1ea6:	b083      	sub	sp, #12
    uint32 Counter = 0U;
    1ea8:	2300      	movs	r3, #0
    1eaa:	9301      	str	r3, [sp, #4]
    uint32 CoreId = OsIfCoreID();
    1eac:	2300      	movs	r3, #0
    1eae:	9300      	str	r3, [sp, #0]
        (void)CoreId;
        Counter = Trusted_k_cycle_get_32();
#elif defined(USING_OS_FREERTOS) || defined(USING_OS_BAREMETAL)
        /* FreeRTOS and Baremetal*/
        (void)CoreId;
        Counter = Trusted_OsIf_Timer_System_Internal_GetCounter();
    1eb0:	f000 f86c 	bl	1f8c <OsIf_Timer_System_Internal_GetCounter>
    1eb4:	9001      	str	r0, [sp, #4]
#endif
    }

    return Counter;
    1eb6:	9b01      	ldr	r3, [sp, #4]
}
    1eb8:	4618      	mov	r0, r3
    1eba:	b003      	add	sp, #12
    1ebc:	f85d fb04 	ldr.w	pc, [sp], #4

00001ec0 <OsIf_Timer_System_GetElapsed>:
 * Function Name : OsIf_Timer_System_GetElapsed.
 * Description   : Get elapsed value from system timer.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_GetElapsed(uint32 * const CurrentRef)
{
    1ec0:	b500      	push	{lr}
    1ec2:	b085      	sub	sp, #20
    1ec4:	9001      	str	r0, [sp, #4]
    uint32 Elapsed = 0U;
    1ec6:	2300      	movs	r3, #0
    1ec8:	9303      	str	r3, [sp, #12]
    uint32 CoreId = OsIfCoreID();
    1eca:	2300      	movs	r3, #0
    1ecc:	9302      	str	r3, [sp, #8]
        *CurrentRef = CurrentVal;
        (void)CoreId;
#elif defined(USING_OS_FREERTOS) || defined(USING_OS_BAREMETAL)
        /* FreeRTOS and Baremetal*/
        (void)CoreId;
        Elapsed = Trusted_OsIf_Timer_System_Internal_GetElapsed(CurrentRef);
    1ece:	9801      	ldr	r0, [sp, #4]
    1ed0:	f000 f864 	bl	1f9c <OsIf_Timer_System_Internal_GetElapsed>
    1ed4:	9003      	str	r0, [sp, #12]
#endif
    }

    return Elapsed;
    1ed6:	9b03      	ldr	r3, [sp, #12]
}
    1ed8:	4618      	mov	r0, r3
    1eda:	b005      	add	sp, #20
    1edc:	f85d fb04 	ldr.w	pc, [sp], #4

00001ee0 <OsIf_Timer_System_SetTimerFrequency>:
 * Function Name : OsIf_Timer_System_SetTimerFrequency.
 * Description   : Set system timer frequency.
 * 
 *END**************************************************************************/
void OsIf_Timer_System_SetTimerFrequency(uint32 Freq)
{
    1ee0:	b084      	sub	sp, #16
    1ee2:	9001      	str	r0, [sp, #4]
    uint32 CoreId = OsIfCoreID();
    1ee4:	2300      	movs	r3, #0
    1ee6:	9303      	str	r3, [sp, #12]
        (void)CoreId;
        (void)Freq;
        /* As of 2.6.0: "The frequency of this counter is required to be steady over time" */
#elif defined(USING_OS_FREERTOS) || defined(USING_OS_BAREMETAL)
        /* FreeRTOS and Baremetal*/
        OsIf_au32InternalFrequencies[CoreId] = Freq;
    1ee8:	4903      	ldr	r1, [pc, #12]	; (1ef8 <OsIf_Timer_System_SetTimerFrequency+0x18>)
    1eea:	9b03      	ldr	r3, [sp, #12]
    1eec:	9a01      	ldr	r2, [sp, #4]
    1eee:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif
    }
}
    1ef2:	bf00      	nop
    1ef4:	b004      	add	sp, #16
    1ef6:	4770      	bx	lr
    1ef8:	1fff8b34 	.word	0x1fff8b34

00001efc <OsIf_Timer_System_MicrosToTicks>:
 * Function Name : OsIf_Timer_System_MicrosToTicks.
 * Description   : Convert micro second to ticks based on system timer frequency.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_MicrosToTicks(uint32 Micros)
{
    1efc:	b5f0      	push	{r4, r5, r6, r7, lr}
    1efe:	b087      	sub	sp, #28
    1f00:	9001      	str	r0, [sp, #4]
    uint64 interim;
    uint32 ticks = 0U;
    1f02:	2100      	movs	r1, #0
    1f04:	9105      	str	r1, [sp, #20]
    uint32 CoreId = OsIfCoreID();
    1f06:	2100      	movs	r1, #0
    1f08:	9104      	str	r1, [sp, #16]
    #endif /* defined(USING_OS_AUTOSAROS) */
    }
    else
#endif /* (STD_ON == OSIF_DEV_ERROR_DETECT)  */
    {
        interim = Micros * (uint64)OsIf_au32InternalFrequencies[CoreId];
    1f0a:	9901      	ldr	r1, [sp, #4]
    1f0c:	2000      	movs	r0, #0
    1f0e:	460e      	mov	r6, r1
    1f10:	4607      	mov	r7, r0
    1f12:	4812      	ldr	r0, [pc, #72]	; (1f5c <OsIf_Timer_System_MicrosToTicks+0x60>)
    1f14:	9904      	ldr	r1, [sp, #16]
    1f16:	f850 1021 	ldr.w	r1, [r0, r1, lsl #2]
    1f1a:	2000      	movs	r0, #0
    1f1c:	460c      	mov	r4, r1
    1f1e:	4605      	mov	r5, r0
    1f20:	fb04 f007 	mul.w	r0, r4, r7
    1f24:	fb06 f105 	mul.w	r1, r6, r5
    1f28:	4401      	add	r1, r0
    1f2a:	fba6 2304 	umull	r2, r3, r6, r4
    1f2e:	4419      	add	r1, r3
    1f30:	460b      	mov	r3, r1
    1f32:	e9cd 2302 	strd	r2, r3, [sp, #8]
    1f36:	e9cd 2302 	strd	r2, r3, [sp, #8]
        interim /= 1000000u;
    1f3a:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
    1f3e:	4a08      	ldr	r2, [pc, #32]	; (1f60 <OsIf_Timer_System_MicrosToTicks+0x64>)
    1f40:	f04f 0300 	mov.w	r3, #0
    1f44:	f7fe fb2e 	bl	5a4 <__aeabi_uldivmod>
    1f48:	4602      	mov	r2, r0
    1f4a:	460b      	mov	r3, r1
    1f4c:	e9cd 2302 	strd	r2, r3, [sp, #8]
        /* check that computed value fits in 32 bits */
        OSIF_DEV_ASSERT(interim <= 0xFFFFFFFFu);
        ticks = (uint32)(interim & 0xFFFFFFFFu);
    1f50:	9b02      	ldr	r3, [sp, #8]
    1f52:	9305      	str	r3, [sp, #20]
    }

    return ticks;
    1f54:	9b05      	ldr	r3, [sp, #20]
}
    1f56:	4618      	mov	r0, r3
    1f58:	b007      	add	sp, #28
    1f5a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1f5c:	1fff8b34 	.word	0x1fff8b34
    1f60:	000f4240 	.word	0x000f4240

00001f64 <OsIf_Timer_System_Internal_Init>:
 * Function Name : OsIf_Timer_System_Internal_Init.
 * Description   : Initialize systick timer.
 * 
 *END**************************************************************************/
void OsIf_Timer_System_Internal_Init(uint32 SystemCounterFreq)
{
    1f64:	b082      	sub	sp, #8
    1f66:	9001      	str	r0, [sp, #4]
    (void)SystemCounterFreq;

    /* For Cortex-M0 devices the systick counter is initialized with an undefined
     value, so make sure to initialize it to 0 before starting */
    S32_SysTick->CSRr = S32_SysTick_CSR_ENABLE(0u);
    1f68:	4b07      	ldr	r3, [pc, #28]	; (1f88 <OsIf_Timer_System_Internal_Init+0x24>)
    1f6a:	2200      	movs	r2, #0
    1f6c:	601a      	str	r2, [r3, #0]
    S32_SysTick->RVR = S32_SysTick_RVR_RELOAD(SYSTICK_MAX);
    1f6e:	4b06      	ldr	r3, [pc, #24]	; (1f88 <OsIf_Timer_System_Internal_Init+0x24>)
    1f70:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
    1f74:	605a      	str	r2, [r3, #4]
    S32_SysTick->CVR = S32_SysTick_CVR_CURRENT(0U);
    1f76:	4b04      	ldr	r3, [pc, #16]	; (1f88 <OsIf_Timer_System_Internal_Init+0x24>)
    1f78:	2200      	movs	r2, #0
    1f7a:	609a      	str	r2, [r3, #8]
    S32_SysTick->CSRr = S32_SysTick_CSR_ENABLE(1u) | S32_SysTick_CSR_TICKINT(0u) | S32_SysTick_CSR_CLKSOURCE(1u);
    1f7c:	4b02      	ldr	r3, [pc, #8]	; (1f88 <OsIf_Timer_System_Internal_Init+0x24>)
    1f7e:	2205      	movs	r2, #5
    1f80:	601a      	str	r2, [r3, #0]
}
    1f82:	bf00      	nop
    1f84:	b002      	add	sp, #8
    1f86:	4770      	bx	lr
    1f88:	e000e010 	.word	0xe000e010

00001f8c <OsIf_Timer_System_Internal_GetCounter>:
 * Description   : Get systick counter value.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_Internal_GetCounter(void)
{
    return SYSTICK_GET_COUNTER();
    1f8c:	4b02      	ldr	r3, [pc, #8]	; (1f98 <OsIf_Timer_System_Internal_GetCounter+0xc>)
    1f8e:	689b      	ldr	r3, [r3, #8]
    1f90:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
}
    1f94:	4618      	mov	r0, r3
    1f96:	4770      	bx	lr
    1f98:	e000e010 	.word	0xe000e010

00001f9c <OsIf_Timer_System_Internal_GetElapsed>:
 * Function Name : OsIf_Timer_System_Internal_GetElapsed.
 * Description   : Get systick elapsed value.
 * 
 *END**************************************************************************/
uint32 OsIf_Timer_System_Internal_GetElapsed(uint32 * const CurrentRef)
{
    1f9c:	b084      	sub	sp, #16
    1f9e:	9001      	str	r0, [sp, #4]
    uint32 CurrentVal = SYSTICK_GET_COUNTER();
    1fa0:	4b10      	ldr	r3, [pc, #64]	; (1fe4 <OsIf_Timer_System_Internal_GetElapsed+0x48>)
    1fa2:	689b      	ldr	r3, [r3, #8]
    1fa4:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
    1fa8:	9302      	str	r3, [sp, #8]
    uint32 dif = 0U;
    1faa:	2300      	movs	r3, #0
    1fac:	9303      	str	r3, [sp, #12]

    if (SYSTICK_OVERFLOWED((CurrentVal), (*CurrentRef)))
    1fae:	9b01      	ldr	r3, [sp, #4]
    1fb0:	681b      	ldr	r3, [r3, #0]
    1fb2:	9a02      	ldr	r2, [sp, #8]
    1fb4:	429a      	cmp	r2, r3
    1fb6:	d909      	bls.n	1fcc <OsIf_Timer_System_Internal_GetElapsed+0x30>
    {
        /* overflow occurred */
        dif = SYSTICK_DELTA_OUTER(CurrentVal, *CurrentRef, SYSTICK_MAX);
    1fb8:	9b01      	ldr	r3, [sp, #4]
    1fba:	681a      	ldr	r2, [r3, #0]
    1fbc:	9b02      	ldr	r3, [sp, #8]
    1fbe:	1ad3      	subs	r3, r2, r3
    1fc0:	f103 13ff 	add.w	r3, r3, #16711935	; 0xff00ff
    1fc4:	f503 437f 	add.w	r3, r3, #65280	; 0xff00
    1fc8:	9303      	str	r3, [sp, #12]
    1fca:	e004      	b.n	1fd6 <OsIf_Timer_System_Internal_GetElapsed+0x3a>
    }
    else
    {
        /* overflow did not occur */
        dif = SYSTICK_DELTA_INNER(*CurrentRef, CurrentVal);
    1fcc:	9b01      	ldr	r3, [sp, #4]
    1fce:	681a      	ldr	r2, [r3, #0]
    1fd0:	9b02      	ldr	r3, [sp, #8]
    1fd2:	1ad3      	subs	r3, r2, r3
    1fd4:	9303      	str	r3, [sp, #12]
    }
    *CurrentRef = CurrentVal;
    1fd6:	9b01      	ldr	r3, [sp, #4]
    1fd8:	9a02      	ldr	r2, [sp, #8]
    1fda:	601a      	str	r2, [r3, #0]

    return dif;
    1fdc:	9b03      	ldr	r3, [sp, #12]
}
    1fde:	4618      	mov	r0, r3
    1fe0:	b004      	add	sp, #16
    1fe2:	4770      	bx	lr
    1fe4:	e000e010 	.word	0xe000e010

00001fe8 <Clock_Ip_NotificatonsEmptyCallback>:
 *
 *END**************************************************************************/
static void Clock_Ip_NotificatonsEmptyCallback( Clock_Ip_NotificationType Notification,
                                                Clock_Ip_NameType ClockName
                                               )
{
    1fe8:	b082      	sub	sp, #8
    1fea:	9001      	str	r0, [sp, #4]
    1fec:	9100      	str	r1, [sp, #0]
    /* No implementation */
    (void)Notification;
    (void)ClockName;
}
    1fee:	bf00      	nop
    1ff0:	b002      	add	sp, #8
    1ff2:	4770      	bx	lr

00001ff4 <Clock_Ip_UpdateDriverContext>:
 * Function Name : Clock_Ip_UpdateDriverContext.
 * Description   : Updates context of the driver, internal memory, clock objects.
 *
 *END**************************************************************************/
static void Clock_Ip_UpdateDriverContext(Clock_Ip_ClockConfigType const * Config)
{
    1ff4:	b500      	push	{lr}
    1ff6:	b085      	sub	sp, #20
    1ff8:	9001      	str	r0, [sp, #4]
    uint8 Index;
    (void)Config;
    Clock_Ip_bSentFromUpdateDriverContext = TRUE;
    1ffa:	4b24      	ldr	r3, [pc, #144]	; (208c <Clock_Ip_UpdateDriverContext+0x98>)
    1ffc:	2201      	movs	r2, #1
    1ffe:	701a      	strb	r2, [r3, #0]
    /* Initialize clock objects */
    Clock_Ip_Command(Clock_Ip_pxConfig, CLOCK_IP_INITIALIZE_CLOCK_OBJECTS_COMMAND);
    2000:	4b23      	ldr	r3, [pc, #140]	; (2090 <Clock_Ip_UpdateDriverContext+0x9c>)
    2002:	681b      	ldr	r3, [r3, #0]
    2004:	2102      	movs	r1, #2
    2006:	4618      	mov	r0, r3
    2008:	f003 fc32 	bl	5870 <Clock_Ip_Command>

    for (Index = 0U; Index < Config->ExtClksCount; Index++)    /* Set external signal frequency. */
    200c:	2300      	movs	r3, #0
    200e:	f88d 300f 	strb.w	r3, [sp, #15]
    2012:	e015      	b.n	2040 <Clock_Ip_UpdateDriverContext+0x4c>
    {
        Clock_Ip_SetExternalSignalFrequency(Config->ExtClks[Index].Name, Config->ExtClks[Index].Value);
    2014:	f89d 300f 	ldrb.w	r3, [sp, #15]
    2018:	9a01      	ldr	r2, [sp, #4]
    201a:	334a      	adds	r3, #74	; 0x4a
    201c:	00db      	lsls	r3, r3, #3
    201e:	4413      	add	r3, r2
    2020:	6858      	ldr	r0, [r3, #4]
    2022:	f89d 300f 	ldrb.w	r3, [sp, #15]
    2026:	9a01      	ldr	r2, [sp, #4]
    2028:	334a      	adds	r3, #74	; 0x4a
    202a:	00db      	lsls	r3, r3, #3
    202c:	4413      	add	r3, r2
    202e:	689b      	ldr	r3, [r3, #8]
    2030:	4619      	mov	r1, r3
    2032:	f001 fadc 	bl	35ee <Clock_Ip_SetExternalSignalFrequency>
    for (Index = 0U; Index < Config->ExtClksCount; Index++)    /* Set external signal frequency. */
    2036:	f89d 300f 	ldrb.w	r3, [sp, #15]
    203a:	3301      	adds	r3, #1
    203c:	f88d 300f 	strb.w	r3, [sp, #15]
    2040:	9b01      	ldr	r3, [sp, #4]
    2042:	7bdb      	ldrb	r3, [r3, #15]
    2044:	f89d 200f 	ldrb.w	r2, [sp, #15]
    2048:	429a      	cmp	r2, r3
    204a:	d3e3      	bcc.n	2014 <Clock_Ip_UpdateDriverContext+0x20>
    }

    /* Call empty callbacks */
    Clock_Ip_CallEmptyCallbacks();
    204c:	f000 f824 	bl	2098 <Clock_Ip_CallEmptyCallbacks>

#if CLOCK_IP_CONFIGURED_FREQUENCIES_COUNT > 0U

    for (Index = 1U; Index < Config->ConfigureFrequenciesCount; Index++)
    2050:	2301      	movs	r3, #1
    2052:	f88d 300f 	strb.w	r3, [sp, #15]
    2056:	e00e      	b.n	2076 <Clock_Ip_UpdateDriverContext+0x82>
    {
        Clock_Ip_FreqIds[Config->ConfiguredFrequencies[Index].Name] = Index;
    2058:	f89d 200f 	ldrb.w	r2, [sp, #15]
    205c:	9b01      	ldr	r3, [sp, #4]
    205e:	327e      	adds	r2, #126	; 0x7e
    2060:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    2064:	490b      	ldr	r1, [pc, #44]	; (2094 <Clock_Ip_UpdateDriverContext+0xa0>)
    2066:	f89d 200f 	ldrb.w	r2, [sp, #15]
    206a:	54ca      	strb	r2, [r1, r3]
    for (Index = 1U; Index < Config->ConfigureFrequenciesCount; Index++)
    206c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    2070:	3301      	adds	r3, #1
    2072:	f88d 300f 	strb.w	r3, [sp, #15]
    2076:	9b01      	ldr	r3, [sp, #4]
    2078:	7cdb      	ldrb	r3, [r3, #19]
    207a:	f89d 200f 	ldrb.w	r2, [sp, #15]
    207e:	429a      	cmp	r2, r3
    2080:	d3ea      	bcc.n	2058 <Clock_Ip_UpdateDriverContext+0x64>
    }

#endif /* CLOCK_IP_CONFIGURED_FREQUENCIES_COUNT > 0U */
}
    2082:	bf00      	nop
    2084:	bf00      	nop
    2086:	b005      	add	sp, #20
    2088:	f85d fb04 	ldr.w	pc, [sp], #4
    208c:	1fff8b10 	.word	0x1fff8b10
    2090:	1fff8b38 	.word	0x1fff8b38
    2094:	1fff8b44 	.word	0x1fff8b44

00002098 <Clock_Ip_CallEmptyCallbacks>:

#define CLOCK_IP_NO_CALLBACK 0U

/* Call empty callbacks to improve CCOV*/
static void Clock_Ip_CallEmptyCallbacks(void)
{
    2098:	b508      	push	{r3, lr}

    if (FALSE == FunctionWasCalled)
    209a:	4b23      	ldr	r3, [pc, #140]	; (2128 <Clock_Ip_CallEmptyCallbacks+0x90>)
    209c:	781b      	ldrb	r3, [r3, #0]
    209e:	f083 0301 	eor.w	r3, r3, #1
    20a2:	b2db      	uxtb	r3, r3
    20a4:	2b00      	cmp	r3, #0
    20a6:	d03d      	beq.n	2124 <Clock_Ip_CallEmptyCallbacks+0x8c>
    {
        FunctionWasCalled = TRUE;
    20a8:	4b1f      	ldr	r3, [pc, #124]	; (2128 <Clock_Ip_CallEmptyCallbacks+0x90>)
    20aa:	2201      	movs	r2, #1
    20ac:	701a      	strb	r2, [r3, #0]

        Clock_Ip_axCmuCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR, 0U);
    20ae:	4b1f      	ldr	r3, [pc, #124]	; (212c <Clock_Ip_CallEmptyCallbacks+0x94>)
    20b0:	685b      	ldr	r3, [r3, #4]
    20b2:	2100      	movs	r1, #0
    20b4:	2000      	movs	r0, #0
    20b6:	4798      	blx	r3
        Clock_Ip_axCmuCallbacks[CLOCK_IP_NO_CALLBACK].Disable(RESERVED_CLK);
    20b8:	4b1c      	ldr	r3, [pc, #112]	; (212c <Clock_Ip_CallEmptyCallbacks+0x94>)
    20ba:	689b      	ldr	r3, [r3, #8]
    20bc:	2057      	movs	r0, #87	; 0x57
    20be:	4798      	blx	r3

        Clock_Ip_axDividerCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    20c0:	4b1b      	ldr	r3, [pc, #108]	; (2130 <Clock_Ip_CallEmptyCallbacks+0x98>)
    20c2:	681b      	ldr	r3, [r3, #0]
    20c4:	2000      	movs	r0, #0
    20c6:	4798      	blx	r3

        Clock_Ip_axDividerTriggerCallbacks[CLOCK_IP_NO_CALLBACK].Configure(NULL_PTR);
    20c8:	4b1a      	ldr	r3, [pc, #104]	; (2134 <Clock_Ip_CallEmptyCallbacks+0x9c>)
    20ca:	681b      	ldr	r3, [r3, #0]
    20cc:	2000      	movs	r0, #0
    20ce:	4798      	blx	r3

        Clock_Ip_axExtOscCallbacks[CLOCK_IP_NO_CALLBACK].Reset(NULL_PTR);
    20d0:	4b19      	ldr	r3, [pc, #100]	; (2138 <Clock_Ip_CallEmptyCallbacks+0xa0>)
    20d2:	681b      	ldr	r3, [r3, #0]
    20d4:	2000      	movs	r0, #0
    20d6:	4798      	blx	r3

        Clock_Ip_axFracDivCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    20d8:	4b18      	ldr	r3, [pc, #96]	; (213c <Clock_Ip_CallEmptyCallbacks+0xa4>)
    20da:	685b      	ldr	r3, [r3, #4]
    20dc:	2000      	movs	r0, #0
    20de:	4798      	blx	r3
        (void)Clock_Ip_axFracDivCallbacks[CLOCK_IP_NO_CALLBACK].Complete(RESERVED_CLK);
    20e0:	4b16      	ldr	r3, [pc, #88]	; (213c <Clock_Ip_CallEmptyCallbacks+0xa4>)
    20e2:	689b      	ldr	r3, [r3, #8]
    20e4:	2057      	movs	r0, #87	; 0x57
    20e6:	4798      	blx	r3

        Clock_Ip_axGateCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    20e8:	4b15      	ldr	r3, [pc, #84]	; (2140 <Clock_Ip_CallEmptyCallbacks+0xa8>)
    20ea:	681b      	ldr	r3, [r3, #0]
    20ec:	2000      	movs	r0, #0
    20ee:	4798      	blx	r3
        Clock_Ip_axGateCallbacks[CLOCK_IP_NO_CALLBACK].Update(RESERVED_CLK,FALSE);
    20f0:	4b13      	ldr	r3, [pc, #76]	; (2140 <Clock_Ip_CallEmptyCallbacks+0xa8>)
    20f2:	685b      	ldr	r3, [r3, #4]
    20f4:	2100      	movs	r1, #0
    20f6:	2057      	movs	r0, #87	; 0x57
    20f8:	4798      	blx	r3

        Clock_Ip_axIntOscCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    20fa:	4b12      	ldr	r3, [pc, #72]	; (2144 <Clock_Ip_CallEmptyCallbacks+0xac>)
    20fc:	681b      	ldr	r3, [r3, #0]
    20fe:	2000      	movs	r0, #0
    2100:	4798      	blx	r3

        Clock_Ip_axPllCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    2102:	4b11      	ldr	r3, [pc, #68]	; (2148 <Clock_Ip_CallEmptyCallbacks+0xb0>)
    2104:	685b      	ldr	r3, [r3, #4]
    2106:	2000      	movs	r0, #0
    2108:	4798      	blx	r3
        (void)Clock_Ip_axPllCallbacks[CLOCK_IP_NO_CALLBACK].Complete(RESERVED_CLK);
    210a:	4b0f      	ldr	r3, [pc, #60]	; (2148 <Clock_Ip_CallEmptyCallbacks+0xb0>)
    210c:	689b      	ldr	r3, [r3, #8]
    210e:	2057      	movs	r0, #87	; 0x57
    2110:	4798      	blx	r3

        Clock_Ip_axSelectorCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR);
    2112:	4b0e      	ldr	r3, [pc, #56]	; (214c <Clock_Ip_CallEmptyCallbacks+0xb4>)
    2114:	685b      	ldr	r3, [r3, #4]
    2116:	2000      	movs	r0, #0
    2118:	4798      	blx	r3

        Clock_Ip_axPcfsCallbacks[CLOCK_IP_NO_CALLBACK].Set(NULL_PTR, 0U);
    211a:	4b0d      	ldr	r3, [pc, #52]	; (2150 <Clock_Ip_CallEmptyCallbacks+0xb8>)
    211c:	681b      	ldr	r3, [r3, #0]
    211e:	2100      	movs	r1, #0
    2120:	2000      	movs	r0, #0
    2122:	4798      	blx	r3
    }
}
    2124:	bf00      	nop
    2126:	bd08      	pop	{r3, pc}
    2128:	1fff8b3c 	.word	0x1fff8b3c
    212c:	00015acc 	.word	0x00015acc
    2130:	000159e0 	.word	0x000159e0
    2134:	00015a1c 	.word	0x00015a1c
    2138:	00015a24 	.word	0x00015a24
    213c:	00015a4c 	.word	0x00015a4c
    2140:	00015a58 	.word	0x00015a58
    2144:	00015a90 	.word	0x00015a90
    2148:	00015adc 	.word	0x00015adc
    214c:	00015b08 	.word	0x00015b08
    2150:	00015b04 	.word	0x00015b04

00002154 <Clock_Ip_ResetClockConfiguration>:

static void Clock_Ip_ResetClockConfiguration(Clock_Ip_ClockConfigType const * Config)
{
    2154:	b500      	push	{lr}
    2156:	b085      	sub	sp, #20
    2158:	9001      	str	r0, [sp, #4]
    uint32 CallbackIndex;
    uint32 Index;

    for (Index = Config->SelectorsCount ; Index > 0U; Index--)    /* Ramp down all selectors from configuration to SAFE_CLOCK */
    215a:	9b01      	ldr	r3, [sp, #4]
    215c:	7adb      	ldrb	r3, [r3, #11]
    215e:	9303      	str	r3, [sp, #12]
    2160:	e01f      	b.n	21a2 <Clock_Ip_ResetClockConfiguration+0x4e>
    {
        CallbackIndex = Clock_Ip_au8SelectorCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Selectors[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    2162:	9b03      	ldr	r3, [sp, #12]
    2164:	1e5a      	subs	r2, r3, #1
    2166:	9b01      	ldr	r3, [sp, #4]
    2168:	320d      	adds	r2, #13
    216a:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
    216e:	495a      	ldr	r1, [pc, #360]	; (22d8 <Clock_Ip_ResetClockConfiguration+0x184>)
    2170:	4613      	mov	r3, r2
    2172:	00db      	lsls	r3, r3, #3
    2174:	4413      	add	r3, r2
    2176:	440b      	add	r3, r1
    2178:	3301      	adds	r3, #1
    217a:	781b      	ldrb	r3, [r3, #0]
    217c:	461a      	mov	r2, r3
    217e:	4b57      	ldr	r3, [pc, #348]	; (22dc <Clock_Ip_ResetClockConfiguration+0x188>)
    2180:	5c9b      	ldrb	r3, [r3, r2]
    2182:	9302      	str	r3, [sp, #8]
        Clock_Ip_axSelectorCallbacks[CallbackIndex].Reset(&Config->Selectors[Index - 1U]);
    2184:	4a56      	ldr	r2, [pc, #344]	; (22e0 <Clock_Ip_ResetClockConfiguration+0x18c>)
    2186:	9b02      	ldr	r3, [sp, #8]
    2188:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    218c:	9a03      	ldr	r2, [sp, #12]
    218e:	3a01      	subs	r2, #1
    2190:	320d      	adds	r2, #13
    2192:	00d2      	lsls	r2, r2, #3
    2194:	9901      	ldr	r1, [sp, #4]
    2196:	440a      	add	r2, r1
    2198:	4610      	mov	r0, r2
    219a:	4798      	blx	r3
    for (Index = Config->SelectorsCount ; Index > 0U; Index--)    /* Ramp down all selectors from configuration to SAFE_CLOCK */
    219c:	9b03      	ldr	r3, [sp, #12]
    219e:	3b01      	subs	r3, #1
    21a0:	9303      	str	r3, [sp, #12]
    21a2:	9b03      	ldr	r3, [sp, #12]
    21a4:	2b00      	cmp	r3, #0
    21a6:	d1dc      	bne.n	2162 <Clock_Ip_ResetClockConfiguration+0xe>
    }

    for (Index = Config->FracDivsCount; Index > 0U; Index--)    /* Put in reset state all fractional dividers from configuration */
    21a8:	9b01      	ldr	r3, [sp, #4]
    21aa:	7b9b      	ldrb	r3, [r3, #14]
    21ac:	9303      	str	r3, [sp, #12]
    21ae:	e026      	b.n	21fe <Clock_Ip_ResetClockConfiguration+0xaa>
    {
        CallbackIndex = Clock_Ip_au8FractionalDividerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->FracDivs[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    21b0:	9b03      	ldr	r3, [sp, #12]
    21b2:	3b01      	subs	r3, #1
    21b4:	9a01      	ldr	r2, [sp, #4]
    21b6:	3324      	adds	r3, #36	; 0x24
    21b8:	011b      	lsls	r3, r3, #4
    21ba:	4413      	add	r3, r2
    21bc:	3304      	adds	r3, #4
    21be:	681a      	ldr	r2, [r3, #0]
    21c0:	4945      	ldr	r1, [pc, #276]	; (22d8 <Clock_Ip_ResetClockConfiguration+0x184>)
    21c2:	4613      	mov	r3, r2
    21c4:	00db      	lsls	r3, r3, #3
    21c6:	4413      	add	r3, r2
    21c8:	440b      	add	r3, r1
    21ca:	3301      	adds	r3, #1
    21cc:	781b      	ldrb	r3, [r3, #0]
    21ce:	461a      	mov	r2, r3
    21d0:	4b44      	ldr	r3, [pc, #272]	; (22e4 <Clock_Ip_ResetClockConfiguration+0x190>)
    21d2:	5c9b      	ldrb	r3, [r3, r2]
    21d4:	9302      	str	r3, [sp, #8]
        Clock_Ip_axFracDivCallbacks[CallbackIndex].Reset(&Config->FracDivs[Index - 1U]);
    21d6:	4944      	ldr	r1, [pc, #272]	; (22e8 <Clock_Ip_ResetClockConfiguration+0x194>)
    21d8:	9a02      	ldr	r2, [sp, #8]
    21da:	4613      	mov	r3, r2
    21dc:	005b      	lsls	r3, r3, #1
    21de:	4413      	add	r3, r2
    21e0:	009b      	lsls	r3, r3, #2
    21e2:	440b      	add	r3, r1
    21e4:	681b      	ldr	r3, [r3, #0]
    21e6:	9a03      	ldr	r2, [sp, #12]
    21e8:	3a01      	subs	r2, #1
    21ea:	3224      	adds	r2, #36	; 0x24
    21ec:	0112      	lsls	r2, r2, #4
    21ee:	9901      	ldr	r1, [sp, #4]
    21f0:	440a      	add	r2, r1
    21f2:	3204      	adds	r2, #4
    21f4:	4610      	mov	r0, r2
    21f6:	4798      	blx	r3
    for (Index = Config->FracDivsCount; Index > 0U; Index--)    /* Put in reset state all fractional dividers from configuration */
    21f8:	9b03      	ldr	r3, [sp, #12]
    21fa:	3b01      	subs	r3, #1
    21fc:	9303      	str	r3, [sp, #12]
    21fe:	9b03      	ldr	r3, [sp, #12]
    2200:	2b00      	cmp	r3, #0
    2202:	d1d5      	bne.n	21b0 <Clock_Ip_ResetClockConfiguration+0x5c>
    }

    for (Index = Config->PllsCount; Index > 0U; Index--)       /* Power down all plls from configuration */
    2204:	9b01      	ldr	r3, [sp, #4]
    2206:	7a9b      	ldrb	r3, [r3, #10]
    2208:	9303      	str	r3, [sp, #12]
    220a:	e02a      	b.n	2262 <Clock_Ip_ResetClockConfiguration+0x10e>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Plls[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    220c:	9b03      	ldr	r3, [sp, #12]
    220e:	1e5a      	subs	r2, r3, #1
    2210:	9901      	ldr	r1, [sp, #4]
    2212:	4613      	mov	r3, r2
    2214:	009b      	lsls	r3, r3, #2
    2216:	4413      	add	r3, r2
    2218:	00db      	lsls	r3, r3, #3
    221a:	440b      	add	r3, r1
    221c:	3340      	adds	r3, #64	; 0x40
    221e:	681a      	ldr	r2, [r3, #0]
    2220:	492d      	ldr	r1, [pc, #180]	; (22d8 <Clock_Ip_ResetClockConfiguration+0x184>)
    2222:	4613      	mov	r3, r2
    2224:	00db      	lsls	r3, r3, #3
    2226:	4413      	add	r3, r2
    2228:	440b      	add	r3, r1
    222a:	3301      	adds	r3, #1
    222c:	781b      	ldrb	r3, [r3, #0]
    222e:	461a      	mov	r2, r3
    2230:	4b2e      	ldr	r3, [pc, #184]	; (22ec <Clock_Ip_ResetClockConfiguration+0x198>)
    2232:	5c9b      	ldrb	r3, [r3, r2]
    2234:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPllCallbacks[CallbackIndex].Reset(&Config->Plls[Index - 1U]);
    2236:	492e      	ldr	r1, [pc, #184]	; (22f0 <Clock_Ip_ResetClockConfiguration+0x19c>)
    2238:	9a02      	ldr	r2, [sp, #8]
    223a:	4613      	mov	r3, r2
    223c:	009b      	lsls	r3, r3, #2
    223e:	4413      	add	r3, r2
    2240:	009b      	lsls	r3, r3, #2
    2242:	440b      	add	r3, r1
    2244:	6819      	ldr	r1, [r3, #0]
    2246:	9b03      	ldr	r3, [sp, #12]
    2248:	1e5a      	subs	r2, r3, #1
    224a:	4613      	mov	r3, r2
    224c:	009b      	lsls	r3, r3, #2
    224e:	4413      	add	r3, r2
    2250:	00db      	lsls	r3, r3, #3
    2252:	3340      	adds	r3, #64	; 0x40
    2254:	9a01      	ldr	r2, [sp, #4]
    2256:	4413      	add	r3, r2
    2258:	4618      	mov	r0, r3
    225a:	4788      	blx	r1
    for (Index = Config->PllsCount; Index > 0U; Index--)       /* Power down all plls from configuration */
    225c:	9b03      	ldr	r3, [sp, #12]
    225e:	3b01      	subs	r3, #1
    2260:	9303      	str	r3, [sp, #12]
    2262:	9b03      	ldr	r3, [sp, #12]
    2264:	2b00      	cmp	r3, #0
    2266:	d1d1      	bne.n	220c <Clock_Ip_ResetClockConfiguration+0xb8>
    }

    for (Index = Config->XoscsCount; Index > 0U; Index--)     /* Power down all xoscs from configuration */
    2268:	9b01      	ldr	r3, [sp, #4]
    226a:	7a5b      	ldrb	r3, [r3, #9]
    226c:	9303      	str	r3, [sp, #12]
    226e:	e02b      	b.n	22c8 <Clock_Ip_ResetClockConfiguration+0x174>
    {
        CallbackIndex = Clock_Ip_au8XoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Xoscs[Index - 1U].Name][CLOCK_IP_CALLBACK]];
    2270:	9b03      	ldr	r3, [sp, #12]
    2272:	1e5a      	subs	r2, r3, #1
    2274:	9901      	ldr	r1, [sp, #4]
    2276:	4613      	mov	r3, r2
    2278:	009b      	lsls	r3, r3, #2
    227a:	4413      	add	r3, r2
    227c:	009b      	lsls	r3, r3, #2
    227e:	440b      	add	r3, r1
    2280:	332c      	adds	r3, #44	; 0x2c
    2282:	681a      	ldr	r2, [r3, #0]
    2284:	4914      	ldr	r1, [pc, #80]	; (22d8 <Clock_Ip_ResetClockConfiguration+0x184>)
    2286:	4613      	mov	r3, r2
    2288:	00db      	lsls	r3, r3, #3
    228a:	4413      	add	r3, r2
    228c:	440b      	add	r3, r1
    228e:	3301      	adds	r3, #1
    2290:	781b      	ldrb	r3, [r3, #0]
    2292:	461a      	mov	r2, r3
    2294:	4b17      	ldr	r3, [pc, #92]	; (22f4 <Clock_Ip_ResetClockConfiguration+0x1a0>)
    2296:	5c9b      	ldrb	r3, [r3, r2]
    2298:	9302      	str	r3, [sp, #8]
        Clock_Ip_axExtOscCallbacks[CallbackIndex].Reset(&Config->Xoscs[Index - 1U]);
    229a:	4917      	ldr	r1, [pc, #92]	; (22f8 <Clock_Ip_ResetClockConfiguration+0x1a4>)
    229c:	9a02      	ldr	r2, [sp, #8]
    229e:	4613      	mov	r3, r2
    22a0:	009b      	lsls	r3, r3, #2
    22a2:	4413      	add	r3, r2
    22a4:	009b      	lsls	r3, r3, #2
    22a6:	440b      	add	r3, r1
    22a8:	6819      	ldr	r1, [r3, #0]
    22aa:	9b03      	ldr	r3, [sp, #12]
    22ac:	1e5a      	subs	r2, r3, #1
    22ae:	4613      	mov	r3, r2
    22b0:	009b      	lsls	r3, r3, #2
    22b2:	4413      	add	r3, r2
    22b4:	009b      	lsls	r3, r3, #2
    22b6:	3328      	adds	r3, #40	; 0x28
    22b8:	9a01      	ldr	r2, [sp, #4]
    22ba:	4413      	add	r3, r2
    22bc:	3304      	adds	r3, #4
    22be:	4618      	mov	r0, r3
    22c0:	4788      	blx	r1
    for (Index = Config->XoscsCount; Index > 0U; Index--)     /* Power down all xoscs from configuration */
    22c2:	9b03      	ldr	r3, [sp, #12]
    22c4:	3b01      	subs	r3, #1
    22c6:	9303      	str	r3, [sp, #12]
    22c8:	9b03      	ldr	r3, [sp, #12]
    22ca:	2b00      	cmp	r3, #0
    22cc:	d1d0      	bne.n	2270 <Clock_Ip_ResetClockConfiguration+0x11c>
    }
}
    22ce:	bf00      	nop
    22d0:	bf00      	nop
    22d2:	b005      	add	sp, #20
    22d4:	f85d fb04 	ldr.w	pc, [sp], #4
    22d8:	000154d0 	.word	0x000154d0
    22dc:	000154a0 	.word	0x000154a0
    22e0:	00015b08 	.word	0x00015b08
    22e4:	00015480 	.word	0x00015480
    22e8:	00015a4c 	.word	0x00015a4c
    22ec:	00015490 	.word	0x00015490
    22f0:	00015adc 	.word	0x00015adc
    22f4:	00015450 	.word	0x00015450
    22f8:	00015a24 	.word	0x00015a24

000022fc <Clock_Ip_Init>:
 *                 enabled, for example, if the external oscillator is used, please setup correctly.
 *
 * @implements Clock_Ip_Init_Activity
 * END**********************************************************************************/
Clock_Ip_StatusType Clock_Ip_Init(Clock_Ip_ClockConfigType const * Config)
{
    22fc:	b500      	push	{lr}
    22fe:	b085      	sub	sp, #20
    2300:	9001      	str	r0, [sp, #4]
    Clock_Ip_StatusType ClockStatus = CLOCK_IP_ERROR;
    2302:	2301      	movs	r3, #1
    2304:	9303      	str	r3, [sp, #12]
    Clock_Ip_Command(Config, CLOCK_IP_SET_USER_ACCESS_ALLOWED_COMMAND);
  #endif
#endif
    CLOCK_IP_DEV_ASSERT(NULL_PTR != Config);

    Clock_Ip_InitClock(Config);
    2306:	9801      	ldr	r0, [sp, #4]
    2308:	f000 f818 	bl	233c <Clock_Ip_InitClock>

    if (DriverContext.ClockTreeIsConsumingPll)
    230c:	4b0a      	ldr	r3, [pc, #40]	; (2338 <Clock_Ip_Init+0x3c>)
    230e:	781b      	ldrb	r3, [r3, #0]
    2310:	2b00      	cmp	r3, #0
    2312:	d00a      	beq.n	232a <Clock_Ip_Init+0x2e>
    {
        PllStatus = Clock_Ip_GetPllStatus();
    2314:	f000 fb74 	bl	2a00 <Clock_Ip_GetPllStatus>
    2318:	9002      	str	r0, [sp, #8]
        if (CLOCK_IP_PLL_LOCKED == PllStatus)
    231a:	9b02      	ldr	r3, [sp, #8]
    231c:	2b00      	cmp	r3, #0
    231e:	d106      	bne.n	232e <Clock_Ip_Init+0x32>
        {
            Clock_Ip_DistributePll();
    2320:	f000 fbf2 	bl	2b08 <Clock_Ip_DistributePll>
            ClockStatus = CLOCK_IP_SUCCESS;
    2324:	2300      	movs	r3, #0
    2326:	9303      	str	r3, [sp, #12]
    2328:	e001      	b.n	232e <Clock_Ip_Init+0x32>
        }
    }
    else
    {
        ClockStatus = CLOCK_IP_SUCCESS;
    232a:	2300      	movs	r3, #0
    232c:	9303      	str	r3, [sp, #12]
    }

    return ClockStatus;
    232e:	9b03      	ldr	r3, [sp, #12]
}
    2330:	4618      	mov	r0, r3
    2332:	b005      	add	sp, #20
    2334:	f85d fb04 	ldr.w	pc, [sp], #4
    2338:	1fff8b40 	.word	0x1fff8b40

0000233c <Clock_Ip_InitClock>:
 *                 shall be initialized) and shall return without waiting until the PLL is locked.
 *
 * @implements Clock_Ip_InitClock_Activity
 * END**********************************************************************************/
void Clock_Ip_InitClock(Clock_Ip_ClockConfigType const * Config)
{
    233c:	b510      	push	{r4, lr}
    233e:	b084      	sub	sp, #16
    2340:	9001      	str	r0, [sp, #4]
#endif

    CLOCK_IP_DEV_ASSERT(NULL_PTR != Config);

    /* Save the current clock configuration to be used by "Clock_Ip_DistributePllClock". */
    Clock_Ip_pxConfig = Config;
    2342:	4a9f      	ldr	r2, [pc, #636]	; (25c0 <Clock_Ip_InitClock+0x284>)
    2344:	9b01      	ldr	r3, [sp, #4]
    2346:	6013      	str	r3, [r2, #0]

    /* Platform specific initialization:
     * DFS reset, FIRC_CLK configuration etc. */
    Clock_Ip_Command(Config, CLOCK_IP_INITIALIZE_PLATFORM_COMMAND);
    2348:	2101      	movs	r1, #1
    234a:	9801      	ldr	r0, [sp, #4]
    234c:	f003 fa90 	bl	5870 <Clock_Ip_Command>

    /* Clear all the settings for CMU0/1/2... */
    /* In case one clock configuration has the CMU disabled, then need to make the transition to
    reset state of CMU modules. */
    if (NULL_PTR != Clock_Ip_pxConfig)
    2350:	4b9b      	ldr	r3, [pc, #620]	; (25c0 <Clock_Ip_InitClock+0x284>)
    2352:	681b      	ldr	r3, [r3, #0]
    2354:	2b00      	cmp	r3, #0
    2356:	d030      	beq.n	23ba <Clock_Ip_InitClock+0x7e>
    {
        for (Index = 0U; Index < Config->CmusCount; Index++)    /* Reset all clock monitor units from previous configuration. */
    2358:	2300      	movs	r3, #0
    235a:	9303      	str	r3, [sp, #12]
    235c:	e027      	b.n	23ae <Clock_Ip_InitClock+0x72>
        {
            CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    235e:	9901      	ldr	r1, [sp, #4]
    2360:	9a03      	ldr	r2, [sp, #12]
    2362:	4613      	mov	r3, r2
    2364:	009b      	lsls	r3, r3, #2
    2366:	4413      	add	r3, r2
    2368:	009b      	lsls	r3, r3, #2
    236a:	440b      	add	r3, r1
    236c:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    2370:	681a      	ldr	r2, [r3, #0]
    2372:	4994      	ldr	r1, [pc, #592]	; (25c4 <Clock_Ip_InitClock+0x288>)
    2374:	4613      	mov	r3, r2
    2376:	00db      	lsls	r3, r3, #3
    2378:	4413      	add	r3, r2
    237a:	440b      	add	r3, r1
    237c:	3301      	adds	r3, #1
    237e:	781b      	ldrb	r3, [r3, #0]
    2380:	461a      	mov	r2, r3
    2382:	4b91      	ldr	r3, [pc, #580]	; (25c8 <Clock_Ip_InitClock+0x28c>)
    2384:	5c9b      	ldrb	r3, [r3, r2]
    2386:	9302      	str	r3, [sp, #8]
            Clock_Ip_axCmuCallbacks[CallbackIndex].Reset(&Config->Cmus[Index]);
    2388:	4a90      	ldr	r2, [pc, #576]	; (25cc <Clock_Ip_InitClock+0x290>)
    238a:	9b02      	ldr	r3, [sp, #8]
    238c:	011b      	lsls	r3, r3, #4
    238e:	4413      	add	r3, r2
    2390:	6819      	ldr	r1, [r3, #0]
    2392:	9a03      	ldr	r2, [sp, #12]
    2394:	4613      	mov	r3, r2
    2396:	009b      	lsls	r3, r3, #2
    2398:	4413      	add	r3, r2
    239a:	009b      	lsls	r3, r3, #2
    239c:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    23a0:	9a01      	ldr	r2, [sp, #4]
    23a2:	4413      	add	r3, r2
    23a4:	4618      	mov	r0, r3
    23a6:	4788      	blx	r1
        for (Index = 0U; Index < Config->CmusCount; Index++)    /* Reset all clock monitor units from previous configuration. */
    23a8:	9b03      	ldr	r3, [sp, #12]
    23aa:	3301      	adds	r3, #1
    23ac:	9303      	str	r3, [sp, #12]
    23ae:	9b01      	ldr	r3, [sp, #4]
    23b0:	7c9b      	ldrb	r3, [r3, #18]
    23b2:	461a      	mov	r2, r3
    23b4:	9b03      	ldr	r3, [sp, #12]
    23b6:	4293      	cmp	r3, r2
    23b8:	d3d1      	bcc.n	235e <Clock_Ip_InitClock+0x22>

    /*********************************************************************
     ***  Ramp down to safe configuration. Reset elements from clock tree:
     ***  selectors, fractional dividers, plls and xoscs
     ***********************************************************************/
    Clock_Ip_ResetClockConfiguration(Config);
    23ba:	9801      	ldr	r0, [sp, #4]
    23bc:	f7ff feca 	bl	2154 <Clock_Ip_ResetClockConfiguration>
    /*******************************************************
     *** Load the new configuration. Selectors that might
     *** be clocked from PLLs shouldn't be configured.
     *******************************************************/

    for (Index = 0U; Index < Config->IrcoscsCount; Index++)   /* Set internal oscillators from configuration */
    23c0:	2300      	movs	r3, #0
    23c2:	9303      	str	r3, [sp, #12]
    23c4:	e029      	b.n	241a <Clock_Ip_InitClock+0xde>
    {
        CallbackIndex = Clock_Ip_au8IrcoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Ircoscs[Index].Name][CLOCK_IP_CALLBACK]];
    23c6:	9901      	ldr	r1, [sp, #4]
    23c8:	9a03      	ldr	r2, [sp, #12]
    23ca:	4613      	mov	r3, r2
    23cc:	005b      	lsls	r3, r3, #1
    23ce:	4413      	add	r3, r2
    23d0:	009b      	lsls	r3, r3, #2
    23d2:	440b      	add	r3, r1
    23d4:	3314      	adds	r3, #20
    23d6:	681a      	ldr	r2, [r3, #0]
    23d8:	497a      	ldr	r1, [pc, #488]	; (25c4 <Clock_Ip_InitClock+0x288>)
    23da:	4613      	mov	r3, r2
    23dc:	00db      	lsls	r3, r3, #3
    23de:	4413      	add	r3, r2
    23e0:	440b      	add	r3, r1
    23e2:	3301      	adds	r3, #1
    23e4:	781b      	ldrb	r3, [r3, #0]
    23e6:	461a      	mov	r2, r3
    23e8:	4b79      	ldr	r3, [pc, #484]	; (25d0 <Clock_Ip_InitClock+0x294>)
    23ea:	5c9b      	ldrb	r3, [r3, r2]
    23ec:	9302      	str	r3, [sp, #8]
        Clock_Ip_axIntOscCallbacks[CallbackIndex].Set(&Config->Ircoscs[Index]);
    23ee:	4979      	ldr	r1, [pc, #484]	; (25d4 <Clock_Ip_InitClock+0x298>)
    23f0:	9a02      	ldr	r2, [sp, #8]
    23f2:	4613      	mov	r3, r2
    23f4:	005b      	lsls	r3, r3, #1
    23f6:	4413      	add	r3, r2
    23f8:	009b      	lsls	r3, r3, #2
    23fa:	440b      	add	r3, r1
    23fc:	6819      	ldr	r1, [r3, #0]
    23fe:	9a03      	ldr	r2, [sp, #12]
    2400:	4613      	mov	r3, r2
    2402:	005b      	lsls	r3, r3, #1
    2404:	4413      	add	r3, r2
    2406:	009b      	lsls	r3, r3, #2
    2408:	3310      	adds	r3, #16
    240a:	9a01      	ldr	r2, [sp, #4]
    240c:	4413      	add	r3, r2
    240e:	3304      	adds	r3, #4
    2410:	4618      	mov	r0, r3
    2412:	4788      	blx	r1
    for (Index = 0U; Index < Config->IrcoscsCount; Index++)   /* Set internal oscillators from configuration */
    2414:	9b03      	ldr	r3, [sp, #12]
    2416:	3301      	adds	r3, #1
    2418:	9303      	str	r3, [sp, #12]
    241a:	9b01      	ldr	r3, [sp, #4]
    241c:	7a1b      	ldrb	r3, [r3, #8]
    241e:	461a      	mov	r2, r3
    2420:	9b03      	ldr	r3, [sp, #12]
    2422:	4293      	cmp	r3, r2
    2424:	d3cf      	bcc.n	23c6 <Clock_Ip_InitClock+0x8a>
    }

    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Configure all xoscs from configuration */
    2426:	2300      	movs	r3, #0
    2428:	9303      	str	r3, [sp, #12]
    242a:	e02a      	b.n	2482 <Clock_Ip_InitClock+0x146>
    {
        CallbackIndex = Clock_Ip_au8XoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Xoscs[Index].Name][CLOCK_IP_CALLBACK]];
    242c:	9901      	ldr	r1, [sp, #4]
    242e:	9a03      	ldr	r2, [sp, #12]
    2430:	4613      	mov	r3, r2
    2432:	009b      	lsls	r3, r3, #2
    2434:	4413      	add	r3, r2
    2436:	009b      	lsls	r3, r3, #2
    2438:	440b      	add	r3, r1
    243a:	332c      	adds	r3, #44	; 0x2c
    243c:	681a      	ldr	r2, [r3, #0]
    243e:	4961      	ldr	r1, [pc, #388]	; (25c4 <Clock_Ip_InitClock+0x288>)
    2440:	4613      	mov	r3, r2
    2442:	00db      	lsls	r3, r3, #3
    2444:	4413      	add	r3, r2
    2446:	440b      	add	r3, r1
    2448:	3301      	adds	r3, #1
    244a:	781b      	ldrb	r3, [r3, #0]
    244c:	461a      	mov	r2, r3
    244e:	4b62      	ldr	r3, [pc, #392]	; (25d8 <Clock_Ip_InitClock+0x29c>)
    2450:	5c9b      	ldrb	r3, [r3, r2]
    2452:	9302      	str	r3, [sp, #8]
        Clock_Ip_axExtOscCallbacks[CallbackIndex].Set(&Config->Xoscs[Index]);
    2454:	4961      	ldr	r1, [pc, #388]	; (25dc <Clock_Ip_InitClock+0x2a0>)
    2456:	9a02      	ldr	r2, [sp, #8]
    2458:	4613      	mov	r3, r2
    245a:	009b      	lsls	r3, r3, #2
    245c:	4413      	add	r3, r2
    245e:	009b      	lsls	r3, r3, #2
    2460:	440b      	add	r3, r1
    2462:	3304      	adds	r3, #4
    2464:	6819      	ldr	r1, [r3, #0]
    2466:	9a03      	ldr	r2, [sp, #12]
    2468:	4613      	mov	r3, r2
    246a:	009b      	lsls	r3, r3, #2
    246c:	4413      	add	r3, r2
    246e:	009b      	lsls	r3, r3, #2
    2470:	3328      	adds	r3, #40	; 0x28
    2472:	9a01      	ldr	r2, [sp, #4]
    2474:	4413      	add	r3, r2
    2476:	3304      	adds	r3, #4
    2478:	4618      	mov	r0, r3
    247a:	4788      	blx	r1
    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Configure all xoscs from configuration */
    247c:	9b03      	ldr	r3, [sp, #12]
    247e:	3301      	adds	r3, #1
    2480:	9303      	str	r3, [sp, #12]
    2482:	9b01      	ldr	r3, [sp, #4]
    2484:	7a5b      	ldrb	r3, [r3, #9]
    2486:	461a      	mov	r2, r3
    2488:	9b03      	ldr	r3, [sp, #12]
    248a:	4293      	cmp	r3, r2
    248c:	d3ce      	bcc.n	242c <Clock_Ip_InitClock+0xf0>
    }

    /* Initialize clock objects, internal driver data */
    Clock_Ip_UpdateDriverContext(Config);
    248e:	9801      	ldr	r0, [sp, #4]
    2490:	f7ff fdb0 	bl	1ff4 <Clock_Ip_UpdateDriverContext>

    /* Configure the PCFS  */
    for (Index = 0U; Index < Config->PcfsCount; Index++)       /* Configure all progressive frequency switching clocks from configuration */
    2494:	2300      	movs	r3, #0
    2496:	9303      	str	r3, [sp, #12]
    2498:	e028      	b.n	24ec <Clock_Ip_InitClock+0x1b0>
    {
        CallbackIndex = Clock_Ip_au8PcfsCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Pcfs[Index].Name][CLOCK_IP_CALLBACK]];
    249a:	9901      	ldr	r1, [sp, #4]
    249c:	9a03      	ldr	r2, [sp, #12]
    249e:	4613      	mov	r3, r2
    24a0:	009b      	lsls	r3, r3, #2
    24a2:	4413      	add	r3, r2
    24a4:	009b      	lsls	r3, r3, #2
    24a6:	440b      	add	r3, r1
    24a8:	f503 736f 	add.w	r3, r3, #956	; 0x3bc
    24ac:	681a      	ldr	r2, [r3, #0]
    24ae:	4945      	ldr	r1, [pc, #276]	; (25c4 <Clock_Ip_InitClock+0x288>)
    24b0:	4613      	mov	r3, r2
    24b2:	00db      	lsls	r3, r3, #3
    24b4:	4413      	add	r3, r2
    24b6:	440b      	add	r3, r1
    24b8:	3301      	adds	r3, #1
    24ba:	781b      	ldrb	r3, [r3, #0]
    24bc:	461a      	mov	r2, r3
    24be:	4b48      	ldr	r3, [pc, #288]	; (25e0 <Clock_Ip_InitClock+0x2a4>)
    24c0:	5c9b      	ldrb	r3, [r3, r2]
    24c2:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPcfsCallbacks[CallbackIndex].Set(&Config->Pcfs[Index], Index);
    24c4:	4a47      	ldr	r2, [pc, #284]	; (25e4 <Clock_Ip_InitClock+0x2a8>)
    24c6:	9b02      	ldr	r3, [sp, #8]
    24c8:	f852 4023 	ldr.w	r4, [r2, r3, lsl #2]
    24cc:	9a03      	ldr	r2, [sp, #12]
    24ce:	4613      	mov	r3, r2
    24d0:	009b      	lsls	r3, r3, #2
    24d2:	4413      	add	r3, r2
    24d4:	009b      	lsls	r3, r3, #2
    24d6:	f503 736e 	add.w	r3, r3, #952	; 0x3b8
    24da:	9a01      	ldr	r2, [sp, #4]
    24dc:	4413      	add	r3, r2
    24de:	3304      	adds	r3, #4
    24e0:	9903      	ldr	r1, [sp, #12]
    24e2:	4618      	mov	r0, r3
    24e4:	47a0      	blx	r4
    for (Index = 0U; Index < Config->PcfsCount; Index++)       /* Configure all progressive frequency switching clocks from configuration */
    24e6:	9b03      	ldr	r3, [sp, #12]
    24e8:	3301      	adds	r3, #1
    24ea:	9303      	str	r3, [sp, #12]
    24ec:	9b01      	ldr	r3, [sp, #4]
    24ee:	7c5b      	ldrb	r3, [r3, #17]
    24f0:	461a      	mov	r2, r3
    24f2:	9b03      	ldr	r3, [sp, #12]
    24f4:	4293      	cmp	r3, r2
    24f6:	d3d0      	bcc.n	249a <Clock_Ip_InitClock+0x15e>
    }

    /* Configure the clock divider triggers that are under MCU control */
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    24f8:	2300      	movs	r3, #0
    24fa:	9303      	str	r3, [sp, #12]
    24fc:	e026      	b.n	254c <Clock_Ip_InitClock+0x210>
    {
        CallbackIndex = Clock_Ip_au8DividerTriggerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->DividerTriggers[Index].Name][CLOCK_IP_CALLBACK]];
    24fe:	9901      	ldr	r1, [sp, #4]
    2500:	9a03      	ldr	r2, [sp, #12]
    2502:	4613      	mov	r3, r2
    2504:	005b      	lsls	r3, r3, #1
    2506:	4413      	add	r3, r2
    2508:	009b      	lsls	r3, r3, #2
    250a:	440b      	add	r3, r1
    250c:	f503 730e 	add.w	r3, r3, #568	; 0x238
    2510:	681a      	ldr	r2, [r3, #0]
    2512:	492c      	ldr	r1, [pc, #176]	; (25c4 <Clock_Ip_InitClock+0x288>)
    2514:	4613      	mov	r3, r2
    2516:	00db      	lsls	r3, r3, #3
    2518:	4413      	add	r3, r2
    251a:	440b      	add	r3, r1
    251c:	3301      	adds	r3, #1
    251e:	781b      	ldrb	r3, [r3, #0]
    2520:	461a      	mov	r2, r3
    2522:	4b31      	ldr	r3, [pc, #196]	; (25e8 <Clock_Ip_InitClock+0x2ac>)
    2524:	5c9b      	ldrb	r3, [r3, r2]
    2526:	9302      	str	r3, [sp, #8]
        Clock_Ip_axDividerTriggerCallbacks[CallbackIndex].Configure(&Config->DividerTriggers[Index]);
    2528:	4a30      	ldr	r2, [pc, #192]	; (25ec <Clock_Ip_InitClock+0x2b0>)
    252a:	9b02      	ldr	r3, [sp, #8]
    252c:	f852 1033 	ldr.w	r1, [r2, r3, lsl #3]
    2530:	9a03      	ldr	r2, [sp, #12]
    2532:	4613      	mov	r3, r2
    2534:	005b      	lsls	r3, r3, #1
    2536:	4413      	add	r3, r2
    2538:	009b      	lsls	r3, r3, #2
    253a:	f503 730e 	add.w	r3, r3, #568	; 0x238
    253e:	9a01      	ldr	r2, [sp, #4]
    2540:	4413      	add	r3, r2
    2542:	4618      	mov	r0, r3
    2544:	4788      	blx	r1
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    2546:	9b03      	ldr	r3, [sp, #12]
    2548:	3301      	adds	r3, #1
    254a:	9303      	str	r3, [sp, #12]
    254c:	9b01      	ldr	r3, [sp, #4]
    254e:	7b5b      	ldrb	r3, [r3, #13]
    2550:	461a      	mov	r2, r3
    2552:	9b03      	ldr	r3, [sp, #12]
    2554:	4293      	cmp	r3, r2
    2556:	d3d2      	bcc.n	24fe <Clock_Ip_InitClock+0x1c2>
    }

    /* Configure the clock dividers that are under MCU control */
    for (Index = 0U; Index < Config->DividersCount; Index++)    /* Set dividers from configuration. */
    2558:	2300      	movs	r3, #0
    255a:	9303      	str	r3, [sp, #12]
    255c:	e026      	b.n	25ac <Clock_Ip_InitClock+0x270>
    {
        CallbackIndex = Clock_Ip_au8DividerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Dividers[Index].Name][CLOCK_IP_CALLBACK]];
    255e:	9901      	ldr	r1, [sp, #4]
    2560:	9a03      	ldr	r2, [sp, #12]
    2562:	4613      	mov	r3, r2
    2564:	005b      	lsls	r3, r3, #1
    2566:	4413      	add	r3, r2
    2568:	009b      	lsls	r3, r3, #2
    256a:	440b      	add	r3, r1
    256c:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    2570:	681a      	ldr	r2, [r3, #0]
    2572:	4914      	ldr	r1, [pc, #80]	; (25c4 <Clock_Ip_InitClock+0x288>)
    2574:	4613      	mov	r3, r2
    2576:	00db      	lsls	r3, r3, #3
    2578:	4413      	add	r3, r2
    257a:	440b      	add	r3, r1
    257c:	3301      	adds	r3, #1
    257e:	781b      	ldrb	r3, [r3, #0]
    2580:	461a      	mov	r2, r3
    2582:	4b1b      	ldr	r3, [pc, #108]	; (25f0 <Clock_Ip_InitClock+0x2b4>)
    2584:	5c9b      	ldrb	r3, [r3, r2]
    2586:	9302      	str	r3, [sp, #8]
        Clock_Ip_axDividerCallbacks[CallbackIndex].Set(&Config->Dividers[Index]);
    2588:	4a1a      	ldr	r2, [pc, #104]	; (25f4 <Clock_Ip_InitClock+0x2b8>)
    258a:	9b02      	ldr	r3, [sp, #8]
    258c:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    2590:	9a03      	ldr	r2, [sp, #12]
    2592:	4613      	mov	r3, r2
    2594:	005b      	lsls	r3, r3, #1
    2596:	4413      	add	r3, r2
    2598:	009b      	lsls	r3, r3, #2
    259a:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    259e:	9a01      	ldr	r2, [sp, #4]
    25a0:	4413      	add	r3, r2
    25a2:	4618      	mov	r0, r3
    25a4:	4788      	blx	r1
    for (Index = 0U; Index < Config->DividersCount; Index++)    /* Set dividers from configuration. */
    25a6:	9b03      	ldr	r3, [sp, #12]
    25a8:	3301      	adds	r3, #1
    25aa:	9303      	str	r3, [sp, #12]
    25ac:	9b01      	ldr	r3, [sp, #4]
    25ae:	7b1b      	ldrb	r3, [r3, #12]
    25b0:	461a      	mov	r2, r3
    25b2:	9b03      	ldr	r3, [sp, #12]
    25b4:	4293      	cmp	r3, r2
    25b6:	d3d2      	bcc.n	255e <Clock_Ip_InitClock+0x222>
    }

    /* Trigger update for all divider trigger that are under MCU control */
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    25b8:	2300      	movs	r3, #0
    25ba:	9303      	str	r3, [sp, #12]
    25bc:	e044      	b.n	2648 <Clock_Ip_InitClock+0x30c>
    25be:	bf00      	nop
    25c0:	1fff8b38 	.word	0x1fff8b38
    25c4:	000154d0 	.word	0x000154d0
    25c8:	000154c0 	.word	0x000154c0
    25cc:	00015acc 	.word	0x00015acc
    25d0:	00015460 	.word	0x00015460
    25d4:	00015a90 	.word	0x00015a90
    25d8:	00015450 	.word	0x00015450
    25dc:	00015a24 	.word	0x00015a24
    25e0:	000154b0 	.word	0x000154b0
    25e4:	00015b04 	.word	0x00015b04
    25e8:	00015440 	.word	0x00015440
    25ec:	00015a1c 	.word	0x00015a1c
    25f0:	00015430 	.word	0x00015430
    25f4:	000159e0 	.word	0x000159e0
    {
        CallbackIndex = Clock_Ip_au8DividerTriggerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->DividerTriggers[Index].Name][CLOCK_IP_CALLBACK]];
    25f8:	9901      	ldr	r1, [sp, #4]
    25fa:	9a03      	ldr	r2, [sp, #12]
    25fc:	4613      	mov	r3, r2
    25fe:	005b      	lsls	r3, r3, #1
    2600:	4413      	add	r3, r2
    2602:	009b      	lsls	r3, r3, #2
    2604:	440b      	add	r3, r1
    2606:	f503 730e 	add.w	r3, r3, #568	; 0x238
    260a:	681a      	ldr	r2, [r3, #0]
    260c:	49ac      	ldr	r1, [pc, #688]	; (28c0 <Clock_Ip_InitClock+0x584>)
    260e:	4613      	mov	r3, r2
    2610:	00db      	lsls	r3, r3, #3
    2612:	4413      	add	r3, r2
    2614:	440b      	add	r3, r1
    2616:	3301      	adds	r3, #1
    2618:	781b      	ldrb	r3, [r3, #0]
    261a:	461a      	mov	r2, r3
    261c:	4ba9      	ldr	r3, [pc, #676]	; (28c4 <Clock_Ip_InitClock+0x588>)
    261e:	5c9b      	ldrb	r3, [r3, r2]
    2620:	9302      	str	r3, [sp, #8]
        Clock_Ip_axDividerTriggerCallbacks[CallbackIndex].TriggerUpdate(&Config->DividerTriggers[Index]);
    2622:	4aa9      	ldr	r2, [pc, #676]	; (28c8 <Clock_Ip_InitClock+0x58c>)
    2624:	9b02      	ldr	r3, [sp, #8]
    2626:	00db      	lsls	r3, r3, #3
    2628:	4413      	add	r3, r2
    262a:	6859      	ldr	r1, [r3, #4]
    262c:	9a03      	ldr	r2, [sp, #12]
    262e:	4613      	mov	r3, r2
    2630:	005b      	lsls	r3, r3, #1
    2632:	4413      	add	r3, r2
    2634:	009b      	lsls	r3, r3, #2
    2636:	f503 730e 	add.w	r3, r3, #568	; 0x238
    263a:	9a01      	ldr	r2, [sp, #4]
    263c:	4413      	add	r3, r2
    263e:	4618      	mov	r0, r3
    2640:	4788      	blx	r1
    for (Index = 0U; Index < Config->DividerTriggersCount; Index++)    /* Set divider triggers from configuration. */
    2642:	9b03      	ldr	r3, [sp, #12]
    2644:	3301      	adds	r3, #1
    2646:	9303      	str	r3, [sp, #12]
    2648:	9b01      	ldr	r3, [sp, #4]
    264a:	7b5b      	ldrb	r3, [r3, #13]
    264c:	461a      	mov	r2, r3
    264e:	9b03      	ldr	r3, [sp, #12]
    2650:	4293      	cmp	r3, r2
    2652:	d3d1      	bcc.n	25f8 <Clock_Ip_InitClock+0x2bc>
    }

    /* Configure PLL clock generators */
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Configure all plls from configuration asynchronously. Do not enable. */
    2654:	2300      	movs	r3, #0
    2656:	9303      	str	r3, [sp, #12]
    2658:	e029      	b.n	26ae <Clock_Ip_InitClock+0x372>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Plls[Index].Name][CLOCK_IP_CALLBACK]];
    265a:	9901      	ldr	r1, [sp, #4]
    265c:	9a03      	ldr	r2, [sp, #12]
    265e:	4613      	mov	r3, r2
    2660:	009b      	lsls	r3, r3, #2
    2662:	4413      	add	r3, r2
    2664:	00db      	lsls	r3, r3, #3
    2666:	440b      	add	r3, r1
    2668:	3340      	adds	r3, #64	; 0x40
    266a:	681a      	ldr	r2, [r3, #0]
    266c:	4994      	ldr	r1, [pc, #592]	; (28c0 <Clock_Ip_InitClock+0x584>)
    266e:	4613      	mov	r3, r2
    2670:	00db      	lsls	r3, r3, #3
    2672:	4413      	add	r3, r2
    2674:	440b      	add	r3, r1
    2676:	3301      	adds	r3, #1
    2678:	781b      	ldrb	r3, [r3, #0]
    267a:	461a      	mov	r2, r3
    267c:	4b93      	ldr	r3, [pc, #588]	; (28cc <Clock_Ip_InitClock+0x590>)
    267e:	5c9b      	ldrb	r3, [r3, r2]
    2680:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPllCallbacks[CallbackIndex].Set(&Config->Plls[Index]);
    2682:	4993      	ldr	r1, [pc, #588]	; (28d0 <Clock_Ip_InitClock+0x594>)
    2684:	9a02      	ldr	r2, [sp, #8]
    2686:	4613      	mov	r3, r2
    2688:	009b      	lsls	r3, r3, #2
    268a:	4413      	add	r3, r2
    268c:	009b      	lsls	r3, r3, #2
    268e:	440b      	add	r3, r1
    2690:	3304      	adds	r3, #4
    2692:	6819      	ldr	r1, [r3, #0]
    2694:	9a03      	ldr	r2, [sp, #12]
    2696:	4613      	mov	r3, r2
    2698:	009b      	lsls	r3, r3, #2
    269a:	4413      	add	r3, r2
    269c:	00db      	lsls	r3, r3, #3
    269e:	3340      	adds	r3, #64	; 0x40
    26a0:	9a01      	ldr	r2, [sp, #4]
    26a2:	4413      	add	r3, r2
    26a4:	4618      	mov	r0, r3
    26a6:	4788      	blx	r1
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Configure all plls from configuration asynchronously. Do not enable. */
    26a8:	9b03      	ldr	r3, [sp, #12]
    26aa:	3301      	adds	r3, #1
    26ac:	9303      	str	r3, [sp, #12]
    26ae:	9b01      	ldr	r3, [sp, #4]
    26b0:	7a9b      	ldrb	r3, [r3, #10]
    26b2:	461a      	mov	r2, r3
    26b4:	9b03      	ldr	r3, [sp, #12]
    26b6:	4293      	cmp	r3, r2
    26b8:	d3cf      	bcc.n	265a <Clock_Ip_InitClock+0x31e>
    }

    for (Index = 0U; Index < Config->CmusCount; Index++)     /* Set the Clock Monitoring Units that are under mcu control. Cmus are not enabled. */
    26ba:	2300      	movs	r3, #0
    26bc:	9303      	str	r3, [sp, #12]
    26be:	e029      	b.n	2714 <Clock_Ip_InitClock+0x3d8>
    {
        CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    26c0:	9901      	ldr	r1, [sp, #4]
    26c2:	9a03      	ldr	r2, [sp, #12]
    26c4:	4613      	mov	r3, r2
    26c6:	009b      	lsls	r3, r3, #2
    26c8:	4413      	add	r3, r2
    26ca:	009b      	lsls	r3, r3, #2
    26cc:	440b      	add	r3, r1
    26ce:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    26d2:	681a      	ldr	r2, [r3, #0]
    26d4:	497a      	ldr	r1, [pc, #488]	; (28c0 <Clock_Ip_InitClock+0x584>)
    26d6:	4613      	mov	r3, r2
    26d8:	00db      	lsls	r3, r3, #3
    26da:	4413      	add	r3, r2
    26dc:	440b      	add	r3, r1
    26de:	3301      	adds	r3, #1
    26e0:	781b      	ldrb	r3, [r3, #0]
    26e2:	461a      	mov	r2, r3
    26e4:	4b7b      	ldr	r3, [pc, #492]	; (28d4 <Clock_Ip_InitClock+0x598>)
    26e6:	5c9b      	ldrb	r3, [r3, r2]
    26e8:	9302      	str	r3, [sp, #8]
        Clock_Ip_axCmuCallbacks[CallbackIndex].Set(&Config->Cmus[Index], Index);
    26ea:	4a7b      	ldr	r2, [pc, #492]	; (28d8 <Clock_Ip_InitClock+0x59c>)
    26ec:	9b02      	ldr	r3, [sp, #8]
    26ee:	011b      	lsls	r3, r3, #4
    26f0:	4413      	add	r3, r2
    26f2:	3304      	adds	r3, #4
    26f4:	681c      	ldr	r4, [r3, #0]
    26f6:	9a03      	ldr	r2, [sp, #12]
    26f8:	4613      	mov	r3, r2
    26fa:	009b      	lsls	r3, r3, #2
    26fc:	4413      	add	r3, r2
    26fe:	009b      	lsls	r3, r3, #2
    2700:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    2704:	9a01      	ldr	r2, [sp, #4]
    2706:	4413      	add	r3, r2
    2708:	9903      	ldr	r1, [sp, #12]
    270a:	4618      	mov	r0, r3
    270c:	47a0      	blx	r4
    for (Index = 0U; Index < Config->CmusCount; Index++)     /* Set the Clock Monitoring Units that are under mcu control. Cmus are not enabled. */
    270e:	9b03      	ldr	r3, [sp, #12]
    2710:	3301      	adds	r3, #1
    2712:	9303      	str	r3, [sp, #12]
    2714:	9b01      	ldr	r3, [sp, #4]
    2716:	7c9b      	ldrb	r3, [r3, #18]
    2718:	461a      	mov	r2, r3
    271a:	9b03      	ldr	r3, [sp, #12]
    271c:	4293      	cmp	r3, r2
    271e:	d3cf      	bcc.n	26c0 <Clock_Ip_InitClock+0x384>
    }

    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Wait for all xoscs from configuration to lock */
    2720:	2300      	movs	r3, #0
    2722:	9303      	str	r3, [sp, #12]
    2724:	e02a      	b.n	277c <Clock_Ip_InitClock+0x440>
    {
        CallbackIndex = Clock_Ip_au8XoscCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Xoscs[Index].Name][CLOCK_IP_CALLBACK]];
    2726:	9901      	ldr	r1, [sp, #4]
    2728:	9a03      	ldr	r2, [sp, #12]
    272a:	4613      	mov	r3, r2
    272c:	009b      	lsls	r3, r3, #2
    272e:	4413      	add	r3, r2
    2730:	009b      	lsls	r3, r3, #2
    2732:	440b      	add	r3, r1
    2734:	332c      	adds	r3, #44	; 0x2c
    2736:	681a      	ldr	r2, [r3, #0]
    2738:	4961      	ldr	r1, [pc, #388]	; (28c0 <Clock_Ip_InitClock+0x584>)
    273a:	4613      	mov	r3, r2
    273c:	00db      	lsls	r3, r3, #3
    273e:	4413      	add	r3, r2
    2740:	440b      	add	r3, r1
    2742:	3301      	adds	r3, #1
    2744:	781b      	ldrb	r3, [r3, #0]
    2746:	461a      	mov	r2, r3
    2748:	4b64      	ldr	r3, [pc, #400]	; (28dc <Clock_Ip_InitClock+0x5a0>)
    274a:	5c9b      	ldrb	r3, [r3, r2]
    274c:	9302      	str	r3, [sp, #8]
        Clock_Ip_axExtOscCallbacks[CallbackIndex].Complete(&Config->Xoscs[Index]);
    274e:	4964      	ldr	r1, [pc, #400]	; (28e0 <Clock_Ip_InitClock+0x5a4>)
    2750:	9a02      	ldr	r2, [sp, #8]
    2752:	4613      	mov	r3, r2
    2754:	009b      	lsls	r3, r3, #2
    2756:	4413      	add	r3, r2
    2758:	009b      	lsls	r3, r3, #2
    275a:	440b      	add	r3, r1
    275c:	3308      	adds	r3, #8
    275e:	6819      	ldr	r1, [r3, #0]
    2760:	9a03      	ldr	r2, [sp, #12]
    2762:	4613      	mov	r3, r2
    2764:	009b      	lsls	r3, r3, #2
    2766:	4413      	add	r3, r2
    2768:	009b      	lsls	r3, r3, #2
    276a:	3328      	adds	r3, #40	; 0x28
    276c:	9a01      	ldr	r2, [sp, #4]
    276e:	4413      	add	r3, r2
    2770:	3304      	adds	r3, #4
    2772:	4618      	mov	r0, r3
    2774:	4788      	blx	r1
    for (Index = 0U; Index < Config->XoscsCount; Index++)     /* Wait for all xoscs from configuration to lock */
    2776:	9b03      	ldr	r3, [sp, #12]
    2778:	3301      	adds	r3, #1
    277a:	9303      	str	r3, [sp, #12]
    277c:	9b01      	ldr	r3, [sp, #4]
    277e:	7a5b      	ldrb	r3, [r3, #9]
    2780:	461a      	mov	r2, r3
    2782:	9b03      	ldr	r3, [sp, #12]
    2784:	4293      	cmp	r3, r2
    2786:	d3ce      	bcc.n	2726 <Clock_Ip_InitClock+0x3ea>
    }

    /* Configure PLL clock generators */
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Enable plls according to configuration asynchronously. Do not wait. */
    2788:	2300      	movs	r3, #0
    278a:	9303      	str	r3, [sp, #12]
    278c:	e029      	b.n	27e2 <Clock_Ip_InitClock+0x4a6>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Plls[Index].Name][CLOCK_IP_CALLBACK]];
    278e:	9901      	ldr	r1, [sp, #4]
    2790:	9a03      	ldr	r2, [sp, #12]
    2792:	4613      	mov	r3, r2
    2794:	009b      	lsls	r3, r3, #2
    2796:	4413      	add	r3, r2
    2798:	00db      	lsls	r3, r3, #3
    279a:	440b      	add	r3, r1
    279c:	3340      	adds	r3, #64	; 0x40
    279e:	681a      	ldr	r2, [r3, #0]
    27a0:	4947      	ldr	r1, [pc, #284]	; (28c0 <Clock_Ip_InitClock+0x584>)
    27a2:	4613      	mov	r3, r2
    27a4:	00db      	lsls	r3, r3, #3
    27a6:	4413      	add	r3, r2
    27a8:	440b      	add	r3, r1
    27aa:	3301      	adds	r3, #1
    27ac:	781b      	ldrb	r3, [r3, #0]
    27ae:	461a      	mov	r2, r3
    27b0:	4b46      	ldr	r3, [pc, #280]	; (28cc <Clock_Ip_InitClock+0x590>)
    27b2:	5c9b      	ldrb	r3, [r3, r2]
    27b4:	9302      	str	r3, [sp, #8]
        Clock_Ip_axPllCallbacks[CallbackIndex].Enable(&Config->Plls[Index]);
    27b6:	4946      	ldr	r1, [pc, #280]	; (28d0 <Clock_Ip_InitClock+0x594>)
    27b8:	9a02      	ldr	r2, [sp, #8]
    27ba:	4613      	mov	r3, r2
    27bc:	009b      	lsls	r3, r3, #2
    27be:	4413      	add	r3, r2
    27c0:	009b      	lsls	r3, r3, #2
    27c2:	440b      	add	r3, r1
    27c4:	330c      	adds	r3, #12
    27c6:	6819      	ldr	r1, [r3, #0]
    27c8:	9a03      	ldr	r2, [sp, #12]
    27ca:	4613      	mov	r3, r2
    27cc:	009b      	lsls	r3, r3, #2
    27ce:	4413      	add	r3, r2
    27d0:	00db      	lsls	r3, r3, #3
    27d2:	3340      	adds	r3, #64	; 0x40
    27d4:	9a01      	ldr	r2, [sp, #4]
    27d6:	4413      	add	r3, r2
    27d8:	4618      	mov	r0, r3
    27da:	4788      	blx	r1
    for (Index = 0U; Index < Config->PllsCount; Index++)       /* Enable plls according to configuration asynchronously. Do not wait. */
    27dc:	9b03      	ldr	r3, [sp, #12]
    27de:	3301      	adds	r3, #1
    27e0:	9303      	str	r3, [sp, #12]
    27e2:	9b01      	ldr	r3, [sp, #4]
    27e4:	7a9b      	ldrb	r3, [r3, #10]
    27e6:	461a      	mov	r2, r3
    27e8:	9b03      	ldr	r3, [sp, #12]
    27ea:	4293      	cmp	r3, r2
    27ec:	d3cf      	bcc.n	278e <Clock_Ip_InitClock+0x452>
    }

    /* Configure fractional dividers */
    /* Note: The DFS configuration might actually need to be done after we
     * know that the PLLs are all locked in "Clock_Ip_GetPllStatus". */
    for (Index = 0U; Index < Config->FracDivsCount; Index++)    /* Configure all fractional dividers from configuration asynchronously. Do not wait. */
    27ee:	2300      	movs	r3, #0
    27f0:	9303      	str	r3, [sp, #12]
    27f2:	e025      	b.n	2840 <Clock_Ip_InitClock+0x504>
    {
        CallbackIndex = Clock_Ip_au8FractionalDividerCallbackIndex[Clock_Ip_au8ClockFeatures[Config->FracDivs[Index].Name][CLOCK_IP_CALLBACK]];
    27f4:	9a01      	ldr	r2, [sp, #4]
    27f6:	9b03      	ldr	r3, [sp, #12]
    27f8:	3324      	adds	r3, #36	; 0x24
    27fa:	011b      	lsls	r3, r3, #4
    27fc:	4413      	add	r3, r2
    27fe:	3304      	adds	r3, #4
    2800:	681a      	ldr	r2, [r3, #0]
    2802:	492f      	ldr	r1, [pc, #188]	; (28c0 <Clock_Ip_InitClock+0x584>)
    2804:	4613      	mov	r3, r2
    2806:	00db      	lsls	r3, r3, #3
    2808:	4413      	add	r3, r2
    280a:	440b      	add	r3, r1
    280c:	3301      	adds	r3, #1
    280e:	781b      	ldrb	r3, [r3, #0]
    2810:	461a      	mov	r2, r3
    2812:	4b34      	ldr	r3, [pc, #208]	; (28e4 <Clock_Ip_InitClock+0x5a8>)
    2814:	5c9b      	ldrb	r3, [r3, r2]
    2816:	9302      	str	r3, [sp, #8]
        Clock_Ip_axFracDivCallbacks[CallbackIndex].Set(&Config->FracDivs[Index]);
    2818:	4933      	ldr	r1, [pc, #204]	; (28e8 <Clock_Ip_InitClock+0x5ac>)
    281a:	9a02      	ldr	r2, [sp, #8]
    281c:	4613      	mov	r3, r2
    281e:	005b      	lsls	r3, r3, #1
    2820:	4413      	add	r3, r2
    2822:	009b      	lsls	r3, r3, #2
    2824:	440b      	add	r3, r1
    2826:	3304      	adds	r3, #4
    2828:	681b      	ldr	r3, [r3, #0]
    282a:	9a03      	ldr	r2, [sp, #12]
    282c:	3224      	adds	r2, #36	; 0x24
    282e:	0112      	lsls	r2, r2, #4
    2830:	9901      	ldr	r1, [sp, #4]
    2832:	440a      	add	r2, r1
    2834:	3204      	adds	r2, #4
    2836:	4610      	mov	r0, r2
    2838:	4798      	blx	r3
    for (Index = 0U; Index < Config->FracDivsCount; Index++)    /* Configure all fractional dividers from configuration asynchronously. Do not wait. */
    283a:	9b03      	ldr	r3, [sp, #12]
    283c:	3301      	adds	r3, #1
    283e:	9303      	str	r3, [sp, #12]
    2840:	9b01      	ldr	r3, [sp, #4]
    2842:	7b9b      	ldrb	r3, [r3, #14]
    2844:	461a      	mov	r2, r3
    2846:	9b03      	ldr	r3, [sp, #12]
    2848:	4293      	cmp	r3, r2
    284a:	d3d3      	bcc.n	27f4 <Clock_Ip_InitClock+0x4b8>
    }

    DriverContext.ClockTreeIsConsumingPll = FALSE;                                  /* Check if clock tree is using a PLL output */
    284c:	4b27      	ldr	r3, [pc, #156]	; (28ec <Clock_Ip_InitClock+0x5b0>)
    284e:	2200      	movs	r2, #0
    2850:	701a      	strb	r2, [r3, #0]
#if (defined(CLOCK_IP_SUPPORTS_WAIT_STATES))
#if(CLOCK_IP_SUPPORTS_WAIT_STATES == STD_ON)
    DriverContext.WaitStatesAreSupported = TRUE;                                    /* Wait states are supported */
#else 
    DriverContext.WaitStatesAreSupported = FALSE;                                   /* Wait states are not supported */ 
    2852:	4b26      	ldr	r3, [pc, #152]	; (28ec <Clock_Ip_InitClock+0x5b0>)
    2854:	2200      	movs	r2, #0
    2856:	705a      	strb	r2, [r3, #1]
#endif /*CLOCK_IP_SUPPORTS_WAIT_STATES == STD_ON */
#else 
    DriverContext.WaitStatesAreSupported = FALSE;                                   /* Wait states are not supported */ 
#endif /* #if (defined(CLOCK_IP_SUPPORTS_WAIT_STATES)) */
    DriverContext.HwPllsNo = CLOCK_IP_NUMBER_OF_HARDWARE_PLL;                       /* Number of plls */
    2858:	4b24      	ldr	r3, [pc, #144]	; (28ec <Clock_Ip_InitClock+0x5b0>)
    285a:	2201      	movs	r2, #1
    285c:	709a      	strb	r2, [r3, #2]
    DriverContext.HwDfsNo = CLOCK_IP_NUMBER_OF_HARDWARE_DFS;                        /* Number of fractional dividers */
    285e:	4b23      	ldr	r3, [pc, #140]	; (28ec <Clock_Ip_InitClock+0x5b0>)
    2860:	2200      	movs	r2, #0
    2862:	70da      	strb	r2, [r3, #3]


    /* Configure wait states */
    Clock_Ip_SetWaitStates();
    2864:	f000 fa9c 	bl	2da0 <Clock_Ip_SetWaitStates>
    /* Switch the clock multiplexers under MCU control to the configured source clocks */
    /* Note: if the configured source clock of a ClockMux is the output clock of a PLL/DFS,
     * the configuration will be skipped and the respective ClockMux will be switched in
     * the "Clock_Ip_DistributePllClock" function instead, when the source clock will have
     * stabilized already. */
    for (Index = 0U; Index < Config->SelectorsCount; Index++)    /* Set only if selected inputs are not clocked from PLLs */
    2868:	2300      	movs	r3, #0
    286a:	9303      	str	r3, [sp, #12]
    286c:	e04c      	b.n	2908 <Clock_Ip_InitClock+0x5cc>
    {
        if ((PLL_TYPE != Clock_Ip_aeSourceTypeClockName[Config->Selectors[Index].Value]))
    286e:	9a01      	ldr	r2, [sp, #4]
    2870:	9b03      	ldr	r3, [sp, #12]
    2872:	330d      	adds	r3, #13
    2874:	00db      	lsls	r3, r3, #3
    2876:	4413      	add	r3, r2
    2878:	685b      	ldr	r3, [r3, #4]
    287a:	4a1d      	ldr	r2, [pc, #116]	; (28f0 <Clock_Ip_InitClock+0x5b4>)
    287c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    2880:	2b03      	cmp	r3, #3
    2882:	d03b      	beq.n	28fc <Clock_Ip_InitClock+0x5c0>
        {

            CallbackIndex = Clock_Ip_au8SelectorCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Selectors[Index].Name][CLOCK_IP_CALLBACK]];
    2884:	9b01      	ldr	r3, [sp, #4]
    2886:	9a03      	ldr	r2, [sp, #12]
    2888:	320d      	adds	r2, #13
    288a:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
    288e:	490c      	ldr	r1, [pc, #48]	; (28c0 <Clock_Ip_InitClock+0x584>)
    2890:	4613      	mov	r3, r2
    2892:	00db      	lsls	r3, r3, #3
    2894:	4413      	add	r3, r2
    2896:	440b      	add	r3, r1
    2898:	3301      	adds	r3, #1
    289a:	781b      	ldrb	r3, [r3, #0]
    289c:	461a      	mov	r2, r3
    289e:	4b15      	ldr	r3, [pc, #84]	; (28f4 <Clock_Ip_InitClock+0x5b8>)
    28a0:	5c9b      	ldrb	r3, [r3, r2]
    28a2:	9302      	str	r3, [sp, #8]
            Clock_Ip_axSelectorCallbacks[CallbackIndex].Set(&Config->Selectors[Index]);
    28a4:	4a14      	ldr	r2, [pc, #80]	; (28f8 <Clock_Ip_InitClock+0x5bc>)
    28a6:	9b02      	ldr	r3, [sp, #8]
    28a8:	00db      	lsls	r3, r3, #3
    28aa:	4413      	add	r3, r2
    28ac:	685b      	ldr	r3, [r3, #4]
    28ae:	9a03      	ldr	r2, [sp, #12]
    28b0:	320d      	adds	r2, #13
    28b2:	00d2      	lsls	r2, r2, #3
    28b4:	9901      	ldr	r1, [sp, #4]
    28b6:	440a      	add	r2, r1
    28b8:	4610      	mov	r0, r2
    28ba:	4798      	blx	r3
    28bc:	e021      	b.n	2902 <Clock_Ip_InitClock+0x5c6>
    28be:	bf00      	nop
    28c0:	000154d0 	.word	0x000154d0
    28c4:	00015440 	.word	0x00015440
    28c8:	00015a1c 	.word	0x00015a1c
    28cc:	00015490 	.word	0x00015490
    28d0:	00015adc 	.word	0x00015adc
    28d4:	000154c0 	.word	0x000154c0
    28d8:	00015acc 	.word	0x00015acc
    28dc:	00015450 	.word	0x00015450
    28e0:	00015a24 	.word	0x00015a24
    28e4:	00015480 	.word	0x00015480
    28e8:	00015a4c 	.word	0x00015a4c
    28ec:	1fff8b40 	.word	0x1fff8b40
    28f0:	0001591c 	.word	0x0001591c
    28f4:	000154a0 	.word	0x000154a0
    28f8:	00015b08 	.word	0x00015b08
        }
        else
        {
            /* At least one mux is consuming pll */
            DriverContext.ClockTreeIsConsumingPll = TRUE;
    28fc:	4b3a      	ldr	r3, [pc, #232]	; (29e8 <Clock_Ip_InitClock+0x6ac>)
    28fe:	2201      	movs	r2, #1
    2900:	701a      	strb	r2, [r3, #0]
    for (Index = 0U; Index < Config->SelectorsCount; Index++)    /* Set only if selected inputs are not clocked from PLLs */
    2902:	9b03      	ldr	r3, [sp, #12]
    2904:	3301      	adds	r3, #1
    2906:	9303      	str	r3, [sp, #12]
    2908:	9b01      	ldr	r3, [sp, #4]
    290a:	7adb      	ldrb	r3, [r3, #11]
    290c:	461a      	mov	r2, r3
    290e:	9b03      	ldr	r3, [sp, #12]
    2910:	4293      	cmp	r3, r2
    2912:	d3ac      	bcc.n	286e <Clock_Ip_InitClock+0x532>
        }
    }

    /* Check if the clock tree is using a PLL output */
    if ( FALSE == DriverContext.ClockTreeIsConsumingPll )
    2914:	4b34      	ldr	r3, [pc, #208]	; (29e8 <Clock_Ip_InitClock+0x6ac>)
    2916:	781b      	ldrb	r3, [r3, #0]
    2918:	f083 0301 	eor.w	r3, r3, #1
    291c:	b2db      	uxtb	r3, r3
    291e:	2b00      	cmp	r3, #0
    2920:	d05e      	beq.n	29e0 <Clock_Ip_InitClock+0x6a4>
    {
        for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    2922:	2300      	movs	r3, #0
    2924:	9303      	str	r3, [sp, #12]
    2926:	e01f      	b.n	2968 <Clock_Ip_InitClock+0x62c>
        {
            CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Gates[Index].Name][CLOCK_IP_CALLBACK]];
    2928:	9a01      	ldr	r2, [sp, #4]
    292a:	9b03      	ldr	r3, [sp, #12]
    292c:	334e      	adds	r3, #78	; 0x4e
    292e:	00db      	lsls	r3, r3, #3
    2930:	4413      	add	r3, r2
    2932:	685a      	ldr	r2, [r3, #4]
    2934:	492d      	ldr	r1, [pc, #180]	; (29ec <Clock_Ip_InitClock+0x6b0>)
    2936:	4613      	mov	r3, r2
    2938:	00db      	lsls	r3, r3, #3
    293a:	4413      	add	r3, r2
    293c:	440b      	add	r3, r1
    293e:	3301      	adds	r3, #1
    2940:	781b      	ldrb	r3, [r3, #0]
    2942:	461a      	mov	r2, r3
    2944:	4b2a      	ldr	r3, [pc, #168]	; (29f0 <Clock_Ip_InitClock+0x6b4>)
    2946:	5c9b      	ldrb	r3, [r3, r2]
    2948:	9302      	str	r3, [sp, #8]
            Clock_Ip_axGateCallbacks[CallbackIndex].Set(&Config->Gates[Index]);
    294a:	4a2a      	ldr	r2, [pc, #168]	; (29f4 <Clock_Ip_InitClock+0x6b8>)
    294c:	9b02      	ldr	r3, [sp, #8]
    294e:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    2952:	9a03      	ldr	r2, [sp, #12]
    2954:	324e      	adds	r2, #78	; 0x4e
    2956:	00d2      	lsls	r2, r2, #3
    2958:	9901      	ldr	r1, [sp, #4]
    295a:	440a      	add	r2, r1
    295c:	3204      	adds	r2, #4
    295e:	4610      	mov	r0, r2
    2960:	4798      	blx	r3
        for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    2962:	9b03      	ldr	r3, [sp, #12]
    2964:	3301      	adds	r3, #1
    2966:	9303      	str	r3, [sp, #12]
    2968:	9b01      	ldr	r3, [sp, #4]
    296a:	7c1b      	ldrb	r3, [r3, #16]
    296c:	461a      	mov	r2, r3
    296e:	9b03      	ldr	r3, [sp, #12]
    2970:	4293      	cmp	r3, r2
    2972:	d3d9      	bcc.n	2928 <Clock_Ip_InitClock+0x5ec>
        }

        /* Enable the Clock Monitoring Units ( CMU0 .. n ) according to configuration. */
        for (Index = 0U; Index < Config->CmusCount; Index++)
    2974:	2300      	movs	r3, #0
    2976:	9303      	str	r3, [sp, #12]
    2978:	e028      	b.n	29cc <Clock_Ip_InitClock+0x690>
        {
            CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Config->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    297a:	9901      	ldr	r1, [sp, #4]
    297c:	9a03      	ldr	r2, [sp, #12]
    297e:	4613      	mov	r3, r2
    2980:	009b      	lsls	r3, r3, #2
    2982:	4413      	add	r3, r2
    2984:	009b      	lsls	r3, r3, #2
    2986:	440b      	add	r3, r1
    2988:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    298c:	681a      	ldr	r2, [r3, #0]
    298e:	4917      	ldr	r1, [pc, #92]	; (29ec <Clock_Ip_InitClock+0x6b0>)
    2990:	4613      	mov	r3, r2
    2992:	00db      	lsls	r3, r3, #3
    2994:	4413      	add	r3, r2
    2996:	440b      	add	r3, r1
    2998:	3301      	adds	r3, #1
    299a:	781b      	ldrb	r3, [r3, #0]
    299c:	461a      	mov	r2, r3
    299e:	4b16      	ldr	r3, [pc, #88]	; (29f8 <Clock_Ip_InitClock+0x6bc>)
    29a0:	5c9b      	ldrb	r3, [r3, r2]
    29a2:	9302      	str	r3, [sp, #8]
            Clock_Ip_axCmuCallbacks[CallbackIndex].Enable(&Config->Cmus[Index]);
    29a4:	4a15      	ldr	r2, [pc, #84]	; (29fc <Clock_Ip_InitClock+0x6c0>)
    29a6:	9b02      	ldr	r3, [sp, #8]
    29a8:	011b      	lsls	r3, r3, #4
    29aa:	4413      	add	r3, r2
    29ac:	330c      	adds	r3, #12
    29ae:	6819      	ldr	r1, [r3, #0]
    29b0:	9a03      	ldr	r2, [sp, #12]
    29b2:	4613      	mov	r3, r2
    29b4:	009b      	lsls	r3, r3, #2
    29b6:	4413      	add	r3, r2
    29b8:	009b      	lsls	r3, r3, #2
    29ba:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    29be:	9a01      	ldr	r2, [sp, #4]
    29c0:	4413      	add	r3, r2
    29c2:	4618      	mov	r0, r3
    29c4:	4788      	blx	r1
        for (Index = 0U; Index < Config->CmusCount; Index++)
    29c6:	9b03      	ldr	r3, [sp, #12]
    29c8:	3301      	adds	r3, #1
    29ca:	9303      	str	r3, [sp, #12]
    29cc:	9b01      	ldr	r3, [sp, #4]
    29ce:	7c9b      	ldrb	r3, [r3, #18]
    29d0:	461a      	mov	r2, r3
    29d2:	9b03      	ldr	r3, [sp, #12]
    29d4:	4293      	cmp	r3, r2
    29d6:	d3d0      	bcc.n	297a <Clock_Ip_InitClock+0x63e>
        }
        /* Disable safe clock if it is supported by platform and it is configured/required. */
        /* Note: Safe clock is the fast internal oscillator clock. It is clocking the clock tree until pll is distributed.
         * At the end of configuration it can be disabled if it is supported on this platform and required/configured. */
        Clock_Ip_Command(Config, CLOCK_IP_DISABLE_SAFE_CLOCK_COMMAND);
    29d8:	2104      	movs	r1, #4
    29da:	9801      	ldr	r0, [sp, #4]
    29dc:	f002 ff48 	bl	5870 <Clock_Ip_Command>
    {
        /* The clock tree is using at least one PLL/DFS output clock as source. */
        /* The user must wait until the PLLs and DFSs are locked by polling Clock_Ip_GetPllStatus */
        /* and then call "Clock_Ip_DistributePllClock" */
    }
}
    29e0:	bf00      	nop
    29e2:	b004      	add	sp, #16
    29e4:	bd10      	pop	{r4, pc}
    29e6:	bf00      	nop
    29e8:	1fff8b40 	.word	0x1fff8b40
    29ec:	000154d0 	.word	0x000154d0
    29f0:	00015470 	.word	0x00015470
    29f4:	00015a58 	.word	0x00015a58
    29f8:	000154c0 	.word	0x000154c0
    29fc:	00015acc 	.word	0x00015acc

00002a00 <Clock_Ip_GetPllStatus>:
 * will calculate frequencies only.
 *
 * @implements Clock_Ip_GetPllStatus_Activity
 * END**********************************************************************************/
Clock_Ip_PllStatusType Clock_Ip_GetPllStatus(void)
{
    2a00:	b500      	push	{lr}
    2a02:	b087      	sub	sp, #28
    Clock_Ip_PllStatusType RetValue = CLOCK_IP_PLL_STATUS_UNDEFINED;
    2a04:	2302      	movs	r3, #2
    2a06:	9305      	str	r3, [sp, #20]
    Clock_Ip_DfsStatusType DfsStatus;

    uint32 Index;
    uint32 CallbackIndex;

    for (Index = 0U; Index < DriverContext.HwPllsNo; Index++)
    2a08:	2300      	movs	r3, #0
    2a0a:	9304      	str	r3, [sp, #16]
    2a0c:	e02c      	b.n	2a68 <Clock_Ip_GetPllStatus+0x68>
    {
        CallbackIndex = Clock_Ip_au8PllCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_aeHwPllName[Index]][CLOCK_IP_CALLBACK]];
    2a0e:	4a36      	ldr	r2, [pc, #216]	; (2ae8 <Clock_Ip_GetPllStatus+0xe8>)
    2a10:	9b04      	ldr	r3, [sp, #16]
    2a12:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    2a16:	4935      	ldr	r1, [pc, #212]	; (2aec <Clock_Ip_GetPllStatus+0xec>)
    2a18:	4613      	mov	r3, r2
    2a1a:	00db      	lsls	r3, r3, #3
    2a1c:	4413      	add	r3, r2
    2a1e:	440b      	add	r3, r1
    2a20:	3301      	adds	r3, #1
    2a22:	781b      	ldrb	r3, [r3, #0]
    2a24:	461a      	mov	r2, r3
    2a26:	4b32      	ldr	r3, [pc, #200]	; (2af0 <Clock_Ip_GetPllStatus+0xf0>)
    2a28:	5c9b      	ldrb	r3, [r3, r2]
    2a2a:	9303      	str	r3, [sp, #12]
        PllStatus = Clock_Ip_axPllCallbacks[CallbackIndex].Complete(Clock_Ip_aeHwPllName[Index]);
    2a2c:	4931      	ldr	r1, [pc, #196]	; (2af4 <Clock_Ip_GetPllStatus+0xf4>)
    2a2e:	9a03      	ldr	r2, [sp, #12]
    2a30:	4613      	mov	r3, r2
    2a32:	009b      	lsls	r3, r3, #2
    2a34:	4413      	add	r3, r2
    2a36:	009b      	lsls	r3, r3, #2
    2a38:	440b      	add	r3, r1
    2a3a:	3308      	adds	r3, #8
    2a3c:	681b      	ldr	r3, [r3, #0]
    2a3e:	492a      	ldr	r1, [pc, #168]	; (2ae8 <Clock_Ip_GetPllStatus+0xe8>)
    2a40:	9a04      	ldr	r2, [sp, #16]
    2a42:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    2a46:	4610      	mov	r0, r2
    2a48:	4798      	blx	r3
    2a4a:	9002      	str	r0, [sp, #8]
        if (STATUS_PLL_UNLOCKED == PllStatus)
    2a4c:	9b02      	ldr	r3, [sp, #8]
    2a4e:	2b01      	cmp	r3, #1
    2a50:	d102      	bne.n	2a58 <Clock_Ip_GetPllStatus+0x58>
        {
            RetValue = CLOCK_IP_PLL_UNLOCKED;
    2a52:	2301      	movs	r3, #1
    2a54:	9305      	str	r3, [sp, #20]
            break;
    2a56:	e00d      	b.n	2a74 <Clock_Ip_GetPllStatus+0x74>
        }
        else
        {
            if (STATUS_PLL_LOCKED == PllStatus)
    2a58:	9b02      	ldr	r3, [sp, #8]
    2a5a:	2b02      	cmp	r3, #2
    2a5c:	d101      	bne.n	2a62 <Clock_Ip_GetPllStatus+0x62>
            {
                RetValue = CLOCK_IP_PLL_LOCKED;
    2a5e:	2300      	movs	r3, #0
    2a60:	9305      	str	r3, [sp, #20]
    for (Index = 0U; Index < DriverContext.HwPllsNo; Index++)
    2a62:	9b04      	ldr	r3, [sp, #16]
    2a64:	3301      	adds	r3, #1
    2a66:	9304      	str	r3, [sp, #16]
    2a68:	4b23      	ldr	r3, [pc, #140]	; (2af8 <Clock_Ip_GetPllStatus+0xf8>)
    2a6a:	789b      	ldrb	r3, [r3, #2]
    2a6c:	461a      	mov	r2, r3
    2a6e:	9b04      	ldr	r3, [sp, #16]
    2a70:	4293      	cmp	r3, r2
    2a72:	d3cc      	bcc.n	2a0e <Clock_Ip_GetPllStatus+0xe>
            }
        }
    }

    if (CLOCK_IP_PLL_LOCKED == RetValue)
    2a74:	9b05      	ldr	r3, [sp, #20]
    2a76:	2b00      	cmp	r3, #0
    2a78:	d130      	bne.n	2adc <Clock_Ip_GetPllStatus+0xdc>
    {
        for (Index = 0U; Index < DriverContext.HwDfsNo; Index++)
    2a7a:	2300      	movs	r3, #0
    2a7c:	9304      	str	r3, [sp, #16]
    2a7e:	e027      	b.n	2ad0 <Clock_Ip_GetPllStatus+0xd0>
        {
            CallbackIndex = Clock_Ip_au8FractionalDividerCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_aeHwDfsName[Index]][CLOCK_IP_CALLBACK]];
    2a80:	4a1e      	ldr	r2, [pc, #120]	; (2afc <Clock_Ip_GetPllStatus+0xfc>)
    2a82:	9b04      	ldr	r3, [sp, #16]
    2a84:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    2a88:	4918      	ldr	r1, [pc, #96]	; (2aec <Clock_Ip_GetPllStatus+0xec>)
    2a8a:	4613      	mov	r3, r2
    2a8c:	00db      	lsls	r3, r3, #3
    2a8e:	4413      	add	r3, r2
    2a90:	440b      	add	r3, r1
    2a92:	3301      	adds	r3, #1
    2a94:	781b      	ldrb	r3, [r3, #0]
    2a96:	461a      	mov	r2, r3
    2a98:	4b19      	ldr	r3, [pc, #100]	; (2b00 <Clock_Ip_GetPllStatus+0x100>)
    2a9a:	5c9b      	ldrb	r3, [r3, r2]
    2a9c:	9303      	str	r3, [sp, #12]
            DfsStatus = Clock_Ip_axFracDivCallbacks[CallbackIndex].Complete(Clock_Ip_aeHwDfsName[Index]);
    2a9e:	4919      	ldr	r1, [pc, #100]	; (2b04 <Clock_Ip_GetPllStatus+0x104>)
    2aa0:	9a03      	ldr	r2, [sp, #12]
    2aa2:	4613      	mov	r3, r2
    2aa4:	005b      	lsls	r3, r3, #1
    2aa6:	4413      	add	r3, r2
    2aa8:	009b      	lsls	r3, r3, #2
    2aaa:	440b      	add	r3, r1
    2aac:	3308      	adds	r3, #8
    2aae:	681b      	ldr	r3, [r3, #0]
    2ab0:	4912      	ldr	r1, [pc, #72]	; (2afc <Clock_Ip_GetPllStatus+0xfc>)
    2ab2:	9a04      	ldr	r2, [sp, #16]
    2ab4:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    2ab8:	4610      	mov	r0, r2
    2aba:	4798      	blx	r3
    2abc:	9001      	str	r0, [sp, #4]
            if (STATUS_DFS_UNLOCKED == DfsStatus)
    2abe:	9b01      	ldr	r3, [sp, #4]
    2ac0:	2b01      	cmp	r3, #1
    2ac2:	d102      	bne.n	2aca <Clock_Ip_GetPllStatus+0xca>
            {
                RetValue = CLOCK_IP_PLL_UNLOCKED;
    2ac4:	2301      	movs	r3, #1
    2ac6:	9305      	str	r3, [sp, #20]
                break;
    2ac8:	e008      	b.n	2adc <Clock_Ip_GetPllStatus+0xdc>
        for (Index = 0U; Index < DriverContext.HwDfsNo; Index++)
    2aca:	9b04      	ldr	r3, [sp, #16]
    2acc:	3301      	adds	r3, #1
    2ace:	9304      	str	r3, [sp, #16]
    2ad0:	4b09      	ldr	r3, [pc, #36]	; (2af8 <Clock_Ip_GetPllStatus+0xf8>)
    2ad2:	78db      	ldrb	r3, [r3, #3]
    2ad4:	461a      	mov	r2, r3
    2ad6:	9b04      	ldr	r3, [sp, #16]
    2ad8:	4293      	cmp	r3, r2
    2ada:	d3d1      	bcc.n	2a80 <Clock_Ip_GetPllStatus+0x80>
            }
        }
    }

    return RetValue;
    2adc:	9b05      	ldr	r3, [sp, #20]
}
    2ade:	4618      	mov	r0, r3
    2ae0:	b007      	add	sp, #28
    2ae2:	f85d fb04 	ldr.w	pc, [sp], #4
    2ae6:	bf00      	nop
    2ae8:	000159d8 	.word	0x000159d8
    2aec:	000154d0 	.word	0x000154d0
    2af0:	00015490 	.word	0x00015490
    2af4:	00015adc 	.word	0x00015adc
    2af8:	1fff8b40 	.word	0x1fff8b40
    2afc:	000159dc 	.word	0x000159dc
    2b00:	00015480 	.word	0x00015480
    2b04:	00015a4c 	.word	0x00015a4c

00002b08 <Clock_Ip_DistributePll>:
 * The function will not distribute the PLL clock if the driver state does not allow it, or the PLL is not stable.
 *
 * @implements Clock_Ip_DistributePll_Activity
 * END**********************************************************************************/
void Clock_Ip_DistributePll(void)
{
    2b08:	b500      	push	{lr}
    2b0a:	b083      	sub	sp, #12
    uint32 CallbackIndex;

    CLOCK_IP_DEV_ASSERT(NULL_PTR != Clock_Ip_pxConfig);
    /* 'Clock_Ip_pxConfig' is set by Clock_Ip_InitClock().
     *  It doesn't make sense to call PLL distribution without clock initialization. */
    if (NULL_PTR != Clock_Ip_pxConfig)
    2b0c:	4b55      	ldr	r3, [pc, #340]	; (2c64 <Clock_Ip_DistributePll+0x15c>)
    2b0e:	681b      	ldr	r3, [r3, #0]
    2b10:	2b00      	cmp	r3, #0
    2b12:	f000 80a2 	beq.w	2c5a <Clock_Ip_DistributePll+0x152>
    {
        for (Index = 0U; Index < Clock_Ip_pxConfig->SelectorsCount; Index++)    /* Set only if selected inputs are clocked from PLLs */
    2b16:	2300      	movs	r3, #0
    2b18:	9301      	str	r3, [sp, #4]
    2b1a:	e02c      	b.n	2b76 <Clock_Ip_DistributePll+0x6e>
        {
            if (PLL_TYPE == Clock_Ip_aeSourceTypeClockName[Clock_Ip_pxConfig->Selectors[Index].Value])
    2b1c:	4b51      	ldr	r3, [pc, #324]	; (2c64 <Clock_Ip_DistributePll+0x15c>)
    2b1e:	681a      	ldr	r2, [r3, #0]
    2b20:	9b01      	ldr	r3, [sp, #4]
    2b22:	330d      	adds	r3, #13
    2b24:	00db      	lsls	r3, r3, #3
    2b26:	4413      	add	r3, r2
    2b28:	685b      	ldr	r3, [r3, #4]
    2b2a:	4a4f      	ldr	r2, [pc, #316]	; (2c68 <Clock_Ip_DistributePll+0x160>)
    2b2c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    2b30:	2b03      	cmp	r3, #3
    2b32:	d11d      	bne.n	2b70 <Clock_Ip_DistributePll+0x68>
            {

                CallbackIndex = Clock_Ip_au8SelectorCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_pxConfig->Selectors[Index].Name][CLOCK_IP_CALLBACK]];
    2b34:	4b4b      	ldr	r3, [pc, #300]	; (2c64 <Clock_Ip_DistributePll+0x15c>)
    2b36:	681b      	ldr	r3, [r3, #0]
    2b38:	9a01      	ldr	r2, [sp, #4]
    2b3a:	320d      	adds	r2, #13
    2b3c:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
    2b40:	494a      	ldr	r1, [pc, #296]	; (2c6c <Clock_Ip_DistributePll+0x164>)
    2b42:	4613      	mov	r3, r2
    2b44:	00db      	lsls	r3, r3, #3
    2b46:	4413      	add	r3, r2
    2b48:	440b      	add	r3, r1
    2b4a:	3301      	adds	r3, #1
    2b4c:	781b      	ldrb	r3, [r3, #0]
    2b4e:	461a      	mov	r2, r3
    2b50:	4b47      	ldr	r3, [pc, #284]	; (2c70 <Clock_Ip_DistributePll+0x168>)
    2b52:	5c9b      	ldrb	r3, [r3, r2]
    2b54:	9300      	str	r3, [sp, #0]
                Clock_Ip_axSelectorCallbacks[CallbackIndex].Set(&Clock_Ip_pxConfig->Selectors[Index]);
    2b56:	4a47      	ldr	r2, [pc, #284]	; (2c74 <Clock_Ip_DistributePll+0x16c>)
    2b58:	9b00      	ldr	r3, [sp, #0]
    2b5a:	00db      	lsls	r3, r3, #3
    2b5c:	4413      	add	r3, r2
    2b5e:	685b      	ldr	r3, [r3, #4]
    2b60:	4a40      	ldr	r2, [pc, #256]	; (2c64 <Clock_Ip_DistributePll+0x15c>)
    2b62:	6811      	ldr	r1, [r2, #0]
    2b64:	9a01      	ldr	r2, [sp, #4]
    2b66:	320d      	adds	r2, #13
    2b68:	00d2      	lsls	r2, r2, #3
    2b6a:	440a      	add	r2, r1
    2b6c:	4610      	mov	r0, r2
    2b6e:	4798      	blx	r3
        for (Index = 0U; Index < Clock_Ip_pxConfig->SelectorsCount; Index++)    /* Set only if selected inputs are clocked from PLLs */
    2b70:	9b01      	ldr	r3, [sp, #4]
    2b72:	3301      	adds	r3, #1
    2b74:	9301      	str	r3, [sp, #4]
    2b76:	4b3b      	ldr	r3, [pc, #236]	; (2c64 <Clock_Ip_DistributePll+0x15c>)
    2b78:	681b      	ldr	r3, [r3, #0]
    2b7a:	7adb      	ldrb	r3, [r3, #11]
    2b7c:	461a      	mov	r2, r3
    2b7e:	9b01      	ldr	r3, [sp, #4]
    2b80:	4293      	cmp	r3, r2
    2b82:	d3cb      	bcc.n	2b1c <Clock_Ip_DistributePll+0x14>
        }

        /* In the case of PLL is enabled but PLL clock source is not used by any clock Mux.
           So, no need to re-configure for CMUs, because they are configured by Clock_Ip_InitClock */
        /* Check if the clock tree is using a PLL output */
        if ( DriverContext.ClockTreeIsConsumingPll )
    2b84:	4b3c      	ldr	r3, [pc, #240]	; (2c78 <Clock_Ip_DistributePll+0x170>)
    2b86:	781b      	ldrb	r3, [r3, #0]
    2b88:	2b00      	cmp	r3, #0
    2b8a:	d066      	beq.n	2c5a <Clock_Ip_DistributePll+0x152>
        {
            for (Index = 0U; Index < Clock_Ip_pxConfig->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    2b8c:	2300      	movs	r3, #0
    2b8e:	9301      	str	r3, [sp, #4]
    2b90:	e021      	b.n	2bd6 <Clock_Ip_DistributePll+0xce>
            {
                CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_pxConfig->Gates[Index].Name][CLOCK_IP_CALLBACK]];
    2b92:	4b34      	ldr	r3, [pc, #208]	; (2c64 <Clock_Ip_DistributePll+0x15c>)
    2b94:	681a      	ldr	r2, [r3, #0]
    2b96:	9b01      	ldr	r3, [sp, #4]
    2b98:	334e      	adds	r3, #78	; 0x4e
    2b9a:	00db      	lsls	r3, r3, #3
    2b9c:	4413      	add	r3, r2
    2b9e:	685a      	ldr	r2, [r3, #4]
    2ba0:	4932      	ldr	r1, [pc, #200]	; (2c6c <Clock_Ip_DistributePll+0x164>)
    2ba2:	4613      	mov	r3, r2
    2ba4:	00db      	lsls	r3, r3, #3
    2ba6:	4413      	add	r3, r2
    2ba8:	440b      	add	r3, r1
    2baa:	3301      	adds	r3, #1
    2bac:	781b      	ldrb	r3, [r3, #0]
    2bae:	461a      	mov	r2, r3
    2bb0:	4b32      	ldr	r3, [pc, #200]	; (2c7c <Clock_Ip_DistributePll+0x174>)
    2bb2:	5c9b      	ldrb	r3, [r3, r2]
    2bb4:	9300      	str	r3, [sp, #0]
                Clock_Ip_axGateCallbacks[CallbackIndex].Set(&Clock_Ip_pxConfig->Gates[Index]);
    2bb6:	4a32      	ldr	r2, [pc, #200]	; (2c80 <Clock_Ip_DistributePll+0x178>)
    2bb8:	9b00      	ldr	r3, [sp, #0]
    2bba:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
    2bbe:	4a29      	ldr	r2, [pc, #164]	; (2c64 <Clock_Ip_DistributePll+0x15c>)
    2bc0:	6811      	ldr	r1, [r2, #0]
    2bc2:	9a01      	ldr	r2, [sp, #4]
    2bc4:	324e      	adds	r2, #78	; 0x4e
    2bc6:	00d2      	lsls	r2, r2, #3
    2bc8:	440a      	add	r2, r1
    2bca:	3204      	adds	r2, #4
    2bcc:	4610      	mov	r0, r2
    2bce:	4798      	blx	r3
            for (Index = 0U; Index < Clock_Ip_pxConfig->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    2bd0:	9b01      	ldr	r3, [sp, #4]
    2bd2:	3301      	adds	r3, #1
    2bd4:	9301      	str	r3, [sp, #4]
    2bd6:	4b23      	ldr	r3, [pc, #140]	; (2c64 <Clock_Ip_DistributePll+0x15c>)
    2bd8:	681b      	ldr	r3, [r3, #0]
    2bda:	7c1b      	ldrb	r3, [r3, #16]
    2bdc:	461a      	mov	r2, r3
    2bde:	9b01      	ldr	r3, [sp, #4]
    2be0:	4293      	cmp	r3, r2
    2be2:	d3d6      	bcc.n	2b92 <Clock_Ip_DistributePll+0x8a>
            }

            /* Enable the Clock Monitoring Units ( CMU0 .. n ) according to configuration. */
            for (Index = 0U; Index < Clock_Ip_pxConfig->CmusCount; Index++)
    2be4:	2300      	movs	r3, #0
    2be6:	9301      	str	r3, [sp, #4]
    2be8:	e02a      	b.n	2c40 <Clock_Ip_DistributePll+0x138>
            {
                CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[Clock_Ip_pxConfig->Cmus[Index].Name][CLOCK_IP_CALLBACK]];
    2bea:	4b1e      	ldr	r3, [pc, #120]	; (2c64 <Clock_Ip_DistributePll+0x15c>)
    2bec:	6819      	ldr	r1, [r3, #0]
    2bee:	9a01      	ldr	r2, [sp, #4]
    2bf0:	4613      	mov	r3, r2
    2bf2:	009b      	lsls	r3, r3, #2
    2bf4:	4413      	add	r3, r2
    2bf6:	009b      	lsls	r3, r3, #2
    2bf8:	440b      	add	r3, r1
    2bfa:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    2bfe:	681a      	ldr	r2, [r3, #0]
    2c00:	491a      	ldr	r1, [pc, #104]	; (2c6c <Clock_Ip_DistributePll+0x164>)
    2c02:	4613      	mov	r3, r2
    2c04:	00db      	lsls	r3, r3, #3
    2c06:	4413      	add	r3, r2
    2c08:	440b      	add	r3, r1
    2c0a:	3301      	adds	r3, #1
    2c0c:	781b      	ldrb	r3, [r3, #0]
    2c0e:	461a      	mov	r2, r3
    2c10:	4b1c      	ldr	r3, [pc, #112]	; (2c84 <Clock_Ip_DistributePll+0x17c>)
    2c12:	5c9b      	ldrb	r3, [r3, r2]
    2c14:	9300      	str	r3, [sp, #0]
                Clock_Ip_axCmuCallbacks[CallbackIndex].Enable(&Clock_Ip_pxConfig->Cmus[Index]);
    2c16:	4a1c      	ldr	r2, [pc, #112]	; (2c88 <Clock_Ip_DistributePll+0x180>)
    2c18:	9b00      	ldr	r3, [sp, #0]
    2c1a:	011b      	lsls	r3, r3, #4
    2c1c:	4413      	add	r3, r2
    2c1e:	330c      	adds	r3, #12
    2c20:	6819      	ldr	r1, [r3, #0]
    2c22:	4b10      	ldr	r3, [pc, #64]	; (2c64 <Clock_Ip_DistributePll+0x15c>)
    2c24:	6818      	ldr	r0, [r3, #0]
    2c26:	9a01      	ldr	r2, [sp, #4]
    2c28:	4613      	mov	r3, r2
    2c2a:	009b      	lsls	r3, r3, #2
    2c2c:	4413      	add	r3, r2
    2c2e:	009b      	lsls	r3, r3, #2
    2c30:	f503 7374 	add.w	r3, r3, #976	; 0x3d0
    2c34:	4403      	add	r3, r0
    2c36:	4618      	mov	r0, r3
    2c38:	4788      	blx	r1
            for (Index = 0U; Index < Clock_Ip_pxConfig->CmusCount; Index++)
    2c3a:	9b01      	ldr	r3, [sp, #4]
    2c3c:	3301      	adds	r3, #1
    2c3e:	9301      	str	r3, [sp, #4]
    2c40:	4b08      	ldr	r3, [pc, #32]	; (2c64 <Clock_Ip_DistributePll+0x15c>)
    2c42:	681b      	ldr	r3, [r3, #0]
    2c44:	7c9b      	ldrb	r3, [r3, #18]
    2c46:	461a      	mov	r2, r3
    2c48:	9b01      	ldr	r3, [sp, #4]
    2c4a:	4293      	cmp	r3, r2
    2c4c:	d3cd      	bcc.n	2bea <Clock_Ip_DistributePll+0xe2>
            }

            /* Disable safe clock if it is supported by platform and it is configured/required. */
            /* Note: Safe clock is the fast internal oscillator clock. It is clocking the clock tree until pll is distributed.
             * At the end of configuration it can be disabled if it is supported on this platform and required/configured. */
            Clock_Ip_Command(Clock_Ip_pxConfig, CLOCK_IP_DISABLE_SAFE_CLOCK_COMMAND);
    2c4e:	4b05      	ldr	r3, [pc, #20]	; (2c64 <Clock_Ip_DistributePll+0x15c>)
    2c50:	681b      	ldr	r3, [r3, #0]
    2c52:	2104      	movs	r1, #4
    2c54:	4618      	mov	r0, r3
    2c56:	f002 fe0b 	bl	5870 <Clock_Ip_Command>
        }
    }
}
    2c5a:	bf00      	nop
    2c5c:	b003      	add	sp, #12
    2c5e:	f85d fb04 	ldr.w	pc, [sp], #4
    2c62:	bf00      	nop
    2c64:	1fff8b38 	.word	0x1fff8b38
    2c68:	0001591c 	.word	0x0001591c
    2c6c:	000154d0 	.word	0x000154d0
    2c70:	000154a0 	.word	0x000154a0
    2c74:	00015b08 	.word	0x00015b08
    2c78:	1fff8b40 	.word	0x1fff8b40
    2c7c:	00015470 	.word	0x00015470
    2c80:	00015a58 	.word	0x00015a58
    2c84:	000154c0 	.word	0x000154c0
    2c88:	00015acc 	.word	0x00015acc

00002c8c <Clock_Ip_DisableClockMonitor>:
 * Description   : Disables a clock monitor.
 *
 * @implements Clock_Ip_DisableClockMonitor_Activity
 * END**********************************************************************************/
void Clock_Ip_DisableClockMonitor(Clock_Ip_NameType ClockName)
{
    2c8c:	b500      	push	{lr}
    2c8e:	b085      	sub	sp, #20
    2c90:	9001      	str	r0, [sp, #4]

    uint32 CallbackIndex;

    CallbackIndex = Clock_Ip_au8CmuCallbackIndex[Clock_Ip_au8ClockFeatures[ClockName][CLOCK_IP_CALLBACK]];
    2c92:	490c      	ldr	r1, [pc, #48]	; (2cc4 <Clock_Ip_DisableClockMonitor+0x38>)
    2c94:	9a01      	ldr	r2, [sp, #4]
    2c96:	4613      	mov	r3, r2
    2c98:	00db      	lsls	r3, r3, #3
    2c9a:	4413      	add	r3, r2
    2c9c:	440b      	add	r3, r1
    2c9e:	3301      	adds	r3, #1
    2ca0:	781b      	ldrb	r3, [r3, #0]
    2ca2:	461a      	mov	r2, r3
    2ca4:	4b08      	ldr	r3, [pc, #32]	; (2cc8 <Clock_Ip_DisableClockMonitor+0x3c>)
    2ca6:	5c9b      	ldrb	r3, [r3, r2]
    2ca8:	9303      	str	r3, [sp, #12]
    Clock_Ip_axCmuCallbacks[CallbackIndex].Disable(ClockName);
    2caa:	4a08      	ldr	r2, [pc, #32]	; (2ccc <Clock_Ip_DisableClockMonitor+0x40>)
    2cac:	9b03      	ldr	r3, [sp, #12]
    2cae:	011b      	lsls	r3, r3, #4
    2cb0:	4413      	add	r3, r2
    2cb2:	3308      	adds	r3, #8
    2cb4:	681b      	ldr	r3, [r3, #0]
    2cb6:	9801      	ldr	r0, [sp, #4]
    2cb8:	4798      	blx	r3
}
    2cba:	bf00      	nop
    2cbc:	b005      	add	sp, #20
    2cbe:	f85d fb04 	ldr.w	pc, [sp], #4
    2cc2:	bf00      	nop
    2cc4:	000154d0 	.word	0x000154d0
    2cc8:	000154c0 	.word	0x000154c0
    2ccc:	00015acc 	.word	0x00015acc

00002cd0 <Clock_Ip_InstallNotificationsCallback>:
 * Description   : This function installs a callback for clock notifications.
 *
 * @implements Clock_Ip_InstallNotificationsCallback_Activity
 * END**********************************************************************************/
void Clock_Ip_InstallNotificationsCallback(Clock_Ip_NotificationsCallbackType Callback)
{
    2cd0:	b082      	sub	sp, #8
    2cd2:	9001      	str	r0, [sp, #4]
    CLOCK_IP_DEV_ASSERT(NULL_PTR != Callback);

    Clock_Ip_pfkNotificationsCallback = Callback;
    2cd4:	4a02      	ldr	r2, [pc, #8]	; (2ce0 <Clock_Ip_InstallNotificationsCallback+0x10>)
    2cd6:	9b01      	ldr	r3, [sp, #4]
    2cd8:	6013      	str	r3, [r2, #0]
}
    2cda:	bf00      	nop
    2cdc:	b002      	add	sp, #8
    2cde:	4770      	bx	lr
    2ce0:	1fff8b14 	.word	0x1fff8b14

00002ce4 <Clock_Ip_DisableModuleClock>:
 * Description   : Disables clock for a peripheral.
 *
 * @implements Clock_Ip_DisableModuleClock_Activity
 * END**********************************************************************************/
void Clock_Ip_DisableModuleClock(Clock_Ip_NameType ClockName)
{
    2ce4:	b500      	push	{lr}
    2ce6:	b085      	sub	sp, #20
    2ce8:	9001      	str	r0, [sp, #4]

    uint32 CallbackIndex;

    CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[ClockName][CLOCK_IP_CALLBACK]];
    2cea:	490c      	ldr	r1, [pc, #48]	; (2d1c <Clock_Ip_DisableModuleClock+0x38>)
    2cec:	9a01      	ldr	r2, [sp, #4]
    2cee:	4613      	mov	r3, r2
    2cf0:	00db      	lsls	r3, r3, #3
    2cf2:	4413      	add	r3, r2
    2cf4:	440b      	add	r3, r1
    2cf6:	3301      	adds	r3, #1
    2cf8:	781b      	ldrb	r3, [r3, #0]
    2cfa:	461a      	mov	r2, r3
    2cfc:	4b08      	ldr	r3, [pc, #32]	; (2d20 <Clock_Ip_DisableModuleClock+0x3c>)
    2cfe:	5c9b      	ldrb	r3, [r3, r2]
    2d00:	9303      	str	r3, [sp, #12]
    Clock_Ip_axGateCallbacks[CallbackIndex].Update(ClockName,TRUE);
    2d02:	4a08      	ldr	r2, [pc, #32]	; (2d24 <Clock_Ip_DisableModuleClock+0x40>)
    2d04:	9b03      	ldr	r3, [sp, #12]
    2d06:	00db      	lsls	r3, r3, #3
    2d08:	4413      	add	r3, r2
    2d0a:	685b      	ldr	r3, [r3, #4]
    2d0c:	2101      	movs	r1, #1
    2d0e:	9801      	ldr	r0, [sp, #4]
    2d10:	4798      	blx	r3
}
    2d12:	bf00      	nop
    2d14:	b005      	add	sp, #20
    2d16:	f85d fb04 	ldr.w	pc, [sp], #4
    2d1a:	bf00      	nop
    2d1c:	000154d0 	.word	0x000154d0
    2d20:	00015470 	.word	0x00015470
    2d24:	00015a58 	.word	0x00015a58

00002d28 <Clock_Ip_EnableModuleClock>:
 * Description   : Enable clock for a peripheral.
 *
 * @implements Clock_Ip_EnableModuleClock_Activity
 * END**********************************************************************************/
void Clock_Ip_EnableModuleClock(Clock_Ip_NameType ClockName)
{
    2d28:	b500      	push	{lr}
    2d2a:	b085      	sub	sp, #20
    2d2c:	9001      	str	r0, [sp, #4]

    uint32 CallbackIndex;

    CallbackIndex = Clock_Ip_au8GateCallbackIndex[Clock_Ip_au8ClockFeatures[ClockName][CLOCK_IP_CALLBACK]];
    2d2e:	490c      	ldr	r1, [pc, #48]	; (2d60 <Clock_Ip_EnableModuleClock+0x38>)
    2d30:	9a01      	ldr	r2, [sp, #4]
    2d32:	4613      	mov	r3, r2
    2d34:	00db      	lsls	r3, r3, #3
    2d36:	4413      	add	r3, r2
    2d38:	440b      	add	r3, r1
    2d3a:	3301      	adds	r3, #1
    2d3c:	781b      	ldrb	r3, [r3, #0]
    2d3e:	461a      	mov	r2, r3
    2d40:	4b08      	ldr	r3, [pc, #32]	; (2d64 <Clock_Ip_EnableModuleClock+0x3c>)
    2d42:	5c9b      	ldrb	r3, [r3, r2]
    2d44:	9303      	str	r3, [sp, #12]
    Clock_Ip_axGateCallbacks[CallbackIndex].Update(ClockName,FALSE);
    2d46:	4a08      	ldr	r2, [pc, #32]	; (2d68 <Clock_Ip_EnableModuleClock+0x40>)
    2d48:	9b03      	ldr	r3, [sp, #12]
    2d4a:	00db      	lsls	r3, r3, #3
    2d4c:	4413      	add	r3, r2
    2d4e:	685b      	ldr	r3, [r3, #4]
    2d50:	2100      	movs	r1, #0
    2d52:	9801      	ldr	r0, [sp, #4]
    2d54:	4798      	blx	r3
}
    2d56:	bf00      	nop
    2d58:	b005      	add	sp, #20
    2d5a:	f85d fb04 	ldr.w	pc, [sp], #4
    2d5e:	bf00      	nop
    2d60:	000154d0 	.word	0x000154d0
    2d64:	00015470 	.word	0x00015470
    2d68:	00015a58 	.word	0x00015a58

00002d6c <Clock_Ip_PowerModeChangeNotification>:
 * Description   : Notifies clock driver when a power mode is changed.
 *
 * @implements Clock_Ip_PowerModeChangeNotification_Activity
 * END**********************************************************************************/
void Clock_Ip_PowerModeChangeNotification(Clock_Ip_PowerModesType PowerMode,Clock_Ip_PowerNotificationType Notification)
{
    2d6c:	b500      	push	{lr}
    2d6e:	b083      	sub	sp, #12
    2d70:	9001      	str	r0, [sp, #4]
    2d72:	9100      	str	r1, [sp, #0]
    Clock_Ip_bSentFromUpdateDriverContext  = FALSE;
    2d74:	4b08      	ldr	r3, [pc, #32]	; (2d98 <Clock_Ip_PowerModeChangeNotification+0x2c>)
    2d76:	2200      	movs	r2, #0
    2d78:	701a      	strb	r2, [r3, #0]
    Clock_Ip_Command(Clock_Ip_pxConfig, CLOCK_IP_INITIALIZE_CLOCK_OBJECTS_COMMAND);
    2d7a:	4b08      	ldr	r3, [pc, #32]	; (2d9c <Clock_Ip_PowerModeChangeNotification+0x30>)
    2d7c:	681b      	ldr	r3, [r3, #0]
    2d7e:	2102      	movs	r1, #2
    2d80:	4618      	mov	r0, r3
    2d82:	f002 fd75 	bl	5870 <Clock_Ip_Command>

    Clock_Ip_ClockPowerModeChangeNotification(PowerMode, Notification);
    2d86:	9900      	ldr	r1, [sp, #0]
    2d88:	9801      	ldr	r0, [sp, #4]
    2d8a:	f002 fc51 	bl	5630 <Clock_Ip_ClockPowerModeChangeNotification>
}
    2d8e:	bf00      	nop
    2d90:	b003      	add	sp, #12
    2d92:	f85d fb04 	ldr.w	pc, [sp], #4
    2d96:	bf00      	nop
    2d98:	1fff8b10 	.word	0x1fff8b10
    2d9c:	1fff8b38 	.word	0x1fff8b38

00002da0 <Clock_Ip_SetWaitStates>:
 * Function Name : Clock_Ip_SetWaitStates
 * Description   : Hardware wait states are not supported, checking function.
 *
 *END**************************************************************************/
static void Clock_Ip_SetWaitStates(void)
{
    2da0:	b082      	sub	sp, #8
    uint32 Counter = CLOCK_IP_WAIT_STATES_DELAY;
    2da2:	f06f 5380 	mvn.w	r3, #268435456	; 0x10000000
    2da6:	9301      	str	r3, [sp, #4]
    
    /* HW doesn't support wait states configuration */
    if (DriverContext.WaitStatesAreSupported)
    2da8:	4b06      	ldr	r3, [pc, #24]	; (2dc4 <Clock_Ip_SetWaitStates+0x24>)
    2daa:	785b      	ldrb	r3, [r3, #1]
    2dac:	2b00      	cmp	r3, #0
    2dae:	d005      	beq.n	2dbc <Clock_Ip_SetWaitStates+0x1c>
        /* Wait states are not supported by HW,
           insert a delay . */

        do
        {
            Counter--;
    2db0:	9b01      	ldr	r3, [sp, #4]
    2db2:	3b01      	subs	r3, #1
    2db4:	9301      	str	r3, [sp, #4]
        }
        while(Counter > 0u);
    2db6:	9b01      	ldr	r3, [sp, #4]
    2db8:	2b00      	cmp	r3, #0
    2dba:	d1f9      	bne.n	2db0 <Clock_Ip_SetWaitStates+0x10>
    }
}
    2dbc:	bf00      	nop
    2dbe:	b002      	add	sp, #8
    2dc0:	4770      	bx	lr
    2dc2:	bf00      	nop
    2dc4:	1fff8b40 	.word	0x1fff8b40

00002dc8 <Clock_Ip_ReportClockErrors>:
 * Function Name : Clock_Ip_ReportClockErrors
 * Description   : Report clock error
 *
 *END**************************************************************************/
void Clock_Ip_ReportClockErrors(Clock_Ip_NotificationType Error, Clock_Ip_NameType ClockName)
{
    2dc8:	b500      	push	{lr}
    2dca:	b083      	sub	sp, #12
    2dcc:	9001      	str	r0, [sp, #4]
    2dce:	9100      	str	r1, [sp, #0]
    Clock_Ip_pfkNotificationsCallback(Error,ClockName);
    2dd0:	4b04      	ldr	r3, [pc, #16]	; (2de4 <Clock_Ip_ReportClockErrors+0x1c>)
    2dd2:	681b      	ldr	r3, [r3, #0]
    2dd4:	9900      	ldr	r1, [sp, #0]
    2dd6:	9801      	ldr	r0, [sp, #4]
    2dd8:	4798      	blx	r3
}
    2dda:	bf00      	nop
    2ddc:	b003      	add	sp, #12
    2dde:	f85d fb04 	ldr.w	pc, [sp], #4
    2de2:	bf00      	nop
    2de4:	1fff8b14 	.word	0x1fff8b14

00002de8 <Clock_Ip_StartTimeout>:
 *END**************************************************************************/
void Clock_Ip_StartTimeout(uint32 *StartTimeOut,
                       uint32 *ElapsedTimeOut,
                       uint32 *TimeoutTicksOut,
                       uint32 TimeoutUs)
{
    2de8:	b500      	push	{lr}
    2dea:	b085      	sub	sp, #20
    2dec:	9003      	str	r0, [sp, #12]
    2dee:	9102      	str	r1, [sp, #8]
    2df0:	9201      	str	r2, [sp, #4]
    2df2:	9300      	str	r3, [sp, #0]
    *StartTimeOut    = OsIf_GetCounter(CLOCK_IP_TIMEOUT_TYPE);
    2df4:	2000      	movs	r0, #0
    2df6:	f7fe ffd1 	bl	1d9c <OsIf_GetCounter>
    2dfa:	4602      	mov	r2, r0
    2dfc:	9b03      	ldr	r3, [sp, #12]
    2dfe:	601a      	str	r2, [r3, #0]
    *ElapsedTimeOut  = 0U;
    2e00:	9b02      	ldr	r3, [sp, #8]
    2e02:	2200      	movs	r2, #0
    2e04:	601a      	str	r2, [r3, #0]
    *TimeoutTicksOut = OsIf_MicrosToTicks(TimeoutUs, CLOCK_IP_TIMEOUT_TYPE);
    2e06:	2100      	movs	r1, #0
    2e08:	9800      	ldr	r0, [sp, #0]
    2e0a:	f7ff f813 	bl	1e34 <OsIf_MicrosToTicks>
    2e0e:	4602      	mov	r2, r0
    2e10:	9b01      	ldr	r3, [sp, #4]
    2e12:	601a      	str	r2, [r3, #0]
}
    2e14:	bf00      	nop
    2e16:	b005      	add	sp, #20
    2e18:	f85d fb04 	ldr.w	pc, [sp], #4

00002e1c <Clock_Ip_TimeoutExpired>:
 *
 *END**************************************************************************/
boolean Clock_Ip_TimeoutExpired(uint32 *StartTimeInOut,
                            uint32 *ElapsedTimeInOut,
                            uint32 TimeoutTicks)
{
    2e1c:	b500      	push	{lr}
    2e1e:	b087      	sub	sp, #28
    2e20:	9003      	str	r0, [sp, #12]
    2e22:	9102      	str	r1, [sp, #8]
    2e24:	9201      	str	r2, [sp, #4]
    boolean RetVal = FALSE;
    2e26:	2300      	movs	r3, #0
    2e28:	f88d 3017 	strb.w	r3, [sp, #23]
    *ElapsedTimeInOut += OsIf_GetElapsed(StartTimeInOut, CLOCK_IP_TIMEOUT_TYPE);
    2e2c:	2100      	movs	r1, #0
    2e2e:	9803      	ldr	r0, [sp, #12]
    2e30:	f7fe ffcd 	bl	1dce <OsIf_GetElapsed>
    2e34:	4602      	mov	r2, r0
    2e36:	9b02      	ldr	r3, [sp, #8]
    2e38:	681b      	ldr	r3, [r3, #0]
    2e3a:	441a      	add	r2, r3
    2e3c:	9b02      	ldr	r3, [sp, #8]
    2e3e:	601a      	str	r2, [r3, #0]

    if (*ElapsedTimeInOut >= TimeoutTicks)
    2e40:	9b02      	ldr	r3, [sp, #8]
    2e42:	681b      	ldr	r3, [r3, #0]
    2e44:	9a01      	ldr	r2, [sp, #4]
    2e46:	429a      	cmp	r2, r3
    2e48:	d802      	bhi.n	2e50 <Clock_Ip_TimeoutExpired+0x34>
    {
        RetVal = TRUE;
    2e4a:	2301      	movs	r3, #1
    2e4c:	f88d 3017 	strb.w	r3, [sp, #23]
    }
    return RetVal;
    2e50:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    2e54:	4618      	mov	r0, r3
    2e56:	b007      	add	sp, #28
    2e58:	f85d fb04 	ldr.w	pc, [sp], #4

00002e5c <Clock_Ip_Callback_DividerEmpty>:
/* Clock start section code */

#include "Mcu_MemMap.h"

static void Clock_Ip_Callback_DividerEmpty(Clock_Ip_DividerConfigType const* Config)
{
    2e5c:	b082      	sub	sp, #8
    2e5e:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    2e60:	bf00      	nop
    2e62:	b002      	add	sp, #8
    2e64:	4770      	bx	lr

00002e66 <Clock_Ip_SetScgAsyncDiv1>:

#ifdef CLOCK_IP_SCG_ASYNC_DIV1
static void Clock_Ip_SetScgAsyncDiv1(Clock_Ip_DividerConfigType const* Config)
{
    2e66:	b500      	push	{lr}
    2e68:	b083      	sub	sp, #12
    2e6a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2e6c:	9b01      	ldr	r3, [sp, #4]
    2e6e:	2b00      	cmp	r3, #0
    2e70:	d002      	beq.n	2e78 <Clock_Ip_SetScgAsyncDiv1+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgAsyncDiv1_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgAsyncDiv1_TrustedCall(Config);
    2e72:	9801      	ldr	r0, [sp, #4]
    2e74:	f000 f8ad 	bl	2fd2 <Clock_Ip_SetScgAsyncDiv1_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2e78:	bf00      	nop
    2e7a:	b003      	add	sp, #12
    2e7c:	f85d fb04 	ldr.w	pc, [sp], #4

00002e80 <Clock_Ip_SetScgAsyncDiv2>:
#endif

#ifdef CLOCK_IP_SCG_ASYNC_DIV2
static void Clock_Ip_SetScgAsyncDiv2(Clock_Ip_DividerConfigType const* Config)
{
    2e80:	b500      	push	{lr}
    2e82:	b083      	sub	sp, #12
    2e84:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2e86:	9b01      	ldr	r3, [sp, #4]
    2e88:	2b00      	cmp	r3, #0
    2e8a:	d002      	beq.n	2e92 <Clock_Ip_SetScgAsyncDiv2+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgAsyncDiv2_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgAsyncDiv2_TrustedCall(Config);
    2e8c:	9801      	ldr	r0, [sp, #4]
    2e8e:	f000 f8cd 	bl	302c <Clock_Ip_SetScgAsyncDiv2_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2e92:	bf00      	nop
    2e94:	b003      	add	sp, #12
    2e96:	f85d fb04 	ldr.w	pc, [sp], #4

00002e9a <Clock_Ip_SetScgRunDivcore>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_RUN
static void Clock_Ip_SetScgRunDivcore(Clock_Ip_DividerConfigType const* Config)
{
    2e9a:	b500      	push	{lr}
    2e9c:	b083      	sub	sp, #12
    2e9e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2ea0:	9b01      	ldr	r3, [sp, #4]
    2ea2:	2b00      	cmp	r3, #0
    2ea4:	d002      	beq.n	2eac <Clock_Ip_SetScgRunDivcore+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunDivcore_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunDivcore_TrustedCall(Config);
    2ea6:	9801      	ldr	r0, [sp, #4]
    2ea8:	f000 f8ee 	bl	3088 <Clock_Ip_SetScgRunDivcore_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2eac:	bf00      	nop
    2eae:	b003      	add	sp, #12
    2eb0:	f85d fb04 	ldr.w	pc, [sp], #4

00002eb4 <Clock_Ip_SetScgRunDivbus>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_RUN
static void Clock_Ip_SetScgRunDivbus(Clock_Ip_DividerConfigType const* Config)
{
    2eb4:	b500      	push	{lr}
    2eb6:	b083      	sub	sp, #12
    2eb8:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2eba:	9b01      	ldr	r3, [sp, #4]
    2ebc:	2b00      	cmp	r3, #0
    2ebe:	d002      	beq.n	2ec6 <Clock_Ip_SetScgRunDivbus+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunDivbus_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunDivbus_TrustedCall(Config);
    2ec0:	9801      	ldr	r0, [sp, #4]
    2ec2:	f000 f8f9 	bl	30b8 <Clock_Ip_SetScgRunDivbus_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2ec6:	bf00      	nop
    2ec8:	b003      	add	sp, #12
    2eca:	f85d fb04 	ldr.w	pc, [sp], #4

00002ece <Clock_Ip_SetScgRunDivslow>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_RUN
static void Clock_Ip_SetScgRunDivslow(Clock_Ip_DividerConfigType const* Config)
{
    2ece:	b500      	push	{lr}
    2ed0:	b083      	sub	sp, #12
    2ed2:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2ed4:	9b01      	ldr	r3, [sp, #4]
    2ed6:	2b00      	cmp	r3, #0
    2ed8:	d002      	beq.n	2ee0 <Clock_Ip_SetScgRunDivslow+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunDivslow_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunDivslow_TrustedCall(Config);
    2eda:	9801      	ldr	r0, [sp, #4]
    2edc:	f000 f904 	bl	30e8 <Clock_Ip_SetScgRunDivslow_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2ee0:	bf00      	nop
    2ee2:	b003      	add	sp, #12
    2ee4:	f85d fb04 	ldr.w	pc, [sp], #4

00002ee8 <Clock_Ip_SetScgVlprDivcore>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_VLPR
static void Clock_Ip_SetScgVlprDivcore(Clock_Ip_DividerConfigType const* Config)
{
    2ee8:	b500      	push	{lr}
    2eea:	b083      	sub	sp, #12
    2eec:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2eee:	9b01      	ldr	r3, [sp, #4]
    2ef0:	2b00      	cmp	r3, #0
    2ef2:	d002      	beq.n	2efa <Clock_Ip_SetScgVlprDivcore+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprDivcore_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprDivcore_TrustedCall(Config);
    2ef4:	9801      	ldr	r0, [sp, #4]
    2ef6:	f000 f90f 	bl	3118 <Clock_Ip_SetScgVlprDivcore_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2efa:	bf00      	nop
    2efc:	b003      	add	sp, #12
    2efe:	f85d fb04 	ldr.w	pc, [sp], #4

00002f02 <Clock_Ip_SetScgVlprDivbus>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_VLPR
static void Clock_Ip_SetScgVlprDivbus(Clock_Ip_DividerConfigType const* Config)
{
    2f02:	b500      	push	{lr}
    2f04:	b083      	sub	sp, #12
    2f06:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2f08:	9b01      	ldr	r3, [sp, #4]
    2f0a:	2b00      	cmp	r3, #0
    2f0c:	d002      	beq.n	2f14 <Clock_Ip_SetScgVlprDivbus+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprDivbus_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprDivbus_TrustedCall(Config);
    2f0e:	9801      	ldr	r0, [sp, #4]
    2f10:	f000 f91a 	bl	3148 <Clock_Ip_SetScgVlprDivbus_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2f14:	bf00      	nop
    2f16:	b003      	add	sp, #12
    2f18:	f85d fb04 	ldr.w	pc, [sp], #4

00002f1c <Clock_Ip_SetScgVlprDivslow>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_VLPR
static void Clock_Ip_SetScgVlprDivslow(Clock_Ip_DividerConfigType const* Config)
{
    2f1c:	b500      	push	{lr}
    2f1e:	b083      	sub	sp, #12
    2f20:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2f22:	9b01      	ldr	r3, [sp, #4]
    2f24:	2b00      	cmp	r3, #0
    2f26:	d002      	beq.n	2f2e <Clock_Ip_SetScgVlprDivslow+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprDivslow_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprDivslow_TrustedCall(Config);
    2f28:	9801      	ldr	r0, [sp, #4]
    2f2a:	f000 f925 	bl	3178 <Clock_Ip_SetScgVlprDivslow_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2f2e:	bf00      	nop
    2f30:	b003      	add	sp, #12
    2f32:	f85d fb04 	ldr.w	pc, [sp], #4

00002f36 <Clock_Ip_SetScgHsrunDivcore>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_HSRUN
static void Clock_Ip_SetScgHsrunDivcore(Clock_Ip_DividerConfigType const* Config)
{
    2f36:	b500      	push	{lr}
    2f38:	b083      	sub	sp, #12
    2f3a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2f3c:	9b01      	ldr	r3, [sp, #4]
    2f3e:	2b00      	cmp	r3, #0
    2f40:	d002      	beq.n	2f48 <Clock_Ip_SetScgHsrunDivcore+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunDivcore_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunDivcore_TrustedCall(Config);
    2f42:	9801      	ldr	r0, [sp, #4]
    2f44:	f000 f930 	bl	31a8 <Clock_Ip_SetScgHsrunDivcore_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2f48:	bf00      	nop
    2f4a:	b003      	add	sp, #12
    2f4c:	f85d fb04 	ldr.w	pc, [sp], #4

00002f50 <Clock_Ip_SetScgHsrunDivbus>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_HSRUN
static void Clock_Ip_SetScgHsrunDivbus(Clock_Ip_DividerConfigType const* Config)
{
    2f50:	b500      	push	{lr}
    2f52:	b083      	sub	sp, #12
    2f54:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2f56:	9b01      	ldr	r3, [sp, #4]
    2f58:	2b00      	cmp	r3, #0
    2f5a:	d002      	beq.n	2f62 <Clock_Ip_SetScgHsrunDivbus+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunDivbus_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunDivbus_TrustedCall(Config);
    2f5c:	9801      	ldr	r0, [sp, #4]
    2f5e:	f000 f93b 	bl	31d8 <Clock_Ip_SetScgHsrunDivbus_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2f62:	bf00      	nop
    2f64:	b003      	add	sp, #12
    2f66:	f85d fb04 	ldr.w	pc, [sp], #4

00002f6a <Clock_Ip_SetScgHsrunDivslow>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_HSRUN
static void Clock_Ip_SetScgHsrunDivslow(Clock_Ip_DividerConfigType const* Config)
{
    2f6a:	b500      	push	{lr}
    2f6c:	b083      	sub	sp, #12
    2f6e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2f70:	9b01      	ldr	r3, [sp, #4]
    2f72:	2b00      	cmp	r3, #0
    2f74:	d002      	beq.n	2f7c <Clock_Ip_SetScgHsrunDivslow+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunDivslow_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunDivslow_TrustedCall(Config);
    2f76:	9801      	ldr	r0, [sp, #4]
    2f78:	f000 f946 	bl	3208 <Clock_Ip_SetScgHsrunDivslow_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2f7c:	bf00      	nop
    2f7e:	b003      	add	sp, #12
    2f80:	f85d fb04 	ldr.w	pc, [sp], #4

00002f84 <Clock_Ip_SetSimClkoutDiv>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_DIV
static void Clock_Ip_SetSimClkoutDiv(Clock_Ip_DividerConfigType const *Config)
{
    2f84:	b500      	push	{lr}
    2f86:	b083      	sub	sp, #12
    2f88:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2f8a:	9b01      	ldr	r3, [sp, #4]
    2f8c:	2b00      	cmp	r3, #0
    2f8e:	d002      	beq.n	2f96 <Clock_Ip_SetSimClkoutDiv+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimClkoutDiv_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimClkoutDiv_TrustedCall(Config);
    2f90:	9801      	ldr	r0, [sp, #4]
    2f92:	f000 f951 	bl	3238 <Clock_Ip_SetSimClkoutDiv_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2f96:	bf00      	nop
    2f98:	b003      	add	sp, #12
    2f9a:	f85d fb04 	ldr.w	pc, [sp], #4

00002f9e <Clock_Ip_SetPccPcdDivFrac>:
#endif

#ifdef CLOCK_IP_PCC_PCD_FRAC
static void Clock_Ip_SetPccPcdDivFrac(Clock_Ip_DividerConfigType const* Config)
{
    2f9e:	b500      	push	{lr}
    2fa0:	b083      	sub	sp, #12
    2fa2:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2fa4:	9b01      	ldr	r3, [sp, #4]
    2fa6:	2b00      	cmp	r3, #0
    2fa8:	d002      	beq.n	2fb0 <Clock_Ip_SetPccPcdDivFrac+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetPccPcdDivFrac_TrustedCall,(Config));
      #else
        Clock_Ip_SetPccPcdDivFrac_TrustedCall(Config);
    2faa:	9801      	ldr	r0, [sp, #4]
    2fac:	f000 f95e 	bl	326c <Clock_Ip_SetPccPcdDivFrac_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2fb0:	bf00      	nop
    2fb2:	b003      	add	sp, #12
    2fb4:	f85d fb04 	ldr.w	pc, [sp], #4

00002fb8 <Clock_Ip_SetSimTraceDivMul>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_DIV_MUL
static void Clock_Ip_SetSimTraceDivMul(Clock_Ip_DividerConfigType const* Config)
{
    2fb8:	b500      	push	{lr}
    2fba:	b083      	sub	sp, #12
    2fbc:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    2fbe:	9b01      	ldr	r3, [sp, #4]
    2fc0:	2b00      	cmp	r3, #0
    2fc2:	d002      	beq.n	2fca <Clock_Ip_SetSimTraceDivMul+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimTraceDivMul_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimTraceDivMul_TrustedCall(Config);
    2fc4:	9801      	ldr	r0, [sp, #4]
    2fc6:	f000 f98b 	bl	32e0 <Clock_Ip_SetSimTraceDivMul_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    2fca:	bf00      	nop
    2fcc:	b003      	add	sp, #12
    2fce:	f85d fb04 	ldr.w	pc, [sp], #4

00002fd2 <Clock_Ip_SetScgAsyncDiv1_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SCG_ASYNC_DIV1
void Clock_Ip_SetScgAsyncDiv1_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    2fd2:	b086      	sub	sp, #24
    2fd4:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    2fd6:	9b01      	ldr	r3, [sp, #4]
    2fd8:	681a      	ldr	r2, [r3, #0]
    2fda:	4911      	ldr	r1, [pc, #68]	; (3020 <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x4e>)
    2fdc:	4613      	mov	r3, r2
    2fde:	00db      	lsls	r3, r3, #3
    2fe0:	4413      	add	r3, r2
    2fe2:	440b      	add	r3, r1
    2fe4:	781b      	ldrb	r3, [r3, #0]
    2fe6:	9305      	str	r3, [sp, #20]
    uint32 DividerValue  = Clock_Ip_au8DividerValueHardwareValue[Config->Value];    /* Hw value corresponding to divider value. Translate the value by which is divided to hardware value. */
    2fe8:	9b01      	ldr	r3, [sp, #4]
    2fea:	685b      	ldr	r3, [r3, #4]
    2fec:	4a0d      	ldr	r2, [pc, #52]	; (3024 <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x52>)
    2fee:	5cd3      	ldrb	r3, [r2, r3]
    2ff0:	9304      	str	r3, [sp, #16]


    RegValue = Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV;
    2ff2:	4a0d      	ldr	r2, [pc, #52]	; (3028 <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x56>)
    2ff4:	9b05      	ldr	r3, [sp, #20]
    2ff6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    2ffa:	681b      	ldr	r3, [r3, #0]
    2ffc:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_SIRCDIV_SIRCDIV1_MASK;
    2ffe:	9b03      	ldr	r3, [sp, #12]
    3000:	f023 0307 	bic.w	r3, r3, #7
    3004:	9303      	str	r3, [sp, #12]
    RegValue |= (DividerValue << SCG_SIRCDIV_SIRCDIV1_SHIFT);
    3006:	9a03      	ldr	r2, [sp, #12]
    3008:	9b04      	ldr	r3, [sp, #16]
    300a:	4313      	orrs	r3, r2
    300c:	9303      	str	r3, [sp, #12]
    Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV = RegValue;
    300e:	4a06      	ldr	r2, [pc, #24]	; (3028 <Clock_Ip_SetScgAsyncDiv1_TrustedCall+0x56>)
    3010:	9b05      	ldr	r3, [sp, #20]
    3012:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    3016:	9a03      	ldr	r2, [sp, #12]
    3018:	601a      	str	r2, [r3, #0]
}
    301a:	bf00      	nop
    301c:	b006      	add	sp, #24
    301e:	4770      	bx	lr
    3020:	000154d0 	.word	0x000154d0
    3024:	000158c8 	.word	0x000158c8
    3028:	0001590c 	.word	0x0001590c

0000302c <Clock_Ip_SetScgAsyncDiv2_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_ASYNC_DIV2
void Clock_Ip_SetScgAsyncDiv2_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    302c:	b086      	sub	sp, #24
    302e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    3030:	9b01      	ldr	r3, [sp, #4]
    3032:	681a      	ldr	r2, [r3, #0]
    3034:	4911      	ldr	r1, [pc, #68]	; (307c <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x50>)
    3036:	4613      	mov	r3, r2
    3038:	00db      	lsls	r3, r3, #3
    303a:	4413      	add	r3, r2
    303c:	440b      	add	r3, r1
    303e:	781b      	ldrb	r3, [r3, #0]
    3040:	9305      	str	r3, [sp, #20]
    uint32 DividerValue  = Clock_Ip_au8DividerValueHardwareValue[Config->Value];    /* Hw value corresponding to divider value. Translate the value by which is divided to hardware value. */
    3042:	9b01      	ldr	r3, [sp, #4]
    3044:	685b      	ldr	r3, [r3, #4]
    3046:	4a0e      	ldr	r2, [pc, #56]	; (3080 <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x54>)
    3048:	5cd3      	ldrb	r3, [r2, r3]
    304a:	9304      	str	r3, [sp, #16]

    RegValue = Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV;
    304c:	4a0d      	ldr	r2, [pc, #52]	; (3084 <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x58>)
    304e:	9b05      	ldr	r3, [sp, #20]
    3050:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    3054:	681b      	ldr	r3, [r3, #0]
    3056:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_SIRCDIV_SIRCDIV2_MASK;
    3058:	9b03      	ldr	r3, [sp, #12]
    305a:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    305e:	9303      	str	r3, [sp, #12]
    RegValue |= (DividerValue << SCG_SIRCDIV_SIRCDIV2_SHIFT);
    3060:	9b04      	ldr	r3, [sp, #16]
    3062:	021b      	lsls	r3, r3, #8
    3064:	9a03      	ldr	r2, [sp, #12]
    3066:	4313      	orrs	r3, r2
    3068:	9303      	str	r3, [sp, #12]
    Clock_Ip_apxScgPeriphAsyncDivs[Instance]->ASYNC_DIV = RegValue;
    306a:	4a06      	ldr	r2, [pc, #24]	; (3084 <Clock_Ip_SetScgAsyncDiv2_TrustedCall+0x58>)
    306c:	9b05      	ldr	r3, [sp, #20]
    306e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    3072:	9a03      	ldr	r2, [sp, #12]
    3074:	601a      	str	r2, [r3, #0]
}
    3076:	bf00      	nop
    3078:	b006      	add	sp, #24
    307a:	4770      	bx	lr
    307c:	000154d0 	.word	0x000154d0
    3080:	000158c8 	.word	0x000158c8
    3084:	0001590c 	.word	0x0001590c

00003088 <Clock_Ip_SetScgRunDivcore_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_RUN
/* Set divider value of CORE_RUN_CLK to register */
void Clock_Ip_SetScgRunDivcore_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    3088:	b084      	sub	sp, #16
    308a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->RCCR;
    308c:	4b09      	ldr	r3, [pc, #36]	; (30b4 <Clock_Ip_SetScgRunDivcore_TrustedCall+0x2c>)
    308e:	695b      	ldr	r3, [r3, #20]
    3090:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_RCCR_DIVCORE_MASK;
    3092:	9b03      	ldr	r3, [sp, #12]
    3094:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    3098:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_RCCR_DIVCORE_SHIFT);
    309a:	9b01      	ldr	r3, [sp, #4]
    309c:	685b      	ldr	r3, [r3, #4]
    309e:	3b01      	subs	r3, #1
    30a0:	041b      	lsls	r3, r3, #16
    30a2:	9a03      	ldr	r2, [sp, #12]
    30a4:	4313      	orrs	r3, r2
    30a6:	9303      	str	r3, [sp, #12]
    IP_SCG->RCCR = RegValue;
    30a8:	4a02      	ldr	r2, [pc, #8]	; (30b4 <Clock_Ip_SetScgRunDivcore_TrustedCall+0x2c>)
    30aa:	9b03      	ldr	r3, [sp, #12]
    30ac:	6153      	str	r3, [r2, #20]
}
    30ae:	bf00      	nop
    30b0:	b004      	add	sp, #16
    30b2:	4770      	bx	lr
    30b4:	40064000 	.word	0x40064000

000030b8 <Clock_Ip_SetScgRunDivbus_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_RUN
/* Set divider value of BUS_RUN_CLK to register */
void Clock_Ip_SetScgRunDivbus_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    30b8:	b084      	sub	sp, #16
    30ba:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->RCCR;
    30bc:	4b09      	ldr	r3, [pc, #36]	; (30e4 <Clock_Ip_SetScgRunDivbus_TrustedCall+0x2c>)
    30be:	695b      	ldr	r3, [r3, #20]
    30c0:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_RCCR_DIVBUS_MASK;
    30c2:	9b03      	ldr	r3, [sp, #12]
    30c4:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    30c8:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_RCCR_DIVBUS_SHIFT);
    30ca:	9b01      	ldr	r3, [sp, #4]
    30cc:	685b      	ldr	r3, [r3, #4]
    30ce:	3b01      	subs	r3, #1
    30d0:	011b      	lsls	r3, r3, #4
    30d2:	9a03      	ldr	r2, [sp, #12]
    30d4:	4313      	orrs	r3, r2
    30d6:	9303      	str	r3, [sp, #12]
    IP_SCG->RCCR = RegValue;
    30d8:	4a02      	ldr	r2, [pc, #8]	; (30e4 <Clock_Ip_SetScgRunDivbus_TrustedCall+0x2c>)
    30da:	9b03      	ldr	r3, [sp, #12]
    30dc:	6153      	str	r3, [r2, #20]
}
    30de:	bf00      	nop
    30e0:	b004      	add	sp, #16
    30e2:	4770      	bx	lr
    30e4:	40064000 	.word	0x40064000

000030e8 <Clock_Ip_SetScgRunDivslow_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_RUN
/* Set divider value of SLOW_RUN_CLK to register */
void Clock_Ip_SetScgRunDivslow_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    30e8:	b084      	sub	sp, #16
    30ea:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->RCCR;
    30ec:	4b09      	ldr	r3, [pc, #36]	; (3114 <Clock_Ip_SetScgRunDivslow_TrustedCall+0x2c>)
    30ee:	695b      	ldr	r3, [r3, #20]
    30f0:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_RCCR_DIVSLOW_MASK;
    30f2:	9b03      	ldr	r3, [sp, #12]
    30f4:	f023 030f 	bic.w	r3, r3, #15
    30f8:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_RCCR_DIVSLOW_SHIFT);
    30fa:	9b01      	ldr	r3, [sp, #4]
    30fc:	685b      	ldr	r3, [r3, #4]
    30fe:	3b01      	subs	r3, #1
    3100:	9a03      	ldr	r2, [sp, #12]
    3102:	4313      	orrs	r3, r2
    3104:	9303      	str	r3, [sp, #12]
    IP_SCG->RCCR = RegValue;
    3106:	4a03      	ldr	r2, [pc, #12]	; (3114 <Clock_Ip_SetScgRunDivslow_TrustedCall+0x2c>)
    3108:	9b03      	ldr	r3, [sp, #12]
    310a:	6153      	str	r3, [r2, #20]
}
    310c:	bf00      	nop
    310e:	b004      	add	sp, #16
    3110:	4770      	bx	lr
    3112:	bf00      	nop
    3114:	40064000 	.word	0x40064000

00003118 <Clock_Ip_SetScgVlprDivcore_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_VLPR
/* Set divider value of CORE_VLPR_CLK to register */
void Clock_Ip_SetScgVlprDivcore_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    3118:	b084      	sub	sp, #16
    311a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->VCCR;
    311c:	4b09      	ldr	r3, [pc, #36]	; (3144 <Clock_Ip_SetScgVlprDivcore_TrustedCall+0x2c>)
    311e:	699b      	ldr	r3, [r3, #24]
    3120:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_VCCR_DIVCORE_MASK;
    3122:	9b03      	ldr	r3, [sp, #12]
    3124:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    3128:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_VCCR_DIVCORE_SHIFT);
    312a:	9b01      	ldr	r3, [sp, #4]
    312c:	685b      	ldr	r3, [r3, #4]
    312e:	3b01      	subs	r3, #1
    3130:	041b      	lsls	r3, r3, #16
    3132:	9a03      	ldr	r2, [sp, #12]
    3134:	4313      	orrs	r3, r2
    3136:	9303      	str	r3, [sp, #12]
    IP_SCG->VCCR = RegValue;
    3138:	4a02      	ldr	r2, [pc, #8]	; (3144 <Clock_Ip_SetScgVlprDivcore_TrustedCall+0x2c>)
    313a:	9b03      	ldr	r3, [sp, #12]
    313c:	6193      	str	r3, [r2, #24]
}
    313e:	bf00      	nop
    3140:	b004      	add	sp, #16
    3142:	4770      	bx	lr
    3144:	40064000 	.word	0x40064000

00003148 <Clock_Ip_SetScgVlprDivbus_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_VLPR
/* Set divider value of BUS_VLPR_CLK to register */
void Clock_Ip_SetScgVlprDivbus_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    3148:	b084      	sub	sp, #16
    314a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->VCCR;
    314c:	4b09      	ldr	r3, [pc, #36]	; (3174 <Clock_Ip_SetScgVlprDivbus_TrustedCall+0x2c>)
    314e:	699b      	ldr	r3, [r3, #24]
    3150:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_VCCR_DIVBUS_MASK;
    3152:	9b03      	ldr	r3, [sp, #12]
    3154:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    3158:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_VCCR_DIVBUS_SHIFT);
    315a:	9b01      	ldr	r3, [sp, #4]
    315c:	685b      	ldr	r3, [r3, #4]
    315e:	3b01      	subs	r3, #1
    3160:	011b      	lsls	r3, r3, #4
    3162:	9a03      	ldr	r2, [sp, #12]
    3164:	4313      	orrs	r3, r2
    3166:	9303      	str	r3, [sp, #12]
    IP_SCG->VCCR = RegValue;
    3168:	4a02      	ldr	r2, [pc, #8]	; (3174 <Clock_Ip_SetScgVlprDivbus_TrustedCall+0x2c>)
    316a:	9b03      	ldr	r3, [sp, #12]
    316c:	6193      	str	r3, [r2, #24]
}
    316e:	bf00      	nop
    3170:	b004      	add	sp, #16
    3172:	4770      	bx	lr
    3174:	40064000 	.word	0x40064000

00003178 <Clock_Ip_SetScgVlprDivslow_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_VLPR
/* Set divider value of SLOW_VLPR_CLK to register */
void Clock_Ip_SetScgVlprDivslow_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    3178:	b084      	sub	sp, #16
    317a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->VCCR;
    317c:	4b09      	ldr	r3, [pc, #36]	; (31a4 <Clock_Ip_SetScgVlprDivslow_TrustedCall+0x2c>)
    317e:	699b      	ldr	r3, [r3, #24]
    3180:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_VCCR_DIVSLOW_MASK;
    3182:	9b03      	ldr	r3, [sp, #12]
    3184:	f023 030f 	bic.w	r3, r3, #15
    3188:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_VCCR_DIVSLOW_SHIFT);
    318a:	9b01      	ldr	r3, [sp, #4]
    318c:	685b      	ldr	r3, [r3, #4]
    318e:	3b01      	subs	r3, #1
    3190:	9a03      	ldr	r2, [sp, #12]
    3192:	4313      	orrs	r3, r2
    3194:	9303      	str	r3, [sp, #12]
    IP_SCG->VCCR = RegValue;
    3196:	4a03      	ldr	r2, [pc, #12]	; (31a4 <Clock_Ip_SetScgVlprDivslow_TrustedCall+0x2c>)
    3198:	9b03      	ldr	r3, [sp, #12]
    319a:	6193      	str	r3, [r2, #24]
}
    319c:	bf00      	nop
    319e:	b004      	add	sp, #16
    31a0:	4770      	bx	lr
    31a2:	bf00      	nop
    31a4:	40064000 	.word	0x40064000

000031a8 <Clock_Ip_SetScgHsrunDivcore_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVCORE_HSRUN
/* Set divider value of CORE_HSRUN_CLK to register */
void Clock_Ip_SetScgHsrunDivcore_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    31a8:	b084      	sub	sp, #16
    31aa:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->HCCR;
    31ac:	4b09      	ldr	r3, [pc, #36]	; (31d4 <Clock_Ip_SetScgHsrunDivcore_TrustedCall+0x2c>)
    31ae:	69db      	ldr	r3, [r3, #28]
    31b0:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_HCCR_DIVCORE_MASK;
    31b2:	9b03      	ldr	r3, [sp, #12]
    31b4:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    31b8:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_HCCR_DIVCORE_SHIFT);
    31ba:	9b01      	ldr	r3, [sp, #4]
    31bc:	685b      	ldr	r3, [r3, #4]
    31be:	3b01      	subs	r3, #1
    31c0:	041b      	lsls	r3, r3, #16
    31c2:	9a03      	ldr	r2, [sp, #12]
    31c4:	4313      	orrs	r3, r2
    31c6:	9303      	str	r3, [sp, #12]
    IP_SCG->HCCR = RegValue;
    31c8:	4a02      	ldr	r2, [pc, #8]	; (31d4 <Clock_Ip_SetScgHsrunDivcore_TrustedCall+0x2c>)
    31ca:	9b03      	ldr	r3, [sp, #12]
    31cc:	61d3      	str	r3, [r2, #28]
}
    31ce:	bf00      	nop
    31d0:	b004      	add	sp, #16
    31d2:	4770      	bx	lr
    31d4:	40064000 	.word	0x40064000

000031d8 <Clock_Ip_SetScgHsrunDivbus_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVBUS_HSRUN
/* Set divider value of BUS_HSRUN_CLK to register */
void Clock_Ip_SetScgHsrunDivbus_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    31d8:	b084      	sub	sp, #16
    31da:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->HCCR;
    31dc:	4b09      	ldr	r3, [pc, #36]	; (3204 <Clock_Ip_SetScgHsrunDivbus_TrustedCall+0x2c>)
    31de:	69db      	ldr	r3, [r3, #28]
    31e0:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_HCCR_DIVBUS_MASK;
    31e2:	9b03      	ldr	r3, [sp, #12]
    31e4:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    31e8:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_HCCR_DIVBUS_SHIFT);
    31ea:	9b01      	ldr	r3, [sp, #4]
    31ec:	685b      	ldr	r3, [r3, #4]
    31ee:	3b01      	subs	r3, #1
    31f0:	011b      	lsls	r3, r3, #4
    31f2:	9a03      	ldr	r2, [sp, #12]
    31f4:	4313      	orrs	r3, r2
    31f6:	9303      	str	r3, [sp, #12]
    IP_SCG->HCCR = RegValue;
    31f8:	4a02      	ldr	r2, [pc, #8]	; (3204 <Clock_Ip_SetScgHsrunDivbus_TrustedCall+0x2c>)
    31fa:	9b03      	ldr	r3, [sp, #12]
    31fc:	61d3      	str	r3, [r2, #28]
}
    31fe:	bf00      	nop
    3200:	b004      	add	sp, #16
    3202:	4770      	bx	lr
    3204:	40064000 	.word	0x40064000

00003208 <Clock_Ip_SetScgHsrunDivslow_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_DIVSLOW_HSRUN
/* Set divider value of SLOW_HSRUN_CLK to register */
void Clock_Ip_SetScgHsrunDivslow_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    3208:	b084      	sub	sp, #16
    320a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SCG->HCCR;
    320c:	4b09      	ldr	r3, [pc, #36]	; (3234 <Clock_Ip_SetScgHsrunDivslow_TrustedCall+0x2c>)
    320e:	69db      	ldr	r3, [r3, #28]
    3210:	9303      	str	r3, [sp, #12]
    RegValue &= ~SCG_HCCR_DIVSLOW_MASK;
    3212:	9b03      	ldr	r3, [sp, #12]
    3214:	f023 030f 	bic.w	r3, r3, #15
    3218:	9303      	str	r3, [sp, #12]
    RegValue |= ((Config->Value - 1U) << SCG_HCCR_DIVSLOW_SHIFT);
    321a:	9b01      	ldr	r3, [sp, #4]
    321c:	685b      	ldr	r3, [r3, #4]
    321e:	3b01      	subs	r3, #1
    3220:	9a03      	ldr	r2, [sp, #12]
    3222:	4313      	orrs	r3, r2
    3224:	9303      	str	r3, [sp, #12]
    IP_SCG->HCCR = RegValue;
    3226:	4a03      	ldr	r2, [pc, #12]	; (3234 <Clock_Ip_SetScgHsrunDivslow_TrustedCall+0x2c>)
    3228:	9b03      	ldr	r3, [sp, #12]
    322a:	61d3      	str	r3, [r2, #28]
}
    322c:	bf00      	nop
    322e:	b004      	add	sp, #16
    3230:	4770      	bx	lr
    3232:	bf00      	nop
    3234:	40064000 	.word	0x40064000

00003238 <Clock_Ip_SetSimClkoutDiv_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_DIV
/* Set divider value of CLKOUT0_CLK to register */
void Clock_Ip_SetSimClkoutDiv_TrustedCall(Clock_Ip_DividerConfigType const *Config)
{
    3238:	b084      	sub	sp, #16
    323a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->CHIPCTL;
    323c:	4b0a      	ldr	r3, [pc, #40]	; (3268 <Clock_Ip_SetSimClkoutDiv_TrustedCall+0x30>)
    323e:	685b      	ldr	r3, [r3, #4]
    3240:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_CHIPCTL_CLKOUTDIV_MASK;
    3242:	9b03      	ldr	r3, [sp, #12]
    3244:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    3248:	9303      	str	r3, [sp, #12]
    RegValue |= SIM_CHIPCTL_CLKOUTDIV(Config->Value - 1U);
    324a:	9b01      	ldr	r3, [sp, #4]
    324c:	685b      	ldr	r3, [r3, #4]
    324e:	3b01      	subs	r3, #1
    3250:	021b      	lsls	r3, r3, #8
    3252:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    3256:	9a03      	ldr	r2, [sp, #12]
    3258:	4313      	orrs	r3, r2
    325a:	9303      	str	r3, [sp, #12]
    IP_SIM->CHIPCTL = RegValue;
    325c:	4a02      	ldr	r2, [pc, #8]	; (3268 <Clock_Ip_SetSimClkoutDiv_TrustedCall+0x30>)
    325e:	9b03      	ldr	r3, [sp, #12]
    3260:	6053      	str	r3, [r2, #4]
}
    3262:	bf00      	nop
    3264:	b004      	add	sp, #16
    3266:	4770      	bx	lr
    3268:	40048000 	.word	0x40048000

0000326c <Clock_Ip_SetPccPcdDivFrac_TrustedCall>:
#endif

#ifdef CLOCK_IP_PCC_PCD_FRAC
void Clock_Ip_SetPccPcdDivFrac_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    326c:	b084      	sub	sp, #16
    326e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_DIVIDER_INDEX]];
    3270:	4919      	ldr	r1, [pc, #100]	; (32d8 <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x6c>)
    3272:	9b01      	ldr	r3, [sp, #4]
    3274:	681a      	ldr	r2, [r3, #0]
    3276:	4819      	ldr	r0, [pc, #100]	; (32dc <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x70>)
    3278:	4613      	mov	r3, r2
    327a:	00db      	lsls	r3, r3, #3
    327c:	4413      	add	r3, r2
    327e:	4403      	add	r3, r0
    3280:	3305      	adds	r3, #5
    3282:	781b      	ldrb	r3, [r3, #0]
    3284:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    3288:	9303      	str	r3, [sp, #12]
    RegValue &= ~(PCC_PCCn_PCD_MASK | PCC_PCCn_FRAC_MASK);
    328a:	9b03      	ldr	r3, [sp, #12]
    328c:	f023 030f 	bic.w	r3, r3, #15
    3290:	9303      	str	r3, [sp, #12]
    RegValue |= PCC_PCCn_PCD(Config->Value - 1U);                            /* Divider */
    3292:	9b01      	ldr	r3, [sp, #4]
    3294:	685b      	ldr	r3, [r3, #4]
    3296:	3b01      	subs	r3, #1
    3298:	f003 0307 	and.w	r3, r3, #7
    329c:	9a03      	ldr	r2, [sp, #12]
    329e:	4313      	orrs	r3, r2
    32a0:	9303      	str	r3, [sp, #12]
    RegValue |= PCC_PCCn_FRAC((uint32)(Config->Options[0U]) - 1U);                        /* Multiplier */
    32a2:	9b01      	ldr	r3, [sp, #4]
    32a4:	7a1b      	ldrb	r3, [r3, #8]
    32a6:	3b01      	subs	r3, #1
    32a8:	00db      	lsls	r3, r3, #3
    32aa:	f003 0308 	and.w	r3, r3, #8
    32ae:	9a03      	ldr	r2, [sp, #12]
    32b0:	4313      	orrs	r3, r2
    32b2:	9303      	str	r3, [sp, #12]
    IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_DIVIDER_INDEX]] = RegValue;
    32b4:	4908      	ldr	r1, [pc, #32]	; (32d8 <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x6c>)
    32b6:	9b01      	ldr	r3, [sp, #4]
    32b8:	681a      	ldr	r2, [r3, #0]
    32ba:	4808      	ldr	r0, [pc, #32]	; (32dc <Clock_Ip_SetPccPcdDivFrac_TrustedCall+0x70>)
    32bc:	4613      	mov	r3, r2
    32be:	00db      	lsls	r3, r3, #3
    32c0:	4413      	add	r3, r2
    32c2:	4403      	add	r3, r0
    32c4:	3305      	adds	r3, #5
    32c6:	781b      	ldrb	r3, [r3, #0]
    32c8:	461a      	mov	r2, r3
    32ca:	9b03      	ldr	r3, [sp, #12]
    32cc:	f841 3022 	str.w	r3, [r1, r2, lsl #2]
}
    32d0:	bf00      	nop
    32d2:	b004      	add	sp, #16
    32d4:	4770      	bx	lr
    32d6:	bf00      	nop
    32d8:	40065000 	.word	0x40065000
    32dc:	000154d0 	.word	0x000154d0

000032e0 <Clock_Ip_SetSimTraceDivMul_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_DIV_MUL
void Clock_Ip_SetSimTraceDivMul_TrustedCall(Clock_Ip_DividerConfigType const* Config)
{
    32e0:	b084      	sub	sp, #16
    32e2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    /* Disable TRACEDIVEN to configure TRACEDIV */
    IP_SIM->CLKDIV4  &= ~(SIM_CLKDIV4_TRACEDIVEN_MASK);
    32e4:	4b10      	ldr	r3, [pc, #64]	; (3328 <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    32e6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    32e8:	4a0f      	ldr	r2, [pc, #60]	; (3328 <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    32ea:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    32ee:	6693      	str	r3, [r2, #104]	; 0x68
    RegValue = IP_SIM->CLKDIV4;
    32f0:	4b0d      	ldr	r3, [pc, #52]	; (3328 <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    32f2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    32f4:	9303      	str	r3, [sp, #12]
    RegValue &= ~(SIM_CLKDIV4_TRACEDIV_MASK | SIM_CLKDIV4_TRACEFRAC_MASK);
    32f6:	9b03      	ldr	r3, [sp, #12]
    32f8:	f023 030f 	bic.w	r3, r3, #15
    32fc:	9303      	str	r3, [sp, #12]
    RegValue |= SIM_CLKDIV4_TRACEDIV((uint32)(Config->Value) - 1U)              |    /* Divider */
    32fe:	9b01      	ldr	r3, [sp, #4]
    3300:	685b      	ldr	r3, [r3, #4]
    3302:	3b01      	subs	r3, #1
    3304:	005b      	lsls	r3, r3, #1
    3306:	f003 020e 	and.w	r2, r3, #14
                     SIM_CLKDIV4_TRACEFRAC((uint32)(Config->Options[0U]) - 1U);                /* Multiplier */
    330a:	9b01      	ldr	r3, [sp, #4]
    330c:	7a1b      	ldrb	r3, [r3, #8]
    330e:	3b01      	subs	r3, #1
    3310:	f003 0301 	and.w	r3, r3, #1
    RegValue |= SIM_CLKDIV4_TRACEDIV((uint32)(Config->Value) - 1U)              |    /* Divider */
    3314:	4313      	orrs	r3, r2
    3316:	9a03      	ldr	r2, [sp, #12]
    3318:	4313      	orrs	r3, r2
    331a:	9303      	str	r3, [sp, #12]
    IP_SIM->CLKDIV4 = RegValue;
    331c:	4a02      	ldr	r2, [pc, #8]	; (3328 <Clock_Ip_SetSimTraceDivMul_TrustedCall+0x48>)
    331e:	9b03      	ldr	r3, [sp, #12]
    3320:	6693      	str	r3, [r2, #104]	; 0x68
}
    3322:	bf00      	nop
    3324:	b004      	add	sp, #16
    3326:	4770      	bx	lr
    3328:	40048000 	.word	0x40048000

0000332c <Clock_Ip_Callback_DividerTriggerEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_Callback_DividerTriggerEmpty(Clock_Ip_DividerTriggerConfigType const* Config)
{
    332c:	b082      	sub	sp, #8
    332e:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    3330:	bf00      	nop
    3332:	b002      	add	sp, #8
    3334:	4770      	bx	lr
	...

00003338 <Clock_Ip_ExternalOscillatorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_ExternalOscillatorEmpty(Clock_Ip_XoscConfigType const* Config)
{
    3338:	b082      	sub	sp, #8
    333a:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    333c:	bf00      	nop
    333e:	b002      	add	sp, #8
    3340:	4770      	bx	lr

00003342 <Clock_Ip_DisableClockIpExternalOscillatorEmpty>:
static void Clock_Ip_DisableClockIpExternalOscillatorEmpty(Clock_Ip_NameType XoscName)
{
    3342:	b082      	sub	sp, #8
    3344:	9001      	str	r0, [sp, #4]
    (void)XoscName;
    /* No implementation */
}
    3346:	bf00      	nop
    3348:	b002      	add	sp, #8
    334a:	4770      	bx	lr

0000334c <Clock_Ip_ResetSOSC>:



#ifdef CLOCK_IP_SOSC_ENABLE
static void Clock_Ip_ResetSOSC(Clock_Ip_XoscConfigType const* Config)
{
    334c:	b500      	push	{lr}
    334e:	b083      	sub	sp, #12
    3350:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3352:	9b01      	ldr	r3, [sp, #4]
    3354:	2b00      	cmp	r3, #0
    3356:	d002      	beq.n	335e <Clock_Ip_ResetSOSC+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSOSC_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSOSC_TrustedCall(Config);
    3358:	9801      	ldr	r0, [sp, #4]
    335a:	f000 f86a 	bl	3432 <Clock_Ip_ResetSOSC_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    335e:	bf00      	nop
    3360:	b003      	add	sp, #12
    3362:	f85d fb04 	ldr.w	pc, [sp], #4

00003366 <Clock_Ip_SetSOSC>:
static void Clock_Ip_SetSOSC(Clock_Ip_XoscConfigType const* Config)
{
    3366:	b500      	push	{lr}
    3368:	b083      	sub	sp, #12
    336a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    336c:	9b01      	ldr	r3, [sp, #4]
    336e:	2b00      	cmp	r3, #0
    3370:	d002      	beq.n	3378 <Clock_Ip_SetSOSC+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSOSC_TrustedCall,(Config));
      #else
        Clock_Ip_SetSOSC_TrustedCall(Config);
    3372:	9801      	ldr	r0, [sp, #4]
    3374:	f000 f884 	bl	3480 <Clock_Ip_SetSOSC_TrustedCall>
    #if (CLOCK_IP_GET_FREQUENCY_API == STD_ON)
        Clock_Ip_SetExternalOscillatorFrequency(Config->Name,Config->Freq);
    #endif
    #endif
    }
}
    3378:	bf00      	nop
    337a:	b003      	add	sp, #12
    337c:	f85d fb04 	ldr.w	pc, [sp], #4

00003380 <Clock_Ip_CompleteSOSC>:
static void Clock_Ip_CompleteSOSC(Clock_Ip_XoscConfigType const* Config)
{
    3380:	b500      	push	{lr}
    3382:	b089      	sub	sp, #36	; 0x24
    3384:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    3386:	2300      	movs	r3, #0
    3388:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 SoscStatus;

    if (NULL_PTR != Config)
    338c:	9b01      	ldr	r3, [sp, #4]
    338e:	2b00      	cmp	r3, #0
    3390:	d031      	beq.n	33f6 <Clock_Ip_CompleteSOSC+0x76>
    {
        /* Configure SOSC. */
        if ((IP_SCG->SOSCCSR & SCG_SOSCCSR_SOSCEN_MASK) != 0U)
    3392:	4b1b      	ldr	r3, [pc, #108]	; (3400 <Clock_Ip_CompleteSOSC+0x80>)
    3394:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    3398:	f003 0301 	and.w	r3, r3, #1
    339c:	2b00      	cmp	r3, #0
    339e:	d02a      	beq.n	33f6 <Clock_Ip_CompleteSOSC+0x76>
        {
            Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    33a0:	aa03      	add	r2, sp, #12
    33a2:	a904      	add	r1, sp, #16
    33a4:	a805      	add	r0, sp, #20
    33a6:	f24c 3350 	movw	r3, #50000	; 0xc350
    33aa:	f7ff fd1d 	bl	2de8 <Clock_Ip_StartTimeout>
            /* Wait until ircosc is locked */
            do
            {
                SoscStatus = (((IP_SCG->SOSCCSR & SCG_SOSCCSR_SOSCVLD_MASK) >> SCG_SOSCCSR_SOSCVLD_SHIFT));
    33ae:	4b14      	ldr	r3, [pc, #80]	; (3400 <Clock_Ip_CompleteSOSC+0x80>)
    33b0:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    33b4:	0e1b      	lsrs	r3, r3, #24
    33b6:	f003 0301 	and.w	r3, r3, #1
    33ba:	9306      	str	r3, [sp, #24]
                TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    33bc:	9a03      	ldr	r2, [sp, #12]
    33be:	a904      	add	r1, sp, #16
    33c0:	ab05      	add	r3, sp, #20
    33c2:	4618      	mov	r0, r3
    33c4:	f7ff fd2a 	bl	2e1c <Clock_Ip_TimeoutExpired>
    33c8:	4603      	mov	r3, r0
    33ca:	f88d 301f 	strb.w	r3, [sp, #31]
            }
            while ((0U == SoscStatus) && (FALSE == TimeoutOccurred));
    33ce:	9b06      	ldr	r3, [sp, #24]
    33d0:	2b00      	cmp	r3, #0
    33d2:	d106      	bne.n	33e2 <Clock_Ip_CompleteSOSC+0x62>
    33d4:	f89d 301f 	ldrb.w	r3, [sp, #31]
    33d8:	f083 0301 	eor.w	r3, r3, #1
    33dc:	b2db      	uxtb	r3, r3
    33de:	2b00      	cmp	r3, #0
    33e0:	d1e5      	bne.n	33ae <Clock_Ip_CompleteSOSC+0x2e>

            if (FALSE != TimeoutOccurred)
    33e2:	f89d 301f 	ldrb.w	r3, [sp, #31]
    33e6:	2b00      	cmp	r3, #0
    33e8:	d005      	beq.n	33f6 <Clock_Ip_CompleteSOSC+0x76>
            {
                /* Report timeout error */
                Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    33ea:	9b01      	ldr	r3, [sp, #4]
    33ec:	681b      	ldr	r3, [r3, #0]
    33ee:	4619      	mov	r1, r3
    33f0:	2001      	movs	r0, #1
    33f2:	f7ff fce9 	bl	2dc8 <Clock_Ip_ReportClockErrors>
        (void)StartTime;
        (void)ElapsedTime;
        (void)TimeoutTicks;
        (void)SoscStatus;
    }
}
    33f6:	bf00      	nop
    33f8:	b009      	add	sp, #36	; 0x24
    33fa:	f85d fb04 	ldr.w	pc, [sp], #4
    33fe:	bf00      	nop
    3400:	40064000 	.word	0x40064000

00003404 <Clock_Ip_DisableSOSC>:
static void Clock_Ip_DisableSOSC(Clock_Ip_NameType XoscName)
{
    3404:	b500      	push	{lr}
    3406:	b083      	sub	sp, #12
    3408:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSOSC_TrustedCall,(XoscName));
  #else
    Clock_Ip_DisableSOSC_TrustedCall(XoscName);
    340a:	9801      	ldr	r0, [sp, #4]
    340c:	f000 f8c0 	bl	3590 <Clock_Ip_DisableSOSC_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    3410:	bf00      	nop
    3412:	b003      	add	sp, #12
    3414:	f85d fb04 	ldr.w	pc, [sp], #4

00003418 <Clock_Ip_EnableSOSC>:
static void Clock_Ip_EnableSOSC(Clock_Ip_XoscConfigType const* Config)
{
    3418:	b500      	push	{lr}
    341a:	b083      	sub	sp, #12
    341c:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    341e:	9b01      	ldr	r3, [sp, #4]
    3420:	2b00      	cmp	r3, #0
    3422:	d002      	beq.n	342a <Clock_Ip_EnableSOSC+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSOSC_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSOSC_TrustedCall(Config);
    3424:	9801      	ldr	r0, [sp, #4]
    3426:	f000 f8c3 	bl	35b0 <Clock_Ip_EnableSOSC_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    342a:	bf00      	nop
    342c:	b003      	add	sp, #12
    342e:	f85d fb04 	ldr.w	pc, [sp], #4

00003432 <Clock_Ip_ResetSOSC_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SOSC_ENABLE
void Clock_Ip_ResetSOSC_TrustedCall(Clock_Ip_XoscConfigType const* Config)
{
    3432:	b082      	sub	sp, #8
    3434:	9001      	str	r0, [sp, #4]
    (void)Config;

    /* Clear LK bit field */
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_LK_MASK));
    3436:	4b11      	ldr	r3, [pc, #68]	; (347c <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    3438:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    343c:	4a0f      	ldr	r2, [pc, #60]	; (347c <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    343e:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    3442:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

    /* Disable clock monitor */
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_SOSCCM_MASK));
    3446:	4b0d      	ldr	r3, [pc, #52]	; (347c <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    3448:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    344c:	4a0b      	ldr	r2, [pc, #44]	; (347c <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    344e:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    3452:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

    /* Disable clock monitor reset*/
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_SOSCCMRE_MASK));
    3456:	4b09      	ldr	r3, [pc, #36]	; (347c <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    3458:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    345c:	4a07      	ldr	r2, [pc, #28]	; (347c <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    345e:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    3462:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

    /* Disable clock */
    IP_SCG->SOSCCSR &= (~((uint32)SCG_SOSCCSR_SOSCEN_MASK));
    3466:	4b05      	ldr	r3, [pc, #20]	; (347c <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    3468:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    346c:	4a03      	ldr	r2, [pc, #12]	; (347c <Clock_Ip_ResetSOSC_TrustedCall+0x4a>)
    346e:	f023 0301 	bic.w	r3, r3, #1
    3472:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
}
    3476:	bf00      	nop
    3478:	b002      	add	sp, #8
    347a:	4770      	bx	lr
    347c:	40064000 	.word	0x40064000

00003480 <Clock_Ip_SetSOSC_TrustedCall>:
void Clock_Ip_SetSOSC_TrustedCall(Clock_Ip_XoscConfigType const* Config)
{
    3480:	b082      	sub	sp, #8
    3482:	9001      	str	r0, [sp, #4]
    /* Configure SOSC. */
    if (1U == Config->Enable)
    3484:	9b01      	ldr	r3, [sp, #4]
    3486:	891b      	ldrh	r3, [r3, #8]
    3488:	2b01      	cmp	r3, #1
    348a:	d174      	bne.n	3576 <Clock_Ip_SetSOSC_TrustedCall+0xf6>
#ifdef CLOCK_IP_GET_FREQUENCY_API
#if (CLOCK_IP_GET_FREQUENCY_API == STD_ON)
        Clock_Ip_SetExternalOscillatorFrequency(Config->Name,Config->Freq);
#endif
#endif
        switch(Config->Gain)
    348c:	9b01      	ldr	r3, [sp, #4]
    348e:	7bdb      	ldrb	r3, [r3, #15]
    3490:	2b00      	cmp	r3, #0
    3492:	d002      	beq.n	349a <Clock_Ip_SetSOSC_TrustedCall+0x1a>
    3494:	2b01      	cmp	r3, #1
    3496:	d009      	beq.n	34ac <Clock_Ip_SetSOSC_TrustedCall+0x2c>
            default:
            {
                /* Invalid configuration element */
                CLOCK_IP_DEV_ASSERT(FALSE);
            }
            break;
    3498:	e011      	b.n	34be <Clock_Ip_SetSOSC_TrustedCall+0x3e>
                IP_SCG->SOSCCFG &= ~SCG_SOSCCFG_HGO_MASK;
    349a:	4b39      	ldr	r3, [pc, #228]	; (3580 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    349c:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    34a0:	4a37      	ldr	r2, [pc, #220]	; (3580 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    34a2:	f023 0308 	bic.w	r3, r3, #8
    34a6:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
            break;
    34aa:	e008      	b.n	34be <Clock_Ip_SetSOSC_TrustedCall+0x3e>
                IP_SCG->SOSCCFG |= SCG_SOSCCFG_HGO_MASK;
    34ac:	4b34      	ldr	r3, [pc, #208]	; (3580 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    34ae:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    34b2:	4a33      	ldr	r2, [pc, #204]	; (3580 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    34b4:	f043 0308 	orr.w	r3, r3, #8
    34b8:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
            break;
    34bc:	bf00      	nop
        }


        IP_SCG->SOSCCFG &= ~SCG_SOSCCFG_RANGE_MASK;
    34be:	4b30      	ldr	r3, [pc, #192]	; (3580 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    34c0:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    34c4:	4a2e      	ldr	r2, [pc, #184]	; (3580 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    34c6:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    34ca:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108

        if ((Config->Freq >= 4000000U) && (Config->Freq < 8000000U))
    34ce:	9b01      	ldr	r3, [sp, #4]
    34d0:	685b      	ldr	r3, [r3, #4]
    34d2:	4a2c      	ldr	r2, [pc, #176]	; (3584 <Clock_Ip_SetSOSC_TrustedCall+0x104>)
    34d4:	4293      	cmp	r3, r2
    34d6:	d90d      	bls.n	34f4 <Clock_Ip_SetSOSC_TrustedCall+0x74>
    34d8:	9b01      	ldr	r3, [sp, #4]
    34da:	685b      	ldr	r3, [r3, #4]
    34dc:	4a2a      	ldr	r2, [pc, #168]	; (3588 <Clock_Ip_SetSOSC_TrustedCall+0x108>)
    34de:	4293      	cmp	r3, r2
    34e0:	d208      	bcs.n	34f4 <Clock_Ip_SetSOSC_TrustedCall+0x74>
        {
            IP_SCG->SOSCCFG |= SCG_SOSCCFG_RANGE(2U);
    34e2:	4b27      	ldr	r3, [pc, #156]	; (3580 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    34e4:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    34e8:	4a25      	ldr	r2, [pc, #148]	; (3580 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    34ea:	f043 0320 	orr.w	r3, r3, #32
    34ee:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
    34f2:	e007      	b.n	3504 <Clock_Ip_SetSOSC_TrustedCall+0x84>
        }
        else
        {
            IP_SCG->SOSCCFG |= SCG_SOSCCFG_RANGE(3U);
    34f4:	4b22      	ldr	r3, [pc, #136]	; (3580 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    34f6:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    34fa:	4a21      	ldr	r2, [pc, #132]	; (3580 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    34fc:	f043 0330 	orr.w	r3, r3, #48	; 0x30
    3500:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
        }

        if (0U == Config->BypassOption)
    3504:	9b01      	ldr	r3, [sp, #4]
    3506:	7b1b      	ldrb	r3, [r3, #12]
    3508:	2b00      	cmp	r3, #0
    350a:	d108      	bne.n	351e <Clock_Ip_SetSOSC_TrustedCall+0x9e>
        {
            IP_SCG->SOSCCFG |= SCG_SOSCCFG_EREFS_MASK;
    350c:	4b1c      	ldr	r3, [pc, #112]	; (3580 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    350e:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    3512:	4a1b      	ldr	r2, [pc, #108]	; (3580 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    3514:	f043 0304 	orr.w	r3, r3, #4
    3518:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
    351c:	e007      	b.n	352e <Clock_Ip_SetSOSC_TrustedCall+0xae>
        }
        else
        {
            IP_SCG->SOSCCFG &= ~SCG_SOSCCFG_EREFS_MASK;
    351e:	4b18      	ldr	r3, [pc, #96]	; (3580 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    3520:	f8d3 3108 	ldr.w	r3, [r3, #264]	; 0x108
    3524:	4a16      	ldr	r2, [pc, #88]	; (3580 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    3526:	f023 0304 	bic.w	r3, r3, #4
    352a:	f8c2 3108 	str.w	r3, [r2, #264]	; 0x108
        }


        /* Enable clock, configure monitor, lock register. */
        switch (Config->Monitor)
    352e:	9b01      	ldr	r3, [sp, #4]
    3530:	7c1b      	ldrb	r3, [r3, #16]
    3532:	2b02      	cmp	r3, #2
    3534:	d011      	beq.n	355a <Clock_Ip_SetSOSC_TrustedCall+0xda>
    3536:	2b02      	cmp	r3, #2
    3538:	dc14      	bgt.n	3564 <Clock_Ip_SetSOSC_TrustedCall+0xe4>
    353a:	2b00      	cmp	r3, #0
    353c:	d002      	beq.n	3544 <Clock_Ip_SetSOSC_TrustedCall+0xc4>
    353e:	2b01      	cmp	r3, #1
    3540:	d005      	beq.n	354e <Clock_Ip_SetSOSC_TrustedCall+0xce>
    3542:	e00f      	b.n	3564 <Clock_Ip_SetSOSC_TrustedCall+0xe4>
        {
#ifdef CLOCK_IP_HAS_MONITOR_DISABLE
            case CLOCK_IP_HAS_MONITOR_DISABLE:
            {
                IP_SCG->SOSCCSR = SCG_SOSCCSR_SOSCEN(1UL) |
    3544:	4b0e      	ldr	r3, [pc, #56]	; (3580 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    3546:	2201      	movs	r2, #1
    3548:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
                               SCG_SOSCCSR_SOSCCM(0UL) |
                               SCG_SOSCCSR_SOSCCMRE(0UL);
            }
            break;
    354c:	e014      	b.n	3578 <Clock_Ip_SetSOSC_TrustedCall+0xf8>
#endif
#ifdef CLOCK_IP_HAS_MONITOR_INT
            case CLOCK_IP_HAS_MONITOR_INT:
            {
                IP_SCG->SOSCCSR = SCG_SOSCCSR_SOSCEN(1UL) |
    354e:	4b0c      	ldr	r3, [pc, #48]	; (3580 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    3550:	f04f 1201 	mov.w	r2, #65537	; 0x10001
    3554:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
                               SCG_SOSCCSR_SOSCCM(1UL) |
                               SCG_SOSCCSR_SOSCCMRE(0UL);
            }
            break;
    3558:	e00e      	b.n	3578 <Clock_Ip_SetSOSC_TrustedCall+0xf8>
#endif
#ifdef CLOCK_IP_HAS_MONITOR_RESET
            case CLOCK_IP_HAS_MONITOR_RESET:
            {
                IP_SCG->SOSCCSR = SCG_SOSCCSR_SOSCEN(1UL) |
    355a:	4b09      	ldr	r3, [pc, #36]	; (3580 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    355c:	4a0b      	ldr	r2, [pc, #44]	; (358c <Clock_Ip_SetSOSC_TrustedCall+0x10c>)
    355e:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
                               SCG_SOSCCSR_SOSCCM(1UL) |
                               SCG_SOSCCSR_SOSCCMRE(1UL);
            }
            break;
    3562:	e009      	b.n	3578 <Clock_Ip_SetSOSC_TrustedCall+0xf8>
#endif
            default:
                /* Enable SOSC. */
                IP_SCG->SOSCCSR |= SCG_SOSCCSR_SOSCEN_MASK;
    3564:	4b06      	ldr	r3, [pc, #24]	; (3580 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    3566:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    356a:	4a05      	ldr	r2, [pc, #20]	; (3580 <Clock_Ip_SetSOSC_TrustedCall+0x100>)
    356c:	f043 0301 	orr.w	r3, r3, #1
    3570:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100

                /* Invalid monitor mode */
                CLOCK_IP_DEV_ASSERT(FALSE);
                break;
    3574:	e000      	b.n	3578 <Clock_Ip_SetSOSC_TrustedCall+0xf8>
        }
    }
    3576:	bf00      	nop
}
    3578:	bf00      	nop
    357a:	b002      	add	sp, #8
    357c:	4770      	bx	lr
    357e:	bf00      	nop
    3580:	40064000 	.word	0x40064000
    3584:	003d08ff 	.word	0x003d08ff
    3588:	007a1200 	.word	0x007a1200
    358c:	00030001 	.word	0x00030001

00003590 <Clock_Ip_DisableSOSC_TrustedCall>:

void Clock_Ip_DisableSOSC_TrustedCall(Clock_Ip_NameType XoscName)
{
    3590:	b082      	sub	sp, #8
    3592:	9001      	str	r0, [sp, #4]
    (void)XoscName;

    /* Disable SOSC. */
    IP_SCG->SOSCCSR &= ~SCG_SOSCCSR_SOSCEN_MASK;
    3594:	4b05      	ldr	r3, [pc, #20]	; (35ac <Clock_Ip_DisableSOSC_TrustedCall+0x1c>)
    3596:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    359a:	4a04      	ldr	r2, [pc, #16]	; (35ac <Clock_Ip_DisableSOSC_TrustedCall+0x1c>)
    359c:	f023 0301 	bic.w	r3, r3, #1
    35a0:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
}
    35a4:	bf00      	nop
    35a6:	b002      	add	sp, #8
    35a8:	4770      	bx	lr
    35aa:	bf00      	nop
    35ac:	40064000 	.word	0x40064000

000035b0 <Clock_Ip_EnableSOSC_TrustedCall>:

void Clock_Ip_EnableSOSC_TrustedCall(Clock_Ip_XoscConfigType const* Config)
{
    35b0:	b082      	sub	sp, #8
    35b2:	9001      	str	r0, [sp, #4]
    if (1U == Config->Enable)
    35b4:	9b01      	ldr	r3, [sp, #4]
    35b6:	891b      	ldrh	r3, [r3, #8]
    35b8:	2b01      	cmp	r3, #1
    35ba:	d107      	bne.n	35cc <Clock_Ip_EnableSOSC_TrustedCall+0x1c>
    {
        /* Enable SOSC. */
        IP_SCG->SOSCCSR |= SCG_SOSCCSR_SOSCEN_MASK;
    35bc:	4b05      	ldr	r3, [pc, #20]	; (35d4 <Clock_Ip_EnableSOSC_TrustedCall+0x24>)
    35be:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    35c2:	4a04      	ldr	r2, [pc, #16]	; (35d4 <Clock_Ip_EnableSOSC_TrustedCall+0x24>)
    35c4:	f043 0301 	orr.w	r3, r3, #1
    35c8:	f8c2 3100 	str.w	r3, [r2, #256]	; 0x100
    }
}
    35cc:	bf00      	nop
    35ce:	b002      	add	sp, #8
    35d0:	4770      	bx	lr
    35d2:	bf00      	nop
    35d4:	40064000 	.word	0x40064000

000035d8 <Clock_Ip_CallbackFracDivEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_CallbackFracDivEmpty(Clock_Ip_FracDivConfigType const* Config)
{
    35d8:	b082      	sub	sp, #8
    35da:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    35dc:	bf00      	nop
    35de:	b002      	add	sp, #8
    35e0:	4770      	bx	lr

000035e2 <Clock_Ip_CallbackFracDivEmptyComplete>:

static Clock_Ip_DfsStatusType Clock_Ip_CallbackFracDivEmptyComplete(Clock_Ip_NameType DfsName)
{
    35e2:	b082      	sub	sp, #8
    35e4:	9001      	str	r0, [sp, #4]
    (void)DfsName;
    /* No implementation */
    return STATUS_DFS_NOT_ENABLED;
    35e6:	2300      	movs	r3, #0
}
    35e8:	4618      	mov	r0, r3
    35ea:	b002      	add	sp, #8
    35ec:	4770      	bx	lr

000035ee <Clock_Ip_SetExternalSignalFrequency>:
#define MCU_START_SEC_CODE
#include "Mcu_MemMap.h"

/* Set frequency value for External Signal */
void Clock_Ip_SetExternalSignalFrequency(Clock_Ip_NameType SignalName, uint32 Frequency)
{
    35ee:	b082      	sub	sp, #8
    35f0:	9001      	str	r0, [sp, #4]
    35f2:	9100      	str	r1, [sp, #0]
    }
#else
    (void)SignalName;
    (void)Frequency;
#endif
}
    35f4:	bf00      	nop
    35f6:	b002      	add	sp, #8
    35f8:	4770      	bx	lr
	...

000035fc <Clock_Ip_ClockSetGateEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_ClockSetGateEmpty(Clock_Ip_GateConfigType const* Config)
{
    35fc:	b082      	sub	sp, #8
    35fe:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    3600:	bf00      	nop
    3602:	b002      	add	sp, #8
    3604:	4770      	bx	lr

00003606 <Clock_Ip_ClockUpdateGateEmpty>:
static void Clock_Ip_ClockUpdateGateEmpty(Clock_Ip_NameType ClockName, boolean Gate)
{
    3606:	b082      	sub	sp, #8
    3608:	9001      	str	r0, [sp, #4]
    360a:	460b      	mov	r3, r1
    360c:	f88d 3003 	strb.w	r3, [sp, #3]
    (void)ClockName;
    (void)Gate;
    /* No implementation */
}
    3610:	bf00      	nop
    3612:	b002      	add	sp, #8
    3614:	4770      	bx	lr

00003616 <Clock_Ip_ClockSetSimLPO1KEnable>:

#ifdef CLOCK_IP_SIM_LPO1K_ENABLE
static void Clock_Ip_ClockSetSimLPO1KEnable(Clock_Ip_GateConfigType const* Config)
{
    3616:	b500      	push	{lr}
    3618:	b083      	sub	sp, #12
    361a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    361c:	9b01      	ldr	r3, [sp, #4]
    361e:	2b00      	cmp	r3, #0
    3620:	d002      	beq.n	3628 <Clock_Ip_ClockSetSimLPO1KEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall(Config);
    3622:	9801      	ldr	r0, [sp, #4]
    3624:	f000 f8e7 	bl	37f6 <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3628:	bf00      	nop
    362a:	b003      	add	sp, #12
    362c:	f85d fb04 	ldr.w	pc, [sp], #4

00003630 <Clock_Ip_ClockUpdateSimLPO1KEnable>:

static void Clock_Ip_ClockUpdateSimLPO1KEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    3630:	b500      	push	{lr}
    3632:	b085      	sub	sp, #20
    3634:	9001      	str	r0, [sp, #4]
    3636:	460b      	mov	r3, r1
    3638:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    363c:	9b01      	ldr	r3, [sp, #4]
    363e:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    3640:	f89d 3003 	ldrb.w	r3, [sp, #3]
    3644:	2b00      	cmp	r3, #0
    3646:	d003      	beq.n	3650 <Clock_Ip_ClockUpdateSimLPO1KEnable+0x20>
    {
        Config.Enable = 0U;
    3648:	2300      	movs	r3, #0
    364a:	f8ad 300c 	strh.w	r3, [sp, #12]
    364e:	e002      	b.n	3656 <Clock_Ip_ClockUpdateSimLPO1KEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    3650:	2301      	movs	r3, #1
    3652:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimLPO1KEnable(&Config);
    3656:	ab02      	add	r3, sp, #8
    3658:	4618      	mov	r0, r3
    365a:	f7ff ffdc 	bl	3616 <Clock_Ip_ClockSetSimLPO1KEnable>
}
    365e:	bf00      	nop
    3660:	b005      	add	sp, #20
    3662:	f85d fb04 	ldr.w	pc, [sp], #4

00003666 <Clock_Ip_ClockSetSimLPO32KEnable>:
#endif

#ifdef CLOCK_IP_SIM_LPO32K_ENABLE
static void Clock_Ip_ClockSetSimLPO32KEnable(Clock_Ip_GateConfigType const* Config)
{
    3666:	b500      	push	{lr}
    3668:	b083      	sub	sp, #12
    366a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    366c:	9b01      	ldr	r3, [sp, #4]
    366e:	2b00      	cmp	r3, #0
    3670:	d002      	beq.n	3678 <Clock_Ip_ClockSetSimLPO32KEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall(Config);
    3672:	9801      	ldr	r0, [sp, #4]
    3674:	f000 f8d6 	bl	3824 <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3678:	bf00      	nop
    367a:	b003      	add	sp, #12
    367c:	f85d fb04 	ldr.w	pc, [sp], #4

00003680 <Clock_Ip_ClockUpdateSimLPO32KEnable>:
static void Clock_Ip_ClockUpdateSimLPO32KEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    3680:	b500      	push	{lr}
    3682:	b085      	sub	sp, #20
    3684:	9001      	str	r0, [sp, #4]
    3686:	460b      	mov	r3, r1
    3688:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    368c:	9b01      	ldr	r3, [sp, #4]
    368e:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    3690:	f89d 3003 	ldrb.w	r3, [sp, #3]
    3694:	2b00      	cmp	r3, #0
    3696:	d003      	beq.n	36a0 <Clock_Ip_ClockUpdateSimLPO32KEnable+0x20>
    {
        Config.Enable = 0U;
    3698:	2300      	movs	r3, #0
    369a:	f8ad 300c 	strh.w	r3, [sp, #12]
    369e:	e002      	b.n	36a6 <Clock_Ip_ClockUpdateSimLPO32KEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    36a0:	2301      	movs	r3, #1
    36a2:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimLPO32KEnable(&Config);
    36a6:	ab02      	add	r3, sp, #8
    36a8:	4618      	mov	r0, r3
    36aa:	f7ff ffdc 	bl	3666 <Clock_Ip_ClockSetSimLPO32KEnable>
}
    36ae:	bf00      	nop
    36b0:	b005      	add	sp, #20
    36b2:	f85d fb04 	ldr.w	pc, [sp], #4

000036b6 <Clock_Ip_ClockSetSimClkoutEnable>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_ENABLE
static void Clock_Ip_ClockSetSimClkoutEnable(Clock_Ip_GateConfigType const* Config)
{
    36b6:	b500      	push	{lr}
    36b8:	b083      	sub	sp, #12
    36ba:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    36bc:	9b01      	ldr	r3, [sp, #4]
    36be:	2b00      	cmp	r3, #0
    36c0:	d002      	beq.n	36c8 <Clock_Ip_ClockSetSimClkoutEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimClkoutEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimClkoutEnable_TrustedCall(Config);
    36c2:	9801      	ldr	r0, [sp, #4]
    36c4:	f000 f8c6 	bl	3854 <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    36c8:	bf00      	nop
    36ca:	b003      	add	sp, #12
    36cc:	f85d fb04 	ldr.w	pc, [sp], #4

000036d0 <Clock_Ip_ClockUpdateSimClkoutEnable>:
static void Clock_Ip_ClockUpdateSimClkoutEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    36d0:	b500      	push	{lr}
    36d2:	b085      	sub	sp, #20
    36d4:	9001      	str	r0, [sp, #4]
    36d6:	460b      	mov	r3, r1
    36d8:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    36dc:	9b01      	ldr	r3, [sp, #4]
    36de:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    36e0:	f89d 3003 	ldrb.w	r3, [sp, #3]
    36e4:	2b00      	cmp	r3, #0
    36e6:	d003      	beq.n	36f0 <Clock_Ip_ClockUpdateSimClkoutEnable+0x20>
    {
        Config.Enable = 0U;
    36e8:	2300      	movs	r3, #0
    36ea:	f8ad 300c 	strh.w	r3, [sp, #12]
    36ee:	e002      	b.n	36f6 <Clock_Ip_ClockUpdateSimClkoutEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    36f0:	2301      	movs	r3, #1
    36f2:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimClkoutEnable(&Config);
    36f6:	ab02      	add	r3, sp, #8
    36f8:	4618      	mov	r0, r3
    36fa:	f7ff ffdc 	bl	36b6 <Clock_Ip_ClockSetSimClkoutEnable>
}
    36fe:	bf00      	nop
    3700:	b005      	add	sp, #20
    3702:	f85d fb04 	ldr.w	pc, [sp], #4

00003706 <Clock_Ip_ClockSetPccCgcEnable>:
#endif

#ifdef CLOCK_IP_PCC_CGC_ENABLE
static void Clock_Ip_ClockSetPccCgcEnable(Clock_Ip_GateConfigType const* Config)
{
    3706:	b500      	push	{lr}
    3708:	b083      	sub	sp, #12
    370a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    370c:	9b01      	ldr	r3, [sp, #4]
    370e:	2b00      	cmp	r3, #0
    3710:	d002      	beq.n	3718 <Clock_Ip_ClockSetPccCgcEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetPccCgcEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetPccCgcEnable_TrustedCall(Config);
    3712:	9801      	ldr	r0, [sp, #4]
    3714:	f000 f8b6 	bl	3884 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3718:	bf00      	nop
    371a:	b003      	add	sp, #12
    371c:	f85d fb04 	ldr.w	pc, [sp], #4

00003720 <Clock_Ip_ClockUpdatePccCgcEnable>:
static void Clock_Ip_ClockUpdatePccCgcEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    3720:	b500      	push	{lr}
    3722:	b085      	sub	sp, #20
    3724:	9001      	str	r0, [sp, #4]
    3726:	460b      	mov	r3, r1
    3728:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    372c:	9b01      	ldr	r3, [sp, #4]
    372e:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    3730:	f89d 3003 	ldrb.w	r3, [sp, #3]
    3734:	2b00      	cmp	r3, #0
    3736:	d003      	beq.n	3740 <Clock_Ip_ClockUpdatePccCgcEnable+0x20>
    {
        Config.Enable = 0U;
    3738:	2300      	movs	r3, #0
    373a:	f8ad 300c 	strh.w	r3, [sp, #12]
    373e:	e002      	b.n	3746 <Clock_Ip_ClockUpdatePccCgcEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    3740:	2301      	movs	r3, #1
    3742:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetPccCgcEnable(&Config);
    3746:	ab02      	add	r3, sp, #8
    3748:	4618      	mov	r0, r3
    374a:	f7ff ffdc 	bl	3706 <Clock_Ip_ClockSetPccCgcEnable>
}
    374e:	bf00      	nop
    3750:	b005      	add	sp, #20
    3752:	f85d fb04 	ldr.w	pc, [sp], #4

00003756 <Clock_Ip_ClockSetSimGate>:

#ifdef CLOCK_IP_SIM_PLATCGC_CGC
#define SIM_PLATCGC_CGC_SHIFT(x)   (x)
#define SIM_PLATCGC_CGC_MASK(x)  ((uint32)1U << (x))
static void Clock_Ip_ClockSetSimGate(Clock_Ip_GateConfigType const* Config)
{
    3756:	b500      	push	{lr}
    3758:	b083      	sub	sp, #12
    375a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    375c:	9b01      	ldr	r3, [sp, #4]
    375e:	2b00      	cmp	r3, #0
    3760:	d002      	beq.n	3768 <Clock_Ip_ClockSetSimGate+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimGate_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimGate_TrustedCall(Config);
    3762:	9801      	ldr	r0, [sp, #4]
    3764:	f000 f8bc 	bl	38e0 <Clock_Ip_ClockSetSimGate_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3768:	bf00      	nop
    376a:	b003      	add	sp, #12
    376c:	f85d fb04 	ldr.w	pc, [sp], #4

00003770 <Clock_Ip_ClockUpdateSimGate>:
static void Clock_Ip_ClockUpdateSimGate(Clock_Ip_NameType ClockName, boolean Gate)
{
    3770:	b500      	push	{lr}
    3772:	b085      	sub	sp, #20
    3774:	9001      	str	r0, [sp, #4]
    3776:	460b      	mov	r3, r1
    3778:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    377c:	9b01      	ldr	r3, [sp, #4]
    377e:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    3780:	f89d 3003 	ldrb.w	r3, [sp, #3]
    3784:	2b00      	cmp	r3, #0
    3786:	d003      	beq.n	3790 <Clock_Ip_ClockUpdateSimGate+0x20>
    {
        Config.Enable = 0U;
    3788:	2300      	movs	r3, #0
    378a:	f8ad 300c 	strh.w	r3, [sp, #12]
    378e:	e002      	b.n	3796 <Clock_Ip_ClockUpdateSimGate+0x26>
    }
    else
    {
        Config.Enable = 1U;
    3790:	2301      	movs	r3, #1
    3792:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimGate(&Config);
    3796:	ab02      	add	r3, sp, #8
    3798:	4618      	mov	r0, r3
    379a:	f7ff ffdc 	bl	3756 <Clock_Ip_ClockSetSimGate>
}
    379e:	bf00      	nop
    37a0:	b005      	add	sp, #20
    37a2:	f85d fb04 	ldr.w	pc, [sp], #4

000037a6 <Clock_Ip_ClockSetSimTraceEnable>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_ENABLE
static void Clock_Ip_ClockSetSimTraceEnable(Clock_Ip_GateConfigType const* Config)
{
    37a6:	b500      	push	{lr}
    37a8:	b083      	sub	sp, #12
    37aa:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    37ac:	9b01      	ldr	r3, [sp, #4]
    37ae:	2b00      	cmp	r3, #0
    37b0:	d002      	beq.n	37b8 <Clock_Ip_ClockSetSimTraceEnable+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ClockSetSimTraceEnable_TrustedCall,(Config));
      #else
        Clock_Ip_ClockSetSimTraceEnable_TrustedCall(Config);
    37b2:	9801      	ldr	r0, [sp, #4]
    37b4:	f000 f8c0 	bl	3938 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    37b8:	bf00      	nop
    37ba:	b003      	add	sp, #12
    37bc:	f85d fb04 	ldr.w	pc, [sp], #4

000037c0 <Clock_Ip_ClockUpdateSimTraceEnable>:

static void Clock_Ip_ClockUpdateSimTraceEnable(Clock_Ip_NameType ClockName, boolean Gate)
{
    37c0:	b500      	push	{lr}
    37c2:	b085      	sub	sp, #20
    37c4:	9001      	str	r0, [sp, #4]
    37c6:	460b      	mov	r3, r1
    37c8:	f88d 3003 	strb.w	r3, [sp, #3]
    Clock_Ip_GateConfigType Config;

    Config.Name = ClockName;
    37cc:	9b01      	ldr	r3, [sp, #4]
    37ce:	9302      	str	r3, [sp, #8]
    if (TRUE == Gate)
    37d0:	f89d 3003 	ldrb.w	r3, [sp, #3]
    37d4:	2b00      	cmp	r3, #0
    37d6:	d003      	beq.n	37e0 <Clock_Ip_ClockUpdateSimTraceEnable+0x20>
    {
        Config.Enable = 0U;
    37d8:	2300      	movs	r3, #0
    37da:	f8ad 300c 	strh.w	r3, [sp, #12]
    37de:	e002      	b.n	37e6 <Clock_Ip_ClockUpdateSimTraceEnable+0x26>
    }
    else
    {
        Config.Enable = 1U;
    37e0:	2301      	movs	r3, #1
    37e2:	f8ad 300c 	strh.w	r3, [sp, #12]
    }
    /* Write configuration to register */
    Clock_Ip_ClockSetSimTraceEnable(&Config);
    37e6:	ab02      	add	r3, sp, #8
    37e8:	4618      	mov	r0, r3
    37ea:	f7ff ffdc 	bl	37a6 <Clock_Ip_ClockSetSimTraceEnable>
}
    37ee:	bf00      	nop
    37f0:	b005      	add	sp, #20
    37f2:	f85d fb04 	ldr.w	pc, [sp], #4

000037f6 <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall>:
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SIM_LPO1K_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    37f6:	b084      	sub	sp, #16
    37f8:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->LPOCLKS;
    37fa:	4b09      	ldr	r3, [pc, #36]	; (3820 <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall+0x2a>)
    37fc:	691b      	ldr	r3, [r3, #16]
    37fe:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_LPOCLKS_LPO1KCLKEN_MASK;
    3800:	9b03      	ldr	r3, [sp, #12]
    3802:	f023 0301 	bic.w	r3, r3, #1
    3806:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << SIM_LPOCLKS_LPO1KCLKEN_SHIFT);
    3808:	9b01      	ldr	r3, [sp, #4]
    380a:	889b      	ldrh	r3, [r3, #4]
    380c:	461a      	mov	r2, r3
    380e:	9b03      	ldr	r3, [sp, #12]
    3810:	4313      	orrs	r3, r2
    3812:	9303      	str	r3, [sp, #12]
    IP_SIM->LPOCLKS = RegValue;
    3814:	4a02      	ldr	r2, [pc, #8]	; (3820 <Clock_Ip_ClockSetSimLPO1KEnable_TrustedCall+0x2a>)
    3816:	9b03      	ldr	r3, [sp, #12]
    3818:	6113      	str	r3, [r2, #16]
}
    381a:	bf00      	nop
    381c:	b004      	add	sp, #16
    381e:	4770      	bx	lr
    3820:	40048000 	.word	0x40048000

00003824 <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_LPO32K_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    3824:	b084      	sub	sp, #16
    3826:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->LPOCLKS;
    3828:	4b09      	ldr	r3, [pc, #36]	; (3850 <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall+0x2c>)
    382a:	691b      	ldr	r3, [r3, #16]
    382c:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_LPOCLKS_LPO32KCLKEN_MASK;
    382e:	9b03      	ldr	r3, [sp, #12]
    3830:	f023 0302 	bic.w	r3, r3, #2
    3834:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << SIM_LPOCLKS_LPO32KCLKEN_SHIFT);
    3836:	9b01      	ldr	r3, [sp, #4]
    3838:	889b      	ldrh	r3, [r3, #4]
    383a:	005b      	lsls	r3, r3, #1
    383c:	9a03      	ldr	r2, [sp, #12]
    383e:	4313      	orrs	r3, r2
    3840:	9303      	str	r3, [sp, #12]
    IP_SIM->LPOCLKS = RegValue;
    3842:	4a03      	ldr	r2, [pc, #12]	; (3850 <Clock_Ip_ClockSetSimLPO32KEnable_TrustedCall+0x2c>)
    3844:	9b03      	ldr	r3, [sp, #12]
    3846:	6113      	str	r3, [r2, #16]
}
    3848:	bf00      	nop
    384a:	b004      	add	sp, #16
    384c:	4770      	bx	lr
    384e:	bf00      	nop
    3850:	40048000 	.word	0x40048000

00003854 <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimClkoutEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    3854:	b084      	sub	sp, #16
    3856:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->CHIPCTL;
    3858:	4b09      	ldr	r3, [pc, #36]	; (3880 <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall+0x2c>)
    385a:	685b      	ldr	r3, [r3, #4]
    385c:	9303      	str	r3, [sp, #12]
    RegValue &= ~SIM_CHIPCTL_CLKOUTEN_MASK;
    385e:	9b03      	ldr	r3, [sp, #12]
    3860:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    3864:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << SIM_CHIPCTL_CLKOUTEN_SHIFT);
    3866:	9b01      	ldr	r3, [sp, #4]
    3868:	889b      	ldrh	r3, [r3, #4]
    386a:	02db      	lsls	r3, r3, #11
    386c:	9a03      	ldr	r2, [sp, #12]
    386e:	4313      	orrs	r3, r2
    3870:	9303      	str	r3, [sp, #12]
    IP_SIM->CHIPCTL = RegValue;
    3872:	4a03      	ldr	r2, [pc, #12]	; (3880 <Clock_Ip_ClockSetSimClkoutEnable_TrustedCall+0x2c>)
    3874:	9b03      	ldr	r3, [sp, #12]
    3876:	6053      	str	r3, [r2, #4]
}
    3878:	bf00      	nop
    387a:	b004      	add	sp, #16
    387c:	4770      	bx	lr
    387e:	bf00      	nop
    3880:	40048000 	.word	0x40048000

00003884 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_PCC_CGC_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetPccCgcEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    3884:	b084      	sub	sp, #16
    3886:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_GATE_INDEX]];
    3888:	4913      	ldr	r1, [pc, #76]	; (38d8 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x54>)
    388a:	9b01      	ldr	r3, [sp, #4]
    388c:	681a      	ldr	r2, [r3, #0]
    388e:	4813      	ldr	r0, [pc, #76]	; (38dc <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x58>)
    3890:	4613      	mov	r3, r2
    3892:	00db      	lsls	r3, r3, #3
    3894:	4413      	add	r3, r2
    3896:	4403      	add	r3, r0
    3898:	3306      	adds	r3, #6
    389a:	781b      	ldrb	r3, [r3, #0]
    389c:	f851 3023 	ldr.w	r3, [r1, r3, lsl #2]
    38a0:	9303      	str	r3, [sp, #12]
    RegValue &= ~PCC_PCCn_CGC_MASK;
    38a2:	9b03      	ldr	r3, [sp, #12]
    38a4:	f023 4380 	bic.w	r3, r3, #1073741824	; 0x40000000
    38a8:	9303      	str	r3, [sp, #12]
    RegValue |= ((uint32)(Config->Enable) << PCC_PCCn_CGC_SHIFT);
    38aa:	9b01      	ldr	r3, [sp, #4]
    38ac:	889b      	ldrh	r3, [r3, #4]
    38ae:	079b      	lsls	r3, r3, #30
    38b0:	9a03      	ldr	r2, [sp, #12]
    38b2:	4313      	orrs	r3, r2
    38b4:	9303      	str	r3, [sp, #12]
    IP_PCC->PCCn[Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_GATE_INDEX]] = RegValue;
    38b6:	4908      	ldr	r1, [pc, #32]	; (38d8 <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x54>)
    38b8:	9b01      	ldr	r3, [sp, #4]
    38ba:	681a      	ldr	r2, [r3, #0]
    38bc:	4807      	ldr	r0, [pc, #28]	; (38dc <Clock_Ip_ClockSetPccCgcEnable_TrustedCall+0x58>)
    38be:	4613      	mov	r3, r2
    38c0:	00db      	lsls	r3, r3, #3
    38c2:	4413      	add	r3, r2
    38c4:	4403      	add	r3, r0
    38c6:	3306      	adds	r3, #6
    38c8:	781b      	ldrb	r3, [r3, #0]
    38ca:	461a      	mov	r2, r3
    38cc:	9b03      	ldr	r3, [sp, #12]
    38ce:	f841 3022 	str.w	r3, [r1, r2, lsl #2]

}
    38d2:	bf00      	nop
    38d4:	b004      	add	sp, #16
    38d6:	4770      	bx	lr
    38d8:	40065000 	.word	0x40065000
    38dc:	000154d0 	.word	0x000154d0

000038e0 <Clock_Ip_ClockSetSimGate_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_PLATCGC_CGC
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimGate_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    38e0:	b086      	sub	sp, #24
    38e2:	9001      	str	r0, [sp, #4]
    uint32 Enable = Config->Enable;
    38e4:	9b01      	ldr	r3, [sp, #4]
    38e6:	889b      	ldrh	r3, [r3, #4]
    38e8:	9305      	str	r3, [sp, #20]
    uint32 GateIndex = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_GATE_INDEX];
    38ea:	9b01      	ldr	r3, [sp, #4]
    38ec:	681a      	ldr	r2, [r3, #0]
    38ee:	4910      	ldr	r1, [pc, #64]	; (3930 <Clock_Ip_ClockSetSimGate_TrustedCall+0x50>)
    38f0:	4613      	mov	r3, r2
    38f2:	00db      	lsls	r3, r3, #3
    38f4:	4413      	add	r3, r2
    38f6:	440b      	add	r3, r1
    38f8:	3306      	adds	r3, #6
    38fa:	781b      	ldrb	r3, [r3, #0]
    38fc:	9304      	str	r3, [sp, #16]

    uint32 RegValue = (uint32 )IP_SIM->PLATCGC;
    38fe:	4b0d      	ldr	r3, [pc, #52]	; (3934 <Clock_Ip_ClockSetSimGate_TrustedCall+0x54>)
    3900:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    3902:	9303      	str	r3, [sp, #12]
    RegValue &= (~((uint32 )SIM_PLATCGC_CGC_MASK(GateIndex)));
    3904:	2201      	movs	r2, #1
    3906:	9b04      	ldr	r3, [sp, #16]
    3908:	fa02 f303 	lsl.w	r3, r2, r3
    390c:	43db      	mvns	r3, r3
    390e:	9a03      	ldr	r2, [sp, #12]
    3910:	4013      	ands	r3, r2
    3912:	9303      	str	r3, [sp, #12]
    RegValue |= Enable << SIM_PLATCGC_CGC_SHIFT(GateIndex);
    3914:	9a05      	ldr	r2, [sp, #20]
    3916:	9b04      	ldr	r3, [sp, #16]
    3918:	fa02 f303 	lsl.w	r3, r2, r3
    391c:	9a03      	ldr	r2, [sp, #12]
    391e:	4313      	orrs	r3, r2
    3920:	9303      	str	r3, [sp, #12]
    IP_SIM->PLATCGC = (uint32 )RegValue;
    3922:	4a04      	ldr	r2, [pc, #16]	; (3934 <Clock_Ip_ClockSetSimGate_TrustedCall+0x54>)
    3924:	9b03      	ldr	r3, [sp, #12]
    3926:	6413      	str	r3, [r2, #64]	; 0x40
}
    3928:	bf00      	nop
    392a:	b006      	add	sp, #24
    392c:	4770      	bx	lr
    392e:	bf00      	nop
    3930:	000154d0 	.word	0x000154d0
    3934:	40048000 	.word	0x40048000

00003938 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_ENABLE
/* Write configuration of clock gate to register */
void Clock_Ip_ClockSetSimTraceEnable_TrustedCall(Clock_Ip_GateConfigType const* Config)
{
    3938:	b084      	sub	sp, #16
    393a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    RegValue = IP_SIM->CLKDIV4;
    393c:	4b0a      	ldr	r3, [pc, #40]	; (3968 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x30>)
    393e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
    3940:	9303      	str	r3, [sp, #12]
    if (1U == Config->Enable)
    3942:	9b01      	ldr	r3, [sp, #4]
    3944:	889b      	ldrh	r3, [r3, #4]
    3946:	2b01      	cmp	r3, #1
    3948:	d104      	bne.n	3954 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x1c>
    {
        RegValue |= (SIM_CLKDIV4_TRACEDIVEN_MASK);
    394a:	9b03      	ldr	r3, [sp, #12]
    394c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
    3950:	9303      	str	r3, [sp, #12]
    3952:	e003      	b.n	395c <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x24>
    }
    else
    {
        RegValue &= ~(SIM_CLKDIV4_TRACEDIVEN_MASK);
    3954:	9b03      	ldr	r3, [sp, #12]
    3956:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
    395a:	9303      	str	r3, [sp, #12]
    }
    IP_SIM->CLKDIV4 = RegValue;
    395c:	4a02      	ldr	r2, [pc, #8]	; (3968 <Clock_Ip_ClockSetSimTraceEnable_TrustedCall+0x30>)
    395e:	9b03      	ldr	r3, [sp, #12]
    3960:	6693      	str	r3, [r2, #104]	; 0x68
}
    3962:	bf00      	nop
    3964:	b004      	add	sp, #16
    3966:	4770      	bx	lr
    3968:	40048000 	.word	0x40048000

0000396c <Clock_Ip_InternalOscillatorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_InternalOscillatorEmpty(Clock_Ip_IrcoscConfigType const* Config)
{
    396c:	b082      	sub	sp, #8
    396e:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    3970:	bf00      	nop
    3972:	b002      	add	sp, #8
    3974:	4770      	bx	lr

00003976 <Clock_Ip_InternalOscillatorEmpty_Disable>:
static void Clock_Ip_InternalOscillatorEmpty_Disable(Clock_Ip_NameType Name)
{
    3976:	b082      	sub	sp, #8
    3978:	9001      	str	r0, [sp, #4]
    (void)Name;
    /* No implementation */
}
    397a:	bf00      	nop
    397c:	b002      	add	sp, #8
    397e:	4770      	bx	lr

00003980 <Clock_Ip_SetSirc>:
}
#endif

#ifdef CLOCK_IP_SIRC_ENABLE
static void Clock_Ip_SetSirc(Clock_Ip_IrcoscConfigType const* Config)
{
    3980:	b500      	push	{lr}
    3982:	b083      	sub	sp, #12
    3984:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3986:	9b01      	ldr	r3, [sp, #4]
    3988:	2b00      	cmp	r3, #0
    398a:	d002      	beq.n	3992 <Clock_Ip_SetSirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSirc_TrustedCall,(Config));
      #else
        Clock_Ip_SetSirc_TrustedCall(Config);
    398c:	9801      	ldr	r0, [sp, #4]
    398e:	f000 f8d1 	bl	3b34 <Clock_Ip_SetSirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3992:	bf00      	nop
    3994:	b003      	add	sp, #12
    3996:	f85d fb04 	ldr.w	pc, [sp], #4

0000399a <Clock_Ip_EnableSirc>:
static void Clock_Ip_EnableSirc(Clock_Ip_IrcoscConfigType const* Config)
{
    399a:	b500      	push	{lr}
    399c:	b083      	sub	sp, #12
    399e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    39a0:	9b01      	ldr	r3, [sp, #4]
    39a2:	2b00      	cmp	r3, #0
    39a4:	d002      	beq.n	39ac <Clock_Ip_EnableSirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSirc_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSirc_TrustedCall(Config);
    39a6:	9801      	ldr	r0, [sp, #4]
    39a8:	f000 f950 	bl	3c4c <Clock_Ip_EnableSirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    39ac:	bf00      	nop
    39ae:	b003      	add	sp, #12
    39b0:	f85d fb04 	ldr.w	pc, [sp], #4

000039b4 <Clock_Ip_DisableSirc>:
static void Clock_Ip_DisableSirc(Clock_Ip_NameType Name)
{
    39b4:	b500      	push	{lr}
    39b6:	b083      	sub	sp, #12
    39b8:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSirc_TrustedCall,(Name));
  #else
    Clock_Ip_DisableSirc_TrustedCall(Name);
    39ba:	9801      	ldr	r0, [sp, #4]
    39bc:	f000 f98e 	bl	3cdc <Clock_Ip_DisableSirc_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    39c0:	bf00      	nop
    39c2:	b003      	add	sp, #12
    39c4:	f85d fb04 	ldr.w	pc, [sp], #4

000039c8 <Clock_Ip_SetSircVlp>:
#endif

#ifdef CLOCK_IP_SIRC_VLP_ENABLE
static void Clock_Ip_SetSircVlp(Clock_Ip_IrcoscConfigType const* Config)
{
    39c8:	b500      	push	{lr}
    39ca:	b083      	sub	sp, #12
    39cc:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    39ce:	9b01      	ldr	r3, [sp, #4]
    39d0:	2b00      	cmp	r3, #0
    39d2:	d002      	beq.n	39da <Clock_Ip_SetSircVlp+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSircVlp_TrustedCall,(Config));
      #else
        Clock_Ip_SetSircVlp_TrustedCall(Config);
    39d4:	9801      	ldr	r0, [sp, #4]
    39d6:	f000 f999 	bl	3d0c <Clock_Ip_SetSircVlp_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    39da:	bf00      	nop
    39dc:	b003      	add	sp, #12
    39de:	f85d fb04 	ldr.w	pc, [sp], #4

000039e2 <Clock_Ip_EnableSircVlp>:
static void Clock_Ip_EnableSircVlp(Clock_Ip_IrcoscConfigType const* Config)
{
    39e2:	b500      	push	{lr}
    39e4:	b083      	sub	sp, #12
    39e6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    39e8:	9b01      	ldr	r3, [sp, #4]
    39ea:	2b00      	cmp	r3, #0
    39ec:	d002      	beq.n	39f4 <Clock_Ip_EnableSircVlp+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSircVlp_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSircVlp_TrustedCall(Config);
    39ee:	9801      	ldr	r0, [sp, #4]
    39f0:	f000 f9b0 	bl	3d54 <Clock_Ip_EnableSircVlp_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    39f4:	bf00      	nop
    39f6:	b003      	add	sp, #12
    39f8:	f85d fb04 	ldr.w	pc, [sp], #4

000039fc <Clock_Ip_DisableSircVlp>:
static void Clock_Ip_DisableSircVlp(Clock_Ip_NameType Name)
{
    39fc:	b500      	push	{lr}
    39fe:	b083      	sub	sp, #12
    3a00:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSircVlp_TrustedCall,(Name));
  #else
    Clock_Ip_DisableSircVlp_TrustedCall(Name);
    3a02:	9801      	ldr	r0, [sp, #4]
    3a04:	f000 f9ba 	bl	3d7c <Clock_Ip_DisableSircVlp_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    3a08:	bf00      	nop
    3a0a:	b003      	add	sp, #12
    3a0c:	f85d fb04 	ldr.w	pc, [sp], #4

00003a10 <Clock_Ip_SetSircStop>:
#endif

#ifdef CLOCK_IP_SIRC_STOP_ENABLE
static void Clock_Ip_SetSircStop(Clock_Ip_IrcoscConfigType const* Config)
{
    3a10:	b500      	push	{lr}
    3a12:	b083      	sub	sp, #12
    3a14:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3a16:	9b01      	ldr	r3, [sp, #4]
    3a18:	2b00      	cmp	r3, #0
    3a1a:	d002      	beq.n	3a22 <Clock_Ip_SetSircStop+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSircStop_TrustedCall,(Config));
      #else
        Clock_Ip_SetSircStop_TrustedCall(Config);
    3a1c:	9801      	ldr	r0, [sp, #4]
    3a1e:	f000 f9bd 	bl	3d9c <Clock_Ip_SetSircStop_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3a22:	bf00      	nop
    3a24:	b003      	add	sp, #12
    3a26:	f85d fb04 	ldr.w	pc, [sp], #4

00003a2a <Clock_Ip_EnableSircStop>:
static void Clock_Ip_EnableSircStop(Clock_Ip_IrcoscConfigType const* Config)
{
    3a2a:	b500      	push	{lr}
    3a2c:	b083      	sub	sp, #12
    3a2e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3a30:	9b01      	ldr	r3, [sp, #4]
    3a32:	2b00      	cmp	r3, #0
    3a34:	d002      	beq.n	3a3c <Clock_Ip_EnableSircStop+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSircStop_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSircStop_TrustedCall(Config);
    3a36:	9801      	ldr	r0, [sp, #4]
    3a38:	f000 f9d4 	bl	3de4 <Clock_Ip_EnableSircStop_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3a3c:	bf00      	nop
    3a3e:	b003      	add	sp, #12
    3a40:	f85d fb04 	ldr.w	pc, [sp], #4

00003a44 <Clock_Ip_DisableSircStop>:
static void Clock_Ip_DisableSircStop(Clock_Ip_NameType Name)
{
    3a44:	b500      	push	{lr}
    3a46:	b083      	sub	sp, #12
    3a48:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSircStop_TrustedCall,(Name));
  #else
    Clock_Ip_DisableSircStop_TrustedCall(Name);
    3a4a:	9801      	ldr	r0, [sp, #4]
    3a4c:	f000 f9de 	bl	3e0c <Clock_Ip_DisableSircStop_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    3a50:	bf00      	nop
    3a52:	b003      	add	sp, #12
    3a54:	f85d fb04 	ldr.w	pc, [sp], #4

00003a58 <SetInputSouceSytemClock>:

#ifdef CLOCK_IP_FIRC_ENABLE
#define CLOCK_IP_SIRC_CLK_SOURCE 2U
#define CLOCK_IP_FIRC_CLK_SOURCE 3U
static void SetInputSouceSytemClock(uint32 SourceClock)
{
    3a58:	b500      	push	{lr}
    3a5a:	b089      	sub	sp, #36	; 0x24
    3a5c:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    boolean TimeoutOccurred = FALSE;
    3a5e:	2300      	movs	r3, #0
    3a60:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 ScsStatus;

    RegValue = IP_SCG->RCCR;
    3a64:	4b20      	ldr	r3, [pc, #128]	; (3ae8 <SetInputSouceSytemClock+0x90>)
    3a66:	695b      	ldr	r3, [r3, #20]
    3a68:	9306      	str	r3, [sp, #24]
    RegValue &= ~SCG_RCCR_SCS_MASK;
    3a6a:	9b06      	ldr	r3, [sp, #24]
    3a6c:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    3a70:	9306      	str	r3, [sp, #24]
    RegValue |= (SourceClock << SCG_RCCR_SCS_SHIFT);
    3a72:	9b01      	ldr	r3, [sp, #4]
    3a74:	061b      	lsls	r3, r3, #24
    3a76:	9a06      	ldr	r2, [sp, #24]
    3a78:	4313      	orrs	r3, r2
    3a7a:	9306      	str	r3, [sp, #24]
    IP_SCG->RCCR = RegValue;
    3a7c:	4a1a      	ldr	r2, [pc, #104]	; (3ae8 <SetInputSouceSytemClock+0x90>)
    3a7e:	9b06      	ldr	r3, [sp, #24]
    3a80:	6153      	str	r3, [r2, #20]

    Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    3a82:	aa02      	add	r2, sp, #8
    3a84:	a903      	add	r1, sp, #12
    3a86:	a804      	add	r0, sp, #16
    3a88:	f24c 3350 	movw	r3, #50000	; 0xc350
    3a8c:	f7ff f9ac 	bl	2de8 <Clock_Ip_StartTimeout>
    do
    {
        ScsStatus = (((IP_SCG->CSR & SCG_CSR_SCS_MASK) >> SCG_CSR_SCS_SHIFT) != (SourceClock))?0U:1U;
    3a90:	4b15      	ldr	r3, [pc, #84]	; (3ae8 <SetInputSouceSytemClock+0x90>)
    3a92:	691b      	ldr	r3, [r3, #16]
    3a94:	0e1b      	lsrs	r3, r3, #24
    3a96:	f003 030f 	and.w	r3, r3, #15
    3a9a:	9a01      	ldr	r2, [sp, #4]
    3a9c:	429a      	cmp	r2, r3
    3a9e:	bf0c      	ite	eq
    3aa0:	2301      	moveq	r3, #1
    3aa2:	2300      	movne	r3, #0
    3aa4:	b2db      	uxtb	r3, r3
    3aa6:	9305      	str	r3, [sp, #20]
        TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    3aa8:	9a02      	ldr	r2, [sp, #8]
    3aaa:	a903      	add	r1, sp, #12
    3aac:	ab04      	add	r3, sp, #16
    3aae:	4618      	mov	r0, r3
    3ab0:	f7ff f9b4 	bl	2e1c <Clock_Ip_TimeoutExpired>
    3ab4:	4603      	mov	r3, r0
    3ab6:	f88d 301f 	strb.w	r3, [sp, #31]
    }
    while ((0U == ScsStatus) && (FALSE == TimeoutOccurred));
    3aba:	9b05      	ldr	r3, [sp, #20]
    3abc:	2b00      	cmp	r3, #0
    3abe:	d106      	bne.n	3ace <SetInputSouceSytemClock+0x76>
    3ac0:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3ac4:	f083 0301 	eor.w	r3, r3, #1
    3ac8:	b2db      	uxtb	r3, r3
    3aca:	2b00      	cmp	r3, #0
    3acc:	d1e0      	bne.n	3a90 <SetInputSouceSytemClock+0x38>

    if (FALSE != TimeoutOccurred)
    3ace:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3ad2:	2b00      	cmp	r3, #0
    3ad4:	d003      	beq.n	3ade <SetInputSouceSytemClock+0x86>
    {
        /* Report timeout error */
        Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, FIRC_CLK);
    3ad6:	2105      	movs	r1, #5
    3ad8:	2001      	movs	r0, #1
    3ada:	f7ff f975 	bl	2dc8 <Clock_Ip_ReportClockErrors>
    }
}
    3ade:	bf00      	nop
    3ae0:	b009      	add	sp, #36	; 0x24
    3ae2:	f85d fb04 	ldr.w	pc, [sp], #4
    3ae6:	bf00      	nop
    3ae8:	40064000 	.word	0x40064000

00003aec <Clock_Ip_SetFirc>:
static void Clock_Ip_SetFirc(Clock_Ip_IrcoscConfigType const* Config)
{
    3aec:	b500      	push	{lr}
    3aee:	b083      	sub	sp, #12
    3af0:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3af2:	9b01      	ldr	r3, [sp, #4]
    3af4:	2b00      	cmp	r3, #0
    3af6:	d002      	beq.n	3afe <Clock_Ip_SetFirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetFirc_TrustedCall,(Config));
      #else
        Clock_Ip_SetFirc_TrustedCall(Config);
    3af8:	9801      	ldr	r0, [sp, #4]
    3afa:	f000 f997 	bl	3e2c <Clock_Ip_SetFirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3afe:	bf00      	nop
    3b00:	b003      	add	sp, #12
    3b02:	f85d fb04 	ldr.w	pc, [sp], #4

00003b06 <Clock_Ip_EnableFirc>:
static void Clock_Ip_EnableFirc(Clock_Ip_IrcoscConfigType const* Config)
{
    3b06:	b500      	push	{lr}
    3b08:	b083      	sub	sp, #12
    3b0a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    3b0c:	9b01      	ldr	r3, [sp, #4]
    3b0e:	2b00      	cmp	r3, #0
    3b10:	d002      	beq.n	3b18 <Clock_Ip_EnableFirc+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableFirc_TrustedCall,(Config));
      #else
        Clock_Ip_EnableFirc_TrustedCall(Config);
    3b12:	9801      	ldr	r0, [sp, #4]
    3b14:	f000 fa7e 	bl	4014 <Clock_Ip_EnableFirc_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    3b18:	bf00      	nop
    3b1a:	b003      	add	sp, #12
    3b1c:	f85d fb04 	ldr.w	pc, [sp], #4

00003b20 <Clock_Ip_DisableFirc>:
static void Clock_Ip_DisableFirc(Clock_Ip_NameType Name)
{
    3b20:	b500      	push	{lr}
    3b22:	b083      	sub	sp, #12
    3b24:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableFirc_TrustedCall,(Name));
  #else
    Clock_Ip_DisableFirc_TrustedCall(Name);
    3b26:	9801      	ldr	r0, [sp, #4]
    3b28:	f000 fab8 	bl	409c <Clock_Ip_DisableFirc_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    3b2c:	bf00      	nop
    3b2e:	b003      	add	sp, #12
    3b30:	f85d fb04 	ldr.w	pc, [sp], #4

00003b34 <Clock_Ip_SetSirc_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SIRC_ENABLE
void Clock_Ip_SetSirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    3b34:	b500      	push	{lr}
    3b36:	b08b      	sub	sp, #44	; 0x2c
    3b38:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    3b3a:	2300      	movs	r3, #0
    3b3c:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;
    Clock_Ip_IrcoscConfigType SircConfig;

    if (NULL_PTR == Config)
    3b40:	9b01      	ldr	r3, [sp, #4]
    3b42:	2b00      	cmp	r3, #0
    3b44:	d10b      	bne.n	3b5e <Clock_Ip_SetSirc_TrustedCall+0x2a>
    {
        SircConfig.Name   = FIRC_CLK;
    3b46:	2305      	movs	r3, #5
    3b48:	9302      	str	r3, [sp, #8]
        SircConfig.Range  = 1U;   /* 8MHz */
    3b4a:	2301      	movs	r3, #1
    3b4c:	f88d 300f 	strb.w	r3, [sp, #15]
        SircConfig.Enable = 1U;   /* enabled */
    3b50:	2301      	movs	r3, #1
    3b52:	f8ad 300c 	strh.w	r3, [sp, #12]
        SircConfig.LowPowerModeEnable =1U;
    3b56:	2301      	movs	r3, #1
    3b58:	f88d 3010 	strb.w	r3, [sp, #16]
    3b5c:	e00e      	b.n	3b7c <Clock_Ip_SetSirc_TrustedCall+0x48>
    }
    else
    {
        SircConfig.Name   = Config->Name;
    3b5e:	9b01      	ldr	r3, [sp, #4]
    3b60:	681b      	ldr	r3, [r3, #0]
    3b62:	9302      	str	r3, [sp, #8]
        SircConfig.Range  = Config->Range;
    3b64:	9b01      	ldr	r3, [sp, #4]
    3b66:	79db      	ldrb	r3, [r3, #7]
    3b68:	f88d 300f 	strb.w	r3, [sp, #15]
        SircConfig.Enable = Config->Enable;
    3b6c:	9b01      	ldr	r3, [sp, #4]
    3b6e:	889b      	ldrh	r3, [r3, #4]
    3b70:	f8ad 300c 	strh.w	r3, [sp, #12]
        SircConfig.LowPowerModeEnable = Config->LowPowerModeEnable;
    3b74:	9b01      	ldr	r3, [sp, #4]
    3b76:	7a1b      	ldrb	r3, [r3, #8]
    3b78:	f88d 3010 	strb.w	r3, [sp, #16]
    }

    /* Clear LK bit field */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_LK_MASK));
    3b7c:	4b32      	ldr	r3, [pc, #200]	; (3c48 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3b7e:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3b82:	4a31      	ldr	r2, [pc, #196]	; (3c48 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3b84:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    3b88:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Disable clock */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCEN_MASK));
    3b8c:	4b2e      	ldr	r3, [pc, #184]	; (3c48 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3b8e:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3b92:	4a2d      	ldr	r2, [pc, #180]	; (3c48 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3b94:	f023 0301 	bic.w	r3, r3, #1
    3b98:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Disable SIRC Low Power */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    3b9c:	4b2a      	ldr	r3, [pc, #168]	; (3c48 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3b9e:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3ba2:	4a29      	ldr	r2, [pc, #164]	; (3c48 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3ba4:	f023 0304 	bic.w	r3, r3, #4
    3ba8:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Configure SIRC. */
    if (1U == SircConfig.Enable)
    3bac:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    3bb0:	2b01      	cmp	r3, #1
    3bb2:	d144      	bne.n	3c3e <Clock_Ip_SetSirc_TrustedCall+0x10a>
    {
        /* Step frequency range. */
        IP_SCG->SIRCCFG = SCG_SIRCCFG_RANGE(SircConfig.Range);
    3bb4:	f89d 300f 	ldrb.w	r3, [sp, #15]
    3bb8:	4a23      	ldr	r2, [pc, #140]	; (3c48 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3bba:	f003 0301 	and.w	r3, r3, #1
    3bbe:	f8c2 3208 	str.w	r3, [r2, #520]	; 0x208

        /* Enable clock. */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCEN(1U);
    3bc2:	4b21      	ldr	r3, [pc, #132]	; (3c48 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3bc4:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3bc8:	4a1f      	ldr	r2, [pc, #124]	; (3c48 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3bca:	f043 0301 	orr.w	r3, r3, #1
    3bce:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

        /* Set SIRC in VLP modes */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(SircConfig.LowPowerModeEnable);
    3bd2:	4b1d      	ldr	r3, [pc, #116]	; (3c48 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3bd4:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    3bd8:	f89d 3010 	ldrb.w	r3, [sp, #16]
    3bdc:	009b      	lsls	r3, r3, #2
    3bde:	f003 0304 	and.w	r3, r3, #4
    3be2:	4919      	ldr	r1, [pc, #100]	; (3c48 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3be4:	4313      	orrs	r3, r2
    3be6:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200

        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    3bea:	aa05      	add	r2, sp, #20
    3bec:	a906      	add	r1, sp, #24
    3bee:	a807      	add	r0, sp, #28
    3bf0:	f24c 3350 	movw	r3, #50000	; 0xc350
    3bf4:	f7ff f8f8 	bl	2de8 <Clock_Ip_StartTimeout>
        /* Wait until ircosc is locked */
        do
        {
            IrcoscStatus = (((IP_SCG->SIRCCSR & SCG_SIRCCSR_SIRCVLD_MASK) >> SCG_SIRCCSR_SIRCVLD_SHIFT));
    3bf8:	4b13      	ldr	r3, [pc, #76]	; (3c48 <Clock_Ip_SetSirc_TrustedCall+0x114>)
    3bfa:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3bfe:	0e1b      	lsrs	r3, r3, #24
    3c00:	f003 0301 	and.w	r3, r3, #1
    3c04:	9308      	str	r3, [sp, #32]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    3c06:	9a05      	ldr	r2, [sp, #20]
    3c08:	a906      	add	r1, sp, #24
    3c0a:	ab07      	add	r3, sp, #28
    3c0c:	4618      	mov	r0, r3
    3c0e:	f7ff f905 	bl	2e1c <Clock_Ip_TimeoutExpired>
    3c12:	4603      	mov	r3, r0
    3c14:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
        }
        while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    3c18:	9b08      	ldr	r3, [sp, #32]
    3c1a:	2b00      	cmp	r3, #0
    3c1c:	d106      	bne.n	3c2c <Clock_Ip_SetSirc_TrustedCall+0xf8>
    3c1e:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    3c22:	f083 0301 	eor.w	r3, r3, #1
    3c26:	b2db      	uxtb	r3, r3
    3c28:	2b00      	cmp	r3, #0
    3c2a:	d1e5      	bne.n	3bf8 <Clock_Ip_SetSirc_TrustedCall+0xc4>

        if (FALSE != TimeoutOccurred)
    3c2c:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    3c30:	2b00      	cmp	r3, #0
    3c32:	d004      	beq.n	3c3e <Clock_Ip_SetSirc_TrustedCall+0x10a>
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, SircConfig.Name);
    3c34:	9b02      	ldr	r3, [sp, #8]
    3c36:	4619      	mov	r1, r3
    3c38:	2001      	movs	r0, #1
    3c3a:	f7ff f8c5 	bl	2dc8 <Clock_Ip_ReportClockErrors>
        }
    }
}
    3c3e:	bf00      	nop
    3c40:	b00b      	add	sp, #44	; 0x2c
    3c42:	f85d fb04 	ldr.w	pc, [sp], #4
    3c46:	bf00      	nop
    3c48:	40064000 	.word	0x40064000

00003c4c <Clock_Ip_EnableSirc_TrustedCall>:
void Clock_Ip_EnableSirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    3c4c:	b500      	push	{lr}
    3c4e:	b089      	sub	sp, #36	; 0x24
    3c50:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    3c52:	2300      	movs	r3, #0
    3c54:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;

    /* Enable clock. */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCEN(1U);
    3c58:	4b1f      	ldr	r3, [pc, #124]	; (3cd8 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    3c5a:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3c5e:	4a1e      	ldr	r2, [pc, #120]	; (3cd8 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    3c60:	f043 0301 	orr.w	r3, r3, #1
    3c64:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Enable SIRC Low Power */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(1UL);
    3c68:	4b1b      	ldr	r3, [pc, #108]	; (3cd8 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    3c6a:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3c6e:	4a1a      	ldr	r2, [pc, #104]	; (3cd8 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    3c70:	f043 0304 	orr.w	r3, r3, #4
    3c74:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    3c78:	aa03      	add	r2, sp, #12
    3c7a:	a904      	add	r1, sp, #16
    3c7c:	a805      	add	r0, sp, #20
    3c7e:	f24c 3350 	movw	r3, #50000	; 0xc350
    3c82:	f7ff f8b1 	bl	2de8 <Clock_Ip_StartTimeout>
    /* Wait until ircosc is locked */
    do
    {
        IrcoscStatus = (((IP_SCG->SIRCCSR & SCG_SIRCCSR_SIRCVLD_MASK) >> SCG_SIRCCSR_SIRCVLD_SHIFT));
    3c86:	4b14      	ldr	r3, [pc, #80]	; (3cd8 <Clock_Ip_EnableSirc_TrustedCall+0x8c>)
    3c88:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3c8c:	0e1b      	lsrs	r3, r3, #24
    3c8e:	f003 0301 	and.w	r3, r3, #1
    3c92:	9306      	str	r3, [sp, #24]
        TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    3c94:	9a03      	ldr	r2, [sp, #12]
    3c96:	a904      	add	r1, sp, #16
    3c98:	ab05      	add	r3, sp, #20
    3c9a:	4618      	mov	r0, r3
    3c9c:	f7ff f8be 	bl	2e1c <Clock_Ip_TimeoutExpired>
    3ca0:	4603      	mov	r3, r0
    3ca2:	f88d 301f 	strb.w	r3, [sp, #31]
    }
    while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    3ca6:	9b06      	ldr	r3, [sp, #24]
    3ca8:	2b00      	cmp	r3, #0
    3caa:	d106      	bne.n	3cba <Clock_Ip_EnableSirc_TrustedCall+0x6e>
    3cac:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3cb0:	f083 0301 	eor.w	r3, r3, #1
    3cb4:	b2db      	uxtb	r3, r3
    3cb6:	2b00      	cmp	r3, #0
    3cb8:	d1e5      	bne.n	3c86 <Clock_Ip_EnableSirc_TrustedCall+0x3a>

    if (FALSE != TimeoutOccurred)
    3cba:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3cbe:	2b00      	cmp	r3, #0
    3cc0:	d005      	beq.n	3cce <Clock_Ip_EnableSirc_TrustedCall+0x82>
    {
        /* Report timeout error */
        Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    3cc2:	9b01      	ldr	r3, [sp, #4]
    3cc4:	681b      	ldr	r3, [r3, #0]
    3cc6:	4619      	mov	r1, r3
    3cc8:	2001      	movs	r0, #1
    3cca:	f7ff f87d 	bl	2dc8 <Clock_Ip_ReportClockErrors>
    }
}
    3cce:	bf00      	nop
    3cd0:	b009      	add	sp, #36	; 0x24
    3cd2:	f85d fb04 	ldr.w	pc, [sp], #4
    3cd6:	bf00      	nop
    3cd8:	40064000 	.word	0x40064000

00003cdc <Clock_Ip_DisableSirc_TrustedCall>:
void Clock_Ip_DisableSirc_TrustedCall(Clock_Ip_NameType Name)
{
    3cdc:	b082      	sub	sp, #8
    3cde:	9001      	str	r0, [sp, #4]
    (void)Name;

    /* Disable clock. */
    IP_SCG->SIRCCSR &= ~SCG_SIRCCSR_SIRCEN_MASK;
    3ce0:	4b09      	ldr	r3, [pc, #36]	; (3d08 <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    3ce2:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3ce6:	4a08      	ldr	r2, [pc, #32]	; (3d08 <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    3ce8:	f023 0301 	bic.w	r3, r3, #1
    3cec:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Disable SIRC Low Power */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    3cf0:	4b05      	ldr	r3, [pc, #20]	; (3d08 <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    3cf2:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3cf6:	4a04      	ldr	r2, [pc, #16]	; (3d08 <Clock_Ip_DisableSirc_TrustedCall+0x2c>)
    3cf8:	f023 0304 	bic.w	r3, r3, #4
    3cfc:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
    3d00:	bf00      	nop
    3d02:	b002      	add	sp, #8
    3d04:	4770      	bx	lr
    3d06:	bf00      	nop
    3d08:	40064000 	.word	0x40064000

00003d0c <Clock_Ip_SetSircVlp_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIRC_VLP_ENABLE
void Clock_Ip_SetSircVlp_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    3d0c:	b082      	sub	sp, #8
    3d0e:	9001      	str	r0, [sp, #4]
    /* Clear LK bit field */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_LK_MASK));
    3d10:	4b0f      	ldr	r3, [pc, #60]	; (3d50 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    3d12:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3d16:	4a0e      	ldr	r2, [pc, #56]	; (3d50 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    3d18:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    3d1c:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    3d20:	4b0b      	ldr	r3, [pc, #44]	; (3d50 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    3d22:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3d26:	4a0a      	ldr	r2, [pc, #40]	; (3d50 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    3d28:	f023 0304 	bic.w	r3, r3, #4
    3d2c:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Configure SIRC in VLP mode */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(Config->LowPowerModeEnable);
    3d30:	4b07      	ldr	r3, [pc, #28]	; (3d50 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    3d32:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    3d36:	9b01      	ldr	r3, [sp, #4]
    3d38:	7a1b      	ldrb	r3, [r3, #8]
    3d3a:	009b      	lsls	r3, r3, #2
    3d3c:	f003 0304 	and.w	r3, r3, #4
    3d40:	4903      	ldr	r1, [pc, #12]	; (3d50 <Clock_Ip_SetSircVlp_TrustedCall+0x44>)
    3d42:	4313      	orrs	r3, r2
    3d44:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200
}
    3d48:	bf00      	nop
    3d4a:	b002      	add	sp, #8
    3d4c:	4770      	bx	lr
    3d4e:	bf00      	nop
    3d50:	40064000 	.word	0x40064000

00003d54 <Clock_Ip_EnableSircVlp_TrustedCall>:
void Clock_Ip_EnableSircVlp_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    3d54:	b082      	sub	sp, #8
    3d56:	9001      	str	r0, [sp, #4]
    if (1U == Config->Enable)
    3d58:	9b01      	ldr	r3, [sp, #4]
    3d5a:	889b      	ldrh	r3, [r3, #4]
    3d5c:	2b01      	cmp	r3, #1
    3d5e:	d107      	bne.n	3d70 <Clock_Ip_EnableSircVlp_TrustedCall+0x1c>
    {
        /* Enable clock in VLP mode */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCLPEN(1U);
    3d60:	4b05      	ldr	r3, [pc, #20]	; (3d78 <Clock_Ip_EnableSircVlp_TrustedCall+0x24>)
    3d62:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3d66:	4a04      	ldr	r2, [pc, #16]	; (3d78 <Clock_Ip_EnableSircVlp_TrustedCall+0x24>)
    3d68:	f043 0304 	orr.w	r3, r3, #4
    3d6c:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
    }
}
    3d70:	bf00      	nop
    3d72:	b002      	add	sp, #8
    3d74:	4770      	bx	lr
    3d76:	bf00      	nop
    3d78:	40064000 	.word	0x40064000

00003d7c <Clock_Ip_DisableSircVlp_TrustedCall>:
void Clock_Ip_DisableSircVlp_TrustedCall(Clock_Ip_NameType Name)
{
    3d7c:	b082      	sub	sp, #8
    3d7e:	9001      	str	r0, [sp, #4]
    (void)Name;

    /* Disable clock */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCLPEN_MASK));
    3d80:	4b05      	ldr	r3, [pc, #20]	; (3d98 <Clock_Ip_DisableSircVlp_TrustedCall+0x1c>)
    3d82:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3d86:	4a04      	ldr	r2, [pc, #16]	; (3d98 <Clock_Ip_DisableSircVlp_TrustedCall+0x1c>)
    3d88:	f023 0304 	bic.w	r3, r3, #4
    3d8c:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
    3d90:	bf00      	nop
    3d92:	b002      	add	sp, #8
    3d94:	4770      	bx	lr
    3d96:	bf00      	nop
    3d98:	40064000 	.word	0x40064000

00003d9c <Clock_Ip_SetSircStop_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIRC_STOP_ENABLE
void Clock_Ip_SetSircStop_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    3d9c:	b082      	sub	sp, #8
    3d9e:	9001      	str	r0, [sp, #4]
    (void)Config;

    /* Clear LK bit field */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_LK_MASK));
    3da0:	4b0f      	ldr	r3, [pc, #60]	; (3de0 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    3da2:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3da6:	4a0e      	ldr	r2, [pc, #56]	; (3de0 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    3da8:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    3dac:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCSTEN_MASK));
    3db0:	4b0b      	ldr	r3, [pc, #44]	; (3de0 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    3db2:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3db6:	4a0a      	ldr	r2, [pc, #40]	; (3de0 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    3db8:	f023 0302 	bic.w	r3, r3, #2
    3dbc:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200

    /* Configure SIRC in STOP mode */
    IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCSTEN(Config->StopModeEnable);
    3dc0:	4b07      	ldr	r3, [pc, #28]	; (3de0 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    3dc2:	f8d3 2200 	ldr.w	r2, [r3, #512]	; 0x200
    3dc6:	9b01      	ldr	r3, [sp, #4]
    3dc8:	7a5b      	ldrb	r3, [r3, #9]
    3dca:	005b      	lsls	r3, r3, #1
    3dcc:	f003 0302 	and.w	r3, r3, #2
    3dd0:	4903      	ldr	r1, [pc, #12]	; (3de0 <Clock_Ip_SetSircStop_TrustedCall+0x44>)
    3dd2:	4313      	orrs	r3, r2
    3dd4:	f8c1 3200 	str.w	r3, [r1, #512]	; 0x200
}
    3dd8:	bf00      	nop
    3dda:	b002      	add	sp, #8
    3ddc:	4770      	bx	lr
    3dde:	bf00      	nop
    3de0:	40064000 	.word	0x40064000

00003de4 <Clock_Ip_EnableSircStop_TrustedCall>:
void Clock_Ip_EnableSircStop_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    3de4:	b082      	sub	sp, #8
    3de6:	9001      	str	r0, [sp, #4]
    if (1U == Config->Enable)
    3de8:	9b01      	ldr	r3, [sp, #4]
    3dea:	889b      	ldrh	r3, [r3, #4]
    3dec:	2b01      	cmp	r3, #1
    3dee:	d107      	bne.n	3e00 <Clock_Ip_EnableSircStop_TrustedCall+0x1c>
    {
        /* Enable clock in VLP mode */
        IP_SCG->SIRCCSR |= SCG_SIRCCSR_SIRCSTEN(1U);
    3df0:	4b05      	ldr	r3, [pc, #20]	; (3e08 <Clock_Ip_EnableSircStop_TrustedCall+0x24>)
    3df2:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3df6:	4a04      	ldr	r2, [pc, #16]	; (3e08 <Clock_Ip_EnableSircStop_TrustedCall+0x24>)
    3df8:	f043 0302 	orr.w	r3, r3, #2
    3dfc:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
    }
}
    3e00:	bf00      	nop
    3e02:	b002      	add	sp, #8
    3e04:	4770      	bx	lr
    3e06:	bf00      	nop
    3e08:	40064000 	.word	0x40064000

00003e0c <Clock_Ip_DisableSircStop_TrustedCall>:
void Clock_Ip_DisableSircStop_TrustedCall(Clock_Ip_NameType Name)
{
    3e0c:	b082      	sub	sp, #8
    3e0e:	9001      	str	r0, [sp, #4]
    (void)Name;

    /* Disable clock */
    IP_SCG->SIRCCSR &= (~((uint32)SCG_SIRCCSR_SIRCSTEN_MASK));
    3e10:	4b05      	ldr	r3, [pc, #20]	; (3e28 <Clock_Ip_DisableSircStop_TrustedCall+0x1c>)
    3e12:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3e16:	4a04      	ldr	r2, [pc, #16]	; (3e28 <Clock_Ip_DisableSircStop_TrustedCall+0x1c>)
    3e18:	f023 0302 	bic.w	r3, r3, #2
    3e1c:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
}
    3e20:	bf00      	nop
    3e22:	b002      	add	sp, #8
    3e24:	4770      	bx	lr
    3e26:	bf00      	nop
    3e28:	40064000 	.word	0x40064000

00003e2c <Clock_Ip_SetFirc_TrustedCall>:
#endif

#ifdef CLOCK_IP_FIRC_ENABLE
void Clock_Ip_SetFirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    3e2c:	b500      	push	{lr}
    3e2e:	b08b      	sub	sp, #44	; 0x2c
    3e30:	9001      	str	r0, [sp, #4]
    uint32 Instance = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    3e32:	9b01      	ldr	r3, [sp, #4]
    3e34:	681a      	ldr	r2, [r3, #0]
    3e36:	4975      	ldr	r1, [pc, #468]	; (400c <Clock_Ip_SetFirc_TrustedCall+0x1e0>)
    3e38:	4613      	mov	r3, r2
    3e3a:	00db      	lsls	r3, r3, #3
    3e3c:	4413      	add	r3, r2
    3e3e:	440b      	add	r3, r1
    3e40:	781b      	ldrb	r3, [r3, #0]
    3e42:	9308      	str	r3, [sp, #32]
    boolean TimeoutOccurred = FALSE;
    3e44:	2300      	movs	r3, #0
    3e46:	f88d 301f 	strb.w	r3, [sp, #31]
    boolean SircWasDisabled = FALSE;
    3e4a:	2300      	movs	r3, #0
    3e4c:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    uint32 IrcoscStatus;

    (void)Instance;

    /* Clear LK bit field */
    IP_SCG->FIRCCSR &= (uint32)(~(SCG_FIRCCSR_LK_MASK));
    3e50:	4b6f      	ldr	r3, [pc, #444]	; (4010 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3e52:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3e56:	4a6e      	ldr	r2, [pc, #440]	; (4010 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3e58:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    3e5c:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

    /* Check that FIRC is used by system clock) */
    if ((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCSEL_MASK) != 0U)
    3e60:	4b6b      	ldr	r3, [pc, #428]	; (4010 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3e62:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3e66:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
    3e6a:	2b00      	cmp	r3, #0
    3e6c:	d07d      	beq.n	3f6a <Clock_Ip_SetFirc_TrustedCall+0x13e>
    {
        /* Check whether FIRC is already configured as required */
        if ( (Config->Range != ((IP_SCG->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT)) ||
    3e6e:	9b01      	ldr	r3, [sp, #4]
    3e70:	79db      	ldrb	r3, [r3, #7]
    3e72:	461a      	mov	r2, r3
    3e74:	4b66      	ldr	r3, [pc, #408]	; (4010 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3e76:	f8d3 3308 	ldr.w	r3, [r3, #776]	; 0x308
    3e7a:	f003 0303 	and.w	r3, r3, #3
    3e7e:	429a      	cmp	r2, r3
    3e80:	d10b      	bne.n	3e9a <Clock_Ip_SetFirc_TrustedCall+0x6e>
            (Config->Regulator != ((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCREGOFF_MASK) >> SCG_FIRCCSR_FIRCREGOFF_SHIFT)) )
    3e82:	9b01      	ldr	r3, [sp, #4]
    3e84:	799b      	ldrb	r3, [r3, #6]
    3e86:	461a      	mov	r2, r3
    3e88:	4b61      	ldr	r3, [pc, #388]	; (4010 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3e8a:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3e8e:	08db      	lsrs	r3, r3, #3
    3e90:	f003 0301 	and.w	r3, r3, #1
        if ( (Config->Range != ((IP_SCG->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT)) ||
    3e94:	429a      	cmp	r2, r3
    3e96:	f000 80b4 	beq.w	4002 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
        {
            /* Enable SIRC if it is disabled. */
            if (0U == (IP_SCG->SIRCCSR & SCG_SIRCCSR_SIRCEN_MASK))
    3e9a:	4b5d      	ldr	r3, [pc, #372]	; (4010 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3e9c:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    3ea0:	f003 0301 	and.w	r3, r3, #1
    3ea4:	2b00      	cmp	r3, #0
    3ea6:	d105      	bne.n	3eb4 <Clock_Ip_SetFirc_TrustedCall+0x88>
            {
                SircWasDisabled = TRUE;
    3ea8:	2301      	movs	r3, #1
    3eaa:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
                Clock_Ip_SetSirc(NULL_PTR);
    3eae:	2000      	movs	r0, #0
    3eb0:	f7ff fd66 	bl	3980 <Clock_Ip_SetSirc>
            }

            /* Switch to SIRC */
            SetInputSouceSytemClock(CLOCK_IP_SIRC_CLK_SOURCE);
    3eb4:	2002      	movs	r0, #2
    3eb6:	f7ff fdcf 	bl	3a58 <SetInputSouceSytemClock>

            /* Disable clock */
            IP_SCG->FIRCCSR &= (~((uint32)SCG_FIRCCSR_FIRCEN_MASK));
    3eba:	4b55      	ldr	r3, [pc, #340]	; (4010 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3ebc:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3ec0:	4a53      	ldr	r2, [pc, #332]	; (4010 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3ec2:	f023 0301 	bic.w	r3, r3, #1
    3ec6:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

            /* Configure FIRC. */
            if (1U == Config->Enable)
    3eca:	9b01      	ldr	r3, [sp, #4]
    3ecc:	889b      	ldrh	r3, [r3, #4]
    3ece:	2b01      	cmp	r3, #1
    3ed0:	f040 8097 	bne.w	4002 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
            {
                /* Step frequency range. */
                IP_SCG->FIRCCFG = SCG_FIRCCFG_RANGE(Config->Range);
    3ed4:	9b01      	ldr	r3, [sp, #4]
    3ed6:	79db      	ldrb	r3, [r3, #7]
    3ed8:	4a4d      	ldr	r2, [pc, #308]	; (4010 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3eda:	f003 0303 	and.w	r3, r3, #3
    3ede:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308

                /* Enable clock. */
                IP_SCG->FIRCCSR |= (SCG_FIRCCSR_FIRCEN(1U) | SCG_FIRCCSR_FIRCREGOFF(Config->Regulator));
    3ee2:	4b4b      	ldr	r3, [pc, #300]	; (4010 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3ee4:	f8d3 2300 	ldr.w	r2, [r3, #768]	; 0x300
    3ee8:	9b01      	ldr	r3, [sp, #4]
    3eea:	799b      	ldrb	r3, [r3, #6]
    3eec:	00db      	lsls	r3, r3, #3
    3eee:	f003 0308 	and.w	r3, r3, #8
    3ef2:	4313      	orrs	r3, r2
    3ef4:	4a46      	ldr	r2, [pc, #280]	; (4010 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3ef6:	f043 0301 	orr.w	r3, r3, #1
    3efa:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

                Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    3efe:	aa03      	add	r2, sp, #12
    3f00:	a904      	add	r1, sp, #16
    3f02:	a805      	add	r0, sp, #20
    3f04:	f24c 3350 	movw	r3, #50000	; 0xc350
    3f08:	f7fe ff6e 	bl	2de8 <Clock_Ip_StartTimeout>
                /* Wait until ircosc is locked */
                do
                {
                    IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    3f0c:	4b40      	ldr	r3, [pc, #256]	; (4010 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3f0e:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3f12:	0e1b      	lsrs	r3, r3, #24
    3f14:	f003 0301 	and.w	r3, r3, #1
    3f18:	9306      	str	r3, [sp, #24]
                    TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    3f1a:	9a03      	ldr	r2, [sp, #12]
    3f1c:	a904      	add	r1, sp, #16
    3f1e:	ab05      	add	r3, sp, #20
    3f20:	4618      	mov	r0, r3
    3f22:	f7fe ff7b 	bl	2e1c <Clock_Ip_TimeoutExpired>
    3f26:	4603      	mov	r3, r0
    3f28:	f88d 301f 	strb.w	r3, [sp, #31]
                }
                while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    3f2c:	9b06      	ldr	r3, [sp, #24]
    3f2e:	2b00      	cmp	r3, #0
    3f30:	d106      	bne.n	3f40 <Clock_Ip_SetFirc_TrustedCall+0x114>
    3f32:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3f36:	f083 0301 	eor.w	r3, r3, #1
    3f3a:	b2db      	uxtb	r3, r3
    3f3c:	2b00      	cmp	r3, #0
    3f3e:	d1e5      	bne.n	3f0c <Clock_Ip_SetFirc_TrustedCall+0xe0>

                if (FALSE != TimeoutOccurred)
    3f40:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3f44:	2b00      	cmp	r3, #0
    3f46:	d005      	beq.n	3f54 <Clock_Ip_SetFirc_TrustedCall+0x128>
                {
                    /* Report timeout error */
                    Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    3f48:	9b01      	ldr	r3, [sp, #4]
    3f4a:	681b      	ldr	r3, [r3, #0]
    3f4c:	4619      	mov	r1, r3
    3f4e:	2001      	movs	r0, #1
    3f50:	f7fe ff3a 	bl	2dc8 <Clock_Ip_ReportClockErrors>
                }

                /* Switch back to FIRC */
                SetInputSouceSytemClock(CLOCK_IP_FIRC_CLK_SOURCE);
    3f54:	2003      	movs	r0, #3
    3f56:	f7ff fd7f 	bl	3a58 <SetInputSouceSytemClock>

                if (SircWasDisabled)
    3f5a:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    3f5e:	2b00      	cmp	r3, #0
    3f60:	d04f      	beq.n	4002 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
                {
                    Clock_Ip_DisableSirc(SIRC_CLK);
    3f62:	2002      	movs	r0, #2
    3f64:	f7ff fd26 	bl	39b4 <Clock_Ip_DisableSirc>
                /* Report timeout error */
                Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
            }
        }
    }
}
    3f68:	e04b      	b.n	4002 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
        IP_SCG->FIRCCSR &= (~((uint32)SCG_FIRCCSR_FIRCEN_MASK));
    3f6a:	4b29      	ldr	r3, [pc, #164]	; (4010 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3f6c:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3f70:	4a27      	ldr	r2, [pc, #156]	; (4010 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3f72:	f023 0301 	bic.w	r3, r3, #1
    3f76:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
        if (1U == Config->Enable)
    3f7a:	9b01      	ldr	r3, [sp, #4]
    3f7c:	889b      	ldrh	r3, [r3, #4]
    3f7e:	2b01      	cmp	r3, #1
    3f80:	d13f      	bne.n	4002 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
            IP_SCG->FIRCCFG = SCG_FIRCCFG_RANGE(Config->Range);
    3f82:	9b01      	ldr	r3, [sp, #4]
    3f84:	79db      	ldrb	r3, [r3, #7]
    3f86:	4a22      	ldr	r2, [pc, #136]	; (4010 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3f88:	f003 0303 	and.w	r3, r3, #3
    3f8c:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
            IP_SCG->FIRCCSR |= (SCG_FIRCCSR_FIRCEN(1U) | SCG_FIRCCSR_FIRCREGOFF(Config->Regulator));
    3f90:	4b1f      	ldr	r3, [pc, #124]	; (4010 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3f92:	f8d3 2300 	ldr.w	r2, [r3, #768]	; 0x300
    3f96:	9b01      	ldr	r3, [sp, #4]
    3f98:	799b      	ldrb	r3, [r3, #6]
    3f9a:	00db      	lsls	r3, r3, #3
    3f9c:	f003 0308 	and.w	r3, r3, #8
    3fa0:	4313      	orrs	r3, r2
    3fa2:	4a1b      	ldr	r2, [pc, #108]	; (4010 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3fa4:	f043 0301 	orr.w	r3, r3, #1
    3fa8:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
            Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    3fac:	aa03      	add	r2, sp, #12
    3fae:	a904      	add	r1, sp, #16
    3fb0:	a805      	add	r0, sp, #20
    3fb2:	f24c 3350 	movw	r3, #50000	; 0xc350
    3fb6:	f7fe ff17 	bl	2de8 <Clock_Ip_StartTimeout>
                IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    3fba:	4b15      	ldr	r3, [pc, #84]	; (4010 <Clock_Ip_SetFirc_TrustedCall+0x1e4>)
    3fbc:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    3fc0:	0e1b      	lsrs	r3, r3, #24
    3fc2:	f003 0301 	and.w	r3, r3, #1
    3fc6:	9306      	str	r3, [sp, #24]
                TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    3fc8:	9a03      	ldr	r2, [sp, #12]
    3fca:	a904      	add	r1, sp, #16
    3fcc:	ab05      	add	r3, sp, #20
    3fce:	4618      	mov	r0, r3
    3fd0:	f7fe ff24 	bl	2e1c <Clock_Ip_TimeoutExpired>
    3fd4:	4603      	mov	r3, r0
    3fd6:	f88d 301f 	strb.w	r3, [sp, #31]
            while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    3fda:	9b06      	ldr	r3, [sp, #24]
    3fdc:	2b00      	cmp	r3, #0
    3fde:	d106      	bne.n	3fee <Clock_Ip_SetFirc_TrustedCall+0x1c2>
    3fe0:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3fe4:	f083 0301 	eor.w	r3, r3, #1
    3fe8:	b2db      	uxtb	r3, r3
    3fea:	2b00      	cmp	r3, #0
    3fec:	d1e5      	bne.n	3fba <Clock_Ip_SetFirc_TrustedCall+0x18e>
            if (FALSE != TimeoutOccurred)
    3fee:	f89d 301f 	ldrb.w	r3, [sp, #31]
    3ff2:	2b00      	cmp	r3, #0
    3ff4:	d005      	beq.n	4002 <Clock_Ip_SetFirc_TrustedCall+0x1d6>
                Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    3ff6:	9b01      	ldr	r3, [sp, #4]
    3ff8:	681b      	ldr	r3, [r3, #0]
    3ffa:	4619      	mov	r1, r3
    3ffc:	2001      	movs	r0, #1
    3ffe:	f7fe fee3 	bl	2dc8 <Clock_Ip_ReportClockErrors>
}
    4002:	bf00      	nop
    4004:	b00b      	add	sp, #44	; 0x2c
    4006:	f85d fb04 	ldr.w	pc, [sp], #4
    400a:	bf00      	nop
    400c:	000154d0 	.word	0x000154d0
    4010:	40064000 	.word	0x40064000

00004014 <Clock_Ip_EnableFirc_TrustedCall>:
void Clock_Ip_EnableFirc_TrustedCall(Clock_Ip_IrcoscConfigType const* Config)
{
    4014:	b500      	push	{lr}
    4016:	b089      	sub	sp, #36	; 0x24
    4018:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    401a:	2300      	movs	r3, #0
    401c:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;

    if (1U == Config->Enable)
    4020:	9b01      	ldr	r3, [sp, #4]
    4022:	889b      	ldrh	r3, [r3, #4]
    4024:	2b01      	cmp	r3, #1
    4026:	d132      	bne.n	408e <Clock_Ip_EnableFirc_TrustedCall+0x7a>
    {
        /* Enable clock. */
        IP_SCG->FIRCCSR |= SCG_FIRCCSR_FIRCEN(1U);
    4028:	4b1b      	ldr	r3, [pc, #108]	; (4098 <Clock_Ip_EnableFirc_TrustedCall+0x84>)
    402a:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    402e:	4a1a      	ldr	r2, [pc, #104]	; (4098 <Clock_Ip_EnableFirc_TrustedCall+0x84>)
    4030:	f043 0301 	orr.w	r3, r3, #1
    4034:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300

        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    4038:	aa03      	add	r2, sp, #12
    403a:	a904      	add	r1, sp, #16
    403c:	a805      	add	r0, sp, #20
    403e:	f24c 3350 	movw	r3, #50000	; 0xc350
    4042:	f7fe fed1 	bl	2de8 <Clock_Ip_StartTimeout>
        /* Wait until ircosc is locked */
        do
        {
            IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    4046:	4b14      	ldr	r3, [pc, #80]	; (4098 <Clock_Ip_EnableFirc_TrustedCall+0x84>)
    4048:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    404c:	0e1b      	lsrs	r3, r3, #24
    404e:	f003 0301 	and.w	r3, r3, #1
    4052:	9306      	str	r3, [sp, #24]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    4054:	9a03      	ldr	r2, [sp, #12]
    4056:	a904      	add	r1, sp, #16
    4058:	ab05      	add	r3, sp, #20
    405a:	4618      	mov	r0, r3
    405c:	f7fe fede 	bl	2e1c <Clock_Ip_TimeoutExpired>
    4060:	4603      	mov	r3, r0
    4062:	f88d 301f 	strb.w	r3, [sp, #31]
        }
        while ((0U == IrcoscStatus) && (FALSE == TimeoutOccurred));
    4066:	9b06      	ldr	r3, [sp, #24]
    4068:	2b00      	cmp	r3, #0
    406a:	d106      	bne.n	407a <Clock_Ip_EnableFirc_TrustedCall+0x66>
    406c:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4070:	f083 0301 	eor.w	r3, r3, #1
    4074:	b2db      	uxtb	r3, r3
    4076:	2b00      	cmp	r3, #0
    4078:	d1e5      	bne.n	4046 <Clock_Ip_EnableFirc_TrustedCall+0x32>

        if (FALSE != TimeoutOccurred)
    407a:	f89d 301f 	ldrb.w	r3, [sp, #31]
    407e:	2b00      	cmp	r3, #0
    4080:	d005      	beq.n	408e <Clock_Ip_EnableFirc_TrustedCall+0x7a>
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, Config->Name);
    4082:	9b01      	ldr	r3, [sp, #4]
    4084:	681b      	ldr	r3, [r3, #0]
    4086:	4619      	mov	r1, r3
    4088:	2001      	movs	r0, #1
    408a:	f7fe fe9d 	bl	2dc8 <Clock_Ip_ReportClockErrors>
        }
    }
}
    408e:	bf00      	nop
    4090:	b009      	add	sp, #36	; 0x24
    4092:	f85d fb04 	ldr.w	pc, [sp], #4
    4096:	bf00      	nop
    4098:	40064000 	.word	0x40064000

0000409c <Clock_Ip_DisableFirc_TrustedCall>:
void Clock_Ip_DisableFirc_TrustedCall(Clock_Ip_NameType Name)
{
    409c:	b082      	sub	sp, #8
    409e:	9001      	str	r0, [sp, #4]
    (void) Name;

    /* Disable clock. */
    IP_SCG->FIRCCSR &= ~SCG_FIRCCSR_FIRCEN_MASK;
    40a0:	4b05      	ldr	r3, [pc, #20]	; (40b8 <Clock_Ip_DisableFirc_TrustedCall+0x1c>)
    40a2:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    40a6:	4a04      	ldr	r2, [pc, #16]	; (40b8 <Clock_Ip_DisableFirc_TrustedCall+0x1c>)
    40a8:	f023 0301 	bic.w	r3, r3, #1
    40ac:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
}
    40b0:	bf00      	nop
    40b2:	b002      	add	sp, #8
    40b4:	4770      	bx	lr
    40b6:	bf00      	nop
    40b8:	40064000 	.word	0x40064000

000040bc <Clock_Ip_ClockMonitorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_ClockMonitorEmpty(Clock_Ip_CmuConfigType const* Config)
{
    40bc:	b082      	sub	sp, #8
    40be:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    40c0:	bf00      	nop
    40c2:	b002      	add	sp, #8
    40c4:	4770      	bx	lr

000040c6 <Clock_Ip_ClockMonitorEmpty_Set>:

static void Clock_Ip_ClockMonitorEmpty_Set( Clock_Ip_CmuConfigType const* Config,
                                            uint32 Index
                                           )
{
    40c6:	b082      	sub	sp, #8
    40c8:	9001      	str	r0, [sp, #4]
    40ca:	9100      	str	r1, [sp, #0]
    (void)Config;
    (void)Index;
    /* No implementation */
}
    40cc:	bf00      	nop
    40ce:	b002      	add	sp, #8
    40d0:	4770      	bx	lr

000040d2 <Clock_Ip_ClockMonitorEmpty_Disable>:

static void Clock_Ip_ClockMonitorEmpty_Disable(Clock_Ip_NameType Name)
{
    40d2:	b082      	sub	sp, #8
    40d4:	9001      	str	r0, [sp, #4]
    (void)Name;
    /* No implementation */
}
    40d6:	bf00      	nop
    40d8:	b002      	add	sp, #8
    40da:	4770      	bx	lr

000040dc <Clock_Ip_CallbackPllEmpty>:

#include "Mcu_MemMap.h"


static void Clock_Ip_CallbackPllEmpty(Clock_Ip_PllConfigType const* Config)
{
    40dc:	b082      	sub	sp, #8
    40de:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    40e0:	bf00      	nop
    40e2:	b002      	add	sp, #8
    40e4:	4770      	bx	lr

000040e6 <Clock_Ip_CallbackPllEmptyComplete>:
static Clock_Ip_PllStatusReturnType Clock_Ip_CallbackPllEmptyComplete(Clock_Ip_NameType PllName)
{
    40e6:	b082      	sub	sp, #8
    40e8:	9001      	str	r0, [sp, #4]
    (void)PllName;
    /* No implementation */
    return STATUS_PLL_LOCKED;
    40ea:	2302      	movs	r3, #2
}
    40ec:	4618      	mov	r0, r3
    40ee:	b002      	add	sp, #8
    40f0:	4770      	bx	lr

000040f2 <Clock_Ip_CallbackPllEmptyDisable>:
static void Clock_Ip_CallbackPllEmptyDisable(Clock_Ip_NameType PllName)
{
    40f2:	b082      	sub	sp, #8
    40f4:	9001      	str	r0, [sp, #4]
    (void)PllName;
    /* No implementation */
}
    40f6:	bf00      	nop
    40f8:	b002      	add	sp, #8
    40fa:	4770      	bx	lr

000040fc <Clock_Ip_ResetSpll>:


#ifdef CLOCK_IP_SPLL_ENABLE
static void Clock_Ip_ResetSpll(Clock_Ip_PllConfigType const* Config)
{
    40fc:	b500      	push	{lr}
    40fe:	b083      	sub	sp, #12
    4100:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4102:	9b01      	ldr	r3, [sp, #4]
    4104:	2b00      	cmp	r3, #0
    4106:	d002      	beq.n	410e <Clock_Ip_ResetSpll+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSpll_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSpll_TrustedCall(Config);
    4108:	9801      	ldr	r0, [sp, #4]
    410a:	f000 f870 	bl	41ee <Clock_Ip_ResetSpll_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    410e:	bf00      	nop
    4110:	b003      	add	sp, #12
    4112:	f85d fb04 	ldr.w	pc, [sp], #4

00004116 <Clock_Ip_SetSpll>:
static void Clock_Ip_SetSpll(Clock_Ip_PllConfigType const* Config)
{
    4116:	b500      	push	{lr}
    4118:	b083      	sub	sp, #12
    411a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    411c:	9b01      	ldr	r3, [sp, #4]
    411e:	2b00      	cmp	r3, #0
    4120:	d002      	beq.n	4128 <Clock_Ip_SetSpll+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSpll_TrustedCall,(Config));
      #else
        Clock_Ip_SetSpll_TrustedCall(Config);
    4122:	9801      	ldr	r0, [sp, #4]
    4124:	f000 f89a 	bl	425c <Clock_Ip_SetSpll_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4128:	bf00      	nop
    412a:	b003      	add	sp, #12
    412c:	f85d fb04 	ldr.w	pc, [sp], #4

00004130 <Clock_Ip_CompleteSpll>:
static Clock_Ip_PllStatusReturnType Clock_Ip_CompleteSpll(Clock_Ip_NameType PllName)
{
    4130:	b500      	push	{lr}
    4132:	b089      	sub	sp, #36	; 0x24
    4134:	9001      	str	r0, [sp, #4]
    Clock_Ip_PllStatusReturnType PllStatus = STATUS_PLL_UNLOCKED;
    4136:	2301      	movs	r3, #1
    4138:	9307      	str	r3, [sp, #28]
    boolean TimeoutOccurred = FALSE;
    413a:	2300      	movs	r3, #0
    413c:	f88d 301b 	strb.w	r3, [sp, #27]
    uint32 TimeoutTicks;
    uint32 SpllStatus;


    /* Configure SPLL. */
    if ((IP_SCG->SPLLCSR & SCG_SPLLCSR_SPLLEN_MASK) != 0U)
    4140:	4b1e      	ldr	r3, [pc, #120]	; (41bc <Clock_Ip_CompleteSpll+0x8c>)
    4142:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    4146:	f003 0301 	and.w	r3, r3, #1
    414a:	2b00      	cmp	r3, #0
    414c:	d02f      	beq.n	41ae <Clock_Ip_CompleteSpll+0x7e>
    {
        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    414e:	aa02      	add	r2, sp, #8
    4150:	a903      	add	r1, sp, #12
    4152:	a804      	add	r0, sp, #16
    4154:	f24c 3350 	movw	r3, #50000	; 0xc350
    4158:	f7fe fe46 	bl	2de8 <Clock_Ip_StartTimeout>
        /* Wait until pll is locked */
        do
        {
            SpllStatus = (((IP_SCG->SPLLCSR & SCG_SPLLCSR_SPLLVLD_MASK) >> SCG_SPLLCSR_SPLLVLD_SHIFT));
    415c:	4b17      	ldr	r3, [pc, #92]	; (41bc <Clock_Ip_CompleteSpll+0x8c>)
    415e:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    4162:	0e1b      	lsrs	r3, r3, #24
    4164:	f003 0301 	and.w	r3, r3, #1
    4168:	9305      	str	r3, [sp, #20]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    416a:	9a02      	ldr	r2, [sp, #8]
    416c:	a903      	add	r1, sp, #12
    416e:	ab04      	add	r3, sp, #16
    4170:	4618      	mov	r0, r3
    4172:	f7fe fe53 	bl	2e1c <Clock_Ip_TimeoutExpired>
    4176:	4603      	mov	r3, r0
    4178:	f88d 301b 	strb.w	r3, [sp, #27]
        }
        while ((0U == SpllStatus) && (FALSE == TimeoutOccurred));
    417c:	9b05      	ldr	r3, [sp, #20]
    417e:	2b00      	cmp	r3, #0
    4180:	d106      	bne.n	4190 <Clock_Ip_CompleteSpll+0x60>
    4182:	f89d 301b 	ldrb.w	r3, [sp, #27]
    4186:	f083 0301 	eor.w	r3, r3, #1
    418a:	b2db      	uxtb	r3, r3
    418c:	2b00      	cmp	r3, #0
    418e:	d1e5      	bne.n	415c <Clock_Ip_CompleteSpll+0x2c>

        if (FALSE == TimeoutOccurred)
    4190:	f89d 301b 	ldrb.w	r3, [sp, #27]
    4194:	f083 0301 	eor.w	r3, r3, #1
    4198:	b2db      	uxtb	r3, r3
    419a:	2b00      	cmp	r3, #0
    419c:	d002      	beq.n	41a4 <Clock_Ip_CompleteSpll+0x74>
        {
            PllStatus = STATUS_PLL_LOCKED;
    419e:	2302      	movs	r3, #2
    41a0:	9307      	str	r3, [sp, #28]
    41a2:	e006      	b.n	41b2 <Clock_Ip_CompleteSpll+0x82>
        }
        else
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, PllName);
    41a4:	9901      	ldr	r1, [sp, #4]
    41a6:	2001      	movs	r0, #1
    41a8:	f7fe fe0e 	bl	2dc8 <Clock_Ip_ReportClockErrors>
    41ac:	e001      	b.n	41b2 <Clock_Ip_CompleteSpll+0x82>
        }
    }
    else
    {
        PllStatus = STATUS_PLL_NOT_ENABLED;
    41ae:	2300      	movs	r3, #0
    41b0:	9307      	str	r3, [sp, #28]
    }
    
    return PllStatus;
    41b2:	9b07      	ldr	r3, [sp, #28]
}
    41b4:	4618      	mov	r0, r3
    41b6:	b009      	add	sp, #36	; 0x24
    41b8:	f85d fb04 	ldr.w	pc, [sp], #4
    41bc:	40064000 	.word	0x40064000

000041c0 <Clock_Ip_DisableSpll>:
static void Clock_Ip_DisableSpll(Clock_Ip_NameType PllName)
{
    41c0:	b500      	push	{lr}
    41c2:	b083      	sub	sp, #12
    41c4:	9001      	str	r0, [sp, #4]
#ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
  #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(Clock_Ip_DisableSpll_TrustedCall,(PllName));
  #else
    Clock_Ip_DisableSpll_TrustedCall(PllName);
    41c6:	9801      	ldr	r0, [sp, #4]
    41c8:	f000 f886 	bl	42d8 <Clock_Ip_DisableSpll_TrustedCall>
  #endif
#endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
}
    41cc:	bf00      	nop
    41ce:	b003      	add	sp, #12
    41d0:	f85d fb04 	ldr.w	pc, [sp], #4

000041d4 <Clock_Ip_EnableSpll>:
static void Clock_Ip_EnableSpll(Clock_Ip_PllConfigType const* Config)
{
    41d4:	b500      	push	{lr}
    41d6:	b083      	sub	sp, #12
    41d8:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    41da:	9b01      	ldr	r3, [sp, #4]
    41dc:	2b00      	cmp	r3, #0
    41de:	d002      	beq.n	41e6 <Clock_Ip_EnableSpll+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_EnableSpll_TrustedCall,(Config));
      #else
        Clock_Ip_EnableSpll_TrustedCall(Config);
    41e0:	9801      	ldr	r0, [sp, #4]
    41e2:	f000 f891 	bl	4308 <Clock_Ip_EnableSpll_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    41e6:	bf00      	nop
    41e8:	b003      	add	sp, #12
    41ea:	f85d fb04 	ldr.w	pc, [sp], #4

000041ee <Clock_Ip_ResetSpll_TrustedCall>:
*                                        GLOBAL FUNCTIONS
==================================================================================================*/

#ifdef CLOCK_IP_SPLL_ENABLE
void Clock_Ip_ResetSpll_TrustedCall(Clock_Ip_PllConfigType const* Config)
{
    41ee:	b082      	sub	sp, #8
    41f0:	9001      	str	r0, [sp, #4]
    (void)Config;

    /* Power down PLL */

    /* Clear LK bit field */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_LK_MASK));
    41f2:	4b19      	ldr	r3, [pc, #100]	; (4258 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    41f4:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    41f8:	4a17      	ldr	r2, [pc, #92]	; (4258 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    41fa:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    41fe:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock monitor */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLCM_MASK));
    4202:	4b15      	ldr	r3, [pc, #84]	; (4258 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    4204:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    4208:	4a13      	ldr	r2, [pc, #76]	; (4258 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    420a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    420e:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock monitor reset*/
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLCMRE_MASK));
    4212:	4b11      	ldr	r3, [pc, #68]	; (4258 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    4214:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    4218:	4a0f      	ldr	r2, [pc, #60]	; (4258 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    421a:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    421e:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLEN_MASK));
    4222:	4b0d      	ldr	r3, [pc, #52]	; (4258 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    4224:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    4228:	4a0b      	ldr	r2, [pc, #44]	; (4258 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    422a:	f023 0301 	bic.w	r3, r3, #1
    422e:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Reset PLL configuration. */
    #if (defined (CLOCK_IP_S32K142W) || defined(CLOCK_IP_S32K144W) || defined(CLOCK_IP_S32M244))
    IP_SCG->SPLLCFG &= (~((uint32)SCG_SPLLCFG_SOURCE_MASK));
    #endif
    IP_SCG->SPLLCFG &= (~((uint32)SCG_SPLLCFG_PREDIV_MASK));
    4232:	4b09      	ldr	r3, [pc, #36]	; (4258 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    4234:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    4238:	4a07      	ldr	r2, [pc, #28]	; (4258 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    423a:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    423e:	f8c2 3608 	str.w	r3, [r2, #1544]	; 0x608
    IP_SCG->SPLLCFG &= (~((uint32)SCG_SPLLCFG_MULT_MASK));
    4242:	4b05      	ldr	r3, [pc, #20]	; (4258 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    4244:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    4248:	4a03      	ldr	r2, [pc, #12]	; (4258 <Clock_Ip_ResetSpll_TrustedCall+0x6a>)
    424a:	f423 13f8 	bic.w	r3, r3, #2031616	; 0x1f0000
    424e:	f8c2 3608 	str.w	r3, [r2, #1544]	; 0x608
}
    4252:	bf00      	nop
    4254:	b002      	add	sp, #8
    4256:	4770      	bx	lr
    4258:	40064000 	.word	0x40064000

0000425c <Clock_Ip_SetSpll_TrustedCall>:
void Clock_Ip_SetSpll_TrustedCall(Clock_Ip_PllConfigType const* Config)
{
    425c:	b082      	sub	sp, #8
    425e:	9001      	str	r0, [sp, #4]
    /* Configure SPLL. */
    if (1U == Config->Enable)
    4260:	9b01      	ldr	r3, [sp, #4]
    4262:	889b      	ldrh	r3, [r3, #4]
    4264:	2b01      	cmp	r3, #1
    4266:	d12f      	bne.n	42c8 <Clock_Ip_SetSpll_TrustedCall+0x6c>
            IP_SCG->SPLLCFG |= SCG_SPLLCFG_SOURCE(1UL);
        }
        #endif

        /* Set PLL configuration. */
        IP_SCG->SPLLCFG |= SCG_SPLLCFG_PREDIV((uint32)(Config->Predivider) - 1U)  |
    4268:	4b1a      	ldr	r3, [pc, #104]	; (42d4 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    426a:	f8d3 2608 	ldr.w	r2, [r3, #1544]	; 0x608
    426e:	9b01      	ldr	r3, [sp, #4]
    4270:	7b5b      	ldrb	r3, [r3, #13]
    4272:	3b01      	subs	r3, #1
    4274:	021b      	lsls	r3, r3, #8
    4276:	f403 61e0 	and.w	r1, r3, #1792	; 0x700
                        SCG_SPLLCFG_MULT((uint32)(Config->MulFactorDiv) - 16U);
    427a:	9b01      	ldr	r3, [sp, #4]
    427c:	7d1b      	ldrb	r3, [r3, #20]
    427e:	3b10      	subs	r3, #16
    4280:	041b      	lsls	r3, r3, #16
    4282:	f403 13f8 	and.w	r3, r3, #2031616	; 0x1f0000
        IP_SCG->SPLLCFG |= SCG_SPLLCFG_PREDIV((uint32)(Config->Predivider) - 1U)  |
    4286:	430b      	orrs	r3, r1
    4288:	4912      	ldr	r1, [pc, #72]	; (42d4 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    428a:	4313      	orrs	r3, r2
    428c:	f8c1 3608 	str.w	r3, [r1, #1544]	; 0x608

        /* Enable clock, configure monitor, lock register. */
        switch (Config->Monitor)
    4290:	9b01      	ldr	r3, [sp, #4]
    4292:	7fdb      	ldrb	r3, [r3, #31]
    4294:	2b02      	cmp	r3, #2
    4296:	d011      	beq.n	42bc <Clock_Ip_SetSpll_TrustedCall+0x60>
    4298:	2b02      	cmp	r3, #2
    429a:	dc17      	bgt.n	42cc <Clock_Ip_SetSpll_TrustedCall+0x70>
    429c:	2b00      	cmp	r3, #0
    429e:	d002      	beq.n	42a6 <Clock_Ip_SetSpll_TrustedCall+0x4a>
    42a0:	2b01      	cmp	r3, #1
    42a2:	d005      	beq.n	42b0 <Clock_Ip_SetSpll_TrustedCall+0x54>
            break;
#endif
            default:
                /* Invalid monitor mode */
                CLOCK_IP_DEV_ASSERT(FALSE);
                break;
    42a4:	e012      	b.n	42cc <Clock_Ip_SetSpll_TrustedCall+0x70>
                IP_SCG->SPLLCSR = SCG_SPLLCSR_SPLLCM(0UL) |
    42a6:	4b0b      	ldr	r3, [pc, #44]	; (42d4 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    42a8:	2200      	movs	r2, #0
    42aa:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
            break;
    42ae:	e00e      	b.n	42ce <Clock_Ip_SetSpll_TrustedCall+0x72>
                IP_SCG->SPLLCSR = SCG_SPLLCSR_SPLLCM(1UL) |
    42b0:	4b08      	ldr	r3, [pc, #32]	; (42d4 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    42b2:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    42b6:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
            break;
    42ba:	e008      	b.n	42ce <Clock_Ip_SetSpll_TrustedCall+0x72>
                IP_SCG->SPLLCSR = SCG_SPLLCSR_SPLLCM(1UL) |
    42bc:	4b05      	ldr	r3, [pc, #20]	; (42d4 <Clock_Ip_SetSpll_TrustedCall+0x78>)
    42be:	f44f 3240 	mov.w	r2, #196608	; 0x30000
    42c2:	f8c3 2600 	str.w	r2, [r3, #1536]	; 0x600
            break;
    42c6:	e002      	b.n	42ce <Clock_Ip_SetSpll_TrustedCall+0x72>
        }
    }
    42c8:	bf00      	nop
    42ca:	e000      	b.n	42ce <Clock_Ip_SetSpll_TrustedCall+0x72>
                break;
    42cc:	bf00      	nop
}
    42ce:	bf00      	nop
    42d0:	b002      	add	sp, #8
    42d2:	4770      	bx	lr
    42d4:	40064000 	.word	0x40064000

000042d8 <Clock_Ip_DisableSpll_TrustedCall>:
void Clock_Ip_DisableSpll_TrustedCall(Clock_Ip_NameType PllName)
{
    42d8:	b082      	sub	sp, #8
    42da:	9001      	str	r0, [sp, #4]
    (void)PllName;

    /* Power down PLL */

    /* Clear LK bit field */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_LK_MASK));
    42dc:	4b09      	ldr	r3, [pc, #36]	; (4304 <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    42de:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    42e2:	4a08      	ldr	r2, [pc, #32]	; (4304 <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    42e4:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
    42e8:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600

    /* Disable clock */
    IP_SCG->SPLLCSR &= (~((uint32)SCG_SPLLCSR_SPLLEN_MASK));
    42ec:	4b05      	ldr	r3, [pc, #20]	; (4304 <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    42ee:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    42f2:	4a04      	ldr	r2, [pc, #16]	; (4304 <Clock_Ip_DisableSpll_TrustedCall+0x2c>)
    42f4:	f023 0301 	bic.w	r3, r3, #1
    42f8:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600
}
    42fc:	bf00      	nop
    42fe:	b002      	add	sp, #8
    4300:	4770      	bx	lr
    4302:	bf00      	nop
    4304:	40064000 	.word	0x40064000

00004308 <Clock_Ip_EnableSpll_TrustedCall>:
void Clock_Ip_EnableSpll_TrustedCall(Clock_Ip_PllConfigType const* Config)
{
    4308:	b082      	sub	sp, #8
    430a:	9001      	str	r0, [sp, #4]
    /* Configure SPLL. */
    if (1U == Config->Enable)
    430c:	9b01      	ldr	r3, [sp, #4]
    430e:	889b      	ldrh	r3, [r3, #4]
    4310:	2b01      	cmp	r3, #1
    4312:	d107      	bne.n	4324 <Clock_Ip_EnableSpll_TrustedCall+0x1c>
    {
        /* Enable SPLL */
        IP_SCG->SPLLCSR |= SCG_SPLLCSR_SPLLEN(1UL);
    4314:	4b05      	ldr	r3, [pc, #20]	; (432c <Clock_Ip_EnableSpll_TrustedCall+0x24>)
    4316:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    431a:	4a04      	ldr	r2, [pc, #16]	; (432c <Clock_Ip_EnableSpll_TrustedCall+0x24>)
    431c:	f043 0301 	orr.w	r3, r3, #1
    4320:	f8c2 3600 	str.w	r3, [r2, #1536]	; 0x600
    }
}
    4324:	bf00      	nop
    4326:	b002      	add	sp, #8
    4328:	4770      	bx	lr
    432a:	bf00      	nop
    432c:	40064000 	.word	0x40064000

00004330 <Clock_Ip_ProgressiveFrequencyClockSwitchEmpty>:
#include "Mcu_MemMap.h"

static void Clock_Ip_ProgressiveFrequencyClockSwitchEmpty(  Clock_Ip_PcfsConfigType const* Config,
                                                            uint32 Index
                                                          )
{
    4330:	b082      	sub	sp, #8
    4332:	9001      	str	r0, [sp, #4]
    4334:	9100      	str	r1, [sp, #0]
    (void)Config;
    (void)Index;
    /* No implementation */
}
    4336:	bf00      	nop
    4338:	b002      	add	sp, #8
    433a:	4770      	bx	lr

0000433c <Clock_Ip_CallbackSelectorEmpty>:
#define MCU_START_SEC_CODE

#include "Mcu_MemMap.h"

static void Clock_Ip_CallbackSelectorEmpty(Clock_Ip_SelectorConfigType const* Config)
{
    433c:	b082      	sub	sp, #8
    433e:	9001      	str	r0, [sp, #4]
    (void)Config;
    /* No implementation */
}
    4340:	bf00      	nop
    4342:	b002      	add	sp, #8
    4344:	4770      	bx	lr

00004346 <Clock_Ip_ResetScgRunSel>:

#ifdef CLOCK_IP_SCG_SCS_RUN_SEL
static void Clock_Ip_ResetScgRunSel(Clock_Ip_SelectorConfigType const *Config)
{
    4346:	b500      	push	{lr}
    4348:	b083      	sub	sp, #12
    434a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    434c:	9b01      	ldr	r3, [sp, #4]
    434e:	2b00      	cmp	r3, #0
    4350:	d002      	beq.n	4358 <Clock_Ip_ResetScgRunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetScgRunSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetScgRunSel_TrustedCall(Config);
    4352:	9801      	ldr	r0, [sp, #4]
    4354:	f000 f8ee 	bl	4534 <Clock_Ip_ResetScgRunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4358:	bf00      	nop
    435a:	b003      	add	sp, #12
    435c:	f85d fb04 	ldr.w	pc, [sp], #4

00004360 <Clock_Ip_SetScgRunSel>:

static void Clock_Ip_SetScgRunSel(Clock_Ip_SelectorConfigType const *Config)
{
    4360:	b500      	push	{lr}
    4362:	b083      	sub	sp, #12
    4364:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4366:	9b01      	ldr	r3, [sp, #4]
    4368:	2b00      	cmp	r3, #0
    436a:	d002      	beq.n	4372 <Clock_Ip_SetScgRunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgRunSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgRunSel_TrustedCall(Config);
    436c:	9801      	ldr	r0, [sp, #4]
    436e:	f000 f8ff 	bl	4570 <Clock_Ip_SetScgRunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4372:	bf00      	nop
    4374:	b003      	add	sp, #12
    4376:	f85d fb04 	ldr.w	pc, [sp], #4

0000437a <Clock_Ip_SetScgVlprSel>:

#endif

#ifdef CLOCK_IP_SCG_SCS_VLPR_SEL
static void Clock_Ip_SetScgVlprSel(Clock_Ip_SelectorConfigType const *Config)
{
    437a:	b500      	push	{lr}
    437c:	b083      	sub	sp, #12
    437e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4380:	9b01      	ldr	r3, [sp, #4]
    4382:	2b00      	cmp	r3, #0
    4384:	d002      	beq.n	438c <Clock_Ip_SetScgVlprSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgVlprSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgVlprSel_TrustedCall(Config);
    4386:	9801      	ldr	r0, [sp, #4]
    4388:	f000 f912 	bl	45b0 <Clock_Ip_SetScgVlprSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    438c:	bf00      	nop
    438e:	b003      	add	sp, #12
    4390:	f85d fb04 	ldr.w	pc, [sp], #4

00004394 <Clock_Ip_ResetScgHsrunSel>:

#endif

#ifdef CLOCK_IP_SCG_SCS_HSRUN_SEL
static void Clock_Ip_ResetScgHsrunSel(Clock_Ip_SelectorConfigType const *Config)
{
    4394:	b500      	push	{lr}
    4396:	b083      	sub	sp, #12
    4398:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    439a:	9b01      	ldr	r3, [sp, #4]
    439c:	2b00      	cmp	r3, #0
    439e:	d002      	beq.n	43a6 <Clock_Ip_ResetScgHsrunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetScgHsrunSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetScgHsrunSel_TrustedCall(Config);
    43a0:	9801      	ldr	r0, [sp, #4]
    43a2:	f000 f925 	bl	45f0 <Clock_Ip_ResetScgHsrunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    43a6:	bf00      	nop
    43a8:	b003      	add	sp, #12
    43aa:	f85d fb04 	ldr.w	pc, [sp], #4

000043ae <Clock_Ip_SetScgHsrunSel>:
static void Clock_Ip_SetScgHsrunSel(Clock_Ip_SelectorConfigType const *Config)
{
    43ae:	b500      	push	{lr}
    43b0:	b083      	sub	sp, #12
    43b2:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    43b4:	9b01      	ldr	r3, [sp, #4]
    43b6:	2b00      	cmp	r3, #0
    43b8:	d002      	beq.n	43c0 <Clock_Ip_SetScgHsrunSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgHsrunSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgHsrunSel_TrustedCall(Config);
    43ba:	9801      	ldr	r0, [sp, #4]
    43bc:	f000 f936 	bl	462c <Clock_Ip_SetScgHsrunSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    43c0:	bf00      	nop
    43c2:	b003      	add	sp, #12
    43c4:	f85d fb04 	ldr.w	pc, [sp], #4

000043c8 <Clock_Ip_ResetSimRtcSel>:
#endif

#ifdef CLOCK_IP_SIM_RTC_SEL
static void Clock_Ip_ResetSimRtcSel(Clock_Ip_SelectorConfigType const *Config)
{
    43c8:	b500      	push	{lr}
    43ca:	b083      	sub	sp, #12
    43cc:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    43ce:	9b01      	ldr	r3, [sp, #4]
    43d0:	2b00      	cmp	r3, #0
    43d2:	d002      	beq.n	43da <Clock_Ip_ResetSimRtcSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimRtcSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimRtcSel_TrustedCall(Config);
    43d4:	9801      	ldr	r0, [sp, #4]
    43d6:	f000 f949 	bl	466c <Clock_Ip_ResetSimRtcSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    43da:	bf00      	nop
    43dc:	b003      	add	sp, #12
    43de:	f85d fb04 	ldr.w	pc, [sp], #4

000043e2 <Clock_Ip_SetSimRtcSel>:
static void Clock_Ip_SetSimRtcSel(Clock_Ip_SelectorConfigType const *Config)
{
    43e2:	b500      	push	{lr}
    43e4:	b083      	sub	sp, #12
    43e6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    43e8:	9b01      	ldr	r3, [sp, #4]
    43ea:	2b00      	cmp	r3, #0
    43ec:	d002      	beq.n	43f4 <Clock_Ip_SetSimRtcSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimRtcSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimRtcSel_TrustedCall(Config);
    43ee:	9801      	ldr	r0, [sp, #4]
    43f0:	f000 f958 	bl	46a4 <Clock_Ip_SetSimRtcSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    43f4:	bf00      	nop
    43f6:	b003      	add	sp, #12
    43f8:	f85d fb04 	ldr.w	pc, [sp], #4

000043fc <Clock_Ip_ResetSimLpoSel>:
#endif

#ifdef CLOCK_IP_SIM_LPO_SEL
static void Clock_Ip_ResetSimLpoSel(Clock_Ip_SelectorConfigType const *Config)
{
    43fc:	b500      	push	{lr}
    43fe:	b083      	sub	sp, #12
    4400:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4402:	9b01      	ldr	r3, [sp, #4]
    4404:	2b00      	cmp	r3, #0
    4406:	d002      	beq.n	440e <Clock_Ip_ResetSimLpoSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimLpoSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimLpoSel_TrustedCall(Config);
    4408:	9801      	ldr	r0, [sp, #4]
    440a:	f000 f969 	bl	46e0 <Clock_Ip_ResetSimLpoSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    440e:	bf00      	nop
    4410:	b003      	add	sp, #12
    4412:	f85d fb04 	ldr.w	pc, [sp], #4

00004416 <Clock_Ip_SetSimLpoSel>:
static void Clock_Ip_SetSimLpoSel(Clock_Ip_SelectorConfigType const *Config)
{
    4416:	b500      	push	{lr}
    4418:	b083      	sub	sp, #12
    441a:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    441c:	9b01      	ldr	r3, [sp, #4]
    441e:	2b00      	cmp	r3, #0
    4420:	d002      	beq.n	4428 <Clock_Ip_SetSimLpoSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimLpoSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimLpoSel_TrustedCall(Config);
    4422:	9801      	ldr	r0, [sp, #4]
    4424:	f000 f978 	bl	4718 <Clock_Ip_SetSimLpoSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4428:	bf00      	nop
    442a:	b003      	add	sp, #12
    442c:	f85d fb04 	ldr.w	pc, [sp], #4

00004430 <Clock_Ip_ResetScgClkoutSel>:
#endif

#ifdef CLOCK_IP_SCG_CLKOUT_SEL
static void Clock_Ip_ResetScgClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    4430:	b500      	push	{lr}
    4432:	b083      	sub	sp, #12
    4434:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4436:	9b01      	ldr	r3, [sp, #4]
    4438:	2b00      	cmp	r3, #0
    443a:	d002      	beq.n	4442 <Clock_Ip_ResetScgClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetScgClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetScgClkoutSel_TrustedCall(Config);
    443c:	9801      	ldr	r0, [sp, #4]
    443e:	f000 f989 	bl	4754 <Clock_Ip_ResetScgClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4442:	bf00      	nop
    4444:	b003      	add	sp, #12
    4446:	f85d fb04 	ldr.w	pc, [sp], #4

0000444a <Clock_Ip_SetScgClkoutSel>:
static void Clock_Ip_SetScgClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    444a:	b500      	push	{lr}
    444c:	b083      	sub	sp, #12
    444e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4450:	9b01      	ldr	r3, [sp, #4]
    4452:	2b00      	cmp	r3, #0
    4454:	d002      	beq.n	445c <Clock_Ip_SetScgClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetScgClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetScgClkoutSel_TrustedCall(Config);
    4456:	9801      	ldr	r0, [sp, #4]
    4458:	f000 f998 	bl	478c <Clock_Ip_SetScgClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    445c:	bf00      	nop
    445e:	b003      	add	sp, #12
    4460:	f85d fb04 	ldr.w	pc, [sp], #4

00004464 <Clock_Ip_ResetSimFtmoptSel>:
#endif

#ifdef CLOCK_IP_SIM_FTMOPT_SEL
static void Clock_Ip_ResetSimFtmoptSel(Clock_Ip_SelectorConfigType const *Config)
{
    4464:	b500      	push	{lr}
    4466:	b083      	sub	sp, #12
    4468:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    446a:	9b01      	ldr	r3, [sp, #4]
    446c:	2b00      	cmp	r3, #0
    446e:	d002      	beq.n	4476 <Clock_Ip_ResetSimFtmoptSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimFtmoptSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimFtmoptSel_TrustedCall(Config);
    4470:	9801      	ldr	r0, [sp, #4]
    4472:	f000 f9a9 	bl	47c8 <Clock_Ip_ResetSimFtmoptSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4476:	bf00      	nop
    4478:	b003      	add	sp, #12
    447a:	f85d fb04 	ldr.w	pc, [sp], #4

0000447e <Clock_Ip_SetSimFtmoptSel>:
static void Clock_Ip_SetSimFtmoptSel(Clock_Ip_SelectorConfigType const *Config)
{
    447e:	b500      	push	{lr}
    4480:	b083      	sub	sp, #12
    4482:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4484:	9b01      	ldr	r3, [sp, #4]
    4486:	2b00      	cmp	r3, #0
    4488:	d002      	beq.n	4490 <Clock_Ip_SetSimFtmoptSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimFtmoptSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimFtmoptSel_TrustedCall(Config);
    448a:	9801      	ldr	r0, [sp, #4]
    448c:	f000 f9e6 	bl	485c <Clock_Ip_SetSimFtmoptSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4490:	bf00      	nop
    4492:	b003      	add	sp, #12
    4494:	f85d fb04 	ldr.w	pc, [sp], #4

00004498 <Clock_Ip_ResetSimClkoutSel>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_SEL
static void Clock_Ip_ResetSimClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    4498:	b500      	push	{lr}
    449a:	b083      	sub	sp, #12
    449c:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    449e:	9b01      	ldr	r3, [sp, #4]
    44a0:	2b00      	cmp	r3, #0
    44a2:	d002      	beq.n	44aa <Clock_Ip_ResetSimClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimClkoutSel_TrustedCall(Config);
    44a4:	9801      	ldr	r0, [sp, #4]
    44a6:	f000 fa25 	bl	48f4 <Clock_Ip_ResetSimClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    44aa:	bf00      	nop
    44ac:	b003      	add	sp, #12
    44ae:	f85d fb04 	ldr.w	pc, [sp], #4

000044b2 <Clock_Ip_SetSimClkoutSel>:
static void Clock_Ip_SetSimClkoutSel(Clock_Ip_SelectorConfigType const *Config)
{
    44b2:	b500      	push	{lr}
    44b4:	b083      	sub	sp, #12
    44b6:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    44b8:	9b01      	ldr	r3, [sp, #4]
    44ba:	2b00      	cmp	r3, #0
    44bc:	d002      	beq.n	44c4 <Clock_Ip_SetSimClkoutSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimClkoutSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimClkoutSel_TrustedCall(Config);
    44be:	9801      	ldr	r0, [sp, #4]
    44c0:	f000 fa2a 	bl	4918 <Clock_Ip_SetSimClkoutSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    44c4:	bf00      	nop
    44c6:	b003      	add	sp, #12
    44c8:	f85d fb04 	ldr.w	pc, [sp], #4

000044cc <Clock_Ip_ResetPccPcsSelect>:
#endif

#ifdef CLOCK_IP_PCC_PCS_SELECT
static void Clock_Ip_ResetPccPcsSelect(Clock_Ip_SelectorConfigType const *Config)
{
    44cc:	b500      	push	{lr}
    44ce:	b083      	sub	sp, #12
    44d0:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    44d2:	9b01      	ldr	r3, [sp, #4]
    44d4:	2b00      	cmp	r3, #0
    44d6:	d002      	beq.n	44de <Clock_Ip_ResetPccPcsSelect+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetPccPcsSelect_TrustedCall,(Config));
      #else
        Clock_Ip_ResetPccPcsSelect_TrustedCall(Config);
    44d8:	9801      	ldr	r0, [sp, #4]
    44da:	f000 fa3b 	bl	4954 <Clock_Ip_ResetPccPcsSelect_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    44de:	bf00      	nop
    44e0:	b003      	add	sp, #12
    44e2:	f85d fb04 	ldr.w	pc, [sp], #4

000044e6 <Clock_Ip_SetPccPcsSelect>:
static void Clock_Ip_SetPccPcsSelect(Clock_Ip_SelectorConfigType const *Config)
{
    44e6:	b500      	push	{lr}
    44e8:	b083      	sub	sp, #12
    44ea:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    44ec:	9b01      	ldr	r3, [sp, #4]
    44ee:	2b00      	cmp	r3, #0
    44f0:	d002      	beq.n	44f8 <Clock_Ip_SetPccPcsSelect+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetPccPcsSelect_TrustedCall,(Config));
      #else
        Clock_Ip_SetPccPcsSelect_TrustedCall(Config);
    44f2:	9801      	ldr	r0, [sp, #4]
    44f4:	f000 fa56 	bl	49a4 <Clock_Ip_SetPccPcsSelect_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    44f8:	bf00      	nop
    44fa:	b003      	add	sp, #12
    44fc:	f85d fb04 	ldr.w	pc, [sp], #4

00004500 <Clock_Ip_ResetSimTraceSel>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_SEL
static void Clock_Ip_ResetSimTraceSel(Clock_Ip_SelectorConfigType const *Config)
{
    4500:	b500      	push	{lr}
    4502:	b083      	sub	sp, #12
    4504:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4506:	9b01      	ldr	r3, [sp, #4]
    4508:	2b00      	cmp	r3, #0
    450a:	d002      	beq.n	4512 <Clock_Ip_ResetSimTraceSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_ResetSimTraceSel_TrustedCall,(Config));
      #else
        Clock_Ip_ResetSimTraceSel_TrustedCall(Config);
    450c:	9801      	ldr	r0, [sp, #4]
    450e:	f000 fa79 	bl	4a04 <Clock_Ip_ResetSimTraceSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    4512:	bf00      	nop
    4514:	b003      	add	sp, #12
    4516:	f85d fb04 	ldr.w	pc, [sp], #4

0000451a <Clock_Ip_SetSimTraceSel>:
static void Clock_Ip_SetSimTraceSel(Clock_Ip_SelectorConfigType const *Config)
{
    451a:	b500      	push	{lr}
    451c:	b083      	sub	sp, #12
    451e:	9001      	str	r0, [sp, #4]
    if (NULL_PTR != Config)
    4520:	9b01      	ldr	r3, [sp, #4]
    4522:	2b00      	cmp	r3, #0
    4524:	d002      	beq.n	452c <Clock_Ip_SetSimTraceSel+0x12>
    {
    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call1param(Clock_Ip_SetSimTraceSel_TrustedCall,(Config));
      #else
        Clock_Ip_SetSimTraceSel_TrustedCall(Config);
    4526:	9801      	ldr	r0, [sp, #4]
    4528:	f000 fa8a 	bl	4a40 <Clock_Ip_SetSimTraceSel_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */
    }
}
    452c:	bf00      	nop
    452e:	b003      	add	sp, #12
    4530:	f85d fb04 	ldr.w	pc, [sp], #4

00004534 <Clock_Ip_ResetScgRunSel_TrustedCall>:
/*==================================================================================================
*                                        GLOBAL FUNCTIONS
==================================================================================================*/
#ifdef CLOCK_IP_SCG_SCS_RUN_SEL
void Clock_Ip_ResetScgRunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4534:	b084      	sub	sp, #16
    4536:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4538:	4b0b      	ldr	r3, [pc, #44]	; (4568 <Clock_Ip_ResetScgRunSel_TrustedCall+0x34>)
    453a:	795b      	ldrb	r3, [r3, #5]
    453c:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SCG->RCCR;
    453e:	4b0b      	ldr	r3, [pc, #44]	; (456c <Clock_Ip_ResetScgRunSel_TrustedCall+0x38>)
    4540:	695b      	ldr	r3, [r3, #20]
    4542:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_RCCR_SCS_MASK;
    4544:	9b02      	ldr	r3, [sp, #8]
    4546:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    454a:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_RCCR_SCS(SelectorValue);
    454c:	9b03      	ldr	r3, [sp, #12]
    454e:	061b      	lsls	r3, r3, #24
    4550:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    4554:	9a02      	ldr	r2, [sp, #8]
    4556:	4313      	orrs	r3, r2
    4558:	9302      	str	r3, [sp, #8]
    IP_SCG->RCCR = RegValue;
    455a:	4a04      	ldr	r2, [pc, #16]	; (456c <Clock_Ip_ResetScgRunSel_TrustedCall+0x38>)
    455c:	9b02      	ldr	r3, [sp, #8]
    455e:	6153      	str	r3, [r2, #20]
}
    4560:	bf00      	nop
    4562:	b004      	add	sp, #16
    4564:	4770      	bx	lr
    4566:	bf00      	nop
    4568:	00015838 	.word	0x00015838
    456c:	40064000 	.word	0x40064000

00004570 <Clock_Ip_SetScgRunSel_TrustedCall>:

void Clock_Ip_SetScgRunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4570:	b084      	sub	sp, #16
    4572:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4574:	9b01      	ldr	r3, [sp, #4]
    4576:	685b      	ldr	r3, [r3, #4]
    4578:	4a0b      	ldr	r2, [pc, #44]	; (45a8 <Clock_Ip_SetScgRunSel_TrustedCall+0x38>)
    457a:	5cd3      	ldrb	r3, [r2, r3]
    457c:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->RCCR;
    457e:	4b0b      	ldr	r3, [pc, #44]	; (45ac <Clock_Ip_SetScgRunSel_TrustedCall+0x3c>)
    4580:	695b      	ldr	r3, [r3, #20]
    4582:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_RCCR_SCS_MASK;
    4584:	9b02      	ldr	r3, [sp, #8]
    4586:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    458a:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_RCCR_SCS(SelectorValue);
    458c:	9b03      	ldr	r3, [sp, #12]
    458e:	061b      	lsls	r3, r3, #24
    4590:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    4594:	9a02      	ldr	r2, [sp, #8]
    4596:	4313      	orrs	r3, r2
    4598:	9302      	str	r3, [sp, #8]
    IP_SCG->RCCR = RegValue;
    459a:	4a04      	ldr	r2, [pc, #16]	; (45ac <Clock_Ip_SetScgRunSel_TrustedCall+0x3c>)
    459c:	9b02      	ldr	r3, [sp, #8]
    459e:	6153      	str	r3, [r2, #20]
}
    45a0:	bf00      	nop
    45a2:	b004      	add	sp, #16
    45a4:	4770      	bx	lr
    45a6:	bf00      	nop
    45a8:	00015838 	.word	0x00015838
    45ac:	40064000 	.word	0x40064000

000045b0 <Clock_Ip_SetScgVlprSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_SCS_VLPR_SEL

void Clock_Ip_SetScgVlprSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    45b0:	b084      	sub	sp, #16
    45b2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    45b4:	9b01      	ldr	r3, [sp, #4]
    45b6:	685b      	ldr	r3, [r3, #4]
    45b8:	4a0b      	ldr	r2, [pc, #44]	; (45e8 <Clock_Ip_SetScgVlprSel_TrustedCall+0x38>)
    45ba:	5cd3      	ldrb	r3, [r2, r3]
    45bc:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->VCCR;
    45be:	4b0b      	ldr	r3, [pc, #44]	; (45ec <Clock_Ip_SetScgVlprSel_TrustedCall+0x3c>)
    45c0:	699b      	ldr	r3, [r3, #24]
    45c2:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_VCCR_SCS_MASK;
    45c4:	9b02      	ldr	r3, [sp, #8]
    45c6:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    45ca:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_VCCR_SCS(SelectorValue);
    45cc:	9b03      	ldr	r3, [sp, #12]
    45ce:	061b      	lsls	r3, r3, #24
    45d0:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    45d4:	9a02      	ldr	r2, [sp, #8]
    45d6:	4313      	orrs	r3, r2
    45d8:	9302      	str	r3, [sp, #8]
    IP_SCG->VCCR = RegValue;
    45da:	4a04      	ldr	r2, [pc, #16]	; (45ec <Clock_Ip_SetScgVlprSel_TrustedCall+0x3c>)
    45dc:	9b02      	ldr	r3, [sp, #8]
    45de:	6193      	str	r3, [r2, #24]
}
    45e0:	bf00      	nop
    45e2:	b004      	add	sp, #16
    45e4:	4770      	bx	lr
    45e6:	bf00      	nop
    45e8:	00015838 	.word	0x00015838
    45ec:	40064000 	.word	0x40064000

000045f0 <Clock_Ip_ResetScgHsrunSel_TrustedCall>:

#endif

#ifdef CLOCK_IP_SCG_SCS_HSRUN_SEL
void Clock_Ip_ResetScgHsrunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    45f0:	b084      	sub	sp, #16
    45f2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    45f4:	4b0b      	ldr	r3, [pc, #44]	; (4624 <Clock_Ip_ResetScgHsrunSel_TrustedCall+0x34>)
    45f6:	795b      	ldrb	r3, [r3, #5]
    45f8:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SCG->HCCR;
    45fa:	4b0b      	ldr	r3, [pc, #44]	; (4628 <Clock_Ip_ResetScgHsrunSel_TrustedCall+0x38>)
    45fc:	69db      	ldr	r3, [r3, #28]
    45fe:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_HCCR_SCS_MASK;
    4600:	9b02      	ldr	r3, [sp, #8]
    4602:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    4606:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_HCCR_SCS(SelectorValue);
    4608:	9b03      	ldr	r3, [sp, #12]
    460a:	061b      	lsls	r3, r3, #24
    460c:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    4610:	9a02      	ldr	r2, [sp, #8]
    4612:	4313      	orrs	r3, r2
    4614:	9302      	str	r3, [sp, #8]
    IP_SCG->HCCR = RegValue;
    4616:	4a04      	ldr	r2, [pc, #16]	; (4628 <Clock_Ip_ResetScgHsrunSel_TrustedCall+0x38>)
    4618:	9b02      	ldr	r3, [sp, #8]
    461a:	61d3      	str	r3, [r2, #28]
}
    461c:	bf00      	nop
    461e:	b004      	add	sp, #16
    4620:	4770      	bx	lr
    4622:	bf00      	nop
    4624:	00015838 	.word	0x00015838
    4628:	40064000 	.word	0x40064000

0000462c <Clock_Ip_SetScgHsrunSel_TrustedCall>:
void Clock_Ip_SetScgHsrunSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    462c:	b084      	sub	sp, #16
    462e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4630:	9b01      	ldr	r3, [sp, #4]
    4632:	685b      	ldr	r3, [r3, #4]
    4634:	4a0b      	ldr	r2, [pc, #44]	; (4664 <Clock_Ip_SetScgHsrunSel_TrustedCall+0x38>)
    4636:	5cd3      	ldrb	r3, [r2, r3]
    4638:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->HCCR;
    463a:	4b0b      	ldr	r3, [pc, #44]	; (4668 <Clock_Ip_SetScgHsrunSel_TrustedCall+0x3c>)
    463c:	69db      	ldr	r3, [r3, #28]
    463e:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_HCCR_SCS_MASK;
    4640:	9b02      	ldr	r3, [sp, #8]
    4642:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    4646:	9302      	str	r3, [sp, #8]
    RegValue |= SCG_HCCR_SCS(SelectorValue);
    4648:	9b03      	ldr	r3, [sp, #12]
    464a:	061b      	lsls	r3, r3, #24
    464c:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    4650:	9a02      	ldr	r2, [sp, #8]
    4652:	4313      	orrs	r3, r2
    4654:	9302      	str	r3, [sp, #8]
    IP_SCG->HCCR = RegValue;
    4656:	4a04      	ldr	r2, [pc, #16]	; (4668 <Clock_Ip_SetScgHsrunSel_TrustedCall+0x3c>)
    4658:	9b02      	ldr	r3, [sp, #8]
    465a:	61d3      	str	r3, [r2, #28]
}
    465c:	bf00      	nop
    465e:	b004      	add	sp, #16
    4660:	4770      	bx	lr
    4662:	bf00      	nop
    4664:	00015838 	.word	0x00015838
    4668:	40064000 	.word	0x40064000

0000466c <Clock_Ip_ResetSimRtcSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_RTC_SEL
void Clock_Ip_ResetSimRtcSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    466c:	b084      	sub	sp, #16
    466e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[SOSCDIV1_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4670:	4b0a      	ldr	r3, [pc, #40]	; (469c <Clock_Ip_ResetSimRtcSel_TrustedCall+0x30>)
    4672:	7b9b      	ldrb	r3, [r3, #14]
    4674:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SIM->LPOCLKS;
    4676:	4b0a      	ldr	r3, [pc, #40]	; (46a0 <Clock_Ip_ResetSimRtcSel_TrustedCall+0x34>)
    4678:	691b      	ldr	r3, [r3, #16]
    467a:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_RTCCLKSEL_MASK;
    467c:	9b02      	ldr	r3, [sp, #8]
    467e:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    4682:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_RTCCLKSEL_SHIFT);
    4684:	9b03      	ldr	r3, [sp, #12]
    4686:	011b      	lsls	r3, r3, #4
    4688:	9a02      	ldr	r2, [sp, #8]
    468a:	4313      	orrs	r3, r2
    468c:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    468e:	4a04      	ldr	r2, [pc, #16]	; (46a0 <Clock_Ip_ResetSimRtcSel_TrustedCall+0x34>)
    4690:	9b02      	ldr	r3, [sp, #8]
    4692:	6113      	str	r3, [r2, #16]
}
    4694:	bf00      	nop
    4696:	b004      	add	sp, #16
    4698:	4770      	bx	lr
    469a:	bf00      	nop
    469c:	000157e0 	.word	0x000157e0
    46a0:	40048000 	.word	0x40048000

000046a4 <Clock_Ip_SetSimRtcSel_TrustedCall>:

void Clock_Ip_SetSimRtcSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    46a4:	b084      	sub	sp, #16
    46a6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    46a8:	9b01      	ldr	r3, [sp, #4]
    46aa:	685b      	ldr	r3, [r3, #4]
    46ac:	4a0a      	ldr	r2, [pc, #40]	; (46d8 <Clock_Ip_SetSimRtcSel_TrustedCall+0x34>)
    46ae:	5cd3      	ldrb	r3, [r2, r3]
    46b0:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->LPOCLKS;
    46b2:	4b0a      	ldr	r3, [pc, #40]	; (46dc <Clock_Ip_SetSimRtcSel_TrustedCall+0x38>)
    46b4:	691b      	ldr	r3, [r3, #16]
    46b6:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_RTCCLKSEL_MASK;
    46b8:	9b02      	ldr	r3, [sp, #8]
    46ba:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    46be:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_RTCCLKSEL_SHIFT);
    46c0:	9b03      	ldr	r3, [sp, #12]
    46c2:	011b      	lsls	r3, r3, #4
    46c4:	9a02      	ldr	r2, [sp, #8]
    46c6:	4313      	orrs	r3, r2
    46c8:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    46ca:	4a04      	ldr	r2, [pc, #16]	; (46dc <Clock_Ip_SetSimRtcSel_TrustedCall+0x38>)
    46cc:	9b02      	ldr	r3, [sp, #8]
    46ce:	6113      	str	r3, [r2, #16]
}
    46d0:	bf00      	nop
    46d2:	b004      	add	sp, #16
    46d4:	4770      	bx	lr
    46d6:	bf00      	nop
    46d8:	000157e0 	.word	0x000157e0
    46dc:	40048000 	.word	0x40048000

000046e0 <Clock_Ip_ResetSimLpoSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_LPO_SEL
void Clock_Ip_ResetSimLpoSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    46e0:	b084      	sub	sp, #16
    46e2:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntrySIMHardwareValue[LPO_128K_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    46e4:	4b0a      	ldr	r3, [pc, #40]	; (4710 <Clock_Ip_ResetSimLpoSel_TrustedCall+0x30>)
    46e6:	785b      	ldrb	r3, [r3, #1]
    46e8:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SIM->LPOCLKS;
    46ea:	4b0a      	ldr	r3, [pc, #40]	; (4714 <Clock_Ip_ResetSimLpoSel_TrustedCall+0x34>)
    46ec:	691b      	ldr	r3, [r3, #16]
    46ee:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_LPOCLKSEL_MASK;
    46f0:	9b02      	ldr	r3, [sp, #8]
    46f2:	f023 030c 	bic.w	r3, r3, #12
    46f6:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_LPOCLKSEL_SHIFT);
    46f8:	9b03      	ldr	r3, [sp, #12]
    46fa:	009b      	lsls	r3, r3, #2
    46fc:	9a02      	ldr	r2, [sp, #8]
    46fe:	4313      	orrs	r3, r2
    4700:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    4702:	4a04      	ldr	r2, [pc, #16]	; (4714 <Clock_Ip_ResetSimLpoSel_TrustedCall+0x34>)
    4704:	9b02      	ldr	r3, [sp, #8]
    4706:	6113      	str	r3, [r2, #16]
}
    4708:	bf00      	nop
    470a:	b004      	add	sp, #16
    470c:	4770      	bx	lr
    470e:	bf00      	nop
    4710:	00015898 	.word	0x00015898
    4714:	40048000 	.word	0x40048000

00004718 <Clock_Ip_SetSimLpoSel_TrustedCall>:
void Clock_Ip_SetSimLpoSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4718:	b084      	sub	sp, #16
    471a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* LPO_CLK selector mapped to Clock_Ip_au8SelectorEntrySIMHardwareValue */
    uint32 SelectorValue = Clock_Ip_au8SelectorEntrySIMHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    471c:	9b01      	ldr	r3, [sp, #4]
    471e:	685b      	ldr	r3, [r3, #4]
    4720:	4a0a      	ldr	r2, [pc, #40]	; (474c <Clock_Ip_SetSimLpoSel_TrustedCall+0x34>)
    4722:	5cd3      	ldrb	r3, [r2, r3]
    4724:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SIM->LPOCLKS;
    4726:	4b0a      	ldr	r3, [pc, #40]	; (4750 <Clock_Ip_SetSimLpoSel_TrustedCall+0x38>)
    4728:	691b      	ldr	r3, [r3, #16]
    472a:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_LPOCLKS_LPOCLKSEL_MASK;
    472c:	9b02      	ldr	r3, [sp, #8]
    472e:	f023 030c 	bic.w	r3, r3, #12
    4732:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_LPOCLKS_LPOCLKSEL_SHIFT);
    4734:	9b03      	ldr	r3, [sp, #12]
    4736:	009b      	lsls	r3, r3, #2
    4738:	9a02      	ldr	r2, [sp, #8]
    473a:	4313      	orrs	r3, r2
    473c:	9302      	str	r3, [sp, #8]
    IP_SIM->LPOCLKS = RegValue;
    473e:	4a04      	ldr	r2, [pc, #16]	; (4750 <Clock_Ip_SetSimLpoSel_TrustedCall+0x38>)
    4740:	9b02      	ldr	r3, [sp, #8]
    4742:	6113      	str	r3, [r2, #16]
}
    4744:	bf00      	nop
    4746:	b004      	add	sp, #16
    4748:	4770      	bx	lr
    474a:	bf00      	nop
    474c:	00015898 	.word	0x00015898
    4750:	40048000 	.word	0x40048000

00004754 <Clock_Ip_ResetScgClkoutSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SCG_CLKOUT_SEL
void Clock_Ip_ResetScgClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4754:	b084      	sub	sp, #16
    4756:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* LPO_CLK selector mapped to Clock_Ip_au8SelectorEntryScsHardwareValue */
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4758:	4b0a      	ldr	r3, [pc, #40]	; (4784 <Clock_Ip_ResetScgClkoutSel_TrustedCall+0x30>)
    475a:	795b      	ldrb	r3, [r3, #5]
    475c:	9303      	str	r3, [sp, #12]

    (void)Config;

    RegValue = IP_SCG->CLKOUTCNFG;
    475e:	4b0a      	ldr	r3, [pc, #40]	; (4788 <Clock_Ip_ResetScgClkoutSel_TrustedCall+0x34>)
    4760:	6a1b      	ldr	r3, [r3, #32]
    4762:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_CLKOUTCNFG_CLKOUTSEL_MASK;
    4764:	9b02      	ldr	r3, [sp, #8]
    4766:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    476a:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SCG_CLKOUTCNFG_CLKOUTSEL_SHIFT);
    476c:	9b03      	ldr	r3, [sp, #12]
    476e:	061b      	lsls	r3, r3, #24
    4770:	9a02      	ldr	r2, [sp, #8]
    4772:	4313      	orrs	r3, r2
    4774:	9302      	str	r3, [sp, #8]
    IP_SCG->CLKOUTCNFG = RegValue;
    4776:	4a04      	ldr	r2, [pc, #16]	; (4788 <Clock_Ip_ResetScgClkoutSel_TrustedCall+0x34>)
    4778:	9b02      	ldr	r3, [sp, #8]
    477a:	6213      	str	r3, [r2, #32]
}
    477c:	bf00      	nop
    477e:	b004      	add	sp, #16
    4780:	4770      	bx	lr
    4782:	bf00      	nop
    4784:	00015838 	.word	0x00015838
    4788:	40064000 	.word	0x40064000

0000478c <Clock_Ip_SetScgClkoutSel_TrustedCall>:
void Clock_Ip_SetScgClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    478c:	b084      	sub	sp, #16
    478e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryScsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4790:	9b01      	ldr	r3, [sp, #4]
    4792:	685b      	ldr	r3, [r3, #4]
    4794:	4a0a      	ldr	r2, [pc, #40]	; (47c0 <Clock_Ip_SetScgClkoutSel_TrustedCall+0x34>)
    4796:	5cd3      	ldrb	r3, [r2, r3]
    4798:	9303      	str	r3, [sp, #12]

    RegValue = IP_SCG->CLKOUTCNFG;
    479a:	4b0a      	ldr	r3, [pc, #40]	; (47c4 <Clock_Ip_SetScgClkoutSel_TrustedCall+0x38>)
    479c:	6a1b      	ldr	r3, [r3, #32]
    479e:	9302      	str	r3, [sp, #8]
    RegValue &= ~SCG_CLKOUTCNFG_CLKOUTSEL_MASK;
    47a0:	9b02      	ldr	r3, [sp, #8]
    47a2:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    47a6:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SCG_CLKOUTCNFG_CLKOUTSEL_SHIFT);
    47a8:	9b03      	ldr	r3, [sp, #12]
    47aa:	061b      	lsls	r3, r3, #24
    47ac:	9a02      	ldr	r2, [sp, #8]
    47ae:	4313      	orrs	r3, r2
    47b0:	9302      	str	r3, [sp, #8]
    IP_SCG->CLKOUTCNFG = RegValue;
    47b2:	4a04      	ldr	r2, [pc, #16]	; (47c4 <Clock_Ip_SetScgClkoutSel_TrustedCall+0x38>)
    47b4:	9b02      	ldr	r3, [sp, #8]
    47b6:	6213      	str	r3, [r2, #32]
}
    47b8:	bf00      	nop
    47ba:	b004      	add	sp, #16
    47bc:	4770      	bx	lr
    47be:	bf00      	nop
    47c0:	00015838 	.word	0x00015838
    47c4:	40064000 	.word	0x40064000

000047c8 <Clock_Ip_ResetSimFtmoptSel_TrustedCall>:
#define SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(x)  (24U + ((x) << 1U))
#define SIM_FTMOPT0_FTM_0_3_CLKSEL_MASK(x)   ((uint32)3U << SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(x))
#define SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(x)  (16U + (((x) - 4U) << 1U))
#define SIM_FTMOPT0_FTM_4_7_CLKSEL_MASK(x)   ((uint32)3U << SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(x))
void Clock_Ip_ResetSimFtmoptSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    47c8:	b086      	sub	sp, #24
    47ca:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[FIRC_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    47cc:	4b20      	ldr	r3, [pc, #128]	; (4850 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x88>)
    47ce:	795b      	ldrb	r3, [r3, #5]
    47d0:	9304      	str	r3, [sp, #16]
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    47d2:	9b01      	ldr	r3, [sp, #4]
    47d4:	681a      	ldr	r2, [r3, #0]
    47d6:	491f      	ldr	r1, [pc, #124]	; (4854 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x8c>)
    47d8:	4613      	mov	r3, r2
    47da:	00db      	lsls	r3, r3, #3
    47dc:	4413      	add	r3, r2
    47de:	440b      	add	r3, r1
    47e0:	781b      	ldrb	r3, [r3, #0]
    47e2:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->FTMOPT0;
    47e4:	4b1c      	ldr	r3, [pc, #112]	; (4858 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x90>)
    47e6:	68db      	ldr	r3, [r3, #12]
    47e8:	9305      	str	r3, [sp, #20]
    if(Instance < 4U)
    47ea:	9b03      	ldr	r3, [sp, #12]
    47ec:	2b03      	cmp	r3, #3
    47ee:	d813      	bhi.n	4818 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x50>
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_0_3_CLKSEL_MASK(Instance));
    47f0:	9b03      	ldr	r3, [sp, #12]
    47f2:	005b      	lsls	r3, r3, #1
    47f4:	3318      	adds	r3, #24
    47f6:	2203      	movs	r2, #3
    47f8:	fa02 f303 	lsl.w	r3, r2, r3
    47fc:	43db      	mvns	r3, r3
    47fe:	9a05      	ldr	r2, [sp, #20]
    4800:	4013      	ands	r3, r2
    4802:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(Instance));
    4804:	9b03      	ldr	r3, [sp, #12]
    4806:	005b      	lsls	r3, r3, #1
    4808:	3318      	adds	r3, #24
    480a:	9a04      	ldr	r2, [sp, #16]
    480c:	fa02 f303 	lsl.w	r3, r2, r3
    4810:	9a05      	ldr	r2, [sp, #20]
    4812:	4313      	orrs	r3, r2
    4814:	9305      	str	r3, [sp, #20]
    4816:	e014      	b.n	4842 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x7a>
    }
    else
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_4_7_CLKSEL_MASK(Instance));
    4818:	9b03      	ldr	r3, [sp, #12]
    481a:	3b04      	subs	r3, #4
    481c:	005b      	lsls	r3, r3, #1
    481e:	3310      	adds	r3, #16
    4820:	2203      	movs	r2, #3
    4822:	fa02 f303 	lsl.w	r3, r2, r3
    4826:	43db      	mvns	r3, r3
    4828:	9a05      	ldr	r2, [sp, #20]
    482a:	4013      	ands	r3, r2
    482c:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(Instance));
    482e:	9b03      	ldr	r3, [sp, #12]
    4830:	3b04      	subs	r3, #4
    4832:	005b      	lsls	r3, r3, #1
    4834:	3310      	adds	r3, #16
    4836:	9a04      	ldr	r2, [sp, #16]
    4838:	fa02 f303 	lsl.w	r3, r2, r3
    483c:	9a05      	ldr	r2, [sp, #20]
    483e:	4313      	orrs	r3, r2
    4840:	9305      	str	r3, [sp, #20]
    }

    IP_SIM->FTMOPT0 = RegValue;
    4842:	4a05      	ldr	r2, [pc, #20]	; (4858 <Clock_Ip_ResetSimFtmoptSel_TrustedCall+0x90>)
    4844:	9b05      	ldr	r3, [sp, #20]
    4846:	60d3      	str	r3, [r2, #12]
}
    4848:	bf00      	nop
    484a:	b006      	add	sp, #24
    484c:	4770      	bx	lr
    484e:	bf00      	nop
    4850:	000157e0 	.word	0x000157e0
    4854:	000154d0 	.word	0x000154d0
    4858:	40048000 	.word	0x40048000

0000485c <Clock_Ip_SetSimFtmoptSel_TrustedCall>:
void Clock_Ip_SetSimFtmoptSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    485c:	b086      	sub	sp, #24
    485e:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4860:	9b01      	ldr	r3, [sp, #4]
    4862:	685b      	ldr	r3, [r3, #4]
    4864:	4a20      	ldr	r2, [pc, #128]	; (48e8 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x8c>)
    4866:	5cd3      	ldrb	r3, [r2, r3]
    4868:	9304      	str	r3, [sp, #16]
    uint32 Instance      = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_MODULE_INSTANCE];
    486a:	9b01      	ldr	r3, [sp, #4]
    486c:	681a      	ldr	r2, [r3, #0]
    486e:	491f      	ldr	r1, [pc, #124]	; (48ec <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x90>)
    4870:	4613      	mov	r3, r2
    4872:	00db      	lsls	r3, r3, #3
    4874:	4413      	add	r3, r2
    4876:	440b      	add	r3, r1
    4878:	781b      	ldrb	r3, [r3, #0]
    487a:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->FTMOPT0;
    487c:	4b1c      	ldr	r3, [pc, #112]	; (48f0 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x94>)
    487e:	68db      	ldr	r3, [r3, #12]
    4880:	9305      	str	r3, [sp, #20]
    if(Instance < 4U)
    4882:	9b03      	ldr	r3, [sp, #12]
    4884:	2b03      	cmp	r3, #3
    4886:	d813      	bhi.n	48b0 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x54>
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_0_3_CLKSEL_MASK(Instance));
    4888:	9b03      	ldr	r3, [sp, #12]
    488a:	005b      	lsls	r3, r3, #1
    488c:	3318      	adds	r3, #24
    488e:	2203      	movs	r2, #3
    4890:	fa02 f303 	lsl.w	r3, r2, r3
    4894:	43db      	mvns	r3, r3
    4896:	9a05      	ldr	r2, [sp, #20]
    4898:	4013      	ands	r3, r2
    489a:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_0_3_CLKSEL_SHIFT(Instance));
    489c:	9b03      	ldr	r3, [sp, #12]
    489e:	005b      	lsls	r3, r3, #1
    48a0:	3318      	adds	r3, #24
    48a2:	9a04      	ldr	r2, [sp, #16]
    48a4:	fa02 f303 	lsl.w	r3, r2, r3
    48a8:	9a05      	ldr	r2, [sp, #20]
    48aa:	4313      	orrs	r3, r2
    48ac:	9305      	str	r3, [sp, #20]
    48ae:	e014      	b.n	48da <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x7e>
    }
    else
    {
        RegValue &= ~(SIM_FTMOPT0_FTM_4_7_CLKSEL_MASK(Instance));
    48b0:	9b03      	ldr	r3, [sp, #12]
    48b2:	3b04      	subs	r3, #4
    48b4:	005b      	lsls	r3, r3, #1
    48b6:	3310      	adds	r3, #16
    48b8:	2203      	movs	r2, #3
    48ba:	fa02 f303 	lsl.w	r3, r2, r3
    48be:	43db      	mvns	r3, r3
    48c0:	9a05      	ldr	r2, [sp, #20]
    48c2:	4013      	ands	r3, r2
    48c4:	9305      	str	r3, [sp, #20]
        RegValue |= (SelectorValue << SIM_FTMOPT0_FTM_4_7_CLKSEL_SHIFT(Instance));
    48c6:	9b03      	ldr	r3, [sp, #12]
    48c8:	3b04      	subs	r3, #4
    48ca:	005b      	lsls	r3, r3, #1
    48cc:	3310      	adds	r3, #16
    48ce:	9a04      	ldr	r2, [sp, #16]
    48d0:	fa02 f303 	lsl.w	r3, r2, r3
    48d4:	9a05      	ldr	r2, [sp, #20]
    48d6:	4313      	orrs	r3, r2
    48d8:	9305      	str	r3, [sp, #20]
    }

    IP_SIM->FTMOPT0 = RegValue;
    48da:	4a05      	ldr	r2, [pc, #20]	; (48f0 <Clock_Ip_SetSimFtmoptSel_TrustedCall+0x94>)
    48dc:	9b05      	ldr	r3, [sp, #20]
    48de:	60d3      	str	r3, [r2, #12]
}
    48e0:	bf00      	nop
    48e2:	b006      	add	sp, #24
    48e4:	4770      	bx	lr
    48e6:	bf00      	nop
    48e8:	000157e0 	.word	0x000157e0
    48ec:	000154d0 	.word	0x000154d0
    48f0:	40048000 	.word	0x40048000

000048f4 <Clock_Ip_ResetSimClkoutSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_CLKOUT_SEL
/* Clear CLKOUTSEL and CLKOUTEN bit field in SIM_CHIPCTL register  */
void Clock_Ip_ResetSimClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    48f4:	b084      	sub	sp, #16
    48f6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;

    (void)Config;

    RegValue = IP_SIM->CHIPCTL;
    48f8:	4b06      	ldr	r3, [pc, #24]	; (4914 <Clock_Ip_ResetSimClkoutSel_TrustedCall+0x20>)
    48fa:	685b      	ldr	r3, [r3, #4]
    48fc:	9303      	str	r3, [sp, #12]
    RegValue &= ~(SIM_CHIPCTL_CLKOUTSEL_MASK | SIM_CHIPCTL_CLKOUTEN_MASK);
    48fe:	9b03      	ldr	r3, [sp, #12]
    4900:	f423 630f 	bic.w	r3, r3, #2288	; 0x8f0
    4904:	9303      	str	r3, [sp, #12]
    IP_SIM->CHIPCTL = RegValue;
    4906:	4a03      	ldr	r2, [pc, #12]	; (4914 <Clock_Ip_ResetSimClkoutSel_TrustedCall+0x20>)
    4908:	9b03      	ldr	r3, [sp, #12]
    490a:	6053      	str	r3, [r2, #4]
}
    490c:	bf00      	nop
    490e:	b004      	add	sp, #16
    4910:	4770      	bx	lr
    4912:	bf00      	nop
    4914:	40048000 	.word	0x40048000

00004918 <Clock_Ip_SetSimClkoutSel_TrustedCall>:
void Clock_Ip_SetSimClkoutSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4918:	b084      	sub	sp, #16
    491a:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    491c:	9b01      	ldr	r3, [sp, #4]
    491e:	685b      	ldr	r3, [r3, #4]
    4920:	4a0a      	ldr	r2, [pc, #40]	; (494c <Clock_Ip_SetSimClkoutSel_TrustedCall+0x34>)
    4922:	5cd3      	ldrb	r3, [r2, r3]
    4924:	9303      	str	r3, [sp, #12]

    RegValue = IP_SIM->CHIPCTL;
    4926:	4b0a      	ldr	r3, [pc, #40]	; (4950 <Clock_Ip_SetSimClkoutSel_TrustedCall+0x38>)
    4928:	685b      	ldr	r3, [r3, #4]
    492a:	9302      	str	r3, [sp, #8]
    RegValue &= ~SIM_CHIPCTL_CLKOUTSEL_MASK;
    492c:	9b02      	ldr	r3, [sp, #8]
    492e:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
    4932:	9302      	str	r3, [sp, #8]
    RegValue |= (SelectorValue << SIM_CHIPCTL_CLKOUTSEL_SHIFT);
    4934:	9b03      	ldr	r3, [sp, #12]
    4936:	011b      	lsls	r3, r3, #4
    4938:	9a02      	ldr	r2, [sp, #8]
    493a:	4313      	orrs	r3, r2
    493c:	9302      	str	r3, [sp, #8]
    IP_SIM->CHIPCTL = RegValue;
    493e:	4a04      	ldr	r2, [pc, #16]	; (4950 <Clock_Ip_SetSimClkoutSel_TrustedCall+0x38>)
    4940:	9b02      	ldr	r3, [sp, #8]
    4942:	6053      	str	r3, [r2, #4]
}
    4944:	bf00      	nop
    4946:	b004      	add	sp, #16
    4948:	4770      	bx	lr
    494a:	bf00      	nop
    494c:	000157e0 	.word	0x000157e0
    4950:	40048000 	.word	0x40048000

00004954 <Clock_Ip_ResetPccPcsSelect_TrustedCall>:
#ifdef CLOCK_IP_PCC_PCS_SELECT
/**
* @brief            This function will reset writable bit fields of PCC register
*/
void Clock_Ip_ResetPccPcsSelect_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4954:	b084      	sub	sp, #16
    4956:	9001      	str	r0, [sp, #4]
    uint32 PccIndex = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_SELECTOR_INDEX];
    4958:	9b01      	ldr	r3, [sp, #4]
    495a:	681a      	ldr	r2, [r3, #0]
    495c:	490f      	ldr	r1, [pc, #60]	; (499c <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x48>)
    495e:	4613      	mov	r3, r2
    4960:	00db      	lsls	r3, r3, #3
    4962:	4413      	add	r3, r2
    4964:	440b      	add	r3, r1
    4966:	3304      	adds	r3, #4
    4968:	781b      	ldrb	r3, [r3, #0]
    496a:	9303      	str	r3, [sp, #12]

    /* Disable CGC before set PCS */
    IP_PCC->PCCn[PccIndex] &= ~(PCC_PCCn_CGC_MASK);
    496c:	4a0c      	ldr	r2, [pc, #48]	; (49a0 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    496e:	9b03      	ldr	r3, [sp, #12]
    4970:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    4974:	490a      	ldr	r1, [pc, #40]	; (49a0 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    4976:	f023 4280 	bic.w	r2, r3, #1073741824	; 0x40000000
    497a:	9b03      	ldr	r3, [sp, #12]
    497c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    IP_PCC->PCCn[PccIndex] &= ~(PCC_PCCn_PCS_MASK);
    4980:	4a07      	ldr	r2, [pc, #28]	; (49a0 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    4982:	9b03      	ldr	r3, [sp, #12]
    4984:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    4988:	4905      	ldr	r1, [pc, #20]	; (49a0 <Clock_Ip_ResetPccPcsSelect_TrustedCall+0x4c>)
    498a:	f023 62e0 	bic.w	r2, r3, #117440512	; 0x7000000
    498e:	9b03      	ldr	r3, [sp, #12]
    4990:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    4994:	bf00      	nop
    4996:	b004      	add	sp, #16
    4998:	4770      	bx	lr
    499a:	bf00      	nop
    499c:	000154d0 	.word	0x000154d0
    49a0:	40065000 	.word	0x40065000

000049a4 <Clock_Ip_SetPccPcsSelect_TrustedCall>:
void Clock_Ip_SetPccPcsSelect_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    49a4:	b086      	sub	sp, #24
    49a6:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    uint32 PccIndex = Clock_Ip_au8ClockFeatures[Config->Name][CLOCK_IP_SELECTOR_INDEX];
    49a8:	9b01      	ldr	r3, [sp, #4]
    49aa:	681a      	ldr	r2, [r3, #0]
    49ac:	4912      	ldr	r1, [pc, #72]	; (49f8 <Clock_Ip_SetPccPcsSelect_TrustedCall+0x54>)
    49ae:	4613      	mov	r3, r2
    49b0:	00db      	lsls	r3, r3, #3
    49b2:	4413      	add	r3, r2
    49b4:	440b      	add	r3, r1
    49b6:	3304      	adds	r3, #4
    49b8:	781b      	ldrb	r3, [r3, #0]
    49ba:	9305      	str	r3, [sp, #20]
    uint32 SelectorValue = Clock_Ip_au8SelectorEntryPcsHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    49bc:	9b01      	ldr	r3, [sp, #4]
    49be:	685b      	ldr	r3, [r3, #4]
    49c0:	4a0e      	ldr	r2, [pc, #56]	; (49fc <Clock_Ip_SetPccPcsSelect_TrustedCall+0x58>)
    49c2:	5cd3      	ldrb	r3, [r2, r3]
    49c4:	9304      	str	r3, [sp, #16]

    RegValue = IP_PCC->PCCn[PccIndex];
    49c6:	4a0e      	ldr	r2, [pc, #56]	; (4a00 <Clock_Ip_SetPccPcsSelect_TrustedCall+0x5c>)
    49c8:	9b05      	ldr	r3, [sp, #20]
    49ca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    49ce:	9303      	str	r3, [sp, #12]
    RegValue &= ~PCC_PCCn_PCS_MASK;
    49d0:	9b03      	ldr	r3, [sp, #12]
    49d2:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
    49d6:	9303      	str	r3, [sp, #12]
    RegValue |= PCC_PCCn_PCS(SelectorValue);
    49d8:	9b04      	ldr	r3, [sp, #16]
    49da:	061b      	lsls	r3, r3, #24
    49dc:	f003 63e0 	and.w	r3, r3, #117440512	; 0x7000000
    49e0:	9a03      	ldr	r2, [sp, #12]
    49e2:	4313      	orrs	r3, r2
    49e4:	9303      	str	r3, [sp, #12]
    IP_PCC->PCCn[PccIndex] = RegValue;
    49e6:	4906      	ldr	r1, [pc, #24]	; (4a00 <Clock_Ip_SetPccPcsSelect_TrustedCall+0x5c>)
    49e8:	9b05      	ldr	r3, [sp, #20]
    49ea:	9a03      	ldr	r2, [sp, #12]
    49ec:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    49f0:	bf00      	nop
    49f2:	b006      	add	sp, #24
    49f4:	4770      	bx	lr
    49f6:	bf00      	nop
    49f8:	000154d0 	.word	0x000154d0
    49fc:	00015868 	.word	0x00015868
    4a00:	40065000 	.word	0x40065000

00004a04 <Clock_Ip_ResetSimTraceSel_TrustedCall>:
#endif

#ifdef CLOCK_IP_SIM_TRACE_SEL
void Clock_Ip_ResetSimTraceSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4a04:	b084      	sub	sp, #16
    4a06:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* TRACE_CLK selector mapped to Clock_Ip_au16SelectorEntryHardwareValue */
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[CORE_CLK];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4a08:	4b0b      	ldr	r3, [pc, #44]	; (4a38 <Clock_Ip_ResetSimTraceSel_TrustedCall+0x34>)
    4a0a:	7f1b      	ldrb	r3, [r3, #28]
    4a0c:	9303      	str	r3, [sp, #12]

    (void) Config;
    RegValue = (uint32)IP_SIM->CHIPCTL;
    4a0e:	4b0b      	ldr	r3, [pc, #44]	; (4a3c <Clock_Ip_ResetSimTraceSel_TrustedCall+0x38>)
    4a10:	685b      	ldr	r3, [r3, #4]
    4a12:	9302      	str	r3, [sp, #8]
    RegValue &= (~((uint32)SIM_CHIPCTL_TRACECLK_SEL_MASK));
    4a14:	9b02      	ldr	r3, [sp, #8]
    4a16:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    4a1a:	9302      	str	r3, [sp, #8]
    RegValue |= SIM_CHIPCTL_TRACECLK_SEL(SelectorValue);
    4a1c:	9b03      	ldr	r3, [sp, #12]
    4a1e:	031b      	lsls	r3, r3, #12
    4a20:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    4a24:	9a02      	ldr	r2, [sp, #8]
    4a26:	4313      	orrs	r3, r2
    4a28:	9302      	str	r3, [sp, #8]
    IP_SIM->CHIPCTL = (uint32)RegValue;
    4a2a:	4a04      	ldr	r2, [pc, #16]	; (4a3c <Clock_Ip_ResetSimTraceSel_TrustedCall+0x38>)
    4a2c:	9b02      	ldr	r3, [sp, #8]
    4a2e:	6053      	str	r3, [r2, #4]
}
    4a30:	bf00      	nop
    4a32:	b004      	add	sp, #16
    4a34:	4770      	bx	lr
    4a36:	bf00      	nop
    4a38:	000157e0 	.word	0x000157e0
    4a3c:	40048000 	.word	0x40048000

00004a40 <Clock_Ip_SetSimTraceSel_TrustedCall>:
void Clock_Ip_SetSimTraceSel_TrustedCall(Clock_Ip_SelectorConfigType const *Config)
{
    4a40:	b084      	sub	sp, #16
    4a42:	9001      	str	r0, [sp, #4]
    uint32 RegValue;
    /* TRACE_CLK selector mapped to Clock_Ip_au16SelectorEntryHardwareValue */
    uint32 SelectorValue = Clock_Ip_au16SelectorEntryHardwareValue[Config->Value];    /* Hw value corresponding to selector entry. Translate input clock source to hardware value. */
    4a44:	9b01      	ldr	r3, [sp, #4]
    4a46:	685b      	ldr	r3, [r3, #4]
    4a48:	4a0b      	ldr	r2, [pc, #44]	; (4a78 <Clock_Ip_SetSimTraceSel_TrustedCall+0x38>)
    4a4a:	5cd3      	ldrb	r3, [r2, r3]
    4a4c:	9303      	str	r3, [sp, #12]

    RegValue = (uint32)IP_SIM->CHIPCTL;
    4a4e:	4b0b      	ldr	r3, [pc, #44]	; (4a7c <Clock_Ip_SetSimTraceSel_TrustedCall+0x3c>)
    4a50:	685b      	ldr	r3, [r3, #4]
    4a52:	9302      	str	r3, [sp, #8]
    RegValue &= (~((uint32)SIM_CHIPCTL_TRACECLK_SEL_MASK));
    4a54:	9b02      	ldr	r3, [sp, #8]
    4a56:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    4a5a:	9302      	str	r3, [sp, #8]
    RegValue |= SIM_CHIPCTL_TRACECLK_SEL(SelectorValue);
    4a5c:	9b03      	ldr	r3, [sp, #12]
    4a5e:	031b      	lsls	r3, r3, #12
    4a60:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
    4a64:	9a02      	ldr	r2, [sp, #8]
    4a66:	4313      	orrs	r3, r2
    4a68:	9302      	str	r3, [sp, #8]
    IP_SIM->CHIPCTL = (uint32)RegValue;
    4a6a:	4a04      	ldr	r2, [pc, #16]	; (4a7c <Clock_Ip_SetSimTraceSel_TrustedCall+0x3c>)
    4a6c:	9b02      	ldr	r3, [sp, #8]
    4a6e:	6053      	str	r3, [r2, #4]
}
    4a70:	bf00      	nop
    4a72:	b004      	add	sp, #16
    4a74:	4770      	bx	lr
    4a76:	bf00      	nop
    4a78:	000157e0 	.word	0x000157e0
    4a7c:	40048000 	.word	0x40048000

00004a80 <DisableSafeClock>:

#define MCU_START_SEC_CODE
#include "Mcu_MemMap.h"

static void DisableSafeClock(Clock_Ip_ClockConfigType const * Config)
{
    4a80:	b500      	push	{lr}
    4a82:	b085      	sub	sp, #20
    4a84:	9001      	str	r0, [sp, #4]
    uint32 Index;
    boolean FircConfigFound = FALSE;
    4a86:	2300      	movs	r3, #0
    4a88:	f88d 300b 	strb.w	r3, [sp, #11]

    if (Config != NULL_PTR)
    4a8c:	9b01      	ldr	r3, [sp, #4]
    4a8e:	2b00      	cmp	r3, #0
    4a90:	d037      	beq.n	4b02 <DisableSafeClock+0x82>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    4a92:	2300      	movs	r3, #0
    4a94:	9303      	str	r3, [sp, #12]
    4a96:	e02b      	b.n	4af0 <DisableSafeClock+0x70>
        {
            if (Clock_Ip_apConfig->Ircoscs[Index].Name == FIRC_CLK)
    4a98:	4b29      	ldr	r3, [pc, #164]	; (4b40 <DisableSafeClock+0xc0>)
    4a9a:	6819      	ldr	r1, [r3, #0]
    4a9c:	9a03      	ldr	r2, [sp, #12]
    4a9e:	4613      	mov	r3, r2
    4aa0:	005b      	lsls	r3, r3, #1
    4aa2:	4413      	add	r3, r2
    4aa4:	009b      	lsls	r3, r3, #2
    4aa6:	440b      	add	r3, r1
    4aa8:	3314      	adds	r3, #20
    4aaa:	681b      	ldr	r3, [r3, #0]
    4aac:	2b05      	cmp	r3, #5
    4aae:	d11c      	bne.n	4aea <DisableSafeClock+0x6a>
            {
                FircConfigFound = TRUE;
    4ab0:	2301      	movs	r3, #1
    4ab2:	f88d 300b 	strb.w	r3, [sp, #11]
                if (Clock_Ip_apConfig->Ircoscs[Index].Enable == FALSE)
    4ab6:	4b22      	ldr	r3, [pc, #136]	; (4b40 <DisableSafeClock+0xc0>)
    4ab8:	6819      	ldr	r1, [r3, #0]
    4aba:	9a03      	ldr	r2, [sp, #12]
    4abc:	4613      	mov	r3, r2
    4abe:	005b      	lsls	r3, r3, #1
    4ac0:	4413      	add	r3, r2
    4ac2:	009b      	lsls	r3, r3, #2
    4ac4:	440b      	add	r3, r1
    4ac6:	3318      	adds	r3, #24
    4ac8:	881b      	ldrh	r3, [r3, #0]
    4aca:	2b00      	cmp	r3, #0
    4acc:	d118      	bne.n	4b00 <DisableSafeClock+0x80>
                {
                    /* Disable FIRC according to configuration */
                    Clock_Ip_axIntOscCallbacks[Clock_Ip_au8IrcoscCallbackIndex[CLOCK_IP_FIRCOSC]].Disable(FIRC_CLK);
    4ace:	4b1d      	ldr	r3, [pc, #116]	; (4b44 <DisableSafeClock+0xc4>)
    4ad0:	791b      	ldrb	r3, [r3, #4]
    4ad2:	4619      	mov	r1, r3
    4ad4:	4a1c      	ldr	r2, [pc, #112]	; (4b48 <DisableSafeClock+0xc8>)
    4ad6:	460b      	mov	r3, r1
    4ad8:	005b      	lsls	r3, r3, #1
    4ada:	440b      	add	r3, r1
    4adc:	009b      	lsls	r3, r3, #2
    4ade:	4413      	add	r3, r2
    4ae0:	3308      	adds	r3, #8
    4ae2:	681b      	ldr	r3, [r3, #0]
    4ae4:	2005      	movs	r0, #5
    4ae6:	4798      	blx	r3
                }
                break;
    4ae8:	e00a      	b.n	4b00 <DisableSafeClock+0x80>
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    4aea:	9b03      	ldr	r3, [sp, #12]
    4aec:	3301      	adds	r3, #1
    4aee:	9303      	str	r3, [sp, #12]
    4af0:	4b13      	ldr	r3, [pc, #76]	; (4b40 <DisableSafeClock+0xc0>)
    4af2:	681b      	ldr	r3, [r3, #0]
    4af4:	7a1b      	ldrb	r3, [r3, #8]
    4af6:	461a      	mov	r2, r3
    4af8:	9b03      	ldr	r3, [sp, #12]
    4afa:	4293      	cmp	r3, r2
    4afc:	d3cc      	bcc.n	4a98 <DisableSafeClock+0x18>
    4afe:	e000      	b.n	4b02 <DisableSafeClock+0x82>
                break;
    4b00:	bf00      	nop
            }
        }
    }

    if ((FircConfigFound == FALSE) && (Clock_Ip_bFircWasEnabledBeforeMcuInit == FALSE))
    4b02:	f89d 300b 	ldrb.w	r3, [sp, #11]
    4b06:	f083 0301 	eor.w	r3, r3, #1
    4b0a:	b2db      	uxtb	r3, r3
    4b0c:	2b00      	cmp	r3, #0
    4b0e:	d013      	beq.n	4b38 <DisableSafeClock+0xb8>
    4b10:	4b0e      	ldr	r3, [pc, #56]	; (4b4c <DisableSafeClock+0xcc>)
    4b12:	781b      	ldrb	r3, [r3, #0]
    4b14:	f083 0301 	eor.w	r3, r3, #1
    4b18:	b2db      	uxtb	r3, r3
    4b1a:	2b00      	cmp	r3, #0
    4b1c:	d00c      	beq.n	4b38 <DisableSafeClock+0xb8>
    {
        /* Disable FIRC according to configuration */
        Clock_Ip_axIntOscCallbacks[Clock_Ip_au8IrcoscCallbackIndex[CLOCK_IP_FIRCOSC]].Disable(FIRC_CLK);
    4b1e:	4b09      	ldr	r3, [pc, #36]	; (4b44 <DisableSafeClock+0xc4>)
    4b20:	791b      	ldrb	r3, [r3, #4]
    4b22:	4619      	mov	r1, r3
    4b24:	4a08      	ldr	r2, [pc, #32]	; (4b48 <DisableSafeClock+0xc8>)
    4b26:	460b      	mov	r3, r1
    4b28:	005b      	lsls	r3, r3, #1
    4b2a:	440b      	add	r3, r1
    4b2c:	009b      	lsls	r3, r3, #2
    4b2e:	4413      	add	r3, r2
    4b30:	3308      	adds	r3, #8
    4b32:	681b      	ldr	r3, [r3, #0]
    4b34:	2005      	movs	r0, #5
    4b36:	4798      	blx	r3
    }
}
    4b38:	bf00      	nop
    4b3a:	b005      	add	sp, #20
    4b3c:	f85d fb04 	ldr.w	pc, [sp], #4
    4b40:	1fff8b9c 	.word	0x1fff8b9c
    4b44:	00015460 	.word	0x00015460
    4b48:	00015a90 	.word	0x00015a90
    4b4c:	1fff8b18 	.word	0x1fff8b18

00004b50 <SetFircToResetValue_TrustedCall>:

void SetFircToResetValue_TrustedCall(void)
{
        /* Range is 48Mhz. */
        IP_SCG->FIRCCFG = SCG_FIRCCFG_RANGE(0U);
    4b50:	4b06      	ldr	r3, [pc, #24]	; (4b6c <SetFircToResetValue_TrustedCall+0x1c>)
    4b52:	2200      	movs	r2, #0
    4b54:	f8c3 2308 	str.w	r2, [r3, #776]	; 0x308

        /* Enable clock, Regulator is enabled. */
        IP_SCG->FIRCCSR |= (SCG_FIRCCSR_FIRCEN(1U) | SCG_FIRCCSR_FIRCREGOFF(0U));
    4b58:	4b04      	ldr	r3, [pc, #16]	; (4b6c <SetFircToResetValue_TrustedCall+0x1c>)
    4b5a:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4b5e:	4a03      	ldr	r2, [pc, #12]	; (4b6c <SetFircToResetValue_TrustedCall+0x1c>)
    4b60:	f043 0301 	orr.w	r3, r3, #1
    4b64:	f8c2 3300 	str.w	r3, [r2, #768]	; 0x300
}
    4b68:	bf00      	nop
    4b6a:	4770      	bx	lr
    4b6c:	40064000 	.word	0x40064000

00004b70 <SetSimLpoclksRegister_TrustedCall>:

void SetSimLpoclksRegister_TrustedCall(Clock_Ip_ClockConfigType const *Config)
{
    4b70:	b084      	sub	sp, #16
    4b72:	9001      	str	r0, [sp, #4]
    uint32 SimLpoValue = 3U; /* Reset value of SIM_LPOCLKS register */
    4b74:	2303      	movs	r3, #3
    4b76:	9303      	str	r3, [sp, #12]
    uint32 Index;

    /* The LPOCLKS register is a write-once register so configuration will be written here*/

    for (Index = 0U; Index < Config->SelectorsCount; Index++)
    4b78:	2300      	movs	r3, #0
    4b7a:	9302      	str	r3, [sp, #8]
    4b7c:	e028      	b.n	4bd0 <SetSimLpoclksRegister_TrustedCall+0x60>
    {
        /* Selector for RTC_CLK */
        if (RTC_CLK == Config->Selectors[Index].Name)
    4b7e:	9b01      	ldr	r3, [sp, #4]
    4b80:	9a02      	ldr	r2, [sp, #8]
    4b82:	320d      	adds	r2, #13
    4b84:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    4b88:	2b28      	cmp	r3, #40	; 0x28
    4b8a:	d10b      	bne.n	4ba4 <SetSimLpoclksRegister_TrustedCall+0x34>
        {
            SimLpoValue |= ((uint32)(Clock_Ip_au16SelectorEntryHardwareValue[Config->Selectors[Index].Value]) << SIM_LPOCLKS_RTCCLKSEL_SHIFT);
    4b8c:	9a01      	ldr	r2, [sp, #4]
    4b8e:	9b02      	ldr	r3, [sp, #8]
    4b90:	330d      	adds	r3, #13
    4b92:	00db      	lsls	r3, r3, #3
    4b94:	4413      	add	r3, r2
    4b96:	685b      	ldr	r3, [r3, #4]
    4b98:	4a2b      	ldr	r2, [pc, #172]	; (4c48 <SetSimLpoclksRegister_TrustedCall+0xd8>)
    4b9a:	5cd3      	ldrb	r3, [r2, r3]
    4b9c:	011b      	lsls	r3, r3, #4
    4b9e:	9a03      	ldr	r2, [sp, #12]
    4ba0:	4313      	orrs	r3, r2
    4ba2:	9303      	str	r3, [sp, #12]
        }

         /* Selector for LPO_CLK */
        if (LPO_CLK == Config->Selectors[Index].Name)
    4ba4:	9b01      	ldr	r3, [sp, #4]
    4ba6:	9a02      	ldr	r2, [sp, #8]
    4ba8:	320d      	adds	r2, #13
    4baa:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    4bae:	2b29      	cmp	r3, #41	; 0x29
    4bb0:	d10b      	bne.n	4bca <SetSimLpoclksRegister_TrustedCall+0x5a>
        {
            SimLpoValue |= ((uint32)(Clock_Ip_au8SelectorEntrySIMHardwareValue[Config->Selectors[Index].Value]) << SIM_LPOCLKS_LPOCLKSEL_SHIFT);
    4bb2:	9a01      	ldr	r2, [sp, #4]
    4bb4:	9b02      	ldr	r3, [sp, #8]
    4bb6:	330d      	adds	r3, #13
    4bb8:	00db      	lsls	r3, r3, #3
    4bba:	4413      	add	r3, r2
    4bbc:	685b      	ldr	r3, [r3, #4]
    4bbe:	4a23      	ldr	r2, [pc, #140]	; (4c4c <SetSimLpoclksRegister_TrustedCall+0xdc>)
    4bc0:	5cd3      	ldrb	r3, [r2, r3]
    4bc2:	009b      	lsls	r3, r3, #2
    4bc4:	9a03      	ldr	r2, [sp, #12]
    4bc6:	4313      	orrs	r3, r2
    4bc8:	9303      	str	r3, [sp, #12]
    for (Index = 0U; Index < Config->SelectorsCount; Index++)
    4bca:	9b02      	ldr	r3, [sp, #8]
    4bcc:	3301      	adds	r3, #1
    4bce:	9302      	str	r3, [sp, #8]
    4bd0:	9b01      	ldr	r3, [sp, #4]
    4bd2:	7adb      	ldrb	r3, [r3, #11]
    4bd4:	461a      	mov	r2, r3
    4bd6:	9b02      	ldr	r3, [sp, #8]
    4bd8:	4293      	cmp	r3, r2
    4bda:	d3d0      	bcc.n	4b7e <SetSimLpoclksRegister_TrustedCall+0xe>
        }
    }

    for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    4bdc:	2300      	movs	r3, #0
    4bde:	9302      	str	r3, [sp, #8]
    4be0:	e026      	b.n	4c30 <SetSimLpoclksRegister_TrustedCall+0xc0>
    {
        /* Gate for LPO_32K_CLK */
        if (LPO_32K_CLK == Config->Gates[Index].Name)
    4be2:	9a01      	ldr	r2, [sp, #4]
    4be4:	9b02      	ldr	r3, [sp, #8]
    4be6:	334e      	adds	r3, #78	; 0x4e
    4be8:	00db      	lsls	r3, r3, #3
    4bea:	4413      	add	r3, r2
    4bec:	685b      	ldr	r3, [r3, #4]
    4bee:	2b12      	cmp	r3, #18
    4bf0:	d109      	bne.n	4c06 <SetSimLpoclksRegister_TrustedCall+0x96>
        {
             SimLpoValue |= ((uint32)(Config->Gates[Index].Enable) << SIM_LPOCLKS_LPO32KCLKEN_SHIFT);
    4bf2:	9a01      	ldr	r2, [sp, #4]
    4bf4:	9b02      	ldr	r3, [sp, #8]
    4bf6:	334e      	adds	r3, #78	; 0x4e
    4bf8:	00db      	lsls	r3, r3, #3
    4bfa:	4413      	add	r3, r2
    4bfc:	891b      	ldrh	r3, [r3, #8]
    4bfe:	005b      	lsls	r3, r3, #1
    4c00:	9a03      	ldr	r2, [sp, #12]
    4c02:	4313      	orrs	r3, r2
    4c04:	9303      	str	r3, [sp, #12]
        }

         /* Gate for LPO_1K_CLK */
        if (LPO_1K_CLK == Config->Gates[Index].Name)
    4c06:	9a01      	ldr	r2, [sp, #4]
    4c08:	9b02      	ldr	r3, [sp, #8]
    4c0a:	334e      	adds	r3, #78	; 0x4e
    4c0c:	00db      	lsls	r3, r3, #3
    4c0e:	4413      	add	r3, r2
    4c10:	685b      	ldr	r3, [r3, #4]
    4c12:	2b13      	cmp	r3, #19
    4c14:	d109      	bne.n	4c2a <SetSimLpoclksRegister_TrustedCall+0xba>
        {
            SimLpoValue |= ((uint32)(Config->Gates[Index].Enable) << SIM_LPOCLKS_LPO1KCLKEN_SHIFT);
    4c16:	9a01      	ldr	r2, [sp, #4]
    4c18:	9b02      	ldr	r3, [sp, #8]
    4c1a:	334e      	adds	r3, #78	; 0x4e
    4c1c:	00db      	lsls	r3, r3, #3
    4c1e:	4413      	add	r3, r2
    4c20:	891b      	ldrh	r3, [r3, #8]
    4c22:	461a      	mov	r2, r3
    4c24:	9b03      	ldr	r3, [sp, #12]
    4c26:	4313      	orrs	r3, r2
    4c28:	9303      	str	r3, [sp, #12]
    for (Index = 0U; Index < Config->GatesCount; Index++)    /* Set clock gates that are under clock control. */
    4c2a:	9b02      	ldr	r3, [sp, #8]
    4c2c:	3301      	adds	r3, #1
    4c2e:	9302      	str	r3, [sp, #8]
    4c30:	9b01      	ldr	r3, [sp, #4]
    4c32:	7c1b      	ldrb	r3, [r3, #16]
    4c34:	461a      	mov	r2, r3
    4c36:	9b02      	ldr	r3, [sp, #8]
    4c38:	4293      	cmp	r3, r2
    4c3a:	d3d2      	bcc.n	4be2 <SetSimLpoclksRegister_TrustedCall+0x72>
        }
    }

    IP_SIM->LPOCLKS = SimLpoValue;
    4c3c:	4a04      	ldr	r2, [pc, #16]	; (4c50 <SetSimLpoclksRegister_TrustedCall+0xe0>)
    4c3e:	9b03      	ldr	r3, [sp, #12]
    4c40:	6113      	str	r3, [r2, #16]
}
    4c42:	bf00      	nop
    4c44:	b004      	add	sp, #16
    4c46:	4770      	bx	lr
    4c48:	000157e0 	.word	0x000157e0
    4c4c:	00015898 	.word	0x00015898
    4c50:	40048000 	.word	0x40048000

00004c54 <Clock_Ip_SpecificPlatformInitClock>:
}
#endif


static void Clock_Ip_SpecificPlatformInitClock(Clock_Ip_ClockConfigType const * Config)
{
    4c54:	b500      	push	{lr}
    4c56:	b089      	sub	sp, #36	; 0x24
    4c58:	9001      	str	r0, [sp, #4]
    boolean TimeoutOccurred = FALSE;
    4c5a:	2300      	movs	r3, #0
    4c5c:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    uint32 IrcoscStatus;

    (void)Clock_Ip_FreqIds;
    Clock_Ip_apConfig = Config;
    4c60:	4a21      	ldr	r2, [pc, #132]	; (4ce8 <Clock_Ip_SpecificPlatformInitClock+0x94>)
    4c62:	9b01      	ldr	r3, [sp, #4]
    4c64:	6013      	str	r3, [r2, #0]

    /* Clocks cannot be configured while the chip is in other mode than RUN_MODE */
    CLOCK_IP_DEV_ASSERT(CLOCK_IP_RUN_POWER_MODE_STATUS == ((IP_SMC->PMSTAT & SMC_PMSTAT_PMSTAT_MASK) >> SMC_PMSTAT_PMSTAT_SHIFT));

    /* Check whether FIRC is disabled, enable it in this case. */
    if ((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCEN_MASK) == 0U)
    4c66:	4b21      	ldr	r3, [pc, #132]	; (4cec <Clock_Ip_SpecificPlatformInitClock+0x98>)
    4c68:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4c6c:	f003 0301 	and.w	r3, r3, #1
    4c70:	2b00      	cmp	r3, #0
    4c72:	d12e      	bne.n	4cd2 <Clock_Ip_SpecificPlatformInitClock+0x7e>
    {
        Clock_Ip_bFircWasEnabledBeforeMcuInit = FALSE;
    4c74:	4b1e      	ldr	r3, [pc, #120]	; (4cf0 <Clock_Ip_SpecificPlatformInitClock+0x9c>)
    4c76:	2200      	movs	r2, #0
    4c78:	701a      	strb	r2, [r3, #0]

    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
      #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
        OsIf_Trusted_Call(SetFircToResetValue_TrustedCall);
      #else
        SetFircToResetValue_TrustedCall();
    4c7a:	f7ff ff69 	bl	4b50 <SetFircToResetValue_TrustedCall>
      #endif
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */

        Clock_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, CLOCK_IP_TIMEOUT_VALUE_US);
    4c7e:	aa03      	add	r2, sp, #12
    4c80:	a904      	add	r1, sp, #16
    4c82:	a805      	add	r0, sp, #20
    4c84:	f24c 3350 	movw	r3, #50000	; 0xc350
    4c88:	f7fe f8ae 	bl	2de8 <Clock_Ip_StartTimeout>
        /* Wait until ircosc is locked */
        do
        {
            IrcoscStatus = (((IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCVLD_MASK) >> SCG_FIRCCSR_FIRCVLD_SHIFT));
    4c8c:	4b17      	ldr	r3, [pc, #92]	; (4cec <Clock_Ip_SpecificPlatformInitClock+0x98>)
    4c8e:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4c92:	0e1b      	lsrs	r3, r3, #24
    4c94:	f003 0301 	and.w	r3, r3, #1
    4c98:	9306      	str	r3, [sp, #24]
            TimeoutOccurred = Clock_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    4c9a:	9a03      	ldr	r2, [sp, #12]
    4c9c:	a904      	add	r1, sp, #16
    4c9e:	ab05      	add	r3, sp, #20
    4ca0:	4618      	mov	r0, r3
    4ca2:	f7fe f8bb 	bl	2e1c <Clock_Ip_TimeoutExpired>
    4ca6:	4603      	mov	r3, r0
    4ca8:	f88d 301f 	strb.w	r3, [sp, #31]
        }
        while ((IrcoscStatus == 0U) && (FALSE == TimeoutOccurred));
    4cac:	9b06      	ldr	r3, [sp, #24]
    4cae:	2b00      	cmp	r3, #0
    4cb0:	d106      	bne.n	4cc0 <Clock_Ip_SpecificPlatformInitClock+0x6c>
    4cb2:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4cb6:	f083 0301 	eor.w	r3, r3, #1
    4cba:	b2db      	uxtb	r3, r3
    4cbc:	2b00      	cmp	r3, #0
    4cbe:	d1e5      	bne.n	4c8c <Clock_Ip_SpecificPlatformInitClock+0x38>

        if (FALSE != TimeoutOccurred)
    4cc0:	f89d 301f 	ldrb.w	r3, [sp, #31]
    4cc4:	2b00      	cmp	r3, #0
    4cc6:	d007      	beq.n	4cd8 <Clock_Ip_SpecificPlatformInitClock+0x84>
        {
            /* Report timeout error */
            Clock_Ip_ReportClockErrors(CLOCK_IP_REPORT_TIMEOUT_ERROR, FIRC_CLK);
    4cc8:	2105      	movs	r1, #5
    4cca:	2001      	movs	r0, #1
    4ccc:	f7fe f87c 	bl	2dc8 <Clock_Ip_ReportClockErrors>
    4cd0:	e002      	b.n	4cd8 <Clock_Ip_SpecificPlatformInitClock+0x84>
        }
    }
    else
    {
        Clock_Ip_bFircWasEnabledBeforeMcuInit = TRUE;
    4cd2:	4b07      	ldr	r3, [pc, #28]	; (4cf0 <Clock_Ip_SpecificPlatformInitClock+0x9c>)
    4cd4:	2201      	movs	r2, #1
    4cd6:	701a      	strb	r2, [r3, #0]

    #ifdef CLOCK_IP_ENABLE_USER_MODE_SUPPORT
        #if (STD_ON == CLOCK_IP_ENABLE_USER_MODE_SUPPORT)
    OsIf_Trusted_Call1param(SetSimLpoclksRegister_TrustedCall,(Config));
        #else
    SetSimLpoclksRegister_TrustedCall(Config);
    4cd8:	9801      	ldr	r0, [sp, #4]
    4cda:	f7ff ff49 	bl	4b70 <SetSimLpoclksRegister_TrustedCall>
    #endif /* CLOCK_IP_ENABLE_USER_MODE_SUPPORT */

    #if defined(CLOCK_IP_HAS_FIRC_MON1_CLK) || defined(CLOCK_IP_HAS_FIRC_MON2_CLK)
    Clock_Ip_PllPowerClockIp();
    #endif
}
    4cde:	bf00      	nop
    4ce0:	b009      	add	sp, #36	; 0x24
    4ce2:	f85d fb04 	ldr.w	pc, [sp], #4
    4ce6:	bf00      	nop
    4ce8:	1fff8b9c 	.word	0x1fff8b9c
    4cec:	40064000 	.word	0x40064000
    4cf0:	1fff8b18 	.word	0x1fff8b18

00004cf4 <getFircConfig>:

/**
* @brief            This function will get current configuration of FIRC.
*/
static const Clock_Ip_IrcoscConfigType *getFircConfig(void)
{
    4cf4:	b082      	sub	sp, #8
    uint32 Index;

    const Clock_Ip_IrcoscConfigType *ReturnValue = NULL_PTR;
    4cf6:	2300      	movs	r3, #0
    4cf8:	9300      	str	r3, [sp, #0]

    if (Clock_Ip_apConfig != NULL_PTR)
    4cfa:	4b29      	ldr	r3, [pc, #164]	; (4da0 <getFircConfig+0xac>)
    4cfc:	681b      	ldr	r3, [r3, #0]
    4cfe:	2b00      	cmp	r3, #0
    4d00:	d024      	beq.n	4d4c <getFircConfig+0x58>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    4d02:	2300      	movs	r3, #0
    4d04:	9301      	str	r3, [sp, #4]
    4d06:	e01a      	b.n	4d3e <getFircConfig+0x4a>
        {
            if (Clock_Ip_apConfig->Ircoscs[Index].Name == FIRC_CLK)
    4d08:	4b25      	ldr	r3, [pc, #148]	; (4da0 <getFircConfig+0xac>)
    4d0a:	6819      	ldr	r1, [r3, #0]
    4d0c:	9a01      	ldr	r2, [sp, #4]
    4d0e:	4613      	mov	r3, r2
    4d10:	005b      	lsls	r3, r3, #1
    4d12:	4413      	add	r3, r2
    4d14:	009b      	lsls	r3, r3, #2
    4d16:	440b      	add	r3, r1
    4d18:	3314      	adds	r3, #20
    4d1a:	681b      	ldr	r3, [r3, #0]
    4d1c:	2b05      	cmp	r3, #5
    4d1e:	d10b      	bne.n	4d38 <getFircConfig+0x44>
            {
                ReturnValue = &Clock_Ip_apConfig->Ircoscs[Index];
    4d20:	4b1f      	ldr	r3, [pc, #124]	; (4da0 <getFircConfig+0xac>)
    4d22:	6819      	ldr	r1, [r3, #0]
    4d24:	9a01      	ldr	r2, [sp, #4]
    4d26:	4613      	mov	r3, r2
    4d28:	005b      	lsls	r3, r3, #1
    4d2a:	4413      	add	r3, r2
    4d2c:	009b      	lsls	r3, r3, #2
    4d2e:	3310      	adds	r3, #16
    4d30:	440b      	add	r3, r1
    4d32:	3304      	adds	r3, #4
    4d34:	9300      	str	r3, [sp, #0]
                break;
    4d36:	e009      	b.n	4d4c <getFircConfig+0x58>
        for (Index = 0U; Index < Clock_Ip_apConfig->IrcoscsCount; Index++)
    4d38:	9b01      	ldr	r3, [sp, #4]
    4d3a:	3301      	adds	r3, #1
    4d3c:	9301      	str	r3, [sp, #4]
    4d3e:	4b18      	ldr	r3, [pc, #96]	; (4da0 <getFircConfig+0xac>)
    4d40:	681b      	ldr	r3, [r3, #0]
    4d42:	7a1b      	ldrb	r3, [r3, #8]
    4d44:	461a      	mov	r2, r3
    4d46:	9b01      	ldr	r3, [sp, #4]
    4d48:	4293      	cmp	r3, r2
    4d4a:	d3dd      	bcc.n	4d08 <getFircConfig+0x14>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    4d4c:	9b00      	ldr	r3, [sp, #0]
    4d4e:	2b00      	cmp	r3, #0
    4d50:	d121      	bne.n	4d96 <getFircConfig+0xa2>
    {
        ReturnValue = &FircConfiguration;
    4d52:	4b14      	ldr	r3, [pc, #80]	; (4da4 <getFircConfig+0xb0>)
    4d54:	9300      	str	r3, [sp, #0]
        FircConfiguration.Name = FIRC_CLK;
    4d56:	4b13      	ldr	r3, [pc, #76]	; (4da4 <getFircConfig+0xb0>)
    4d58:	2205      	movs	r2, #5
    4d5a:	601a      	str	r2, [r3, #0]
        FircConfiguration.Enable = (uint16)(IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCEN_MASK) >> SCG_FIRCCSR_FIRCEN_SHIFT;
    4d5c:	4b12      	ldr	r3, [pc, #72]	; (4da8 <getFircConfig+0xb4>)
    4d5e:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4d62:	b29b      	uxth	r3, r3
    4d64:	f003 0301 	and.w	r3, r3, #1
    4d68:	b29a      	uxth	r2, r3
    4d6a:	4b0e      	ldr	r3, [pc, #56]	; (4da4 <getFircConfig+0xb0>)
    4d6c:	809a      	strh	r2, [r3, #4]
        FircConfiguration.Range = (uint8)(IP_SCG->FIRCCFG & SCG_FIRCCFG_RANGE_MASK) >> SCG_FIRCCFG_RANGE_SHIFT;
    4d6e:	4b0e      	ldr	r3, [pc, #56]	; (4da8 <getFircConfig+0xb4>)
    4d70:	f8d3 3308 	ldr.w	r3, [r3, #776]	; 0x308
    4d74:	b2db      	uxtb	r3, r3
    4d76:	f003 0303 	and.w	r3, r3, #3
    4d7a:	b2da      	uxtb	r2, r3
    4d7c:	4b09      	ldr	r3, [pc, #36]	; (4da4 <getFircConfig+0xb0>)
    4d7e:	71da      	strb	r2, [r3, #7]
        FircConfiguration.Regulator = (uint8)(IP_SCG->FIRCCSR & SCG_FIRCCSR_FIRCREGOFF_MASK) >> SCG_FIRCCSR_FIRCREGOFF_SHIFT;
    4d80:	4b09      	ldr	r3, [pc, #36]	; (4da8 <getFircConfig+0xb4>)
    4d82:	f8d3 3300 	ldr.w	r3, [r3, #768]	; 0x300
    4d86:	b2db      	uxtb	r3, r3
    4d88:	10db      	asrs	r3, r3, #3
    4d8a:	b2db      	uxtb	r3, r3
    4d8c:	f003 0301 	and.w	r3, r3, #1
    4d90:	b2da      	uxtb	r2, r3
    4d92:	4b04      	ldr	r3, [pc, #16]	; (4da4 <getFircConfig+0xb0>)
    4d94:	719a      	strb	r2, [r3, #6]
    }

    return ReturnValue;
    4d96:	9b00      	ldr	r3, [sp, #0]
}
    4d98:	4618      	mov	r0, r3
    4d9a:	b002      	add	sp, #8
    4d9c:	4770      	bx	lr
    4d9e:	bf00      	nop
    4da0:	1fff8b9c 	.word	0x1fff8b9c
    4da4:	1fff8c08 	.word	0x1fff8c08
    4da8:	40064000 	.word	0x40064000

00004dac <getSoscConfig>:

/**
* @brief            This function will get current configuration of SOSC.
*/
static const Clock_Ip_XoscConfigType *getSoscConfig(void)
{
    4dac:	b082      	sub	sp, #8
    uint32 Index;

    const Clock_Ip_XoscConfigType *ReturnValue = NULL_PTR;
    4dae:	2300      	movs	r3, #0
    4db0:	9300      	str	r3, [sp, #0]

    if (Clock_Ip_apConfig != NULL_PTR)
    4db2:	4b20      	ldr	r3, [pc, #128]	; (4e34 <getSoscConfig+0x88>)
    4db4:	681b      	ldr	r3, [r3, #0]
    4db6:	2b00      	cmp	r3, #0
    4db8:	d024      	beq.n	4e04 <getSoscConfig+0x58>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->XoscsCount; Index++)
    4dba:	2300      	movs	r3, #0
    4dbc:	9301      	str	r3, [sp, #4]
    4dbe:	e01a      	b.n	4df6 <getSoscConfig+0x4a>
        {
            if (Clock_Ip_apConfig->Xoscs[Index].Name == SOSC_CLK)
    4dc0:	4b1c      	ldr	r3, [pc, #112]	; (4e34 <getSoscConfig+0x88>)
    4dc2:	6819      	ldr	r1, [r3, #0]
    4dc4:	9a01      	ldr	r2, [sp, #4]
    4dc6:	4613      	mov	r3, r2
    4dc8:	009b      	lsls	r3, r3, #2
    4dca:	4413      	add	r3, r2
    4dcc:	009b      	lsls	r3, r3, #2
    4dce:	440b      	add	r3, r1
    4dd0:	332c      	adds	r3, #44	; 0x2c
    4dd2:	681b      	ldr	r3, [r3, #0]
    4dd4:	2b08      	cmp	r3, #8
    4dd6:	d10b      	bne.n	4df0 <getSoscConfig+0x44>
            {
                ReturnValue = &Clock_Ip_apConfig->Xoscs[Index];
    4dd8:	4b16      	ldr	r3, [pc, #88]	; (4e34 <getSoscConfig+0x88>)
    4dda:	6819      	ldr	r1, [r3, #0]
    4ddc:	9a01      	ldr	r2, [sp, #4]
    4dde:	4613      	mov	r3, r2
    4de0:	009b      	lsls	r3, r3, #2
    4de2:	4413      	add	r3, r2
    4de4:	009b      	lsls	r3, r3, #2
    4de6:	3328      	adds	r3, #40	; 0x28
    4de8:	440b      	add	r3, r1
    4dea:	3304      	adds	r3, #4
    4dec:	9300      	str	r3, [sp, #0]
                break;
    4dee:	e009      	b.n	4e04 <getSoscConfig+0x58>
        for (Index = 0U; Index < Clock_Ip_apConfig->XoscsCount; Index++)
    4df0:	9b01      	ldr	r3, [sp, #4]
    4df2:	3301      	adds	r3, #1
    4df4:	9301      	str	r3, [sp, #4]
    4df6:	4b0f      	ldr	r3, [pc, #60]	; (4e34 <getSoscConfig+0x88>)
    4df8:	681b      	ldr	r3, [r3, #0]
    4dfa:	7a5b      	ldrb	r3, [r3, #9]
    4dfc:	461a      	mov	r2, r3
    4dfe:	9b01      	ldr	r3, [sp, #4]
    4e00:	4293      	cmp	r3, r2
    4e02:	d3dd      	bcc.n	4dc0 <getSoscConfig+0x14>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    4e04:	9b00      	ldr	r3, [sp, #0]
    4e06:	2b00      	cmp	r3, #0
    4e08:	d110      	bne.n	4e2c <getSoscConfig+0x80>
    {
        ReturnValue = &SoscConfiguration;
    4e0a:	4b0b      	ldr	r3, [pc, #44]	; (4e38 <getSoscConfig+0x8c>)
    4e0c:	9300      	str	r3, [sp, #0]
        SoscConfiguration.Name = SOSC_CLK;
    4e0e:	4b0a      	ldr	r3, [pc, #40]	; (4e38 <getSoscConfig+0x8c>)
    4e10:	2208      	movs	r2, #8
    4e12:	601a      	str	r2, [r3, #0]
        SoscConfiguration.Enable = (uint16)(IP_SCG->SOSCCSR & SCG_SOSCCSR_SOSCEN_MASK) >> SCG_SOSCCSR_SOSCEN_SHIFT;
    4e14:	4b09      	ldr	r3, [pc, #36]	; (4e3c <getSoscConfig+0x90>)
    4e16:	f8d3 3100 	ldr.w	r3, [r3, #256]	; 0x100
    4e1a:	b29b      	uxth	r3, r3
    4e1c:	f003 0301 	and.w	r3, r3, #1
    4e20:	b29a      	uxth	r2, r3
    4e22:	4b05      	ldr	r3, [pc, #20]	; (4e38 <getSoscConfig+0x8c>)
    4e24:	811a      	strh	r2, [r3, #8]
        SoscConfiguration.Freq = CLOCK_IP_DEFAULT_SOSC_FREQUENCY;
    4e26:	4b04      	ldr	r3, [pc, #16]	; (4e38 <getSoscConfig+0x8c>)
    4e28:	4a05      	ldr	r2, [pc, #20]	; (4e40 <getSoscConfig+0x94>)
    4e2a:	605a      	str	r2, [r3, #4]
    }

    return ReturnValue;
    4e2c:	9b00      	ldr	r3, [sp, #0]
}
    4e2e:	4618      	mov	r0, r3
    4e30:	b002      	add	sp, #8
    4e32:	4770      	bx	lr
    4e34:	1fff8b9c 	.word	0x1fff8b9c
    4e38:	1fff8c14 	.word	0x1fff8c14
    4e3c:	40064000 	.word	0x40064000
    4e40:	02625a00 	.word	0x02625a00

00004e44 <getSpllConfig>:
#if defined(CLOCK_IP_HAS_SPLL_CLK)
/**
* @brief            This function will get current configuration of SPLL.
*/
static const Clock_Ip_PllConfigType *getSpllConfig(void)
{
    4e44:	b082      	sub	sp, #8
    uint32 Index;
    const Clock_Ip_PllConfigType *ReturnValue = NULL_PTR;
    4e46:	2300      	movs	r3, #0
    4e48:	9300      	str	r3, [sp, #0]

    if (Clock_Ip_apConfig != NULL_PTR)
    4e4a:	4b28      	ldr	r3, [pc, #160]	; (4eec <getSpllConfig+0xa8>)
    4e4c:	681b      	ldr	r3, [r3, #0]
    4e4e:	2b00      	cmp	r3, #0
    4e50:	d023      	beq.n	4e9a <getSpllConfig+0x56>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->PllsCount; Index++)
    4e52:	2300      	movs	r3, #0
    4e54:	9301      	str	r3, [sp, #4]
    4e56:	e019      	b.n	4e8c <getSpllConfig+0x48>
        {
            if (Clock_Ip_apConfig->Plls[Index].Name == SPLL_CLK)
    4e58:	4b24      	ldr	r3, [pc, #144]	; (4eec <getSpllConfig+0xa8>)
    4e5a:	6819      	ldr	r1, [r3, #0]
    4e5c:	9a01      	ldr	r2, [sp, #4]
    4e5e:	4613      	mov	r3, r2
    4e60:	009b      	lsls	r3, r3, #2
    4e62:	4413      	add	r3, r2
    4e64:	00db      	lsls	r3, r3, #3
    4e66:	440b      	add	r3, r1
    4e68:	3340      	adds	r3, #64	; 0x40
    4e6a:	681b      	ldr	r3, [r3, #0]
    4e6c:	2b09      	cmp	r3, #9
    4e6e:	d10a      	bne.n	4e86 <getSpllConfig+0x42>
            {
                ReturnValue = &Clock_Ip_apConfig->Plls[Index];
    4e70:	4b1e      	ldr	r3, [pc, #120]	; (4eec <getSpllConfig+0xa8>)
    4e72:	6819      	ldr	r1, [r3, #0]
    4e74:	9a01      	ldr	r2, [sp, #4]
    4e76:	4613      	mov	r3, r2
    4e78:	009b      	lsls	r3, r3, #2
    4e7a:	4413      	add	r3, r2
    4e7c:	00db      	lsls	r3, r3, #3
    4e7e:	3340      	adds	r3, #64	; 0x40
    4e80:	440b      	add	r3, r1
    4e82:	9300      	str	r3, [sp, #0]
                break;
    4e84:	e009      	b.n	4e9a <getSpllConfig+0x56>
        for (Index = 0U; Index < Clock_Ip_apConfig->PllsCount; Index++)
    4e86:	9b01      	ldr	r3, [sp, #4]
    4e88:	3301      	adds	r3, #1
    4e8a:	9301      	str	r3, [sp, #4]
    4e8c:	4b17      	ldr	r3, [pc, #92]	; (4eec <getSpllConfig+0xa8>)
    4e8e:	681b      	ldr	r3, [r3, #0]
    4e90:	7a9b      	ldrb	r3, [r3, #10]
    4e92:	461a      	mov	r2, r3
    4e94:	9b01      	ldr	r3, [sp, #4]
    4e96:	4293      	cmp	r3, r2
    4e98:	d3de      	bcc.n	4e58 <getSpllConfig+0x14>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    4e9a:	9b00      	ldr	r3, [sp, #0]
    4e9c:	2b00      	cmp	r3, #0
    4e9e:	d121      	bne.n	4ee4 <getSpllConfig+0xa0>
    {
        ReturnValue = &SpllConfiguration;
    4ea0:	4b13      	ldr	r3, [pc, #76]	; (4ef0 <getSpllConfig+0xac>)
    4ea2:	9300      	str	r3, [sp, #0]
        SpllConfiguration.Name = SPLL_CLK;
    4ea4:	4b12      	ldr	r3, [pc, #72]	; (4ef0 <getSpllConfig+0xac>)
    4ea6:	2209      	movs	r2, #9
    4ea8:	601a      	str	r2, [r3, #0]
        SpllConfiguration.Enable = (uint16)(IP_SCG->SPLLCSR & SCG_SPLLCSR_SPLLEN_MASK) >> SCG_SPLLCSR_SPLLEN_SHIFT;
    4eaa:	4b12      	ldr	r3, [pc, #72]	; (4ef4 <getSpllConfig+0xb0>)
    4eac:	f8d3 3600 	ldr.w	r3, [r3, #1536]	; 0x600
    4eb0:	b29b      	uxth	r3, r3
    4eb2:	f003 0301 	and.w	r3, r3, #1
    4eb6:	b29a      	uxth	r2, r3
    4eb8:	4b0d      	ldr	r3, [pc, #52]	; (4ef0 <getSpllConfig+0xac>)
    4eba:	809a      	strh	r2, [r3, #4]
        SpllConfiguration.Predivider = (uint8)((IP_SCG->SPLLCFG & SCG_SPLLCFG_PREDIV_MASK) >> SCG_SPLLCFG_PREDIV_SHIFT);
    4ebc:	4b0d      	ldr	r3, [pc, #52]	; (4ef4 <getSpllConfig+0xb0>)
    4ebe:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    4ec2:	0a1b      	lsrs	r3, r3, #8
    4ec4:	b2db      	uxtb	r3, r3
    4ec6:	f003 0307 	and.w	r3, r3, #7
    4eca:	b2da      	uxtb	r2, r3
    4ecc:	4b08      	ldr	r3, [pc, #32]	; (4ef0 <getSpllConfig+0xac>)
    4ece:	735a      	strb	r2, [r3, #13]
        SpllConfiguration.MulFactorDiv = (uint8)((IP_SCG->SPLLCFG & SCG_SPLLCFG_MULT_MASK) >> SCG_SPLLCFG_MULT_SHIFT);
    4ed0:	4b08      	ldr	r3, [pc, #32]	; (4ef4 <getSpllConfig+0xb0>)
    4ed2:	f8d3 3608 	ldr.w	r3, [r3, #1544]	; 0x608
    4ed6:	0c1b      	lsrs	r3, r3, #16
    4ed8:	b2db      	uxtb	r3, r3
    4eda:	f003 031f 	and.w	r3, r3, #31
    4ede:	b2da      	uxtb	r2, r3
    4ee0:	4b03      	ldr	r3, [pc, #12]	; (4ef0 <getSpllConfig+0xac>)
    4ee2:	751a      	strb	r2, [r3, #20]
    }

    return ReturnValue;
    4ee4:	9b00      	ldr	r3, [sp, #0]
}
    4ee6:	4618      	mov	r0, r3
    4ee8:	b002      	add	sp, #8
    4eea:	4770      	bx	lr
    4eec:	1fff8b9c 	.word	0x1fff8b9c
    4ef0:	1fff8c28 	.word	0x1fff8c28
    4ef4:	40064000 	.word	0x40064000

00004ef8 <getSelectorConfig>:
    return ReturnValue;
}
#endif

static const Clock_Ip_SelectorConfigType *getSelectorConfig(Clock_Ip_NameType Name)
{
    4ef8:	b086      	sub	sp, #24
    4efa:	9001      	str	r0, [sp, #4]
    const Clock_Ip_SelectorConfigType *ReturnValue = NULL_PTR;
    4efc:	2300      	movs	r3, #0
    4efe:	9305      	str	r3, [sp, #20]
    uint32 SelectorConfigIndex;
    uint32 Index;

    switch(Name)
    4f00:	9b01      	ldr	r3, [sp, #4]
    4f02:	2b1b      	cmp	r3, #27
    4f04:	d00f      	beq.n	4f26 <getSelectorConfig+0x2e>
    4f06:	9b01      	ldr	r3, [sp, #4]
    4f08:	2b1b      	cmp	r3, #27
    4f0a:	d80f      	bhi.n	4f2c <getSelectorConfig+0x34>
    4f0c:	9b01      	ldr	r3, [sp, #4]
    4f0e:	2b19      	cmp	r3, #25
    4f10:	d003      	beq.n	4f1a <getSelectorConfig+0x22>
    4f12:	9b01      	ldr	r3, [sp, #4]
    4f14:	2b1a      	cmp	r3, #26
    4f16:	d003      	beq.n	4f20 <getSelectorConfig+0x28>
    4f18:	e008      	b.n	4f2c <getSelectorConfig+0x34>
    {
        case SCS_RUN_CLK:
            SelectorConfigIndex = 0U;
    4f1a:	2300      	movs	r3, #0
    4f1c:	9304      	str	r3, [sp, #16]
            break;
    4f1e:	e008      	b.n	4f32 <getSelectorConfig+0x3a>
        case SCS_VLPR_CLK:
            SelectorConfigIndex = 1U;
    4f20:	2301      	movs	r3, #1
    4f22:	9304      	str	r3, [sp, #16]
            break;
    4f24:	e005      	b.n	4f32 <getSelectorConfig+0x3a>
#if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
        case SCS_HSRUN_CLK:
            SelectorConfigIndex = 2U;
    4f26:	2302      	movs	r3, #2
    4f28:	9304      	str	r3, [sp, #16]
            break;
    4f2a:	e002      	b.n	4f32 <getSelectorConfig+0x3a>
#endif
        default:
            SelectorConfigIndex = 0U;
    4f2c:	2300      	movs	r3, #0
    4f2e:	9304      	str	r3, [sp, #16]
            break;
    4f30:	bf00      	nop
    }


    if (Clock_Ip_apConfig != NULL_PTR)
    4f32:	4b36      	ldr	r3, [pc, #216]	; (500c <getSelectorConfig+0x114>)
    4f34:	681b      	ldr	r3, [r3, #0]
    4f36:	2b00      	cmp	r3, #0
    4f38:	d01d      	beq.n	4f76 <getSelectorConfig+0x7e>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->SelectorsCount; Index++)
    4f3a:	2300      	movs	r3, #0
    4f3c:	9303      	str	r3, [sp, #12]
    4f3e:	e013      	b.n	4f68 <getSelectorConfig+0x70>
        {
            if (Clock_Ip_apConfig->Selectors[Index].Name == Name)
    4f40:	4b32      	ldr	r3, [pc, #200]	; (500c <getSelectorConfig+0x114>)
    4f42:	681b      	ldr	r3, [r3, #0]
    4f44:	9a03      	ldr	r2, [sp, #12]
    4f46:	320d      	adds	r2, #13
    4f48:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
    4f4c:	9a01      	ldr	r2, [sp, #4]
    4f4e:	429a      	cmp	r2, r3
    4f50:	d107      	bne.n	4f62 <getSelectorConfig+0x6a>
            {
                ReturnValue = &Clock_Ip_apConfig->Selectors[Index];
    4f52:	4b2e      	ldr	r3, [pc, #184]	; (500c <getSelectorConfig+0x114>)
    4f54:	681a      	ldr	r2, [r3, #0]
    4f56:	9b03      	ldr	r3, [sp, #12]
    4f58:	330d      	adds	r3, #13
    4f5a:	00db      	lsls	r3, r3, #3
    4f5c:	4413      	add	r3, r2
    4f5e:	9305      	str	r3, [sp, #20]
                break;
    4f60:	e009      	b.n	4f76 <getSelectorConfig+0x7e>
        for (Index = 0U; Index < Clock_Ip_apConfig->SelectorsCount; Index++)
    4f62:	9b03      	ldr	r3, [sp, #12]
    4f64:	3301      	adds	r3, #1
    4f66:	9303      	str	r3, [sp, #12]
    4f68:	4b28      	ldr	r3, [pc, #160]	; (500c <getSelectorConfig+0x114>)
    4f6a:	681b      	ldr	r3, [r3, #0]
    4f6c:	7adb      	ldrb	r3, [r3, #11]
    4f6e:	461a      	mov	r2, r3
    4f70:	9b03      	ldr	r3, [sp, #12]
    4f72:	4293      	cmp	r3, r2
    4f74:	d3e4      	bcc.n	4f40 <getSelectorConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    4f76:	9b05      	ldr	r3, [sp, #20]
    4f78:	2b00      	cmp	r3, #0
    4f7a:	d140      	bne.n	4ffe <getSelectorConfig+0x106>
    {
        ReturnValue = &SelectorConfigurations[SelectorConfigIndex];
    4f7c:	9b04      	ldr	r3, [sp, #16]
    4f7e:	00db      	lsls	r3, r3, #3
    4f80:	4a23      	ldr	r2, [pc, #140]	; (5010 <getSelectorConfig+0x118>)
    4f82:	4413      	add	r3, r2
    4f84:	9305      	str	r3, [sp, #20]
        SelectorConfigurations[SelectorConfigIndex].Name = Name;
    4f86:	4922      	ldr	r1, [pc, #136]	; (5010 <getSelectorConfig+0x118>)
    4f88:	9b04      	ldr	r3, [sp, #16]
    4f8a:	9a01      	ldr	r2, [sp, #4]
    4f8c:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
        switch(Name)
    4f90:	9b01      	ldr	r3, [sp, #4]
    4f92:	2b1b      	cmp	r3, #27
    4f94:	d025      	beq.n	4fe2 <getSelectorConfig+0xea>
    4f96:	9b01      	ldr	r3, [sp, #4]
    4f98:	2b1b      	cmp	r3, #27
    4f9a:	d832      	bhi.n	5002 <getSelectorConfig+0x10a>
    4f9c:	9b01      	ldr	r3, [sp, #4]
    4f9e:	2b19      	cmp	r3, #25
    4fa0:	d003      	beq.n	4faa <getSelectorConfig+0xb2>
    4fa2:	9b01      	ldr	r3, [sp, #4]
    4fa4:	2b1a      	cmp	r3, #26
    4fa6:	d00e      	beq.n	4fc6 <getSelectorConfig+0xce>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->HCCR & SCG_HCCR_SCS_MASK) >> SCG_HCCR_SCS_SHIFT];
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    4fa8:	e02b      	b.n	5002 <getSelectorConfig+0x10a>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->RCCR & SCG_RCCR_SCS_MASK) >> SCG_RCCR_SCS_SHIFT];
    4faa:	4b1a      	ldr	r3, [pc, #104]	; (5014 <getSelectorConfig+0x11c>)
    4fac:	695b      	ldr	r3, [r3, #20]
    4fae:	0e1b      	lsrs	r3, r3, #24
    4fb0:	f003 030f 	and.w	r3, r3, #15
    4fb4:	4a18      	ldr	r2, [pc, #96]	; (5018 <getSelectorConfig+0x120>)
    4fb6:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    4fba:	4915      	ldr	r1, [pc, #84]	; (5010 <getSelectorConfig+0x118>)
    4fbc:	9b04      	ldr	r3, [sp, #16]
    4fbe:	00db      	lsls	r3, r3, #3
    4fc0:	440b      	add	r3, r1
    4fc2:	605a      	str	r2, [r3, #4]
                break;
    4fc4:	e01e      	b.n	5004 <getSelectorConfig+0x10c>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->VCCR & SCG_VCCR_SCS_MASK) >> SCG_VCCR_SCS_SHIFT];
    4fc6:	4b13      	ldr	r3, [pc, #76]	; (5014 <getSelectorConfig+0x11c>)
    4fc8:	699b      	ldr	r3, [r3, #24]
    4fca:	0e1b      	lsrs	r3, r3, #24
    4fcc:	f003 030f 	and.w	r3, r3, #15
    4fd0:	4a11      	ldr	r2, [pc, #68]	; (5018 <getSelectorConfig+0x120>)
    4fd2:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    4fd6:	490e      	ldr	r1, [pc, #56]	; (5010 <getSelectorConfig+0x118>)
    4fd8:	9b04      	ldr	r3, [sp, #16]
    4fda:	00db      	lsls	r3, r3, #3
    4fdc:	440b      	add	r3, r1
    4fde:	605a      	str	r2, [r3, #4]
                break;
    4fe0:	e010      	b.n	5004 <getSelectorConfig+0x10c>
                SelectorConfigurations[SelectorConfigIndex].Value = ClockSource[(IP_SCG->HCCR & SCG_HCCR_SCS_MASK) >> SCG_HCCR_SCS_SHIFT];
    4fe2:	4b0c      	ldr	r3, [pc, #48]	; (5014 <getSelectorConfig+0x11c>)
    4fe4:	69db      	ldr	r3, [r3, #28]
    4fe6:	0e1b      	lsrs	r3, r3, #24
    4fe8:	f003 030f 	and.w	r3, r3, #15
    4fec:	4a0a      	ldr	r2, [pc, #40]	; (5018 <getSelectorConfig+0x120>)
    4fee:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    4ff2:	4907      	ldr	r1, [pc, #28]	; (5010 <getSelectorConfig+0x118>)
    4ff4:	9b04      	ldr	r3, [sp, #16]
    4ff6:	00db      	lsls	r3, r3, #3
    4ff8:	440b      	add	r3, r1
    4ffa:	605a      	str	r2, [r3, #4]
                break;
    4ffc:	e002      	b.n	5004 <getSelectorConfig+0x10c>
        }
    }
    4ffe:	bf00      	nop
    5000:	e000      	b.n	5004 <getSelectorConfig+0x10c>
                break;
    5002:	bf00      	nop

    return ReturnValue;
    5004:	9b05      	ldr	r3, [sp, #20]
}
    5006:	4618      	mov	r0, r3
    5008:	b006      	add	sp, #24
    500a:	4770      	bx	lr
    500c:	1fff8b9c 	.word	0x1fff8b9c
    5010:	1fff8c50 	.word	0x1fff8c50
    5014:	40064000 	.word	0x40064000
    5018:	00015b60 	.word	0x00015b60

0000501c <getCoreDividerConfig>:

static const Clock_Ip_DividerConfigType *getCoreDividerConfig(Clock_Ip_NameType Name)
{
    501c:	b086      	sub	sp, #24
    501e:	9001      	str	r0, [sp, #4]
    const Clock_Ip_DividerConfigType *ReturnValue = NULL_PTR;
    5020:	2300      	movs	r3, #0
    5022:	9305      	str	r3, [sp, #20]
    uint32 DividerConfigIndex = 0U;
    5024:	2300      	movs	r3, #0
    5026:	9304      	str	r3, [sp, #16]
    uint32 Index;

    switch(Name)
    5028:	9b01      	ldr	r3, [sp, #4]
    502a:	2b1f      	cmp	r3, #31
    502c:	d00f      	beq.n	504e <getCoreDividerConfig+0x32>
    502e:	9b01      	ldr	r3, [sp, #4]
    5030:	2b1f      	cmp	r3, #31
    5032:	d80f      	bhi.n	5054 <getCoreDividerConfig+0x38>
    5034:	9b01      	ldr	r3, [sp, #4]
    5036:	2b1d      	cmp	r3, #29
    5038:	d003      	beq.n	5042 <getCoreDividerConfig+0x26>
    503a:	9b01      	ldr	r3, [sp, #4]
    503c:	2b1e      	cmp	r3, #30
    503e:	d003      	beq.n	5048 <getCoreDividerConfig+0x2c>
            DividerConfigIndex = 2U;
            break;
#endif
            default:
                /* Invalid clock name */
                break;
    5040:	e008      	b.n	5054 <getCoreDividerConfig+0x38>
            DividerConfigIndex = 0U;
    5042:	2300      	movs	r3, #0
    5044:	9304      	str	r3, [sp, #16]
            break;
    5046:	e006      	b.n	5056 <getCoreDividerConfig+0x3a>
            DividerConfigIndex = 1U;
    5048:	2301      	movs	r3, #1
    504a:	9304      	str	r3, [sp, #16]
            break;
    504c:	e003      	b.n	5056 <getCoreDividerConfig+0x3a>
            DividerConfigIndex = 2U;
    504e:	2302      	movs	r3, #2
    5050:	9304      	str	r3, [sp, #16]
            break;
    5052:	e000      	b.n	5056 <getCoreDividerConfig+0x3a>
                break;
    5054:	bf00      	nop
    }


    if (Clock_Ip_apConfig != NULL_PTR)
    5056:	4b41      	ldr	r3, [pc, #260]	; (515c <getCoreDividerConfig+0x140>)
    5058:	681b      	ldr	r3, [r3, #0]
    505a:	2b00      	cmp	r3, #0
    505c:	d026      	beq.n	50ac <getCoreDividerConfig+0x90>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    505e:	2300      	movs	r3, #0
    5060:	9303      	str	r3, [sp, #12]
    5062:	e01c      	b.n	509e <getCoreDividerConfig+0x82>
        {
            if (Clock_Ip_apConfig->Dividers[Index].Name == Name)
    5064:	4b3d      	ldr	r3, [pc, #244]	; (515c <getCoreDividerConfig+0x140>)
    5066:	6819      	ldr	r1, [r3, #0]
    5068:	9a03      	ldr	r2, [sp, #12]
    506a:	4613      	mov	r3, r2
    506c:	005b      	lsls	r3, r3, #1
    506e:	4413      	add	r3, r2
    5070:	009b      	lsls	r3, r3, #2
    5072:	440b      	add	r3, r1
    5074:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    5078:	681b      	ldr	r3, [r3, #0]
    507a:	9a01      	ldr	r2, [sp, #4]
    507c:	429a      	cmp	r2, r3
    507e:	d10b      	bne.n	5098 <getCoreDividerConfig+0x7c>
            {
                ReturnValue = &Clock_Ip_apConfig->Dividers[Index];
    5080:	4b36      	ldr	r3, [pc, #216]	; (515c <getCoreDividerConfig+0x140>)
    5082:	6819      	ldr	r1, [r3, #0]
    5084:	9a03      	ldr	r2, [sp, #12]
    5086:	4613      	mov	r3, r2
    5088:	005b      	lsls	r3, r3, #1
    508a:	4413      	add	r3, r2
    508c:	009b      	lsls	r3, r3, #2
    508e:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    5092:	440b      	add	r3, r1
    5094:	9305      	str	r3, [sp, #20]
                break;
    5096:	e009      	b.n	50ac <getCoreDividerConfig+0x90>
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    5098:	9b03      	ldr	r3, [sp, #12]
    509a:	3301      	adds	r3, #1
    509c:	9303      	str	r3, [sp, #12]
    509e:	4b2f      	ldr	r3, [pc, #188]	; (515c <getCoreDividerConfig+0x140>)
    50a0:	681b      	ldr	r3, [r3, #0]
    50a2:	7b1b      	ldrb	r3, [r3, #12]
    50a4:	461a      	mov	r2, r3
    50a6:	9b03      	ldr	r3, [sp, #12]
    50a8:	4293      	cmp	r3, r2
    50aa:	d3db      	bcc.n	5064 <getCoreDividerConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    50ac:	9b05      	ldr	r3, [sp, #20]
    50ae:	2b00      	cmp	r3, #0
    50b0:	d14d      	bne.n	514e <getCoreDividerConfig+0x132>
    {
        ReturnValue = &CoreDividerConfigurations[DividerConfigIndex];
    50b2:	9a04      	ldr	r2, [sp, #16]
    50b4:	4613      	mov	r3, r2
    50b6:	005b      	lsls	r3, r3, #1
    50b8:	4413      	add	r3, r2
    50ba:	009b      	lsls	r3, r3, #2
    50bc:	4a28      	ldr	r2, [pc, #160]	; (5160 <getCoreDividerConfig+0x144>)
    50be:	4413      	add	r3, r2
    50c0:	9305      	str	r3, [sp, #20]
        CoreDividerConfigurations[DividerConfigIndex].Name = Name;
    50c2:	4927      	ldr	r1, [pc, #156]	; (5160 <getCoreDividerConfig+0x144>)
    50c4:	9a04      	ldr	r2, [sp, #16]
    50c6:	4613      	mov	r3, r2
    50c8:	005b      	lsls	r3, r3, #1
    50ca:	4413      	add	r3, r2
    50cc:	009b      	lsls	r3, r3, #2
    50ce:	440b      	add	r3, r1
    50d0:	9a01      	ldr	r2, [sp, #4]
    50d2:	601a      	str	r2, [r3, #0]
        switch(Name)
    50d4:	9b01      	ldr	r3, [sp, #4]
    50d6:	2b1f      	cmp	r3, #31
    50d8:	d029      	beq.n	512e <getCoreDividerConfig+0x112>
    50da:	9b01      	ldr	r3, [sp, #4]
    50dc:	2b1f      	cmp	r3, #31
    50de:	d838      	bhi.n	5152 <getCoreDividerConfig+0x136>
    50e0:	9b01      	ldr	r3, [sp, #4]
    50e2:	2b1d      	cmp	r3, #29
    50e4:	d003      	beq.n	50ee <getCoreDividerConfig+0xd2>
    50e6:	9b01      	ldr	r3, [sp, #4]
    50e8:	2b1e      	cmp	r3, #30
    50ea:	d010      	beq.n	510e <getCoreDividerConfig+0xf2>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVCORE_MASK) >> SCG_HCCR_DIVCORE_SHIFT) + 1U;
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    50ec:	e031      	b.n	5152 <getCoreDividerConfig+0x136>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->RCCR & SCG_RCCR_DIVCORE_MASK) >> SCG_RCCR_DIVCORE_SHIFT) + 1U;
    50ee:	4b1d      	ldr	r3, [pc, #116]	; (5164 <getCoreDividerConfig+0x148>)
    50f0:	695b      	ldr	r3, [r3, #20]
    50f2:	0c1b      	lsrs	r3, r3, #16
    50f4:	f003 030f 	and.w	r3, r3, #15
    50f8:	1c59      	adds	r1, r3, #1
    50fa:	4819      	ldr	r0, [pc, #100]	; (5160 <getCoreDividerConfig+0x144>)
    50fc:	9a04      	ldr	r2, [sp, #16]
    50fe:	4613      	mov	r3, r2
    5100:	005b      	lsls	r3, r3, #1
    5102:	4413      	add	r3, r2
    5104:	009b      	lsls	r3, r3, #2
    5106:	4403      	add	r3, r0
    5108:	3304      	adds	r3, #4
    510a:	6019      	str	r1, [r3, #0]
                break;
    510c:	e022      	b.n	5154 <getCoreDividerConfig+0x138>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->VCCR & SCG_VCCR_DIVCORE_MASK) >> SCG_VCCR_DIVCORE_SHIFT) + 1U;
    510e:	4b15      	ldr	r3, [pc, #84]	; (5164 <getCoreDividerConfig+0x148>)
    5110:	699b      	ldr	r3, [r3, #24]
    5112:	0c1b      	lsrs	r3, r3, #16
    5114:	f003 030f 	and.w	r3, r3, #15
    5118:	1c59      	adds	r1, r3, #1
    511a:	4811      	ldr	r0, [pc, #68]	; (5160 <getCoreDividerConfig+0x144>)
    511c:	9a04      	ldr	r2, [sp, #16]
    511e:	4613      	mov	r3, r2
    5120:	005b      	lsls	r3, r3, #1
    5122:	4413      	add	r3, r2
    5124:	009b      	lsls	r3, r3, #2
    5126:	4403      	add	r3, r0
    5128:	3304      	adds	r3, #4
    512a:	6019      	str	r1, [r3, #0]
                break;
    512c:	e012      	b.n	5154 <getCoreDividerConfig+0x138>
                CoreDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVCORE_MASK) >> SCG_HCCR_DIVCORE_SHIFT) + 1U;
    512e:	4b0d      	ldr	r3, [pc, #52]	; (5164 <getCoreDividerConfig+0x148>)
    5130:	69db      	ldr	r3, [r3, #28]
    5132:	0c1b      	lsrs	r3, r3, #16
    5134:	f003 030f 	and.w	r3, r3, #15
    5138:	1c59      	adds	r1, r3, #1
    513a:	4809      	ldr	r0, [pc, #36]	; (5160 <getCoreDividerConfig+0x144>)
    513c:	9a04      	ldr	r2, [sp, #16]
    513e:	4613      	mov	r3, r2
    5140:	005b      	lsls	r3, r3, #1
    5142:	4413      	add	r3, r2
    5144:	009b      	lsls	r3, r3, #2
    5146:	4403      	add	r3, r0
    5148:	3304      	adds	r3, #4
    514a:	6019      	str	r1, [r3, #0]
                break;
    514c:	e002      	b.n	5154 <getCoreDividerConfig+0x138>
        }
    }
    514e:	bf00      	nop
    5150:	e000      	b.n	5154 <getCoreDividerConfig+0x138>
                break;
    5152:	bf00      	nop

    return ReturnValue;
    5154:	9b05      	ldr	r3, [sp, #20]
}
    5156:	4618      	mov	r0, r3
    5158:	b006      	add	sp, #24
    515a:	4770      	bx	lr
    515c:	1fff8b9c 	.word	0x1fff8b9c
    5160:	1fff8c68 	.word	0x1fff8c68
    5164:	40064000 	.word	0x40064000

00005168 <getBusDividerConfig>:


static const Clock_Ip_DividerConfigType *getBusDividerConfig(Clock_Ip_NameType Name)
{
    5168:	b086      	sub	sp, #24
    516a:	9001      	str	r0, [sp, #4]
    const Clock_Ip_DividerConfigType *ReturnValue = NULL_PTR;
    516c:	2300      	movs	r3, #0
    516e:	9305      	str	r3, [sp, #20]
    uint32 DividerConfigIndex = 0U;
    5170:	2300      	movs	r3, #0
    5172:	9304      	str	r3, [sp, #16]
    uint32 Index;

    switch(Name)
    5174:	9b01      	ldr	r3, [sp, #4]
    5176:	2b23      	cmp	r3, #35	; 0x23
    5178:	d00f      	beq.n	519a <getBusDividerConfig+0x32>
    517a:	9b01      	ldr	r3, [sp, #4]
    517c:	2b23      	cmp	r3, #35	; 0x23
    517e:	d80f      	bhi.n	51a0 <getBusDividerConfig+0x38>
    5180:	9b01      	ldr	r3, [sp, #4]
    5182:	2b21      	cmp	r3, #33	; 0x21
    5184:	d003      	beq.n	518e <getBusDividerConfig+0x26>
    5186:	9b01      	ldr	r3, [sp, #4]
    5188:	2b22      	cmp	r3, #34	; 0x22
    518a:	d003      	beq.n	5194 <getBusDividerConfig+0x2c>
            DividerConfigIndex = 2U;
            break;
#endif
            default:
                /* Invalid clock name */
                break;
    518c:	e008      	b.n	51a0 <getBusDividerConfig+0x38>
            DividerConfigIndex = 0U;
    518e:	2300      	movs	r3, #0
    5190:	9304      	str	r3, [sp, #16]
            break;
    5192:	e006      	b.n	51a2 <getBusDividerConfig+0x3a>
            DividerConfigIndex = 1U;
    5194:	2301      	movs	r3, #1
    5196:	9304      	str	r3, [sp, #16]
            break;
    5198:	e003      	b.n	51a2 <getBusDividerConfig+0x3a>
            DividerConfigIndex = 2U;
    519a:	2302      	movs	r3, #2
    519c:	9304      	str	r3, [sp, #16]
            break;
    519e:	e000      	b.n	51a2 <getBusDividerConfig+0x3a>
                break;
    51a0:	bf00      	nop

    }


    if (Clock_Ip_apConfig != NULL_PTR)
    51a2:	4b41      	ldr	r3, [pc, #260]	; (52a8 <getBusDividerConfig+0x140>)
    51a4:	681b      	ldr	r3, [r3, #0]
    51a6:	2b00      	cmp	r3, #0
    51a8:	d026      	beq.n	51f8 <getBusDividerConfig+0x90>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    51aa:	2300      	movs	r3, #0
    51ac:	9303      	str	r3, [sp, #12]
    51ae:	e01c      	b.n	51ea <getBusDividerConfig+0x82>
        {
            if (Clock_Ip_apConfig->Dividers[Index].Name == Name)
    51b0:	4b3d      	ldr	r3, [pc, #244]	; (52a8 <getBusDividerConfig+0x140>)
    51b2:	6819      	ldr	r1, [r3, #0]
    51b4:	9a03      	ldr	r2, [sp, #12]
    51b6:	4613      	mov	r3, r2
    51b8:	005b      	lsls	r3, r3, #1
    51ba:	4413      	add	r3, r2
    51bc:	009b      	lsls	r3, r3, #2
    51be:	440b      	add	r3, r1
    51c0:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    51c4:	681b      	ldr	r3, [r3, #0]
    51c6:	9a01      	ldr	r2, [sp, #4]
    51c8:	429a      	cmp	r2, r3
    51ca:	d10b      	bne.n	51e4 <getBusDividerConfig+0x7c>
            {
                ReturnValue = &Clock_Ip_apConfig->Dividers[Index];
    51cc:	4b36      	ldr	r3, [pc, #216]	; (52a8 <getBusDividerConfig+0x140>)
    51ce:	6819      	ldr	r1, [r3, #0]
    51d0:	9a03      	ldr	r2, [sp, #12]
    51d2:	4613      	mov	r3, r2
    51d4:	005b      	lsls	r3, r3, #1
    51d6:	4413      	add	r3, r2
    51d8:	009b      	lsls	r3, r3, #2
    51da:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    51de:	440b      	add	r3, r1
    51e0:	9305      	str	r3, [sp, #20]
                break;
    51e2:	e009      	b.n	51f8 <getBusDividerConfig+0x90>
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    51e4:	9b03      	ldr	r3, [sp, #12]
    51e6:	3301      	adds	r3, #1
    51e8:	9303      	str	r3, [sp, #12]
    51ea:	4b2f      	ldr	r3, [pc, #188]	; (52a8 <getBusDividerConfig+0x140>)
    51ec:	681b      	ldr	r3, [r3, #0]
    51ee:	7b1b      	ldrb	r3, [r3, #12]
    51f0:	461a      	mov	r2, r3
    51f2:	9b03      	ldr	r3, [sp, #12]
    51f4:	4293      	cmp	r3, r2
    51f6:	d3db      	bcc.n	51b0 <getBusDividerConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    51f8:	9b05      	ldr	r3, [sp, #20]
    51fa:	2b00      	cmp	r3, #0
    51fc:	d14d      	bne.n	529a <getBusDividerConfig+0x132>
    {
        ReturnValue = &BusDividerConfigurations[DividerConfigIndex];
    51fe:	9a04      	ldr	r2, [sp, #16]
    5200:	4613      	mov	r3, r2
    5202:	005b      	lsls	r3, r3, #1
    5204:	4413      	add	r3, r2
    5206:	009b      	lsls	r3, r3, #2
    5208:	4a28      	ldr	r2, [pc, #160]	; (52ac <getBusDividerConfig+0x144>)
    520a:	4413      	add	r3, r2
    520c:	9305      	str	r3, [sp, #20]
        BusDividerConfigurations[DividerConfigIndex].Name = Name;
    520e:	4927      	ldr	r1, [pc, #156]	; (52ac <getBusDividerConfig+0x144>)
    5210:	9a04      	ldr	r2, [sp, #16]
    5212:	4613      	mov	r3, r2
    5214:	005b      	lsls	r3, r3, #1
    5216:	4413      	add	r3, r2
    5218:	009b      	lsls	r3, r3, #2
    521a:	440b      	add	r3, r1
    521c:	9a01      	ldr	r2, [sp, #4]
    521e:	601a      	str	r2, [r3, #0]
        switch(Name)
    5220:	9b01      	ldr	r3, [sp, #4]
    5222:	2b23      	cmp	r3, #35	; 0x23
    5224:	d029      	beq.n	527a <getBusDividerConfig+0x112>
    5226:	9b01      	ldr	r3, [sp, #4]
    5228:	2b23      	cmp	r3, #35	; 0x23
    522a:	d838      	bhi.n	529e <getBusDividerConfig+0x136>
    522c:	9b01      	ldr	r3, [sp, #4]
    522e:	2b21      	cmp	r3, #33	; 0x21
    5230:	d003      	beq.n	523a <getBusDividerConfig+0xd2>
    5232:	9b01      	ldr	r3, [sp, #4]
    5234:	2b22      	cmp	r3, #34	; 0x22
    5236:	d010      	beq.n	525a <getBusDividerConfig+0xf2>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVBUS_MASK) >> SCG_HCCR_DIVBUS_SHIFT) + 1U;
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    5238:	e031      	b.n	529e <getBusDividerConfig+0x136>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->RCCR & SCG_RCCR_DIVBUS_MASK) >> SCG_RCCR_DIVBUS_SHIFT) + 1U;
    523a:	4b1d      	ldr	r3, [pc, #116]	; (52b0 <getBusDividerConfig+0x148>)
    523c:	695b      	ldr	r3, [r3, #20]
    523e:	091b      	lsrs	r3, r3, #4
    5240:	f003 030f 	and.w	r3, r3, #15
    5244:	1c59      	adds	r1, r3, #1
    5246:	4819      	ldr	r0, [pc, #100]	; (52ac <getBusDividerConfig+0x144>)
    5248:	9a04      	ldr	r2, [sp, #16]
    524a:	4613      	mov	r3, r2
    524c:	005b      	lsls	r3, r3, #1
    524e:	4413      	add	r3, r2
    5250:	009b      	lsls	r3, r3, #2
    5252:	4403      	add	r3, r0
    5254:	3304      	adds	r3, #4
    5256:	6019      	str	r1, [r3, #0]
                break;
    5258:	e022      	b.n	52a0 <getBusDividerConfig+0x138>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->VCCR & SCG_VCCR_DIVBUS_MASK) >> SCG_VCCR_DIVBUS_SHIFT) + 1U;
    525a:	4b15      	ldr	r3, [pc, #84]	; (52b0 <getBusDividerConfig+0x148>)
    525c:	699b      	ldr	r3, [r3, #24]
    525e:	091b      	lsrs	r3, r3, #4
    5260:	f003 030f 	and.w	r3, r3, #15
    5264:	1c59      	adds	r1, r3, #1
    5266:	4811      	ldr	r0, [pc, #68]	; (52ac <getBusDividerConfig+0x144>)
    5268:	9a04      	ldr	r2, [sp, #16]
    526a:	4613      	mov	r3, r2
    526c:	005b      	lsls	r3, r3, #1
    526e:	4413      	add	r3, r2
    5270:	009b      	lsls	r3, r3, #2
    5272:	4403      	add	r3, r0
    5274:	3304      	adds	r3, #4
    5276:	6019      	str	r1, [r3, #0]
                break;
    5278:	e012      	b.n	52a0 <getBusDividerConfig+0x138>
                BusDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVBUS_MASK) >> SCG_HCCR_DIVBUS_SHIFT) + 1U;
    527a:	4b0d      	ldr	r3, [pc, #52]	; (52b0 <getBusDividerConfig+0x148>)
    527c:	69db      	ldr	r3, [r3, #28]
    527e:	091b      	lsrs	r3, r3, #4
    5280:	f003 030f 	and.w	r3, r3, #15
    5284:	1c59      	adds	r1, r3, #1
    5286:	4809      	ldr	r0, [pc, #36]	; (52ac <getBusDividerConfig+0x144>)
    5288:	9a04      	ldr	r2, [sp, #16]
    528a:	4613      	mov	r3, r2
    528c:	005b      	lsls	r3, r3, #1
    528e:	4413      	add	r3, r2
    5290:	009b      	lsls	r3, r3, #2
    5292:	4403      	add	r3, r0
    5294:	3304      	adds	r3, #4
    5296:	6019      	str	r1, [r3, #0]
                break;
    5298:	e002      	b.n	52a0 <getBusDividerConfig+0x138>
        }
    }
    529a:	bf00      	nop
    529c:	e000      	b.n	52a0 <getBusDividerConfig+0x138>
                break;
    529e:	bf00      	nop

    return ReturnValue;
    52a0:	9b05      	ldr	r3, [sp, #20]
}
    52a2:	4618      	mov	r0, r3
    52a4:	b006      	add	sp, #24
    52a6:	4770      	bx	lr
    52a8:	1fff8b9c 	.word	0x1fff8b9c
    52ac:	1fff8c8c 	.word	0x1fff8c8c
    52b0:	40064000 	.word	0x40064000

000052b4 <getSlowDividerConfig>:

static const Clock_Ip_DividerConfigType *getSlowDividerConfig(Clock_Ip_NameType Name)
{
    52b4:	b086      	sub	sp, #24
    52b6:	9001      	str	r0, [sp, #4]
    const Clock_Ip_DividerConfigType *ReturnValue = NULL_PTR;
    52b8:	2300      	movs	r3, #0
    52ba:	9305      	str	r3, [sp, #20]
    uint32 DividerConfigIndex = 0U;
    52bc:	2300      	movs	r3, #0
    52be:	9304      	str	r3, [sp, #16]
    uint32 Index;

    switch(Name)
    52c0:	9b01      	ldr	r3, [sp, #4]
    52c2:	2b27      	cmp	r3, #39	; 0x27
    52c4:	d00f      	beq.n	52e6 <getSlowDividerConfig+0x32>
    52c6:	9b01      	ldr	r3, [sp, #4]
    52c8:	2b27      	cmp	r3, #39	; 0x27
    52ca:	d80f      	bhi.n	52ec <getSlowDividerConfig+0x38>
    52cc:	9b01      	ldr	r3, [sp, #4]
    52ce:	2b25      	cmp	r3, #37	; 0x25
    52d0:	d003      	beq.n	52da <getSlowDividerConfig+0x26>
    52d2:	9b01      	ldr	r3, [sp, #4]
    52d4:	2b26      	cmp	r3, #38	; 0x26
    52d6:	d003      	beq.n	52e0 <getSlowDividerConfig+0x2c>
            DividerConfigIndex = 2U;
            break;
#endif
            default:
                /* Invalid clock name */
                break;
    52d8:	e008      	b.n	52ec <getSlowDividerConfig+0x38>
            DividerConfigIndex = 0U;
    52da:	2300      	movs	r3, #0
    52dc:	9304      	str	r3, [sp, #16]
            break;
    52de:	e006      	b.n	52ee <getSlowDividerConfig+0x3a>
            DividerConfigIndex = 1U;
    52e0:	2301      	movs	r3, #1
    52e2:	9304      	str	r3, [sp, #16]
            break;
    52e4:	e003      	b.n	52ee <getSlowDividerConfig+0x3a>
            DividerConfigIndex = 2U;
    52e6:	2302      	movs	r3, #2
    52e8:	9304      	str	r3, [sp, #16]
            break;
    52ea:	e000      	b.n	52ee <getSlowDividerConfig+0x3a>
                break;
    52ec:	bf00      	nop

    }


    if (Clock_Ip_apConfig != NULL_PTR)
    52ee:	4b40      	ldr	r3, [pc, #256]	; (53f0 <getSlowDividerConfig+0x13c>)
    52f0:	681b      	ldr	r3, [r3, #0]
    52f2:	2b00      	cmp	r3, #0
    52f4:	d026      	beq.n	5344 <getSlowDividerConfig+0x90>
    {
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    52f6:	2300      	movs	r3, #0
    52f8:	9303      	str	r3, [sp, #12]
    52fa:	e01c      	b.n	5336 <getSlowDividerConfig+0x82>
        {
            if (Clock_Ip_apConfig->Dividers[Index].Name == Name)
    52fc:	4b3c      	ldr	r3, [pc, #240]	; (53f0 <getSlowDividerConfig+0x13c>)
    52fe:	6819      	ldr	r1, [r3, #0]
    5300:	9a03      	ldr	r2, [sp, #12]
    5302:	4613      	mov	r3, r2
    5304:	005b      	lsls	r3, r3, #1
    5306:	4413      	add	r3, r2
    5308:	009b      	lsls	r3, r3, #2
    530a:	440b      	add	r3, r1
    530c:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    5310:	681b      	ldr	r3, [r3, #0]
    5312:	9a01      	ldr	r2, [sp, #4]
    5314:	429a      	cmp	r2, r3
    5316:	d10b      	bne.n	5330 <getSlowDividerConfig+0x7c>
            {
                ReturnValue = &Clock_Ip_apConfig->Dividers[Index];
    5318:	4b35      	ldr	r3, [pc, #212]	; (53f0 <getSlowDividerConfig+0x13c>)
    531a:	6819      	ldr	r1, [r3, #0]
    531c:	9a03      	ldr	r2, [sp, #12]
    531e:	4613      	mov	r3, r2
    5320:	005b      	lsls	r3, r3, #1
    5322:	4413      	add	r3, r2
    5324:	009b      	lsls	r3, r3, #2
    5326:	f503 73a4 	add.w	r3, r3, #328	; 0x148
    532a:	440b      	add	r3, r1
    532c:	9305      	str	r3, [sp, #20]
                break;
    532e:	e009      	b.n	5344 <getSlowDividerConfig+0x90>
        for (Index = 0U; Index < Clock_Ip_apConfig->DividersCount; Index++)
    5330:	9b03      	ldr	r3, [sp, #12]
    5332:	3301      	adds	r3, #1
    5334:	9303      	str	r3, [sp, #12]
    5336:	4b2e      	ldr	r3, [pc, #184]	; (53f0 <getSlowDividerConfig+0x13c>)
    5338:	681b      	ldr	r3, [r3, #0]
    533a:	7b1b      	ldrb	r3, [r3, #12]
    533c:	461a      	mov	r2, r3
    533e:	9b03      	ldr	r3, [sp, #12]
    5340:	4293      	cmp	r3, r2
    5342:	d3db      	bcc.n	52fc <getSlowDividerConfig+0x48>
            }
        }
    }

    /* Element is not under mcu control */
    if (ReturnValue == NULL_PTR)
    5344:	9b05      	ldr	r3, [sp, #20]
    5346:	2b00      	cmp	r3, #0
    5348:	d14a      	bne.n	53e0 <getSlowDividerConfig+0x12c>
    {
        ReturnValue = &SlowDividerConfigurations[DividerConfigIndex];
    534a:	9a04      	ldr	r2, [sp, #16]
    534c:	4613      	mov	r3, r2
    534e:	005b      	lsls	r3, r3, #1
    5350:	4413      	add	r3, r2
    5352:	009b      	lsls	r3, r3, #2
    5354:	4a27      	ldr	r2, [pc, #156]	; (53f4 <getSlowDividerConfig+0x140>)
    5356:	4413      	add	r3, r2
    5358:	9305      	str	r3, [sp, #20]
        SlowDividerConfigurations[DividerConfigIndex].Name = Name;
    535a:	4926      	ldr	r1, [pc, #152]	; (53f4 <getSlowDividerConfig+0x140>)
    535c:	9a04      	ldr	r2, [sp, #16]
    535e:	4613      	mov	r3, r2
    5360:	005b      	lsls	r3, r3, #1
    5362:	4413      	add	r3, r2
    5364:	009b      	lsls	r3, r3, #2
    5366:	440b      	add	r3, r1
    5368:	9a01      	ldr	r2, [sp, #4]
    536a:	601a      	str	r2, [r3, #0]
        switch(Name)
    536c:	9b01      	ldr	r3, [sp, #4]
    536e:	2b27      	cmp	r3, #39	; 0x27
    5370:	d027      	beq.n	53c2 <getSlowDividerConfig+0x10e>
    5372:	9b01      	ldr	r3, [sp, #4]
    5374:	2b27      	cmp	r3, #39	; 0x27
    5376:	d835      	bhi.n	53e4 <getSlowDividerConfig+0x130>
    5378:	9b01      	ldr	r3, [sp, #4]
    537a:	2b25      	cmp	r3, #37	; 0x25
    537c:	d003      	beq.n	5386 <getSlowDividerConfig+0xd2>
    537e:	9b01      	ldr	r3, [sp, #4]
    5380:	2b26      	cmp	r3, #38	; 0x26
    5382:	d00f      	beq.n	53a4 <getSlowDividerConfig+0xf0>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVSLOW_MASK) >> SCG_HCCR_DIVSLOW_SHIFT) + 1U;
                break;
#endif
            default:
                /* Invalid clock name */
                break;
    5384:	e02e      	b.n	53e4 <getSlowDividerConfig+0x130>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->RCCR & SCG_RCCR_DIVSLOW_MASK) >> SCG_RCCR_DIVSLOW_SHIFT) + 1U;
    5386:	4b1c      	ldr	r3, [pc, #112]	; (53f8 <getSlowDividerConfig+0x144>)
    5388:	695b      	ldr	r3, [r3, #20]
    538a:	f003 030f 	and.w	r3, r3, #15
    538e:	1c59      	adds	r1, r3, #1
    5390:	4818      	ldr	r0, [pc, #96]	; (53f4 <getSlowDividerConfig+0x140>)
    5392:	9a04      	ldr	r2, [sp, #16]
    5394:	4613      	mov	r3, r2
    5396:	005b      	lsls	r3, r3, #1
    5398:	4413      	add	r3, r2
    539a:	009b      	lsls	r3, r3, #2
    539c:	4403      	add	r3, r0
    539e:	3304      	adds	r3, #4
    53a0:	6019      	str	r1, [r3, #0]
                break;
    53a2:	e020      	b.n	53e6 <getSlowDividerConfig+0x132>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->VCCR & SCG_VCCR_DIVSLOW_MASK) >> SCG_VCCR_DIVSLOW_SHIFT) + 1U;
    53a4:	4b14      	ldr	r3, [pc, #80]	; (53f8 <getSlowDividerConfig+0x144>)
    53a6:	699b      	ldr	r3, [r3, #24]
    53a8:	f003 030f 	and.w	r3, r3, #15
    53ac:	1c59      	adds	r1, r3, #1
    53ae:	4811      	ldr	r0, [pc, #68]	; (53f4 <getSlowDividerConfig+0x140>)
    53b0:	9a04      	ldr	r2, [sp, #16]
    53b2:	4613      	mov	r3, r2
    53b4:	005b      	lsls	r3, r3, #1
    53b6:	4413      	add	r3, r2
    53b8:	009b      	lsls	r3, r3, #2
    53ba:	4403      	add	r3, r0
    53bc:	3304      	adds	r3, #4
    53be:	6019      	str	r1, [r3, #0]
                break;
    53c0:	e011      	b.n	53e6 <getSlowDividerConfig+0x132>
                SlowDividerConfigurations[DividerConfigIndex].Value = ((IP_SCG->HCCR & SCG_HCCR_DIVSLOW_MASK) >> SCG_HCCR_DIVSLOW_SHIFT) + 1U;
    53c2:	4b0d      	ldr	r3, [pc, #52]	; (53f8 <getSlowDividerConfig+0x144>)
    53c4:	69db      	ldr	r3, [r3, #28]
    53c6:	f003 030f 	and.w	r3, r3, #15
    53ca:	1c59      	adds	r1, r3, #1
    53cc:	4809      	ldr	r0, [pc, #36]	; (53f4 <getSlowDividerConfig+0x140>)
    53ce:	9a04      	ldr	r2, [sp, #16]
    53d0:	4613      	mov	r3, r2
    53d2:	005b      	lsls	r3, r3, #1
    53d4:	4413      	add	r3, r2
    53d6:	009b      	lsls	r3, r3, #2
    53d8:	4403      	add	r3, r0
    53da:	3304      	adds	r3, #4
    53dc:	6019      	str	r1, [r3, #0]
                break;
    53de:	e002      	b.n	53e6 <getSlowDividerConfig+0x132>
        }
    }
    53e0:	bf00      	nop
    53e2:	e000      	b.n	53e6 <getSlowDividerConfig+0x132>
                break;
    53e4:	bf00      	nop

    return ReturnValue;
    53e6:	9b05      	ldr	r3, [sp, #20]
}
    53e8:	4618      	mov	r0, r3
    53ea:	b006      	add	sp, #24
    53ec:	4770      	bx	lr
    53ee:	bf00      	nop
    53f0:	1fff8b9c 	.word	0x1fff8b9c
    53f4:	1fff8cb0 	.word	0x1fff8cb0
    53f8:	40064000 	.word	0x40064000

000053fc <Clock_Ip_ClockInitializeObjects>:

/* Initialize objects for clock */
static void Clock_Ip_ClockInitializeObjects(Clock_Ip_ClockConfigType const * Config)
{
    53fc:	b500      	push	{lr}
    53fe:	b083      	sub	sp, #12
    5400:	9001      	str	r0, [sp, #4]
    if (FALSE == Clock_Ip_bObjsAreInitialized)
    5402:	4b64      	ldr	r3, [pc, #400]	; (5594 <Clock_Ip_ClockInitializeObjects+0x198>)
    5404:	781b      	ldrb	r3, [r3, #0]
    5406:	f083 0301 	eor.w	r3, r3, #1
    540a:	b2db      	uxtb	r3, r3
    540c:	2b00      	cmp	r3, #0
    540e:	d05b      	beq.n	54c8 <Clock_Ip_ClockInitializeObjects+0xcc>
    {
        Clock_Ip_bObjsAreInitialized = TRUE;
    5410:	4b60      	ldr	r3, [pc, #384]	; (5594 <Clock_Ip_ClockInitializeObjects+0x198>)
    5412:	2201      	movs	r2, #1
    5414:	701a      	strb	r2, [r3, #0]

    #if defined(CLOCK_IP_HAS_SPLL_CLK)
        Clock_Ip_pxSpllClock = &Clock_Ip_axPllCallbacks[Clock_Ip_au8PllCallbackIndex[CLOCK_IP_SYS_PLL]];
    5416:	4b60      	ldr	r3, [pc, #384]	; (5598 <Clock_Ip_ClockInitializeObjects+0x19c>)
    5418:	785b      	ldrb	r3, [r3, #1]
    541a:	461a      	mov	r2, r3
    541c:	4613      	mov	r3, r2
    541e:	009b      	lsls	r3, r3, #2
    5420:	4413      	add	r3, r2
    5422:	009b      	lsls	r3, r3, #2
    5424:	4a5d      	ldr	r2, [pc, #372]	; (559c <Clock_Ip_ClockInitializeObjects+0x1a0>)
    5426:	4413      	add	r3, r2
    5428:	4a5d      	ldr	r2, [pc, #372]	; (55a0 <Clock_Ip_ClockInitializeObjects+0x1a4>)
    542a:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxSoscClock = &Clock_Ip_axExtOscCallbacks[Clock_Ip_au8XoscCallbackIndex[CLOCK_IP_SYS_OSC]];
    542c:	4b5d      	ldr	r3, [pc, #372]	; (55a4 <Clock_Ip_ClockInitializeObjects+0x1a8>)
    542e:	785b      	ldrb	r3, [r3, #1]
    5430:	461a      	mov	r2, r3
    5432:	4613      	mov	r3, r2
    5434:	009b      	lsls	r3, r3, #2
    5436:	4413      	add	r3, r2
    5438:	009b      	lsls	r3, r3, #2
    543a:	4a5b      	ldr	r2, [pc, #364]	; (55a8 <Clock_Ip_ClockInitializeObjects+0x1ac>)
    543c:	4413      	add	r3, r2
    543e:	4a5b      	ldr	r2, [pc, #364]	; (55ac <Clock_Ip_ClockInitializeObjects+0x1b0>)
    5440:	6013      	str	r3, [r2, #0]

        Clock_Ip_pxFircClock = &Clock_Ip_axIntOscCallbacks[Clock_Ip_au8IrcoscCallbackIndex[CLOCK_IP_FIRCOSC]];
    5442:	4b5b      	ldr	r3, [pc, #364]	; (55b0 <Clock_Ip_ClockInitializeObjects+0x1b4>)
    5444:	791b      	ldrb	r3, [r3, #4]
    5446:	461a      	mov	r2, r3
    5448:	4613      	mov	r3, r2
    544a:	005b      	lsls	r3, r3, #1
    544c:	4413      	add	r3, r2
    544e:	009b      	lsls	r3, r3, #2
    5450:	4a58      	ldr	r2, [pc, #352]	; (55b4 <Clock_Ip_ClockInitializeObjects+0x1b8>)
    5452:	4413      	add	r3, r2
    5454:	4a58      	ldr	r2, [pc, #352]	; (55b8 <Clock_Ip_ClockInitializeObjects+0x1bc>)
    5456:	6013      	str	r3, [r2, #0]

    #if defined(CLOCK_IP_HAS_FIRC_MON1_CLK) || defined(CLOCK_IP_HAS_FIRC_MON2_CLK)
        Clock_Ip_pxCmuFircMonitor = &Clock_Ip_axCmuCallbacks[Clock_Ip_au8CmuCallbackIndex[CLOCK_IP_CMU]];
    #endif

        Clock_Ip_pxScsRunClockSelector   = &Clock_Ip_axSelectorCallbacks[Clock_Ip_au8SelectorCallbackIndex[CLOCK_IP_SCS_RUN]];
    5458:	4b58      	ldr	r3, [pc, #352]	; (55bc <Clock_Ip_ClockInitializeObjects+0x1c0>)
    545a:	795b      	ldrb	r3, [r3, #5]
    545c:	00db      	lsls	r3, r3, #3
    545e:	4a58      	ldr	r2, [pc, #352]	; (55c0 <Clock_Ip_ClockInitializeObjects+0x1c4>)
    5460:	4413      	add	r3, r2
    5462:	4a58      	ldr	r2, [pc, #352]	; (55c4 <Clock_Ip_ClockInitializeObjects+0x1c8>)
    5464:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
        Clock_Ip_pxScsHsrunClockSelector = &Clock_Ip_axSelectorCallbacks[Clock_Ip_au8SelectorCallbackIndex[CLOCK_IP_SCS_HSRUN]];
    5466:	4b55      	ldr	r3, [pc, #340]	; (55bc <Clock_Ip_ClockInitializeObjects+0x1c0>)
    5468:	79db      	ldrb	r3, [r3, #7]
    546a:	00db      	lsls	r3, r3, #3
    546c:	4a54      	ldr	r2, [pc, #336]	; (55c0 <Clock_Ip_ClockInitializeObjects+0x1c4>)
    546e:	4413      	add	r3, r2
    5470:	4a55      	ldr	r2, [pc, #340]	; (55c8 <Clock_Ip_ClockInitializeObjects+0x1cc>)
    5472:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxCoreRunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVCORE_RUN]];
    5474:	4b55      	ldr	r3, [pc, #340]	; (55cc <Clock_Ip_ClockInitializeObjects+0x1d0>)
    5476:	799b      	ldrb	r3, [r3, #6]
    5478:	009b      	lsls	r3, r3, #2
    547a:	4a55      	ldr	r2, [pc, #340]	; (55d0 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    547c:	4413      	add	r3, r2
    547e:	4a55      	ldr	r2, [pc, #340]	; (55d4 <Clock_Ip_ClockInitializeObjects+0x1d8>)
    5480:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_CORE_HSRUN_CLK)
        Clock_Ip_pxCoreHsrunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVCORE_HSRUN]];
    5482:	4b52      	ldr	r3, [pc, #328]	; (55cc <Clock_Ip_ClockInitializeObjects+0x1d0>)
    5484:	7a1b      	ldrb	r3, [r3, #8]
    5486:	009b      	lsls	r3, r3, #2
    5488:	4a51      	ldr	r2, [pc, #324]	; (55d0 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    548a:	4413      	add	r3, r2
    548c:	4a52      	ldr	r2, [pc, #328]	; (55d8 <Clock_Ip_ClockInitializeObjects+0x1dc>)
    548e:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxBusRunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVBUS_RUN]];
    5490:	4b4e      	ldr	r3, [pc, #312]	; (55cc <Clock_Ip_ClockInitializeObjects+0x1d0>)
    5492:	7a5b      	ldrb	r3, [r3, #9]
    5494:	009b      	lsls	r3, r3, #2
    5496:	4a4e      	ldr	r2, [pc, #312]	; (55d0 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    5498:	4413      	add	r3, r2
    549a:	4a50      	ldr	r2, [pc, #320]	; (55dc <Clock_Ip_ClockInitializeObjects+0x1e0>)
    549c:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_BUS_HSRUN_CLK)
        Clock_Ip_pxBusHsrunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVBUS_HSRUN]];
    549e:	4b4b      	ldr	r3, [pc, #300]	; (55cc <Clock_Ip_ClockInitializeObjects+0x1d0>)
    54a0:	7adb      	ldrb	r3, [r3, #11]
    54a2:	009b      	lsls	r3, r3, #2
    54a4:	4a4a      	ldr	r2, [pc, #296]	; (55d0 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    54a6:	4413      	add	r3, r2
    54a8:	4a4d      	ldr	r2, [pc, #308]	; (55e0 <Clock_Ip_ClockInitializeObjects+0x1e4>)
    54aa:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxSlowRunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVSLOW_RUN]];
    54ac:	4b47      	ldr	r3, [pc, #284]	; (55cc <Clock_Ip_ClockInitializeObjects+0x1d0>)
    54ae:	7b1b      	ldrb	r3, [r3, #12]
    54b0:	009b      	lsls	r3, r3, #2
    54b2:	4a47      	ldr	r2, [pc, #284]	; (55d0 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    54b4:	4413      	add	r3, r2
    54b6:	4a4b      	ldr	r2, [pc, #300]	; (55e4 <Clock_Ip_ClockInitializeObjects+0x1e8>)
    54b8:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SLOW_HSRUN_CLK)
        Clock_Ip_pxSlowHsrunClockDivider = &Clock_Ip_axDividerCallbacks[Clock_Ip_au8DividerCallbackIndex[CLOCK_IP_DIVSLOW_HSRUN]];
    54ba:	4b44      	ldr	r3, [pc, #272]	; (55cc <Clock_Ip_ClockInitializeObjects+0x1d0>)
    54bc:	7b9b      	ldrb	r3, [r3, #14]
    54be:	009b      	lsls	r3, r3, #2
    54c0:	4a43      	ldr	r2, [pc, #268]	; (55d0 <Clock_Ip_ClockInitializeObjects+0x1d4>)
    54c2:	4413      	add	r3, r2
    54c4:	4a48      	ldr	r2, [pc, #288]	; (55e8 <Clock_Ip_ClockInitializeObjects+0x1ec>)
    54c6:	6013      	str	r3, [r2, #0]
    #endif
    }

    if( ((TRUE == Clock_Ip_bAcceptedCopyClockConfiguration) && (Config == NULL_PTR)) || (Clock_Ip_bSentFromUpdateDriverContext ==TRUE) )
    54c8:	4b48      	ldr	r3, [pc, #288]	; (55ec <Clock_Ip_ClockInitializeObjects+0x1f0>)
    54ca:	781b      	ldrb	r3, [r3, #0]
    54cc:	2b00      	cmp	r3, #0
    54ce:	d002      	beq.n	54d6 <Clock_Ip_ClockInitializeObjects+0xda>
    54d0:	9b01      	ldr	r3, [sp, #4]
    54d2:	2b00      	cmp	r3, #0
    54d4:	d003      	beq.n	54de <Clock_Ip_ClockInitializeObjects+0xe2>
    54d6:	4b46      	ldr	r3, [pc, #280]	; (55f0 <Clock_Ip_ClockInitializeObjects+0x1f4>)
    54d8:	781b      	ldrb	r3, [r3, #0]
    54da:	2b00      	cmp	r3, #0
    54dc:	d056      	beq.n	558c <Clock_Ip_ClockInitializeObjects+0x190>
    {
        Clock_Ip_pxFircConfig = getFircConfig();
    54de:	f7ff fc09 	bl	4cf4 <getFircConfig>
    54e2:	4603      	mov	r3, r0
    54e4:	4a43      	ldr	r2, [pc, #268]	; (55f4 <Clock_Ip_ClockInitializeObjects+0x1f8>)
    54e6:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxSoscConfig = getSoscConfig();
    54e8:	f7ff fc60 	bl	4dac <getSoscConfig>
    54ec:	4603      	mov	r3, r0
    54ee:	4a42      	ldr	r2, [pc, #264]	; (55f8 <Clock_Ip_ClockInitializeObjects+0x1fc>)
    54f0:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SPLL_CLK)
        Clock_Ip_pxSpllConfig = getSpllConfig();
    54f2:	f7ff fca7 	bl	4e44 <getSpllConfig>
    54f6:	4603      	mov	r3, r0
    54f8:	4a40      	ldr	r2, [pc, #256]	; (55fc <Clock_Ip_ClockInitializeObjects+0x200>)
    54fa:	6013      	str	r3, [r2, #0]
    #endif
    #if defined(CLOCK_IP_HAS_FIRC_MON2_CLK)
        Clock_Ip_pxCmuFircMon2Config = getCmuFircConfig(FIRC_MON2_CLK);
    #endif

        Clock_Ip_pxScsConfigRunMode = getSelectorConfig(SCS_RUN_CLK);
    54fc:	2019      	movs	r0, #25
    54fe:	f7ff fcfb 	bl	4ef8 <getSelectorConfig>
    5502:	4603      	mov	r3, r0
    5504:	4a3e      	ldr	r2, [pc, #248]	; (5600 <Clock_Ip_ClockInitializeObjects+0x204>)
    5506:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxScsConfigVlprMode = getSelectorConfig(SCS_VLPR_CLK);
    5508:	201a      	movs	r0, #26
    550a:	f7ff fcf5 	bl	4ef8 <getSelectorConfig>
    550e:	4603      	mov	r3, r0
    5510:	4a3c      	ldr	r2, [pc, #240]	; (5604 <Clock_Ip_ClockInitializeObjects+0x208>)
    5512:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
        Clock_Ip_pxScsConfigHsrunMode = getSelectorConfig(SCS_HSRUN_CLK);
    5514:	201b      	movs	r0, #27
    5516:	f7ff fcef 	bl	4ef8 <getSelectorConfig>
    551a:	4603      	mov	r3, r0
    551c:	4a3a      	ldr	r2, [pc, #232]	; (5608 <Clock_Ip_ClockInitializeObjects+0x20c>)
    551e:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxCoreConfigRunMode = getCoreDividerConfig(CORE_RUN_CLK);
    5520:	201d      	movs	r0, #29
    5522:	f7ff fd7b 	bl	501c <getCoreDividerConfig>
    5526:	4603      	mov	r3, r0
    5528:	4a38      	ldr	r2, [pc, #224]	; (560c <Clock_Ip_ClockInitializeObjects+0x210>)
    552a:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxCoreConfigVlprMode = getCoreDividerConfig(CORE_VLPR_CLK);
    552c:	201e      	movs	r0, #30
    552e:	f7ff fd75 	bl	501c <getCoreDividerConfig>
    5532:	4603      	mov	r3, r0
    5534:	4a36      	ldr	r2, [pc, #216]	; (5610 <Clock_Ip_ClockInitializeObjects+0x214>)
    5536:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_CORE_HSRUN_CLK)
        Clock_Ip_pxCoreConfigHsrunMode = getCoreDividerConfig(CORE_HSRUN_CLK);
    5538:	201f      	movs	r0, #31
    553a:	f7ff fd6f 	bl	501c <getCoreDividerConfig>
    553e:	4603      	mov	r3, r0
    5540:	4a34      	ldr	r2, [pc, #208]	; (5614 <Clock_Ip_ClockInitializeObjects+0x218>)
    5542:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxBusConfigRunMode = getBusDividerConfig(BUS_RUN_CLK);
    5544:	2021      	movs	r0, #33	; 0x21
    5546:	f7ff fe0f 	bl	5168 <getBusDividerConfig>
    554a:	4603      	mov	r3, r0
    554c:	4a32      	ldr	r2, [pc, #200]	; (5618 <Clock_Ip_ClockInitializeObjects+0x21c>)
    554e:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxBusConfigVlprMode = getBusDividerConfig(BUS_VLPR_CLK);
    5550:	2022      	movs	r0, #34	; 0x22
    5552:	f7ff fe09 	bl	5168 <getBusDividerConfig>
    5556:	4603      	mov	r3, r0
    5558:	4a30      	ldr	r2, [pc, #192]	; (561c <Clock_Ip_ClockInitializeObjects+0x220>)
    555a:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_BUS_HSRUN_CLK)
        Clock_Ip_pxBusConfigHsrunMode = getBusDividerConfig(BUS_HSRUN_CLK);
    555c:	2023      	movs	r0, #35	; 0x23
    555e:	f7ff fe03 	bl	5168 <getBusDividerConfig>
    5562:	4603      	mov	r3, r0
    5564:	4a2e      	ldr	r2, [pc, #184]	; (5620 <Clock_Ip_ClockInitializeObjects+0x224>)
    5566:	6013      	str	r3, [r2, #0]
    #endif

        Clock_Ip_pxSlowConfigRunMode = getSlowDividerConfig(SLOW_RUN_CLK);
    5568:	2025      	movs	r0, #37	; 0x25
    556a:	f7ff fea3 	bl	52b4 <getSlowDividerConfig>
    556e:	4603      	mov	r3, r0
    5570:	4a2c      	ldr	r2, [pc, #176]	; (5624 <Clock_Ip_ClockInitializeObjects+0x228>)
    5572:	6013      	str	r3, [r2, #0]
        Clock_Ip_pxSlowConfigVlprMode = getSlowDividerConfig(SLOW_VLPR_CLK);
    5574:	2026      	movs	r0, #38	; 0x26
    5576:	f7ff fe9d 	bl	52b4 <getSlowDividerConfig>
    557a:	4603      	mov	r3, r0
    557c:	4a2a      	ldr	r2, [pc, #168]	; (5628 <Clock_Ip_ClockInitializeObjects+0x22c>)
    557e:	6013      	str	r3, [r2, #0]
    #if defined(CLOCK_IP_HAS_SLOW_HSRUN_CLK)
        Clock_Ip_pxSlowConfigHsrunMode = getSlowDividerConfig(SLOW_HSRUN_CLK);
    5580:	2027      	movs	r0, #39	; 0x27
    5582:	f7ff fe97 	bl	52b4 <getSlowDividerConfig>
    5586:	4603      	mov	r3, r0
    5588:	4a28      	ldr	r2, [pc, #160]	; (562c <Clock_Ip_ClockInitializeObjects+0x230>)
    558a:	6013      	str	r3, [r2, #0]
    #endif
    }

}
    558c:	bf00      	nop
    558e:	b003      	add	sp, #12
    5590:	f85d fb04 	ldr.w	pc, [sp], #4
    5594:	1fff8cd4 	.word	0x1fff8cd4
    5598:	00015490 	.word	0x00015490
    559c:	00015adc 	.word	0x00015adc
    55a0:	1fff8ba0 	.word	0x1fff8ba0
    55a4:	00015450 	.word	0x00015450
    55a8:	00015a24 	.word	0x00015a24
    55ac:	1fff8ba4 	.word	0x1fff8ba4
    55b0:	00015460 	.word	0x00015460
    55b4:	00015a90 	.word	0x00015a90
    55b8:	1fff8ba8 	.word	0x1fff8ba8
    55bc:	000154a0 	.word	0x000154a0
    55c0:	00015b08 	.word	0x00015b08
    55c4:	1fff8bac 	.word	0x1fff8bac
    55c8:	1fff8be8 	.word	0x1fff8be8
    55cc:	00015430 	.word	0x00015430
    55d0:	000159e0 	.word	0x000159e0
    55d4:	1fff8bb0 	.word	0x1fff8bb0
    55d8:	1fff8bec 	.word	0x1fff8bec
    55dc:	1fff8bb4 	.word	0x1fff8bb4
    55e0:	1fff8bf0 	.word	0x1fff8bf0
    55e4:	1fff8bb8 	.word	0x1fff8bb8
    55e8:	1fff8bf4 	.word	0x1fff8bf4
    55ec:	1fff8b19 	.word	0x1fff8b19
    55f0:	1fff8b10 	.word	0x1fff8b10
    55f4:	1fff8bbc 	.word	0x1fff8bbc
    55f8:	1fff8bc0 	.word	0x1fff8bc0
    55fc:	1fff8bc4 	.word	0x1fff8bc4
    5600:	1fff8bc8 	.word	0x1fff8bc8
    5604:	1fff8bcc 	.word	0x1fff8bcc
    5608:	1fff8bf8 	.word	0x1fff8bf8
    560c:	1fff8bd0 	.word	0x1fff8bd0
    5610:	1fff8bd4 	.word	0x1fff8bd4
    5614:	1fff8bfc 	.word	0x1fff8bfc
    5618:	1fff8bd8 	.word	0x1fff8bd8
    561c:	1fff8bdc 	.word	0x1fff8bdc
    5620:	1fff8c00 	.word	0x1fff8c00
    5624:	1fff8be0 	.word	0x1fff8be0
    5628:	1fff8be4 	.word	0x1fff8be4
    562c:	1fff8c04 	.word	0x1fff8c04

00005630 <Clock_Ip_ClockPowerModeChangeNotification>:


void Clock_Ip_ClockPowerModeChangeNotification(Clock_Ip_PowerModesType PowerMode, Clock_Ip_PowerNotificationType Notification)
{
    5630:	b500      	push	{lr}
    5632:	b083      	sub	sp, #12
    5634:	9001      	str	r0, [sp, #4]
    5636:	9100      	str	r1, [sp, #0]
    switch(PowerMode)
    5638:	9b01      	ldr	r3, [sp, #4]
    563a:	2b03      	cmp	r3, #3
    563c:	f000 8090 	beq.w	5760 <Clock_Ip_ClockPowerModeChangeNotification+0x130>
    5640:	9b01      	ldr	r3, [sp, #4]
    5642:	2b03      	cmp	r3, #3
    5644:	f200 80d3 	bhi.w	57ee <Clock_Ip_ClockPowerModeChangeNotification+0x1be>
    5648:	9b01      	ldr	r3, [sp, #4]
    564a:	2b00      	cmp	r3, #0
    564c:	d040      	beq.n	56d0 <Clock_Ip_ClockPowerModeChangeNotification+0xa0>
    564e:	9b01      	ldr	r3, [sp, #4]
    5650:	3b01      	subs	r3, #1
    5652:	2b01      	cmp	r3, #1
    5654:	f200 80cb 	bhi.w	57ee <Clock_Ip_ClockPowerModeChangeNotification+0x1be>
    {
        case VLPR_MODE:
        case VLPS_MODE:
        {
            if(BEFORE_POWER_MODE_CHANGE == Notification)
    5658:	9b00      	ldr	r3, [sp, #0]
    565a:	2b00      	cmp	r3, #0
    565c:	f040 80c9 	bne.w	57f2 <Clock_Ip_ClockPowerModeChangeNotification+0x1c2>
            {
                Clock_Ip_bAcceptedCopyClockConfiguration = FALSE;
    5660:	4b68      	ldr	r3, [pc, #416]	; (5804 <Clock_Ip_ClockPowerModeChangeNotification+0x1d4>)
    5662:	2200      	movs	r2, #0
    5664:	701a      	strb	r2, [r3, #0]
                    Clock_Ip_pxCmuFircMonitor->Disable(FIRC_MON2_CLK);
                }
#endif

                /* Load system clock settings for VLPR mode */
                Clock_Ip_pxScsRunClockSelector->Set(Clock_Ip_pxScsConfigVlprMode);
    5666:	4b68      	ldr	r3, [pc, #416]	; (5808 <Clock_Ip_ClockPowerModeChangeNotification+0x1d8>)
    5668:	681b      	ldr	r3, [r3, #0]
    566a:	685b      	ldr	r3, [r3, #4]
    566c:	4a67      	ldr	r2, [pc, #412]	; (580c <Clock_Ip_ClockPowerModeChangeNotification+0x1dc>)
    566e:	6812      	ldr	r2, [r2, #0]
    5670:	4610      	mov	r0, r2
    5672:	4798      	blx	r3
                Clock_Ip_pxCoreRunClockDivider->Set(Clock_Ip_pxCoreConfigVlprMode);
    5674:	4b66      	ldr	r3, [pc, #408]	; (5810 <Clock_Ip_ClockPowerModeChangeNotification+0x1e0>)
    5676:	681b      	ldr	r3, [r3, #0]
    5678:	681b      	ldr	r3, [r3, #0]
    567a:	4a66      	ldr	r2, [pc, #408]	; (5814 <Clock_Ip_ClockPowerModeChangeNotification+0x1e4>)
    567c:	6812      	ldr	r2, [r2, #0]
    567e:	4610      	mov	r0, r2
    5680:	4798      	blx	r3
                Clock_Ip_pxBusRunClockDivider->Set(Clock_Ip_pxBusConfigVlprMode);
    5682:	4b65      	ldr	r3, [pc, #404]	; (5818 <Clock_Ip_ClockPowerModeChangeNotification+0x1e8>)
    5684:	681b      	ldr	r3, [r3, #0]
    5686:	681b      	ldr	r3, [r3, #0]
    5688:	4a64      	ldr	r2, [pc, #400]	; (581c <Clock_Ip_ClockPowerModeChangeNotification+0x1ec>)
    568a:	6812      	ldr	r2, [r2, #0]
    568c:	4610      	mov	r0, r2
    568e:	4798      	blx	r3
                Clock_Ip_pxSlowRunClockDivider->Set(Clock_Ip_pxSlowConfigVlprMode);
    5690:	4b63      	ldr	r3, [pc, #396]	; (5820 <Clock_Ip_ClockPowerModeChangeNotification+0x1f0>)
    5692:	681b      	ldr	r3, [r3, #0]
    5694:	681b      	ldr	r3, [r3, #0]
    5696:	4a63      	ldr	r2, [pc, #396]	; (5824 <Clock_Ip_ClockPowerModeChangeNotification+0x1f4>)
    5698:	6812      	ldr	r2, [r2, #0]
    569a:	4610      	mov	r0, r2
    569c:	4798      	blx	r3

                /* Disable all clock sources except SIRC */
#if defined(CLOCK_IP_HAS_SPLL_CLK)
                Clock_Ip_pxSpllClock->Disable(Clock_Ip_pxSpllConfig->Name);
    569e:	4b62      	ldr	r3, [pc, #392]	; (5828 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    56a0:	681b      	ldr	r3, [r3, #0]
    56a2:	691b      	ldr	r3, [r3, #16]
    56a4:	4a61      	ldr	r2, [pc, #388]	; (582c <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    56a6:	6812      	ldr	r2, [r2, #0]
    56a8:	6812      	ldr	r2, [r2, #0]
    56aa:	4610      	mov	r0, r2
    56ac:	4798      	blx	r3
#endif
                Clock_Ip_pxSoscClock->Disable(Clock_Ip_pxSoscConfig->Name);
    56ae:	4b60      	ldr	r3, [pc, #384]	; (5830 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    56b0:	681b      	ldr	r3, [r3, #0]
    56b2:	68db      	ldr	r3, [r3, #12]
    56b4:	4a5f      	ldr	r2, [pc, #380]	; (5834 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    56b6:	6812      	ldr	r2, [r2, #0]
    56b8:	6812      	ldr	r2, [r2, #0]
    56ba:	4610      	mov	r0, r2
    56bc:	4798      	blx	r3
                Clock_Ip_pxFircClock->Disable(Clock_Ip_pxFircConfig->Name);
    56be:	4b5e      	ldr	r3, [pc, #376]	; (5838 <Clock_Ip_ClockPowerModeChangeNotification+0x208>)
    56c0:	681b      	ldr	r3, [r3, #0]
    56c2:	689b      	ldr	r3, [r3, #8]
    56c4:	4a5d      	ldr	r2, [pc, #372]	; (583c <Clock_Ip_ClockPowerModeChangeNotification+0x20c>)
    56c6:	6812      	ldr	r2, [r2, #0]
    56c8:	6812      	ldr	r2, [r2, #0]
    56ca:	4610      	mov	r0, r2
    56cc:	4798      	blx	r3
            }
        }
        break;
    56ce:	e090      	b.n	57f2 <Clock_Ip_ClockPowerModeChangeNotification+0x1c2>

        case RUN_MODE:
        {
            if(POWER_MODE_CHANGED == Notification)
    56d0:	9b00      	ldr	r3, [sp, #0]
    56d2:	2b02      	cmp	r3, #2
    56d4:	f040 808f 	bne.w	57f6 <Clock_Ip_ClockPowerModeChangeNotification+0x1c6>
            {
                Clock_Ip_bAcceptedCopyClockConfiguration = TRUE;
    56d8:	4b4a      	ldr	r3, [pc, #296]	; (5804 <Clock_Ip_ClockPowerModeChangeNotification+0x1d4>)
    56da:	2201      	movs	r2, #1
    56dc:	701a      	strb	r2, [r3, #0]
                /* Restore clock source settings */
                Clock_Ip_pxFircClock->Enable(Clock_Ip_pxFircConfig);
    56de:	4b56      	ldr	r3, [pc, #344]	; (5838 <Clock_Ip_ClockPowerModeChangeNotification+0x208>)
    56e0:	681b      	ldr	r3, [r3, #0]
    56e2:	685b      	ldr	r3, [r3, #4]
    56e4:	4a55      	ldr	r2, [pc, #340]	; (583c <Clock_Ip_ClockPowerModeChangeNotification+0x20c>)
    56e6:	6812      	ldr	r2, [r2, #0]
    56e8:	4610      	mov	r0, r2
    56ea:	4798      	blx	r3

                Clock_Ip_pxSoscClock->Enable(Clock_Ip_pxSoscConfig);                 /* Enable */
    56ec:	4b50      	ldr	r3, [pc, #320]	; (5830 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    56ee:	681b      	ldr	r3, [r3, #0]
    56f0:	691b      	ldr	r3, [r3, #16]
    56f2:	4a50      	ldr	r2, [pc, #320]	; (5834 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    56f4:	6812      	ldr	r2, [r2, #0]
    56f6:	4610      	mov	r0, r2
    56f8:	4798      	blx	r3
                Clock_Ip_pxSoscClock->Complete(Clock_Ip_pxSoscConfig);               /* Wait to lock */
    56fa:	4b4d      	ldr	r3, [pc, #308]	; (5830 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    56fc:	681b      	ldr	r3, [r3, #0]
    56fe:	689b      	ldr	r3, [r3, #8]
    5700:	4a4c      	ldr	r2, [pc, #304]	; (5834 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    5702:	6812      	ldr	r2, [r2, #0]
    5704:	4610      	mov	r0, r2
    5706:	4798      	blx	r3

#if defined(CLOCK_IP_HAS_SPLL_CLK)
                Clock_Ip_pxSpllClock->Enable(Clock_Ip_pxSpllConfig);                 /* Enable */
    5708:	4b47      	ldr	r3, [pc, #284]	; (5828 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    570a:	681b      	ldr	r3, [r3, #0]
    570c:	68db      	ldr	r3, [r3, #12]
    570e:	4a47      	ldr	r2, [pc, #284]	; (582c <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    5710:	6812      	ldr	r2, [r2, #0]
    5712:	4610      	mov	r0, r2
    5714:	4798      	blx	r3
                (void)(Clock_Ip_pxSpllClock->Complete(Clock_Ip_pxSpllConfig->Name));         /* Wait to lock */
    5716:	4b44      	ldr	r3, [pc, #272]	; (5828 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    5718:	681b      	ldr	r3, [r3, #0]
    571a:	689b      	ldr	r3, [r3, #8]
    571c:	4a43      	ldr	r2, [pc, #268]	; (582c <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    571e:	6812      	ldr	r2, [r2, #0]
    5720:	6812      	ldr	r2, [r2, #0]
    5722:	4610      	mov	r0, r2
    5724:	4798      	blx	r3
#endif

                /* Restore system clock settings */
                Clock_Ip_pxScsRunClockSelector->Set(Clock_Ip_pxScsConfigRunMode);
    5726:	4b38      	ldr	r3, [pc, #224]	; (5808 <Clock_Ip_ClockPowerModeChangeNotification+0x1d8>)
    5728:	681b      	ldr	r3, [r3, #0]
    572a:	685b      	ldr	r3, [r3, #4]
    572c:	4a44      	ldr	r2, [pc, #272]	; (5840 <Clock_Ip_ClockPowerModeChangeNotification+0x210>)
    572e:	6812      	ldr	r2, [r2, #0]
    5730:	4610      	mov	r0, r2
    5732:	4798      	blx	r3
                Clock_Ip_pxCoreRunClockDivider->Set(Clock_Ip_pxCoreConfigRunMode);
    5734:	4b36      	ldr	r3, [pc, #216]	; (5810 <Clock_Ip_ClockPowerModeChangeNotification+0x1e0>)
    5736:	681b      	ldr	r3, [r3, #0]
    5738:	681b      	ldr	r3, [r3, #0]
    573a:	4a42      	ldr	r2, [pc, #264]	; (5844 <Clock_Ip_ClockPowerModeChangeNotification+0x214>)
    573c:	6812      	ldr	r2, [r2, #0]
    573e:	4610      	mov	r0, r2
    5740:	4798      	blx	r3
                Clock_Ip_pxBusRunClockDivider->Set(Clock_Ip_pxBusConfigRunMode);
    5742:	4b35      	ldr	r3, [pc, #212]	; (5818 <Clock_Ip_ClockPowerModeChangeNotification+0x1e8>)
    5744:	681b      	ldr	r3, [r3, #0]
    5746:	681b      	ldr	r3, [r3, #0]
    5748:	4a3f      	ldr	r2, [pc, #252]	; (5848 <Clock_Ip_ClockPowerModeChangeNotification+0x218>)
    574a:	6812      	ldr	r2, [r2, #0]
    574c:	4610      	mov	r0, r2
    574e:	4798      	blx	r3
                Clock_Ip_pxSlowRunClockDivider->Set(Clock_Ip_pxSlowConfigRunMode);
    5750:	4b33      	ldr	r3, [pc, #204]	; (5820 <Clock_Ip_ClockPowerModeChangeNotification+0x1f0>)
    5752:	681b      	ldr	r3, [r3, #0]
    5754:	681b      	ldr	r3, [r3, #0]
    5756:	4a3d      	ldr	r2, [pc, #244]	; (584c <Clock_Ip_ClockPowerModeChangeNotification+0x21c>)
    5758:	6812      	ldr	r2, [r2, #0]
    575a:	4610      	mov	r0, r2
    575c:	4798      	blx	r3
                    Clock_Ip_pxCmuFircMonitor->Enable(Clock_Ip_pxCmuFircMon2Config);
                }
#endif
            }
        }
        break;
    575e:	e04a      	b.n	57f6 <Clock_Ip_ClockPowerModeChangeNotification+0x1c6>

        case HSRUN_MODE:
        {
            if(POWER_MODE_CHANGED == Notification)
    5760:	9b00      	ldr	r3, [sp, #0]
    5762:	2b02      	cmp	r3, #2
    5764:	d149      	bne.n	57fa <Clock_Ip_ClockPowerModeChangeNotification+0x1ca>
            {
                Clock_Ip_bAcceptedCopyClockConfiguration = TRUE;
    5766:	4b27      	ldr	r3, [pc, #156]	; (5804 <Clock_Ip_ClockPowerModeChangeNotification+0x1d4>)
    5768:	2201      	movs	r2, #1
    576a:	701a      	strb	r2, [r3, #0]
                /* Restore clock source settings */
                Clock_Ip_pxFircClock->Enable(Clock_Ip_pxFircConfig);
    576c:	4b32      	ldr	r3, [pc, #200]	; (5838 <Clock_Ip_ClockPowerModeChangeNotification+0x208>)
    576e:	681b      	ldr	r3, [r3, #0]
    5770:	685b      	ldr	r3, [r3, #4]
    5772:	4a32      	ldr	r2, [pc, #200]	; (583c <Clock_Ip_ClockPowerModeChangeNotification+0x20c>)
    5774:	6812      	ldr	r2, [r2, #0]
    5776:	4610      	mov	r0, r2
    5778:	4798      	blx	r3

                Clock_Ip_pxSoscClock->Enable(Clock_Ip_pxSoscConfig);                 /* Enable */
    577a:	4b2d      	ldr	r3, [pc, #180]	; (5830 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    577c:	681b      	ldr	r3, [r3, #0]
    577e:	691b      	ldr	r3, [r3, #16]
    5780:	4a2c      	ldr	r2, [pc, #176]	; (5834 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    5782:	6812      	ldr	r2, [r2, #0]
    5784:	4610      	mov	r0, r2
    5786:	4798      	blx	r3
                Clock_Ip_pxSoscClock->Complete(Clock_Ip_pxSoscConfig);               /* Wait to lock */
    5788:	4b29      	ldr	r3, [pc, #164]	; (5830 <Clock_Ip_ClockPowerModeChangeNotification+0x200>)
    578a:	681b      	ldr	r3, [r3, #0]
    578c:	689b      	ldr	r3, [r3, #8]
    578e:	4a29      	ldr	r2, [pc, #164]	; (5834 <Clock_Ip_ClockPowerModeChangeNotification+0x204>)
    5790:	6812      	ldr	r2, [r2, #0]
    5792:	4610      	mov	r0, r2
    5794:	4798      	blx	r3

#if defined(CLOCK_IP_HAS_SPLL_CLK)
                Clock_Ip_pxSpllClock->Enable(Clock_Ip_pxSpllConfig);                 /* Enable */
    5796:	4b24      	ldr	r3, [pc, #144]	; (5828 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    5798:	681b      	ldr	r3, [r3, #0]
    579a:	68db      	ldr	r3, [r3, #12]
    579c:	4a23      	ldr	r2, [pc, #140]	; (582c <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    579e:	6812      	ldr	r2, [r2, #0]
    57a0:	4610      	mov	r0, r2
    57a2:	4798      	blx	r3
                (void)(Clock_Ip_pxSpllClock->Complete(Clock_Ip_pxSpllConfig->Name));         /* Wait to lock */
    57a4:	4b20      	ldr	r3, [pc, #128]	; (5828 <Clock_Ip_ClockPowerModeChangeNotification+0x1f8>)
    57a6:	681b      	ldr	r3, [r3, #0]
    57a8:	689b      	ldr	r3, [r3, #8]
    57aa:	4a20      	ldr	r2, [pc, #128]	; (582c <Clock_Ip_ClockPowerModeChangeNotification+0x1fc>)
    57ac:	6812      	ldr	r2, [r2, #0]
    57ae:	6812      	ldr	r2, [r2, #0]
    57b0:	4610      	mov	r0, r2
    57b2:	4798      	blx	r3
#endif

                /* Restore system clock settings */
#if defined(CLOCK_IP_HAS_SCS_HSRUN_CLK)
                Clock_Ip_pxScsHsrunClockSelector->Set(Clock_Ip_pxScsConfigHsrunMode);
    57b4:	4b26      	ldr	r3, [pc, #152]	; (5850 <Clock_Ip_ClockPowerModeChangeNotification+0x220>)
    57b6:	681b      	ldr	r3, [r3, #0]
    57b8:	685b      	ldr	r3, [r3, #4]
    57ba:	4a26      	ldr	r2, [pc, #152]	; (5854 <Clock_Ip_ClockPowerModeChangeNotification+0x224>)
    57bc:	6812      	ldr	r2, [r2, #0]
    57be:	4610      	mov	r0, r2
    57c0:	4798      	blx	r3
#endif
#if defined(CLOCK_IP_HAS_CORE_HSRUN_CLK)
                Clock_Ip_pxCoreHsrunClockDivider->Set(Clock_Ip_pxCoreConfigHsrunMode);
    57c2:	4b25      	ldr	r3, [pc, #148]	; (5858 <Clock_Ip_ClockPowerModeChangeNotification+0x228>)
    57c4:	681b      	ldr	r3, [r3, #0]
    57c6:	681b      	ldr	r3, [r3, #0]
    57c8:	4a24      	ldr	r2, [pc, #144]	; (585c <Clock_Ip_ClockPowerModeChangeNotification+0x22c>)
    57ca:	6812      	ldr	r2, [r2, #0]
    57cc:	4610      	mov	r0, r2
    57ce:	4798      	blx	r3
#endif
#if defined(CLOCK_IP_HAS_BUS_HSRUN_CLK)
                Clock_Ip_pxBusHsrunClockDivider->Set(Clock_Ip_pxBusConfigHsrunMode);
    57d0:	4b23      	ldr	r3, [pc, #140]	; (5860 <Clock_Ip_ClockPowerModeChangeNotification+0x230>)
    57d2:	681b      	ldr	r3, [r3, #0]
    57d4:	681b      	ldr	r3, [r3, #0]
    57d6:	4a23      	ldr	r2, [pc, #140]	; (5864 <Clock_Ip_ClockPowerModeChangeNotification+0x234>)
    57d8:	6812      	ldr	r2, [r2, #0]
    57da:	4610      	mov	r0, r2
    57dc:	4798      	blx	r3
#endif
#if defined(CLOCK_IP_HAS_SLOW_HSRUN_CLK)
                Clock_Ip_pxSlowHsrunClockDivider->Set(Clock_Ip_pxSlowConfigHsrunMode);
    57de:	4b22      	ldr	r3, [pc, #136]	; (5868 <Clock_Ip_ClockPowerModeChangeNotification+0x238>)
    57e0:	681b      	ldr	r3, [r3, #0]
    57e2:	681b      	ldr	r3, [r3, #0]
    57e4:	4a21      	ldr	r2, [pc, #132]	; (586c <Clock_Ip_ClockPowerModeChangeNotification+0x23c>)
    57e6:	6812      	ldr	r2, [r2, #0]
    57e8:	4610      	mov	r0, r2
    57ea:	4798      	blx	r3
                    Clock_Ip_pxCmuFircMonitor->Enable(Clock_Ip_pxCmuFircMon2Config);
                }
#endif
            }
        }
        break;
    57ec:	e005      	b.n	57fa <Clock_Ip_ClockPowerModeChangeNotification+0x1ca>

        default:
        {
            /* Invalid power mode */
        }
        break;
    57ee:	bf00      	nop
    57f0:	e004      	b.n	57fc <Clock_Ip_ClockPowerModeChangeNotification+0x1cc>
        break;
    57f2:	bf00      	nop
    57f4:	e002      	b.n	57fc <Clock_Ip_ClockPowerModeChangeNotification+0x1cc>
        break;
    57f6:	bf00      	nop
    57f8:	e000      	b.n	57fc <Clock_Ip_ClockPowerModeChangeNotification+0x1cc>
        break;
    57fa:	bf00      	nop
    }

}
    57fc:	bf00      	nop
    57fe:	b003      	add	sp, #12
    5800:	f85d fb04 	ldr.w	pc, [sp], #4
    5804:	1fff8b19 	.word	0x1fff8b19
    5808:	1fff8bac 	.word	0x1fff8bac
    580c:	1fff8bcc 	.word	0x1fff8bcc
    5810:	1fff8bb0 	.word	0x1fff8bb0
    5814:	1fff8bd4 	.word	0x1fff8bd4
    5818:	1fff8bb4 	.word	0x1fff8bb4
    581c:	1fff8bdc 	.word	0x1fff8bdc
    5820:	1fff8bb8 	.word	0x1fff8bb8
    5824:	1fff8be4 	.word	0x1fff8be4
    5828:	1fff8ba0 	.word	0x1fff8ba0
    582c:	1fff8bc4 	.word	0x1fff8bc4
    5830:	1fff8ba4 	.word	0x1fff8ba4
    5834:	1fff8bc0 	.word	0x1fff8bc0
    5838:	1fff8ba8 	.word	0x1fff8ba8
    583c:	1fff8bbc 	.word	0x1fff8bbc
    5840:	1fff8bc8 	.word	0x1fff8bc8
    5844:	1fff8bd0 	.word	0x1fff8bd0
    5848:	1fff8bd8 	.word	0x1fff8bd8
    584c:	1fff8be0 	.word	0x1fff8be0
    5850:	1fff8be8 	.word	0x1fff8be8
    5854:	1fff8bf8 	.word	0x1fff8bf8
    5858:	1fff8bec 	.word	0x1fff8bec
    585c:	1fff8bfc 	.word	0x1fff8bfc
    5860:	1fff8bf0 	.word	0x1fff8bf0
    5864:	1fff8c00 	.word	0x1fff8c00
    5868:	1fff8bf4 	.word	0x1fff8bf4
    586c:	1fff8c04 	.word	0x1fff8c04

00005870 <Clock_Ip_Command>:


void Clock_Ip_Command(Clock_Ip_ClockConfigType const * Config, Clock_Ip_CommandType Command)
{
    5870:	b500      	push	{lr}
    5872:	b083      	sub	sp, #12
    5874:	9001      	str	r0, [sp, #4]
    5876:	9100      	str	r1, [sp, #0]
    switch(Command)
    5878:	9b00      	ldr	r3, [sp, #0]
    587a:	2b04      	cmp	r3, #4
    587c:	d010      	beq.n	58a0 <Clock_Ip_Command+0x30>
    587e:	9b00      	ldr	r3, [sp, #0]
    5880:	2b04      	cmp	r3, #4
    5882:	d811      	bhi.n	58a8 <Clock_Ip_Command+0x38>
    5884:	9b00      	ldr	r3, [sp, #0]
    5886:	2b01      	cmp	r3, #1
    5888:	d006      	beq.n	5898 <Clock_Ip_Command+0x28>
    588a:	9b00      	ldr	r3, [sp, #0]
    588c:	2b02      	cmp	r3, #2
    588e:	d10b      	bne.n	58a8 <Clock_Ip_Command+0x38>
    {
        case CLOCK_IP_INITIALIZE_CLOCK_OBJECTS_COMMAND:
            Clock_Ip_ClockInitializeObjects(Config);
    5890:	9801      	ldr	r0, [sp, #4]
    5892:	f7ff fdb3 	bl	53fc <Clock_Ip_ClockInitializeObjects>
            break;
    5896:	e008      	b.n	58aa <Clock_Ip_Command+0x3a>
        case CLOCK_IP_INITIALIZE_PLATFORM_COMMAND:
            Clock_Ip_SpecificPlatformInitClock(Config);
    5898:	9801      	ldr	r0, [sp, #4]
    589a:	f7ff f9db 	bl	4c54 <Clock_Ip_SpecificPlatformInitClock>
            break;
    589e:	e004      	b.n	58aa <Clock_Ip_Command+0x3a>
        case CLOCK_IP_DISABLE_SAFE_CLOCK_COMMAND:
            DisableSafeClock(Config);
    58a0:	9801      	ldr	r0, [sp, #4]
    58a2:	f7ff f8ed 	bl	4a80 <DisableSafeClock>
            break;
    58a6:	e000      	b.n	58aa <Clock_Ip_Command+0x3a>
        default:
            /* Command is not implemented on this platform */
            break;
    58a8:	bf00      	nop
    }
}
    58aa:	bf00      	nop
    58ac:	b003      	add	sp, #12
    58ae:	f85d fb04 	ldr.w	pc, [sp], #4
    58b2:	bf00      	nop

000058b4 <Mcu_CheckInit>:
/**
* @brief Mcu_CheckInit - checks for Mcu_Init
* @implements Mcu_CheckInit_Activity
*/
static Std_ReturnType Mcu_CheckInit(const Mcu_ConfigType * ConfigPtr)
{
    58b4:	b500      	push	{lr}
    58b6:	b085      	sub	sp, #20
    58b8:	9001      	str	r0, [sp, #4]
    Std_ReturnType CheckStatus = (Std_ReturnType)E_OK;
    58ba:	2300      	movs	r3, #0
    58bc:	f88d 300f 	strb.w	r3, [sp, #15]

#if (MCU_PRECOMPILE_SUPPORT == STD_OFF)
    if (NULL_PTR == ConfigPtr)
    58c0:	9b01      	ldr	r3, [sp, #4]
    58c2:	2b00      	cmp	r3, #0
    58c4:	d108      	bne.n	58d8 <Mcu_CheckInit+0x24>
    {
        CheckStatus = (Std_ReturnType)E_NOT_OK;
    58c6:	2301      	movs	r3, #1
    58c8:	f88d 300f 	strb.w	r3, [sp, #15]

        (void) Det_ReportError((uint16)MCU_MODULE_ID, MCU_INSTANCE_ID, MCU_INIT_ID, MCU_E_INIT_FAILED);
    58cc:	2311      	movs	r3, #17
    58ce:	2200      	movs	r2, #0
    58d0:	2100      	movs	r1, #0
    58d2:	2065      	movs	r0, #101	; 0x65
    58d4:	f00e fd24 	bl	14320 <Det_ReportError>

        (void) Det_ReportError((uint16)MCU_MODULE_ID, MCU_INSTANCE_ID, MCU_INIT_ID, MCU_E_INIT_FAILED);
    }
#endif /* (MCU_PRECOMPILE_SUPPORT == STD_ON) */

    return CheckStatus;
    58d8:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    58dc:	4618      	mov	r0, r3
    58de:	b005      	add	sp, #20
    58e0:	f85d fb04 	ldr.w	pc, [sp], #4

000058e4 <Mcu_CheckInitClock>:
/**
* @brief Mcu_CheckInitClock - checks for Mcu_InitClock
* @implements Mcu_CheckInitClock_Activity
*/
static Std_ReturnType Mcu_CheckInitClock(Mcu_ClockType ClockSetting)
{
    58e4:	b500      	push	{lr}
    58e6:	b085      	sub	sp, #20
    58e8:	9001      	str	r0, [sp, #4]
    Std_ReturnType CheckStatus = (Std_ReturnType)E_OK;
    58ea:	2300      	movs	r3, #0
    58ec:	f88d 300f 	strb.w	r3, [sp, #15]

    if (ClockSetting >= Mcu_pConfigPtr->NoClkConfigs)
    58f0:	4b0a      	ldr	r3, [pc, #40]	; (591c <Mcu_CheckInitClock+0x38>)
    58f2:	681b      	ldr	r3, [r3, #0]
    58f4:	68db      	ldr	r3, [r3, #12]
    58f6:	9a01      	ldr	r2, [sp, #4]
    58f8:	429a      	cmp	r2, r3
    58fa:	d308      	bcc.n	590e <Mcu_CheckInitClock+0x2a>
    {
        CheckStatus = (Std_ReturnType)E_NOT_OK;
    58fc:	2301      	movs	r3, #1
    58fe:	f88d 300f 	strb.w	r3, [sp, #15]

        (void) Det_ReportError((uint16)MCU_MODULE_ID, MCU_INSTANCE_ID, MCU_INITCLOCK_ID, MCU_E_PARAM_CLOCK);
    5902:	230b      	movs	r3, #11
    5904:	2202      	movs	r2, #2
    5906:	2100      	movs	r1, #0
    5908:	2065      	movs	r0, #101	; 0x65
    590a:	f00e fd09 	bl	14320 <Det_ReportError>
    }

    return CheckStatus;
    590e:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    5912:	4618      	mov	r0, r3
    5914:	b005      	add	sp, #20
    5916:	f85d fb04 	ldr.w	pc, [sp], #4
    591a:	bf00      	nop
    591c:	1fff8ce0 	.word	0x1fff8ce0

00005920 <Mcu_CheckSetMode>:
/**
* @brief Mcu_CheckSetMode - checks for Mcu_SetMode
* @implements Mcu_CheckSetMode_Activity
*/
static Std_ReturnType Mcu_CheckSetMode(Power_Ip_ModeType McuMode)
{
    5920:	b500      	push	{lr}
    5922:	b085      	sub	sp, #20
    5924:	9001      	str	r0, [sp, #4]
    Std_ReturnType CheckStatus = (Std_ReturnType)E_OK;
    5926:	2300      	movs	r3, #0
    5928:	f88d 300f 	strb.w	r3, [sp, #15]

    if (McuMode >= Mcu_pConfigPtr->NoModeConfigs)
    592c:	4b0a      	ldr	r3, [pc, #40]	; (5958 <Mcu_CheckSetMode+0x38>)
    592e:	681b      	ldr	r3, [r3, #0]
    5930:	689b      	ldr	r3, [r3, #8]
    5932:	9a01      	ldr	r2, [sp, #4]
    5934:	429a      	cmp	r2, r3
    5936:	d308      	bcc.n	594a <Mcu_CheckSetMode+0x2a>
    {
        CheckStatus = (Std_ReturnType)E_NOT_OK;
    5938:	2301      	movs	r3, #1
    593a:	f88d 300f 	strb.w	r3, [sp, #15]

        (void) Det_ReportError((uint16)MCU_MODULE_ID, MCU_INSTANCE_ID, MCU_SETMODE_ID, MCU_E_PARAM_MODE);
    593e:	230c      	movs	r3, #12
    5940:	2208      	movs	r2, #8
    5942:	2100      	movs	r1, #0
    5944:	2065      	movs	r0, #101	; 0x65
    5946:	f00e fceb 	bl	14320 <Det_ReportError>
    }

    return CheckStatus;
    594a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    594e:	4618      	mov	r0, r3
    5950:	b005      	add	sp, #20
    5952:	f85d fb04 	ldr.w	pc, [sp], #4
    5956:	bf00      	nop
    5958:	1fff8ce0 	.word	0x1fff8ce0

0000595c <Mcu_CheckGetVersionInfo>:
/**
* @brief Mcu_CheckGetVersionInfo - checks for Mcu_GetVersionInfo
* @implements Mcu_CheckGetVersionInfo_Activity
*/
static Std_ReturnType Mcu_CheckGetVersionInfo(const Std_VersionInfoType * VersionInfo)
{
    595c:	b500      	push	{lr}
    595e:	b085      	sub	sp, #20
    5960:	9001      	str	r0, [sp, #4]
    Std_ReturnType CheckStatus = (Std_ReturnType)E_OK;
    5962:	2300      	movs	r3, #0
    5964:	f88d 300f 	strb.w	r3, [sp, #15]

    if (NULL_PTR == VersionInfo)
    5968:	9b01      	ldr	r3, [sp, #4]
    596a:	2b00      	cmp	r3, #0
    596c:	d108      	bne.n	5980 <Mcu_CheckGetVersionInfo+0x24>
    {
        CheckStatus = (Std_ReturnType)E_NOT_OK;
    596e:	2301      	movs	r3, #1
    5970:	f88d 300f 	strb.w	r3, [sp, #15]

        (void)Det_ReportError((uint16)MCU_MODULE_ID, MCU_INSTANCE_ID, MCU_GETVERSIONINFO_ID, MCU_E_PARAM_POINTER);
    5974:	2310      	movs	r3, #16
    5976:	2209      	movs	r2, #9
    5978:	2100      	movs	r1, #0
    597a:	2065      	movs	r0, #101	; 0x65
    597c:	f00e fcd0 	bl	14320 <Det_ReportError>
    }

    return CheckStatus;
    5980:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    5984:	4618      	mov	r0, r3
    5986:	b005      	add	sp, #20
    5988:	f85d fb04 	ldr.w	pc, [sp], #4

0000598c <Mcu_HLDChecksEntry>:
/**
* @brief Mcu_HLDChecksEntry - checks for invalid mode transitions.
* @implements Mcu_HLDChecksEntry_Activity
*/
static Std_ReturnType Mcu_HLDChecksEntry(uint8 McuServiceID)
{
    598c:	b500      	push	{lr}
    598e:	b085      	sub	sp, #20
    5990:	4603      	mov	r3, r0
    5992:	f88d 3007 	strb.w	r3, [sp, #7]
    Std_ReturnType CheckStatus = (Std_ReturnType)E_OK;
    5996:	2300      	movs	r3, #0
    5998:	f88d 300f 	strb.w	r3, [sp, #15]

    if (MCU_INIT_ID == McuServiceID)
    599c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    59a0:	2b00      	cmp	r3, #0
    59a2:	d10e      	bne.n	59c2 <Mcu_HLDChecksEntry+0x36>
    {
        if (MCU_UNINIT != Mcu_eStatus) /* If "Mcu_Init" was already called (i.e. driver is initialized). */
    59a4:	4b13      	ldr	r3, [pc, #76]	; (59f4 <Mcu_HLDChecksEntry+0x68>)
    59a6:	681b      	ldr	r3, [r3, #0]
    59a8:	2b03      	cmp	r3, #3
    59aa:	d01c      	beq.n	59e6 <Mcu_HLDChecksEntry+0x5a>
        {
            CheckStatus = (Std_ReturnType)E_NOT_OK;
    59ac:	2301      	movs	r3, #1
    59ae:	f88d 300f 	strb.w	r3, [sp, #15]
            (void) Det_ReportError((uint16)MCU_MODULE_ID, MCU_INSTANCE_ID, McuServiceID, MCU_E_ALREADY_INITIALIZED);
    59b2:	f89d 2007 	ldrb.w	r2, [sp, #7]
    59b6:	2313      	movs	r3, #19
    59b8:	2100      	movs	r1, #0
    59ba:	2065      	movs	r0, #101	; 0x65
    59bc:	f00e fcb0 	bl	14320 <Det_ReportError>
    59c0:	e011      	b.n	59e6 <Mcu_HLDChecksEntry+0x5a>
        }
    }
    else
    {
        if (MCU_UNINIT == Mcu_eStatus) /* If "Mcu_Init" was not called (i.e driver is uninitialized). */
    59c2:	4b0c      	ldr	r3, [pc, #48]	; (59f4 <Mcu_HLDChecksEntry+0x68>)
    59c4:	681b      	ldr	r3, [r3, #0]
    59c6:	2b03      	cmp	r3, #3
    59c8:	d10a      	bne.n	59e0 <Mcu_HLDChecksEntry+0x54>
        {
            CheckStatus = (Std_ReturnType)E_NOT_OK;
    59ca:	2301      	movs	r3, #1
    59cc:	f88d 300f 	strb.w	r3, [sp, #15]
            (void) Det_ReportError((uint16)MCU_MODULE_ID, MCU_INSTANCE_ID, McuServiceID, MCU_E_UNINIT);
    59d0:	f89d 2007 	ldrb.w	r2, [sp, #7]
    59d4:	230f      	movs	r3, #15
    59d6:	2100      	movs	r1, #0
    59d8:	2065      	movs	r0, #101	; 0x65
    59da:	f00e fca1 	bl	14320 <Det_ReportError>
    59de:	e002      	b.n	59e6 <Mcu_HLDChecksEntry+0x5a>
        }
        else
        {
            Mcu_eStatus = MCU_BUSY;
    59e0:	4b04      	ldr	r3, [pc, #16]	; (59f4 <Mcu_HLDChecksEntry+0x68>)
    59e2:	220a      	movs	r2, #10
    59e4:	601a      	str	r2, [r3, #0]
        }
    }

    return CheckStatus;
    59e6:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    59ea:	4618      	mov	r0, r3
    59ec:	b005      	add	sp, #20
    59ee:	f85d fb04 	ldr.w	pc, [sp], #4
    59f2:	bf00      	nop
    59f4:	1fff8b1c 	.word	0x1fff8b1c

000059f8 <Mcu_HLDChecksExit>:
* @implements Mcu_HLDChecksExit_Activity
*/
static void Mcu_HLDChecksExit(  Std_ReturnType RetStatus,
                                uint8 McuServiceID
                              )
{
    59f8:	b082      	sub	sp, #8
    59fa:	4603      	mov	r3, r0
    59fc:	460a      	mov	r2, r1
    59fe:	f88d 3007 	strb.w	r3, [sp, #7]
    5a02:	4613      	mov	r3, r2
    5a04:	f88d 3006 	strb.w	r3, [sp, #6]
    if (MCU_INIT_ID == McuServiceID)
    5a08:	f89d 3006 	ldrb.w	r3, [sp, #6]
    5a0c:	2b00      	cmp	r3, #0
    5a0e:	d10b      	bne.n	5a28 <Mcu_HLDChecksExit+0x30>
    {
        if ((Std_ReturnType)E_OK == (Std_ReturnType)RetStatus)
    5a10:	f89d 3007 	ldrb.w	r3, [sp, #7]
    5a14:	2b00      	cmp	r3, #0
    5a16:	d103      	bne.n	5a20 <Mcu_HLDChecksExit+0x28>
        {
            Mcu_eStatus = MCU_IDLE;
    5a18:	4b06      	ldr	r3, [pc, #24]	; (5a34 <Mcu_HLDChecksExit+0x3c>)
    5a1a:	220c      	movs	r2, #12
    5a1c:	601a      	str	r2, [r3, #0]
    }
    else
    {
        Mcu_eStatus = MCU_IDLE;
    }
}
    5a1e:	e006      	b.n	5a2e <Mcu_HLDChecksExit+0x36>
            Mcu_eStatus = MCU_UNINIT;
    5a20:	4b04      	ldr	r3, [pc, #16]	; (5a34 <Mcu_HLDChecksExit+0x3c>)
    5a22:	2203      	movs	r2, #3
    5a24:	601a      	str	r2, [r3, #0]
}
    5a26:	e002      	b.n	5a2e <Mcu_HLDChecksExit+0x36>
        Mcu_eStatus = MCU_IDLE;
    5a28:	4b02      	ldr	r3, [pc, #8]	; (5a34 <Mcu_HLDChecksExit+0x3c>)
    5a2a:	220c      	movs	r2, #12
    5a2c:	601a      	str	r2, [r3, #0]
}
    5a2e:	bf00      	nop
    5a30:	b002      	add	sp, #8
    5a32:	4770      	bx	lr
    5a34:	1fff8b1c 	.word	0x1fff8b1c

00005a38 <Mcu_Init>:
* @api
*
* @implements Mcu_Init_Activity
*/
void Mcu_Init(const Mcu_ConfigType * ConfigPtr)
{
    5a38:	b500      	push	{lr}
    5a3a:	b085      	sub	sp, #20
    5a3c:	9001      	str	r0, [sp, #4]
#if ( (MCU_VALIDATE_GLOBAL_CALL == STD_ON) || (MCU_PARAM_CHECK == STD_ON) )
    Std_ReturnType CheckStatus;
#endif /* ( (MCU_VALIDATE_GLOBAL_CALL == STD_ON) || (MCU_PARAM_CHECK == STD_ON) ) */

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    CheckStatus = (Std_ReturnType) Mcu_HLDChecksEntry(MCU_INIT_ID);
    5a3e:	2000      	movs	r0, #0
    5a40:	f7ff ffa4 	bl	598c <Mcu_HLDChecksEntry>
    5a44:	4603      	mov	r3, r0
    5a46:	f88d 300b 	strb.w	r3, [sp, #11]

    if ( (Std_ReturnType)E_OK == CheckStatus )
    5a4a:	f89d 300b 	ldrb.w	r3, [sp, #11]
    5a4e:	2b00      	cmp	r3, #0
    5a50:	d150      	bne.n	5af4 <Mcu_Init+0xbc>

#if (MCU_PARAM_CHECK == STD_ON)
        /* When PostBuild is used and #(Variants) > 1, the input parameter 'ConfigPtr' is mandatory
         * to be different than NULL_PTR. */
        /* Check the config. In case of error, return immediately. The "Mcu_CheckInit" function will report DET errors. */
        CheckStatus = Mcu_CheckInit(ConfigPtr);
    5a52:	9801      	ldr	r0, [sp, #4]
    5a54:	f7ff ff2e 	bl	58b4 <Mcu_CheckInit>
    5a58:	4603      	mov	r3, r0
    5a5a:	f88d 300b 	strb.w	r3, [sp, #11]

        if ((Std_ReturnType)E_OK == CheckStatus)
    5a5e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    5a62:	2b00      	cmp	r3, #0
    5a64:	d13d      	bne.n	5ae2 <Mcu_Init+0xaa>

#if (MCU_PRECOMPILE_SUPPORT == STD_ON)
            Mcu_pConfigPtr = &Mcu_PreCompileConfig;
            MCU_PARAM_UNUSED(ConfigPtr);
#else
            Mcu_pConfigPtr = ConfigPtr;
    5a66:	4a25      	ldr	r2, [pc, #148]	; (5afc <Mcu_Init+0xc4>)
    5a68:	9b01      	ldr	r3, [sp, #4]
    5a6a:	6013      	str	r3, [r2, #0]
            /* Get a local copy of the DEM error reporting structure. */
            Mcu_pDemCfgPtr = Mcu_pConfigPtr->DemConfigPtr;
#endif /* (MCU_DISABLE_DEM_REPORT_ERROR_STATUS == STD_OFF) */

            /* Save the Mcu Mode IDs configurations. */
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoModeConfigs; NoConfigs++)
    5a6c:	2300      	movs	r3, #0
    5a6e:	9303      	str	r3, [sp, #12]
    5a70:	e010      	b.n	5a94 <Mcu_Init+0x5c>
            {
                Mcu_au8ModeConfigIds[(*Mcu_pConfigPtr->ModeConfigArrayPtr)[NoConfigs].ModeConfigId] = (uint8)NoConfigs;
    5a72:	4b22      	ldr	r3, [pc, #136]	; (5afc <Mcu_Init+0xc4>)
    5a74:	681b      	ldr	r3, [r3, #0]
    5a76:	6919      	ldr	r1, [r3, #16]
    5a78:	9a03      	ldr	r2, [sp, #12]
    5a7a:	4613      	mov	r3, r2
    5a7c:	005b      	lsls	r3, r3, #1
    5a7e:	4413      	add	r3, r2
    5a80:	009b      	lsls	r3, r3, #2
    5a82:	440b      	add	r3, r1
    5a84:	681b      	ldr	r3, [r3, #0]
    5a86:	9a03      	ldr	r2, [sp, #12]
    5a88:	b2d1      	uxtb	r1, r2
    5a8a:	4a1d      	ldr	r2, [pc, #116]	; (5b00 <Mcu_Init+0xc8>)
    5a8c:	54d1      	strb	r1, [r2, r3]
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoModeConfigs; NoConfigs++)
    5a8e:	9b03      	ldr	r3, [sp, #12]
    5a90:	3301      	adds	r3, #1
    5a92:	9303      	str	r3, [sp, #12]
    5a94:	4b19      	ldr	r3, [pc, #100]	; (5afc <Mcu_Init+0xc4>)
    5a96:	681b      	ldr	r3, [r3, #0]
    5a98:	689b      	ldr	r3, [r3, #8]
    5a9a:	9a03      	ldr	r2, [sp, #12]
    5a9c:	429a      	cmp	r2, r3
    5a9e:	d3e8      	bcc.n	5a72 <Mcu_Init+0x3a>
            }

#if (MCU_INIT_CLOCK == STD_ON)
            /* Save the Mcu Clock IDs configurations. */
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoClkConfigs; NoConfigs++)
    5aa0:	2300      	movs	r3, #0
    5aa2:	9303      	str	r3, [sp, #12]
    5aa4:	e010      	b.n	5ac8 <Mcu_Init+0x90>
            {
                Mcu_au8ClockConfigIds[(*Mcu_pConfigPtr->ClockConfigArrayPtr)[NoConfigs].ClkConfigId] = (uint8)NoConfigs;
    5aa6:	4b15      	ldr	r3, [pc, #84]	; (5afc <Mcu_Init+0xc4>)
    5aa8:	681b      	ldr	r3, [r3, #0]
    5aaa:	6959      	ldr	r1, [r3, #20]
    5aac:	9a03      	ldr	r2, [sp, #12]
    5aae:	4613      	mov	r3, r2
    5ab0:	01db      	lsls	r3, r3, #7
    5ab2:	1a9b      	subs	r3, r3, r2
    5ab4:	00db      	lsls	r3, r3, #3
    5ab6:	440b      	add	r3, r1
    5ab8:	681b      	ldr	r3, [r3, #0]
    5aba:	9a03      	ldr	r2, [sp, #12]
    5abc:	b2d1      	uxtb	r1, r2
    5abe:	4a11      	ldr	r2, [pc, #68]	; (5b04 <Mcu_Init+0xcc>)
    5ac0:	54d1      	strb	r1, [r2, r3]
            for (NoConfigs = (uint32)0U; NoConfigs < Mcu_pConfigPtr->NoClkConfigs; NoConfigs++)
    5ac2:	9b03      	ldr	r3, [sp, #12]
    5ac4:	3301      	adds	r3, #1
    5ac6:	9303      	str	r3, [sp, #12]
    5ac8:	4b0c      	ldr	r3, [pc, #48]	; (5afc <Mcu_Init+0xc4>)
    5aca:	681b      	ldr	r3, [r3, #0]
    5acc:	68db      	ldr	r3, [r3, #12]
    5ace:	9a03      	ldr	r2, [sp, #12]
    5ad0:	429a      	cmp	r2, r3
    5ad2:	d3e8      	bcc.n	5aa6 <Mcu_Init+0x6e>
            {
                Mcu_au8RamConfigIds[(*Mcu_pConfigPtr->RamConfigArrayPtr)[NoConfigs].RamSectorId] = (uint8)NoConfigs;
            }
#endif /* (0 != MCU_MAX_RAMCONFIGS) */

            Mcu_Ipw_Init(Mcu_pConfigPtr->HwIPsConfigPtr);
    5ad4:	4b09      	ldr	r3, [pc, #36]	; (5afc <Mcu_Init+0xc4>)
    5ad6:	681b      	ldr	r3, [r3, #0]
    5ad8:	699b      	ldr	r3, [r3, #24]
    5ada:	4618      	mov	r0, r3
    5adc:	f000 f90c 	bl	5cf8 <Mcu_Ipw_Init>
    5ae0:	e002      	b.n	5ae8 <Mcu_Init+0xb0>
#if (MCU_PARAM_CHECK == STD_ON)
        }
        else
        {
            /* Clean the init pointer in case of an error. */
            Mcu_pConfigPtr = NULL_PTR;
    5ae2:	4b06      	ldr	r3, [pc, #24]	; (5afc <Mcu_Init+0xc4>)
    5ae4:	2200      	movs	r2, #0
    5ae6:	601a      	str	r2, [r3, #0]
#endif /* (MCU_PARAM_CHECK == STD_ON) */


#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        /* The driver is now initialized. Set the proper status. */
        Mcu_HLDChecksExit(CheckStatus, MCU_INIT_ID);
    5ae8:	f89d 300b 	ldrb.w	r3, [sp, #11]
    5aec:	2100      	movs	r1, #0
    5aee:	4618      	mov	r0, r3
    5af0:	f7ff ff82 	bl	59f8 <Mcu_HLDChecksExit>
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
}
    5af4:	bf00      	nop
    5af6:	b005      	add	sp, #20
    5af8:	f85d fb04 	ldr.w	pc, [sp], #4
    5afc:	1fff8ce0 	.word	0x1fff8ce0
    5b00:	1fff8cdc 	.word	0x1fff8cdc
    5b04:	1fff8cd8 	.word	0x1fff8cd8

00005b08 <Mcu_InitRamSection>:
*
* @implements Mcu_InitRamSection_Activity
*
*/
Std_ReturnType Mcu_InitRamSection(Mcu_RamSectionType RamSection)
{
    5b08:	b500      	push	{lr}
    5b0a:	b085      	sub	sp, #20
    5b0c:	9001      	str	r0, [sp, #4]
#ifndef MCU_MAX_NORAMCONFIGS
    const uint8 RamConfigId = Mcu_au8RamConfigIds[RamSection];
#endif /* #ifndef MCU_MAX_NORAMCONFIGS */
    /* Result of the operation. */
    Std_ReturnType RamStatus = (Std_ReturnType)E_NOT_OK;
    5b0e:	2301      	movs	r3, #1
    5b10:	f88d 300f 	strb.w	r3, [sp, #15]

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    /* Check if the driver is initialized. */
    if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_HLDChecksEntry(MCU_INITRAMSECTION_ID) )
    5b14:	2001      	movs	r0, #1
    5b16:	f7ff ff39 	bl	598c <Mcu_HLDChecksEntry>
    5b1a:	4603      	mov	r3, r0
    5b1c:	2b00      	cmp	r3, #0
    5b1e:	d103      	bne.n	5b28 <Mcu_InitRamSection+0x20>
        /* To avoid compiler warning. */
        MCU_PARAM_UNUSED(RamSection);
#endif /* #ifndef MCU_MAX_NORAMCONFIGS */

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_INITRAMSECTION_ID);
    5b20:	2101      	movs	r1, #1
    5b22:	2000      	movs	r0, #0
    5b24:	f7ff ff68 	bl	59f8 <Mcu_HLDChecksExit>
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return RamStatus;
    5b28:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    5b2c:	4618      	mov	r0, r3
    5b2e:	b005      	add	sp, #20
    5b30:	f85d fb04 	ldr.w	pc, [sp], #4

00005b34 <Mcu_InitClock>:
* @api
*
* @implements Mcu_InitClock_Activity
*/
Std_ReturnType Mcu_InitClock(Mcu_ClockType ClockSetting)
{
    5b34:	b500      	push	{lr}
    5b36:	b085      	sub	sp, #20
    5b38:	9001      	str	r0, [sp, #4]
    const uint8 ClockConfigId =  Mcu_au8ClockConfigIds[ClockSetting];
    5b3a:	4a17      	ldr	r2, [pc, #92]	; (5b98 <Mcu_InitClock+0x64>)
    5b3c:	9b01      	ldr	r3, [sp, #4]
    5b3e:	4413      	add	r3, r2
    5b40:	781b      	ldrb	r3, [r3, #0]
    5b42:	f88d 300e 	strb.w	r3, [sp, #14]
    /* Return the success of the clock initalization operation. */
#if ( (MCU_VALIDATE_GLOBAL_CALL == STD_ON) || (MCU_PARAM_CHECK == STD_ON) )
    Std_ReturnType ClockStatus = (Std_ReturnType)E_NOT_OK;
    5b46:	2301      	movs	r3, #1
    5b48:	f88d 300f 	strb.w	r3, [sp, #15]
#else
    Std_ReturnType ClockStatus;
#endif

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_HLDChecksEntry(MCU_INITCLOCK_ID) )
    5b4c:	2002      	movs	r0, #2
    5b4e:	f7ff ff1d 	bl	598c <Mcu_HLDChecksEntry>
    5b52:	4603      	mov	r3, r0
    5b54:	2b00      	cmp	r3, #0
    5b56:	d119      	bne.n	5b8c <Mcu_InitClock+0x58>
    {
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

        /* Check if Clock configuration is valid. */
#if (MCU_PARAM_CHECK == STD_ON)
        if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_CheckInitClock(ClockSetting) )
    5b58:	9801      	ldr	r0, [sp, #4]
    5b5a:	f7ff fec3 	bl	58e4 <Mcu_CheckInitClock>
    5b5e:	4603      	mov	r3, r0
    5b60:	2b00      	cmp	r3, #0
    5b62:	d10f      	bne.n	5b84 <Mcu_InitClock+0x50>
        {
#endif /* (MCU_PARAM_CHECK == STD_ON) */
            Mcu_Ipw_InitClock(&(*Mcu_pConfigPtr->ClockConfigArrayPtr)[ClockConfigId]);
    5b64:	4b0d      	ldr	r3, [pc, #52]	; (5b9c <Mcu_InitClock+0x68>)
    5b66:	681b      	ldr	r3, [r3, #0]
    5b68:	6959      	ldr	r1, [r3, #20]
    5b6a:	f89d 200e 	ldrb.w	r2, [sp, #14]
    5b6e:	4613      	mov	r3, r2
    5b70:	01db      	lsls	r3, r3, #7
    5b72:	1a9b      	subs	r3, r3, r2
    5b74:	00db      	lsls	r3, r3, #3
    5b76:	440b      	add	r3, r1
    5b78:	4618      	mov	r0, r3
    5b7a:	f000 f8c7 	bl	5d0c <Mcu_Ipw_InitClock>

            /* Command has been accepted. */
            ClockStatus = (Std_ReturnType)E_OK;
    5b7e:	2300      	movs	r3, #0
    5b80:	f88d 300f 	strb.w	r3, [sp, #15]
#if (MCU_PARAM_CHECK == STD_ON)
        }
#endif /* (MCU_PARAM_CHECK == STD_ON) */

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_INITCLOCK_ID);
    5b84:	2102      	movs	r1, #2
    5b86:	2000      	movs	r0, #0
    5b88:	f7ff ff36 	bl	59f8 <Mcu_HLDChecksExit>
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return ClockStatus;
    5b8c:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    5b90:	4618      	mov	r0, r3
    5b92:	b005      	add	sp, #20
    5b94:	f85d fb04 	ldr.w	pc, [sp], #4
    5b98:	1fff8cd8 	.word	0x1fff8cd8
    5b9c:	1fff8ce0 	.word	0x1fff8ce0

00005ba0 <Mcu_SetMode>:
* @api
*
* @implements Mcu_SetMode_Activity
*/
void Mcu_SetMode(Mcu_ModeType McuMode)
{
    5ba0:	b500      	push	{lr}
    5ba2:	b085      	sub	sp, #20
    5ba4:	9001      	str	r0, [sp, #4]
    const uint8 McuModeId = Mcu_au8ModeConfigIds[McuMode];
    5ba6:	4a15      	ldr	r2, [pc, #84]	; (5bfc <Mcu_SetMode+0x5c>)
    5ba8:	9b01      	ldr	r3, [sp, #4]
    5baa:	4413      	add	r3, r2
    5bac:	781b      	ldrb	r3, [r3, #0]
    5bae:	f88d 300f 	strb.w	r3, [sp, #15]

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_HLDChecksEntry(MCU_SETMODE_ID) )
    5bb2:	2008      	movs	r0, #8
    5bb4:	f7ff feea 	bl	598c <Mcu_HLDChecksEntry>
    5bb8:	4603      	mov	r3, r0
    5bba:	2b00      	cmp	r3, #0
    5bbc:	d11a      	bne.n	5bf4 <Mcu_SetMode+0x54>
    {
#endif /*( MCU_VALIDATE_GLOBAL_CALL == STD_ON )*/

#if (MCU_PARAM_CHECK == STD_ON)
        /* Check if Mode configuration is valid. */
        if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_CheckSetMode(McuMode) )
    5bbe:	9801      	ldr	r0, [sp, #4]
    5bc0:	f7ff feae 	bl	5920 <Mcu_CheckSetMode>
    5bc4:	4603      	mov	r3, r0
    5bc6:	2b00      	cmp	r3, #0
    5bc8:	d110      	bne.n	5bec <Mcu_SetMode+0x4c>
        {
#endif /* (MCU_PARAM_CHECK == STD_ON) */
            /* ASR 4.3.1: "Mcu_SetMode" has to be "concurrency-safe" */
            SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00();
    5bca:	f00d f877 	bl	12cbc <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00>

            Mcu_Ipw_SetMode( &(*Mcu_pConfigPtr->ModeConfigArrayPtr)[McuModeId] );
    5bce:	4b0c      	ldr	r3, [pc, #48]	; (5c00 <Mcu_SetMode+0x60>)
    5bd0:	681b      	ldr	r3, [r3, #0]
    5bd2:	6919      	ldr	r1, [r3, #16]
    5bd4:	f89d 200f 	ldrb.w	r2, [sp, #15]
    5bd8:	4613      	mov	r3, r2
    5bda:	005b      	lsls	r3, r3, #1
    5bdc:	4413      	add	r3, r2
    5bde:	009b      	lsls	r3, r3, #2
    5be0:	440b      	add	r3, r1
    5be2:	4618      	mov	r0, r3
    5be4:	f000 f89c 	bl	5d20 <Mcu_Ipw_SetMode>

            SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00();
    5be8:	f00d f894 	bl	12d14 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00>
        }
#endif /* (MCU_PARAM_CHECK == STD_ON) */


#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_SETMODE_ID);
    5bec:	2108      	movs	r1, #8
    5bee:	2000      	movs	r0, #0
    5bf0:	f7ff ff02 	bl	59f8 <Mcu_HLDChecksExit>
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
}
    5bf4:	bf00      	nop
    5bf6:	b005      	add	sp, #20
    5bf8:	f85d fb04 	ldr.w	pc, [sp], #4
    5bfc:	1fff8cdc 	.word	0x1fff8cdc
    5c00:	1fff8ce0 	.word	0x1fff8ce0

00005c04 <Mcu_GetPllStatus>:
* @implements Mcu_GetPllStatus_Activity
*
*
*/
Mcu_PllStatusType Mcu_GetPllStatus(void)
{
    5c04:	b500      	push	{lr}
    5c06:	b083      	sub	sp, #12
    /* Return variable. */
#if ( (MCU_VALIDATE_GLOBAL_CALL == STD_ON) || (MCU_NO_PLL == STD_ON) )
    Mcu_PllStatusType PllStatus = MCU_PLL_STATUS_UNDEFINED;
    5c08:	2302      	movs	r3, #2
    5c0a:	9301      	str	r3, [sp, #4]
#else
    Mcu_PllStatusType PllStatus;
#endif

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_HLDChecksEntry(MCU_GETPLLSTATUS_ID) )
    5c0c:	2004      	movs	r0, #4
    5c0e:	f7ff febd 	bl	598c <Mcu_HLDChecksEntry>
    5c12:	4603      	mov	r3, r0
    5c14:	2b00      	cmp	r3, #0
    5c16:	d103      	bne.n	5c20 <Mcu_GetPllStatus+0x1c>
           At this point, the return value can be only MCU_PLL_LOCKED or MCU_PLL_UNLOCKED. */
        PllStatus = Mcu_Ipw_GetPllStatus();
#endif /* (MCU_NO_PLL == STD_OFF) */

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_GETPLLSTATUS_ID);
    5c18:	2104      	movs	r1, #4
    5c1a:	2000      	movs	r0, #0
    5c1c:	f7ff feec 	bl	59f8 <Mcu_HLDChecksExit>
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return PllStatus;
    5c20:	9b01      	ldr	r3, [sp, #4]
}
    5c22:	4618      	mov	r0, r3
    5c24:	b003      	add	sp, #12
    5c26:	f85d fb04 	ldr.w	pc, [sp], #4

00005c2a <Mcu_GetResetReason>:
* @api
*
* @implements Mcu_GetResetReason_Activity
*/
Mcu_ResetType Mcu_GetResetReason(void)
{
    5c2a:	b500      	push	{lr}
    5c2c:	b083      	sub	sp, #12
    /* Return value of the function. */
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    Mcu_ResetType ResetReason = MCU_RESET_UNDEFINED;
    5c2e:	230e      	movs	r3, #14
    5c30:	9301      	str	r3, [sp, #4]
#else
    Mcu_ResetType ResetReason;
#endif

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_HLDChecksEntry(MCU_GETRESETREASON_ID) )
    5c32:	2005      	movs	r0, #5
    5c34:	f7ff feaa 	bl	598c <Mcu_HLDChecksEntry>
    5c38:	4603      	mov	r3, r0
    5c3a:	2b00      	cmp	r3, #0
    5c3c:	d106      	bne.n	5c4c <Mcu_GetResetReason+0x22>
    {
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
        /* Get the reset reason. */
        ResetReason = Mcu_Ipw_GetResetReason();
    5c3e:	f000 f879 	bl	5d34 <Mcu_Ipw_GetResetReason>
    5c42:	9001      	str	r0, [sp, #4]

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit( (Std_ReturnType)E_OK, MCU_GETRESETREASON_ID);
    5c44:	2105      	movs	r1, #5
    5c46:	2000      	movs	r0, #0
    5c48:	f7ff fed6 	bl	59f8 <Mcu_HLDChecksExit>
    }
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */

    return ResetReason;
    5c4c:	9b01      	ldr	r3, [sp, #4]
}
    5c4e:	4618      	mov	r0, r3
    5c50:	b003      	add	sp, #12
    5c52:	f85d fb04 	ldr.w	pc, [sp], #4

00005c56 <Mcu_GetResetRawValue>:
*
* @implements Mcu_GetResetRawValue_Activity
*
*/
Mcu_RawResetType Mcu_GetResetRawValue(void)
{
    5c56:	b500      	push	{lr}
    5c58:	b083      	sub	sp, #12
    /* Return value of the function. */
#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    Mcu_RawResetType RawResetValue = MCU_RAW_RESET_DEFAULT;
    5c5a:	f04f 33ff 	mov.w	r3, #4294967295
    5c5e:	9301      	str	r3, [sp, #4]
#else
    Mcu_RawResetType RawResetValue;
#endif

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
    if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_HLDChecksEntry(MCU_GETRESETRAWVALUE_ID) )
    5c60:	2006      	movs	r0, #6
    5c62:	f7ff fe93 	bl	598c <Mcu_HLDChecksEntry>
    5c66:	4603      	mov	r3, r0
    5c68:	2b00      	cmp	r3, #0
    5c6a:	d106      	bne.n	5c7a <Mcu_GetResetRawValue+0x24>
    {
#endif /* (MCU_VALIDATE_GLOBAL_CALL == STD_ON) */
        RawResetValue = (Mcu_RawResetType) Mcu_Ipw_GetResetRawValue();
    5c6c:	f000 f868 	bl	5d40 <Mcu_Ipw_GetResetRawValue>
    5c70:	9001      	str	r0, [sp, #4]

#if (MCU_VALIDATE_GLOBAL_CALL == STD_ON)
        Mcu_HLDChecksExit((Std_ReturnType)E_OK, MCU_GETRESETRAWVALUE_ID);
    5c72:	2106      	movs	r1, #6
    5c74:	2000      	movs	r0, #0
    5c76:	f7ff febf 	bl	59f8 <Mcu_HLDChecksExit>
    }
#endif /*( MCU_VALIDATE_GLOBAL_CALL == STD_ON )*/

    return RawResetValue;
    5c7a:	9b01      	ldr	r3, [sp, #4]
}
    5c7c:	4618      	mov	r0, r3
    5c7e:	b003      	add	sp, #12
    5c80:	f85d fb04 	ldr.w	pc, [sp], #4

00005c84 <Mcu_GetVersionInfo>:
* @api
*
* @implements Mcu_GetVersionInfo_Activity
*/
void Mcu_GetVersionInfo(Std_VersionInfoType * versioninfo)
{
    5c84:	b500      	push	{lr}
    5c86:	b083      	sub	sp, #12
    5c88:	9001      	str	r0, [sp, #4]
#if (MCU_PARAM_CHECK == STD_ON)
    if ( (Std_ReturnType)E_OK == (Std_ReturnType) Mcu_CheckGetVersionInfo(versioninfo) )
    5c8a:	9801      	ldr	r0, [sp, #4]
    5c8c:	f7ff fe66 	bl	595c <Mcu_CheckGetVersionInfo>
    5c90:	4603      	mov	r3, r0
    5c92:	2b00      	cmp	r3, #0
    5c94:	d10e      	bne.n	5cb4 <Mcu_GetVersionInfo+0x30>
    {
#endif /* (MCU_PARAM_CHECK == STD_ON) */
        (versioninfo)->vendorID = (uint16)MCU_VENDOR_ID;
    5c96:	9b01      	ldr	r3, [sp, #4]
    5c98:	222b      	movs	r2, #43	; 0x2b
    5c9a:	801a      	strh	r2, [r3, #0]
        (versioninfo)->moduleID = (uint8)MCU_MODULE_ID;
    5c9c:	9b01      	ldr	r3, [sp, #4]
    5c9e:	2265      	movs	r2, #101	; 0x65
    5ca0:	805a      	strh	r2, [r3, #2]
        (versioninfo)->sw_major_version = (uint8)MCU_SW_MAJOR_VERSION;
    5ca2:	9b01      	ldr	r3, [sp, #4]
    5ca4:	2202      	movs	r2, #2
    5ca6:	711a      	strb	r2, [r3, #4]
        (versioninfo)->sw_minor_version = (uint8)MCU_SW_MINOR_VERSION;
    5ca8:	9b01      	ldr	r3, [sp, #4]
    5caa:	2200      	movs	r2, #0
    5cac:	715a      	strb	r2, [r3, #5]
        (versioninfo)->sw_patch_version = (uint8)MCU_SW_PATCH_VERSION;
    5cae:	9b01      	ldr	r3, [sp, #4]
    5cb0:	2200      	movs	r2, #0
    5cb2:	719a      	strb	r2, [r3, #6]
#if (MCU_PARAM_CHECK == STD_ON)
    }
#endif /* (MCU_PARAM_CHECK == STD_ON) */
}
    5cb4:	bf00      	nop
    5cb6:	b003      	add	sp, #12
    5cb8:	f85d fb04 	ldr.w	pc, [sp], #4

00005cbc <Mcu_SleepOnExit>:
*
* @implements Mcu_SleepOnExit_Activity
*
*/
void Mcu_SleepOnExit(Mcu_SleepOnExitType SleepOnExit)
{
    5cbc:	b500      	push	{lr}
    5cbe:	b083      	sub	sp, #12
    5cc0:	9001      	str	r0, [sp, #4]
#if ( MCU_VALIDATE_GLOBAL_CALL == STD_ON )
    if ((Std_ReturnType)E_OK == (Std_ReturnType)Mcu_HLDChecksEntry(MCU_SLEEPONEXIT_ID))
    5cc2:	201a      	movs	r0, #26
    5cc4:	f7ff fe62 	bl	598c <Mcu_HLDChecksEntry>
    5cc8:	4603      	mov	r3, r0
    5cca:	2b00      	cmp	r3, #0
    5ccc:	d106      	bne.n	5cdc <Mcu_SleepOnExit+0x20>
    {
#endif /*( MCU_VALIDATE_GLOBAL_CALL == STD_ON )*/

            Mcu_Ipw_SleepOnExit(SleepOnExit);
    5cce:	9801      	ldr	r0, [sp, #4]
    5cd0:	f000 f83c 	bl	5d4c <Mcu_Ipw_SleepOnExit>

#if ( MCU_VALIDATE_GLOBAL_CALL == STD_ON )
        Mcu_HLDChecksExit( (Std_ReturnType)E_OK ,MCU_SLEEPONEXIT_ID);
    5cd4:	211a      	movs	r1, #26
    5cd6:	2000      	movs	r0, #0
    5cd8:	f7ff fe8e 	bl	59f8 <Mcu_HLDChecksExit>
    }
#endif /*( MCU_VALIDATE_GLOBAL_CALL == STD_ON )*/
}
    5cdc:	bf00      	nop
    5cde:	b003      	add	sp, #12
    5ce0:	f85d fb04 	ldr.w	pc, [sp], #4

00005ce4 <Mcu_ClkSrcFailureNotification>:
 * @return                 void
 *
 * @api
 */
void Mcu_ClkSrcFailureNotification(Clock_Ip_NameType ClockName)
{
    5ce4:	b082      	sub	sp, #8
    5ce6:	9001      	str	r0, [sp, #4]
    (void)ClockName;

    if ( (NULL_PTR != Mcu_pConfigPtr) && (Mcu_pConfigPtr->ClkSrcFailureNotification == MCU_CLK_NOTIF_EN))
    5ce8:	4b02      	ldr	r3, [pc, #8]	; (5cf4 <Mcu_ClkSrcFailureNotification+0x10>)
    5cea:	681b      	ldr	r3, [r3, #0]
    5cec:	2b00      	cmp	r3, #0
        #endif
#else
        /* Nothing else to be done. */
#endif /* (MCU_CMU_ERROR_ISR_USED == STD_OFF && MCU_CGU_DETECT_ISR_USED == STD_OFF) */
    }
}
    5cee:	bf00      	nop
    5cf0:	b002      	add	sp, #8
    5cf2:	4770      	bx	lr
    5cf4:	1fff8ce0 	.word	0x1fff8ce0

00005cf8 <Mcu_Ipw_Init>:
*
* @return           void
*
*/
void Mcu_Ipw_Init(const Mcu_HwIPsConfigType * HwIPsConfigPtr)
{
    5cf8:	b500      	push	{lr}
    5cfa:	b083      	sub	sp, #12
    5cfc:	9001      	str	r0, [sp, #4]
#if (POWER_IP_ENABLE_NOTIFICATIONS == STD_ON)
    Power_Ip_InstallNotificationsCallback(ReportPowerErrorsCallback);
#endif

    /* Init Power and Reset */
    Power_Ip_Init(HwIPsConfigPtr);
    5cfe:	9801      	ldr	r0, [sp, #4]
    5d00:	f000 f882 	bl	5e08 <Power_Ip_Init>

    (void)HwIPsConfigPtr; /* Fix warning compiler: unused variable Mcu_pHwIPsConfigPtr */
}
    5d04:	bf00      	nop
    5d06:	b003      	add	sp, #12
    5d08:	f85d fb04 	ldr.w	pc, [sp], #4

00005d0c <Mcu_Ipw_InitClock>:
*
* @return           void
*
*/
void Mcu_Ipw_InitClock(const Mcu_ClockConfigType * ClockConfigPtr)
{
    5d0c:	b500      	push	{lr}
    5d0e:	b083      	sub	sp, #12
    5d10:	9001      	str	r0, [sp, #4]
    Clock_Ip_InitClock(ClockConfigPtr);
    5d12:	9801      	ldr	r0, [sp, #4]
    5d14:	f7fc fb12 	bl	233c <Clock_Ip_InitClock>
}
    5d18:	bf00      	nop
    5d1a:	b003      	add	sp, #12
    5d1c:	f85d fb04 	ldr.w	pc, [sp], #4

00005d20 <Mcu_Ipw_SetMode>:
*
* @return           void
*
*/
void Mcu_Ipw_SetMode(const Mcu_ModeConfigType * ModeConfigPtr)
{
    5d20:	b500      	push	{lr}
    5d22:	b083      	sub	sp, #12
    5d24:	9001      	str	r0, [sp, #4]
    Power_Ip_SetMode(ModeConfigPtr);
    5d26:	9801      	ldr	r0, [sp, #4]
    5d28:	f000 f820 	bl	5d6c <Power_Ip_SetMode>
}
    5d2c:	bf00      	nop
    5d2e:	b003      	add	sp, #12
    5d30:	f85d fb04 	ldr.w	pc, [sp], #4

00005d34 <Mcu_Ipw_GetResetReason>:
*
* @return           void
*
*/
Mcu_ResetType Mcu_Ipw_GetResetReason(void)
{
    5d34:	b508      	push	{r3, lr}
    return (Mcu_ResetType)Power_Ip_GetResetReason();
    5d36:	f000 f84f 	bl	5dd8 <Power_Ip_GetResetReason>
    5d3a:	4603      	mov	r3, r0
}
    5d3c:	4618      	mov	r0, r3
    5d3e:	bd08      	pop	{r3, pc}

00005d40 <Mcu_Ipw_GetResetRawValue>:
*
* @return           void
*
*/
Mcu_RawResetType Mcu_Ipw_GetResetRawValue(void)
{
    5d40:	b508      	push	{r3, lr}
    return (Mcu_RawResetType)Power_Ip_GetResetRawValue();
    5d42:	f000 f857 	bl	5df4 <Power_Ip_GetResetRawValue>
    5d46:	4603      	mov	r3, r0
}
    5d48:	4618      	mov	r0, r3
    5d4a:	bd08      	pop	{r3, pc}

00005d4c <Mcu_Ipw_SleepOnExit>:
*
* @return           void
*
*/
void Mcu_Ipw_SleepOnExit(Mcu_SleepOnExitType SleepOnExit)
{
    5d4c:	b500      	push	{lr}
    5d4e:	b083      	sub	sp, #12
    5d50:	9001      	str	r0, [sp, #4]
    if(MCU_SLEEP_ON_EXIT_DISABLED == (Mcu_SleepOnExitType)SleepOnExit)
    5d52:	9b01      	ldr	r3, [sp, #4]
    5d54:	2b00      	cmp	r3, #0
    5d56:	d102      	bne.n	5d5e <Mcu_Ipw_SleepOnExit+0x12>
    {
        Power_Ip_DisableSleepOnExit();
    5d58:	f000 f86c 	bl	5e34 <Power_Ip_DisableSleepOnExit>
    }
    else
    {
        Power_Ip_EnableSleepOnExit();
    }
}
    5d5c:	e001      	b.n	5d62 <Mcu_Ipw_SleepOnExit+0x16>
        Power_Ip_EnableSleepOnExit();
    5d5e:	f000 f86e 	bl	5e3e <Power_Ip_EnableSleepOnExit>
}
    5d62:	bf00      	nop
    5d64:	b003      	add	sp, #12
    5d66:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00005d6c <Power_Ip_SetMode>:
*
* @implements Power_Ip_SetMode_Activity
*
*/
void Power_Ip_SetMode(const Power_Ip_ModeConfigType * ModeConfigPtr)
{
    5d6c:	b500      	push	{lr}
    5d6e:	b085      	sub	sp, #20
    5d70:	9001      	str	r0, [sp, #4]
    uint32 PowerSwitchMode;
#if (POWER_MODE_CHANGE_NOTIFICATION == STD_ON)
    Clock_Ip_PowerModesType ModeChanged;
    Clock_Ip_PowerNotificationType ModeChangeStatus;
#endif
    Power_Ip_PowerModeType PowerMode = ModeConfigPtr->PowerMode;
    5d72:	9b01      	ldr	r3, [sp, #4]
    5d74:	685b      	ldr	r3, [r3, #4]
    5d76:	9302      	str	r3, [sp, #8]

    if (POWER_IP_MODE_OK != Power_Ip_SMC_ModeCheckEntry(PowerMode))
    5d78:	9802      	ldr	r0, [sp, #8]
    5d7a:	f000 f9f5 	bl	6168 <Power_Ip_SMC_ModeCheckEntry>
    5d7e:	4603      	mov	r3, r0
    5d80:	2b00      	cmp	r3, #0
    5d82:	d002      	beq.n	5d8a <Power_Ip_SetMode+0x1e>
    {
        PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    5d84:	2301      	movs	r3, #1
    5d86:	9303      	str	r3, [sp, #12]
    5d88:	e003      	b.n	5d92 <Power_Ip_SetMode+0x26>
#if (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON)
        Power_Ip_PrepareLowPowerMode(PowerMode);
#endif /* (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON) */

        /* Request new mode transition to SMC. */
    PowerSwitchMode = Call_Power_Ip_SMC_ModeConfig(ModeConfigPtr);
    5d8a:	9801      	ldr	r0, [sp, #4]
    5d8c:	f000 fa1e 	bl	61cc <Power_Ip_SMC_ModeConfig>
    5d90:	9003      	str	r0, [sp, #12]
            /*This will clear SLEEPDEEP bit after wake-up */
            Call_Power_Ip_CM4_DisableDeepSleep();
        }
#endif
    }
    if (POWER_IP_SWITCH_MODE_FAIL == PowerSwitchMode)
    5d92:	9b03      	ldr	r3, [sp, #12]
    5d94:	2b01      	cmp	r3, #1
    5d96:	d103      	bne.n	5da0 <Power_Ip_SetMode+0x34>
    {
        Power_Ip_ReportPowerErrors(POWER_IP_REPORT_SWITCH_MODE_ERROR, POWER_IP_ERR_CODE_RESERVED);
    5d98:	21ff      	movs	r1, #255	; 0xff
    5d9a:	2003      	movs	r0, #3
    5d9c:	f000 f8f4 	bl	5f88 <Power_Ip_ReportPowerErrors>
        ModeChanged = Power_Ip_ModeConvert(PowerMode);
        /* Callback Clock Ip Notification. */
        Clock_Ip_PowerModeChangeNotification(ModeChanged,ModeChangeStatus);
#endif
    }
}
    5da0:	bf00      	nop
    5da2:	b005      	add	sp, #20
    5da4:	f85d fb04 	ldr.w	pc, [sp], #4

00005da8 <Power_Ip_ConvertIntergeToResetType>:
* @param[in]        ResetReasonIndex   Reset reason index.
*
* @return           Power_Ip_ResetType
*/
static Power_Ip_ResetType Power_Ip_ConvertIntergeToResetType(uint32 ResetReasonIndex)
{
    5da8:	b084      	sub	sp, #16
    5daa:	9001      	str	r0, [sp, #4]
    Power_Ip_ResetType ResetReason = MCU_NO_RESET_REASON;
    5dac:	230c      	movs	r3, #12
    5dae:	9303      	str	r3, [sp, #12]

    if (ResetReasonArray[ResetReasonIndex] <= MCU_RESET_UNDEFINED)
    5db0:	4a08      	ldr	r2, [pc, #32]	; (5dd4 <Power_Ip_ConvertIntergeToResetType+0x2c>)
    5db2:	9b01      	ldr	r3, [sp, #4]
    5db4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5db8:	2b0e      	cmp	r3, #14
    5dba:	d805      	bhi.n	5dc8 <Power_Ip_ConvertIntergeToResetType+0x20>
    {
        ResetReason = ResetReasonArray[ResetReasonIndex];
    5dbc:	4a05      	ldr	r2, [pc, #20]	; (5dd4 <Power_Ip_ConvertIntergeToResetType+0x2c>)
    5dbe:	9b01      	ldr	r3, [sp, #4]
    5dc0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    5dc4:	9303      	str	r3, [sp, #12]
    5dc6:	e001      	b.n	5dcc <Power_Ip_ConvertIntergeToResetType+0x24>
    }
    else
    {
        ResetReason = MCU_NO_RESET_REASON;
    5dc8:	230c      	movs	r3, #12
    5dca:	9303      	str	r3, [sp, #12]
    }

    return ResetReason;
    5dcc:	9b03      	ldr	r3, [sp, #12]
}
    5dce:	4618      	mov	r0, r3
    5dd0:	b004      	add	sp, #16
    5dd2:	4770      	bx	lr
    5dd4:	00015b7c 	.word	0x00015b7c

00005dd8 <Power_Ip_GetResetReason>:
*
* @implements Power_Ip_GetResetReason_Activity
*
*/
Power_Ip_ResetType Power_Ip_GetResetReason(void)
{
    5dd8:	b500      	push	{lr}
    5dda:	b083      	sub	sp, #12
    Power_Ip_ResetType ResetReason;
    uint32 ResetVal;

    ResetVal = Call_Power_Ip_RCM_GetResetReason();
    5ddc:	f000 f940 	bl	6060 <Power_Ip_RCM_GetResetReason>
    5de0:	9001      	str	r0, [sp, #4]

    /* Use function Power_Ip_ConvertIntergeToResetType to avoid MISRA violation 10.5 : cast from uint32 to enum */
    ResetReason = Power_Ip_ConvertIntergeToResetType(ResetVal);
    5de2:	9801      	ldr	r0, [sp, #4]
    5de4:	f7ff ffe0 	bl	5da8 <Power_Ip_ConvertIntergeToResetType>
    5de8:	9000      	str	r0, [sp, #0]

    return (Power_Ip_ResetType) ResetReason;
    5dea:	9b00      	ldr	r3, [sp, #0]
}
    5dec:	4618      	mov	r0, r3
    5dee:	b003      	add	sp, #12
    5df0:	f85d fb04 	ldr.w	pc, [sp], #4

00005df4 <Power_Ip_GetResetRawValue>:
*
* @implements Power_Ip_GetResetRawValue_Activity
*
*/
Power_Ip_RawResetType Power_Ip_GetResetRawValue(void)
{
    5df4:	b500      	push	{lr}
    5df6:	b083      	sub	sp, #12
    Power_Ip_RawResetType ResetReason;

    ResetReason = (Power_Ip_RawResetType)Call_Power_Ip_RCM_GetResetRawValue();
    5df8:	f000 f98a 	bl	6110 <Power_Ip_RCM_GetResetRawValue>
    5dfc:	9001      	str	r0, [sp, #4]
    return (Power_Ip_RawResetType) ResetReason;
    5dfe:	9b01      	ldr	r3, [sp, #4]
}
    5e00:	4618      	mov	r0, r3
    5e02:	b003      	add	sp, #12
    5e04:	f85d fb04 	ldr.w	pc, [sp], #4

00005e08 <Power_Ip_Init>:
*
* @implements Power_Ip_Init_Activity
*
*/
void Power_Ip_Init (const Power_Ip_HwIPsConfigType * HwIPsConfigPtr)
{
    5e08:	b500      	push	{lr}
    5e0a:	b083      	sub	sp, #12
    5e0c:	9001      	str	r0, [sp, #4]
    POWER_IP_DEV_ASSERT(NULL_PTR != HwIPsConfigPtr);
    (void)(HwIPsConfigPtr);

#if (defined(POWER_IP_DISABLE_RCM_INIT) && (STD_OFF == POWER_IP_DISABLE_RCM_INIT))
    /* Init the RCM */
    Call_Power_Ip_RCM_ResetInit(HwIPsConfigPtr->RCMConfigPtr);
    5e0e:	9b01      	ldr	r3, [sp, #4]
    5e10:	681b      	ldr	r3, [r3, #0]
    5e12:	4618      	mov	r0, r3
    5e14:	f000 f90e 	bl	6034 <Power_Ip_RCM_ResetInit>
#endif

#if (defined(POWER_IP_DISABLE_PMC_INIT) && (STD_OFF == POWER_IP_DISABLE_PMC_INIT))
    Call_Power_Ip_PMC_PowerInit(HwIPsConfigPtr->PMCConfigPtr);
    5e18:	9b01      	ldr	r3, [sp, #4]
    5e1a:	685b      	ldr	r3, [r3, #4]
    5e1c:	4618      	mov	r0, r3
    5e1e:	f000 f86d 	bl	5efc <Power_Ip_PMC_PowerInit>
#endif

#if (defined(POWER_IP_DISABLE_SMC_INIT) && (STD_OFF == POWER_IP_DISABLE_SMC_INIT))
    Call_Power_Ip_SMC_AllowedModesConfig(HwIPsConfigPtr->SMCConfigPtr);
    5e22:	9b01      	ldr	r3, [sp, #4]
    5e24:	689b      	ldr	r3, [r3, #8]
    5e26:	4618      	mov	r0, r3
    5e28:	f000 f990 	bl	614c <Power_Ip_SMC_AllowedModesConfig>
#endif
}
    5e2c:	bf00      	nop
    5e2e:	b003      	add	sp, #12
    5e30:	f85d fb04 	ldr.w	pc, [sp], #4

00005e34 <Power_Ip_DisableSleepOnExit>:
* @param[in]    none
* @return void
* @implements Power_Ip_DisableSleepOnExit_Activity
*/
void Power_Ip_DisableSleepOnExit(void)
{
    5e34:	b508      	push	{r3, lr}
    Call_Power_Ip_CM4_DisableSleepOnExit();
    5e36:	f000 f811 	bl	5e5c <Power_Ip_CM4_DisableSleepOnExit>
}
    5e3a:	bf00      	nop
    5e3c:	bd08      	pop	{r3, pc}

00005e3e <Power_Ip_EnableSleepOnExit>:
* @param[in]    none
* @return void
* @implements Power_Ip_EnableSleepOnExit_Activity
*/
void Power_Ip_EnableSleepOnExit(void)
{
    5e3e:	b508      	push	{r3, lr}
    Call_Power_Ip_CM4_EnableSleepOnExit();
    5e40:	f000 f820 	bl	5e84 <Power_Ip_CM4_EnableSleepOnExit>
}
    5e44:	bf00      	nop
    5e46:	bd08      	pop	{r3, pc}

00005e48 <Power_Ip_InstallNotificationsCallback>:
* @return           void
*
* @implements Power_Ip_InstallNotificationsCallback_Activity
*/
void Power_Ip_InstallNotificationsCallback(Power_Ip_ReportErrorsCallbackType ReportErrorsCallback)
{
    5e48:	b082      	sub	sp, #8
    5e4a:	9001      	str	r0, [sp, #4]
    POWER_IP_DEV_ASSERT(NULL_PTR != ReportErrorsCallback);

    Power_Ip_pfReportErrorsCallback = ReportErrorsCallback;
    5e4c:	4a02      	ldr	r2, [pc, #8]	; (5e58 <Power_Ip_InstallNotificationsCallback+0x10>)
    5e4e:	9b01      	ldr	r3, [sp, #4]
    5e50:	6013      	str	r3, [r2, #0]
}
    5e52:	bf00      	nop
    5e54:	b002      	add	sp, #8
    5e56:	4770      	bx	lr
    5e58:	1fff8b20 	.word	0x1fff8b20

00005e5c <Power_Ip_CM4_DisableSleepOnExit>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_DisableSleepOnExit(void)
{
    5e5c:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    5e5e:	2300      	movs	r3, #0
    5e60:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    5e62:	4b07      	ldr	r3, [pc, #28]	; (5e80 <Power_Ip_CM4_DisableSleepOnExit+0x24>)
    5e64:	681b      	ldr	r3, [r3, #0]
    5e66:	685b      	ldr	r3, [r3, #4]
    5e68:	9301      	str	r3, [sp, #4]
    TempValue &= ~(CM4_SCR_SLEEPONEXIT_MASK32);
    5e6a:	9b01      	ldr	r3, [sp, #4]
    5e6c:	f023 0302 	bic.w	r3, r3, #2
    5e70:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    5e72:	4b03      	ldr	r3, [pc, #12]	; (5e80 <Power_Ip_CM4_DisableSleepOnExit+0x24>)
    5e74:	681b      	ldr	r3, [r3, #0]
    5e76:	9a01      	ldr	r2, [sp, #4]
    5e78:	605a      	str	r2, [r3, #4]
}
    5e7a:	bf00      	nop
    5e7c:	b002      	add	sp, #8
    5e7e:	4770      	bx	lr
    5e80:	1fff8b24 	.word	0x1fff8b24

00005e84 <Power_Ip_CM4_EnableSleepOnExit>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_EnableSleepOnExit(void)
{
    5e84:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    5e86:	2300      	movs	r3, #0
    5e88:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    5e8a:	4b07      	ldr	r3, [pc, #28]	; (5ea8 <Power_Ip_CM4_EnableSleepOnExit+0x24>)
    5e8c:	681b      	ldr	r3, [r3, #0]
    5e8e:	685b      	ldr	r3, [r3, #4]
    5e90:	9301      	str	r3, [sp, #4]
    TempValue |= (CM4_SCR_SLEEPONEXIT_MASK32);
    5e92:	9b01      	ldr	r3, [sp, #4]
    5e94:	f043 0302 	orr.w	r3, r3, #2
    5e98:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    5e9a:	4b03      	ldr	r3, [pc, #12]	; (5ea8 <Power_Ip_CM4_EnableSleepOnExit+0x24>)
    5e9c:	681b      	ldr	r3, [r3, #0]
    5e9e:	9a01      	ldr	r2, [sp, #4]
    5ea0:	605a      	str	r2, [r3, #4]
}
    5ea2:	bf00      	nop
    5ea4:	b002      	add	sp, #8
    5ea6:	4770      	bx	lr
    5ea8:	1fff8b24 	.word	0x1fff8b24

00005eac <Power_Ip_CM4_EnableDeepSleep>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_EnableDeepSleep(void)
{
    5eac:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    5eae:	2300      	movs	r3, #0
    5eb0:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    5eb2:	4b07      	ldr	r3, [pc, #28]	; (5ed0 <Power_Ip_CM4_EnableDeepSleep+0x24>)
    5eb4:	681b      	ldr	r3, [r3, #0]
    5eb6:	685b      	ldr	r3, [r3, #4]
    5eb8:	9301      	str	r3, [sp, #4]
    TempValue |= CM4_SCR_SLEEPDEEP_MASK32;
    5eba:	9b01      	ldr	r3, [sp, #4]
    5ebc:	f043 0304 	orr.w	r3, r3, #4
    5ec0:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    5ec2:	4b03      	ldr	r3, [pc, #12]	; (5ed0 <Power_Ip_CM4_EnableDeepSleep+0x24>)
    5ec4:	681b      	ldr	r3, [r3, #0]
    5ec6:	9a01      	ldr	r2, [sp, #4]
    5ec8:	605a      	str	r2, [r3, #4]
}
    5eca:	bf00      	nop
    5ecc:	b002      	add	sp, #8
    5ece:	4770      	bx	lr
    5ed0:	1fff8b24 	.word	0x1fff8b24

00005ed4 <Power_Ip_CM4_DisableDeepSleep>:
* @param[in]    none
*
* @return void
*/
void Power_Ip_CM4_DisableDeepSleep(void)
{
    5ed4:	b082      	sub	sp, #8
    uint32 TempValue = 0;
    5ed6:	2300      	movs	r3, #0
    5ed8:	9301      	str	r3, [sp, #4]

    TempValue = Power_Ip_pxCM4->SCR;
    5eda:	4b07      	ldr	r3, [pc, #28]	; (5ef8 <Power_Ip_CM4_DisableDeepSleep+0x24>)
    5edc:	681b      	ldr	r3, [r3, #0]
    5ede:	685b      	ldr	r3, [r3, #4]
    5ee0:	9301      	str	r3, [sp, #4]
    TempValue &= ~(CM4_SCR_SLEEPDEEP_MASK32);
    5ee2:	9b01      	ldr	r3, [sp, #4]
    5ee4:	f023 0304 	bic.w	r3, r3, #4
    5ee8:	9301      	str	r3, [sp, #4]
    Power_Ip_pxCM4->SCR = TempValue;
    5eea:	4b03      	ldr	r3, [pc, #12]	; (5ef8 <Power_Ip_CM4_DisableDeepSleep+0x24>)
    5eec:	681b      	ldr	r3, [r3, #0]
    5eee:	9a01      	ldr	r2, [sp, #4]
    5ef0:	605a      	str	r2, [r3, #4]
}
    5ef2:	bf00      	nop
    5ef4:	b002      	add	sp, #8
    5ef6:	4770      	bx	lr
    5ef8:	1fff8b24 	.word	0x1fff8b24

00005efc <Power_Ip_PMC_PowerInit>:
*
* @return           void
*
*/
void Power_Ip_PMC_PowerInit(const Power_Ip_PMC_ConfigType * ConfigPtr)
{
    5efc:	b084      	sub	sp, #16
    5efe:	9001      	str	r0, [sp, #4]
    uint8 Tmp;

#if(STD_ON == POWER_IP_PMC_LVDSC1_SUPPORT)
    Tmp = (uint8)POWER_IP_PMC->LVDSC1;
    5f00:	4b20      	ldr	r3, [pc, #128]	; (5f84 <Power_Ip_PMC_PowerInit+0x88>)
    5f02:	781b      	ldrb	r3, [r3, #0]
    5f04:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp & (uint8)(~PMC_LVDSC1_RWBITS_MASK8));
    5f08:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5f0c:	f003 030f 	and.w	r3, r3, #15
    5f10:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp | (uint8)(ConfigPtr->Lvdsc1));
    5f14:	9b01      	ldr	r3, [sp, #4]
    5f16:	781a      	ldrb	r2, [r3, #0]
    5f18:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5f1c:	4313      	orrs	r3, r2
    5f1e:	f88d 300f 	strb.w	r3, [sp, #15]
    POWER_IP_PMC->LVDSC1 = Tmp;
    5f22:	4a18      	ldr	r2, [pc, #96]	; (5f84 <Power_Ip_PMC_PowerInit+0x88>)
    5f24:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5f28:	7013      	strb	r3, [r2, #0]
#endif
    Tmp = (uint8)POWER_IP_PMC->LVDSC2;
    5f2a:	4b16      	ldr	r3, [pc, #88]	; (5f84 <Power_Ip_PMC_PowerInit+0x88>)
    5f2c:	785b      	ldrb	r3, [r3, #1]
    5f2e:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp & (uint8)(~PMC_LVDSC2_RWBITS_MASK8));
    5f32:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5f36:	f003 031f 	and.w	r3, r3, #31
    5f3a:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp | (uint8)(ConfigPtr->Lvdsc2));
    5f3e:	9b01      	ldr	r3, [sp, #4]
    5f40:	785a      	ldrb	r2, [r3, #1]
    5f42:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5f46:	4313      	orrs	r3, r2
    5f48:	f88d 300f 	strb.w	r3, [sp, #15]
    POWER_IP_PMC->LVDSC2 = Tmp;
    5f4c:	4a0d      	ldr	r2, [pc, #52]	; (5f84 <Power_Ip_PMC_PowerInit+0x88>)
    5f4e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5f52:	7053      	strb	r3, [r2, #1]

    Tmp = (uint8)POWER_IP_PMC->REGSC;
    5f54:	4b0b      	ldr	r3, [pc, #44]	; (5f84 <Power_Ip_PMC_PowerInit+0x88>)
    5f56:	789b      	ldrb	r3, [r3, #2]
    5f58:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp & (uint8)(~PMC_REGSC_RWBITS_MASK8));
    5f5c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5f60:	f003 0338 	and.w	r3, r3, #56	; 0x38
    5f64:	f88d 300f 	strb.w	r3, [sp, #15]
    Tmp = (uint8)(Tmp | (uint8)(ConfigPtr->Regsc));
    5f68:	9b01      	ldr	r3, [sp, #4]
    5f6a:	789a      	ldrb	r2, [r3, #2]
    5f6c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5f70:	4313      	orrs	r3, r2
    5f72:	f88d 300f 	strb.w	r3, [sp, #15]
    POWER_IP_PMC->REGSC = Tmp;
    5f76:	4a03      	ldr	r2, [pc, #12]	; (5f84 <Power_Ip_PMC_PowerInit+0x88>)
    5f78:	f89d 300f 	ldrb.w	r3, [sp, #15]
    5f7c:	7093      	strb	r3, [r2, #2]
  #if (POWER_IP_VOLTAGE_ERROR_ISR_USED == STD_ON)
    /* make Status of PMC to initialized to check in the interrupt function */
    Power_Ip_ePmcStatus = PMC_INIT;
  #endif
#endif
}
    5f7e:	bf00      	nop
    5f80:	b004      	add	sp, #16
    5f82:	4770      	bx	lr
    5f84:	4007d000 	.word	0x4007d000

00005f88 <Power_Ip_ReportPowerErrors>:

/*==================================================================================================
                                       GLOBAL FUNCTIONS
==================================================================================================*/
void Power_Ip_ReportPowerErrors(Power_Ip_ReportErrorType Error, uint8 ErrorCode)
{
    5f88:	b500      	push	{lr}
    5f8a:	b083      	sub	sp, #12
    5f8c:	9001      	str	r0, [sp, #4]
    5f8e:	460b      	mov	r3, r1
    5f90:	f88d 3003 	strb.w	r3, [sp, #3]
    Power_Ip_pfReportErrorsCallback(Error, ErrorCode);
    5f94:	4b05      	ldr	r3, [pc, #20]	; (5fac <Power_Ip_ReportPowerErrors+0x24>)
    5f96:	681b      	ldr	r3, [r3, #0]
    5f98:	f89d 2003 	ldrb.w	r2, [sp, #3]
    5f9c:	4611      	mov	r1, r2
    5f9e:	9801      	ldr	r0, [sp, #4]
    5fa0:	4798      	blx	r3
}
    5fa2:	bf00      	nop
    5fa4:	b003      	add	sp, #12
    5fa6:	f85d fb04 	ldr.w	pc, [sp], #4
    5faa:	bf00      	nop
    5fac:	1fff8b20 	.word	0x1fff8b20

00005fb0 <Power_Ip_ReportPowerErrorsEmptyCallback>:

void Power_Ip_ReportPowerErrorsEmptyCallback(Power_Ip_ReportErrorType Error, uint8 ErrorCode)
{
    5fb0:	b082      	sub	sp, #8
    5fb2:	9001      	str	r0, [sp, #4]
    5fb4:	460b      	mov	r3, r1
    5fb6:	f88d 3003 	strb.w	r3, [sp, #3]
    /* No implementation */
    (void)Error;
    (void)ErrorCode;
}
    5fba:	bf00      	nop
    5fbc:	b002      	add	sp, #8
    5fbe:	4770      	bx	lr

00005fc0 <Power_Ip_StartTimeout>:
 *END**************************************************************************/
void Power_Ip_StartTimeout(uint32 *StartTimeOut,
                       uint32 *ElapsedTimeOut,
                       uint32 *TimeoutTicksOut,
                       uint32 TimeoutUs)
{
    5fc0:	b500      	push	{lr}
    5fc2:	b085      	sub	sp, #20
    5fc4:	9003      	str	r0, [sp, #12]
    5fc6:	9102      	str	r1, [sp, #8]
    5fc8:	9201      	str	r2, [sp, #4]
    5fca:	9300      	str	r3, [sp, #0]
    *StartTimeOut    = OsIf_GetCounter(POWER_IP_TIMEOUT_TYPE);
    5fcc:	2000      	movs	r0, #0
    5fce:	f7fb fee5 	bl	1d9c <OsIf_GetCounter>
    5fd2:	4602      	mov	r2, r0
    5fd4:	9b03      	ldr	r3, [sp, #12]
    5fd6:	601a      	str	r2, [r3, #0]
    *ElapsedTimeOut  = 0U;
    5fd8:	9b02      	ldr	r3, [sp, #8]
    5fda:	2200      	movs	r2, #0
    5fdc:	601a      	str	r2, [r3, #0]
    *TimeoutTicksOut = OsIf_MicrosToTicks(TimeoutUs, POWER_IP_TIMEOUT_TYPE);
    5fde:	2100      	movs	r1, #0
    5fe0:	9800      	ldr	r0, [sp, #0]
    5fe2:	f7fb ff27 	bl	1e34 <OsIf_MicrosToTicks>
    5fe6:	4602      	mov	r2, r0
    5fe8:	9b01      	ldr	r3, [sp, #4]
    5fea:	601a      	str	r2, [r3, #0]
}
    5fec:	bf00      	nop
    5fee:	b005      	add	sp, #20
    5ff0:	f85d fb04 	ldr.w	pc, [sp], #4

00005ff4 <Power_Ip_TimeoutExpired>:
 *
 *END**************************************************************************/
boolean Power_Ip_TimeoutExpired(uint32 *StartTimeInOut,
                            uint32 *ElapsedTimeInOut,
                            uint32 TimeoutTicks)
{
    5ff4:	b500      	push	{lr}
    5ff6:	b087      	sub	sp, #28
    5ff8:	9003      	str	r0, [sp, #12]
    5ffa:	9102      	str	r1, [sp, #8]
    5ffc:	9201      	str	r2, [sp, #4]
    boolean RetVal = FALSE;
    5ffe:	2300      	movs	r3, #0
    6000:	f88d 3017 	strb.w	r3, [sp, #23]
    *ElapsedTimeInOut += OsIf_GetElapsed(StartTimeInOut, POWER_IP_TIMEOUT_TYPE);
    6004:	2100      	movs	r1, #0
    6006:	9803      	ldr	r0, [sp, #12]
    6008:	f7fb fee1 	bl	1dce <OsIf_GetElapsed>
    600c:	4602      	mov	r2, r0
    600e:	9b02      	ldr	r3, [sp, #8]
    6010:	681b      	ldr	r3, [r3, #0]
    6012:	441a      	add	r2, r3
    6014:	9b02      	ldr	r3, [sp, #8]
    6016:	601a      	str	r2, [r3, #0]

    if (*ElapsedTimeInOut >= TimeoutTicks)
    6018:	9b02      	ldr	r3, [sp, #8]
    601a:	681b      	ldr	r3, [r3, #0]
    601c:	9a01      	ldr	r2, [sp, #4]
    601e:	429a      	cmp	r2, r3
    6020:	d802      	bhi.n	6028 <Power_Ip_TimeoutExpired+0x34>
    {
        RetVal = TRUE;
    6022:	2301      	movs	r3, #1
    6024:	f88d 3017 	strb.w	r3, [sp, #23]
    }
    return RetVal;
    6028:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    602c:	4618      	mov	r0, r3
    602e:	b007      	add	sp, #28
    6030:	f85d fb04 	ldr.w	pc, [sp], #4

00006034 <Power_Ip_RCM_ResetInit>:
*
* @return           void
*
*/
void Power_Ip_RCM_ResetInit(const Power_Ip_RCM_ConfigType * ConfigPtr)
{
    6034:	b082      	sub	sp, #8
    6036:	9001      	str	r0, [sp, #4]
    IP_RCM->RPC = (uint32)(ConfigPtr->ResetPinControlConfig & RCM_RPC_RWBITS_MASK32);
    6038:	9b01      	ldr	r3, [sp, #4]
    603a:	681a      	ldr	r2, [r3, #0]
    603c:	4907      	ldr	r1, [pc, #28]	; (605c <Power_Ip_RCM_ResetInit+0x28>)
    603e:	f641 7307 	movw	r3, #7943	; 0x1f07
    6042:	4013      	ands	r3, r2
    6044:	60cb      	str	r3, [r1, #12]

    IP_RCM->SRIE = (uint32)(ConfigPtr->ResetInterruptEnableConfig & RCM_SRIE_RWBITS_MASK32);
    6046:	9b01      	ldr	r3, [sp, #4]
    6048:	685a      	ldr	r2, [r3, #4]
    604a:	4904      	ldr	r1, [pc, #16]	; (605c <Power_Ip_RCM_ResetInit+0x28>)
    604c:	f642 73ff 	movw	r3, #12287	; 0x2fff
    6050:	4013      	ands	r3, r2
    6052:	61cb      	str	r3, [r1, #28]
#if (defined(POWER_IP_RESET_ALTERNATE_ISR_USED) && (POWER_IP_RESET_ALTERNATE_ISR_USED == STD_ON))
    Power_Ip_RCM_Status = POWER_IP_RCM_INIT;
#endif
}
    6054:	bf00      	nop
    6056:	b002      	add	sp, #8
    6058:	4770      	bx	lr
    605a:	bf00      	nop
    605c:	4007f000 	.word	0x4007f000

00006060 <Power_Ip_RCM_GetResetReason>:
*                   out to avoid multiple reset reasons. The function Mcu_GetResetReason shall
*                   return MCU_RESET_UNDEFINED if this function is called prior to calling of the
*                   function Mcu_Init, and if supported by the hardware.
*/
uint32 Power_Ip_RCM_GetResetReason(void)
{
    6060:	b088      	sub	sp, #32
    /* Code for the Reset event returned by this function. */
    uint32 ResetReason = (uint32)MCU_NO_RESET_REASON;
    6062:	230c      	movs	r3, #12
    6064:	9307      	str	r3, [sp, #28]
    /* Temporary variable for RCM_RSR register value. */
    uint32 RegValue = 0U;
    6066:	2300      	movs	r3, #0
    6068:	9303      	str	r3, [sp, #12]
    uint32 ActiveValue;
    uint32 Index;
    uint32 DynamicMask;
    uint32 Position = (uint32)0x00U;
    606a:	2300      	movs	r3, #0
    606c:	9305      	str	r3, [sp, #20]
    uint32 NumberOfFlags = 0U;
    606e:	2300      	movs	r3, #0
    6070:	9304      	str	r3, [sp, #16]

    /* Check reset reasons from SSRS Status Register. */
    RegValue = (uint32) IP_RCM->SSRS & RCM_SSRS_RWBITS_MASK32;
    6072:	4b25      	ldr	r3, [pc, #148]	; (6108 <Power_Ip_RCM_GetResetReason+0xa8>)
    6074:	699a      	ldr	r2, [r3, #24]
    6076:	f642 73ee 	movw	r3, #12270	; 0x2fee
    607a:	4013      	ands	r3, r2
    607c:	9303      	str	r3, [sp, #12]

    /* Store the content of RSR */
    if ((uint32)0U != RegValue)
    607e:	9b03      	ldr	r3, [sp, #12]
    6080:	2b00      	cmp	r3, #0
    6082:	d008      	beq.n	6096 <Power_Ip_RCM_GetResetReason+0x36>
    {
        /* Clear the flags if any flag is set */
        IP_RCM->SSRS = (uint32)(RegValue & RCM_SSRS_RWBITS_MASK32);
    6084:	4920      	ldr	r1, [pc, #128]	; (6108 <Power_Ip_RCM_GetResetReason+0xa8>)
    6086:	9a03      	ldr	r2, [sp, #12]
    6088:	f642 73ee 	movw	r3, #12270	; 0x2fee
    608c:	4013      	ands	r3, r2
    608e:	618b      	str	r3, [r1, #24]

        Power_Ip_u32ResetStatus = RegValue;
    6090:	4a1e      	ldr	r2, [pc, #120]	; (610c <Power_Ip_RCM_GetResetReason+0xac>)
    6092:	9b03      	ldr	r3, [sp, #12]
    6094:	6013      	str	r3, [r2, #0]
    }
    ActiveValue = Power_Ip_u32ResetStatus;
    6096:	4b1d      	ldr	r3, [pc, #116]	; (610c <Power_Ip_RCM_GetResetReason+0xac>)
    6098:	681b      	ldr	r3, [r3, #0]
    609a:	9302      	str	r3, [sp, #8]

    if((RCM_SSRS_SLVD_MASK | RCM_SSRS_SPOR_MASK) == (ActiveValue & RCM_SSRS_RWBITS_MASK32))
    609c:	9a02      	ldr	r2, [sp, #8]
    609e:	f642 73ee 	movw	r3, #12270	; 0x2fee
    60a2:	4013      	ands	r3, r2
    60a4:	2b82      	cmp	r3, #130	; 0x82
    60a6:	d102      	bne.n	60ae <Power_Ip_RCM_GetResetReason+0x4e>
    {
        ResetReason = (uint32)MCU_POWER_ON_RESET;
    60a8:	2305      	movs	r3, #5
    60aa:	9307      	str	r3, [sp, #28]
    60ac:	e027      	b.n	60fe <Power_Ip_RCM_GetResetReason+0x9e>
    }
    else
    {
        for (Index = 0x00U; Index < 0x20U; Index++)
    60ae:	2300      	movs	r3, #0
    60b0:	9306      	str	r3, [sp, #24]
    60b2:	e021      	b.n	60f8 <Power_Ip_RCM_GetResetReason+0x98>
        {
            DynamicMask = ((uint32)0x80000000U >> Index);
    60b4:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    60b8:	9b06      	ldr	r3, [sp, #24]
    60ba:	fa22 f303 	lsr.w	r3, r2, r3
    60be:	9301      	str	r3, [sp, #4]
            if ((uint32)0x00U != (DynamicMask & RCM_SSRS_RESET_SOURCES_MASK32))
    60c0:	9a01      	ldr	r2, [sp, #4]
    60c2:	f642 73fe 	movw	r3, #12286	; 0x2ffe
    60c6:	4013      	ands	r3, r2
    60c8:	2b00      	cmp	r3, #0
    60ca:	d012      	beq.n	60f2 <Power_Ip_RCM_GetResetReason+0x92>
            {
                if ((uint32)0x00U != (DynamicMask & ActiveValue))
    60cc:	9a01      	ldr	r2, [sp, #4]
    60ce:	9b02      	ldr	r3, [sp, #8]
    60d0:	4013      	ands	r3, r2
    60d2:	2b00      	cmp	r3, #0
    60d4:	d00a      	beq.n	60ec <Power_Ip_RCM_GetResetReason+0x8c>
                {
                    ResetReason = Position;
    60d6:	9b05      	ldr	r3, [sp, #20]
    60d8:	9307      	str	r3, [sp, #28]
                    NumberOfFlags++;
    60da:	9b04      	ldr	r3, [sp, #16]
    60dc:	3301      	adds	r3, #1
    60de:	9304      	str	r3, [sp, #16]
                    /* MCU_MULTIPLE_RESET_REASON returned if more than one reset reason in this case use function Mcu_GetRawValue to determine. */
                    if (NumberOfFlags >= (uint32)2)
    60e0:	9b04      	ldr	r3, [sp, #16]
    60e2:	2b01      	cmp	r3, #1
    60e4:	d902      	bls.n	60ec <Power_Ip_RCM_GetResetReason+0x8c>
                    {
                        ResetReason = (uint32)MCU_MULTIPLE_RESET_REASON;
    60e6:	230d      	movs	r3, #13
    60e8:	9307      	str	r3, [sp, #28]
                        break;
    60ea:	e008      	b.n	60fe <Power_Ip_RCM_GetResetReason+0x9e>
                    }
                }
                Position++;
    60ec:	9b05      	ldr	r3, [sp, #20]
    60ee:	3301      	adds	r3, #1
    60f0:	9305      	str	r3, [sp, #20]
        for (Index = 0x00U; Index < 0x20U; Index++)
    60f2:	9b06      	ldr	r3, [sp, #24]
    60f4:	3301      	adds	r3, #1
    60f6:	9306      	str	r3, [sp, #24]
    60f8:	9b06      	ldr	r3, [sp, #24]
    60fa:	2b1f      	cmp	r3, #31
    60fc:	d9da      	bls.n	60b4 <Power_Ip_RCM_GetResetReason+0x54>
            }
        }
    }
    return ResetReason;
    60fe:	9b07      	ldr	r3, [sp, #28]
}
    6100:	4618      	mov	r0, r3
    6102:	b008      	add	sp, #32
    6104:	4770      	bx	lr
    6106:	bf00      	nop
    6108:	4007f000 	.word	0x4007f000
    610c:	1fff8ce4 	.word	0x1fff8ce4

00006110 <Power_Ip_RCM_GetResetRawValue>:
* @note             The User should ensure that the reset reason is cleared once it has been read
*                   out to avoid multiple reset reasons.
*
*/
Power_Ip_RawResetType Power_Ip_RCM_GetResetRawValue(void)
{
    6110:	b082      	sub	sp, #8
    uint32 RawReset;
    uint32 RegValue;

    RegValue = IP_RCM->SSRS & RCM_SSRS_RWBITS_MASK32;
    6112:	4b0c      	ldr	r3, [pc, #48]	; (6144 <Power_Ip_RCM_GetResetRawValue+0x34>)
    6114:	699a      	ldr	r2, [r3, #24]
    6116:	f642 73ee 	movw	r3, #12270	; 0x2fee
    611a:	4013      	ands	r3, r2
    611c:	9301      	str	r3, [sp, #4]

    if ((uint32)0U != RegValue)
    611e:	9b01      	ldr	r3, [sp, #4]
    6120:	2b00      	cmp	r3, #0
    6122:	d008      	beq.n	6136 <Power_Ip_RCM_GetResetRawValue+0x26>
    {
        /* Clear the flags if any flag is set */
        IP_RCM->SSRS = (uint32)(RegValue & RCM_SSRS_RWBITS_MASK32);
    6124:	4907      	ldr	r1, [pc, #28]	; (6144 <Power_Ip_RCM_GetResetRawValue+0x34>)
    6126:	9a01      	ldr	r2, [sp, #4]
    6128:	f642 73ee 	movw	r3, #12270	; 0x2fee
    612c:	4013      	ands	r3, r2
    612e:	618b      	str	r3, [r1, #24]

        Power_Ip_u32ResetStatus = RegValue;
    6130:	4a05      	ldr	r2, [pc, #20]	; (6148 <Power_Ip_RCM_GetResetRawValue+0x38>)
    6132:	9b01      	ldr	r3, [sp, #4]
    6134:	6013      	str	r3, [r2, #0]
    }

    RawReset = Power_Ip_u32ResetStatus;
    6136:	4b04      	ldr	r3, [pc, #16]	; (6148 <Power_Ip_RCM_GetResetRawValue+0x38>)
    6138:	681b      	ldr	r3, [r3, #0]
    613a:	9300      	str	r3, [sp, #0]

    return (Power_Ip_RawResetType)RawReset;
    613c:	9b00      	ldr	r3, [sp, #0]
}
    613e:	4618      	mov	r0, r3
    6140:	b002      	add	sp, #8
    6142:	4770      	bx	lr
    6144:	4007f000 	.word	0x4007f000
    6148:	1fff8ce4 	.word	0x1fff8ce4

0000614c <Power_Ip_SMC_AllowedModesConfig>:
*
* @details          This function is only called at Mcu initialization
*
*/
void Power_Ip_SMC_AllowedModesConfig(const Power_Ip_SMC_ConfigType * ConfigPtr)
{
    614c:	b082      	sub	sp, #8
    614e:	9001      	str	r0, [sp, #4]
    IP_SMC->PMPROT = ConfigPtr->AllowedModes & SMC_PMPROT_RWBITS_MASK32;
    6150:	9b01      	ldr	r3, [sp, #4]
    6152:	681b      	ldr	r3, [r3, #0]
    6154:	4a03      	ldr	r2, [pc, #12]	; (6164 <Power_Ip_SMC_AllowedModesConfig+0x18>)
    6156:	f003 03a0 	and.w	r3, r3, #160	; 0xa0
    615a:	6093      	str	r3, [r2, #8]
}
    615c:	bf00      	nop
    615e:	b002      	add	sp, #8
    6160:	4770      	bx	lr
    6162:	bf00      	nop
    6164:	4007e000 	.word	0x4007e000

00006168 <Power_Ip_SMC_ModeCheckEntry>:
*
* @return           Power_Ip_SMC_ModeStatusType
*
*/
Power_Ip_SMC_ModeStatusType Power_Ip_SMC_ModeCheckEntry(Power_Ip_PowerModeType PowerMode)
{
    6168:	b084      	sub	sp, #16
    616a:	9001      	str	r0, [sp, #4]
    Power_Ip_SMC_ModeStatusType PowerModeCheck = POWER_IP_MODE_NOT_OK;
    616c:	2301      	movs	r3, #1
    616e:	9303      	str	r3, [sp, #12]
    /* Contains the code of the Power Mode (based PowerModeType enumeration). */
    uint32 CurrentPowerMode;

    CurrentPowerMode = IP_SMC->PMSTAT & SMC_PMSTAT_PMSTAT_MASK;
    6170:	4b15      	ldr	r3, [pc, #84]	; (61c8 <Power_Ip_SMC_ModeCheckEntry+0x60>)
    6172:	695b      	ldr	r3, [r3, #20]
    6174:	b2db      	uxtb	r3, r3
    6176:	9302      	str	r3, [sp, #8]

    switch (PowerMode)
    6178:	9b01      	ldr	r3, [sp, #4]
    617a:	2b02      	cmp	r3, #2
    617c:	d012      	beq.n	61a4 <Power_Ip_SMC_ModeCheckEntry+0x3c>
    617e:	9b01      	ldr	r3, [sp, #4]
    6180:	2b02      	cmp	r3, #2
    6182:	d818      	bhi.n	61b6 <Power_Ip_SMC_ModeCheckEntry+0x4e>
    6184:	9b01      	ldr	r3, [sp, #4]
    6186:	2b00      	cmp	r3, #0
    6188:	d003      	beq.n	6192 <Power_Ip_SMC_ModeCheckEntry+0x2a>
    618a:	9b01      	ldr	r3, [sp, #4]
    618c:	2b01      	cmp	r3, #1
    618e:	d003      	beq.n	6198 <Power_Ip_SMC_ModeCheckEntry+0x30>
        }
#endif /* (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON) */
        default:
        {
            /* Do nothing */
            break;
    6190:	e011      	b.n	61b6 <Power_Ip_SMC_ModeCheckEntry+0x4e>
            PowerModeCheck = POWER_IP_MODE_OK;
    6192:	2300      	movs	r3, #0
    6194:	9303      	str	r3, [sp, #12]
            break;
    6196:	e013      	b.n	61c0 <Power_Ip_SMC_ModeCheckEntry+0x58>
            if (SMC_PMSTAT_RUN_U32 == CurrentPowerMode)
    6198:	9b02      	ldr	r3, [sp, #8]
    619a:	2b01      	cmp	r3, #1
    619c:	d10d      	bne.n	61ba <Power_Ip_SMC_ModeCheckEntry+0x52>
                PowerModeCheck = POWER_IP_MODE_OK;
    619e:	2300      	movs	r3, #0
    61a0:	9303      	str	r3, [sp, #12]
            break;
    61a2:	e00a      	b.n	61ba <Power_Ip_SMC_ModeCheckEntry+0x52>
            if ((SMC_PMSTAT_RUN_U32 == CurrentPowerMode) || (SMC_PMSTAT_VLPS_U32 == CurrentPowerMode))
    61a4:	9b02      	ldr	r3, [sp, #8]
    61a6:	2b01      	cmp	r3, #1
    61a8:	d002      	beq.n	61b0 <Power_Ip_SMC_ModeCheckEntry+0x48>
    61aa:	9b02      	ldr	r3, [sp, #8]
    61ac:	2b10      	cmp	r3, #16
    61ae:	d106      	bne.n	61be <Power_Ip_SMC_ModeCheckEntry+0x56>
                PowerModeCheck = POWER_IP_MODE_OK;
    61b0:	2300      	movs	r3, #0
    61b2:	9303      	str	r3, [sp, #12]
            break;
    61b4:	e003      	b.n	61be <Power_Ip_SMC_ModeCheckEntry+0x56>
            break;
    61b6:	bf00      	nop
    61b8:	e002      	b.n	61c0 <Power_Ip_SMC_ModeCheckEntry+0x58>
            break;
    61ba:	bf00      	nop
    61bc:	e000      	b.n	61c0 <Power_Ip_SMC_ModeCheckEntry+0x58>
            break;
    61be:	bf00      	nop
        }
    }

    return PowerModeCheck;
    61c0:	9b03      	ldr	r3, [sp, #12]
}
    61c2:	4618      	mov	r0, r3
    61c4:	b004      	add	sp, #16
    61c6:	4770      	bx	lr
    61c8:	4007e000 	.word	0x4007e000

000061cc <Power_Ip_SMC_ModeConfig>:
*
* @return           uint32
*
*/
uint32 Power_Ip_SMC_ModeConfig(const Power_Ip_ModeConfigType * ModeConfigPtr)
{
    61cc:	b500      	push	{lr}
    61ce:	b08b      	sub	sp, #44	; 0x2c
    61d0:	9001      	str	r0, [sp, #4]
    uint32 PowerSwitchMode = POWER_IP_SWITCH_MODE_SUCCESS;
    61d2:	2300      	movs	r3, #0
    61d4:	9309      	str	r3, [sp, #36]	; 0x24
    /* Contains the code of the Power Mode (based PowerModeType enumeration). */
    Power_Ip_PowerModeType PowerMode = POWER_IP_RUN_MODE;
    61d6:	2300      	movs	r3, #0
    61d8:	9308      	str	r3, [sp, #32]
    uint32 RegValue = (uint32)0U;
#endif
    uint32 StartTime;
    uint32 ElapsedTime;
    uint32 TimeoutTicks;
    boolean TimeoutOccurred = FALSE;
    61da:	2300      	movs	r3, #0
    61dc:	f88d 301f 	strb.w	r3, [sp, #31]

    PowerMode = ModeConfigPtr->PowerMode;
    61e0:	9b01      	ldr	r3, [sp, #4]
    61e2:	685b      	ldr	r3, [r3, #4]
    61e4:	9308      	str	r3, [sp, #32]

    switch (PowerMode)
    61e6:	9b08      	ldr	r3, [sp, #32]
    61e8:	2b02      	cmp	r3, #2
    61ea:	d076      	beq.n	62da <Power_Ip_SMC_ModeConfig+0x10e>
    61ec:	9b08      	ldr	r3, [sp, #32]
    61ee:	2b02      	cmp	r3, #2
    61f0:	f200 80ab 	bhi.w	634a <Power_Ip_SMC_ModeConfig+0x17e>
    61f4:	9b08      	ldr	r3, [sp, #32]
    61f6:	2b00      	cmp	r3, #0
    61f8:	d003      	beq.n	6202 <Power_Ip_SMC_ModeConfig+0x36>
    61fa:	9b08      	ldr	r3, [sp, #32]
    61fc:	2b01      	cmp	r3, #1
    61fe:	d034      	beq.n	626a <Power_Ip_SMC_ModeConfig+0x9e>
    6200:	e0a3      	b.n	634a <Power_Ip_SMC_ModeConfig+0x17e>
    {
        case (POWER_IP_RUN_MODE):
        {
            /* Set RUN mode */
            TempValue = IP_SMC->PMCTRL;
    6202:	4b58      	ldr	r3, [pc, #352]	; (6364 <Power_Ip_SMC_ModeConfig+0x198>)
    6204:	68db      	ldr	r3, [r3, #12]
    6206:	9306      	str	r3, [sp, #24]
            TempValue &= ~SMC_PMCTRL_RUNM_MASK;
    6208:	9b06      	ldr	r3, [sp, #24]
    620a:	f023 0360 	bic.w	r3, r3, #96	; 0x60
    620e:	9306      	str	r3, [sp, #24]
            TempValue |= SMC_PMCTRL_RUN_MODE_U32;
            IP_SMC->PMCTRL = TempValue;
    6210:	4a54      	ldr	r2, [pc, #336]	; (6364 <Power_Ip_SMC_ModeConfig+0x198>)
    6212:	9b06      	ldr	r3, [sp, #24]
    6214:	60d3      	str	r3, [r2, #12]

            /* Read back to make sure that mode changed successfuly */
            Power_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, POWER_IP_TIMEOUT_VALUE_US);
    6216:	aa02      	add	r2, sp, #8
    6218:	a903      	add	r1, sp, #12
    621a:	a804      	add	r0, sp, #16
    621c:	f24c 3350 	movw	r3, #50000	; 0xc350
    6220:	f7ff fece 	bl	5fc0 <Power_Ip_StartTimeout>
            do
            {
                TimeoutOccurred = Power_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    6224:	9a02      	ldr	r2, [sp, #8]
    6226:	a903      	add	r1, sp, #12
    6228:	ab04      	add	r3, sp, #16
    622a:	4618      	mov	r0, r3
    622c:	f7ff fee2 	bl	5ff4 <Power_Ip_TimeoutExpired>
    6230:	4603      	mov	r3, r0
    6232:	f88d 301f 	strb.w	r3, [sp, #31]
                PowerModeStatus = (IP_SMC->PMSTAT & SMC_PMSTAT_RUN_U32);
    6236:	4b4b      	ldr	r3, [pc, #300]	; (6364 <Power_Ip_SMC_ModeConfig+0x198>)
    6238:	695b      	ldr	r3, [r3, #20]
    623a:	f003 0301 	and.w	r3, r3, #1
    623e:	9305      	str	r3, [sp, #20]
            } while ( (SMC_PMSTAT_RUN_U32 != PowerModeStatus) && (!TimeoutOccurred) );
    6240:	9b05      	ldr	r3, [sp, #20]
    6242:	2b01      	cmp	r3, #1
    6244:	d006      	beq.n	6254 <Power_Ip_SMC_ModeConfig+0x88>
    6246:	f89d 301f 	ldrb.w	r3, [sp, #31]
    624a:	f083 0301 	eor.w	r3, r3, #1
    624e:	b2db      	uxtb	r3, r3
    6250:	2b00      	cmp	r3, #0
    6252:	d1e7      	bne.n	6224 <Power_Ip_SMC_ModeConfig+0x58>
            if(TimeoutOccurred)
    6254:	f89d 301f 	ldrb.w	r3, [sp, #31]
    6258:	2b00      	cmp	r3, #0
    625a:	d079      	beq.n	6350 <Power_Ip_SMC_ModeConfig+0x184>
            {
                PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    625c:	2301      	movs	r3, #1
    625e:	9309      	str	r3, [sp, #36]	; 0x24
                Power_Ip_ReportPowerErrors(POWER_IP_REPORT_TIMEOUT_ERROR, POWER_IP_ERR_CODE_RESERVED);
    6260:	21ff      	movs	r1, #255	; 0xff
    6262:	2000      	movs	r0, #0
    6264:	f7ff fe90 	bl	5f88 <Power_Ip_ReportPowerErrors>
            }

            break;
    6268:	e072      	b.n	6350 <Power_Ip_SMC_ModeConfig+0x184>
        }
        case (POWER_IP_HSRUN_MODE):
        {
            /* Set HSRUN mode. */
            TempValue = IP_SMC->PMCTRL;
    626a:	4b3e      	ldr	r3, [pc, #248]	; (6364 <Power_Ip_SMC_ModeConfig+0x198>)
    626c:	68db      	ldr	r3, [r3, #12]
    626e:	9306      	str	r3, [sp, #24]
            TempValue &= ~SMC_PMCTRL_RUNM_MASK;
    6270:	9b06      	ldr	r3, [sp, #24]
    6272:	f023 0360 	bic.w	r3, r3, #96	; 0x60
    6276:	9306      	str	r3, [sp, #24]
            TempValue |= SMC_PMCTRL_HSRUN_MODE_U32;
    6278:	9b06      	ldr	r3, [sp, #24]
    627a:	f043 0360 	orr.w	r3, r3, #96	; 0x60
    627e:	9306      	str	r3, [sp, #24]
            IP_SMC->PMCTRL = TempValue;
    6280:	4a38      	ldr	r2, [pc, #224]	; (6364 <Power_Ip_SMC_ModeConfig+0x198>)
    6282:	9b06      	ldr	r3, [sp, #24]
    6284:	60d3      	str	r3, [r2, #12]

            /* Read back to make sure that mode changed successfuly */
            Power_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, POWER_IP_TIMEOUT_VALUE_US);
    6286:	aa02      	add	r2, sp, #8
    6288:	a903      	add	r1, sp, #12
    628a:	a804      	add	r0, sp, #16
    628c:	f24c 3350 	movw	r3, #50000	; 0xc350
    6290:	f7ff fe96 	bl	5fc0 <Power_Ip_StartTimeout>
            do
            {
                TimeoutOccurred = Power_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    6294:	9a02      	ldr	r2, [sp, #8]
    6296:	a903      	add	r1, sp, #12
    6298:	ab04      	add	r3, sp, #16
    629a:	4618      	mov	r0, r3
    629c:	f7ff feaa 	bl	5ff4 <Power_Ip_TimeoutExpired>
    62a0:	4603      	mov	r3, r0
    62a2:	f88d 301f 	strb.w	r3, [sp, #31]
                PowerModeStatus = (IP_SMC->PMSTAT & SMC_PMSTAT_HSRUN_U32);
    62a6:	4b2f      	ldr	r3, [pc, #188]	; (6364 <Power_Ip_SMC_ModeConfig+0x198>)
    62a8:	695b      	ldr	r3, [r3, #20]
    62aa:	f003 0380 	and.w	r3, r3, #128	; 0x80
    62ae:	9305      	str	r3, [sp, #20]
            } while ( (SMC_PMSTAT_HSRUN_U32 != PowerModeStatus) && (!TimeoutOccurred) );
    62b0:	9b05      	ldr	r3, [sp, #20]
    62b2:	2b80      	cmp	r3, #128	; 0x80
    62b4:	d006      	beq.n	62c4 <Power_Ip_SMC_ModeConfig+0xf8>
    62b6:	f89d 301f 	ldrb.w	r3, [sp, #31]
    62ba:	f083 0301 	eor.w	r3, r3, #1
    62be:	b2db      	uxtb	r3, r3
    62c0:	2b00      	cmp	r3, #0
    62c2:	d1e7      	bne.n	6294 <Power_Ip_SMC_ModeConfig+0xc8>
            if(TimeoutOccurred)
    62c4:	f89d 301f 	ldrb.w	r3, [sp, #31]
    62c8:	2b00      	cmp	r3, #0
    62ca:	d043      	beq.n	6354 <Power_Ip_SMC_ModeConfig+0x188>
            {
                PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    62cc:	2301      	movs	r3, #1
    62ce:	9309      	str	r3, [sp, #36]	; 0x24
                Power_Ip_ReportPowerErrors(POWER_IP_REPORT_TIMEOUT_ERROR, POWER_IP_ERR_CODE_RESERVED);
    62d0:	21ff      	movs	r1, #255	; 0xff
    62d2:	2000      	movs	r0, #0
    62d4:	f7ff fe58 	bl	5f88 <Power_Ip_ReportPowerErrors>
            }

            break;
    62d8:	e03c      	b.n	6354 <Power_Ip_SMC_ModeConfig+0x188>
        }
        case (POWER_IP_VLPR_MODE):
        {
            /* Set VLPR mode. */
            TempValue = IP_SMC->PMCTRL;
    62da:	4b22      	ldr	r3, [pc, #136]	; (6364 <Power_Ip_SMC_ModeConfig+0x198>)
    62dc:	68db      	ldr	r3, [r3, #12]
    62de:	9306      	str	r3, [sp, #24]
            TempValue &= ~SMC_PMCTRL_RUNM_MASK;
    62e0:	9b06      	ldr	r3, [sp, #24]
    62e2:	f023 0360 	bic.w	r3, r3, #96	; 0x60
    62e6:	9306      	str	r3, [sp, #24]
            TempValue |= SMC_PMCTRL_VLPR_MODE_U32;
    62e8:	9b06      	ldr	r3, [sp, #24]
    62ea:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    62ee:	9306      	str	r3, [sp, #24]
            IP_SMC->PMCTRL = TempValue;
    62f0:	4a1c      	ldr	r2, [pc, #112]	; (6364 <Power_Ip_SMC_ModeConfig+0x198>)
    62f2:	9b06      	ldr	r3, [sp, #24]
    62f4:	60d3      	str	r3, [r2, #12]

            /* Read back to make sure that mode changed successfuly */
            Power_Ip_StartTimeout(&StartTime, &ElapsedTime, &TimeoutTicks, POWER_IP_TIMEOUT_VALUE_US);
    62f6:	aa02      	add	r2, sp, #8
    62f8:	a903      	add	r1, sp, #12
    62fa:	a804      	add	r0, sp, #16
    62fc:	f24c 3350 	movw	r3, #50000	; 0xc350
    6300:	f7ff fe5e 	bl	5fc0 <Power_Ip_StartTimeout>
            do
            {
                TimeoutOccurred = Power_Ip_TimeoutExpired(&StartTime, &ElapsedTime, TimeoutTicks);
    6304:	9a02      	ldr	r2, [sp, #8]
    6306:	a903      	add	r1, sp, #12
    6308:	ab04      	add	r3, sp, #16
    630a:	4618      	mov	r0, r3
    630c:	f7ff fe72 	bl	5ff4 <Power_Ip_TimeoutExpired>
    6310:	4603      	mov	r3, r0
    6312:	f88d 301f 	strb.w	r3, [sp, #31]
                PowerModeStatus = (IP_SMC->PMSTAT & SMC_PMSTAT_VLPR_U32);
    6316:	4b13      	ldr	r3, [pc, #76]	; (6364 <Power_Ip_SMC_ModeConfig+0x198>)
    6318:	695b      	ldr	r3, [r3, #20]
    631a:	f003 0304 	and.w	r3, r3, #4
    631e:	9305      	str	r3, [sp, #20]
            } while ( (SMC_PMSTAT_VLPR_U32 != PowerModeStatus) && (!TimeoutOccurred) );
    6320:	9b05      	ldr	r3, [sp, #20]
    6322:	2b04      	cmp	r3, #4
    6324:	d006      	beq.n	6334 <Power_Ip_SMC_ModeConfig+0x168>
    6326:	f89d 301f 	ldrb.w	r3, [sp, #31]
    632a:	f083 0301 	eor.w	r3, r3, #1
    632e:	b2db      	uxtb	r3, r3
    6330:	2b00      	cmp	r3, #0
    6332:	d1e7      	bne.n	6304 <Power_Ip_SMC_ModeConfig+0x138>
            if(TimeoutOccurred)
    6334:	f89d 301f 	ldrb.w	r3, [sp, #31]
    6338:	2b00      	cmp	r3, #0
    633a:	d00d      	beq.n	6358 <Power_Ip_SMC_ModeConfig+0x18c>
            {
                PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    633c:	2301      	movs	r3, #1
    633e:	9309      	str	r3, [sp, #36]	; 0x24
                Power_Ip_ReportPowerErrors(POWER_IP_REPORT_TIMEOUT_ERROR, POWER_IP_ERR_CODE_RESERVED);
    6340:	21ff      	movs	r1, #255	; 0xff
    6342:	2000      	movs	r0, #0
    6344:	f7ff fe20 	bl	5f88 <Power_Ip_ReportPowerErrors>
            }

            break;
    6348:	e006      	b.n	6358 <Power_Ip_SMC_ModeConfig+0x18c>
        }
#endif /* (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON) */
        default:
        {
            /*Only the above modes are allowed when this function is called*/
            PowerSwitchMode = POWER_IP_SWITCH_MODE_FAIL;
    634a:	2301      	movs	r3, #1
    634c:	9309      	str	r3, [sp, #36]	; 0x24
            break;
    634e:	e004      	b.n	635a <Power_Ip_SMC_ModeConfig+0x18e>
            break;
    6350:	bf00      	nop
    6352:	e002      	b.n	635a <Power_Ip_SMC_ModeConfig+0x18e>
            break;
    6354:	bf00      	nop
    6356:	e000      	b.n	635a <Power_Ip_SMC_ModeConfig+0x18e>
            break;
    6358:	bf00      	nop
#if (POWER_IP_ENTER_LOW_POWER_MODE == STD_ON)
    /* Avoid compiler warning */
    (void)RegValue;
#endif

    return PowerSwitchMode;
    635a:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    635c:	4618      	mov	r0, r3
    635e:	b00b      	add	sp, #44	; 0x2c
    6360:	f85d fb04 	ldr.w	pc, [sp], #4
    6364:	4007e000 	.word	0x4007e000

00006368 <Port_Init>:
*/
void Port_Init
(
    const Port_ConfigType * ConfigPtr
)
{
    6368:	b500      	push	{lr}
    636a:	b085      	sub	sp, #20
    636c:	9001      	str	r0, [sp, #4]
#if (STD_ON == PORT_PRECOMPILE_SUPPORT)
    const Port_ConfigType * pLocalConfigPtr = &Port_Config;
    /* Cast ConfigPtr to avoid the compiler warning when configuring with PORT_PRECOMPILE_SUPPORT == STD_ON and PORT_DEV_ERROR_DETECT == STD_OFF */
    (void)ConfigPtr;
#else
    const Port_ConfigType * pLocalConfigPtr = ConfigPtr;
    636e:	9b01      	ldr	r3, [sp, #4]
    6370:	9303      	str	r3, [sp, #12]
#endif /* (STD_ON == PORT_PRECOMPILE_SUPPORT) */

#if (STD_ON == PORT_DEV_ERROR_DETECT)
    uint8 CoreId;

    CoreId = (uint8)Port_GetCoreID();
    6372:	2300      	movs	r3, #0
    6374:	f88d 300b 	strb.w	r3, [sp, #11]
#if (STD_OFF == PORT_PRECOMPILE_SUPPORT)
    if (NULL_PTR == ConfigPtr)
    6378:	9b01      	ldr	r3, [sp, #4]
    637a:	2b00      	cmp	r3, #0
    637c:	d106      	bne.n	638c <Port_Init+0x24>
#else /*(STD_OFF == PORT_PRECOMPILE_SUPPORT) */
    if (NULL_PTR != ConfigPtr)
#endif /* (STD_OFF == PORT_PRECOMPILE_SUPPORT) */
    {
        (void)Det_ReportError((uint16)PORT_MODULE_ID, PORT_INSTANCE_ID, (uint8)PORT_INIT_ID, (uint8)PORT_E_INIT_FAILED);
    637e:	230c      	movs	r3, #12
    6380:	2200      	movs	r2, #0
    6382:	2100      	movs	r1, #0
    6384:	207c      	movs	r0, #124	; 0x7c
    6386:	f00d ffcb 	bl	14320 <Det_ReportError>

            /*  Save configuration pointer in global variable */
            Port_pConfigPtr = pLocalConfigPtr;
        }
    }
}
    638a:	e014      	b.n	63b6 <Port_Init+0x4e>
        if ((uint32)1 != pLocalConfigPtr->pau8Port_PartitionList[CoreId])
    638c:	9b03      	ldr	r3, [sp, #12]
    638e:	69da      	ldr	r2, [r3, #28]
    6390:	f89d 300b 	ldrb.w	r3, [sp, #11]
    6394:	4413      	add	r3, r2
    6396:	781b      	ldrb	r3, [r3, #0]
    6398:	2b01      	cmp	r3, #1
    639a:	d006      	beq.n	63aa <Port_Init+0x42>
            (void)Det_ReportError((uint16)PORT_MODULE_ID, PORT_INSTANCE_ID, (uint8)PORT_INIT_ID, (uint8)PORT_E_PARAM_CONFIG);
    639c:	23f0      	movs	r3, #240	; 0xf0
    639e:	2200      	movs	r2, #0
    63a0:	2100      	movs	r1, #0
    63a2:	207c      	movs	r0, #124	; 0x7c
    63a4:	f00d ffbc 	bl	14320 <Det_ReportError>
}
    63a8:	e005      	b.n	63b6 <Port_Init+0x4e>
            Port_Ipw_Init(pLocalConfigPtr);
    63aa:	9803      	ldr	r0, [sp, #12]
    63ac:	f000 fc64 	bl	6c78 <Port_Ipw_Init>
            Port_pConfigPtr = pLocalConfigPtr;
    63b0:	4a03      	ldr	r2, [pc, #12]	; (63c0 <Port_Init+0x58>)
    63b2:	9b03      	ldr	r3, [sp, #12]
    63b4:	6013      	str	r3, [r2, #0]
}
    63b6:	bf00      	nop
    63b8:	b005      	add	sp, #20
    63ba:	f85d fb04 	ldr.w	pc, [sp], #4
    63be:	bf00      	nop
    63c0:	1fff8ce8 	.word	0x1fff8ce8

000063c4 <Port_SetPinDirection>:
void Port_SetPinDirection
(
    Port_PinType Pin,
    Port_PinDirectionType Direction
)
{
    63c4:	b500      	push	{lr}
    63c6:	b085      	sub	sp, #20
    63c8:	9001      	str	r0, [sp, #4]
    63ca:	9100      	str	r1, [sp, #0]
#if (STD_ON == PORT_DEV_ERROR_DETECT)
    /* Variable used to store current error status */
    Std_ReturnType ErrStatus;

    /* Check if Port module is initialized */
    if (NULL_PTR == Port_pConfigPtr)
    63cc:	4b11      	ldr	r3, [pc, #68]	; (6414 <Port_SetPinDirection+0x50>)
    63ce:	681b      	ldr	r3, [r3, #0]
    63d0:	2b00      	cmp	r3, #0
    63d2:	d106      	bne.n	63e2 <Port_SetPinDirection+0x1e>
    {
        (void)Det_ReportError((uint16)PORT_MODULE_ID, (uint8)PORT_INSTANCE_ID, (uint8)PORT_SETPINDIRECTION_ID, (uint8)PORT_E_UNINIT);
    63d4:	230f      	movs	r3, #15
    63d6:	2201      	movs	r2, #1
    63d8:	2100      	movs	r1, #0
    63da:	207c      	movs	r0, #124	; 0x7c
    63dc:	f00d ffa0 	bl	14320 <Det_ReportError>
        {
            (void)Det_ReportError((uint16)PORT_MODULE_ID, (uint8)PORT_INSTANCE_ID, (uint8)PORT_SETPINDIRECTION_ID, (uint8)PORT_E_DIRECTION_UNCHANGEABLE);
        }
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */
    }
}
    63e0:	e013      	b.n	640a <Port_SetPinDirection+0x46>
        ErrStatus = Port_Ipw_SetPinDirection(Pin, Direction, Port_pConfigPtr);
    63e2:	4b0c      	ldr	r3, [pc, #48]	; (6414 <Port_SetPinDirection+0x50>)
    63e4:	681b      	ldr	r3, [r3, #0]
    63e6:	461a      	mov	r2, r3
    63e8:	9900      	ldr	r1, [sp, #0]
    63ea:	9801      	ldr	r0, [sp, #4]
    63ec:	f000 fcb2 	bl	6d54 <Port_Ipw_SetPinDirection>
    63f0:	4603      	mov	r3, r0
    63f2:	f88d 300f 	strb.w	r3, [sp, #15]
        if ((Std_ReturnType)E_NOT_OK == ErrStatus)
    63f6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    63fa:	2b01      	cmp	r3, #1
    63fc:	d105      	bne.n	640a <Port_SetPinDirection+0x46>
            (void)Det_ReportError((uint16)PORT_MODULE_ID, (uint8)PORT_INSTANCE_ID, (uint8)PORT_SETPINDIRECTION_ID, (uint8)PORT_E_DIRECTION_UNCHANGEABLE);
    63fe:	230b      	movs	r3, #11
    6400:	2201      	movs	r2, #1
    6402:	2100      	movs	r1, #0
    6404:	207c      	movs	r0, #124	; 0x7c
    6406:	f00d ff8b 	bl	14320 <Det_ReportError>
}
    640a:	bf00      	nop
    640c:	b005      	add	sp, #20
    640e:	f85d fb04 	ldr.w	pc, [sp], #4
    6412:	bf00      	nop
    6414:	1fff8ce8 	.word	0x1fff8ce8

00006418 <Port_SetPinMode>:
void Port_SetPinMode
(
    Port_PinType Pin,
    Port_PinModeType Mode
)
{
    6418:	b500      	push	{lr}
    641a:	b085      	sub	sp, #20
    641c:	9001      	str	r0, [sp, #4]
    641e:	460b      	mov	r3, r1
    6420:	f88d 3003 	strb.w	r3, [sp, #3]
#if (STD_ON == PORT_DEV_ERROR_DETECT)
    uint8 u8PinModeError = (uint8)0U;
    6424:	2300      	movs	r3, #0
    6426:	f88d 300f 	strb.w	r3, [sp, #15]

    /* Check if port is initialized */
    if (NULL_PTR == Port_pConfigPtr)
    642a:	4b12      	ldr	r3, [pc, #72]	; (6474 <Port_SetPinMode+0x5c>)
    642c:	681b      	ldr	r3, [r3, #0]
    642e:	2b00      	cmp	r3, #0
    6430:	d106      	bne.n	6440 <Port_SetPinMode+0x28>
    {
        (void)Det_ReportError((uint16)PORT_MODULE_ID, (uint8)PORT_INSTANCE_ID, (uint8)PORT_SETPINMODE_ID, (uint8)PORT_E_UNINIT);
    6432:	230f      	movs	r3, #15
    6434:	2204      	movs	r2, #4
    6436:	2100      	movs	r1, #0
    6438:	207c      	movs	r0, #124	; 0x7c
    643a:	f00d ff71 	bl	14320 <Det_ReportError>
        {
            (void)Det_ReportError((uint16)PORT_MODULE_ID, (uint8)PORT_INSTANCE_ID, (uint8)PORT_SETPINMODE_ID, (uint8)PORT_E_PARAM_INVALID_MODE);
        }
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */
    }
}
    643e:	e014      	b.n	646a <Port_SetPinMode+0x52>
        u8PinModeError = (uint8)Port_Ipw_SetPinMode(Pin, Mode, Port_pConfigPtr);
    6440:	4b0c      	ldr	r3, [pc, #48]	; (6474 <Port_SetPinMode+0x5c>)
    6442:	681a      	ldr	r2, [r3, #0]
    6444:	f89d 3003 	ldrb.w	r3, [sp, #3]
    6448:	4619      	mov	r1, r3
    644a:	9801      	ldr	r0, [sp, #4]
    644c:	f000 fd7a 	bl	6f44 <Port_Ipw_SetPinMode>
    6450:	4603      	mov	r3, r0
    6452:	f88d 300f 	strb.w	r3, [sp, #15]
        if (PORT_E_PARAM_INVALID_MODE == u8PinModeError)
    6456:	f89d 300f 	ldrb.w	r3, [sp, #15]
    645a:	2b0d      	cmp	r3, #13
    645c:	d105      	bne.n	646a <Port_SetPinMode+0x52>
            (void)Det_ReportError((uint16)PORT_MODULE_ID, (uint8)PORT_INSTANCE_ID, (uint8)PORT_SETPINMODE_ID, (uint8)PORT_E_PARAM_INVALID_MODE);
    645e:	230d      	movs	r3, #13
    6460:	2204      	movs	r2, #4
    6462:	2100      	movs	r1, #0
    6464:	207c      	movs	r0, #124	; 0x7c
    6466:	f00d ff5b 	bl	14320 <Det_ReportError>
}
    646a:	bf00      	nop
    646c:	b005      	add	sp, #20
    646e:	f85d fb04 	ldr.w	pc, [sp], #4
    6472:	bf00      	nop
    6474:	1fff8ce8 	.word	0x1fff8ce8

00006478 <Port_RefreshPortDirection>:
*          are configured as "pin direction changeable during runtime".
* @pre     @p Port_Init() must have been called first.
*
*/
void Port_RefreshPortDirection( void )
{
    6478:	b500      	push	{lr}
    647a:	b083      	sub	sp, #12
#if (STD_ON == PORT_DEV_ERROR_DETECT)
    uint8 CoreId;

    CoreId = (uint8)Port_GetCoreID();
    647c:	2300      	movs	r3, #0
    647e:	f88d 3007 	strb.w	r3, [sp, #7]
    /* Check if Port module is initialized */
    if (NULL_PTR == Port_pConfigPtr)
    6482:	4b12      	ldr	r3, [pc, #72]	; (64cc <Port_RefreshPortDirection+0x54>)
    6484:	681b      	ldr	r3, [r3, #0]
    6486:	2b00      	cmp	r3, #0
    6488:	d106      	bne.n	6498 <Port_RefreshPortDirection+0x20>
    {
        (void)Det_ReportError((uint16)PORT_MODULE_ID, (uint8)PORT_INSTANCE_ID, (uint8)PORT_REFRESHPINDIRECTION_ID, (uint8)PORT_E_UNINIT);
    648a:	230f      	movs	r3, #15
    648c:	2202      	movs	r2, #2
    648e:	2100      	movs	r1, #0
    6490:	207c      	movs	r0, #124	; 0x7c
    6492:	f00d ff45 	bl	14320 <Det_ReportError>
    else
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */
    {
        Port_Ipw_RefreshPortDirection(Port_pConfigPtr);
    }
}
    6496:	e014      	b.n	64c2 <Port_RefreshPortDirection+0x4a>
    else if ((uint32)1 != Port_pConfigPtr->pau8Port_PartitionList[CoreId])
    6498:	4b0c      	ldr	r3, [pc, #48]	; (64cc <Port_RefreshPortDirection+0x54>)
    649a:	681b      	ldr	r3, [r3, #0]
    649c:	69da      	ldr	r2, [r3, #28]
    649e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    64a2:	4413      	add	r3, r2
    64a4:	781b      	ldrb	r3, [r3, #0]
    64a6:	2b01      	cmp	r3, #1
    64a8:	d006      	beq.n	64b8 <Port_RefreshPortDirection+0x40>
        (void)Det_ReportError((uint16)PORT_MODULE_ID, PORT_INSTANCE_ID, (uint8)PORT_REFRESHPINDIRECTION_ID, (uint8)PORT_E_PARAM_CONFIG);
    64aa:	23f0      	movs	r3, #240	; 0xf0
    64ac:	2202      	movs	r2, #2
    64ae:	2100      	movs	r1, #0
    64b0:	207c      	movs	r0, #124	; 0x7c
    64b2:	f00d ff35 	bl	14320 <Det_ReportError>
}
    64b6:	e004      	b.n	64c2 <Port_RefreshPortDirection+0x4a>
        Port_Ipw_RefreshPortDirection(Port_pConfigPtr);
    64b8:	4b04      	ldr	r3, [pc, #16]	; (64cc <Port_RefreshPortDirection+0x54>)
    64ba:	681b      	ldr	r3, [r3, #0]
    64bc:	4618      	mov	r0, r3
    64be:	f000 febf 	bl	7240 <Port_Ipw_RefreshPortDirection>
}
    64c2:	bf00      	nop
    64c4:	b003      	add	sp, #12
    64c6:	f85d fb04 	ldr.w	pc, [sp], #4
    64ca:	bf00      	nop
    64cc:	1fff8ce8 	.word	0x1fff8ce8

000064d0 <Port_GetVersionInfo>:
*/
void Port_GetVersionInfo
(
    Std_VersionInfoType * versioninfo
)
{
    64d0:	b500      	push	{lr}
    64d2:	b083      	sub	sp, #12
    64d4:	9001      	str	r0, [sp, #4]
#if (STD_ON == PORT_DEV_ERROR_DETECT)
    if (NULL_PTR == versioninfo)
    64d6:	9b01      	ldr	r3, [sp, #4]
    64d8:	2b00      	cmp	r3, #0
    64da:	d106      	bne.n	64ea <Port_GetVersionInfo+0x1a>
    {
        (void)Det_ReportError((uint16)PORT_MODULE_ID, (uint8)PORT_INSTANCE_ID, (uint8)PORT_GETVERSIONINFO_ID, (uint8)PORT_E_PARAM_POINTER);
    64dc:	2310      	movs	r3, #16
    64de:	2203      	movs	r2, #3
    64e0:	2100      	movs	r1, #0
    64e2:	207c      	movs	r0, #124	; 0x7c
    64e4:	f00d ff1c 	bl	14320 <Det_ReportError>
        (versioninfo)->moduleID         = (uint16)PORT_MODULE_ID;
        (versioninfo)->sw_major_version = (uint8)PORT_SW_MAJOR_VERSION;
        (versioninfo)->sw_minor_version = (uint8)PORT_SW_MINOR_VERSION;
        (versioninfo)->sw_patch_version = (uint8)PORT_SW_PATCH_VERSION;
    }
}
    64e8:	e00e      	b.n	6508 <Port_GetVersionInfo+0x38>
        (versioninfo)->vendorID         = (uint16)PORT_VENDOR_ID;
    64ea:	9b01      	ldr	r3, [sp, #4]
    64ec:	222b      	movs	r2, #43	; 0x2b
    64ee:	801a      	strh	r2, [r3, #0]
        (versioninfo)->moduleID         = (uint16)PORT_MODULE_ID;
    64f0:	9b01      	ldr	r3, [sp, #4]
    64f2:	227c      	movs	r2, #124	; 0x7c
    64f4:	805a      	strh	r2, [r3, #2]
        (versioninfo)->sw_major_version = (uint8)PORT_SW_MAJOR_VERSION;
    64f6:	9b01      	ldr	r3, [sp, #4]
    64f8:	2202      	movs	r2, #2
    64fa:	711a      	strb	r2, [r3, #4]
        (versioninfo)->sw_minor_version = (uint8)PORT_SW_MINOR_VERSION;
    64fc:	9b01      	ldr	r3, [sp, #4]
    64fe:	2200      	movs	r2, #0
    6500:	715a      	strb	r2, [r3, #5]
        (versioninfo)->sw_patch_version = (uint8)PORT_SW_PATCH_VERSION;
    6502:	9b01      	ldr	r3, [sp, #4]
    6504:	2200      	movs	r2, #0
    6506:	719a      	strb	r2, [r3, #6]
}
    6508:	bf00      	nop
    650a:	b003      	add	sp, #12
    650c:	f85d fb04 	ldr.w	pc, [sp], #4

00006510 <Port_Ci_Port_Ip_GetAdcInterleaveVal>:
(
    const PORT_Type * base,
    const uint32 pinPortIdx,
    const uint32 currentVal
)
{
    6510:	b086      	sub	sp, #24
    6512:	9003      	str	r0, [sp, #12]
    6514:	9102      	str	r1, [sp, #8]
    6516:	9201      	str	r2, [sp, #4]
    uint32 adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_INVALID;
    6518:	23ff      	movs	r3, #255	; 0xff
    651a:	9305      	str	r3, [sp, #20]
    /* calculate appropriate value to enable or disable in SIM_CHIPCTL[ADC_INTERLEAVE_EN] */
    if ((uint32)base == (uint32)IP_PORTB)
    651c:	9b03      	ldr	r3, [sp, #12]
    651e:	4a39      	ldr	r2, [pc, #228]	; (6604 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xf4>)
    6520:	4293      	cmp	r3, r2
    6522:	d151      	bne.n	65c8 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xb8>
    6524:	9b02      	ldr	r3, [sp, #8]
    6526:	2b10      	cmp	r3, #16
    6528:	d867      	bhi.n	65fa <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xea>
    652a:	a201      	add	r2, pc, #4	; (adr r2, 6530 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0x20>)
    652c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    6530:	00006575 	.word	0x00006575
    6534:	00006583 	.word	0x00006583
    6538:	000065fb 	.word	0x000065fb
    653c:	000065fb 	.word	0x000065fb
    6540:	000065fb 	.word	0x000065fb
    6544:	000065fb 	.word	0x000065fb
    6548:	000065fb 	.word	0x000065fb
    654c:	000065fb 	.word	0x000065fb
    6550:	000065fb 	.word	0x000065fb
    6554:	000065fb 	.word	0x000065fb
    6558:	000065fb 	.word	0x000065fb
    655c:	000065fb 	.word	0x000065fb
    6560:	000065fb 	.word	0x000065fb
    6564:	00006591 	.word	0x00006591
    6568:	0000659f 	.word	0x0000659f
    656c:	000065ad 	.word	0x000065ad
    6570:	000065bb 	.word	0x000065bb
    {
        switch (pinPortIdx)
        {
            case 0:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE0;
    6574:	2301      	movs	r3, #1
    6576:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    6578:	9a05      	ldr	r2, [sp, #20]
    657a:	9b01      	ldr	r3, [sp, #4]
    657c:	4313      	orrs	r3, r2
    657e:	9305      	str	r3, [sp, #20]
                break;
    6580:	e03c      	b.n	65fc <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 1:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE1;
    6582:	2302      	movs	r3, #2
    6584:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    6586:	9a05      	ldr	r2, [sp, #20]
    6588:	9b01      	ldr	r3, [sp, #4]
    658a:	4313      	orrs	r3, r2
    658c:	9305      	str	r3, [sp, #20]
                break;
    658e:	e035      	b.n	65fc <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 13:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE2;
    6590:	2304      	movs	r3, #4
    6592:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    6594:	9a05      	ldr	r2, [sp, #20]
    6596:	9b01      	ldr	r3, [sp, #4]
    6598:	4313      	orrs	r3, r2
    659a:	9305      	str	r3, [sp, #20]
                break;
    659c:	e02e      	b.n	65fc <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 14:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_ENABLE3;
    659e:	2308      	movs	r3, #8
    65a0:	9305      	str	r3, [sp, #20]
                adcInterleaveVal |= currentVal;
    65a2:	9a05      	ldr	r2, [sp, #20]
    65a4:	9b01      	ldr	r3, [sp, #4]
    65a6:	4313      	orrs	r3, r2
    65a8:	9305      	str	r3, [sp, #20]
                break;
    65aa:	e027      	b.n	65fc <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 15:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE0;
    65ac:	230e      	movs	r3, #14
    65ae:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    65b0:	9a05      	ldr	r2, [sp, #20]
    65b2:	9b01      	ldr	r3, [sp, #4]
    65b4:	4013      	ands	r3, r2
    65b6:	9305      	str	r3, [sp, #20]
                break;
    65b8:	e020      	b.n	65fc <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            case 16:
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE1;
    65ba:	230d      	movs	r3, #13
    65bc:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    65be:	9a05      	ldr	r2, [sp, #20]
    65c0:	9b01      	ldr	r3, [sp, #4]
    65c2:	4013      	ands	r3, r2
    65c4:	9305      	str	r3, [sp, #20]
                break;
    65c6:	e019      	b.n	65fc <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
            default:
                /* invalid command */
                break;
        }
    }
    else if ((uint32)base == (uint32)IP_PORTC)
    65c8:	9b03      	ldr	r3, [sp, #12]
    65ca:	4a0f      	ldr	r2, [pc, #60]	; (6608 <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xf8>)
    65cc:	4293      	cmp	r3, r2
    65ce:	d115      	bne.n	65fc <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
    {
        switch (pinPortIdx)
    65d0:	9b02      	ldr	r3, [sp, #8]
    65d2:	2b00      	cmp	r3, #0
    65d4:	d003      	beq.n	65de <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xce>
    65d6:	9b02      	ldr	r3, [sp, #8]
    65d8:	2b01      	cmp	r3, #1
    65da:	d007      	beq.n	65ec <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xdc>
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE3;
                adcInterleaveVal &= currentVal;
                break;
            default:
                /* invalid command */
                break;
    65dc:	e00e      	b.n	65fc <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE2;
    65de:	230b      	movs	r3, #11
    65e0:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    65e2:	9a05      	ldr	r2, [sp, #20]
    65e4:	9b01      	ldr	r3, [sp, #4]
    65e6:	4013      	ands	r3, r2
    65e8:	9305      	str	r3, [sp, #20]
                break;
    65ea:	e007      	b.n	65fc <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
                adcInterleaveVal = (uint32)PIN_ADC_INTERLEAVE_DISABLE3;
    65ec:	2307      	movs	r3, #7
    65ee:	9305      	str	r3, [sp, #20]
                adcInterleaveVal &= currentVal;
    65f0:	9a05      	ldr	r2, [sp, #20]
    65f2:	9b01      	ldr	r3, [sp, #4]
    65f4:	4013      	ands	r3, r2
    65f6:	9305      	str	r3, [sp, #20]
                break;
    65f8:	e000      	b.n	65fc <Port_Ci_Port_Ip_GetAdcInterleaveVal+0xec>
                break;
    65fa:	bf00      	nop
    }
    else
    {
        /* invalid command */
    }
    return adcInterleaveVal;
    65fc:	9b05      	ldr	r3, [sp, #20]
}
    65fe:	4618      	mov	r0, r3
    6600:	b006      	add	sp, #24
    6602:	4770      	bx	lr
    6604:	4004a000 	.word	0x4004a000
    6608:	4004b000 	.word	0x4004b000

0000660c <Port_Ci_Port_Ip_ConfigureInterleave>:
(
    const PORT_Type * const base,
    uint32 pin,
    Port_Ci_Port_Ip_PortMux muxing
)
{
    660c:	b500      	push	{lr}
    660e:	b089      	sub	sp, #36	; 0x24
    6610:	9003      	str	r0, [sp, #12]
    6612:	9102      	str	r1, [sp, #8]
    6614:	9201      	str	r2, [sp, #4]
    Port_Ci_Port_Ip_PortMux retMuxing = muxing;
    6616:	9b01      	ldr	r3, [sp, #4]
    6618:	9307      	str	r3, [sp, #28]
    if (muxing == PORT_MUX_ADC_INTERLEAVE)
    661a:	9b01      	ldr	r3, [sp, #4]
    661c:	2b08      	cmp	r3, #8
    661e:	d121      	bne.n	6664 <Port_Ci_Port_Ip_ConfigureInterleave+0x58>
    {
        /* Get ADC Interleave from SIM and enable/disable desired bit */
        uint32 chipCtlReg = (IP_SIM->CHIPCTL & SIM_CHIPCTL_ADC_INTERLEAVE_EN_MASK) >> SIM_CHIPCTL_ADC_INTERLEAVE_EN_SHIFT;
    6620:	4b13      	ldr	r3, [pc, #76]	; (6670 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    6622:	685b      	ldr	r3, [r3, #4]
    6624:	f003 030f 	and.w	r3, r3, #15
    6628:	9306      	str	r3, [sp, #24]
        Port_Ci_Port_Ip_InterleaveMux interleaveVal = (Port_Ci_Port_Ip_InterleaveMux)Port_Ci_Port_Ip_GetAdcInterleaveVal(base, pin, chipCtlReg);
    662a:	9a06      	ldr	r2, [sp, #24]
    662c:	9902      	ldr	r1, [sp, #8]
    662e:	9803      	ldr	r0, [sp, #12]
    6630:	f7ff ff6e 	bl	6510 <Port_Ci_Port_Ip_GetAdcInterleaveVal>
    6634:	9005      	str	r0, [sp, #20]
        if (interleaveVal != PIN_ADC_INTERLEAVE_INVALID)
    6636:	9b05      	ldr	r3, [sp, #20]
    6638:	2bff      	cmp	r3, #255	; 0xff
    663a:	d011      	beq.n	6660 <Port_Ci_Port_Ip_ConfigureInterleave+0x54>
        {
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05();
    663c:	f00c fdce 	bl	131dc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05>
            IP_SIM->CHIPCTL &= ~(SIM_CHIPCTL_ADC_INTERLEAVE_EN_MASK);
    6640:	4b0b      	ldr	r3, [pc, #44]	; (6670 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    6642:	685b      	ldr	r3, [r3, #4]
    6644:	4a0a      	ldr	r2, [pc, #40]	; (6670 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    6646:	f023 030f 	bic.w	r3, r3, #15
    664a:	6053      	str	r3, [r2, #4]
            IP_SIM->CHIPCTL |= SIM_CHIPCTL_ADC_INTERLEAVE_EN(interleaveVal);
    664c:	4b08      	ldr	r3, [pc, #32]	; (6670 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    664e:	685a      	ldr	r2, [r3, #4]
    6650:	9b05      	ldr	r3, [sp, #20]
    6652:	f003 030f 	and.w	r3, r3, #15
    6656:	4906      	ldr	r1, [pc, #24]	; (6670 <Port_Ci_Port_Ip_ConfigureInterleave+0x64>)
    6658:	4313      	orrs	r3, r2
    665a:	604b      	str	r3, [r1, #4]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05();
    665c:	f00c fdea 	bl	13234 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05>
        }
        /* return real muxing for pin */
        retMuxing = PORT_MUX_ALT0;
    6660:	2300      	movs	r3, #0
    6662:	9307      	str	r3, [sp, #28]
    }
    return retMuxing;
    6664:	9b07      	ldr	r3, [sp, #28]
}
    6666:	4618      	mov	r0, r3
    6668:	b009      	add	sp, #36	; 0x24
    666a:	f85d fb04 	ldr.w	pc, [sp], #4
    666e:	bf00      	nop
    6670:	40048000 	.word	0x40048000

00006674 <Port_Ci_Port_Ip_PinInit>:
 * Description   : This function configures the pin feature with the options
 * provided in the given structure.
 *
 ******************************************************************************/
static void Port_Ci_Port_Ip_PinInit(const Port_Ci_Port_Ip_PinSettingsConfig * config)
{
    6674:	b500      	push	{lr}
    6676:	b087      	sub	sp, #28
    6678:	9001      	str	r0, [sp, #4]
    uint32 pinsValues = 0U;
    667a:	2300      	movs	r3, #0
    667c:	9305      	str	r3, [sp, #20]
    uint32 digitalFilters;
    Port_Ci_Port_Ip_PortMux muxing = PORT_MUX_ALT0;
    667e:	2300      	movs	r3, #0
    6680:	9304      	str	r3, [sp, #16]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
    Port_Ci_Port_Ip_PortMux retMuxing = PORT_MUX_ALT0;
    6682:	2300      	movs	r3, #0
    6684:	9303      	str	r3, [sp, #12]
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */
    PORT_CI_PORT_DEV_ASSERT((boolean)(config != NULL_PTR));
    PORT_CI_PORT_DEV_ASSERT((boolean)(config->pinPortIdx < 32));
    PORT_CI_PORT_DEV_ASSERT((boolean)((config->portBase->PCR[config->pinPortIdx]) & PORT_PCR_LK_MASK) == 0);

    if (config->pullConfig != PORT_INTERNAL_PULL_NOT_ENABLED)
    6686:	9b01      	ldr	r3, [sp, #4]
    6688:	68db      	ldr	r3, [r3, #12]
    668a:	2b02      	cmp	r3, #2
    668c:	d00a      	beq.n	66a4 <Port_Ci_Port_Ip_PinInit+0x30>
    {
        pinsValues |= PORT_PCR_PE(1);
    668e:	9b05      	ldr	r3, [sp, #20]
    6690:	f043 0302 	orr.w	r3, r3, #2
    6694:	9305      	str	r3, [sp, #20]
        pinsValues |= PORT_PCR_PS(config->pullConfig);
    6696:	9b01      	ldr	r3, [sp, #4]
    6698:	68db      	ldr	r3, [r3, #12]
    669a:	f003 0301 	and.w	r3, r3, #1
    669e:	9a05      	ldr	r2, [sp, #20]
    66a0:	4313      	orrs	r3, r2
    66a2:	9305      	str	r3, [sp, #20]
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE)
    pinsValues |= PORT_PCR_SRE(config->slewRateCtrlSel);
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_DRIVE_STRENGTH
    pinsValues |= PORT_PCR_DSE(config->driveStrength);
    66a4:	9b01      	ldr	r3, [sp, #4]
    66a6:	699b      	ldr	r3, [r3, #24]
    66a8:	019b      	lsls	r3, r3, #6
    66aa:	f003 0340 	and.w	r3, r3, #64	; 0x40
    66ae:	9a05      	ldr	r2, [sp, #20]
    66b0:	4313      	orrs	r3, r2
    66b2:	9305      	str	r3, [sp, #20]
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_DRIVE_STRENGTH */
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_LOCK_REGISTER
    pinsValues |= PORT_PCR_LK(config->lockRegister);
    66b4:	9b01      	ldr	r3, [sp, #4]
    66b6:	6a1b      	ldr	r3, [r3, #32]
    66b8:	03db      	lsls	r3, r3, #15
    66ba:	b29b      	uxth	r3, r3
    66bc:	9a05      	ldr	r2, [sp, #20]
    66be:	4313      	orrs	r3, r2
    66c0:	9305      	str	r3, [sp, #20]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN)
    pinsValues |= PORT_PCR_ODE(config->openDrain);
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
    pinsValues |= PORT_PCR_PFE(config->passiveFilter?1U:0U);
    66c2:	9b01      	ldr	r3, [sp, #4]
    66c4:	7f1b      	ldrb	r3, [r3, #28]
    66c6:	2b00      	cmp	r3, #0
    66c8:	d001      	beq.n	66ce <Port_Ci_Port_Ip_PinInit+0x5a>
    66ca:	2310      	movs	r3, #16
    66cc:	e000      	b.n	66d0 <Port_Ci_Port_Ip_PinInit+0x5c>
    66ce:	2300      	movs	r3, #0
    66d0:	9a05      	ldr	r2, [sp, #20]
    66d2:	4313      	orrs	r3, r2
    66d4:	9305      	str	r3, [sp, #20]

    muxing = config->mux;
    66d6:	9b01      	ldr	r3, [sp, #4]
    66d8:	691b      	ldr	r3, [r3, #16]
    66da:	9304      	str	r3, [sp, #16]

#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
#if (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT))
    retMuxing = (Port_Ci_Port_Ip_PortMux)OsIf_Trusted_Call_Return3param(Port_Ci_Port_Ip_ConfigureInterleave,(config->portBase),(config->pinPortIdx),(muxing));
#else
    retMuxing = Port_Ci_Port_Ip_ConfigureInterleave(config->portBase, config->pinPortIdx, muxing);
    66dc:	9b01      	ldr	r3, [sp, #4]
    66de:	6818      	ldr	r0, [r3, #0]
    66e0:	9b01      	ldr	r3, [sp, #4]
    66e2:	689b      	ldr	r3, [r3, #8]
    66e4:	9a04      	ldr	r2, [sp, #16]
    66e6:	4619      	mov	r1, r3
    66e8:	f7ff ff90 	bl	660c <Port_Ci_Port_Ip_ConfigureInterleave>
    66ec:	9003      	str	r0, [sp, #12]
#endif /* (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT)) */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
    muxing = retMuxing;
    66ee:	9b03      	ldr	r3, [sp, #12]
    66f0:	9304      	str	r3, [sp, #16]
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */
    pinsValues |= PORT_PCR_MUX(muxing);
    66f2:	9b04      	ldr	r3, [sp, #16]
    66f4:	021b      	lsls	r3, r3, #8
    66f6:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    66fa:	9a05      	ldr	r2, [sp, #20]
    66fc:	4313      	orrs	r3, r2
    66fe:	9305      	str	r3, [sp, #20]

    /* Enter critical region */
    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00();
    6700:	f00c fbd2 	bl	12ea8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00>
    /* Read current digital filter of port */
    digitalFilters = (uint32)(config->portBase->DFER);
    6704:	9b01      	ldr	r3, [sp, #4]
    6706:	681b      	ldr	r3, [r3, #0]
    6708:	f8d3 30c0 	ldr.w	r3, [r3, #192]	; 0xc0
    670c:	9302      	str	r3, [sp, #8]
    digitalFilters &= ~(1UL << (config->pinPortIdx));
    670e:	9b01      	ldr	r3, [sp, #4]
    6710:	689b      	ldr	r3, [r3, #8]
    6712:	2201      	movs	r2, #1
    6714:	fa02 f303 	lsl.w	r3, r2, r3
    6718:	43db      	mvns	r3, r3
    671a:	9a02      	ldr	r2, [sp, #8]
    671c:	4013      	ands	r3, r2
    671e:	9302      	str	r3, [sp, #8]
    digitalFilters |= (((uint32)(config->digitalFilter?1U:0U)) << (config->pinPortIdx));
    6720:	9b01      	ldr	r3, [sp, #4]
    6722:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
    6726:	2b00      	cmp	r3, #0
    6728:	d001      	beq.n	672e <Port_Ci_Port_Ip_PinInit+0xba>
    672a:	2201      	movs	r2, #1
    672c:	e000      	b.n	6730 <Port_Ci_Port_Ip_PinInit+0xbc>
    672e:	2200      	movs	r2, #0
    6730:	9b01      	ldr	r3, [sp, #4]
    6732:	689b      	ldr	r3, [r3, #8]
    6734:	fa02 f303 	lsl.w	r3, r2, r3
    6738:	9a02      	ldr	r2, [sp, #8]
    673a:	4313      	orrs	r3, r2
    673c:	9302      	str	r3, [sp, #8]
    /* Write to digital filter enable register */
    config->portBase->DFER = digitalFilters;
    673e:	9b01      	ldr	r3, [sp, #4]
    6740:	681b      	ldr	r3, [r3, #0]
    6742:	9a02      	ldr	r2, [sp, #8]
    6744:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00();
    6748:	f00c fbda 	bl	12f00 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00>

    /* Configure initial value for GPIO pin in GPIO mux */
    if (PORT_MUX_AS_GPIO == muxing)
    674c:	9b04      	ldr	r3, [sp, #16]
    674e:	2b01      	cmp	r3, #1
    6750:	d16d      	bne.n	682e <Port_Ci_Port_Ip_PinInit+0x1ba>
    {
        /* Check if the direction of the pin is OUTPUT. In this case the driver needs to set the output level too */
        if (PORT_CI_PORT_PIN_OUT == config->direction)
    6752:	9b01      	ldr	r3, [sp, #4]
    6754:	695b      	ldr	r3, [r3, #20]
    6756:	2b02      	cmp	r3, #2
    6758:	d138      	bne.n	67cc <Port_Ci_Port_Ip_PinInit+0x158>
        {
            if ((uint8)1 == config->initValue)
    675a:	9b01      	ldr	r3, [sp, #4]
    675c:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
    6760:	2b01      	cmp	r3, #1
    6762:	d10f      	bne.n	6784 <Port_Ci_Port_Ip_PinInit+0x110>
            {
                SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01();
    6764:	f00c fbf2 	bl	12f4c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01>
                config->gpioBase->PSOR |= ((uint32)1 << (config->pinPortIdx));
    6768:	9b01      	ldr	r3, [sp, #4]
    676a:	685b      	ldr	r3, [r3, #4]
    676c:	6859      	ldr	r1, [r3, #4]
    676e:	9b01      	ldr	r3, [sp, #4]
    6770:	689b      	ldr	r3, [r3, #8]
    6772:	2201      	movs	r2, #1
    6774:	409a      	lsls	r2, r3
    6776:	9b01      	ldr	r3, [sp, #4]
    6778:	685b      	ldr	r3, [r3, #4]
    677a:	430a      	orrs	r2, r1
    677c:	605a      	str	r2, [r3, #4]
                SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01();
    677e:	f00c fc11 	bl	12fa4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01>
    6782:	e013      	b.n	67ac <Port_Ci_Port_Ip_PinInit+0x138>
            }
            else if ((uint8)0 == config->initValue)
    6784:	9b01      	ldr	r3, [sp, #4]
    6786:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
    678a:	2b00      	cmp	r3, #0
    678c:	d10e      	bne.n	67ac <Port_Ci_Port_Ip_PinInit+0x138>
            {
                SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02();
    678e:	f00c fc2f 	bl	12ff0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02>
                config->gpioBase->PCOR |= ((uint32)1 << (config->pinPortIdx));
    6792:	9b01      	ldr	r3, [sp, #4]
    6794:	685b      	ldr	r3, [r3, #4]
    6796:	6899      	ldr	r1, [r3, #8]
    6798:	9b01      	ldr	r3, [sp, #4]
    679a:	689b      	ldr	r3, [r3, #8]
    679c:	2201      	movs	r2, #1
    679e:	409a      	lsls	r2, r3
    67a0:	9b01      	ldr	r3, [sp, #4]
    67a2:	685b      	ldr	r3, [r3, #4]
    67a4:	430a      	orrs	r2, r1
    67a6:	609a      	str	r2, [r3, #8]
                SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02();
    67a8:	f00c fc4e 	bl	13048 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02>
            else
            {
                /* No action to be done */
            }
            /* Set the pin direction as output in the PDDR register of GPIO IP */
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03();
    67ac:	f00c fc72 	bl	13094 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03>
            config->gpioBase->PDDR |= (uint32)1 << (config->pinPortIdx);
    67b0:	9b01      	ldr	r3, [sp, #4]
    67b2:	685b      	ldr	r3, [r3, #4]
    67b4:	6959      	ldr	r1, [r3, #20]
    67b6:	9b01      	ldr	r3, [sp, #4]
    67b8:	689b      	ldr	r3, [r3, #8]
    67ba:	2201      	movs	r2, #1
    67bc:	409a      	lsls	r2, r3
    67be:	9b01      	ldr	r3, [sp, #4]
    67c0:	685b      	ldr	r3, [r3, #4]
    67c2:	430a      	orrs	r2, r1
    67c4:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03();
    67c6:	f00c fc91 	bl	130ec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03>
    67ca:	e030      	b.n	682e <Port_Ci_Port_Ip_PinInit+0x1ba>
        }
        /* The direction of pin is INPUT or HIGH Z */
        else
        {
            /* Clear the pin direction as input in the PDDR register of GPIO IP */
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03();
    67cc:	f00c fc62 	bl	13094 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03>
            config->gpioBase->PDDR &= ~((uint32)1 << (config->pinPortIdx));
    67d0:	9b01      	ldr	r3, [sp, #4]
    67d2:	685b      	ldr	r3, [r3, #4]
    67d4:	6959      	ldr	r1, [r3, #20]
    67d6:	9b01      	ldr	r3, [sp, #4]
    67d8:	689b      	ldr	r3, [r3, #8]
    67da:	2201      	movs	r2, #1
    67dc:	fa02 f303 	lsl.w	r3, r2, r3
    67e0:	43da      	mvns	r2, r3
    67e2:	9b01      	ldr	r3, [sp, #4]
    67e4:	685b      	ldr	r3, [r3, #4]
    67e6:	400a      	ands	r2, r1
    67e8:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03();
    67ea:	f00c fc7f 	bl	130ec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03>

#ifdef FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04();
    67ee:	f00c fca3 	bl	13138 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04>
            config->gpioBase->PIDR &= ~((uint32)1 << (config->pinPortIdx));
    67f2:	9b01      	ldr	r3, [sp, #4]
    67f4:	685b      	ldr	r3, [r3, #4]
    67f6:	6999      	ldr	r1, [r3, #24]
    67f8:	9b01      	ldr	r3, [sp, #4]
    67fa:	689b      	ldr	r3, [r3, #8]
    67fc:	2201      	movs	r2, #1
    67fe:	fa02 f303 	lsl.w	r3, r2, r3
    6802:	43da      	mvns	r2, r3
    6804:	9b01      	ldr	r3, [sp, #4]
    6806:	685b      	ldr	r3, [r3, #4]
    6808:	400a      	ands	r2, r1
    680a:	619a      	str	r2, [r3, #24]

            /* Check if the pin is HIGH_Z. In this case the driver needs to disable port input in PIDR register of GPIO IP*/
            if (PORT_CI_PORT_PIN_HIGH_Z == config->direction)
    680c:	9b01      	ldr	r3, [sp, #4]
    680e:	695b      	ldr	r3, [r3, #20]
    6810:	2b03      	cmp	r3, #3
    6812:	d10a      	bne.n	682a <Port_Ci_Port_Ip_PinInit+0x1b6>
            {
                config->gpioBase->PIDR |= ((uint32)1 << (config->pinPortIdx));
    6814:	9b01      	ldr	r3, [sp, #4]
    6816:	685b      	ldr	r3, [r3, #4]
    6818:	6999      	ldr	r1, [r3, #24]
    681a:	9b01      	ldr	r3, [sp, #4]
    681c:	689b      	ldr	r3, [r3, #8]
    681e:	2201      	movs	r2, #1
    6820:	409a      	lsls	r2, r3
    6822:	9b01      	ldr	r3, [sp, #4]
    6824:	685b      	ldr	r3, [r3, #4]
    6826:	430a      	orrs	r2, r1
    6828:	619a      	str	r2, [r3, #24]
            }
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04();
    682a:	f00c fcb1 	bl	13190 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04>
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER */
        }
    }

    /* Write to Multiplexed Signal Configuration Register */
    config->portBase->PCR[config->pinPortIdx] = pinsValues;
    682e:	9b01      	ldr	r3, [sp, #4]
    6830:	681b      	ldr	r3, [r3, #0]
    6832:	9a01      	ldr	r2, [sp, #4]
    6834:	6892      	ldr	r2, [r2, #8]
    6836:	9905      	ldr	r1, [sp, #20]
    6838:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    683c:	bf00      	nop
    683e:	b007      	add	sp, #28
    6840:	f85d fb04 	ldr.w	pc, [sp], #4

00006844 <Port_Ci_Port_Ip_Init>:
Port_Ci_Port_Ip_PortStatusType Port_Ci_Port_Ip_Init
(
    uint32 pinCount,
    const Port_Ci_Port_Ip_PinSettingsConfig config[]
)
{
    6844:	b500      	push	{lr}
    6846:	b085      	sub	sp, #20
    6848:	9001      	str	r0, [sp, #4]
    684a:	9100      	str	r1, [sp, #0]
    uint32 i;

    for (i = 0U; i < pinCount; i++)
    684c:	2300      	movs	r3, #0
    684e:	9303      	str	r3, [sp, #12]
    6850:	e00d      	b.n	686e <Port_Ci_Port_Ip_Init+0x2a>
    {
        Port_Ci_Port_Ip_PinInit(&config[i]);
    6852:	9a03      	ldr	r2, [sp, #12]
    6854:	4613      	mov	r3, r2
    6856:	009b      	lsls	r3, r3, #2
    6858:	4413      	add	r3, r2
    685a:	00db      	lsls	r3, r3, #3
    685c:	461a      	mov	r2, r3
    685e:	9b00      	ldr	r3, [sp, #0]
    6860:	4413      	add	r3, r2
    6862:	4618      	mov	r0, r3
    6864:	f7ff ff06 	bl	6674 <Port_Ci_Port_Ip_PinInit>
    for (i = 0U; i < pinCount; i++)
    6868:	9b03      	ldr	r3, [sp, #12]
    686a:	3301      	adds	r3, #1
    686c:	9303      	str	r3, [sp, #12]
    686e:	9a03      	ldr	r2, [sp, #12]
    6870:	9b01      	ldr	r3, [sp, #4]
    6872:	429a      	cmp	r2, r3
    6874:	d3ed      	bcc.n	6852 <Port_Ci_Port_Ip_Init+0xe>
    }

    return PORT_CI_PORT_SUCCESS;
    6876:	2300      	movs	r3, #0
}
    6878:	4618      	mov	r0, r3
    687a:	b005      	add	sp, #20
    687c:	f85d fb04 	ldr.w	pc, [sp], #4

00006880 <Port_Ci_Port_Ip_SetMuxModeSel>:
(
    PORT_Type * const base,
    uint32 pin,
    Port_Ci_Port_Ip_PortMux mux
)
{
    6880:	b500      	push	{lr}
    6882:	b087      	sub	sp, #28
    6884:	9003      	str	r0, [sp, #12]
    6886:	9102      	str	r1, [sp, #8]
    6888:	9201      	str	r2, [sp, #4]

#ifdef FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE
#if (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT))
    Port_Ci_Port_Ip_PortMux muxing = (Port_Ci_Port_Ip_PortMux)OsIf_Trusted_Call_Return3param(Port_Ci_Port_Ip_ConfigureInterleave,(base),(pin),(mux));
#else
    Port_Ci_Port_Ip_PortMux muxing = Port_Ci_Port_Ip_ConfigureInterleave(base, pin, mux);
    688a:	9a01      	ldr	r2, [sp, #4]
    688c:	9902      	ldr	r1, [sp, #8]
    688e:	9803      	ldr	r0, [sp, #12]
    6890:	f7ff febc 	bl	660c <Port_Ci_Port_Ip_ConfigureInterleave>
    6894:	9005      	str	r0, [sp, #20]
#endif /* (defined(MCAL_ENABLE_USER_MODE_SUPPORT) && defined(PORT_ENABLE_USER_MODE_SUPPORT) && (STD_ON == PORT_ENABLE_USER_MODE_SUPPORT)) */
#else
    Port_Ci_Port_Ip_PortMux muxing = mux;
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_ADC_INTERLEAVE */

    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06();
    6896:	f00c fcf3 	bl	13280 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06>
    regValue = base->PCR[pin];
    689a:	9b03      	ldr	r3, [sp, #12]
    689c:	9a02      	ldr	r2, [sp, #8]
    689e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    68a2:	9304      	str	r3, [sp, #16]
    regValue &= ~(PORT_PCR_MUX_MASK);
    68a4:	9b04      	ldr	r3, [sp, #16]
    68a6:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    68aa:	9304      	str	r3, [sp, #16]
    regValue |= PORT_PCR_MUX(muxing);
    68ac:	9b05      	ldr	r3, [sp, #20]
    68ae:	021b      	lsls	r3, r3, #8
    68b0:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
    68b4:	9a04      	ldr	r2, [sp, #16]
    68b6:	4313      	orrs	r3, r2
    68b8:	9304      	str	r3, [sp, #16]
    base->PCR[pin] = regValue;
    68ba:	9b03      	ldr	r3, [sp, #12]
    68bc:	9a02      	ldr	r2, [sp, #8]
    68be:	9904      	ldr	r1, [sp, #16]
    68c0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06();
    68c4:	f00c fd08 	bl	132d8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06>
}
    68c8:	bf00      	nop
    68ca:	b007      	add	sp, #28
    68cc:	f85d fb04 	ldr.w	pc, [sp], #4

000068d0 <Port_Ci_Port_Ip_EnableDigitalFilter>:
void Port_Ci_Port_Ip_EnableDigitalFilter
(
    PORT_Type * const base,
    uint32 pin
)
{
    68d0:	b500      	push	{lr}
    68d2:	b083      	sub	sp, #12
    68d4:	9001      	str	r0, [sp, #4]
    68d6:	9100      	str	r1, [sp, #0]
    PORT_CI_PORT_DEV_ASSERT((boolean)(pin < PORT_PCR_COUNT));
    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07();
    68d8:	f00c fd24 	bl	13324 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07>
    base->DFER |= ((uint32)1U << pin);
    68dc:	9b01      	ldr	r3, [sp, #4]
    68de:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
    68e2:	2101      	movs	r1, #1
    68e4:	9b00      	ldr	r3, [sp, #0]
    68e6:	fa01 f303 	lsl.w	r3, r1, r3
    68ea:	431a      	orrs	r2, r3
    68ec:	9b01      	ldr	r3, [sp, #4]
    68ee:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07();
    68f2:	f00c fd43 	bl	1337c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07>
}
    68f6:	bf00      	nop
    68f8:	b003      	add	sp, #12
    68fa:	f85d fb04 	ldr.w	pc, [sp], #4

000068fe <Port_Ci_Port_Ip_DisableDigitalFilter>:
void Port_Ci_Port_Ip_DisableDigitalFilter
(
    PORT_Type * const base,
    uint32 pin
)
{
    68fe:	b500      	push	{lr}
    6900:	b083      	sub	sp, #12
    6902:	9001      	str	r0, [sp, #4]
    6904:	9100      	str	r1, [sp, #0]
    PORT_CI_PORT_DEV_ASSERT((boolean)(pin < PORT_PCR_COUNT));
    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08();
    6906:	f00c fd5f 	bl	133c8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08>
    base->DFER &= ~((uint32)1U << pin);
    690a:	9b01      	ldr	r3, [sp, #4]
    690c:	f8d3 20c0 	ldr.w	r2, [r3, #192]	; 0xc0
    6910:	2101      	movs	r1, #1
    6912:	9b00      	ldr	r3, [sp, #0]
    6914:	fa01 f303 	lsl.w	r3, r1, r3
    6918:	43db      	mvns	r3, r3
    691a:	401a      	ands	r2, r3
    691c:	9b01      	ldr	r3, [sp, #4]
    691e:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08();
    6922:	f00c fd7d 	bl	13420 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08>
}
    6926:	bf00      	nop
    6928:	b003      	add	sp, #12
    692a:	f85d fb04 	ldr.w	pc, [sp], #4

0000692e <Port_Ci_Port_Ip_ConfigDigitalFilter>:
void Port_Ci_Port_Ip_ConfigDigitalFilter
(
    PORT_Type * const base,
    const Port_Ci_Port_Ip_DigitalFilterConfigType * config
)
{
    692e:	b082      	sub	sp, #8
    6930:	9001      	str	r0, [sp, #4]
    6932:	9100      	str	r1, [sp, #0]
    PORT_CI_PORT_DEV_ASSERT((boolean)(config->u8Width <= PORT_DFWR_FILT_MASK));
    base->DFCR = PORT_DFCR_CS(config->u8Clock);
    6934:	9b00      	ldr	r3, [sp, #0]
    6936:	785b      	ldrb	r3, [r3, #1]
    6938:	f003 0201 	and.w	r2, r3, #1
    693c:	9b01      	ldr	r3, [sp, #4]
    693e:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
    base->DFWR = PORT_DFWR_FILT(config->u8Width);
    6942:	9b00      	ldr	r3, [sp, #0]
    6944:	789b      	ldrb	r3, [r3, #2]
    6946:	f003 021f 	and.w	r2, r3, #31
    694a:	9b01      	ldr	r3, [sp, #4]
    694c:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
}
    6950:	bf00      	nop
    6952:	b002      	add	sp, #8
    6954:	4770      	bx	lr

00006956 <Port_Ci_Port_Ip_SetGlobalPinControl>:
    PORT_Type * const base,
    uint16 pins,
    uint16 value,
    Port_Ci_Port_Ip_PortGlobalControlPins halfPort
)
{
    6956:	b086      	sub	sp, #24
    6958:	9003      	str	r0, [sp, #12]
    695a:	9301      	str	r3, [sp, #4]
    695c:	460b      	mov	r3, r1
    695e:	f8ad 300a 	strh.w	r3, [sp, #10]
    6962:	4613      	mov	r3, r2
    6964:	f8ad 3008 	strh.w	r3, [sp, #8]
    uint16 mask = 0;
    6968:	2300      	movs	r3, #0
    696a:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_PS_MASK;
    696e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6972:	f043 0301 	orr.w	r3, r3, #1
    6976:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_PE_MASK;
    697a:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    697e:	f043 0302 	orr.w	r3, r3, #2
    6982:	f8ad 3016 	strh.w	r3, [sp, #22]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE)
    mask |= PORT_PCR_SRE_MASK;
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_SLEW_RATE */
    mask |= PORT_PCR_PFE_MASK;
    6986:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    698a:	f043 0310 	orr.w	r3, r3, #16
    698e:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_DSE_MASK;
    6992:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6996:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    699a:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_MUX_MASK;
    699e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    69a2:	f443 63e0 	orr.w	r3, r3, #1792	; 0x700
    69a6:	f8ad 3016 	strh.w	r3, [sp, #22]
    mask |= PORT_PCR_LK_MASK;
    69aa:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    69ae:	ea6f 4343 	mvn.w	r3, r3, lsl #17
    69b2:	ea6f 4353 	mvn.w	r3, r3, lsr #17
    69b6:	f8ad 3016 	strh.w	r3, [sp, #22]
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN
#if (STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN)
    mask |= PORT_PCR_ODE_MASK;
#endif /* STD_ON == FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_OPEN_DRAIN */
    mask &= value;
    69ba:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    69be:	f8bd 3008 	ldrh.w	r3, [sp, #8]
    69c2:	4013      	ands	r3, r2
    69c4:	f8ad 3016 	strh.w	r3, [sp, #22]

    switch (halfPort)
    69c8:	9b01      	ldr	r3, [sp, #4]
    69ca:	2b00      	cmp	r3, #0
    69cc:	d003      	beq.n	69d6 <Port_Ci_Port_Ip_SetGlobalPinControl+0x80>
    69ce:	9b01      	ldr	r3, [sp, #4]
    69d0:	2b01      	cmp	r3, #1
    69d2:	d00a      	beq.n	69ea <Port_Ci_Port_Ip_SetGlobalPinControl+0x94>
            base->GPCHR = (((uint32)pins) << PORT_GPCHR_GPWE_SHIFT) | (uint32)mask;
            break;
        default:
            /* nothing to configure */
            PORT_CI_PORT_DEV_ASSERT((boolean)FALSE);
            break;
    69d4:	e013      	b.n	69fe <Port_Ci_Port_Ip_SetGlobalPinControl+0xa8>
            base->GPCLR = (((uint32)pins) << PORT_GPCLR_GPWE_SHIFT) | (uint32)mask;
    69d6:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    69da:	041a      	lsls	r2, r3, #16
    69dc:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    69e0:	431a      	orrs	r2, r3
    69e2:	9b03      	ldr	r3, [sp, #12]
    69e4:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
            break;
    69e8:	e009      	b.n	69fe <Port_Ci_Port_Ip_SetGlobalPinControl+0xa8>
            base->GPCHR = (((uint32)pins) << PORT_GPCHR_GPWE_SHIFT) | (uint32)mask;
    69ea:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    69ee:	041a      	lsls	r2, r3, #16
    69f0:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    69f4:	431a      	orrs	r2, r3
    69f6:	9b03      	ldr	r3, [sp, #12]
    69f8:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
            break;
    69fc:	bf00      	nop
    }
}
    69fe:	bf00      	nop
    6a00:	b006      	add	sp, #24
    6a02:	4770      	bx	lr

00006a04 <Port_Ipw_Init_UnusedPins>:
*/
static inline void Port_Ipw_Init_UnusedPins
(
    const Port_ConfigType * pConfigPtr
)
{
    6a04:	b500      	push	{lr}
    6a06:	b087      	sub	sp, #28
    6a08:	9001      	str	r0, [sp, #4]
    uint16 u16PinIndex;
    uint16 u16NumUnusedPins             = (uint16)(pConfigPtr->u16NumUnusedPins);
    6a0a:	9b01      	ldr	r3, [sp, #4]
    6a0c:	885b      	ldrh	r3, [r3, #2]
    6a0e:	f8ad 3014 	strh.w	r3, [sp, #20]
    uint8  u8LocalPDO                   = pConfigPtr->pUnusedPadConfig->u8PDO;
    6a12:	9b01      	ldr	r3, [sp, #4]
    6a14:	689b      	ldr	r3, [r3, #8]
    6a16:	7a1b      	ldrb	r3, [r3, #8]
    6a18:	f88d 3013 	strb.w	r3, [sp, #19]
    uint32 u32LocalPCR                  = pConfigPtr->pUnusedPadConfig->u32PCR;
    6a1c:	9b01      	ldr	r3, [sp, #4]
    6a1e:	689b      	ldr	r3, [r3, #8]
    6a20:	681b      	ldr	r3, [r3, #0]
    6a22:	9303      	str	r3, [sp, #12]
    Port_PinDirectionType eLocalPDDIR   = pConfigPtr->pUnusedPadConfig->ePadDir;
    6a24:	9b01      	ldr	r3, [sp, #4]
    6a26:	689b      	ldr	r3, [r3, #8]
    6a28:	685b      	ldr	r3, [r3, #4]
    6a2a:	9302      	str	r3, [sp, #8]

    /* Initialize All UnUsed pins */
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumUnusedPins; u16PinIndex++)
    6a2c:	2300      	movs	r3, #0
    6a2e:	f8ad 3016 	strh.w	r3, [sp, #22]
    6a32:	e111      	b.n	6c58 <Port_Ipw_Init_UnusedPins+0x254>
    {
        /* Check if the direction of the pin is OUTPUT. In this case the driver needs to set the output level too */
        if (PORT_PIN_OUT == eLocalPDDIR)
    6a34:	9b02      	ldr	r3, [sp, #8]
    6a36:	2b02      	cmp	r3, #2
    6a38:	d169      	bne.n	6b0e <Port_Ipw_Init_UnusedPins+0x10a>
        {
            /* Set pin to High value */
            if (PORT_PIN_LEVEL_HIGH_U8 == u8LocalPDO)
    6a3a:	f89d 3013 	ldrb.w	r3, [sp, #19]
    6a3e:	2b01      	cmp	r3, #1
    6a40:	d11a      	bne.n	6a78 <Port_Ipw_Init_UnusedPins+0x74>
            {
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PSOR = ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    6a42:	9b01      	ldr	r3, [sp, #4]
    6a44:	685a      	ldr	r2, [r3, #4]
    6a46:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6a4a:	005b      	lsls	r3, r3, #1
    6a4c:	4413      	add	r3, r2
    6a4e:	881b      	ldrh	r3, [r3, #0]
    6a50:	f003 021f 	and.w	r2, r3, #31
    6a54:	9b01      	ldr	r3, [sp, #4]
    6a56:	6859      	ldr	r1, [r3, #4]
    6a58:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6a5c:	005b      	lsls	r3, r3, #1
    6a5e:	440b      	add	r3, r1
    6a60:	881b      	ldrh	r3, [r3, #0]
    6a62:	095b      	lsrs	r3, r3, #5
    6a64:	b29b      	uxth	r3, r3
    6a66:	4619      	mov	r1, r3
    6a68:	4b81      	ldr	r3, [pc, #516]	; (6c70 <Port_Ipw_Init_UnusedPins+0x26c>)
    6a6a:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    6a6e:	2101      	movs	r1, #1
    6a70:	fa01 f202 	lsl.w	r2, r1, r2
    6a74:	605a      	str	r2, [r3, #4]
    6a76:	e01d      	b.n	6ab4 <Port_Ipw_Init_UnusedPins+0xb0>
            }
            else if (PORT_PIN_LEVEL_LOW_U8 == u8LocalPDO)
    6a78:	f89d 3013 	ldrb.w	r3, [sp, #19]
    6a7c:	2b00      	cmp	r3, #0
    6a7e:	d119      	bne.n	6ab4 <Port_Ipw_Init_UnusedPins+0xb0>
            {
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PCOR = ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    6a80:	9b01      	ldr	r3, [sp, #4]
    6a82:	685a      	ldr	r2, [r3, #4]
    6a84:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6a88:	005b      	lsls	r3, r3, #1
    6a8a:	4413      	add	r3, r2
    6a8c:	881b      	ldrh	r3, [r3, #0]
    6a8e:	f003 021f 	and.w	r2, r3, #31
    6a92:	9b01      	ldr	r3, [sp, #4]
    6a94:	6859      	ldr	r1, [r3, #4]
    6a96:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6a9a:	005b      	lsls	r3, r3, #1
    6a9c:	440b      	add	r3, r1
    6a9e:	881b      	ldrh	r3, [r3, #0]
    6aa0:	095b      	lsrs	r3, r3, #5
    6aa2:	b29b      	uxth	r3, r3
    6aa4:	4619      	mov	r1, r3
    6aa6:	4b72      	ldr	r3, [pc, #456]	; (6c70 <Port_Ipw_Init_UnusedPins+0x26c>)
    6aa8:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    6aac:	2101      	movs	r1, #1
    6aae:	fa01 f202 	lsl.w	r2, r1, r2
    6ab2:	609a      	str	r2, [r3, #8]
            }
            else
            {
                /* No action to be done */
            }
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09();
    6ab4:	f00c fcda 	bl	1346c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09>
            (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PDDR |= ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    6ab8:	9b01      	ldr	r3, [sp, #4]
    6aba:	685a      	ldr	r2, [r3, #4]
    6abc:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6ac0:	005b      	lsls	r3, r3, #1
    6ac2:	4413      	add	r3, r2
    6ac4:	881b      	ldrh	r3, [r3, #0]
    6ac6:	095b      	lsrs	r3, r3, #5
    6ac8:	b29b      	uxth	r3, r3
    6aca:	461a      	mov	r2, r3
    6acc:	4b68      	ldr	r3, [pc, #416]	; (6c70 <Port_Ipw_Init_UnusedPins+0x26c>)
    6ace:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6ad2:	6959      	ldr	r1, [r3, #20]
    6ad4:	9b01      	ldr	r3, [sp, #4]
    6ad6:	685a      	ldr	r2, [r3, #4]
    6ad8:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6adc:	005b      	lsls	r3, r3, #1
    6ade:	4413      	add	r3, r2
    6ae0:	881b      	ldrh	r3, [r3, #0]
    6ae2:	f003 031f 	and.w	r3, r3, #31
    6ae6:	2201      	movs	r2, #1
    6ae8:	409a      	lsls	r2, r3
    6aea:	9b01      	ldr	r3, [sp, #4]
    6aec:	6858      	ldr	r0, [r3, #4]
    6aee:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6af2:	005b      	lsls	r3, r3, #1
    6af4:	4403      	add	r3, r0
    6af6:	881b      	ldrh	r3, [r3, #0]
    6af8:	095b      	lsrs	r3, r3, #5
    6afa:	b29b      	uxth	r3, r3
    6afc:	4618      	mov	r0, r3
    6afe:	4b5c      	ldr	r3, [pc, #368]	; (6c70 <Port_Ipw_Init_UnusedPins+0x26c>)
    6b00:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    6b04:	430a      	orrs	r2, r1
    6b06:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09();
    6b08:	f00c fcdc 	bl	134c4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09>
    6b0c:	e086      	b.n	6c1c <Port_Ipw_Init_UnusedPins+0x218>
        }
        /* The direction of pin is INPUT or HIGH Z */
        else
        {
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09();
    6b0e:	f00c fcad 	bl	1346c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09>
            (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PDDR &= ~(((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex])));
    6b12:	9b01      	ldr	r3, [sp, #4]
    6b14:	685a      	ldr	r2, [r3, #4]
    6b16:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6b1a:	005b      	lsls	r3, r3, #1
    6b1c:	4413      	add	r3, r2
    6b1e:	881b      	ldrh	r3, [r3, #0]
    6b20:	095b      	lsrs	r3, r3, #5
    6b22:	b29b      	uxth	r3, r3
    6b24:	461a      	mov	r2, r3
    6b26:	4b52      	ldr	r3, [pc, #328]	; (6c70 <Port_Ipw_Init_UnusedPins+0x26c>)
    6b28:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6b2c:	6959      	ldr	r1, [r3, #20]
    6b2e:	9b01      	ldr	r3, [sp, #4]
    6b30:	685a      	ldr	r2, [r3, #4]
    6b32:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6b36:	005b      	lsls	r3, r3, #1
    6b38:	4413      	add	r3, r2
    6b3a:	881b      	ldrh	r3, [r3, #0]
    6b3c:	f003 031f 	and.w	r3, r3, #31
    6b40:	2201      	movs	r2, #1
    6b42:	fa02 f303 	lsl.w	r3, r2, r3
    6b46:	43da      	mvns	r2, r3
    6b48:	9b01      	ldr	r3, [sp, #4]
    6b4a:	6858      	ldr	r0, [r3, #4]
    6b4c:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6b50:	005b      	lsls	r3, r3, #1
    6b52:	4403      	add	r3, r0
    6b54:	881b      	ldrh	r3, [r3, #0]
    6b56:	095b      	lsrs	r3, r3, #5
    6b58:	b29b      	uxth	r3, r3
    6b5a:	4618      	mov	r0, r3
    6b5c:	4b44      	ldr	r3, [pc, #272]	; (6c70 <Port_Ipw_Init_UnusedPins+0x26c>)
    6b5e:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    6b62:	400a      	ands	r2, r1
    6b64:	615a      	str	r2, [r3, #20]
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09();
    6b66:	f00c fcad 	bl	134c4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09>
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER
            SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10();
    6b6a:	f00c fcd1 	bl	13510 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10>
            (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PIDR &= ~((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    6b6e:	9b01      	ldr	r3, [sp, #4]
    6b70:	685a      	ldr	r2, [r3, #4]
    6b72:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6b76:	005b      	lsls	r3, r3, #1
    6b78:	4413      	add	r3, r2
    6b7a:	881b      	ldrh	r3, [r3, #0]
    6b7c:	095b      	lsrs	r3, r3, #5
    6b7e:	b29b      	uxth	r3, r3
    6b80:	461a      	mov	r2, r3
    6b82:	4b3b      	ldr	r3, [pc, #236]	; (6c70 <Port_Ipw_Init_UnusedPins+0x26c>)
    6b84:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6b88:	6999      	ldr	r1, [r3, #24]
    6b8a:	9b01      	ldr	r3, [sp, #4]
    6b8c:	685a      	ldr	r2, [r3, #4]
    6b8e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6b92:	005b      	lsls	r3, r3, #1
    6b94:	4413      	add	r3, r2
    6b96:	881b      	ldrh	r3, [r3, #0]
    6b98:	f003 031f 	and.w	r3, r3, #31
    6b9c:	2201      	movs	r2, #1
    6b9e:	fa02 f303 	lsl.w	r3, r2, r3
    6ba2:	43da      	mvns	r2, r3
    6ba4:	9b01      	ldr	r3, [sp, #4]
    6ba6:	6858      	ldr	r0, [r3, #4]
    6ba8:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6bac:	005b      	lsls	r3, r3, #1
    6bae:	4403      	add	r3, r0
    6bb0:	881b      	ldrh	r3, [r3, #0]
    6bb2:	095b      	lsrs	r3, r3, #5
    6bb4:	b29b      	uxth	r3, r3
    6bb6:	4618      	mov	r0, r3
    6bb8:	4b2d      	ldr	r3, [pc, #180]	; (6c70 <Port_Ipw_Init_UnusedPins+0x26c>)
    6bba:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    6bbe:	400a      	ands	r2, r1
    6bc0:	619a      	str	r2, [r3, #24]

            /* Check if the pin is HIGH-Z. In this case the driver needs to disable port input in PIDR register of GPIO IP */
            if (PORT_PIN_HIGH_Z == eLocalPDDIR)
    6bc2:	9b02      	ldr	r3, [sp, #8]
    6bc4:	2b03      	cmp	r3, #3
    6bc6:	d127      	bne.n	6c18 <Port_Ipw_Init_UnusedPins+0x214>
            {
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PIDR |= ((uint32)1U << GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex]));
    6bc8:	9b01      	ldr	r3, [sp, #4]
    6bca:	685a      	ldr	r2, [r3, #4]
    6bcc:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6bd0:	005b      	lsls	r3, r3, #1
    6bd2:	4413      	add	r3, r2
    6bd4:	881b      	ldrh	r3, [r3, #0]
    6bd6:	095b      	lsrs	r3, r3, #5
    6bd8:	b29b      	uxth	r3, r3
    6bda:	461a      	mov	r2, r3
    6bdc:	4b24      	ldr	r3, [pc, #144]	; (6c70 <Port_Ipw_Init_UnusedPins+0x26c>)
    6bde:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6be2:	6999      	ldr	r1, [r3, #24]
    6be4:	9b01      	ldr	r3, [sp, #4]
    6be6:	685a      	ldr	r2, [r3, #4]
    6be8:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6bec:	005b      	lsls	r3, r3, #1
    6bee:	4413      	add	r3, r2
    6bf0:	881b      	ldrh	r3, [r3, #0]
    6bf2:	f003 031f 	and.w	r3, r3, #31
    6bf6:	2201      	movs	r2, #1
    6bf8:	409a      	lsls	r2, r3
    6bfa:	9b01      	ldr	r3, [sp, #4]
    6bfc:	6858      	ldr	r0, [r3, #4]
    6bfe:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6c02:	005b      	lsls	r3, r3, #1
    6c04:	4403      	add	r3, r0
    6c06:	881b      	ldrh	r3, [r3, #0]
    6c08:	095b      	lsrs	r3, r3, #5
    6c0a:	b29b      	uxth	r3, r3
    6c0c:	4618      	mov	r0, r3
    6c0e:	4b18      	ldr	r3, [pc, #96]	; (6c70 <Port_Ipw_Init_UnusedPins+0x26c>)
    6c10:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    6c14:	430a      	orrs	r2, r1
    6c16:	619a      	str	r2, [r3, #24]
            }
            SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10();
    6c18:	f00c fca6 	bl	13568 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10>
#endif /* FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER */
        }
        /* Write PCR configuration from Configuration tool */
        (Port_au32PortCiPortBaseAddr[GPIO_PORT_U32(pConfigPtr->pUnusedPads[u16PinIndex])])->PCR[GPIO_CHANNEL_U32(pConfigPtr->pUnusedPads[u16PinIndex])] = u32LocalPCR;
    6c1c:	9b01      	ldr	r3, [sp, #4]
    6c1e:	685a      	ldr	r2, [r3, #4]
    6c20:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6c24:	005b      	lsls	r3, r3, #1
    6c26:	4413      	add	r3, r2
    6c28:	881b      	ldrh	r3, [r3, #0]
    6c2a:	095b      	lsrs	r3, r3, #5
    6c2c:	b29b      	uxth	r3, r3
    6c2e:	461a      	mov	r2, r3
    6c30:	4b10      	ldr	r3, [pc, #64]	; (6c74 <Port_Ipw_Init_UnusedPins+0x270>)
    6c32:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6c36:	9a01      	ldr	r2, [sp, #4]
    6c38:	6851      	ldr	r1, [r2, #4]
    6c3a:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    6c3e:	0052      	lsls	r2, r2, #1
    6c40:	440a      	add	r2, r1
    6c42:	8812      	ldrh	r2, [r2, #0]
    6c44:	f002 021f 	and.w	r2, r2, #31
    6c48:	9903      	ldr	r1, [sp, #12]
    6c4a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumUnusedPins; u16PinIndex++)
    6c4e:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    6c52:	3301      	adds	r3, #1
    6c54:	f8ad 3016 	strh.w	r3, [sp, #22]
    6c58:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    6c5c:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    6c60:	429a      	cmp	r2, r3
    6c62:	f4ff aee7 	bcc.w	6a34 <Port_Ipw_Init_UnusedPins+0x30>
    }
}
    6c66:	bf00      	nop
    6c68:	bf00      	nop
    6c6a:	b007      	add	sp, #28
    6c6c:	f85d fb04 	ldr.w	pc, [sp], #4
    6c70:	00015bcc 	.word	0x00015bcc
    6c74:	00015bb8 	.word	0x00015bb8

00006c78 <Port_Ipw_Init>:
*/
void Port_Ipw_Init
(
    const Port_ConfigType * pConfigPtr
)
{
    6c78:	b500      	push	{lr}
    6c7a:	b085      	sub	sp, #20
    6c7c:	9001      	str	r0, [sp, #4]
    uint16 u16PinIndex;

    uint8 u8NumDigFilterPorts          = (uint8)(pConfigPtr->u8NumDigitalFilterPorts);
    6c7e:	9b01      	ldr	r3, [sp, #4]
    6c80:	7c1b      	ldrb	r3, [r3, #16]
    6c82:	f88d 300d 	strb.w	r3, [sp, #13]
    uint8 u8Port;

    /* Initialize all configured digital filter ports. Use u16PinIndex variable as counter, even if we loop on a uint8 variable */
    for (u16PinIndex = (uint16)0U; u16PinIndex < (uint16)u8NumDigFilterPorts; u16PinIndex++)
    6c86:	2300      	movs	r3, #0
    6c88:	f8ad 300e 	strh.w	r3, [sp, #14]
    6c8c:	e035      	b.n	6cfa <Port_Ipw_Init+0x82>
    {
        u8Port = pConfigPtr->pDigitalFilterConfig[u16PinIndex].u8Port;
    6c8e:	9b01      	ldr	r3, [sp, #4]
    6c90:	695a      	ldr	r2, [r3, #20]
    6c92:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    6c96:	00db      	lsls	r3, r3, #3
    6c98:	4413      	add	r3, r2
    6c9a:	781b      	ldrb	r3, [r3, #0]
    6c9c:	f88d 300c 	strb.w	r3, [sp, #12]

        /* Set digital filter clock and width for the current port */
        Port_Ci_Port_Ip_ConfigDigitalFilter(Port_au32PortCiPortBaseAddr[u8Port], &(pConfigPtr->pDigitalFilterConfig[u16PinIndex]));
    6ca0:	f89d 300c 	ldrb.w	r3, [sp, #12]
    6ca4:	4a29      	ldr	r2, [pc, #164]	; (6d4c <Port_Ipw_Init+0xd4>)
    6ca6:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
    6caa:	9b01      	ldr	r3, [sp, #4]
    6cac:	695a      	ldr	r2, [r3, #20]
    6cae:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    6cb2:	00db      	lsls	r3, r3, #3
    6cb4:	4413      	add	r3, r2
    6cb6:	4619      	mov	r1, r3
    6cb8:	f7ff fe39 	bl	692e <Port_Ci_Port_Ip_ConfigDigitalFilter>
        /* Enable digital filter for the pins selected by the user for the current port */
        SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15();
    6cbc:	f00c fdc2 	bl	13844 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15>
        (Port_au32PortCiPortBaseAddr[u8Port])->DFER |= (uint32)(pConfigPtr->pDigitalFilterConfig[u16PinIndex].u32PinMask);
    6cc0:	f89d 300c 	ldrb.w	r3, [sp, #12]
    6cc4:	4a21      	ldr	r2, [pc, #132]	; (6d4c <Port_Ipw_Init+0xd4>)
    6cc6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    6cca:	f8d3 10c0 	ldr.w	r1, [r3, #192]	; 0xc0
    6cce:	9b01      	ldr	r3, [sp, #4]
    6cd0:	695a      	ldr	r2, [r3, #20]
    6cd2:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    6cd6:	00db      	lsls	r3, r3, #3
    6cd8:	4413      	add	r3, r2
    6cda:	685a      	ldr	r2, [r3, #4]
    6cdc:	f89d 300c 	ldrb.w	r3, [sp, #12]
    6ce0:	481a      	ldr	r0, [pc, #104]	; (6d4c <Port_Ipw_Init+0xd4>)
    6ce2:	f850 3023 	ldr.w	r3, [r0, r3, lsl #2]
    6ce6:	430a      	orrs	r2, r1
    6ce8:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
        SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15();
    6cec:	f00c fdd6 	bl	1389c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15>
    for (u16PinIndex = (uint16)0U; u16PinIndex < (uint16)u8NumDigFilterPorts; u16PinIndex++)
    6cf0:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    6cf4:	3301      	adds	r3, #1
    6cf6:	f8ad 300e 	strh.w	r3, [sp, #14]
    6cfa:	f89d 300d 	ldrb.w	r3, [sp, #13]
    6cfe:	b29b      	uxth	r3, r3
    6d00:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    6d04:	429a      	cmp	r2, r3
    6d06:	d3c2      	bcc.n	6c8e <Port_Ipw_Init+0x16>
    }

    (void)Port_Ci_Port_Ip_Init(NUM_OF_CONFIGURED_PINS, pConfigPtr->IpConfigPtr);
    6d08:	9b01      	ldr	r3, [sp, #4]
    6d0a:	6a1b      	ldr	r3, [r3, #32]
    6d0c:	4619      	mov	r1, r3
    6d0e:	200e      	movs	r0, #14
    6d10:	f7ff fd98 	bl	6844 <Port_Ci_Port_Ip_Init>

    /* Initialize All Unused Port Pins */
    Port_Ipw_Init_UnusedPins(pConfigPtr);
    6d14:	9801      	ldr	r0, [sp, #4]
    6d16:	f7ff fe75 	bl	6a04 <Port_Ipw_Init_UnusedPins>
     (defined(PORT_SET_2_PINS_DIRECTION_API) && (STD_ON == PORT_SET_2_PINS_DIRECTION_API))  \
    )
    /* Port_Ipw_au16GpioDirChangeability is only used by Port_Ci_Port_Ip_SetPinDirection, Port_Ci_Port_Ip_Set2PinsDirection
       and Port_Ci_Port_Ip_SetPinMode functions */
    /* Initialize the Array with Change Direction Flags for GPIO */
    for (u16PinIndex = (uint16)0U; u16PinIndex < PAD_16BLOCK_NO_U8; u16PinIndex++)
    6d1a:	2300      	movs	r3, #0
    6d1c:	f8ad 300e 	strh.w	r3, [sp, #14]
    6d20:	e00a      	b.n	6d38 <Port_Ipw_Init+0xc0>
    {
        Port_Ipw_au16GpioDirChangeability[u16PinIndex] = (uint16)0UL;
    6d22:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    6d26:	4a0a      	ldr	r2, [pc, #40]	; (6d50 <Port_Ipw_Init+0xd8>)
    6d28:	2100      	movs	r1, #0
    6d2a:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
    for (u16PinIndex = (uint16)0U; u16PinIndex < PAD_16BLOCK_NO_U8; u16PinIndex++)
    6d2e:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    6d32:	3301      	adds	r3, #1
    6d34:	f8ad 300e 	strh.w	r3, [sp, #14]
    6d38:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    6d3c:	2b09      	cmp	r3, #9
    6d3e:	d9f0      	bls.n	6d22 <Port_Ipw_Init+0xaa>
#endif /* ((STD_ON == PORT_SET_PIN_DIRECTION_API) || (STD_ON == PORT_SET_PIN_MODE_API) ||         \
           (defined(PORT_SET_2_PINS_DIRECTION_API) && (STD_ON == PORT_SET_2_PINS_DIRECTION_API))  \
          ) */
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */

}
    6d40:	bf00      	nop
    6d42:	bf00      	nop
    6d44:	b005      	add	sp, #20
    6d46:	f85d fb04 	ldr.w	pc, [sp], #4
    6d4a:	bf00      	nop
    6d4c:	00015bb8 	.word	0x00015bb8
    6d50:	1fff8cec 	.word	0x1fff8cec

00006d54 <Port_Ipw_SetPinDirection>:
(
    Port_PinType            PinIndex,
    Port_PinDirectionType   eDirection,
    const Port_ConfigType * pConfigPtr
)
{
    6d54:	b500      	push	{lr}
    6d56:	b087      	sub	sp, #28
    6d58:	9003      	str	r0, [sp, #12]
    6d5a:	9102      	str	r1, [sp, #8]
    6d5c:	9201      	str	r2, [sp, #4]
    /* Point to the Port Pin PCR register address */
    uint16 Pin = pConfigPtr->pUsedPadConfig[PinIndex].Pin;
    6d5e:	9b01      	ldr	r3, [sp, #4]
    6d60:	68d9      	ldr	r1, [r3, #12]
    6d62:	9a03      	ldr	r2, [sp, #12]
    6d64:	4613      	mov	r3, r2
    6d66:	009b      	lsls	r3, r3, #2
    6d68:	4413      	add	r3, r2
    6d6a:	009b      	lsls	r3, r3, #2
    6d6c:	440b      	add	r3, r1
    6d6e:	881b      	ldrh	r3, [r3, #0]
    6d70:	f8ad 3014 	strh.w	r3, [sp, #20]
    /* Return value */
    Std_ReturnType PinDirError             = (Std_ReturnType)E_OK;
    6d74:	2300      	movs	r3, #0
    6d76:	f88d 3017 	strb.w	r3, [sp, #23]

#if (STD_ON == PORT_DEV_ERROR_DETECT)
    uint8 CoreId;
    CoreId = (uint8)Port_GetCoreID();
    6d7a:	2300      	movs	r3, #0
    6d7c:	f88d 3013 	strb.w	r3, [sp, #19]

    if ((PinIndex >= (Port_PinType)pConfigPtr->u16NumPins))
    6d80:	9b01      	ldr	r3, [sp, #4]
    6d82:	881b      	ldrh	r3, [r3, #0]
    6d84:	461a      	mov	r2, r3
    6d86:	9b03      	ldr	r3, [sp, #12]
    6d88:	4293      	cmp	r3, r2
    6d8a:	d306      	bcc.n	6d9a <Port_Ipw_SetPinDirection+0x46>
    {
        (void)Det_ReportError((uint16)PORT_MODULE_ID, (uint8)PORT_INSTANCE_ID, (uint8)PORT_SETPINDIRECTION_ID, (uint8)PORT_E_PARAM_PIN);
    6d8c:	230a      	movs	r3, #10
    6d8e:	2201      	movs	r2, #1
    6d90:	2100      	movs	r1, #0
    6d92:	207c      	movs	r0, #124	; 0x7c
    6d94:	f00d fac4 	bl	14320 <Det_ReportError>
    6d98:	e0c9      	b.n	6f2e <Port_Ipw_SetPinDirection+0x1da>
    }
    /* Check port pin validity */
    else if ((uint32)1 != (((pConfigPtr->pau32Port_PinToPartitionMap[PinIndex]) & ((uint32)1 << CoreId)) >> CoreId))
    6d9a:	9b01      	ldr	r3, [sp, #4]
    6d9c:	699a      	ldr	r2, [r3, #24]
    6d9e:	9b03      	ldr	r3, [sp, #12]
    6da0:	009b      	lsls	r3, r3, #2
    6da2:	4413      	add	r3, r2
    6da4:	681a      	ldr	r2, [r3, #0]
    6da6:	f89d 3013 	ldrb.w	r3, [sp, #19]
    6daa:	2101      	movs	r1, #1
    6dac:	fa01 f303 	lsl.w	r3, r1, r3
    6db0:	401a      	ands	r2, r3
    6db2:	f89d 3013 	ldrb.w	r3, [sp, #19]
    6db6:	fa22 f303 	lsr.w	r3, r2, r3
    6dba:	2b01      	cmp	r3, #1
    6dbc:	d006      	beq.n	6dcc <Port_Ipw_SetPinDirection+0x78>
    {
        (void)Det_ReportError((uint16)PORT_MODULE_ID, (uint8)PORT_INSTANCE_ID, (uint8)PORT_SETPINDIRECTION_ID, (uint8)PORT_E_PARAM_CONFIG);
    6dbe:	23f0      	movs	r3, #240	; 0xf0
    6dc0:	2201      	movs	r2, #1
    6dc2:	2100      	movs	r1, #0
    6dc4:	207c      	movs	r0, #124	; 0x7c
    6dc6:	f00d faab 	bl	14320 <Det_ReportError>
    6dca:	e0b0      	b.n	6f2e <Port_Ipw_SetPinDirection+0x1da>
    }
    else
    {
        /* Bit Offset and Table value for change direction flag word */
        uint8 u8PinDescBitOffset       = (uint8)(Pin & PORT_CI_BIT_OFFSET_MASK_U8);
    6dcc:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    6dd0:	b2db      	uxtb	r3, r3
    6dd2:	f003 030f 	and.w	r3, r3, #15
    6dd6:	f88d 3012 	strb.w	r3, [sp, #18]
        /* Number of block 16 */
        uint16 u16PinChangeDirFlagWord  = Port_Ipw_au16GpioDirChangeability[(uint8)(Pin >> 4)];
    6dda:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    6dde:	091b      	lsrs	r3, r3, #4
    6de0:	b29b      	uxth	r3, r3
    6de2:	b2db      	uxtb	r3, r3
    6de4:	461a      	mov	r2, r3
    6de6:	4b55      	ldr	r3, [pc, #340]	; (6f3c <Port_Ipw_SetPinDirection+0x1e8>)
    6de8:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    6dec:	f8ad 3010 	strh.w	r3, [sp, #16]

        /* Check the Direction changeability option */
        if ((TRUE == pConfigPtr->pUsedPadConfig[PinIndex].bDC) || ((uint16)0 != (u16PinChangeDirFlagWord & (uint16)(1UL << u8PinDescBitOffset))))
    6df0:	9b01      	ldr	r3, [sp, #4]
    6df2:	68d9      	ldr	r1, [r3, #12]
    6df4:	9a03      	ldr	r2, [sp, #12]
    6df6:	4613      	mov	r3, r2
    6df8:	009b      	lsls	r3, r3, #2
    6dfa:	4413      	add	r3, r2
    6dfc:	009b      	lsls	r3, r3, #2
    6dfe:	440b      	add	r3, r1
    6e00:	7c5b      	ldrb	r3, [r3, #17]
    6e02:	2b00      	cmp	r3, #0
    6e04:	d10c      	bne.n	6e20 <Port_Ipw_SetPinDirection+0xcc>
    6e06:	f89d 3012 	ldrb.w	r3, [sp, #18]
    6e0a:	2201      	movs	r2, #1
    6e0c:	fa02 f303 	lsl.w	r3, r2, r3
    6e10:	b29a      	uxth	r2, r3
    6e12:	f8bd 3010 	ldrh.w	r3, [sp, #16]
    6e16:	4013      	ands	r3, r2
    6e18:	b29b      	uxth	r3, r3
    6e1a:	2b00      	cmp	r3, #0
    6e1c:	f000 8082 	beq.w	6f24 <Port_Ipw_SetPinDirection+0x1d0>
        {
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */
            /* Configures Port Pin as Output */
            if (PORT_PIN_OUT == eDirection)
    6e20:	9b02      	ldr	r3, [sp, #8]
    6e22:	2b02      	cmp	r3, #2
    6e24:	d11d      	bne.n	6e62 <Port_Ipw_SetPinDirection+0x10e>
            {
                SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16();
    6e26:	f00c fd5f 	bl	138e8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16>
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(Pin)])->PDDR |= (uint32)(1UL << GPIO_CHANNEL_U32(Pin));
    6e2a:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    6e2e:	095b      	lsrs	r3, r3, #5
    6e30:	b29b      	uxth	r3, r3
    6e32:	461a      	mov	r2, r3
    6e34:	4b42      	ldr	r3, [pc, #264]	; (6f40 <Port_Ipw_SetPinDirection+0x1ec>)
    6e36:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6e3a:	6959      	ldr	r1, [r3, #20]
    6e3c:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    6e40:	f003 031f 	and.w	r3, r3, #31
    6e44:	2201      	movs	r2, #1
    6e46:	409a      	lsls	r2, r3
    6e48:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    6e4c:	095b      	lsrs	r3, r3, #5
    6e4e:	b29b      	uxth	r3, r3
    6e50:	4618      	mov	r0, r3
    6e52:	4b3b      	ldr	r3, [pc, #236]	; (6f40 <Port_Ipw_SetPinDirection+0x1ec>)
    6e54:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    6e58:	430a      	orrs	r2, r1
    6e5a:	615a      	str	r2, [r3, #20]
                SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16();
    6e5c:	f00c fd70 	bl	13940 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16>
            if (PORT_PIN_OUT == eDirection)
    6e60:	e064      	b.n	6f2c <Port_Ipw_SetPinDirection+0x1d8>
            }
            /* Configures Port Pin as Input or High-Z*/
            else if ((PORT_PIN_IN == eDirection) || (PORT_PIN_HIGH_Z == eDirection))
    6e62:	9b02      	ldr	r3, [sp, #8]
    6e64:	2b01      	cmp	r3, #1
    6e66:	d002      	beq.n	6e6e <Port_Ipw_SetPinDirection+0x11a>
    6e68:	9b02      	ldr	r3, [sp, #8]
    6e6a:	2b03      	cmp	r3, #3
    6e6c:	d15e      	bne.n	6f2c <Port_Ipw_SetPinDirection+0x1d8>
            {
                SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16();
    6e6e:	f00c fd3b 	bl	138e8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16>
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(Pin)])->PDDR &= ~((uint32)(1UL << GPIO_CHANNEL_U32(Pin)));
    6e72:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    6e76:	095b      	lsrs	r3, r3, #5
    6e78:	b29b      	uxth	r3, r3
    6e7a:	461a      	mov	r2, r3
    6e7c:	4b30      	ldr	r3, [pc, #192]	; (6f40 <Port_Ipw_SetPinDirection+0x1ec>)
    6e7e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6e82:	6959      	ldr	r1, [r3, #20]
    6e84:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    6e88:	f003 031f 	and.w	r3, r3, #31
    6e8c:	2201      	movs	r2, #1
    6e8e:	fa02 f303 	lsl.w	r3, r2, r3
    6e92:	43da      	mvns	r2, r3
    6e94:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    6e98:	095b      	lsrs	r3, r3, #5
    6e9a:	b29b      	uxth	r3, r3
    6e9c:	4618      	mov	r0, r3
    6e9e:	4b28      	ldr	r3, [pc, #160]	; (6f40 <Port_Ipw_SetPinDirection+0x1ec>)
    6ea0:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    6ea4:	400a      	ands	r2, r1
    6ea6:	615a      	str	r2, [r3, #20]
                SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16();
    6ea8:	f00c fd4a 	bl	13940 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16>

#ifdef FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER
                SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17();
    6eac:	f00c fd6e 	bl	1398c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17>
                (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(Pin)])->PIDR &= ~((uint32)(1UL << GPIO_CHANNEL_U32(Pin)));
    6eb0:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    6eb4:	095b      	lsrs	r3, r3, #5
    6eb6:	b29b      	uxth	r3, r3
    6eb8:	461a      	mov	r2, r3
    6eba:	4b21      	ldr	r3, [pc, #132]	; (6f40 <Port_Ipw_SetPinDirection+0x1ec>)
    6ebc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6ec0:	6999      	ldr	r1, [r3, #24]
    6ec2:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    6ec6:	f003 031f 	and.w	r3, r3, #31
    6eca:	2201      	movs	r2, #1
    6ecc:	fa02 f303 	lsl.w	r3, r2, r3
    6ed0:	43da      	mvns	r2, r3
    6ed2:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    6ed6:	095b      	lsrs	r3, r3, #5
    6ed8:	b29b      	uxth	r3, r3
    6eda:	4618      	mov	r0, r3
    6edc:	4b18      	ldr	r3, [pc, #96]	; (6f40 <Port_Ipw_SetPinDirection+0x1ec>)
    6ede:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    6ee2:	400a      	ands	r2, r1
    6ee4:	619a      	str	r2, [r3, #24]

                /* Check if the pin is HIGH-Z. In this case the driver needs to disable port input in PIDR register of GPIO IP*/
                if (PORT_PIN_HIGH_Z == eDirection)
    6ee6:	9b02      	ldr	r3, [sp, #8]
    6ee8:	2b03      	cmp	r3, #3
    6eea:	d118      	bne.n	6f1e <Port_Ipw_SetPinDirection+0x1ca>
                {
                    (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(Pin)])->PIDR |= ((uint32)(1UL << GPIO_CHANNEL_U32(Pin)));
    6eec:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    6ef0:	095b      	lsrs	r3, r3, #5
    6ef2:	b29b      	uxth	r3, r3
    6ef4:	461a      	mov	r2, r3
    6ef6:	4b12      	ldr	r3, [pc, #72]	; (6f40 <Port_Ipw_SetPinDirection+0x1ec>)
    6ef8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    6efc:	6999      	ldr	r1, [r3, #24]
    6efe:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    6f02:	f003 031f 	and.w	r3, r3, #31
    6f06:	2201      	movs	r2, #1
    6f08:	409a      	lsls	r2, r3
    6f0a:	f8bd 3014 	ldrh.w	r3, [sp, #20]
    6f0e:	095b      	lsrs	r3, r3, #5
    6f10:	b29b      	uxth	r3, r3
    6f12:	4618      	mov	r0, r3
    6f14:	4b0a      	ldr	r3, [pc, #40]	; (6f40 <Port_Ipw_SetPinDirection+0x1ec>)
    6f16:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    6f1a:	430a      	orrs	r2, r1
    6f1c:	619a      	str	r2, [r3, #24]
                }
                SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17();
    6f1e:	f00c fd61 	bl	139e4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17>
            if (PORT_PIN_OUT == eDirection)
    6f22:	e003      	b.n	6f2c <Port_Ipw_SetPinDirection+0x1d8>
#if (STD_ON == PORT_DEV_ERROR_DETECT)
        }
        /* Direction changeability is NOT supported */
        else
        {
            PinDirError = (Std_ReturnType)E_NOT_OK;
    6f24:	2301      	movs	r3, #1
    6f26:	f88d 3017 	strb.w	r3, [sp, #23]
    6f2a:	e000      	b.n	6f2e <Port_Ipw_SetPinDirection+0x1da>
            if (PORT_PIN_OUT == eDirection)
    6f2c:	bf00      	nop
        }
    }
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */

    return PinDirError;
    6f2e:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    6f32:	4618      	mov	r0, r3
    6f34:	b007      	add	sp, #28
    6f36:	f85d fb04 	ldr.w	pc, [sp], #4
    6f3a:	bf00      	nop
    6f3c:	1fff8cec 	.word	0x1fff8cec
    6f40:	00015bcc 	.word	0x00015bcc

00006f44 <Port_Ipw_SetPinMode>:
(
    Port_PinType PinIndex,
    Port_PinModeType PinMode,
    const Port_ConfigType * pConfigPtr
)
{
    6f44:	b500      	push	{lr}
    6f46:	b08b      	sub	sp, #44	; 0x2c
    6f48:	9003      	str	r0, [sp, #12]
    6f4a:	460b      	mov	r3, r1
    6f4c:	9201      	str	r2, [sp, #4]
    6f4e:	f88d 300b 	strb.w	r3, [sp, #11]
    Std_ReturnType PinModeError             = (Std_ReturnType)0UL;
    6f52:	2300      	movs	r3, #0
    6f54:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    uint16 PinPad                           = pConfigPtr->pUsedPadConfig[PinIndex].Pin;
    6f58:	9b01      	ldr	r3, [sp, #4]
    6f5a:	68d9      	ldr	r1, [r3, #12]
    6f5c:	9a03      	ldr	r2, [sp, #12]
    6f5e:	4613      	mov	r3, r2
    6f60:	009b      	lsls	r3, r3, #2
    6f62:	4413      	add	r3, r2
    6f64:	009b      	lsls	r3, r3, #2
    6f66:	440b      	add	r3, r1
    6f68:	881b      	ldrh	r3, [r3, #0]
    6f6a:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    Port_PinModeType PinCfgRegValue         = (Port_PinModeType)PinMode;
    6f6e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    6f72:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    uint16 u16PinDescBitOffset;
    /* Variable used to clear and updated PCR register */
    uint32 u32LocalPCR;
#if (STD_ON == PORT_DEV_ERROR_DETECT)
    uint8 CoreId;
    CoreId = (uint8)Port_GetCoreID();
    6f76:	2300      	movs	r3, #0
    6f78:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22

    if ((PinIndex >= (Port_PinType)pConfigPtr->u16NumPins))
    6f7c:	9b01      	ldr	r3, [sp, #4]
    6f7e:	881b      	ldrh	r3, [r3, #0]
    6f80:	461a      	mov	r2, r3
    6f82:	9b03      	ldr	r3, [sp, #12]
    6f84:	4293      	cmp	r3, r2
    6f86:	d306      	bcc.n	6f96 <Port_Ipw_SetPinMode+0x52>
    {
        (void)Det_ReportError((uint16)PORT_MODULE_ID, (uint8)PORT_INSTANCE_ID, (uint8)PORT_SETPINMODE_ID, (uint8)PORT_E_PARAM_PIN);
    6f88:	230a      	movs	r3, #10
    6f8a:	2204      	movs	r2, #4
    6f8c:	2100      	movs	r1, #0
    6f8e:	207c      	movs	r0, #124	; 0x7c
    6f90:	f00d f9c6 	bl	14320 <Det_ReportError>
    6f94:	e0b3      	b.n	70fe <Port_Ipw_SetPinMode+0x1ba>
    }
    /* Check if this function was called with wrong core */
    else if ((uint32)1 != (((pConfigPtr->pau32Port_PinToPartitionMap[PinIndex]) & ((uint32)1 << CoreId)) >> CoreId))
    6f96:	9b01      	ldr	r3, [sp, #4]
    6f98:	699a      	ldr	r2, [r3, #24]
    6f9a:	9b03      	ldr	r3, [sp, #12]
    6f9c:	009b      	lsls	r3, r3, #2
    6f9e:	4413      	add	r3, r2
    6fa0:	681a      	ldr	r2, [r3, #0]
    6fa2:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
    6fa6:	2101      	movs	r1, #1
    6fa8:	fa01 f303 	lsl.w	r3, r1, r3
    6fac:	401a      	ands	r2, r3
    6fae:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
    6fb2:	fa22 f303 	lsr.w	r3, r2, r3
    6fb6:	2b01      	cmp	r3, #1
    6fb8:	d006      	beq.n	6fc8 <Port_Ipw_SetPinMode+0x84>
    {
        (void)Det_ReportError((uint16)PORT_MODULE_ID, (uint8)PORT_INSTANCE_ID, (uint8)PORT_SETPINMODE_ID, (uint8)PORT_E_PARAM_CONFIG);
    6fba:	23f0      	movs	r3, #240	; 0xf0
    6fbc:	2204      	movs	r2, #4
    6fbe:	2100      	movs	r1, #0
    6fc0:	207c      	movs	r0, #124	; 0x7c
    6fc2:	f00d f9ad 	bl	14320 <Det_ReportError>
    6fc6:	e09a      	b.n	70fe <Port_Ipw_SetPinMode+0x1ba>
    }
    /* Check port pin mode Unchangeable */
    else if (FALSE ==  pConfigPtr->pUsedPadConfig[PinIndex].bMC)
    6fc8:	9b01      	ldr	r3, [sp, #4]
    6fca:	68d9      	ldr	r1, [r3, #12]
    6fcc:	9a03      	ldr	r2, [sp, #12]
    6fce:	4613      	mov	r3, r2
    6fd0:	009b      	lsls	r3, r3, #2
    6fd2:	4413      	add	r3, r2
    6fd4:	009b      	lsls	r3, r3, #2
    6fd6:	440b      	add	r3, r1
    6fd8:	7c9b      	ldrb	r3, [r3, #18]
    6fda:	f083 0301 	eor.w	r3, r3, #1
    6fde:	b2db      	uxtb	r3, r3
    6fe0:	2b00      	cmp	r3, #0
    6fe2:	d006      	beq.n	6ff2 <Port_Ipw_SetPinMode+0xae>
    {
        (void)Det_ReportError((uint16)PORT_MODULE_ID, (uint8)PORT_INSTANCE_ID, (uint8)PORT_SETPINMODE_ID, (uint8)PORT_E_MODE_UNCHANGEABLE);
    6fe4:	230e      	movs	r3, #14
    6fe6:	2204      	movs	r2, #4
    6fe8:	2100      	movs	r1, #0
    6fea:	207c      	movs	r0, #124	; 0x7c
    6fec:	f00d f998 	bl	14320 <Det_ReportError>
    6ff0:	e085      	b.n	70fe <Port_Ipw_SetPinMode+0x1ba>
    }
    else
    {
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */

        if (PAD_MODE_OPTIONS_U8 <= PinMode)
    6ff2:	f89d 300b 	ldrb.w	r3, [sp, #11]
    6ff6:	2b07      	cmp	r3, #7
    6ff8:	d903      	bls.n	7002 <Port_Ipw_SetPinMode+0xbe>
        {
            PinModeError = PORT_E_PARAM_INVALID_MODE;
    6ffa:	230d      	movs	r3, #13
    6ffc:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    7000:	e07d      	b.n	70fe <Port_Ipw_SetPinMode+0x1ba>
        }
        else
        {
            Port_PinDirectionType ePadDirection = PORT_PIN_DISABLED;
    7002:	2300      	movs	r3, #0
    7004:	9307      	str	r3, [sp, #28]

            /* Bit offset of Pin index inside the pin description matrix */
            u16PinDescBitOffset = PinPad & PORT_MODE_BIT_OFFSET_MASK_U8;
    7006:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    700a:	f003 030f 	and.w	r3, r3, #15
    700e:	f8ad 301a 	strh.w	r3, [sp, #26]
            /* Selected word inside the pin description matrix */
            u16PinDescWord = (uint16)Port_au16PinDescription[(uint8)PinMode][PinPad >> 4U];
    7012:	f89d 200b 	ldrb.w	r2, [sp, #11]
    7016:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    701a:	091b      	lsrs	r3, r3, #4
    701c:	b29b      	uxth	r3, r3
    701e:	4618      	mov	r0, r3
    7020:	493a      	ldr	r1, [pc, #232]	; (710c <Port_Ipw_SetPinMode+0x1c8>)
    7022:	4613      	mov	r3, r2
    7024:	009b      	lsls	r3, r3, #2
    7026:	4413      	add	r3, r2
    7028:	005b      	lsls	r3, r3, #1
    702a:	4403      	add	r3, r0
    702c:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
    7030:	f8ad 3018 	strh.w	r3, [sp, #24]

            /* Check if desired mode is valid for selected pin */
            if ((u16PinDescWord & ((uint16)1UL<<u16PinDescBitOffset)) != (uint16)0U)
    7034:	f8bd 2018 	ldrh.w	r2, [sp, #24]
    7038:	f8bd 301a 	ldrh.w	r3, [sp, #26]
    703c:	fa42 f303 	asr.w	r3, r2, r3
    7040:	f003 0301 	and.w	r3, r3, #1
    7044:	2b00      	cmp	r3, #0
    7046:	d057      	beq.n	70f8 <Port_Ipw_SetPinMode+0x1b4>
            {
                switch(PinMode)
    7048:	f89d 300b 	ldrb.w	r3, [sp, #11]
    704c:	2b01      	cmp	r3, #1
    704e:	d11f      	bne.n	7090 <Port_Ipw_SetPinMode+0x14c>
                {
                    case PORT_GPIO_MODE:
#if (STD_ON == PORT_DEV_ERROR_DETECT)
                        Port_Ipw_SetGpioDirChangeability(PinPad, TRUE);
    7050:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    7054:	2101      	movs	r1, #1
    7056:	4618      	mov	r0, r3
    7058:	f000 f85c 	bl	7114 <Port_Ipw_SetGpioDirChangeability>
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */
                        ePadDirection = pConfigPtr->pUsedPadConfig[PinIndex].ePadDir;
    705c:	9b01      	ldr	r3, [sp, #4]
    705e:	68d9      	ldr	r1, [r3, #12]
    7060:	9a03      	ldr	r2, [sp, #12]
    7062:	4613      	mov	r3, r2
    7064:	009b      	lsls	r3, r3, #2
    7066:	4413      	add	r3, r2
    7068:	009b      	lsls	r3, r3, #2
    706a:	440b      	add	r3, r1
    706c:	68db      	ldr	r3, [r3, #12]
    706e:	9307      	str	r3, [sp, #28]
#if (STD_OFF == PORT_SETPINMODE_DOES_NOT_TOUCH_GPIO_LEVEL)
                        if ((PORT_PIN_IN != ePadDirection) && (PORT_PIN_HIGH_Z != ePadDirection))
    7070:	9b07      	ldr	r3, [sp, #28]
    7072:	2b01      	cmp	r3, #1
    7074:	d006      	beq.n	7084 <Port_Ipw_SetPinMode+0x140>
    7076:	9b07      	ldr	r3, [sp, #28]
    7078:	2b03      	cmp	r3, #3
    707a:	d003      	beq.n	7084 <Port_Ipw_SetPinMode+0x140>
                        {
                            Port_Ipw_SetGpioPadOutput(PinIndex, pConfigPtr);
    707c:	9901      	ldr	r1, [sp, #4]
    707e:	9803      	ldr	r0, [sp, #12]
    7080:	f000 f896 	bl	71b0 <Port_Ipw_SetGpioPadOutput>
                        }
#endif /* (STD_OFF == PORT_SETPINMODE_DOES_NOT_TOUCH_GPIO_LEVEL) */
                        (void)Port_Ipw_SetPinDirection(PinIndex, ePadDirection, pConfigPtr);
    7084:	9a01      	ldr	r2, [sp, #4]
    7086:	9907      	ldr	r1, [sp, #28]
    7088:	9803      	ldr	r0, [sp, #12]
    708a:	f7ff fe63 	bl	6d54 <Port_Ipw_SetPinDirection>
                        break;
    708e:	e006      	b.n	709e <Port_Ipw_SetPinMode+0x15a>

                    default:
#if (STD_ON == PORT_DEV_ERROR_DETECT)
                    /* All the ALT modes except GPIO*/
                        Port_Ipw_SetGpioDirChangeability(PinPad,FALSE);
    7090:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    7094:	2100      	movs	r1, #0
    7096:	4618      	mov	r0, r3
    7098:	f000 f83c 	bl	7114 <Port_Ipw_SetGpioDirChangeability>
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */
                        break;
    709c:	bf00      	nop
                }
                /* Sets the port pin mode */
                SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27();
    709e:	f00c ffa9 	bl	13ff4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27>
                u32LocalPCR  = (Port_au32PortCiPortBaseAddr[GPIO_PORT_U32(PinPad)])->PCR[GPIO_CHANNEL_U32(PinPad)];
    70a2:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    70a6:	095b      	lsrs	r3, r3, #5
    70a8:	b29b      	uxth	r3, r3
    70aa:	461a      	mov	r2, r3
    70ac:	4b18      	ldr	r3, [pc, #96]	; (7110 <Port_Ipw_SetPinMode+0x1cc>)
    70ae:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    70b2:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
    70b6:	f002 021f 	and.w	r2, r2, #31
    70ba:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    70be:	9305      	str	r3, [sp, #20]

                u32LocalPCR &= ~(PORT_CI_PCR_ALT_MODE_U32);
    70c0:	9b05      	ldr	r3, [sp, #20]
    70c2:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
    70c6:	9305      	str	r3, [sp, #20]
                u32LocalPCR |= ((uint32)PinCfgRegValue << PORT_CI_PCR_ALT_MODE_OFFSET_U32);
    70c8:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    70cc:	021b      	lsls	r3, r3, #8
    70ce:	9a05      	ldr	r2, [sp, #20]
    70d0:	4313      	orrs	r3, r2
    70d2:	9305      	str	r3, [sp, #20]

                (Port_au32PortCiPortBaseAddr[GPIO_PORT_U32(PinPad)])->PCR[GPIO_CHANNEL_U32(PinPad)] = u32LocalPCR;
    70d4:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    70d8:	095b      	lsrs	r3, r3, #5
    70da:	b29b      	uxth	r3, r3
    70dc:	461a      	mov	r2, r3
    70de:	4b0c      	ldr	r3, [pc, #48]	; (7110 <Port_Ipw_SetPinMode+0x1cc>)
    70e0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    70e4:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
    70e8:	f002 021f 	and.w	r2, r2, #31
    70ec:	9905      	ldr	r1, [sp, #20]
    70ee:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
                SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27();
    70f2:	f00c ffab 	bl	1404c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27>
    70f6:	e002      	b.n	70fe <Port_Ipw_SetPinMode+0x1ba>
            }
            else
            {
                PinModeError = PORT_E_PARAM_INVALID_MODE;
    70f8:	230d      	movs	r3, #13
    70fa:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
        }
#if (STD_ON == PORT_DEV_ERROR_DETECT)
    }
#endif /* (STD_ON == PORT_DEV_ERROR_DETECT) */

    return PinModeError;
    70fe:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
}
    7102:	4618      	mov	r0, r3
    7104:	b00b      	add	sp, #44	; 0x2c
    7106:	f85d fb04 	ldr.w	pc, [sp], #4
    710a:	bf00      	nop
    710c:	000166cc 	.word	0x000166cc
    7110:	00015bb8 	.word	0x00015bb8

00007114 <Port_Ipw_SetGpioDirChangeability>:
void Port_Ipw_SetGpioDirChangeability
(
    uint16 PadID,
    boolean bStatus
)
{
    7114:	b500      	push	{lr}
    7116:	b085      	sub	sp, #20
    7118:	4603      	mov	r3, r0
    711a:	460a      	mov	r2, r1
    711c:	f8ad 3006 	strh.w	r3, [sp, #6]
    7120:	4613      	mov	r3, r2
    7122:	f88d 3005 	strb.w	r3, [sp, #5]
    /* Pin description variables */
    uint8 u8PinBitOffset;
    uint16 u16PinDirFlagWord;

    /* Enter critical region */
    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18();
    7126:	f00c fc83 	bl	13a30 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18>
    /* Bit offset of Pin index inside the pin description matrix */
    u8PinBitOffset      = (uint8)((uint8)PadID & PORT_CI_BIT_OFFSET_MASK_U8);
    712a:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    712e:	b2db      	uxtb	r3, r3
    7130:	f003 030f 	and.w	r3, r3, #15
    7134:	f88d 300d 	strb.w	r3, [sp, #13]
    u16PinDirFlagWord   = Port_Ipw_au16GpioDirChangeability[(uint8)((uint8)PadID >> 4)];
    7138:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    713c:	b2db      	uxtb	r3, r3
    713e:	091b      	lsrs	r3, r3, #4
    7140:	b2db      	uxtb	r3, r3
    7142:	461a      	mov	r2, r3
    7144:	4b19      	ldr	r3, [pc, #100]	; (71ac <Port_Ipw_SetGpioDirChangeability+0x98>)
    7146:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    714a:	f8ad 300e 	strh.w	r3, [sp, #14]

    if (TRUE == bStatus)
    714e:	f89d 3005 	ldrb.w	r3, [sp, #5]
    7152:	2b00      	cmp	r3, #0
    7154:	d00b      	beq.n	716e <Port_Ipw_SetGpioDirChangeability+0x5a>
    {
        /* Set the change direction flag */
        u16PinDirFlagWord |= (uint16)(1UL<<u8PinBitOffset);
    7156:	f89d 300d 	ldrb.w	r3, [sp, #13]
    715a:	2201      	movs	r2, #1
    715c:	fa02 f303 	lsl.w	r3, r2, r3
    7160:	b29a      	uxth	r2, r3
    7162:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    7166:	4313      	orrs	r3, r2
    7168:	f8ad 300e 	strh.w	r3, [sp, #14]
    716c:	e00c      	b.n	7188 <Port_Ipw_SetGpioDirChangeability+0x74>
    }
    else
    {
        /* Reset the change direction flag */
        u16PinDirFlagWord &= (uint16)(~((uint16)(1UL<<u8PinBitOffset)));
    716e:	f89d 300d 	ldrb.w	r3, [sp, #13]
    7172:	2201      	movs	r2, #1
    7174:	fa02 f303 	lsl.w	r3, r2, r3
    7178:	b29b      	uxth	r3, r3
    717a:	43db      	mvns	r3, r3
    717c:	b29a      	uxth	r2, r3
    717e:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    7182:	4013      	ands	r3, r2
    7184:	f8ad 300e 	strh.w	r3, [sp, #14]
    }
    Port_Ipw_au16GpioDirChangeability[(uint8)((uint8)PadID >> 4)] = u16PinDirFlagWord;
    7188:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    718c:	b2db      	uxtb	r3, r3
    718e:	091b      	lsrs	r3, r3, #4
    7190:	b2db      	uxtb	r3, r3
    7192:	4619      	mov	r1, r3
    7194:	4a05      	ldr	r2, [pc, #20]	; (71ac <Port_Ipw_SetGpioDirChangeability+0x98>)
    7196:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    719a:	f822 3011 	strh.w	r3, [r2, r1, lsl #1]
    /* Exit critical region */
    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18();
    719e:	f00c fc73 	bl	13a88 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18>
}
    71a2:	bf00      	nop
    71a4:	b005      	add	sp, #20
    71a6:	f85d fb04 	ldr.w	pc, [sp], #4
    71aa:	bf00      	nop
    71ac:	1fff8cec 	.word	0x1fff8cec

000071b0 <Port_Ipw_SetGpioPadOutput>:
void Port_Ipw_SetGpioPadOutput
(
    Port_PinType            PinIndex,
    const Port_ConfigType * pConfigPtr
)
{
    71b0:	b084      	sub	sp, #16
    71b2:	9001      	str	r0, [sp, #4]
    71b4:	9100      	str	r1, [sp, #0]
    uint16 Pin = pConfigPtr->pUsedPadConfig[PinIndex].Pin;
    71b6:	9b00      	ldr	r3, [sp, #0]
    71b8:	68d9      	ldr	r1, [r3, #12]
    71ba:	9a01      	ldr	r2, [sp, #4]
    71bc:	4613      	mov	r3, r2
    71be:	009b      	lsls	r3, r3, #2
    71c0:	4413      	add	r3, r2
    71c2:	009b      	lsls	r3, r3, #2
    71c4:	440b      	add	r3, r1
    71c6:	881b      	ldrh	r3, [r3, #0]
    71c8:	f8ad 300e 	strh.w	r3, [sp, #14]
    uint8 u8LocalPDO = pConfigPtr->pUsedPadConfig[PinIndex].u8PDO;
    71cc:	9b00      	ldr	r3, [sp, #0]
    71ce:	68d9      	ldr	r1, [r3, #12]
    71d0:	9a01      	ldr	r2, [sp, #4]
    71d2:	4613      	mov	r3, r2
    71d4:	009b      	lsls	r3, r3, #2
    71d6:	4413      	add	r3, r2
    71d8:	009b      	lsls	r3, r3, #2
    71da:	440b      	add	r3, r1
    71dc:	7a1b      	ldrb	r3, [r3, #8]
    71de:	f88d 300d 	strb.w	r3, [sp, #13]

    /* Set pin to High value */
    if (PORT_PIN_LEVEL_HIGH_U8 == u8LocalPDO)
    71e2:	f89d 300d 	ldrb.w	r3, [sp, #13]
    71e6:	2b01      	cmp	r3, #1
    71e8:	d110      	bne.n	720c <Port_Ipw_SetGpioPadOutput+0x5c>
    {
        (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(Pin)])->PSOR = ((uint32)1U << GPIO_CHANNEL_U32(Pin));
    71ea:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    71ee:	f003 021f 	and.w	r2, r3, #31
    71f2:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    71f6:	095b      	lsrs	r3, r3, #5
    71f8:	b29b      	uxth	r3, r3
    71fa:	4619      	mov	r1, r3
    71fc:	4b0f      	ldr	r3, [pc, #60]	; (723c <Port_Ipw_SetGpioPadOutput+0x8c>)
    71fe:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    7202:	2101      	movs	r1, #1
    7204:	fa01 f202 	lsl.w	r2, r1, r2
    7208:	605a      	str	r2, [r3, #4]
    }
    else
    {
        /* No action to be done */
    }
}
    720a:	e013      	b.n	7234 <Port_Ipw_SetGpioPadOutput+0x84>
    else if (PORT_PIN_LEVEL_LOW_U8 == u8LocalPDO)
    720c:	f89d 300d 	ldrb.w	r3, [sp, #13]
    7210:	2b00      	cmp	r3, #0
    7212:	d10f      	bne.n	7234 <Port_Ipw_SetGpioPadOutput+0x84>
        (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(Pin)])->PCOR = ((uint32)1U << GPIO_CHANNEL_U32(Pin));
    7214:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    7218:	f003 021f 	and.w	r2, r3, #31
    721c:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    7220:	095b      	lsrs	r3, r3, #5
    7222:	b29b      	uxth	r3, r3
    7224:	4619      	mov	r1, r3
    7226:	4b05      	ldr	r3, [pc, #20]	; (723c <Port_Ipw_SetGpioPadOutput+0x8c>)
    7228:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    722c:	2101      	movs	r1, #1
    722e:	fa01 f202 	lsl.w	r2, r1, r2
    7232:	609a      	str	r2, [r3, #8]
}
    7234:	bf00      	nop
    7236:	b004      	add	sp, #16
    7238:	4770      	bx	lr
    723a:	bf00      	nop
    723c:	00015bcc 	.word	0x00015bcc

00007240 <Port_Ipw_RefreshPortDirection>:
*/
void Port_Ipw_RefreshPortDirection
(
    const Port_ConfigType * pConfigPtr
)
{
    7240:	b500      	push	{lr}
    7242:	b085      	sub	sp, #20
    7244:	9001      	str	r0, [sp, #4]
    uint16 u16NumPins = pConfigPtr->u16NumPins;
    7246:	9b01      	ldr	r3, [sp, #4]
    7248:	881b      	ldrh	r3, [r3, #0]
    724a:	f8ad 300c 	strh.w	r3, [sp, #12]
    /* Index of the port table */
    uint16 u16PinIndex;
    uint16 PinPad;

    /* Initialize All Configured Port Pins that aren't direction changable */
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumPins; u16PinIndex++)
    724e:	2300      	movs	r3, #0
    7250:	f8ad 300e 	strh.w	r3, [sp, #14]
    7254:	e0d2      	b.n	73fc <Port_Ipw_RefreshPortDirection+0x1bc>
    {
        if (FALSE == pConfigPtr->pUsedPadConfig[u16PinIndex].bDC)
    7256:	9b01      	ldr	r3, [sp, #4]
    7258:	68d9      	ldr	r1, [r3, #12]
    725a:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    725e:	4613      	mov	r3, r2
    7260:	009b      	lsls	r3, r3, #2
    7262:	4413      	add	r3, r2
    7264:	009b      	lsls	r3, r3, #2
    7266:	440b      	add	r3, r1
    7268:	7c5b      	ldrb	r3, [r3, #17]
    726a:	f083 0301 	eor.w	r3, r3, #1
    726e:	b2db      	uxtb	r3, r3
    7270:	2b00      	cmp	r3, #0
    7272:	f000 80be 	beq.w	73f2 <Port_Ipw_RefreshPortDirection+0x1b2>
        {
            /* On this platform we can only determine direction for the pins initialy configured as GPIOs */
            if (TRUE == pConfigPtr->pUsedPadConfig[u16PinIndex].bGPIO)
    7276:	9b01      	ldr	r3, [sp, #4]
    7278:	68d9      	ldr	r1, [r3, #12]
    727a:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    727e:	4613      	mov	r3, r2
    7280:	009b      	lsls	r3, r3, #2
    7282:	4413      	add	r3, r2
    7284:	009b      	lsls	r3, r3, #2
    7286:	440b      	add	r3, r1
    7288:	7c1b      	ldrb	r3, [r3, #16]
    728a:	2b00      	cmp	r3, #0
    728c:	f000 80b1 	beq.w	73f2 <Port_Ipw_RefreshPortDirection+0x1b2>
            {
                /* Point to the Port Pin MSCR register address*/
                PinPad = pConfigPtr->pUsedPadConfig[u16PinIndex].Pin;
    7290:	9b01      	ldr	r3, [sp, #4]
    7292:	68d9      	ldr	r1, [r3, #12]
    7294:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    7298:	4613      	mov	r3, r2
    729a:	009b      	lsls	r3, r3, #2
    729c:	4413      	add	r3, r2
    729e:	009b      	lsls	r3, r3, #2
    72a0:	440b      	add	r3, r1
    72a2:	881b      	ldrh	r3, [r3, #0]
    72a4:	f8ad 300a 	strh.w	r3, [sp, #10]

                /* Configures Port Pin as Output */
                if (PORT_PIN_OUT == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir)
    72a8:	9b01      	ldr	r3, [sp, #4]
    72aa:	68d9      	ldr	r1, [r3, #12]
    72ac:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    72b0:	4613      	mov	r3, r2
    72b2:	009b      	lsls	r3, r3, #2
    72b4:	4413      	add	r3, r2
    72b6:	009b      	lsls	r3, r3, #2
    72b8:	440b      	add	r3, r1
    72ba:	68db      	ldr	r3, [r3, #12]
    72bc:	2b02      	cmp	r3, #2
    72be:	d11d      	bne.n	72fc <Port_Ipw_RefreshPortDirection+0xbc>
                {
                    /* Configure the pin direction as output in the PDDR register of GPIO IP */
                    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19();
    72c0:	f00c fc08 	bl	13ad4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19>
                    (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PDDR |= ((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    72c4:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    72c8:	095b      	lsrs	r3, r3, #5
    72ca:	b29b      	uxth	r3, r3
    72cc:	461a      	mov	r2, r3
    72ce:	4b51      	ldr	r3, [pc, #324]	; (7414 <Port_Ipw_RefreshPortDirection+0x1d4>)
    72d0:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    72d4:	6959      	ldr	r1, [r3, #20]
    72d6:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    72da:	f003 031f 	and.w	r3, r3, #31
    72de:	2201      	movs	r2, #1
    72e0:	409a      	lsls	r2, r3
    72e2:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    72e6:	095b      	lsrs	r3, r3, #5
    72e8:	b29b      	uxth	r3, r3
    72ea:	4618      	mov	r0, r3
    72ec:	4b49      	ldr	r3, [pc, #292]	; (7414 <Port_Ipw_RefreshPortDirection+0x1d4>)
    72ee:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    72f2:	430a      	orrs	r2, r1
    72f4:	615a      	str	r2, [r3, #20]
                    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19();
    72f6:	f00c fc19 	bl	13b2c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19>
    72fa:	e07a      	b.n	73f2 <Port_Ipw_RefreshPortDirection+0x1b2>
                }
                /* Configures Port Pin as Input or High-Z*/
                else if ((PORT_PIN_IN == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir) || (PORT_PIN_HIGH_Z == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir))
    72fc:	9b01      	ldr	r3, [sp, #4]
    72fe:	68d9      	ldr	r1, [r3, #12]
    7300:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    7304:	4613      	mov	r3, r2
    7306:	009b      	lsls	r3, r3, #2
    7308:	4413      	add	r3, r2
    730a:	009b      	lsls	r3, r3, #2
    730c:	440b      	add	r3, r1
    730e:	68db      	ldr	r3, [r3, #12]
    7310:	2b01      	cmp	r3, #1
    7312:	d00b      	beq.n	732c <Port_Ipw_RefreshPortDirection+0xec>
    7314:	9b01      	ldr	r3, [sp, #4]
    7316:	68d9      	ldr	r1, [r3, #12]
    7318:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    731c:	4613      	mov	r3, r2
    731e:	009b      	lsls	r3, r3, #2
    7320:	4413      	add	r3, r2
    7322:	009b      	lsls	r3, r3, #2
    7324:	440b      	add	r3, r1
    7326:	68db      	ldr	r3, [r3, #12]
    7328:	2b03      	cmp	r3, #3
    732a:	d162      	bne.n	73f2 <Port_Ipw_RefreshPortDirection+0x1b2>
                {
                    /* Configure the pin direction as input in the PDDR register of GPIO IP */
                    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19();
    732c:	f00c fbd2 	bl	13ad4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19>
                    (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PDDR &= ~((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    7330:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    7334:	095b      	lsrs	r3, r3, #5
    7336:	b29b      	uxth	r3, r3
    7338:	461a      	mov	r2, r3
    733a:	4b36      	ldr	r3, [pc, #216]	; (7414 <Port_Ipw_RefreshPortDirection+0x1d4>)
    733c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    7340:	6959      	ldr	r1, [r3, #20]
    7342:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    7346:	f003 031f 	and.w	r3, r3, #31
    734a:	2201      	movs	r2, #1
    734c:	fa02 f303 	lsl.w	r3, r2, r3
    7350:	43da      	mvns	r2, r3
    7352:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    7356:	095b      	lsrs	r3, r3, #5
    7358:	b29b      	uxth	r3, r3
    735a:	4618      	mov	r0, r3
    735c:	4b2d      	ldr	r3, [pc, #180]	; (7414 <Port_Ipw_RefreshPortDirection+0x1d4>)
    735e:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    7362:	400a      	ands	r2, r1
    7364:	615a      	str	r2, [r3, #20]
                    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19();
    7366:	f00c fbe1 	bl	13b2c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19>
#ifdef FEATURE_PORT_CI_PORT_IP_HAS_PIDR_REGISTER
                    SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20();
    736a:	f00c fc05 	bl	13b78 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20>
                    (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PIDR &= ~((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    736e:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    7372:	095b      	lsrs	r3, r3, #5
    7374:	b29b      	uxth	r3, r3
    7376:	461a      	mov	r2, r3
    7378:	4b26      	ldr	r3, [pc, #152]	; (7414 <Port_Ipw_RefreshPortDirection+0x1d4>)
    737a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    737e:	6999      	ldr	r1, [r3, #24]
    7380:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    7384:	f003 031f 	and.w	r3, r3, #31
    7388:	2201      	movs	r2, #1
    738a:	fa02 f303 	lsl.w	r3, r2, r3
    738e:	43da      	mvns	r2, r3
    7390:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    7394:	095b      	lsrs	r3, r3, #5
    7396:	b29b      	uxth	r3, r3
    7398:	4618      	mov	r0, r3
    739a:	4b1e      	ldr	r3, [pc, #120]	; (7414 <Port_Ipw_RefreshPortDirection+0x1d4>)
    739c:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    73a0:	400a      	ands	r2, r1
    73a2:	619a      	str	r2, [r3, #24]

                    /* Check if the pin is HIGH-Z. In this case the driver needs to disable port input in PIDR register of GPIO IP*/
                    if (PORT_PIN_HIGH_Z == pConfigPtr->pUsedPadConfig[u16PinIndex].ePadDir)
    73a4:	9b01      	ldr	r3, [sp, #4]
    73a6:	68d9      	ldr	r1, [r3, #12]
    73a8:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    73ac:	4613      	mov	r3, r2
    73ae:	009b      	lsls	r3, r3, #2
    73b0:	4413      	add	r3, r2
    73b2:	009b      	lsls	r3, r3, #2
    73b4:	440b      	add	r3, r1
    73b6:	68db      	ldr	r3, [r3, #12]
    73b8:	2b03      	cmp	r3, #3
    73ba:	d118      	bne.n	73ee <Port_Ipw_RefreshPortDirection+0x1ae>
                    {
                        (Port_au32PortCiGpioBaseAddr[GPIO_PORT_U32(PinPad)])->PIDR |= ((uint32)1U << GPIO_CHANNEL_U32(PinPad));
    73bc:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    73c0:	095b      	lsrs	r3, r3, #5
    73c2:	b29b      	uxth	r3, r3
    73c4:	461a      	mov	r2, r3
    73c6:	4b13      	ldr	r3, [pc, #76]	; (7414 <Port_Ipw_RefreshPortDirection+0x1d4>)
    73c8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    73cc:	6999      	ldr	r1, [r3, #24]
    73ce:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    73d2:	f003 031f 	and.w	r3, r3, #31
    73d6:	2201      	movs	r2, #1
    73d8:	409a      	lsls	r2, r3
    73da:	f8bd 300a 	ldrh.w	r3, [sp, #10]
    73de:	095b      	lsrs	r3, r3, #5
    73e0:	b29b      	uxth	r3, r3
    73e2:	4618      	mov	r0, r3
    73e4:	4b0b      	ldr	r3, [pc, #44]	; (7414 <Port_Ipw_RefreshPortDirection+0x1d4>)
    73e6:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
    73ea:	430a      	orrs	r2, r1
    73ec:	619a      	str	r2, [r3, #24]
                    }
                    SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20();
    73ee:	f00c fbef 	bl	13bd0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20>
    for (u16PinIndex = (uint16)0U; u16PinIndex < u16NumPins; u16PinIndex++)
    73f2:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    73f6:	3301      	adds	r3, #1
    73f8:	f8ad 300e 	strh.w	r3, [sp, #14]
    73fc:	f8bd 200e 	ldrh.w	r2, [sp, #14]
    7400:	f8bd 300c 	ldrh.w	r3, [sp, #12]
    7404:	429a      	cmp	r2, r3
    7406:	f4ff af26 	bcc.w	7256 <Port_Ipw_RefreshPortDirection+0x16>
                    /* Do nothing. Else branch present in order to avoid MISRA's violations */
                }
            }
        }
    }
}
    740a:	bf00      	nop
    740c:	bf00      	nop
    740e:	b005      	add	sp, #20
    7410:	f85d fb04 	ldr.w	pc, [sp], #4
    7414:	00015bcc 	.word	0x00015bcc

00007418 <Adc_HwAcc_SetSC2Reg>:
#include "Adc_MemMap.h"

static inline void Adc_HwAcc_SetSC2Reg(ADC_Type * const Base,
                                       const uint32 ClearMask,
                                       const uint32 Value)
{
    7418:	b086      	sub	sp, #24
    741a:	9003      	str	r0, [sp, #12]
    741c:	9102      	str	r1, [sp, #8]
    741e:	9201      	str	r2, [sp, #4]
    /* Clear and set SC2 register based on ClearMask and Value */
    uint32 Sc2Reg = Base->SC2;
    7420:	9b03      	ldr	r3, [sp, #12]
    7422:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
    7426:	9305      	str	r3, [sp, #20]
    Sc2Reg &= ~(ClearMask);
    7428:	9b02      	ldr	r3, [sp, #8]
    742a:	43db      	mvns	r3, r3
    742c:	9a05      	ldr	r2, [sp, #20]
    742e:	4013      	ands	r3, r2
    7430:	9305      	str	r3, [sp, #20]
    Sc2Reg |= Value;
    7432:	9a05      	ldr	r2, [sp, #20]
    7434:	9b01      	ldr	r3, [sp, #4]
    7436:	4313      	orrs	r3, r2
    7438:	9305      	str	r3, [sp, #20]
    Base->SC2 = Sc2Reg;
    743a:	9b03      	ldr	r3, [sp, #12]
    743c:	9a05      	ldr	r2, [sp, #20]
    743e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
}
    7442:	bf00      	nop
    7444:	b006      	add	sp, #24
    7446:	4770      	bx	lr

00007448 <Adc_HwAcc_SetClock>:

static inline void Adc_HwAcc_SetClock(ADC_Type * const Base,
                                      const Adc_Ip_ClockSelType ClockDivide,
                                      const Adc_Ip_ClkSourceType InputClock)
{
    7448:	b086      	sub	sp, #24
    744a:	9003      	str	r0, [sp, #12]
    744c:	9102      	str	r1, [sp, #8]
    744e:	9201      	str	r2, [sp, #4]
    /* Update ClockDivide and InputClock values found in CFG1 register */
    uint32 Cfg1Reg = Base->CFG1;
    7450:	9b03      	ldr	r3, [sp, #12]
    7452:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    7454:	9305      	str	r3, [sp, #20]
    Cfg1Reg &= ~(ADC_CFG1_ADIV_MASK | ADC_CFG1_ADICLK_MASK);
    7456:	9b05      	ldr	r3, [sp, #20]
    7458:	f023 0363 	bic.w	r3, r3, #99	; 0x63
    745c:	9305      	str	r3, [sp, #20]
    Cfg1Reg |= ADC_CFG1_ADIV(ClockDivide);
    745e:	9b02      	ldr	r3, [sp, #8]
    7460:	015b      	lsls	r3, r3, #5
    7462:	f003 0360 	and.w	r3, r3, #96	; 0x60
    7466:	9a05      	ldr	r2, [sp, #20]
    7468:	4313      	orrs	r3, r2
    746a:	9305      	str	r3, [sp, #20]
    Cfg1Reg |= ADC_CFG1_ADICLK(InputClock);
    746c:	9b01      	ldr	r3, [sp, #4]
    746e:	f003 0303 	and.w	r3, r3, #3
    7472:	9a05      	ldr	r2, [sp, #20]
    7474:	4313      	orrs	r3, r2
    7476:	9305      	str	r3, [sp, #20]
    Base->CFG1 = Cfg1Reg;
    7478:	9b03      	ldr	r3, [sp, #12]
    747a:	9a05      	ldr	r2, [sp, #20]
    747c:	641a      	str	r2, [r3, #64]	; 0x40
}
    747e:	bf00      	nop
    7480:	b006      	add	sp, #24
    7482:	4770      	bx	lr

00007484 <Adc_HwAcc_GetClockDivide>:

static inline Adc_Ip_ClockSelType Adc_HwAcc_GetClockDivide(const uint32 Reg)
{
    7484:	b084      	sub	sp, #16
    7486:	9001      	str	r0, [sp, #4]
    /*
     * Retrieve ClockDivide value found in CFG1 register
     * Note: Reg should be the value of CFG1 register
     */
    Adc_Ip_ClockSelType ReturnValue = ADC_IP_CLK_FULL_BUS;
    7488:	2300      	movs	r3, #0
    748a:	9303      	str	r3, [sp, #12]
    switch ((Reg & ADC_CFG1_ADIV_MASK) >> ADC_CFG1_ADIV_SHIFT)
    748c:	9b01      	ldr	r3, [sp, #4]
    748e:	095b      	lsrs	r3, r3, #5
    7490:	f003 0303 	and.w	r3, r3, #3
    7494:	2b03      	cmp	r3, #3
    7496:	d00c      	beq.n	74b2 <Adc_HwAcc_GetClockDivide+0x2e>
    7498:	2b03      	cmp	r3, #3
    749a:	d80d      	bhi.n	74b8 <Adc_HwAcc_GetClockDivide+0x34>
    749c:	2b01      	cmp	r3, #1
    749e:	d002      	beq.n	74a6 <Adc_HwAcc_GetClockDivide+0x22>
    74a0:	2b02      	cmp	r3, #2
    74a2:	d003      	beq.n	74ac <Adc_HwAcc_GetClockDivide+0x28>
        case 3u:
            ReturnValue = ADC_IP_CLK_EIGHTH_BUS;
            break;
        default:
            ; /* no-op */
            break;
    74a4:	e008      	b.n	74b8 <Adc_HwAcc_GetClockDivide+0x34>
            ReturnValue = ADC_IP_CLK_HALF_BUS;
    74a6:	2301      	movs	r3, #1
    74a8:	9303      	str	r3, [sp, #12]
            break;
    74aa:	e006      	b.n	74ba <Adc_HwAcc_GetClockDivide+0x36>
            ReturnValue = ADC_IP_CLK_QUARTER_BUS;
    74ac:	2302      	movs	r3, #2
    74ae:	9303      	str	r3, [sp, #12]
            break;
    74b0:	e003      	b.n	74ba <Adc_HwAcc_GetClockDivide+0x36>
            ReturnValue = ADC_IP_CLK_EIGHTH_BUS;
    74b2:	2303      	movs	r3, #3
    74b4:	9303      	str	r3, [sp, #12]
            break;
    74b6:	e000      	b.n	74ba <Adc_HwAcc_GetClockDivide+0x36>
            break;
    74b8:	bf00      	nop
    }
    return ReturnValue;
    74ba:	9b03      	ldr	r3, [sp, #12]
}
    74bc:	4618      	mov	r0, r3
    74be:	b004      	add	sp, #16
    74c0:	4770      	bx	lr

000074c2 <Adc_HwAcc_GetInputClock>:

static inline Adc_Ip_ClkSourceType Adc_HwAcc_GetInputClock(const uint32 Reg)
{
    74c2:	b084      	sub	sp, #16
    74c4:	9001      	str	r0, [sp, #4]
    /*
     * Retrieve InputClock value found in CFG1 register
     * Note: Reg should be the value of CFG1 register
     */
    Adc_Ip_ClkSourceType ReturnValue = ADC_IP_CLK_ALT_1;
    74c6:	2300      	movs	r3, #0
    74c8:	9303      	str	r3, [sp, #12]
    switch ((Reg & ADC_CFG1_ADICLK_MASK) >> ADC_CFG1_ADICLK_SHIFT)
    74ca:	9b01      	ldr	r3, [sp, #4]
    74cc:	f003 0303 	and.w	r3, r3, #3
    74d0:	2b03      	cmp	r3, #3
    74d2:	d00c      	beq.n	74ee <Adc_HwAcc_GetInputClock+0x2c>
    74d4:	2b03      	cmp	r3, #3
    74d6:	d80d      	bhi.n	74f4 <Adc_HwAcc_GetInputClock+0x32>
    74d8:	2b01      	cmp	r3, #1
    74da:	d002      	beq.n	74e2 <Adc_HwAcc_GetInputClock+0x20>
    74dc:	2b02      	cmp	r3, #2
    74de:	d003      	beq.n	74e8 <Adc_HwAcc_GetInputClock+0x26>
        case 3u:
            ReturnValue = ADC_IP_CLK_ALT_4;
            break;
        default:
            ; /* no-op */
            break;
    74e0:	e008      	b.n	74f4 <Adc_HwAcc_GetInputClock+0x32>
            ReturnValue = ADC_IP_CLK_ALT_2;
    74e2:	2301      	movs	r3, #1
    74e4:	9303      	str	r3, [sp, #12]
            break;
    74e6:	e006      	b.n	74f6 <Adc_HwAcc_GetInputClock+0x34>
            ReturnValue = ADC_IP_CLK_ALT_3;
    74e8:	2302      	movs	r3, #2
    74ea:	9303      	str	r3, [sp, #12]
            break;
    74ec:	e003      	b.n	74f6 <Adc_HwAcc_GetInputClock+0x34>
            ReturnValue = ADC_IP_CLK_ALT_4;
    74ee:	2303      	movs	r3, #3
    74f0:	9303      	str	r3, [sp, #12]
            break;
    74f2:	e000      	b.n	74f6 <Adc_HwAcc_GetInputClock+0x34>
            break;
    74f4:	bf00      	nop
    }
    return ReturnValue;
    74f6:	9b03      	ldr	r3, [sp, #12]
}
    74f8:	4618      	mov	r0, r3
    74fa:	b004      	add	sp, #16
    74fc:	4770      	bx	lr

000074fe <Adc_HwAcc_SetSampleTime>:

static inline void Adc_HwAcc_SetSampleTime(ADC_Type * const Base,
                                           const uint8 SampleTime)
{
    74fe:	b084      	sub	sp, #16
    7500:	9001      	str	r0, [sp, #4]
    7502:	460b      	mov	r3, r1
    7504:	f88d 3003 	strb.w	r3, [sp, #3]
    /* Clip sample time to minimum value */
    uint8 ClippedSampleTime = (uint8)((SampleTime > 0U) ? SampleTime : 1U);
    7508:	f89d 3003 	ldrb.w	r3, [sp, #3]
    750c:	2b00      	cmp	r3, #0
    750e:	d002      	beq.n	7516 <Adc_HwAcc_SetSampleTime+0x18>
    7510:	f89d 3003 	ldrb.w	r3, [sp, #3]
    7514:	e000      	b.n	7518 <Adc_HwAcc_SetSampleTime+0x1a>
    7516:	2301      	movs	r3, #1
    7518:	f88d 300f 	strb.w	r3, [sp, #15]
    /* Update SampleTime values found in SC3 register */
    uint32 Cfg2Reg = Base->CFG2;
    751c:	9b01      	ldr	r3, [sp, #4]
    751e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    7520:	9302      	str	r3, [sp, #8]
    Cfg2Reg &= ~(ADC_CFG2_SMPLTS_MASK);
    7522:	9b02      	ldr	r3, [sp, #8]
    7524:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
    7528:	9302      	str	r3, [sp, #8]
    Cfg2Reg |= ADC_CFG2_SMPLTS(ClippedSampleTime);
    752a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    752e:	9a02      	ldr	r2, [sp, #8]
    7530:	4313      	orrs	r3, r2
    7532:	9302      	str	r3, [sp, #8]
    Base->CFG2 = Cfg2Reg;
    7534:	9b01      	ldr	r3, [sp, #4]
    7536:	9a02      	ldr	r2, [sp, #8]
    7538:	645a      	str	r2, [r3, #68]	; 0x44
}
    753a:	bf00      	nop
    753c:	b004      	add	sp, #16
    753e:	4770      	bx	lr

00007540 <Adc_HwAcc_SetAveraging>:

static inline void Adc_HwAcc_SetAveraging(ADC_Type * const Base,
                                          const boolean AvgEn,
                                          const Adc_Ip_AvgSelectType AvgSel)
{
    7540:	b086      	sub	sp, #24
    7542:	9003      	str	r0, [sp, #12]
    7544:	460b      	mov	r3, r1
    7546:	9201      	str	r2, [sp, #4]
    7548:	f88d 300b 	strb.w	r3, [sp, #11]
    /* Update AvgEn and AvgSel values found in SC3 register */
    uint32 Sc3Reg = Base->SC3;
    754c:	9b03      	ldr	r3, [sp, #12]
    754e:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
    7552:	9305      	str	r3, [sp, #20]
    Sc3Reg &= ~(ADC_SC3_AVGE_MASK | ADC_SC3_AVGS_MASK);
    7554:	9b05      	ldr	r3, [sp, #20]
    7556:	f023 0307 	bic.w	r3, r3, #7
    755a:	9305      	str	r3, [sp, #20]
    Sc3Reg |= ADC_SC3_AVGE(AvgEn ? 1u : 0u);
    755c:	f89d 300b 	ldrb.w	r3, [sp, #11]
    7560:	2b00      	cmp	r3, #0
    7562:	d001      	beq.n	7568 <Adc_HwAcc_SetAveraging+0x28>
    7564:	2304      	movs	r3, #4
    7566:	e000      	b.n	756a <Adc_HwAcc_SetAveraging+0x2a>
    7568:	2300      	movs	r3, #0
    756a:	9a05      	ldr	r2, [sp, #20]
    756c:	4313      	orrs	r3, r2
    756e:	9305      	str	r3, [sp, #20]
    Sc3Reg |= ADC_SC3_AVGS(AvgSel);
    7570:	9b01      	ldr	r3, [sp, #4]
    7572:	f003 0303 	and.w	r3, r3, #3
    7576:	9a05      	ldr	r2, [sp, #20]
    7578:	4313      	orrs	r3, r2
    757a:	9305      	str	r3, [sp, #20]
    Base->SC3 = Sc3Reg;
    757c:	9b03      	ldr	r3, [sp, #12]
    757e:	9a05      	ldr	r2, [sp, #20]
    7580:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
}
    7584:	bf00      	nop
    7586:	b006      	add	sp, #24
    7588:	4770      	bx	lr

0000758a <Adc_HwAcc_GetAverageSelect>:

static inline Adc_Ip_AvgSelectType Adc_HwAcc_GetAverageSelect(const uint32 Reg)
{
    758a:	b084      	sub	sp, #16
    758c:	9001      	str	r0, [sp, #4]
    /*
     * Retrieve AvgSelect value found in SC3 register
     * Note: Reg should be the value of SC3 register
     */
    Adc_Ip_AvgSelectType ReturnValue = ADC_IP_AVG_4_CONV;
    758e:	2300      	movs	r3, #0
    7590:	9303      	str	r3, [sp, #12]
    switch ((Reg & ADC_SC3_AVGS_MASK) >> ADC_SC3_AVGS_SHIFT)
    7592:	9b01      	ldr	r3, [sp, #4]
    7594:	f003 0303 	and.w	r3, r3, #3
    7598:	2b03      	cmp	r3, #3
    759a:	d00c      	beq.n	75b6 <Adc_HwAcc_GetAverageSelect+0x2c>
    759c:	2b03      	cmp	r3, #3
    759e:	d80d      	bhi.n	75bc <Adc_HwAcc_GetAverageSelect+0x32>
    75a0:	2b01      	cmp	r3, #1
    75a2:	d002      	beq.n	75aa <Adc_HwAcc_GetAverageSelect+0x20>
    75a4:	2b02      	cmp	r3, #2
    75a6:	d003      	beq.n	75b0 <Adc_HwAcc_GetAverageSelect+0x26>
        case 3u:
            ReturnValue = ADC_IP_AVG_32_CONV;
            break;
        default:
            ; /* no-op */
            break;
    75a8:	e008      	b.n	75bc <Adc_HwAcc_GetAverageSelect+0x32>
            ReturnValue = ADC_IP_AVG_8_CONV;
    75aa:	2301      	movs	r3, #1
    75ac:	9303      	str	r3, [sp, #12]
            break;
    75ae:	e006      	b.n	75be <Adc_HwAcc_GetAverageSelect+0x34>
            ReturnValue = ADC_IP_AVG_16_CONV;
    75b0:	2302      	movs	r3, #2
    75b2:	9303      	str	r3, [sp, #12]
            break;
    75b4:	e003      	b.n	75be <Adc_HwAcc_GetAverageSelect+0x34>
            ReturnValue = ADC_IP_AVG_32_CONV;
    75b6:	2303      	movs	r3, #3
    75b8:	9303      	str	r3, [sp, #12]
            break;
    75ba:	e000      	b.n	75be <Adc_HwAcc_GetAverageSelect+0x34>
            break;
    75bc:	bf00      	nop
    }
    return ReturnValue;
    75be:	9b03      	ldr	r3, [sp, #12]
}
    75c0:	4618      	mov	r0, r3
    75c2:	b004      	add	sp, #16
    75c4:	4770      	bx	lr

000075c6 <Adc_HwAcc_SetTriggerMode>:

static inline void Adc_HwAcc_SetTriggerMode(ADC_Type * const Base,
                                            const Adc_Ip_TrigType TriggerMode)
{
    75c6:	b084      	sub	sp, #16
    75c8:	9001      	str	r0, [sp, #4]
    75ca:	9100      	str	r1, [sp, #0]
    /* Update TriggerMode value found in SC2 register */
    uint32 Sc2Reg = Base->SC2;
    75cc:	9b01      	ldr	r3, [sp, #4]
    75ce:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
    75d2:	9303      	str	r3, [sp, #12]
    Sc2Reg &= ~(ADC_SC2_ADTRG_MASK);
    75d4:	9b03      	ldr	r3, [sp, #12]
    75d6:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    75da:	9303      	str	r3, [sp, #12]
    Sc2Reg |= ADC_SC2_ADTRG(TriggerMode);
    75dc:	9b00      	ldr	r3, [sp, #0]
    75de:	019b      	lsls	r3, r3, #6
    75e0:	f003 0340 	and.w	r3, r3, #64	; 0x40
    75e4:	9a03      	ldr	r2, [sp, #12]
    75e6:	4313      	orrs	r3, r2
    75e8:	9303      	str	r3, [sp, #12]
    Base->SC2 = Sc2Reg;
    75ea:	9b01      	ldr	r3, [sp, #4]
    75ec:	9a03      	ldr	r2, [sp, #12]
    75ee:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
}
    75f2:	bf00      	nop
    75f4:	b004      	add	sp, #16
    75f6:	4770      	bx	lr

000075f8 <Adc_HwAcc_GetTriggerMode>:

static inline Adc_Ip_TrigType Adc_HwAcc_GetTriggerMode(const uint32 Reg)
{
    75f8:	b084      	sub	sp, #16
    75fa:	9001      	str	r0, [sp, #4]
    /* Retrieve TriggerMode value found in SC2 register */
    Adc_Ip_TrigType ReturnValue = ADC_IP_TRIGGER_SOFTWARE;
    75fc:	2300      	movs	r3, #0
    75fe:	9303      	str	r3, [sp, #12]
    if (((Reg & ADC_SC2_ADTRG_MASK) >> ADC_SC2_ADTRG_SHIFT) == 1u)
    7600:	9b01      	ldr	r3, [sp, #4]
    7602:	f003 0340 	and.w	r3, r3, #64	; 0x40
    7606:	2b00      	cmp	r3, #0
    7608:	d001      	beq.n	760e <Adc_HwAcc_GetTriggerMode+0x16>
    {
        ReturnValue = ADC_IP_TRIGGER_HARDWARE;
    760a:	2301      	movs	r3, #1
    760c:	9303      	str	r3, [sp, #12]
    }
    return ReturnValue;
    760e:	9b03      	ldr	r3, [sp, #12]
}
    7610:	4618      	mov	r0, r3
    7612:	b004      	add	sp, #16
    7614:	4770      	bx	lr

00007616 <Adc_HwAcc_SetChannel>:

static inline void Adc_HwAcc_SetChannel(ADC_Type * const Base,
                                        const uint8 ChnIdx,
                                        const Adc_Ip_InputChannelType InputChannel,
                                        const boolean InterruptEnable)
{
    7616:	b086      	sub	sp, #24
    7618:	9003      	str	r0, [sp, #12]
    761a:	9201      	str	r2, [sp, #4]
    761c:	461a      	mov	r2, r3
    761e:	460b      	mov	r3, r1
    7620:	f88d 300b 	strb.w	r3, [sp, #11]
    7624:	4613      	mov	r3, r2
    7626:	f88d 300a 	strb.w	r3, [sp, #10]
    /* Configure channel by writing all SC1n register fields */
    uint32 Sc1Reg = SC1(Base, ChnIdx);
    762a:	f89d 200b 	ldrb.w	r2, [sp, #11]
    762e:	9b03      	ldr	r3, [sp, #12]
    7630:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    7634:	9305      	str	r3, [sp, #20]
    Sc1Reg &= ~(ADC_SC1_ADCH_MASK | ADC_SC1_AIEN_MASK);
    7636:	9b05      	ldr	r3, [sp, #20]
    7638:	f023 035f 	bic.w	r3, r3, #95	; 0x5f
    763c:	9305      	str	r3, [sp, #20]
    Sc1Reg |= ADC_SC1_ADCH(InputChannel);
    763e:	9b01      	ldr	r3, [sp, #4]
    7640:	f003 031f 	and.w	r3, r3, #31
    7644:	9a05      	ldr	r2, [sp, #20]
    7646:	4313      	orrs	r3, r2
    7648:	9305      	str	r3, [sp, #20]
    Sc1Reg |= ADC_SC1_AIEN(InterruptEnable ? 1u : 0u);
    764a:	f89d 300a 	ldrb.w	r3, [sp, #10]
    764e:	2b00      	cmp	r3, #0
    7650:	d001      	beq.n	7656 <Adc_HwAcc_SetChannel+0x40>
    7652:	2340      	movs	r3, #64	; 0x40
    7654:	e000      	b.n	7658 <Adc_HwAcc_SetChannel+0x42>
    7656:	2300      	movs	r3, #0
    7658:	9a05      	ldr	r2, [sp, #20]
    765a:	4313      	orrs	r3, r2
    765c:	9305      	str	r3, [sp, #20]
    SC1(Base, ChnIdx) = Sc1Reg;
    765e:	f89d 200b 	ldrb.w	r2, [sp, #11]
    7662:	9b03      	ldr	r3, [sp, #12]
    7664:	9905      	ldr	r1, [sp, #20]
    7666:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    766a:	bf00      	nop
    766c:	b006      	add	sp, #24
    766e:	4770      	bx	lr

00007670 <Adc_HwAcc_SetUserGainAndOffset>:

static inline void Adc_HwAcc_SetUserGainAndOffset(ADC_Type * const Base,
                                                  const uint16 UsrGain,
                                                  const uint16 UsrOffset)
{
    7670:	b082      	sub	sp, #8
    7672:	9001      	str	r0, [sp, #4]
    7674:	460b      	mov	r3, r1
    7676:	f8ad 3002 	strh.w	r3, [sp, #2]
    767a:	4613      	mov	r3, r2
    767c:	f8ad 3000 	strh.w	r3, [sp]
     * 2. RegVal <- Sum & 0xF800U
     * 3. if RegVal != 0x0000U then RegVal <- 0xFFFFU
     * 4. Base->G <- RegVal
     */

    Base->USR_OFS = ADC_USR_OFS_USR_OFS(UsrOffset);
    7680:	f8bd 3000 	ldrh.w	r3, [sp]
    7684:	b2da      	uxtb	r2, r3
    7686:	9b01      	ldr	r3, [sp, #4]
    7688:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
    Base->UG = ADC_UG_UG(UsrGain);
    768c:	f8bd 3002 	ldrh.w	r3, [sp, #2]
    7690:	f3c3 0209 	ubfx	r2, r3, #0, #10
    7694:	9b01      	ldr	r3, [sp, #4]
    7696:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
}
    769a:	bf00      	nop
    769c:	b002      	add	sp, #8
    769e:	4770      	bx	lr

000076a0 <Adc_HwAcc_GetAIEN>:

#if (ADC_IP_AIEN_INTERRUPT_ENABLE == STD_ON)
static inline boolean Adc_HwAcc_GetAIEN(const uint32 Reg)
{
    76a0:	b082      	sub	sp, #8
    76a2:	9001      	str	r0, [sp, #4]
    /* Retrive AIEN flag from given SC1 register */
    return (((Reg & ADC_SC1_AIEN_MASK) >> ADC_SC1_AIEN_SHIFT) != 0u) ? TRUE : FALSE;
    76a4:	9b01      	ldr	r3, [sp, #4]
    76a6:	099b      	lsrs	r3, r3, #6
    76a8:	f003 0301 	and.w	r3, r3, #1
    76ac:	2b00      	cmp	r3, #0
    76ae:	bf14      	ite	ne
    76b0:	2301      	movne	r3, #1
    76b2:	2300      	moveq	r3, #0
    76b4:	b2db      	uxtb	r3, r3
}
    76b6:	4618      	mov	r0, r3
    76b8:	b002      	add	sp, #8
    76ba:	4770      	bx	lr

000076bc <Adc_HwAcc_GetCOCO>:
#endif /* (ADC_IP_AIEN_INTERRUPT_ENABLE == STD_ON) */

static inline boolean Adc_HwAcc_GetCOCO(const uint32 Reg)
{
    76bc:	b082      	sub	sp, #8
    76be:	9001      	str	r0, [sp, #4]
    /* Retrive COCO flag from given SC1 register */
    return (((Reg & ADC_SC1_COCO_MASK) >> ADC_SC1_COCO_SHIFT) != 0u) ? TRUE : FALSE;
    76c0:	9b01      	ldr	r3, [sp, #4]
    76c2:	09db      	lsrs	r3, r3, #7
    76c4:	f003 0301 	and.w	r3, r3, #1
    76c8:	2b00      	cmp	r3, #0
    76ca:	bf14      	ite	ne
    76cc:	2301      	movne	r3, #1
    76ce:	2300      	moveq	r3, #0
    76d0:	b2db      	uxtb	r3, r3
}
    76d2:	4618      	mov	r0, r3
    76d4:	b002      	add	sp, #8
    76d6:	4770      	bx	lr

000076d8 <Adc_HwAcc_GetData>:

static inline uint16 Adc_HwAcc_GetData(const ADC_Type * const Base,
                                       const uint8 ChnIdx)
{
    76d8:	b084      	sub	sp, #16
    76da:	9001      	str	r0, [sp, #4]
    76dc:	460b      	mov	r3, r1
    76de:	f88d 3003 	strb.w	r3, [sp, #3]
    /* Retrieve the conversion result of a given channel */
    uint16 Result = (uint16) R(Base, ChnIdx);
    76e2:	f89d 2003 	ldrb.w	r2, [sp, #3]
    76e6:	9b01      	ldr	r3, [sp, #4]
    76e8:	3212      	adds	r2, #18
    76ea:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    76ee:	f8ad 300e 	strh.w	r3, [sp, #14]
    Result = (uint16) ((Result & ADC_R_D_MASK) >> ADC_R_D_SHIFT);
    76f2:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    76f6:	f3c3 030b 	ubfx	r3, r3, #0, #12
    76fa:	f8ad 300e 	strh.w	r3, [sp, #14]
    return Result;
    76fe:	f8bd 300e 	ldrh.w	r3, [sp, #14]
}
    7702:	4618      	mov	r0, r3
    7704:	b004      	add	sp, #16
    7706:	4770      	bx	lr

00007708 <ADC_DoCalibration_SetParams>:
*
* END**************************************************************************/
static inline void ADC_DoCalibration_SetParams(ADC_Type * const Base,
                                               const Adc_Ip_ClockConfigType * const Config,
                                               const Adc_Ip_TrigType TriggerMode)
{
    7708:	b500      	push	{lr}
    770a:	b085      	sub	sp, #20
    770c:	9003      	str	r0, [sp, #12]
    770e:	9102      	str	r1, [sp, #8]
    7710:	9201      	str	r2, [sp, #4]
    /* Configure averaging */
    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_29();
    7712:	f007 fdff 	bl	f314 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_29>
    Adc_HwAcc_SetAveraging(Base, Config->AvgEn, Config->AvgSel);
    7716:	9b02      	ldr	r3, [sp, #8]
    7718:	7a59      	ldrb	r1, [r3, #9]
    771a:	9b02      	ldr	r3, [sp, #8]
    771c:	68db      	ldr	r3, [r3, #12]
    771e:	461a      	mov	r2, r3
    7720:	9803      	ldr	r0, [sp, #12]
    7722:	f7ff ff0d 	bl	7540 <Adc_HwAcc_SetAveraging>
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_29();
    7726:	f007 fe21 	bl	f36c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_29>

    /* Configure trigger mode */
    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_24();
    772a:	f007 fc59 	bl	efe0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_24>
    Adc_HwAcc_SetTriggerMode(Base, TriggerMode);
    772e:	9901      	ldr	r1, [sp, #4]
    7730:	9803      	ldr	r0, [sp, #12]
    7732:	f7ff ff48 	bl	75c6 <Adc_HwAcc_SetTriggerMode>
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_24();
    7736:	f007 fc7f 	bl	f038 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_24>

    /* Configure sample time */
    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_15();
    773a:	f007 f96f 	bl	ea1c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_15>
    Adc_HwAcc_SetSampleTime(Base, Config->SampleTime);
    773e:	9b02      	ldr	r3, [sp, #8]
    7740:	7a1b      	ldrb	r3, [r3, #8]
    7742:	4619      	mov	r1, r3
    7744:	9803      	ldr	r0, [sp, #12]
    7746:	f7ff feda 	bl	74fe <Adc_HwAcc_SetSampleTime>
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_15();
    774a:	f007 f993 	bl	ea74 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_15>

    /* Configure input clock */
    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_13();
    774e:	f007 f8c1 	bl	e8d4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_13>
    Adc_HwAcc_SetClock(Base, Config->ClockDivide, Config->InputClock);
    7752:	9b02      	ldr	r3, [sp, #8]
    7754:	6819      	ldr	r1, [r3, #0]
    7756:	9b02      	ldr	r3, [sp, #8]
    7758:	685b      	ldr	r3, [r3, #4]
    775a:	461a      	mov	r2, r3
    775c:	9803      	ldr	r0, [sp, #12]
    775e:	f7ff fe73 	bl	7448 <Adc_HwAcc_SetClock>
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_13();
    7762:	f007 f8e3 	bl	e92c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_13>
}
    7766:	bf00      	nop
    7768:	b005      	add	sp, #20
    776a:	f85d fb04 	ldr.w	pc, [sp], #4

0000776e <Adc_Ip_Init>:
*
* @implements     Adc_Ip_Init_Activity
* END**************************************************************************/
void Adc_Ip_Init(const uint32 Instance,
                 const Adc_Ip_ConfigType * const Config)
{
    776e:	b500      	push	{lr}
    7770:	b087      	sub	sp, #28
    7772:	9001      	str	r0, [sp, #4]
    7774:	9100      	str	r1, [sp, #0]
    DevAssert(Instance < ADC_INSTANCE_COUNT);
    DevAssert(Config != NULL_PTR);
    DevAssert(Config->NumChannels <= ADC_MAX_CHAN_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7776:	4a67      	ldr	r2, [pc, #412]	; (7914 <Adc_Ip_Init+0x1a6>)
    7778:	9b01      	ldr	r3, [sp, #4]
    777a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    777e:	9302      	str	r3, [sp, #8]
    uint32 SC2Reg = 0u;
    7780:	2300      	movs	r3, #0
    7782:	9305      	str	r3, [sp, #20]
    uint32 SC2ClearMask = 0u;
    7784:	2300      	movs	r3, #0
    7786:	9304      	str	r3, [sp, #16]
    uint8 Index;

    Adc_HwAcc_SetClock(Base, Config->ClockDivide, Config->InputClock);
    7788:	9b00      	ldr	r3, [sp, #0]
    778a:	6819      	ldr	r1, [r3, #0]
    778c:	9b00      	ldr	r3, [sp, #0]
    778e:	689b      	ldr	r3, [r3, #8]
    7790:	461a      	mov	r2, r3
    7792:	9802      	ldr	r0, [sp, #8]
    7794:	f7ff fe58 	bl	7448 <Adc_HwAcc_SetClock>
    Adc_HwAcc_SetSampleTime(Base, Config->SampleTime);
    7798:	9b00      	ldr	r3, [sp, #0]
    779a:	7b1b      	ldrb	r3, [r3, #12]
    779c:	4619      	mov	r1, r3
    779e:	9802      	ldr	r0, [sp, #8]
    77a0:	f7ff fead 	bl	74fe <Adc_HwAcc_SetSampleTime>
    Adc_HwAcc_SetAveraging(Base, Config->AvgEn, Config->AvgSel);
    77a4:	9b00      	ldr	r3, [sp, #0]
    77a6:	7b59      	ldrb	r1, [r3, #13]
    77a8:	9b00      	ldr	r3, [sp, #0]
    77aa:	691b      	ldr	r3, [r3, #16]
    77ac:	461a      	mov	r2, r3
    77ae:	9802      	ldr	r0, [sp, #8]
    77b0:	f7ff fec6 	bl	7540 <Adc_HwAcc_SetAveraging>

    Adc_Ip_SetResolution(Instance, Config->Resolution);
    77b4:	9b00      	ldr	r3, [sp, #0]
    77b6:	695b      	ldr	r3, [r3, #20]
    77b8:	4619      	mov	r1, r3
    77ba:	9801      	ldr	r0, [sp, #4]
    77bc:	f000 f9ea 	bl	7b94 <Adc_Ip_SetResolution>
        ADC_SetSupplyMonitoringEnable(Config->SupplyMonitoringEnable);
    }
#endif /* (ADC_IP_SUPPLY_MONITORING_ENABLED == STD_ON) */

    /* Configure trigger mode */
    SC2ClearMask |= ADC_SC2_ADTRG_MASK;
    77c0:	9b04      	ldr	r3, [sp, #16]
    77c2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    77c6:	9304      	str	r3, [sp, #16]
    SC2Reg |= ADC_SC2_ADTRG(Config->TriggerMode);
    77c8:	9b00      	ldr	r3, [sp, #0]
    77ca:	699b      	ldr	r3, [r3, #24]
    77cc:	019b      	lsls	r3, r3, #6
    77ce:	f003 0340 	and.w	r3, r3, #64	; 0x40
    77d2:	9a05      	ldr	r2, [sp, #20]
    77d4:	4313      	orrs	r3, r2
    77d6:	9305      	str	r3, [sp, #20]

    /* Configure DMA enable */
    if (Config->DmaEnable)
    77d8:	9b00      	ldr	r3, [sp, #0]
    77da:	7f1b      	ldrb	r3, [r3, #28]
    77dc:	2b00      	cmp	r3, #0
    77de:	d004      	beq.n	77ea <Adc_Ip_Init+0x7c>
    {
        SC2Reg |= ADC_SC2_DMAEN_MASK;
    77e0:	9b05      	ldr	r3, [sp, #20]
    77e2:	f043 0304 	orr.w	r3, r3, #4
    77e6:	9305      	str	r3, [sp, #20]
    77e8:	e003      	b.n	77f2 <Adc_Ip_Init+0x84>
    }
    else
    {
        SC2ClearMask |= ADC_SC2_DMAEN_MASK;
    77ea:	9b04      	ldr	r3, [sp, #16]
    77ec:	f043 0304 	orr.w	r3, r3, #4
    77f0:	9304      	str	r3, [sp, #16]
    }

    /* Configure voltage reference selector */
    SC2ClearMask |= ADC_SC2_REFSEL_MASK;
    77f2:	9b04      	ldr	r3, [sp, #16]
    77f4:	f043 0303 	orr.w	r3, r3, #3
    77f8:	9304      	str	r3, [sp, #16]
    SC2Reg |= ADC_SC2_REFSEL(Config->VoltageRef);
    77fa:	9b00      	ldr	r3, [sp, #0]
    77fc:	6a1b      	ldr	r3, [r3, #32]
    77fe:	f003 0303 	and.w	r3, r3, #3
    7802:	9a05      	ldr	r2, [sp, #20]
    7804:	4313      	orrs	r3, r2
    7806:	9305      	str	r3, [sp, #20]

    /* Configure compare enables and values */
    SC2ClearMask |= ADC_SC2_ACFE_MASK | ADC_SC2_ACFGT_MASK | ADC_SC2_ACREN_MASK;
    7808:	9b04      	ldr	r3, [sp, #16]
    780a:	f043 0338 	orr.w	r3, r3, #56	; 0x38
    780e:	9304      	str	r3, [sp, #16]
    SC2Reg |= ADC_SC2_ACFE(Config->CompareEnable ? 1u : 0u);
    7810:	9b00      	ldr	r3, [sp, #0]
    7812:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
    7816:	2b00      	cmp	r3, #0
    7818:	d001      	beq.n	781e <Adc_Ip_Init+0xb0>
    781a:	2320      	movs	r3, #32
    781c:	e000      	b.n	7820 <Adc_Ip_Init+0xb2>
    781e:	2300      	movs	r3, #0
    7820:	9a05      	ldr	r2, [sp, #20]
    7822:	4313      	orrs	r3, r2
    7824:	9305      	str	r3, [sp, #20]
    SC2Reg |= ADC_SC2_ACFGT(Config->CompareGreaterThanEnable ? 1u : 0u);
    7826:	9b00      	ldr	r3, [sp, #0]
    7828:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
    782c:	2b00      	cmp	r3, #0
    782e:	d001      	beq.n	7834 <Adc_Ip_Init+0xc6>
    7830:	2310      	movs	r3, #16
    7832:	e000      	b.n	7836 <Adc_Ip_Init+0xc8>
    7834:	2300      	movs	r3, #0
    7836:	9a05      	ldr	r2, [sp, #20]
    7838:	4313      	orrs	r3, r2
    783a:	9305      	str	r3, [sp, #20]
    SC2Reg |= ADC_SC2_ACREN(Config->CompareRangeFuncEnable ? 1u : 0u);
    783c:	9b00      	ldr	r3, [sp, #0]
    783e:	f893 3027 	ldrb.w	r3, [r3, #39]	; 0x27
    7842:	2b00      	cmp	r3, #0
    7844:	d001      	beq.n	784a <Adc_Ip_Init+0xdc>
    7846:	2308      	movs	r3, #8
    7848:	e000      	b.n	784c <Adc_Ip_Init+0xde>
    784a:	2300      	movs	r3, #0
    784c:	9a05      	ldr	r2, [sp, #20]
    784e:	4313      	orrs	r3, r2
    7850:	9305      	str	r3, [sp, #20]
    Base->CV[0u] = ADC_CV_CV(Config->CompVal1);
    7852:	9b00      	ldr	r3, [sp, #0]
    7854:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
    7856:	461a      	mov	r2, r3
    7858:	9b02      	ldr	r3, [sp, #8]
    785a:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    Base->CV[1u] = ADC_CV_CV(Config->CompVal2);
    785e:	9b00      	ldr	r3, [sp, #0]
    7860:	8d5b      	ldrh	r3, [r3, #42]	; 0x2a
    7862:	461a      	mov	r2, r3
    7864:	9b02      	ldr	r3, [sp, #8]
    7866:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c

    Adc_HwAcc_SetSC2Reg(Base, SC2ClearMask, SC2Reg);
    786a:	9a05      	ldr	r2, [sp, #20]
    786c:	9904      	ldr	r1, [sp, #16]
    786e:	9802      	ldr	r0, [sp, #8]
    7870:	f7ff fdd2 	bl	7418 <Adc_HwAcc_SetSC2Reg>

    Adc_HwAcc_SetUserGainAndOffset(Base, Config->UsrGain, Config->UsrOffset);
    7874:	9b00      	ldr	r3, [sp, #0]
    7876:	8d99      	ldrh	r1, [r3, #44]	; 0x2c
    7878:	9b00      	ldr	r3, [sp, #0]
    787a:	8ddb      	ldrh	r3, [r3, #46]	; 0x2e
    787c:	461a      	mov	r2, r3
    787e:	9802      	ldr	r0, [sp, #8]
    7880:	f7ff fef6 	bl	7670 <Adc_HwAcc_SetUserGainAndOffset>

    Adc_Ip_SetContinuousMode(Instance, Config->ContinuousConvEnable);
    7884:	9b00      	ldr	r3, [sp, #0]
    7886:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
    788a:	4619      	mov	r1, r3
    788c:	9801      	ldr	r0, [sp, #4]
    788e:	f000 f955 	bl	7b3c <Adc_Ip_SetContinuousMode>

    if (Config->ChannelConfigs != NULL_PTR)
    7892:	9b00      	ldr	r3, [sp, #0]
    7894:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    7896:	2b00      	cmp	r3, #0
    7898:	d01c      	beq.n	78d4 <Adc_Ip_Init+0x166>
    {
        for (Index = 0u; Index < Config->NumChannels; Index++)
    789a:	2300      	movs	r3, #0
    789c:	f88d 300f 	strb.w	r3, [sp, #15]
    78a0:	e011      	b.n	78c6 <Adc_Ip_Init+0x158>
        {
            Adc_Ip_ConfigChannel(Instance, &(Config->ChannelConfigs[Index]));
    78a2:	9b00      	ldr	r3, [sp, #0]
    78a4:	6b59      	ldr	r1, [r3, #52]	; 0x34
    78a6:	f89d 200f 	ldrb.w	r2, [sp, #15]
    78aa:	4613      	mov	r3, r2
    78ac:	005b      	lsls	r3, r3, #1
    78ae:	4413      	add	r3, r2
    78b0:	009b      	lsls	r3, r3, #2
    78b2:	440b      	add	r3, r1
    78b4:	4619      	mov	r1, r3
    78b6:	9801      	ldr	r0, [sp, #4]
    78b8:	f000 f9c2 	bl	7c40 <Adc_Ip_ConfigChannel>
        for (Index = 0u; Index < Config->NumChannels; Index++)
    78bc:	f89d 300f 	ldrb.w	r3, [sp, #15]
    78c0:	3301      	adds	r3, #1
    78c2:	f88d 300f 	strb.w	r3, [sp, #15]
    78c6:	9b00      	ldr	r3, [sp, #0]
    78c8:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
    78cc:	f89d 200f 	ldrb.w	r2, [sp, #15]
    78d0:	429a      	cmp	r2, r3
    78d2:	d3e6      	bcc.n	78a2 <Adc_Ip_Init+0x134>
        }
    }

#if (ADC_IP_AIEN_INTERRUPT_ENABLE == STD_ON)
    Adc_Ip_axState[Instance].ConversionCompleteNotification = Config->ConversionCompleteNotification;
    78d4:	9b00      	ldr	r3, [sp, #0]
    78d6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    78d8:	490f      	ldr	r1, [pc, #60]	; (7918 <Adc_Ip_Init+0x1aa>)
    78da:	9b01      	ldr	r3, [sp, #4]
    78dc:	204c      	movs	r0, #76	; 0x4c
    78de:	fb00 f303 	mul.w	r3, r0, r3
    78e2:	440b      	add	r3, r1
    78e4:	3308      	adds	r3, #8
    78e6:	601a      	str	r2, [r3, #0]
#endif /* (ADC_IP_AIEN_INTERRUPT_ENABLE == STD_ON) */
    Adc_Ip_axState[Instance].CalibrationClockDivide = Config->CalibrationClockDivide;
    78e8:	9b00      	ldr	r3, [sp, #0]
    78ea:	685a      	ldr	r2, [r3, #4]
    78ec:	490a      	ldr	r1, [pc, #40]	; (7918 <Adc_Ip_Init+0x1aa>)
    78ee:	9b01      	ldr	r3, [sp, #4]
    78f0:	204c      	movs	r0, #76	; 0x4c
    78f2:	fb00 f303 	mul.w	r3, r0, r3
    78f6:	440b      	add	r3, r1
    78f8:	3304      	adds	r3, #4
    78fa:	601a      	str	r2, [r3, #0]
    Adc_Ip_axState[Instance].Init = TRUE;
    78fc:	4a06      	ldr	r2, [pc, #24]	; (7918 <Adc_Ip_Init+0x1aa>)
    78fe:	9b01      	ldr	r3, [sp, #4]
    7900:	214c      	movs	r1, #76	; 0x4c
    7902:	fb01 f303 	mul.w	r3, r1, r3
    7906:	4413      	add	r3, r2
    7908:	2201      	movs	r2, #1
    790a:	701a      	strb	r2, [r3, #0]
#if (ADC_IP_ENABLE_SIM_SOURCE_SELECTION == STD_ON)
    Adc_Ip_axState[Instance].PretriggerSel = Config->PretriggerSel;
#endif /* (ADC_IP_ENABLE_SIM_SOURCE_SELECTION == STD_ON) */
}
    790c:	bf00      	nop
    790e:	b007      	add	sp, #28
    7910:	f85d fb04 	ldr.w	pc, [sp], #4
    7914:	00015be0 	.word	0x00015be0
    7918:	1fff8d00 	.word	0x1fff8d00

0000791c <Adc_Ip_DeInit>:
* Description   : This function resets the ADC internal registers to default values.
*
* @implements     Adc_Ip_Deinit_Activity
* END**************************************************************************/
void Adc_Ip_DeInit(const uint32 Instance)
{
    791c:	b500      	push	{lr}
    791e:	b0c3      	sub	sp, #268	; 0x10c
    7920:	ab42      	add	r3, sp, #264	; 0x108
    7922:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
    7926:	6018      	str	r0, [r3, #0]

    Adc_Ip_ConfigType DefaultConfig;
    Adc_Ip_ChanConfigType ChannelConfigs[ADC_MAX_CHAN_COUNT];
    uint8 Index;

    DefaultConfig.ClockDivide = ADC_IP_CLK_FULL_BUS;
    7928:	2300      	movs	r3, #0
    792a:	9332      	str	r3, [sp, #200]	; 0xc8
    DefaultConfig.CalibrationClockDivide = ADC_IP_CLK_EIGHTH_BUS;
    792c:	2303      	movs	r3, #3
    792e:	9333      	str	r3, [sp, #204]	; 0xcc
    DefaultConfig.InputClock = ADC_IP_CLK_ALT_1;
    7930:	2300      	movs	r3, #0
    7932:	9334      	str	r3, [sp, #208]	; 0xd0
    DefaultConfig.SampleTime = ADC_IP_DEFAULT_SAMPLE_TIME;
    7934:	230c      	movs	r3, #12
    7936:	f88d 30d4 	strb.w	r3, [sp, #212]	; 0xd4
    DefaultConfig.AvgEn = FALSE;
    793a:	2300      	movs	r3, #0
    793c:	f88d 30d5 	strb.w	r3, [sp, #213]	; 0xd5
    DefaultConfig.AvgSel = ADC_IP_AVG_4_CONV;
    7940:	2300      	movs	r3, #0
    7942:	9336      	str	r3, [sp, #216]	; 0xd8
    DefaultConfig.Resolution = ADC_IP_RESOLUTION_8BIT;
    7944:	2300      	movs	r3, #0
    7946:	9337      	str	r3, [sp, #220]	; 0xdc
    DefaultConfig.TriggerMode = ADC_IP_TRIGGER_SOFTWARE;
    7948:	2300      	movs	r3, #0
    794a:	9338      	str	r3, [sp, #224]	; 0xe0
#if (ADC_IP_ENABLE_SIM_SOURCE_SELECTION == STD_ON)
    DefaultConfig.PretriggerSel = ADC_IP_PRETRIGGER_SEL_PDB;
    DefaultConfig.TriggerSel = ADC_IP_TRIGGER_SEL_PDB;
#endif /* (ADC_IP_ENABLE_SIM_SOURCE_SELECTION == STD_ON) */
    DefaultConfig.DmaEnable = FALSE;
    794c:	2300      	movs	r3, #0
    794e:	f88d 30e4 	strb.w	r3, [sp, #228]	; 0xe4
    DefaultConfig.VoltageRef = ADC_IP_VOLTAGEREF_VREF;
    7952:	2300      	movs	r3, #0
    7954:	933a      	str	r3, [sp, #232]	; 0xe8
    DefaultConfig.ContinuousConvEnable = FALSE;
    7956:	2300      	movs	r3, #0
    7958:	f88d 30ec 	strb.w	r3, [sp, #236]	; 0xec
#if (ADC_IP_SUPPLY_MONITORING_ENABLED == STD_ON)
    DefaultConfig.SupplyMonitoringEnable = FALSE;
#endif /* (ADC_IP_SUPPLY_MONITORING_ENABLED == STD_ON) */
    DefaultConfig.CompareEnable = FALSE;
    795c:	2300      	movs	r3, #0
    795e:	f88d 30ed 	strb.w	r3, [sp, #237]	; 0xed
    DefaultConfig.CompareGreaterThanEnable = FALSE;
    7962:	2300      	movs	r3, #0
    7964:	f88d 30ee 	strb.w	r3, [sp, #238]	; 0xee
    DefaultConfig.CompareRangeFuncEnable = FALSE;
    7968:	2300      	movs	r3, #0
    796a:	f88d 30ef 	strb.w	r3, [sp, #239]	; 0xef
    DefaultConfig.CompVal1 = 0u;
    796e:	2300      	movs	r3, #0
    7970:	f8ad 30f0 	strh.w	r3, [sp, #240]	; 0xf0
    DefaultConfig.CompVal2 = 0u;
    7974:	2300      	movs	r3, #0
    7976:	f8ad 30f2 	strh.w	r3, [sp, #242]	; 0xf2
    DefaultConfig.UsrGain = ADC_IP_DEFAULT_USER_GAIN;
    797a:	2304      	movs	r3, #4
    797c:	f8ad 30f4 	strh.w	r3, [sp, #244]	; 0xf4
    DefaultConfig.UsrOffset = 0u;
    7980:	2300      	movs	r3, #0
    7982:	f8ad 30f6 	strh.w	r3, [sp, #246]	; 0xf6
    DefaultConfig.NumChannels = ADC_MAX_CHAN_COUNT;
    7986:	2310      	movs	r3, #16
    7988:	f88d 30f8 	strb.w	r3, [sp, #248]	; 0xf8
    for (Index = 0u; Index < ADC_MAX_CHAN_COUNT; Index++)
    798c:	2300      	movs	r3, #0
    798e:	f88d 3107 	strb.w	r3, [sp, #263]	; 0x107
    7992:	e02b      	b.n	79ec <Adc_Ip_DeInit+0xd0>
    {
        ChannelConfigs[Index].ChnIdx = Index;
    7994:	f89d 2107 	ldrb.w	r2, [sp, #263]	; 0x107
    7998:	ab42      	add	r3, sp, #264	; 0x108
    799a:	f5a3 7180 	sub.w	r1, r3, #256	; 0x100
    799e:	4613      	mov	r3, r2
    79a0:	005b      	lsls	r3, r3, #1
    79a2:	4413      	add	r3, r2
    79a4:	009b      	lsls	r3, r3, #2
    79a6:	440b      	add	r3, r1
    79a8:	f89d 2107 	ldrb.w	r2, [sp, #263]	; 0x107
    79ac:	701a      	strb	r2, [r3, #0]
        ChannelConfigs[Index].Channel = ADC_IP_INPUTCHAN_DISABLED;
    79ae:	f89d 2107 	ldrb.w	r2, [sp, #263]	; 0x107
    79b2:	ab42      	add	r3, sp, #264	; 0x108
    79b4:	f5a3 7180 	sub.w	r1, r3, #256	; 0x100
    79b8:	4613      	mov	r3, r2
    79ba:	005b      	lsls	r3, r3, #1
    79bc:	4413      	add	r3, r2
    79be:	009b      	lsls	r3, r3, #2
    79c0:	440b      	add	r3, r1
    79c2:	3304      	adds	r3, #4
    79c4:	221f      	movs	r2, #31
    79c6:	601a      	str	r2, [r3, #0]
#if (ADC_IP_AIEN_INTERRUPT_ENABLE == STD_ON)
        ChannelConfigs[Index].InterruptEnable = FALSE;
    79c8:	f89d 2107 	ldrb.w	r2, [sp, #263]	; 0x107
    79cc:	ab42      	add	r3, sp, #264	; 0x108
    79ce:	f5a3 7180 	sub.w	r1, r3, #256	; 0x100
    79d2:	4613      	mov	r3, r2
    79d4:	005b      	lsls	r3, r3, #1
    79d6:	4413      	add	r3, r2
    79d8:	009b      	lsls	r3, r3, #2
    79da:	440b      	add	r3, r1
    79dc:	3308      	adds	r3, #8
    79de:	2200      	movs	r2, #0
    79e0:	701a      	strb	r2, [r3, #0]
    for (Index = 0u; Index < ADC_MAX_CHAN_COUNT; Index++)
    79e2:	f89d 3107 	ldrb.w	r3, [sp, #263]	; 0x107
    79e6:	3301      	adds	r3, #1
    79e8:	f88d 3107 	strb.w	r3, [sp, #263]	; 0x107
    79ec:	f89d 3107 	ldrb.w	r3, [sp, #263]	; 0x107
    79f0:	2b0f      	cmp	r3, #15
    79f2:	d9cf      	bls.n	7994 <Adc_Ip_DeInit+0x78>
#endif /* (ADC_IP_AIEN_INTERRUPT_ENABLE == STD_ON) */
    }
    DefaultConfig.ChannelConfigs = ChannelConfigs;
    79f4:	ab02      	add	r3, sp, #8
    79f6:	933f      	str	r3, [sp, #252]	; 0xfc
#if (ADC_IP_AIEN_INTERRUPT_ENABLE == STD_ON)
    DefaultConfig.ConversionCompleteNotification = NULL_PTR;
    79f8:	2300      	movs	r3, #0
    79fa:	9340      	str	r3, [sp, #256]	; 0x100
#endif /* (ADC_IP_AIEN_INTERRUPT_ENABLE == STD_ON) */

    Adc_Ip_Init(Instance, &DefaultConfig);
    79fc:	aa32      	add	r2, sp, #200	; 0xc8
    79fe:	ab42      	add	r3, sp, #264	; 0x108
    7a00:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
    7a04:	4611      	mov	r1, r2
    7a06:	6818      	ldr	r0, [r3, #0]
    7a08:	f7ff feb1 	bl	776e <Adc_Ip_Init>
    {
        ADC_ResetSupplyMonitoringChannel();
    }
#endif /* (ADC_IP_SUPPLY_MONITORING_ENABLED == STD_ON) */

    Adc_Ip_axState[Instance].Init = FALSE;
    7a0c:	4a07      	ldr	r2, [pc, #28]	; (7a2c <Adc_Ip_DeInit+0x110>)
    7a0e:	ab42      	add	r3, sp, #264	; 0x108
    7a10:	f5a3 7382 	sub.w	r3, r3, #260	; 0x104
    7a14:	681b      	ldr	r3, [r3, #0]
    7a16:	214c      	movs	r1, #76	; 0x4c
    7a18:	fb01 f303 	mul.w	r3, r1, r3
    7a1c:	4413      	add	r3, r2
    7a1e:	2200      	movs	r2, #0
    7a20:	701a      	strb	r2, [r3, #0]
}
    7a22:	bf00      	nop
    7a24:	b043      	add	sp, #268	; 0x10c
    7a26:	f85d fb04 	ldr.w	pc, [sp], #4
    7a2a:	bf00      	nop
    7a2c:	1fff8d00 	.word	0x1fff8d00

00007a30 <Adc_Ip_SetAveraging>:
* @implements     Adc_Ip_SetAveraging_Activity
* END**************************************************************************/
void Adc_Ip_SetAveraging(const uint32 Instance,
                         const boolean AvgEn,
                         const Adc_Ip_AvgSelectType AvgSel)
{
    7a30:	b500      	push	{lr}
    7a32:	b087      	sub	sp, #28
    7a34:	9003      	str	r0, [sp, #12]
    7a36:	460b      	mov	r3, r1
    7a38:	9201      	str	r2, [sp, #4]
    7a3a:	f88d 300b 	strb.w	r3, [sp, #11]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7a3e:	4a0a      	ldr	r2, [pc, #40]	; (7a68 <Adc_Ip_SetAveraging+0x38>)
    7a40:	9b03      	ldr	r3, [sp, #12]
    7a42:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7a46:	9305      	str	r3, [sp, #20]

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_27();
    7a48:	f007 fbc0 	bl	f1cc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_27>
    Adc_HwAcc_SetAveraging(Base, AvgEn, AvgSel);
    7a4c:	f89d 300b 	ldrb.w	r3, [sp, #11]
    7a50:	9a01      	ldr	r2, [sp, #4]
    7a52:	4619      	mov	r1, r3
    7a54:	9805      	ldr	r0, [sp, #20]
    7a56:	f7ff fd73 	bl	7540 <Adc_HwAcc_SetAveraging>
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_27();
    7a5a:	f007 fbe3 	bl	f224 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_27>
}
    7a5e:	bf00      	nop
    7a60:	b007      	add	sp, #28
    7a62:	f85d fb04 	ldr.w	pc, [sp], #4
    7a66:	bf00      	nop
    7a68:	00015be0 	.word	0x00015be0

00007a6c <Adc_Ip_SetSampleTime>:
*
* @implements     Adc_Ip_SetSampleTime_Activity
* END**************************************************************************/
void Adc_Ip_SetSampleTime(const uint32 Instance,
                          const uint8 SampleTime)
{
    7a6c:	b500      	push	{lr}
    7a6e:	b085      	sub	sp, #20
    7a70:	9001      	str	r0, [sp, #4]
    7a72:	460b      	mov	r3, r1
    7a74:	f88d 3003 	strb.w	r3, [sp, #3]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7a78:	4a09      	ldr	r2, [pc, #36]	; (7aa0 <Adc_Ip_SetSampleTime+0x34>)
    7a7a:	9b01      	ldr	r3, [sp, #4]
    7a7c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7a80:	9303      	str	r3, [sp, #12]

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_16();
    7a82:	f007 f81d 	bl	eac0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_16>
    Adc_HwAcc_SetSampleTime(Base, SampleTime);
    7a86:	f89d 3003 	ldrb.w	r3, [sp, #3]
    7a8a:	4619      	mov	r1, r3
    7a8c:	9803      	ldr	r0, [sp, #12]
    7a8e:	f7ff fd36 	bl	74fe <Adc_HwAcc_SetSampleTime>
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_16();
    7a92:	f007 f841 	bl	eb18 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_16>
}
    7a96:	bf00      	nop
    7a98:	b005      	add	sp, #20
    7a9a:	f85d fb04 	ldr.w	pc, [sp], #4
    7a9e:	bf00      	nop
    7aa0:	00015be0 	.word	0x00015be0

00007aa4 <Adc_Ip_EnableDma>:
* Description   : This function enables DMA.
*
* @implements     Adc_Ip_EnableDma_Activity
* END**************************************************************************/
void Adc_Ip_EnableDma(const uint32 Instance)
{
    7aa4:	b500      	push	{lr}
    7aa6:	b085      	sub	sp, #20
    7aa8:	9001      	str	r0, [sp, #4]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7aaa:	4a0a      	ldr	r2, [pc, #40]	; (7ad4 <Adc_Ip_EnableDma+0x30>)
    7aac:	9b01      	ldr	r3, [sp, #4]
    7aae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7ab2:	9303      	str	r3, [sp, #12]

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_26();
    7ab4:	f007 fb38 	bl	f128 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_26>
    Base->SC2 |= ADC_SC2_DMAEN_MASK;
    7ab8:	9b03      	ldr	r3, [sp, #12]
    7aba:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
    7abe:	f043 0204 	orr.w	r2, r3, #4
    7ac2:	9b03      	ldr	r3, [sp, #12]
    7ac4:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_26();
    7ac8:	f007 fb5a 	bl	f180 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_26>
}
    7acc:	bf00      	nop
    7ace:	b005      	add	sp, #20
    7ad0:	f85d fb04 	ldr.w	pc, [sp], #4
    7ad4:	00015be0 	.word	0x00015be0

00007ad8 <Adc_Ip_DisableDma>:
* Description   : This function disables DMA.
*
* @implements     Adc_Ip_DisableDma_Activity
* END**************************************************************************/
void Adc_Ip_DisableDma(const uint32 Instance)
{
    7ad8:	b500      	push	{lr}
    7ada:	b085      	sub	sp, #20
    7adc:	9001      	str	r0, [sp, #4]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7ade:	4a0a      	ldr	r2, [pc, #40]	; (7b08 <Adc_Ip_DisableDma+0x30>)
    7ae0:	9b01      	ldr	r3, [sp, #4]
    7ae2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7ae6:	9303      	str	r3, [sp, #12]

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_22();
    7ae8:	f007 f9d6 	bl	ee98 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_22>
    Base->SC2 &= ~(ADC_SC2_DMAEN_MASK);
    7aec:	9b03      	ldr	r3, [sp, #12]
    7aee:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
    7af2:	f023 0204 	bic.w	r2, r3, #4
    7af6:	9b03      	ldr	r3, [sp, #12]
    7af8:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_22();
    7afc:	f007 f9f8 	bl	eef0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_22>
}
    7b00:	bf00      	nop
    7b02:	b005      	add	sp, #20
    7b04:	f85d fb04 	ldr.w	pc, [sp], #4
    7b08:	00015be0 	.word	0x00015be0

00007b0c <Adc_Ip_SetTriggerMode>:
*
* @implements     Adc_Ip_SetTriggerMode_Activity
* END**************************************************************************/
void Adc_Ip_SetTriggerMode(const uint32 Instance,
                           const Adc_Ip_TrigType TriggerMode)
{
    7b0c:	b500      	push	{lr}
    7b0e:	b085      	sub	sp, #20
    7b10:	9001      	str	r0, [sp, #4]
    7b12:	9100      	str	r1, [sp, #0]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7b14:	4a08      	ldr	r2, [pc, #32]	; (7b38 <Adc_Ip_SetTriggerMode+0x2c>)
    7b16:	9b01      	ldr	r3, [sp, #4]
    7b18:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7b1c:	9303      	str	r3, [sp, #12]

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_23();
    7b1e:	f007 fa0d 	bl	ef3c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_23>
    Adc_HwAcc_SetTriggerMode(Base, TriggerMode);
    7b22:	9900      	ldr	r1, [sp, #0]
    7b24:	9803      	ldr	r0, [sp, #12]
    7b26:	f7ff fd4e 	bl	75c6 <Adc_HwAcc_SetTriggerMode>
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_23();
    7b2a:	f007 fa33 	bl	ef94 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_23>
}
    7b2e:	bf00      	nop
    7b30:	b005      	add	sp, #20
    7b32:	f85d fb04 	ldr.w	pc, [sp], #4
    7b36:	bf00      	nop
    7b38:	00015be0 	.word	0x00015be0

00007b3c <Adc_Ip_SetContinuousMode>:
*
* @implements     Adc_Ip_SetContinuousMode_Activity
* END**************************************************************************/
void Adc_Ip_SetContinuousMode(const uint32 Instance,
                              const boolean ContinuousModeEnable)
{
    7b3c:	b500      	push	{lr}
    7b3e:	b085      	sub	sp, #20
    7b40:	9001      	str	r0, [sp, #4]
    7b42:	460b      	mov	r3, r1
    7b44:	f88d 3003 	strb.w	r3, [sp, #3]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7b48:	4a11      	ldr	r2, [pc, #68]	; (7b90 <Adc_Ip_SetContinuousMode+0x54>)
    7b4a:	9b01      	ldr	r3, [sp, #4]
    7b4c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7b50:	9303      	str	r3, [sp, #12]

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_30();
    7b52:	f007 fc31 	bl	f3b8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_30>
    uint32 Sc3Reg = Base->SC3;
    7b56:	9b03      	ldr	r3, [sp, #12]
    7b58:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
    7b5c:	9302      	str	r3, [sp, #8]
    Sc3Reg &= ~(ADC_SC3_ADCO_MASK);
    7b5e:	9b02      	ldr	r3, [sp, #8]
    7b60:	f023 0308 	bic.w	r3, r3, #8
    7b64:	9302      	str	r3, [sp, #8]
    Sc3Reg |= ADC_SC3_ADCO(ContinuousModeEnable ? 1u : 0u);
    7b66:	f89d 3003 	ldrb.w	r3, [sp, #3]
    7b6a:	2b00      	cmp	r3, #0
    7b6c:	d001      	beq.n	7b72 <Adc_Ip_SetContinuousMode+0x36>
    7b6e:	2308      	movs	r3, #8
    7b70:	e000      	b.n	7b74 <Adc_Ip_SetContinuousMode+0x38>
    7b72:	2300      	movs	r3, #0
    7b74:	9a02      	ldr	r2, [sp, #8]
    7b76:	4313      	orrs	r3, r2
    7b78:	9302      	str	r3, [sp, #8]
    Base->SC3 = Sc3Reg;
    7b7a:	9b03      	ldr	r3, [sp, #12]
    7b7c:	9a02      	ldr	r2, [sp, #8]
    7b7e:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_30();
    7b82:	f007 fc45 	bl	f410 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_30>
}
    7b86:	bf00      	nop
    7b88:	b005      	add	sp, #20
    7b8a:	f85d fb04 	ldr.w	pc, [sp], #4
    7b8e:	bf00      	nop
    7b90:	00015be0 	.word	0x00015be0

00007b94 <Adc_Ip_SetResolution>:
*
* @implements     Adc_Ip_SetResolution_Activity
* END**************************************************************************/
void Adc_Ip_SetResolution(const uint32 Instance,
                          const Adc_Ip_ResolutionType Resolution)
{
    7b94:	b500      	push	{lr}
    7b96:	b085      	sub	sp, #20
    7b98:	9001      	str	r0, [sp, #4]
    7b9a:	9100      	str	r1, [sp, #0]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7b9c:	4a0e      	ldr	r2, [pc, #56]	; (7bd8 <Adc_Ip_SetResolution+0x44>)
    7b9e:	9b01      	ldr	r3, [sp, #4]
    7ba0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7ba4:	9303      	str	r3, [sp, #12]

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_10();
    7ba6:	f006 fc57 	bl	e458 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_10>
    uint32 Cfg1Reg = Base->CFG1;
    7baa:	9b03      	ldr	r3, [sp, #12]
    7bac:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    7bae:	9302      	str	r3, [sp, #8]
    Cfg1Reg &= ~(ADC_CFG1_MODE_MASK);
    7bb0:	9b02      	ldr	r3, [sp, #8]
    7bb2:	f023 030c 	bic.w	r3, r3, #12
    7bb6:	9302      	str	r3, [sp, #8]
    Cfg1Reg |= ADC_CFG1_MODE(Resolution);
    7bb8:	9b00      	ldr	r3, [sp, #0]
    7bba:	009b      	lsls	r3, r3, #2
    7bbc:	f003 030c 	and.w	r3, r3, #12
    7bc0:	9a02      	ldr	r2, [sp, #8]
    7bc2:	4313      	orrs	r3, r2
    7bc4:	9302      	str	r3, [sp, #8]
    Base->CFG1 = Cfg1Reg;
    7bc6:	9b03      	ldr	r3, [sp, #12]
    7bc8:	9a02      	ldr	r2, [sp, #8]
    7bca:	641a      	str	r2, [r3, #64]	; 0x40
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_10();
    7bcc:	f006 fc70 	bl	e4b0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_10>
}
    7bd0:	bf00      	nop
    7bd2:	b005      	add	sp, #20
    7bd4:	f85d fb04 	ldr.w	pc, [sp], #4
    7bd8:	00015be0 	.word	0x00015be0

00007bdc <Adc_Ip_SetClockMode>:
*
* @implements     Adc_Ip_SetClockMode_Activity
* END**************************************************************************/
void Adc_Ip_SetClockMode(const uint32 Instance,
                         const Adc_Ip_ClockConfigType * const Config)
{
    7bdc:	b500      	push	{lr}
    7bde:	b085      	sub	sp, #20
    7be0:	9001      	str	r0, [sp, #4]
    7be2:	9100      	str	r1, [sp, #0]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
    DevAssert(Config != NULL_PTR);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7be4:	4a15      	ldr	r2, [pc, #84]	; (7c3c <Adc_Ip_SetClockMode+0x60>)
    7be6:	9b01      	ldr	r3, [sp, #4]
    7be8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7bec:	9303      	str	r3, [sp, #12]

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_11();
    7bee:	f006 fdcd 	bl	e78c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_11>
    Adc_HwAcc_SetClock(Base, Config->ClockDivide, Config->InputClock);
    7bf2:	9b00      	ldr	r3, [sp, #0]
    7bf4:	6819      	ldr	r1, [r3, #0]
    7bf6:	9b00      	ldr	r3, [sp, #0]
    7bf8:	685b      	ldr	r3, [r3, #4]
    7bfa:	461a      	mov	r2, r3
    7bfc:	9803      	ldr	r0, [sp, #12]
    7bfe:	f7ff fc23 	bl	7448 <Adc_HwAcc_SetClock>
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_11();
    7c02:	f006 fdef 	bl	e7e4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_11>

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_14();
    7c06:	f006 feb7 	bl	e978 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_14>
    Adc_HwAcc_SetSampleTime(Base, Config->SampleTime);
    7c0a:	9b00      	ldr	r3, [sp, #0]
    7c0c:	7a1b      	ldrb	r3, [r3, #8]
    7c0e:	4619      	mov	r1, r3
    7c10:	9803      	ldr	r0, [sp, #12]
    7c12:	f7ff fc74 	bl	74fe <Adc_HwAcc_SetSampleTime>
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_14();
    7c16:	f006 fedb 	bl	e9d0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_14>

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_28();
    7c1a:	f007 fb29 	bl	f270 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_28>
    Adc_HwAcc_SetAveraging(Base, Config->AvgEn, Config->AvgSel);
    7c1e:	9b00      	ldr	r3, [sp, #0]
    7c20:	7a59      	ldrb	r1, [r3, #9]
    7c22:	9b00      	ldr	r3, [sp, #0]
    7c24:	68db      	ldr	r3, [r3, #12]
    7c26:	461a      	mov	r2, r3
    7c28:	9803      	ldr	r0, [sp, #12]
    7c2a:	f7ff fc89 	bl	7540 <Adc_HwAcc_SetAveraging>
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_28();
    7c2e:	f007 fb4b 	bl	f2c8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_28>
}
    7c32:	bf00      	nop
    7c34:	b005      	add	sp, #20
    7c36:	f85d fb04 	ldr.w	pc, [sp], #4
    7c3a:	bf00      	nop
    7c3c:	00015be0 	.word	0x00015be0

00007c40 <Adc_Ip_ConfigChannel>:
*
* @implements     Adc_Ip_ConfigChannel_Activity
* END**************************************************************************/
void Adc_Ip_ConfigChannel(const uint32 Instance,
                          const Adc_Ip_ChanConfigType * const ChanConfig)
{
    7c40:	b510      	push	{r4, lr}
    7c42:	b084      	sub	sp, #16
    7c44:	9001      	str	r0, [sp, #4]
    7c46:	9100      	str	r1, [sp, #0]
#if (ADC_IP_SUPPLY_MONITORING_ENABLED == STD_ON)
    DevAssert((Instance == 0u) || ((uint32)ChanConfig->Channel < (uint32)ADC_IP_INPUTCHAN_SUPPLY_VDD));
#endif /* (ADC_IP_SUPPLY_MONITORING_ENABLED == STD_ON) */
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7c48:	4a13      	ldr	r2, [pc, #76]	; (7c98 <Adc_Ip_ConfigChannel+0x58>)
    7c4a:	9b01      	ldr	r3, [sp, #4]
    7c4c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7c50:	9303      	str	r3, [sp, #12]
        InputChanDemapped = ADC_IP_INPUTCHAN_INT0;
    }
    else
#endif /* (ADC_IP_SUPPLY_MONITORING_ENABLED == STD_ON) */
    {
        InputChanDemapped = ChanConfig->Channel;
    7c52:	9b00      	ldr	r3, [sp, #0]
    7c54:	685b      	ldr	r3, [r3, #4]
    7c56:	9302      	str	r3, [sp, #8]
    }

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_21();
    7c58:	f007 f8cc 	bl	edf4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_21>
#if (ADC_IP_AIEN_INTERRUPT_ENABLE == STD_ON)
    Adc_HwAcc_SetChannel(Base, ChanConfig->ChnIdx, InputChanDemapped, ChanConfig->InterruptEnable);
    7c5c:	9b00      	ldr	r3, [sp, #0]
    7c5e:	7819      	ldrb	r1, [r3, #0]
    7c60:	9b00      	ldr	r3, [sp, #0]
    7c62:	7a1b      	ldrb	r3, [r3, #8]
    7c64:	9a02      	ldr	r2, [sp, #8]
    7c66:	9803      	ldr	r0, [sp, #12]
    7c68:	f7ff fcd5 	bl	7616 <Adc_HwAcc_SetChannel>
#else
    Adc_HwAcc_SetChannel(Base, ChanConfig->ChnIdx, InputChanDemapped, FALSE);
#endif /* (ADC_IP_AIEN_INTERRUPT_ENABLE == STD_ON) */
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_21();
    7c6c:	f007 f8ee 	bl	ee4c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_21>

    /* Also update in state structure */
    Adc_Ip_axState[Instance].ChannelConfig[ChanConfig->ChnIdx] = ChanConfig->Channel;
    7c70:	9b00      	ldr	r3, [sp, #0]
    7c72:	781b      	ldrb	r3, [r3, #0]
    7c74:	461c      	mov	r4, r3
    7c76:	9b00      	ldr	r3, [sp, #0]
    7c78:	6859      	ldr	r1, [r3, #4]
    7c7a:	4808      	ldr	r0, [pc, #32]	; (7c9c <Adc_Ip_ConfigChannel+0x5c>)
    7c7c:	9a01      	ldr	r2, [sp, #4]
    7c7e:	4613      	mov	r3, r2
    7c80:	00db      	lsls	r3, r3, #3
    7c82:	4413      	add	r3, r2
    7c84:	005b      	lsls	r3, r3, #1
    7c86:	4413      	add	r3, r2
    7c88:	4423      	add	r3, r4
    7c8a:	3302      	adds	r3, #2
    7c8c:	009b      	lsls	r3, r3, #2
    7c8e:	4403      	add	r3, r0
    7c90:	6059      	str	r1, [r3, #4]
}
    7c92:	bf00      	nop
    7c94:	b004      	add	sp, #16
    7c96:	bd10      	pop	{r4, pc}
    7c98:	00015be0 	.word	0x00015be0
    7c9c:	1fff8d00 	.word	0x1fff8d00

00007ca0 <Adc_Ip_SetDisabledChannel>:
* @implements     Adc_Ip_SetDisabledChannel_Activity
* END**************************************************************************/
Adc_Ip_StatusType Adc_Ip_SetDisabledChannel(const uint32 Instance,
                                            const uint8 ControlChanIdx,
                                            const boolean WithTimeout)
{
    7ca0:	b500      	push	{lr}
    7ca2:	b089      	sub	sp, #36	; 0x24
    7ca4:	9001      	str	r0, [sp, #4]
    7ca6:	460b      	mov	r3, r1
    7ca8:	f88d 3003 	strb.w	r3, [sp, #3]
    7cac:	4613      	mov	r3, r2
    7cae:	f88d 3002 	strb.w	r3, [sp, #2]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
    DevAssert(ControlChanIdx < ADC_MAX_CHAN_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7cb2:	4a24      	ldr	r2, [pc, #144]	; (7d44 <Adc_Ip_SetDisabledChannel+0xa4>)
    7cb4:	9b01      	ldr	r3, [sp, #4]
    7cb6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7cba:	9305      	str	r3, [sp, #20]
    Adc_Ip_StatusType Status = ADC_IP_STATUS_SUCCESS;
    7cbc:	2300      	movs	r3, #0
    7cbe:	9307      	str	r3, [sp, #28]
    uint32 TimeoutTicks = OsIf_MicrosToTicks(ADC_IP_TIMEOUT_VAL, ADC_IP_TIMEOUT_TYPE);
    7cc0:	2100      	movs	r1, #0
    7cc2:	4821      	ldr	r0, [pc, #132]	; (7d48 <Adc_Ip_SetDisabledChannel+0xa8>)
    7cc4:	f7fa f8b6 	bl	1e34 <OsIf_MicrosToTicks>
    7cc8:	9004      	str	r0, [sp, #16]
    uint32 CurrentTicks = OsIf_GetCounter(ADC_IP_TIMEOUT_TYPE);
    7cca:	2000      	movs	r0, #0
    7ccc:	f7fa f866 	bl	1d9c <OsIf_GetCounter>
    7cd0:	4603      	mov	r3, r0
    7cd2:	9303      	str	r3, [sp, #12]
    uint32 ElapsedTicks = 0u;
    7cd4:	2300      	movs	r3, #0
    7cd6:	9306      	str	r3, [sp, #24]

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_17();
    7cd8:	f006 ff44 	bl	eb64 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_17>
    /* Set input channel select to disabled */
    SC1(Base, ControlChanIdx) |= ADC_SC1_ADCH_MASK;
    7cdc:	f89d 2003 	ldrb.w	r2, [sp, #3]
    7ce0:	9b05      	ldr	r3, [sp, #20]
    7ce2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    7ce6:	f89d 2003 	ldrb.w	r2, [sp, #3]
    7cea:	f043 011f 	orr.w	r1, r3, #31
    7cee:	9b05      	ldr	r3, [sp, #20]
    7cf0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_17();
    7cf4:	f006 ff62 	bl	ebbc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_17>

    if (WithTimeout == TRUE)
    7cf8:	f89d 3002 	ldrb.w	r3, [sp, #2]
    7cfc:	2b00      	cmp	r3, #0
    7cfe:	d01c      	beq.n	7d3a <Adc_Ip_SetDisabledChannel+0x9a>
    {
        while (((SC1(Base, ControlChanIdx) & ADC_SC1_ADCH_MASK) != ADC_SC1_ADCH_MASK) && (ElapsedTicks < TimeoutTicks))
    7d00:	e008      	b.n	7d14 <Adc_Ip_SetDisabledChannel+0x74>
        {
            ElapsedTicks += OsIf_GetElapsed(&CurrentTicks, ADC_IP_TIMEOUT_TYPE);
    7d02:	ab03      	add	r3, sp, #12
    7d04:	2100      	movs	r1, #0
    7d06:	4618      	mov	r0, r3
    7d08:	f7fa f861 	bl	1dce <OsIf_GetElapsed>
    7d0c:	4602      	mov	r2, r0
    7d0e:	9b06      	ldr	r3, [sp, #24]
    7d10:	4413      	add	r3, r2
    7d12:	9306      	str	r3, [sp, #24]
        while (((SC1(Base, ControlChanIdx) & ADC_SC1_ADCH_MASK) != ADC_SC1_ADCH_MASK) && (ElapsedTicks < TimeoutTicks))
    7d14:	f89d 2003 	ldrb.w	r2, [sp, #3]
    7d18:	9b05      	ldr	r3, [sp, #20]
    7d1a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    7d1e:	f003 031f 	and.w	r3, r3, #31
    7d22:	2b1f      	cmp	r3, #31
    7d24:	d003      	beq.n	7d2e <Adc_Ip_SetDisabledChannel+0x8e>
    7d26:	9a06      	ldr	r2, [sp, #24]
    7d28:	9b04      	ldr	r3, [sp, #16]
    7d2a:	429a      	cmp	r2, r3
    7d2c:	d3e9      	bcc.n	7d02 <Adc_Ip_SetDisabledChannel+0x62>
        }
        if (ElapsedTicks >= TimeoutTicks)
    7d2e:	9a06      	ldr	r2, [sp, #24]
    7d30:	9b04      	ldr	r3, [sp, #16]
    7d32:	429a      	cmp	r2, r3
    7d34:	d301      	bcc.n	7d3a <Adc_Ip_SetDisabledChannel+0x9a>
        {
            Status = ADC_IP_STATUS_TIMEOUT;
    7d36:	2302      	movs	r3, #2
    7d38:	9307      	str	r3, [sp, #28]
        }
    }

    return Status;
    7d3a:	9b07      	ldr	r3, [sp, #28]
}
    7d3c:	4618      	mov	r0, r3
    7d3e:	b009      	add	sp, #36	; 0x24
    7d40:	f85d fb04 	ldr.w	pc, [sp], #4
    7d44:	00015be0 	.word	0x00015be0
    7d48:	000186a0 	.word	0x000186a0

00007d4c <Adc_Ip_StartConversion>:
* @implements     Adc_Ip_StartConversion_Activity
* END**************************************************************************/
void Adc_Ip_StartConversion(const uint32 Instance,
                            Adc_Ip_InputChannelType InputChannel,
                            const boolean InterruptEnable)
{
    7d4c:	b500      	push	{lr}
    7d4e:	b087      	sub	sp, #28
    7d50:	9003      	str	r0, [sp, #12]
    7d52:	9102      	str	r1, [sp, #8]
    7d54:	4613      	mov	r3, r2
    7d56:	f88d 3007 	strb.w	r3, [sp, #7]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7d5a:	4a0a      	ldr	r2, [pc, #40]	; (7d84 <Adc_Ip_StartConversion+0x38>)
    7d5c:	9b03      	ldr	r3, [sp, #12]
    7d5e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7d62:	9305      	str	r3, [sp, #20]

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_18();
    7d64:	f006 ff50 	bl	ec08 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_18>
    /* Configure SC1A register */
#if (ADC_IP_AIEN_INTERRUPT_ENABLE == STD_ON)
    Adc_HwAcc_SetChannel(Base, 0u, InputChannel, InterruptEnable);
    7d68:	f89d 3007 	ldrb.w	r3, [sp, #7]
    7d6c:	9a02      	ldr	r2, [sp, #8]
    7d6e:	2100      	movs	r1, #0
    7d70:	9805      	ldr	r0, [sp, #20]
    7d72:	f7ff fc50 	bl	7616 <Adc_HwAcc_SetChannel>
#else
    Adc_HwAcc_SetChannel(Base, 0u, InputChannel, FALSE);
    (void)InterruptEnable;
#endif /* (ADC_IP_AIEN_INTERRUPT_ENABLE == STD_ON) */
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_18();
    7d76:	f006 ff73 	bl	ec60 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_18>
}
    7d7a:	bf00      	nop
    7d7c:	b007      	add	sp, #28
    7d7e:	f85d fb04 	ldr.w	pc, [sp], #4
    7d82:	bf00      	nop
    7d84:	00015be0 	.word	0x00015be0

00007d88 <Adc_Ip_GetConvActiveFlag>:
* Description   : Reads and return conversion active flag status.
*
* @implements     Adc_Ip_GetConvActiveFlag_Activity
* END**************************************************************************/
boolean Adc_Ip_GetConvActiveFlag(const uint32 Instance)
{
    7d88:	b084      	sub	sp, #16
    7d8a:	9001      	str	r0, [sp, #4]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    const ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7d8c:	4a0b      	ldr	r2, [pc, #44]	; (7dbc <Adc_Ip_GetConvActiveFlag+0x34>)
    7d8e:	9b01      	ldr	r3, [sp, #4]
    7d90:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7d94:	9303      	str	r3, [sp, #12]
    uint32 Sc2Reg = Base->SC2;
    7d96:	9b03      	ldr	r3, [sp, #12]
    7d98:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
    7d9c:	9302      	str	r3, [sp, #8]

    Sc2Reg = (Sc2Reg & ADC_SC2_ADACT_MASK) >> ADC_SC2_ADACT_SHIFT;
    7d9e:	9b02      	ldr	r3, [sp, #8]
    7da0:	09db      	lsrs	r3, r3, #7
    7da2:	f003 0301 	and.w	r3, r3, #1
    7da6:	9302      	str	r3, [sp, #8]

    return (Sc2Reg != 0u) ? TRUE : FALSE;
    7da8:	9b02      	ldr	r3, [sp, #8]
    7daa:	2b00      	cmp	r3, #0
    7dac:	bf14      	ite	ne
    7dae:	2301      	movne	r3, #1
    7db0:	2300      	moveq	r3, #0
    7db2:	b2db      	uxtb	r3, r3
}
    7db4:	4618      	mov	r0, r3
    7db6:	b004      	add	sp, #16
    7db8:	4770      	bx	lr
    7dba:	bf00      	nop
    7dbc:	00015be0 	.word	0x00015be0

00007dc0 <Adc_Ip_GetChanInterrupt>:
*
* @implements     Adc_Ip_GetChanInterrupt_Activity
* END**************************************************************************/
boolean Adc_Ip_GetChanInterrupt(const uint32 Instance,
                                const uint8 ControlChanIdx)
{
    7dc0:	b500      	push	{lr}
    7dc2:	b085      	sub	sp, #20
    7dc4:	9001      	str	r0, [sp, #4]
    7dc6:	460b      	mov	r3, r1
    7dc8:	f88d 3003 	strb.w	r3, [sp, #3]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
    DevAssert(ControlChanIdx < ADC_MAX_CHAN_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    const uint32 Sc1Reg = SC1(Adc_Ip_apxBase[Instance], ControlChanIdx);
    7dcc:	4a08      	ldr	r2, [pc, #32]	; (7df0 <Adc_Ip_GetChanInterrupt+0x30>)
    7dce:	9b01      	ldr	r3, [sp, #4]
    7dd0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7dd4:	f89d 2003 	ldrb.w	r2, [sp, #3]
    7dd8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    7ddc:	9303      	str	r3, [sp, #12]

    return Adc_HwAcc_GetAIEN(Sc1Reg);
    7dde:	9803      	ldr	r0, [sp, #12]
    7de0:	f7ff fc5e 	bl	76a0 <Adc_HwAcc_GetAIEN>
    7de4:	4603      	mov	r3, r0
}
    7de6:	4618      	mov	r0, r3
    7de8:	b005      	add	sp, #20
    7dea:	f85d fb04 	ldr.w	pc, [sp], #4
    7dee:	bf00      	nop
    7df0:	00015be0 	.word	0x00015be0

00007df4 <Adc_Ip_GetConvCompleteFlag>:
*
* @implements     Adc_Ip_GetConvCompleteFlag_Activity
* END**************************************************************************/
boolean Adc_Ip_GetConvCompleteFlag(const uint32 Instance,
                                   const uint8 ControlChanIdx)
{
    7df4:	b500      	push	{lr}
    7df6:	b085      	sub	sp, #20
    7df8:	9001      	str	r0, [sp, #4]
    7dfa:	460b      	mov	r3, r1
    7dfc:	f88d 3003 	strb.w	r3, [sp, #3]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
    DevAssert(ControlChanIdx < ADC_MAX_CHAN_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    const uint32 Sc1Reg = SC1(Adc_Ip_apxBase[Instance], ControlChanIdx);
    7e00:	4a08      	ldr	r2, [pc, #32]	; (7e24 <Adc_Ip_GetConvCompleteFlag+0x30>)
    7e02:	9b01      	ldr	r3, [sp, #4]
    7e04:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7e08:	f89d 2003 	ldrb.w	r2, [sp, #3]
    7e0c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    7e10:	9303      	str	r3, [sp, #12]

    return Adc_HwAcc_GetCOCO(Sc1Reg);
    7e12:	9803      	ldr	r0, [sp, #12]
    7e14:	f7ff fc52 	bl	76bc <Adc_HwAcc_GetCOCO>
    7e18:	4603      	mov	r3, r0
}
    7e1a:	4618      	mov	r0, r3
    7e1c:	b005      	add	sp, #20
    7e1e:	f85d fb04 	ldr.w	pc, [sp], #4
    7e22:	bf00      	nop
    7e24:	00015be0 	.word	0x00015be0

00007e28 <Adc_Ip_GetConvData>:
*
* @implements     Adc_Ip_GetConvData_Activity
* END**************************************************************************/
uint16 Adc_Ip_GetConvData(const uint32 Instance,
                          const uint8 ControlChanIdx)
{
    7e28:	b500      	push	{lr}
    7e2a:	b085      	sub	sp, #20
    7e2c:	9001      	str	r0, [sp, #4]
    7e2e:	460b      	mov	r3, r1
    7e30:	f88d 3003 	strb.w	r3, [sp, #3]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
    DevAssert(ControlChanIdx < ADC_MAX_CHAN_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    const ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7e34:	4a07      	ldr	r2, [pc, #28]	; (7e54 <Adc_Ip_GetConvData+0x2c>)
    7e36:	9b01      	ldr	r3, [sp, #4]
    7e38:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7e3c:	9303      	str	r3, [sp, #12]

    return Adc_HwAcc_GetData(Base, ControlChanIdx);
    7e3e:	f89d 3003 	ldrb.w	r3, [sp, #3]
    7e42:	4619      	mov	r1, r3
    7e44:	9803      	ldr	r0, [sp, #12]
    7e46:	f7ff fc47 	bl	76d8 <Adc_HwAcc_GetData>
    7e4a:	4603      	mov	r3, r0
}
    7e4c:	4618      	mov	r0, r3
    7e4e:	b005      	add	sp, #20
    7e50:	f85d fb04 	ldr.w	pc, [sp], #4
    7e54:	00015be0 	.word	0x00015be0

00007e58 <Adc_Ip_DoCalibration>:
* specified frequency (50Mhz) and greater than minimum specified frequency (20Mhz).
*
* @implements     Adc_Ip_DoCalibration_Activity
* END**************************************************************************/
Adc_Ip_StatusType Adc_Ip_DoCalibration(const uint32 Instance)
{
    7e58:	b500      	push	{lr}
    7e5a:	b093      	sub	sp, #76	; 0x4c
    7e5c:	9001      	str	r0, [sp, #4]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7e5e:	4a59      	ldr	r2, [pc, #356]	; (7fc4 <Adc_Ip_DoCalibration+0x16c>)
    7e60:	9b01      	ldr	r3, [sp, #4]
    7e62:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7e66:	930f      	str	r3, [sp, #60]	; 0x3c
    Adc_Ip_StatusType Status = ADC_IP_STATUS_SUCCESS;
    7e68:	2300      	movs	r3, #0
    7e6a:	9311      	str	r3, [sp, #68]	; 0x44
    Adc_Ip_TrigType TriggerMode;
    uint32 TimeoutTicks = OsIf_MicrosToTicks(ADC_IP_TIMEOUT_VAL, ADC_IP_TIMEOUT_TYPE);
    7e6c:	2100      	movs	r1, #0
    7e6e:	4856      	ldr	r0, [pc, #344]	; (7fc8 <Adc_Ip_DoCalibration+0x170>)
    7e70:	f7f9 ffe0 	bl	1e34 <OsIf_MicrosToTicks>
    7e74:	900e      	str	r0, [sp, #56]	; 0x38
    uint32 CurrentTicks = OsIf_GetCounter(ADC_IP_TIMEOUT_TYPE);
    7e76:	2000      	movs	r0, #0
    7e78:	f7f9 ff90 	bl	1d9c <OsIf_GetCounter>
    7e7c:	4603      	mov	r3, r0
    7e7e:	930b      	str	r3, [sp, #44]	; 0x2c
    uint32 ElapsedTicks = 0u;
    7e80:	2300      	movs	r3, #0
    7e82:	9310      	str	r3, [sp, #64]	; 0x40
    uint32 Reg;
    Adc_Ip_ClockConfigType PreClockConfig;
    Adc_Ip_ClockConfigType CalClockConfig;

    /* Store settings before calibration */
    Reg = Base->SC3;
    7e84:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    7e86:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
    7e8a:	930d      	str	r3, [sp, #52]	; 0x34
    PreClockConfig.AvgEn = ((Reg & ADC_SC3_AVGE_MASK) != 0u) ? TRUE : FALSE;
    7e8c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    7e8e:	089b      	lsrs	r3, r3, #2
    7e90:	f003 0301 	and.w	r3, r3, #1
    7e94:	2b00      	cmp	r3, #0
    7e96:	bf14      	ite	ne
    7e98:	2301      	movne	r3, #1
    7e9a:	2300      	moveq	r3, #0
    7e9c:	b2db      	uxtb	r3, r3
    7e9e:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
    PreClockConfig.AvgSel = Adc_HwAcc_GetAverageSelect(Reg);
    7ea2:	980d      	ldr	r0, [sp, #52]	; 0x34
    7ea4:	f7ff fb71 	bl	758a <Adc_HwAcc_GetAverageSelect>
    7ea8:	4603      	mov	r3, r0
    7eaa:	930a      	str	r3, [sp, #40]	; 0x28

    Reg = Base->CFG2;
    7eac:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    7eae:	6c5b      	ldr	r3, [r3, #68]	; 0x44
    7eb0:	930d      	str	r3, [sp, #52]	; 0x34
    PreClockConfig.SampleTime = (uint8) ((Reg & ADC_CFG2_SMPLTS_MASK) >> ADC_CFG2_SMPLTS_SHIFT);
    7eb2:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    7eb4:	b2db      	uxtb	r3, r3
    7eb6:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
    TriggerMode = Adc_HwAcc_GetTriggerMode(Base->SC2);
    7eba:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    7ebc:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
    7ec0:	4618      	mov	r0, r3
    7ec2:	f7ff fb99 	bl	75f8 <Adc_HwAcc_GetTriggerMode>
    7ec6:	900c      	str	r0, [sp, #48]	; 0x30

    Reg = Base->CFG1;
    7ec8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    7eca:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    7ecc:	930d      	str	r3, [sp, #52]	; 0x34
    PreClockConfig.ClockDivide = Adc_HwAcc_GetClockDivide(Reg);
    7ece:	980d      	ldr	r0, [sp, #52]	; 0x34
    7ed0:	f7ff fad8 	bl	7484 <Adc_HwAcc_GetClockDivide>
    7ed4:	4603      	mov	r3, r0
    7ed6:	9307      	str	r3, [sp, #28]
    PreClockConfig.InputClock = Adc_HwAcc_GetInputClock(Reg);
    7ed8:	980d      	ldr	r0, [sp, #52]	; 0x34
    7eda:	f7ff faf2 	bl	74c2 <Adc_HwAcc_GetInputClock>
    7ede:	4603      	mov	r3, r0
    7ee0:	9308      	str	r3, [sp, #32]

    CalClockConfig.AvgEn = TRUE;
    7ee2:	2301      	movs	r3, #1
    7ee4:	f88d 3015 	strb.w	r3, [sp, #21]
    CalClockConfig.AvgSel = ADC_IP_AVG_32_CONV;
    7ee8:	2303      	movs	r3, #3
    7eea:	9306      	str	r3, [sp, #24]
    CalClockConfig.SampleTime = ADC_IP_DEFAULT_SAMPLE_TIME;
    7eec:	230c      	movs	r3, #12
    7eee:	f88d 3014 	strb.w	r3, [sp, #20]
    CalClockConfig.ClockDivide = Adc_Ip_axState[Instance].CalibrationClockDivide;
    7ef2:	4a36      	ldr	r2, [pc, #216]	; (7fcc <Adc_Ip_DoCalibration+0x174>)
    7ef4:	9b01      	ldr	r3, [sp, #4]
    7ef6:	214c      	movs	r1, #76	; 0x4c
    7ef8:	fb01 f303 	mul.w	r3, r1, r3
    7efc:	4413      	add	r3, r2
    7efe:	3304      	adds	r3, #4
    7f00:	681b      	ldr	r3, [r3, #0]
    7f02:	9303      	str	r3, [sp, #12]
    CalClockConfig.InputClock = PreClockConfig.InputClock;
    7f04:	9b08      	ldr	r3, [sp, #32]
    7f06:	9304      	str	r3, [sp, #16]

    /* Prepare required settings for calibration. */
    ADC_DoCalibration_SetParams(Base, &CalClockConfig, ADC_IP_TRIGGER_SOFTWARE);
    7f08:	ab03      	add	r3, sp, #12
    7f0a:	2200      	movs	r2, #0
    7f0c:	4619      	mov	r1, r3
    7f0e:	980f      	ldr	r0, [sp, #60]	; 0x3c
    7f10:	f7ff fbfa 	bl	7708 <ADC_DoCalibration_SetParams>

    Base->CLPS = 0u;
    7f14:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    7f16:	2200      	movs	r2, #0
    7f18:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
    Base->CLP3 = 0u;
    7f1c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    7f1e:	2200      	movs	r2, #0
    7f20:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
    Base->CLP2 = 0u;
    7f24:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    7f26:	2200      	movs	r2, #0
    7f28:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
    Base->CLP1 = 0u;
    7f2c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    7f2e:	2200      	movs	r2, #0
    7f30:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
    Base->CLP0 = 0u;
    7f34:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    7f36:	2200      	movs	r2, #0
    7f38:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
    Base->CLPX = 0u;
    7f3c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    7f3e:	2200      	movs	r2, #0
    7f40:	f8c3 20c8 	str.w	r2, [r3, #200]	; 0xc8
    Base->CLP9 = 0u;
    7f44:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    7f46:	2200      	movs	r2, #0
    7f48:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc

    /* Start calibration by writing to the calibration field */
    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_29();
    7f4c:	f007 f9e2 	bl	f314 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_29>
    Reg = Base->SC3;
    7f50:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    7f52:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
    7f56:	930d      	str	r3, [sp, #52]	; 0x34
    Reg &= ~(ADC_SC3_CAL_MASK);
    7f58:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    7f5a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    7f5e:	930d      	str	r3, [sp, #52]	; 0x34
    Reg |= ADC_SC3_CAL(1u);
    7f60:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    7f62:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    7f66:	930d      	str	r3, [sp, #52]	; 0x34
    Base->SC3 = Reg;
    7f68:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    7f6a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    7f6c:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_29();
    7f70:	f007 f9fc 	bl	f36c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_29>

    /* Wait for the calibration to finish */
    while (((Base->SC3 & ADC_SC3_CAL_MASK) != 0u) && (ElapsedTicks < TimeoutTicks))
    7f74:	e008      	b.n	7f88 <Adc_Ip_DoCalibration+0x130>
    {
        ElapsedTicks += OsIf_GetElapsed(&CurrentTicks, ADC_IP_TIMEOUT_TYPE);
    7f76:	ab0b      	add	r3, sp, #44	; 0x2c
    7f78:	2100      	movs	r1, #0
    7f7a:	4618      	mov	r0, r3
    7f7c:	f7f9 ff27 	bl	1dce <OsIf_GetElapsed>
    7f80:	4602      	mov	r2, r0
    7f82:	9b10      	ldr	r3, [sp, #64]	; 0x40
    7f84:	4413      	add	r3, r2
    7f86:	9310      	str	r3, [sp, #64]	; 0x40
    while (((Base->SC3 & ADC_SC3_CAL_MASK) != 0u) && (ElapsedTicks < TimeoutTicks))
    7f88:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    7f8a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
    7f8e:	f003 0380 	and.w	r3, r3, #128	; 0x80
    7f92:	2b00      	cmp	r3, #0
    7f94:	d003      	beq.n	7f9e <Adc_Ip_DoCalibration+0x146>
    7f96:	9a10      	ldr	r2, [sp, #64]	; 0x40
    7f98:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    7f9a:	429a      	cmp	r2, r3
    7f9c:	d3eb      	bcc.n	7f76 <Adc_Ip_DoCalibration+0x11e>
    }
    if (ElapsedTicks >= TimeoutTicks)
    7f9e:	9a10      	ldr	r2, [sp, #64]	; 0x40
    7fa0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    7fa2:	429a      	cmp	r2, r3
    7fa4:	d301      	bcc.n	7faa <Adc_Ip_DoCalibration+0x152>
    {
        Status = ADC_IP_STATUS_TIMEOUT;
    7fa6:	2302      	movs	r3, #2
    7fa8:	9311      	str	r3, [sp, #68]	; 0x44
    }

    /* Revert settings as same as before calibration. */
    ADC_DoCalibration_SetParams(Base, &PreClockConfig, TriggerMode);
    7faa:	ab07      	add	r3, sp, #28
    7fac:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    7fae:	4619      	mov	r1, r3
    7fb0:	980f      	ldr	r0, [sp, #60]	; 0x3c
    7fb2:	f7ff fba9 	bl	7708 <ADC_DoCalibration_SetParams>

    /* Clear COCO flag */
    (void) R(Base, 0u);
    7fb6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    7fb8:	6c9b      	ldr	r3, [r3, #72]	; 0x48

    return Status;
    7fba:	9b11      	ldr	r3, [sp, #68]	; 0x44
}
    7fbc:	4618      	mov	r0, r3
    7fbe:	b013      	add	sp, #76	; 0x4c
    7fc0:	f85d fb04 	ldr.w	pc, [sp], #4
    7fc4:	00015be0 	.word	0x00015be0
    7fc8:	000186a0 	.word	0x000186a0
    7fcc:	1fff8d00 	.word	0x1fff8d00

00007fd0 <Adc_Ip_ClearLatchedTriggers>:
* has been deactivated.
*
* @implements     Adc_Ip_ClearLatchedTriggers_Activity
* END**************************************************************************/
Adc_Ip_StatusType Adc_Ip_ClearLatchedTriggers(const uint32 Instance)
{
    7fd0:	b500      	push	{lr}
    7fd2:	b089      	sub	sp, #36	; 0x24
    7fd4:	9001      	str	r0, [sp, #4]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
    DevAssert(Instance != 0u);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    7fd6:	4a1e      	ldr	r2, [pc, #120]	; (8050 <Adc_Ip_ClearLatchedTriggers+0x80>)
    7fd8:	9b01      	ldr	r3, [sp, #4]
    7fda:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    7fde:	9305      	str	r3, [sp, #20]
    Adc_Ip_StatusType Status = ADC_IP_STATUS_SUCCESS;
    7fe0:	2300      	movs	r3, #0
    7fe2:	9307      	str	r3, [sp, #28]
    uint32 TimeoutTicks = OsIf_MicrosToTicks(ADC_IP_TIMEOUT_VAL, ADC_IP_TIMEOUT_TYPE);
    7fe4:	2100      	movs	r1, #0
    7fe6:	481b      	ldr	r0, [pc, #108]	; (8054 <Adc_Ip_ClearLatchedTriggers+0x84>)
    7fe8:	f7f9 ff24 	bl	1e34 <OsIf_MicrosToTicks>
    7fec:	9004      	str	r0, [sp, #16]
    uint32 CurrentTicks = OsIf_GetCounter(ADC_IP_TIMEOUT_TYPE);
    7fee:	2000      	movs	r0, #0
    7ff0:	f7f9 fed4 	bl	1d9c <OsIf_GetCounter>
    7ff4:	4603      	mov	r3, r0
    7ff6:	9303      	str	r3, [sp, #12]
    uint32 ElapsedTicks = 0u;
    7ff8:	2300      	movs	r3, #0
    7ffa:	9306      	str	r3, [sp, #24]

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_12();
    7ffc:	f006 fc18 	bl	e830 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_12>
    /* Write bit to clear latched triggers */
    Base->CFG1 |= ADC_CFG1_CLRLTRG(0x01u);
    8000:	9b05      	ldr	r3, [sp, #20]
    8002:	6c1b      	ldr	r3, [r3, #64]	; 0x40
    8004:	f443 7280 	orr.w	r2, r3, #256	; 0x100
    8008:	9b05      	ldr	r3, [sp, #20]
    800a:	641a      	str	r2, [r3, #64]	; 0x40
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_12();
    800c:	f006 fc3c 	bl	e888 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_12>

    /* Wait for latched triggers to be cleared */
    while (((Base->SC2 & ADC_SC2_TRGSTLAT_MASK) != 0u) && (ElapsedTicks < TimeoutTicks))
    8010:	e008      	b.n	8024 <Adc_Ip_ClearLatchedTriggers+0x54>
    {
        ElapsedTicks += OsIf_GetElapsed(&CurrentTicks, ADC_IP_TIMEOUT_TYPE);
    8012:	ab03      	add	r3, sp, #12
    8014:	2100      	movs	r1, #0
    8016:	4618      	mov	r0, r3
    8018:	f7f9 fed9 	bl	1dce <OsIf_GetElapsed>
    801c:	4602      	mov	r2, r0
    801e:	9b06      	ldr	r3, [sp, #24]
    8020:	4413      	add	r3, r2
    8022:	9306      	str	r3, [sp, #24]
    while (((Base->SC2 & ADC_SC2_TRGSTLAT_MASK) != 0u) && (ElapsedTicks < TimeoutTicks))
    8024:	9b05      	ldr	r3, [sp, #20]
    8026:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
    802a:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
    802e:	2b00      	cmp	r3, #0
    8030:	d003      	beq.n	803a <Adc_Ip_ClearLatchedTriggers+0x6a>
    8032:	9a06      	ldr	r2, [sp, #24]
    8034:	9b04      	ldr	r3, [sp, #16]
    8036:	429a      	cmp	r2, r3
    8038:	d3eb      	bcc.n	8012 <Adc_Ip_ClearLatchedTriggers+0x42>
    }
    if (ElapsedTicks >= TimeoutTicks)
    803a:	9a06      	ldr	r2, [sp, #24]
    803c:	9b04      	ldr	r3, [sp, #16]
    803e:	429a      	cmp	r2, r3
    8040:	d301      	bcc.n	8046 <Adc_Ip_ClearLatchedTriggers+0x76>
    {
        Status = ADC_IP_STATUS_TIMEOUT;
    8042:	2302      	movs	r3, #2
    8044:	9307      	str	r3, [sp, #28]
    }

    return Status;
    8046:	9b07      	ldr	r3, [sp, #28]
}
    8048:	4618      	mov	r0, r3
    804a:	b009      	add	sp, #36	; 0x24
    804c:	f85d fb04 	ldr.w	pc, [sp], #4
    8050:	00015be0 	.word	0x00015be0
    8054:	000186a0 	.word	0x000186a0

00008058 <Adc_Ip_EnableChannelNotification>:
*
* @implements     Adc_Ip_EnableChannelNotification_Activity
* END**************************************************************************/
void Adc_Ip_EnableChannelNotification(const uint32 Instance,
                                      const uint8 ControlChanIdx)
{
    8058:	b500      	push	{lr}
    805a:	b085      	sub	sp, #20
    805c:	9001      	str	r0, [sp, #4]
    805e:	460b      	mov	r3, r1
    8060:	f88d 3003 	strb.w	r3, [sp, #3]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
    DevAssert(ControlChanIdx < ADC_MAX_CHAN_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    8064:	4a0c      	ldr	r2, [pc, #48]	; (8098 <Adc_Ip_EnableChannelNotification+0x40>)
    8066:	9b01      	ldr	r3, [sp, #4]
    8068:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    806c:	9303      	str	r3, [sp, #12]

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_19();
    806e:	f006 fe1d 	bl	ecac <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_19>
    SC1(Base, ControlChanIdx) |= ADC_SC1_AIEN_MASK;
    8072:	f89d 2003 	ldrb.w	r2, [sp, #3]
    8076:	9b03      	ldr	r3, [sp, #12]
    8078:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    807c:	f89d 2003 	ldrb.w	r2, [sp, #3]
    8080:	f043 0140 	orr.w	r1, r3, #64	; 0x40
    8084:	9b03      	ldr	r3, [sp, #12]
    8086:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_19();
    808a:	f006 fe3b 	bl	ed04 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_19>
}
    808e:	bf00      	nop
    8090:	b005      	add	sp, #20
    8092:	f85d fb04 	ldr.w	pc, [sp], #4
    8096:	bf00      	nop
    8098:	00015be0 	.word	0x00015be0

0000809c <Adc_Ip_DisableChannelNotification>:
*
* @implements     Adc_Ip_DisableChannelNotification_Activity
* END**************************************************************************/
void Adc_Ip_DisableChannelNotification(const uint32 Instance,
                                       const uint8 ControlChanIdx)
{
    809c:	b500      	push	{lr}
    809e:	b085      	sub	sp, #20
    80a0:	9001      	str	r0, [sp, #4]
    80a2:	460b      	mov	r3, r1
    80a4:	f88d 3003 	strb.w	r3, [sp, #3]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
    DevAssert(ControlChanIdx < ADC_MAX_CHAN_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    80a8:	4a0c      	ldr	r2, [pc, #48]	; (80dc <Adc_Ip_DisableChannelNotification+0x40>)
    80aa:	9b01      	ldr	r3, [sp, #4]
    80ac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    80b0:	9303      	str	r3, [sp, #12]

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_20();
    80b2:	f006 fe4d 	bl	ed50 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_20>
    SC1(Base, ControlChanIdx) &= ~(ADC_SC1_AIEN_MASK);
    80b6:	f89d 2003 	ldrb.w	r2, [sp, #3]
    80ba:	9b03      	ldr	r3, [sp, #12]
    80bc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    80c0:	f89d 2003 	ldrb.w	r2, [sp, #3]
    80c4:	f023 0140 	bic.w	r1, r3, #64	; 0x40
    80c8:	9b03      	ldr	r3, [sp, #12]
    80ca:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_20();
    80ce:	f006 fe6b 	bl	eda8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_20>
}
    80d2:	bf00      	nop
    80d4:	b005      	add	sp, #20
    80d6:	f85d fb04 	ldr.w	pc, [sp], #4
    80da:	bf00      	nop
    80dc:	00015be0 	.word	0x00015be0

000080e0 <Adc_Ip_ClearTrigErrReg>:
* Description   : This function clears all trigger error flags of the ADC instance.
*
* @implements     Adc_Ip_ClearTrigErrReg_Activity
* END**************************************************************************/
void Adc_Ip_ClearTrigErrReg(const uint32 Instance)
{
    80e0:	b500      	push	{lr}
    80e2:	b085      	sub	sp, #20
    80e4:	9001      	str	r0, [sp, #4]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
    DevAssert(Instance != 0u);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    80e6:	4a0a      	ldr	r2, [pc, #40]	; (8110 <Adc_Ip_ClearTrigErrReg+0x30>)
    80e8:	9b01      	ldr	r3, [sp, #4]
    80ea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    80ee:	9303      	str	r3, [sp, #12]

    SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_25();
    80f0:	f006 ffc8 	bl	f084 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_25>
    Base->SC2 |= ADC_SC2_TRGSTERR_MASK;
    80f4:	9b03      	ldr	r3, [sp, #12]
    80f6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
    80fa:	f043 6270 	orr.w	r2, r3, #251658240	; 0xf000000
    80fe:	9b03      	ldr	r3, [sp, #12]
    8100:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_25();
    8104:	f006 ffea 	bl	f0dc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_25>
}
    8108:	bf00      	nop
    810a:	b005      	add	sp, #20
    810c:	f85d fb04 	ldr.w	pc, [sp], #4
    8110:	00015be0 	.word	0x00015be0

00008114 <Adc_Ip_GetTrigErrReg>:
* Description   : This function returns all trigger error flags of the ADC instance.
*
* @implements     Adc_Ip_GetTrigErrReg_Activity
* END**************************************************************************/
uint32 Adc_Ip_GetTrigErrReg(const uint32 Instance)
{
    8114:	b084      	sub	sp, #16
    8116:	9001      	str	r0, [sp, #4]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
    DevAssert(Instance != 0u);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    const ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    8118:	4a06      	ldr	r2, [pc, #24]	; (8134 <Adc_Ip_GetTrigErrReg+0x20>)
    811a:	9b01      	ldr	r3, [sp, #4]
    811c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8120:	9303      	str	r3, [sp, #12]

    return (Base->SC2 & ADC_SC2_TRGSTERR_MASK) >> ADC_SC2_TRGSTERR_SHIFT;
    8122:	9b03      	ldr	r3, [sp, #12]
    8124:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
    8128:	0e1b      	lsrs	r3, r3, #24
    812a:	f003 030f 	and.w	r3, r3, #15
}
    812e:	4618      	mov	r0, r3
    8130:	b004      	add	sp, #16
    8132:	4770      	bx	lr
    8134:	00015be0 	.word	0x00015be0

00008138 <Adc_Ip_GetDataAddress>:
 *
 * @implements     Adc_Ip_GetDataAddress_Activity
 *END*************************************************************************/
uint32 Adc_Ip_GetDataAddress(const uint32 Instance,
                             const uint8 Index)
{
    8138:	b082      	sub	sp, #8
    813a:	9001      	str	r0, [sp, #4]
    813c:	460b      	mov	r3, r1
    813e:	f88d 3003 	strb.w	r3, [sp, #3]
#if (ADC_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < ADC_INSTANCE_COUNT);
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */
    return (uint32)&(R(Adc_Ip_apxBase[Instance], Index));
    8142:	4a06      	ldr	r2, [pc, #24]	; (815c <Adc_Ip_GetDataAddress+0x24>)
    8144:	9b01      	ldr	r3, [sp, #4]
    8146:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    814a:	f89d 3003 	ldrb.w	r3, [sp, #3]
    814e:	3312      	adds	r3, #18
    8150:	009b      	lsls	r3, r3, #2
    8152:	4413      	add	r3, r2
}
    8154:	4618      	mov	r0, r3
    8156:	b002      	add	sp, #8
    8158:	4770      	bx	lr
    815a:	bf00      	nop
    815c:	00015be0 	.word	0x00015be0

00008160 <Adc_Ip_GetChanData>:
* @implements     Adc_Ip_GetChanData_Activity
* END**************************************************************************/
Adc_Ip_StatusType Adc_Ip_GetChanData(const uint32 Instance,
                                     const Adc_Ip_InputChannelType Channel,
                                     uint16 * const Result)
{
    8160:	b088      	sub	sp, #32
    8162:	9003      	str	r0, [sp, #12]
    8164:	9102      	str	r1, [sp, #8]
    8166:	9201      	str	r2, [sp, #4]
#if (ADC_IP_SUPPLY_MONITORING_ENABLED == STD_ON)
    DevAssert((Instance == 0u) || ((uint32)Channel < (uint32)ADC_IP_INPUTCHAN_SUPPLY_VDD));
#endif /* (ADC_IP_SUPPLY_MONITORING_ENABLED == STD_ON) */
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    const ADC_Type * const Base = Adc_Ip_apxBase[Instance];
    8168:	4a25      	ldr	r2, [pc, #148]	; (8200 <Adc_Ip_GetChanData+0xa0>)
    816a:	9b03      	ldr	r3, [sp, #12]
    816c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8170:	9305      	str	r3, [sp, #20]
    Adc_Ip_StatusType Status = ADC_IP_STATUS_SUCCESS;
    8172:	2300      	movs	r3, #0
    8174:	9307      	str	r3, [sp, #28]
    uint16 Temp = 0u;
    8176:	2300      	movs	r3, #0
    8178:	f8ad 301a 	strh.w	r3, [sp, #26]
    uint8 ControlChanIdx;
    boolean Found = FALSE;
    817c:	2300      	movs	r3, #0
    817e:	f88d 3018 	strb.w	r3, [sp, #24]

    for (ControlChanIdx = 0u; ControlChanIdx < ADC_MAX_CHAN_COUNT; ControlChanIdx++)
    8182:	2300      	movs	r3, #0
    8184:	f88d 3019 	strb.w	r3, [sp, #25]
    8188:	e019      	b.n	81be <Adc_Ip_GetChanData+0x5e>
    {
        if (Adc_Ip_axState[Instance].ChannelConfig[ControlChanIdx] == Channel)
    818a:	f89d 1019 	ldrb.w	r1, [sp, #25]
    818e:	481d      	ldr	r0, [pc, #116]	; (8204 <Adc_Ip_GetChanData+0xa4>)
    8190:	9a03      	ldr	r2, [sp, #12]
    8192:	4613      	mov	r3, r2
    8194:	00db      	lsls	r3, r3, #3
    8196:	4413      	add	r3, r2
    8198:	005b      	lsls	r3, r3, #1
    819a:	4413      	add	r3, r2
    819c:	440b      	add	r3, r1
    819e:	3302      	adds	r3, #2
    81a0:	009b      	lsls	r3, r3, #2
    81a2:	4403      	add	r3, r0
    81a4:	685b      	ldr	r3, [r3, #4]
    81a6:	9a02      	ldr	r2, [sp, #8]
    81a8:	429a      	cmp	r2, r3
    81aa:	d103      	bne.n	81b4 <Adc_Ip_GetChanData+0x54>
        {
            Found = TRUE;
    81ac:	2301      	movs	r3, #1
    81ae:	f88d 3018 	strb.w	r3, [sp, #24]
            break;
    81b2:	e008      	b.n	81c6 <Adc_Ip_GetChanData+0x66>
    for (ControlChanIdx = 0u; ControlChanIdx < ADC_MAX_CHAN_COUNT; ControlChanIdx++)
    81b4:	f89d 3019 	ldrb.w	r3, [sp, #25]
    81b8:	3301      	adds	r3, #1
    81ba:	f88d 3019 	strb.w	r3, [sp, #25]
    81be:	f89d 3019 	ldrb.w	r3, [sp, #25]
    81c2:	2b0f      	cmp	r3, #15
    81c4:	d9e1      	bls.n	818a <Adc_Ip_GetChanData+0x2a>
        }
    }

    if (Found == TRUE)
    81c6:	f89d 3018 	ldrb.w	r3, [sp, #24]
    81ca:	2b00      	cmp	r3, #0
    81cc:	d00e      	beq.n	81ec <Adc_Ip_GetChanData+0x8c>
    {
        Temp = (uint16) R(Base, ControlChanIdx);
    81ce:	f89d 2019 	ldrb.w	r2, [sp, #25]
    81d2:	9b05      	ldr	r3, [sp, #20]
    81d4:	3212      	adds	r2, #18
    81d6:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    81da:	f8ad 301a 	strh.w	r3, [sp, #26]
        Temp = (uint16) ((Temp & ADC_R_D_MASK) >> ADC_R_D_SHIFT);
    81de:	f8bd 301a 	ldrh.w	r3, [sp, #26]
    81e2:	f3c3 030b 	ubfx	r3, r3, #0, #12
    81e6:	f8ad 301a 	strh.w	r3, [sp, #26]
    81ea:	e001      	b.n	81f0 <Adc_Ip_GetChanData+0x90>
    }
    else
    {
        Status = ADC_IP_STATUS_ERROR;
    81ec:	2301      	movs	r3, #1
    81ee:	9307      	str	r3, [sp, #28]
    }

    *Result = Temp;
    81f0:	9b01      	ldr	r3, [sp, #4]
    81f2:	f8bd 201a 	ldrh.w	r2, [sp, #26]
    81f6:	801a      	strh	r2, [r3, #0]

    return Status;
    81f8:	9b07      	ldr	r3, [sp, #28]
}
    81fa:	4618      	mov	r0, r3
    81fc:	b008      	add	sp, #32
    81fe:	4770      	bx	lr
    8200:	00015be0 	.word	0x00015be0
    8204:	1fff8d00 	.word	0x1fff8d00

00008208 <Adc_Ip_IRQHandler>:
 * Note          : It's required to read result data in user notification in order to clear the COCO flags and avoid ISR getting invoked repeatedly
 *
 * @implements     Adc_Ip_IRQHandler_Activity
 *END*************************************************************************/
void Adc_Ip_IRQHandler(const uint32 Instance)
{
    8208:	b500      	push	{lr}
    820a:	b085      	sub	sp, #20
    820c:	9001      	str	r0, [sp, #4]
#endif /* (ADC_IP_DEV_ERROR_DETECT == STD_ON) */

    uint8 ControlChanIdx;
#if (ADC_IP_AIEN_INTERRUPT_ENABLE == STD_ON)
    uint32 Sc1Reg;
    boolean ChanIntFlag = FALSE;
    820e:	2300      	movs	r3, #0
    8210:	f88d 300e 	strb.w	r3, [sp, #14]
    boolean ChanCocoFlag = FALSE;
    8214:	2300      	movs	r3, #0
    8216:	f88d 300d 	strb.w	r3, [sp, #13]

    /* Check whether the respective driver is initialized */
    if (TRUE == Adc_Ip_axState[Instance].Init)
    821a:	4a32      	ldr	r2, [pc, #200]	; (82e4 <Adc_Ip_IRQHandler+0xdc>)
    821c:	9b01      	ldr	r3, [sp, #4]
    821e:	214c      	movs	r1, #76	; 0x4c
    8220:	fb01 f303 	mul.w	r3, r1, r3
    8224:	4413      	add	r3, r2
    8226:	781b      	ldrb	r3, [r3, #0]
    8228:	2b00      	cmp	r3, #0
    822a:	d040      	beq.n	82ae <Adc_Ip_IRQHandler+0xa6>
    {
        /* Check if the callback is not NULL since all channels use the same one (to avoid checking inside the loop) */
        if (Adc_Ip_axState[Instance].ConversionCompleteNotification != NULL_PTR)
    822c:	4a2d      	ldr	r2, [pc, #180]	; (82e4 <Adc_Ip_IRQHandler+0xdc>)
    822e:	9b01      	ldr	r3, [sp, #4]
    8230:	214c      	movs	r1, #76	; 0x4c
    8232:	fb01 f303 	mul.w	r3, r1, r3
    8236:	4413      	add	r3, r2
    8238:	3308      	adds	r3, #8
    823a:	681b      	ldr	r3, [r3, #0]
    823c:	2b00      	cmp	r3, #0
    823e:	d04d      	beq.n	82dc <Adc_Ip_IRQHandler+0xd4>
        {
            for (ControlChanIdx = 0u; ControlChanIdx < ADC_MAX_CHAN_COUNT; ControlChanIdx++)
    8240:	2300      	movs	r3, #0
    8242:	f88d 300f 	strb.w	r3, [sp, #15]
    8246:	e02d      	b.n	82a4 <Adc_Ip_IRQHandler+0x9c>
            {
                Sc1Reg = SC1(Adc_Ip_apxBase[Instance], ControlChanIdx);
    8248:	4a27      	ldr	r2, [pc, #156]	; (82e8 <Adc_Ip_IRQHandler+0xe0>)
    824a:	9b01      	ldr	r3, [sp, #4]
    824c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8250:	f89d 200f 	ldrb.w	r2, [sp, #15]
    8254:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    8258:	9302      	str	r3, [sp, #8]
                ChanIntFlag = Adc_HwAcc_GetAIEN(Sc1Reg);
    825a:	9802      	ldr	r0, [sp, #8]
    825c:	f7ff fa20 	bl	76a0 <Adc_HwAcc_GetAIEN>
    8260:	4603      	mov	r3, r0
    8262:	f88d 300e 	strb.w	r3, [sp, #14]
                ChanCocoFlag = Adc_HwAcc_GetCOCO(Sc1Reg);
    8266:	9802      	ldr	r0, [sp, #8]
    8268:	f7ff fa28 	bl	76bc <Adc_HwAcc_GetCOCO>
    826c:	4603      	mov	r3, r0
    826e:	f88d 300d 	strb.w	r3, [sp, #13]
                /* CPR_RTD_00664
                 * Check if the interrupt not spurious (the interrupt is enabled and equivalent conversion has finished)
                 * Ignore spurious ones (return immediately from ISR)
                 */
                if ((TRUE == ChanIntFlag) && (TRUE == ChanCocoFlag))
    8272:	f89d 300e 	ldrb.w	r3, [sp, #14]
    8276:	2b00      	cmp	r3, #0
    8278:	d00f      	beq.n	829a <Adc_Ip_IRQHandler+0x92>
    827a:	f89d 300d 	ldrb.w	r3, [sp, #13]
    827e:	2b00      	cmp	r3, #0
    8280:	d00b      	beq.n	829a <Adc_Ip_IRQHandler+0x92>
                {
                    /* Call the associated callback.
                     * The COCO flag will be cleared by reading the respective result data register in the callback
                     */
                    Adc_Ip_axState[Instance].ConversionCompleteNotification(ControlChanIdx);
    8282:	4a18      	ldr	r2, [pc, #96]	; (82e4 <Adc_Ip_IRQHandler+0xdc>)
    8284:	9b01      	ldr	r3, [sp, #4]
    8286:	214c      	movs	r1, #76	; 0x4c
    8288:	fb01 f303 	mul.w	r3, r1, r3
    828c:	4413      	add	r3, r2
    828e:	3308      	adds	r3, #8
    8290:	681b      	ldr	r3, [r3, #0]
    8292:	f89d 200f 	ldrb.w	r2, [sp, #15]
    8296:	4610      	mov	r0, r2
    8298:	4798      	blx	r3
            for (ControlChanIdx = 0u; ControlChanIdx < ADC_MAX_CHAN_COUNT; ControlChanIdx++)
    829a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    829e:	3301      	adds	r3, #1
    82a0:	f88d 300f 	strb.w	r3, [sp, #15]
    82a4:	f89d 300f 	ldrb.w	r3, [sp, #15]
    82a8:	2b0f      	cmp	r3, #15
    82aa:	d9cd      	bls.n	8248 <Adc_Ip_IRQHandler+0x40>
        {
            /* Do a dummy read to clear the COCO flags */
            (void)Adc_HwAcc_GetData(Adc_Ip_apxBase[Instance], ControlChanIdx);
        }
    }
}
    82ac:	e016      	b.n	82dc <Adc_Ip_IRQHandler+0xd4>
        for (ControlChanIdx = 0u; ControlChanIdx < ADC_MAX_CHAN_COUNT; ControlChanIdx++)
    82ae:	2300      	movs	r3, #0
    82b0:	f88d 300f 	strb.w	r3, [sp, #15]
    82b4:	e00e      	b.n	82d4 <Adc_Ip_IRQHandler+0xcc>
            (void)Adc_HwAcc_GetData(Adc_Ip_apxBase[Instance], ControlChanIdx);
    82b6:	4a0c      	ldr	r2, [pc, #48]	; (82e8 <Adc_Ip_IRQHandler+0xe0>)
    82b8:	9b01      	ldr	r3, [sp, #4]
    82ba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    82be:	f89d 200f 	ldrb.w	r2, [sp, #15]
    82c2:	4611      	mov	r1, r2
    82c4:	4618      	mov	r0, r3
    82c6:	f7ff fa07 	bl	76d8 <Adc_HwAcc_GetData>
        for (ControlChanIdx = 0u; ControlChanIdx < ADC_MAX_CHAN_COUNT; ControlChanIdx++)
    82ca:	f89d 300f 	ldrb.w	r3, [sp, #15]
    82ce:	3301      	adds	r3, #1
    82d0:	f88d 300f 	strb.w	r3, [sp, #15]
    82d4:	f89d 300f 	ldrb.w	r3, [sp, #15]
    82d8:	2b0f      	cmp	r3, #15
    82da:	d9ec      	bls.n	82b6 <Adc_Ip_IRQHandler+0xae>
}
    82dc:	bf00      	nop
    82de:	b005      	add	sp, #20
    82e0:	f85d fb04 	ldr.w	pc, [sp], #4
    82e4:	1fff8d00 	.word	0x1fff8d00
    82e8:	00015be0 	.word	0x00015be0

000082ec <Adc_0_Isr>:
==================================================================================================*/
#define ADC_START_SEC_CODE
#include "Adc_MemMap.h"

ISR(Adc_0_Isr)
{
    82ec:	b508      	push	{r3, lr}
    /* Call IRQ handler with the correct instance */
    Adc_Ip_IRQHandler(0UL);
    82ee:	2000      	movs	r0, #0
    82f0:	f7ff ff8a 	bl	8208 <Adc_Ip_IRQHandler>

    EXIT_INTERRUPT();
    82f4:	f3bf 8f4f 	dsb	sy
}
    82f8:	bf00      	nop
    82fa:	bd08      	pop	{r3, pc}

000082fc <Adc_1_Isr>:

#if (ADC_INSTANCE_COUNT > 1)
ISR(Adc_1_Isr)
{
    82fc:	b508      	push	{r3, lr}
    /* Call IRQ handler with the correct instance */
    Adc_Ip_IRQHandler(1UL);
    82fe:	2001      	movs	r0, #1
    8300:	f7ff ff82 	bl	8208 <Adc_Ip_IRQHandler>

    EXIT_INTERRUPT();
    8304:	f3bf 8f4f 	dsb	sy
}
    8308:	bf00      	nop
    830a:	bd08      	pop	{r3, pc}

0000830c <Can_IsControllersBusy>:
        }
    }
#endif /* CAN_43_FLEXCAN_MAINFUNCTION_MULTIPLE_READ == STD_ON */

static boolean Can_IsControllersBusy(uint32 u32CoreId)
{
    830c:	b084      	sub	sp, #16
    830e:	9001      	str	r0, [sp, #4]
    boolean bCtrlBusy = FALSE;
    8310:	2300      	movs	r3, #0
    8312:	f88d 300f 	strb.w	r3, [sp, #15]
    uint8 u8ControllerID = 0U;
    8316:	2300      	movs	r3, #0
    8318:	f88d 300e 	strb.w	r3, [sp, #14]

    for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    831c:	2300      	movs	r3, #0
    831e:	f88d 300e 	strb.w	r3, [sp, #14]
    8322:	e01b      	b.n	835c <Can_IsControllersBusy+0x50>
    {
        if (NULL_PTR != (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID])
    8324:	4a12      	ldr	r2, [pc, #72]	; (8370 <Can_IsControllersBusy+0x64>)
    8326:	9b01      	ldr	r3, [sp, #4]
    8328:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    832c:	695a      	ldr	r2, [r3, #20]
    832e:	f89d 300e 	ldrb.w	r3, [sp, #14]
    8332:	009b      	lsls	r3, r3, #2
    8334:	4413      	add	r3, r2
    8336:	681b      	ldr	r3, [r3, #0]
    8338:	2b00      	cmp	r3, #0
    833a:	d00a      	beq.n	8352 <Can_IsControllersBusy+0x46>
        {
            if (CAN_CS_UNINIT != Can_eControllerState[u8ControllerID])
    833c:	f89d 300e 	ldrb.w	r3, [sp, #14]
    8340:	4a0c      	ldr	r2, [pc, #48]	; (8374 <Can_IsControllersBusy+0x68>)
    8342:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8346:	2b00      	cmp	r3, #0
    8348:	d003      	beq.n	8352 <Can_IsControllersBusy+0x46>
                *   The function Can_Init shall raise the error CAN_E_TRANSITION if the CAN
                *   controllers are not in state UNINIT.
                */
                (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_INIT, CAN_43_FLEXCAN_E_TRANSITION);
            #endif
                bCtrlBusy = TRUE;
    834a:	2301      	movs	r3, #1
    834c:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    8350:	e008      	b.n	8364 <Can_IsControllersBusy+0x58>
    for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    8352:	f89d 300e 	ldrb.w	r3, [sp, #14]
    8356:	3301      	adds	r3, #1
    8358:	f88d 300e 	strb.w	r3, [sp, #14]
    835c:	f89d 300e 	ldrb.w	r3, [sp, #14]
    8360:	2b00      	cmp	r3, #0
    8362:	d0df      	beq.n	8324 <Can_IsControllersBusy+0x18>
            }
        }
    }

    return bCtrlBusy;
    8364:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    8368:	4618      	mov	r0, r3
    836a:	b004      	add	sp, #16
    836c:	4770      	bx	lr
    836e:	bf00      	nop
    8370:	1fff8da0 	.word	0x1fff8da0
    8374:	1fff8d9c 	.word	0x1fff8d9c

00008378 <Can_InitControllers>:

static void Can_InitControllers(uint32 u32CoreId)
{
    8378:	b500      	push	{lr}
    837a:	b085      	sub	sp, #20
    837c:	9001      	str	r0, [sp, #4]
    boolean bCtrlBusy = FALSE;
    837e:	2300      	movs	r3, #0
    8380:	f88d 300f 	strb.w	r3, [sp, #15]
    uint8 u8ControllerID = 0U;
    8384:	2300      	movs	r3, #0
    8386:	f88d 300e 	strb.w	r3, [sp, #14]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    838a:	2300      	movs	r3, #0
    838c:	9302      	str	r3, [sp, #8]

    /* Loop through all Can controllers configured based CanControllerId parameter. */
    for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    838e:	2300      	movs	r3, #0
    8390:	f88d 300e 	strb.w	r3, [sp, #14]
    8394:	e035      	b.n	8402 <Can_InitControllers+0x8a>
    {
        if (NULL_PTR != (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID])
    8396:	4a30      	ldr	r2, [pc, #192]	; (8458 <Can_InitControllers+0xe0>)
    8398:	9b01      	ldr	r3, [sp, #4]
    839a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    839e:	695a      	ldr	r2, [r3, #20]
    83a0:	f89d 300e 	ldrb.w	r3, [sp, #14]
    83a4:	009b      	lsls	r3, r3, #2
    83a6:	4413      	add	r3, r2
    83a8:	681b      	ldr	r3, [r3, #0]
    83aa:	2b00      	cmp	r3, #0
    83ac:	d024      	beq.n	83f8 <Can_InitControllers+0x80>
        {
            Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID];
    83ae:	4a2a      	ldr	r2, [pc, #168]	; (8458 <Can_InitControllers+0xe0>)
    83b0:	9b01      	ldr	r3, [sp, #4]
    83b2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    83b6:	695a      	ldr	r2, [r3, #20]
    83b8:	f89d 300e 	ldrb.w	r3, [sp, #14]
    83bc:	009b      	lsls	r3, r3, #2
    83be:	4413      	add	r3, r2
    83c0:	681b      	ldr	r3, [r3, #0]
    83c2:	9302      	str	r3, [sp, #8]
            /* The initialization is skipped for the controllers that are not enabled. */
            if (TRUE == Can_pController->Can_bActivation)
    83c4:	9b02      	ldr	r3, [sp, #8]
    83c6:	7a1b      	ldrb	r3, [r3, #8]
    83c8:	2b00      	cmp	r3, #0
    83ca:	d015      	beq.n	83f8 <Can_InitControllers+0x80>
                */
            #if ((CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON) || (CAN_43_FLEXCAN_DUAL_CLOCK_MODE == STD_ON))
                Can_au16BaudrateIDConfig[u8ControllerID] = Can_pController->Can_u16DefaultBaudrateID;
            #endif
                /* Reset interrupt level to default value after re-init */
                Can_au8DisableInterruptLevel[u8ControllerID] = 0U;
    83cc:	f89d 300e 	ldrb.w	r3, [sp, #14]
    83d0:	4a22      	ldr	r2, [pc, #136]	; (845c <Can_InitControllers+0xe4>)
    83d2:	2100      	movs	r1, #0
    83d4:	54d1      	strb	r1, [r2, r3]
            #if (CAN_43_FLEXCAN_PUBLIC_ICOM_SUPPORT == STD_ON)
                Can_apxCtrlConfigIcomIndex[u8ControllerID] = NULL_PTR;
            #endif
                /* Init the controller */
                if ((Std_ReturnType)E_OK == Can_43_FLEXCAN_Ipw_Init(Can_pController))
    83d6:	9802      	ldr	r0, [sp, #8]
    83d8:	f000 ff78 	bl	92cc <Can_43_FLEXCAN_Ipw_Init>
    83dc:	4603      	mov	r3, r0
    83de:	2b00      	cmp	r3, #0
    83e0:	d106      	bne.n	83f0 <Can_InitControllers+0x78>
                {
                    Can_eControllerState[u8ControllerID] = CAN_CS_STOPPED;
    83e2:	f89d 300e 	ldrb.w	r3, [sp, #14]
    83e6:	4a1e      	ldr	r2, [pc, #120]	; (8460 <Can_InitControllers+0xe8>)
    83e8:	2102      	movs	r1, #2
    83ea:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
    83ee:	e003      	b.n	83f8 <Can_InitControllers+0x80>
                else
                {
                    #if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
                    (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_INIT, CAN_43_FLEXCAN_E_INIT_FAILED);
                    #endif
                    bCtrlBusy = TRUE;
    83f0:	2301      	movs	r3, #1
    83f2:	f88d 300f 	strb.w	r3, [sp, #15]
                    break;
    83f6:	e008      	b.n	840a <Can_InitControllers+0x92>
    for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    83f8:	f89d 300e 	ldrb.w	r3, [sp, #14]
    83fc:	3301      	adds	r3, #1
    83fe:	f88d 300e 	strb.w	r3, [sp, #14]
    8402:	f89d 300e 	ldrb.w	r3, [sp, #14]
    8406:	2b00      	cmp	r3, #0
    8408:	d0c5      	beq.n	8396 <Can_InitControllers+0x1e>
    }
    /*
    *  [SWS_Can_00246] After initializing all controllers inside the HW Unit, the function Can_Init
    *   shall change the module state to CAN_READY.
    */
    if (TRUE == bCtrlBusy)
    840a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    840e:	2b00      	cmp	r3, #0
    8410:	d01e      	beq.n	8450 <Can_InitControllers+0xd8>
    {
        /* Init failed due to one or more controllers failed, reset status of all  core's current controllers */
        for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    8412:	2300      	movs	r3, #0
    8414:	f88d 300e 	strb.w	r3, [sp, #14]
    8418:	e016      	b.n	8448 <Can_InitControllers+0xd0>
        {
            if (NULL_PTR != (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID])
    841a:	4a0f      	ldr	r2, [pc, #60]	; (8458 <Can_InitControllers+0xe0>)
    841c:	9b01      	ldr	r3, [sp, #4]
    841e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8422:	695a      	ldr	r2, [r3, #20]
    8424:	f89d 300e 	ldrb.w	r3, [sp, #14]
    8428:	009b      	lsls	r3, r3, #2
    842a:	4413      	add	r3, r2
    842c:	681b      	ldr	r3, [r3, #0]
    842e:	2b00      	cmp	r3, #0
    8430:	d005      	beq.n	843e <Can_InitControllers+0xc6>
            {
                Can_eControllerState[u8ControllerID] = CAN_CS_UNINIT;
    8432:	f89d 300e 	ldrb.w	r3, [sp, #14]
    8436:	4a0a      	ldr	r2, [pc, #40]	; (8460 <Can_InitControllers+0xe8>)
    8438:	2100      	movs	r1, #0
    843a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    843e:	f89d 300e 	ldrb.w	r3, [sp, #14]
    8442:	3301      	adds	r3, #1
    8444:	f88d 300e 	strb.w	r3, [sp, #14]
    8448:	f89d 300e 	ldrb.w	r3, [sp, #14]
    844c:	2b00      	cmp	r3, #0
    844e:	d0e4      	beq.n	841a <Can_InitControllers+0xa2>
    else
    {
        Can_eDriverStatus[u32CoreId] = CAN_43_FLEXCAN_READY;
    }
#endif
}
    8450:	bf00      	nop
    8452:	b005      	add	sp, #20
    8454:	f85d fb04 	ldr.w	pc, [sp], #4
    8458:	1fff8da0 	.word	0x1fff8da0
    845c:	1fff8d98 	.word	0x1fff8d98
    8460:	1fff8d9c 	.word	0x1fff8d9c

00008464 <Can_DeInitControllers>:
    return bResult;
}
#endif

static void Can_DeInitControllers(uint32 u32CoreId)
{
    8464:	b500      	push	{lr}
    8466:	b085      	sub	sp, #20
    8468:	9001      	str	r0, [sp, #4]
    uint8 u8ControllerID = 0U;
    846a:	2300      	movs	r3, #0
    846c:	f88d 300f 	strb.w	r3, [sp, #15]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    8470:	2300      	movs	r3, #0
    8472:	9302      	str	r3, [sp, #8]

    /* Loop through all Can controllers configured based CanControllerId parameter. */
    for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    8474:	2300      	movs	r3, #0
    8476:	f88d 300f 	strb.w	r3, [sp, #15]
    847a:	e028      	b.n	84ce <Can_DeInitControllers+0x6a>
    {
        if (NULL_PTR != (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID])
    847c:	4a18      	ldr	r2, [pc, #96]	; (84e0 <Can_DeInitControllers+0x7c>)
    847e:	9b01      	ldr	r3, [sp, #4]
    8480:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8484:	695a      	ldr	r2, [r3, #20]
    8486:	f89d 300f 	ldrb.w	r3, [sp, #15]
    848a:	009b      	lsls	r3, r3, #2
    848c:	4413      	add	r3, r2
    848e:	681b      	ldr	r3, [r3, #0]
    8490:	2b00      	cmp	r3, #0
    8492:	d017      	beq.n	84c4 <Can_DeInitControllers+0x60>
        {
            Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID];
    8494:	4a12      	ldr	r2, [pc, #72]	; (84e0 <Can_DeInitControllers+0x7c>)
    8496:	9b01      	ldr	r3, [sp, #4]
    8498:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    849c:	695a      	ldr	r2, [r3, #20]
    849e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    84a2:	009b      	lsls	r3, r3, #2
    84a4:	4413      	add	r3, r2
    84a6:	681b      	ldr	r3, [r3, #0]
    84a8:	9302      	str	r3, [sp, #8]
            /* The initialization is skipped for the controllers that are not enabled. */
            if (TRUE == Can_pController->Can_bActivation)
    84aa:	9b02      	ldr	r3, [sp, #8]
    84ac:	7a1b      	ldrb	r3, [r3, #8]
    84ae:	2b00      	cmp	r3, #0
    84b0:	d008      	beq.n	84c4 <Can_DeInitControllers+0x60>
            {
                Can_eControllerState[u8ControllerID] = CAN_CS_UNINIT;
    84b2:	f89d 300f 	ldrb.w	r3, [sp, #15]
    84b6:	4a0b      	ldr	r2, [pc, #44]	; (84e4 <Can_DeInitControllers+0x80>)
    84b8:	2100      	movs	r1, #0
    84ba:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                Can_43_FLEXCAN_Ipw_DeInit(Can_pController);
    84be:	9802      	ldr	r0, [sp, #8]
    84c0:	f001 f80a 	bl	94d8 <Can_43_FLEXCAN_Ipw_DeInit>
    for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    84c4:	f89d 300f 	ldrb.w	r3, [sp, #15]
    84c8:	3301      	adds	r3, #1
    84ca:	f88d 300f 	strb.w	r3, [sp, #15]
    84ce:	f89d 300f 	ldrb.w	r3, [sp, #15]
    84d2:	2b00      	cmp	r3, #0
    84d4:	d0d2      	beq.n	847c <Can_DeInitControllers+0x18>
            }
        }
    }
}
    84d6:	bf00      	nop
    84d8:	bf00      	nop
    84da:	b005      	add	sp, #20
    84dc:	f85d fb04 	ldr.w	pc, [sp], #4
    84e0:	1fff8da0 	.word	0x1fff8da0
    84e4:	1fff8d9c 	.word	0x1fff8d9c

000084e8 <Can_43_FLEXCAN_Init>:
* @api
*/

/* implements     Can_Init_Activity */
void Can_43_FLEXCAN_Init(const Can_43_FLEXCAN_ConfigType * Config)
{
    84e8:	b500      	push	{lr}
    84ea:	b085      	sub	sp, #20
    84ec:	9001      	str	r0, [sp, #4]
    uint32 u32CoreId = 0U;
    84ee:	2300      	movs	r3, #0
    84f0:	9303      	str	r3, [sp, #12]
    boolean bCtrlBusy = FALSE;
    84f2:	2300      	movs	r3, #0
    84f4:	f88d 300b 	strb.w	r3, [sp, #11]
#if (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON)
    boolean bValidCoreID = FALSE;
#endif

    u32CoreId = Can_GetCoreID();
    84f8:	2300      	movs	r3, #0
    84fa:	9303      	str	r3, [sp, #12]
        #if (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON)
            if (u32CoreId == Config->Can_u32CoreID)
            {
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
                /* Copy pointer to current Can Driver configuration. */
                Can_apxConfig[u32CoreId] = Config;
    84fc:	490c      	ldr	r1, [pc, #48]	; (8530 <Can_43_FLEXCAN_Init+0x48>)
    84fe:	9b03      	ldr	r3, [sp, #12]
    8500:	9a01      	ldr	r2, [sp, #4]
    8502:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
            if (TRUE == bValidCoreID)
            {
#endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
                /* Fault Injection point to allow to test SWS_Can_00408 */
                MCAL_FAULT_INJECTION_POINT(CAN_FIP_1_CHANGE_DRIVER_TO_UNINITIALIZED);
                bCtrlBusy = Can_IsControllersBusy(u32CoreId);
    8506:	9803      	ldr	r0, [sp, #12]
    8508:	f7ff ff00 	bl	830c <Can_IsControllersBusy>
    850c:	4603      	mov	r3, r0
    850e:	f88d 300b 	strb.w	r3, [sp, #11]
                if (FALSE == bCtrlBusy)
    8512:	f89d 300b 	ldrb.w	r3, [sp, #11]
    8516:	f083 0301 	eor.w	r3, r3, #1
    851a:	b2db      	uxtb	r3, r3
    851c:	2b00      	cmp	r3, #0
    851e:	d002      	beq.n	8526 <Can_43_FLEXCAN_Init+0x3e>
                {
                    Can_InitControllers(u32CoreId);
    8520:	9803      	ldr	r0, [sp, #12]
    8522:	f7ff ff29 	bl	8378 <Can_InitControllers>

#if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
        }
    }
#endif /* (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON) */
}
    8526:	bf00      	nop
    8528:	b005      	add	sp, #20
    852a:	f85d fb04 	ldr.w	pc, [sp], #4
    852e:	bf00      	nop
    8530:	1fff8da0 	.word	0x1fff8da0

00008534 <Can_43_FLEXCAN_DeInit>:
* @post           Can_DeInit shall de-initialize all the controllers and set the driver in UNINIT state.
*
*/
/* implements     Can_DeInit_Activity */
void Can_43_FLEXCAN_DeInit(void)
{
    8534:	b500      	push	{lr}
    8536:	b083      	sub	sp, #12
    /* Variable for indexing the controllers. */
    uint8 u8ControllerID = 0U;
    8538:	2300      	movs	r3, #0
    853a:	f88d 3007 	strb.w	r3, [sp, #7]
    boolean bCtrlBusy = FALSE;
    853e:	2300      	movs	r3, #0
    8540:	f88d 3006 	strb.w	r3, [sp, #6]
    uint32 u32CoreId = 0U;
    8544:	2300      	movs	r3, #0
    8546:	9300      	str	r3, [sp, #0]

    u32CoreId = Can_GetCoreID();
    8548:	2300      	movs	r3, #0
    854a:	9300      	str	r3, [sp, #0]
    }
    else
    {
#endif
        /* Loop through all Can controllers configured based CanControllerId parameter. */
        for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    854c:	2300      	movs	r3, #0
    854e:	f88d 3007 	strb.w	r3, [sp, #7]
    8552:	e01b      	b.n	858c <Can_43_FLEXCAN_DeInit+0x58>
        {
            if (NULL_PTR != (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID])
    8554:	4a19      	ldr	r2, [pc, #100]	; (85bc <Can_43_FLEXCAN_DeInit+0x88>)
    8556:	9b00      	ldr	r3, [sp, #0]
    8558:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    855c:	695a      	ldr	r2, [r3, #20]
    855e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8562:	009b      	lsls	r3, r3, #2
    8564:	4413      	add	r3, r2
    8566:	681b      	ldr	r3, [r3, #0]
    8568:	2b00      	cmp	r3, #0
    856a:	d00a      	beq.n	8582 <Can_43_FLEXCAN_DeInit+0x4e>
            {
                if (CAN_CS_STARTED == Can_eControllerState[u8ControllerID])
    856c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8570:	4a13      	ldr	r2, [pc, #76]	; (85c0 <Can_43_FLEXCAN_DeInit+0x8c>)
    8572:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8576:	2b01      	cmp	r3, #1
    8578:	d103      	bne.n	8582 <Can_43_FLEXCAN_DeInit+0x4e>
                    *   if any of the CAN controllers is in state STARTED.
                    */
                    (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, (uint8)CAN_43_FLEXCAN_INSTANCE, (uint8)CAN_43_FLEXCAN_SID_DEINIT, (uint8)CAN_43_FLEXCAN_E_TRANSITION);
                #endif
                    /* Controller is busy */
                    bCtrlBusy =  TRUE;
    857a:	2301      	movs	r3, #1
    857c:	f88d 3006 	strb.w	r3, [sp, #6]
                    /* Skipping the loop if any of Can Controller is in state STARTED */
                    break;
    8580:	e008      	b.n	8594 <Can_43_FLEXCAN_DeInit+0x60>
        for (u8ControllerID = 0U; u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT; u8ControllerID++)
    8582:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8586:	3301      	adds	r3, #1
    8588:	f88d 3007 	strb.w	r3, [sp, #7]
    858c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8590:	2b00      	cmp	r3, #0
    8592:	d0df      	beq.n	8554 <Can_43_FLEXCAN_DeInit+0x20>
                }
            }
        }
        /* All Controllers are not busy */
        if (FALSE == bCtrlBusy)
    8594:	f89d 3006 	ldrb.w	r3, [sp, #6]
    8598:	f083 0301 	eor.w	r3, r3, #1
    859c:	b2db      	uxtb	r3, r3
    859e:	2b00      	cmp	r3, #0
    85a0:	d007      	beq.n	85b2 <Can_43_FLEXCAN_DeInit+0x7e>
            *   [SWS_Can_91010] The function Can_DeInit shall change the module state to
            *   CAN_UNINIT before de-initializing all controllers inside the HW unit
            */
            Can_eDriverStatus[u32CoreId] = CAN_43_FLEXCAN_UNINIT;
        #endif
            Can_DeInitControllers(u32CoreId);
    85a2:	9800      	ldr	r0, [sp, #0]
    85a4:	f7ff ff5e 	bl	8464 <Can_DeInitControllers>
            Can_apxConfig[u32CoreId] = NULL_PTR;
    85a8:	4a04      	ldr	r2, [pc, #16]	; (85bc <Can_43_FLEXCAN_DeInit+0x88>)
    85aa:	9b00      	ldr	r3, [sp, #0]
    85ac:	2100      	movs	r1, #0
    85ae:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
        }
#if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
    }
#endif
}
    85b2:	bf00      	nop
    85b4:	b003      	add	sp, #12
    85b6:	f85d fb04 	ldr.w	pc, [sp], #4
    85ba:	bf00      	nop
    85bc:	1fff8da0 	.word	0x1fff8da0
    85c0:	1fff8d9c 	.word	0x1fff8d9c

000085c4 <Can_43_FLEXCAN_SetControllerMode>:
*
* @api
*/
/* implements     Can_SetControllerMode_Activity */
Std_ReturnType Can_43_FLEXCAN_SetControllerMode(uint8 Controller, Can_ControllerStateType Transition)
{
    85c4:	b500      	push	{lr}
    85c6:	b087      	sub	sp, #28
    85c8:	4603      	mov	r3, r0
    85ca:	9100      	str	r1, [sp, #0]
    85cc:	f88d 3007 	strb.w	r3, [sp, #7]
    Std_ReturnType eRetVal = E_NOT_OK;
    85d0:	2301      	movs	r3, #1
    85d2:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32 u32CoreId = 0U;
    85d6:	2300      	movs	r3, #0
    85d8:	9304      	str	r3, [sp, #16]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    85da:	2300      	movs	r3, #0
    85dc:	9303      	str	r3, [sp, #12]

    u32CoreId = Can_GetCoreID();
    85de:	2300      	movs	r3, #0
    85e0:	9304      	str	r3, [sp, #16]
#if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
    if (TRUE == Can_ValidateController(u32CoreId, Controller, CAN_43_FLEXCAN_SID_SET_CONTROLLER_MODE))
    {
#endif
                Can_pController = (const Can_43_FLEXCAN_ControllerConfigType *)(Can_apxConfig[u32CoreId])->Can_ppController[Controller];
    85e2:	4a47      	ldr	r2, [pc, #284]	; (8700 <Can_43_FLEXCAN_SetControllerMode+0x13c>)
    85e4:	9b04      	ldr	r3, [sp, #16]
    85e6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    85ea:	695a      	ldr	r2, [r3, #20]
    85ec:	f89d 3007 	ldrb.w	r3, [sp, #7]
    85f0:	009b      	lsls	r3, r3, #2
    85f2:	4413      	add	r3, r2
    85f4:	681b      	ldr	r3, [r3, #0]
    85f6:	9303      	str	r3, [sp, #12]
                /*
                *   [SWS_Can_00017] The function Can_SetControllerMode shall perform software
                *   triggered state transitions of the CAN controller State machine.
                */
                switch (Transition)
    85f8:	9b00      	ldr	r3, [sp, #0]
    85fa:	2b03      	cmp	r3, #3
    85fc:	d05d      	beq.n	86ba <Can_43_FLEXCAN_SetControllerMode+0xf6>
    85fe:	9b00      	ldr	r3, [sp, #0]
    8600:	2b03      	cmp	r3, #3
    8602:	d874      	bhi.n	86ee <Can_43_FLEXCAN_SetControllerMode+0x12a>
    8604:	9b00      	ldr	r3, [sp, #0]
    8606:	2b01      	cmp	r3, #1
    8608:	d003      	beq.n	8612 <Can_43_FLEXCAN_SetControllerMode+0x4e>
    860a:	9b00      	ldr	r3, [sp, #0]
    860c:	2b02      	cmp	r3, #2
    860e:	d01d      	beq.n	864c <Can_43_FLEXCAN_SetControllerMode+0x88>
                        *   has been requested, the function Can_SetControllerMode shall raise the error CAN_E_TRANSITION and
                        *   return E_NOT_OK
                        */
                        (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_SET_CONTROLLER_MODE, CAN_43_FLEXCAN_E_TRANSITION);
                    #endif
                        break;
    8610:	e06d      	b.n	86ee <Can_43_FLEXCAN_SetControllerMode+0x12a>
                        if (CAN_CS_STOPPED == Can_eControllerState[Controller])
    8612:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8616:	4a3b      	ldr	r2, [pc, #236]	; (8704 <Can_43_FLEXCAN_SetControllerMode+0x140>)
    8618:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    861c:	2b02      	cmp	r3, #2
    861e:	d168      	bne.n	86f2 <Can_43_FLEXCAN_SetControllerMode+0x12e>
                            if ((Std_ReturnType)E_OK == Can_43_FLEXCAN_Ipw_SetControllerToStartMode(Can_pController))
    8620:	9803      	ldr	r0, [sp, #12]
    8622:	f000 ff93 	bl	954c <Can_43_FLEXCAN_Ipw_SetControllerToStartMode>
    8626:	4603      	mov	r3, r0
    8628:	2b00      	cmp	r3, #0
    862a:	d162      	bne.n	86f2 <Can_43_FLEXCAN_SetControllerMode+0x12e>
                                Can_eControllerState[Controller] = CAN_CS_STARTED;
    862c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8630:	4a34      	ldr	r2, [pc, #208]	; (8704 <Can_43_FLEXCAN_SetControllerMode+0x140>)
    8632:	2101      	movs	r1, #1
    8634:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                                CanIf_ControllerModeIndication(Can_pController->Can_u8AbstControllerID, CAN_CS_STARTED);
    8638:	9b03      	ldr	r3, [sp, #12]
    863a:	781b      	ldrb	r3, [r3, #0]
    863c:	2101      	movs	r1, #1
    863e:	4618      	mov	r0, r3
    8640:	f00c f86a 	bl	14718 <CanIf_ControllerModeIndication>
                                eRetVal = E_OK;
    8644:	2300      	movs	r3, #0
    8646:	f88d 3017 	strb.w	r3, [sp, #23]
                        break;
    864a:	e052      	b.n	86f2 <Can_43_FLEXCAN_SetControllerMode+0x12e>
                        switch (Can_eControllerState[Controller])
    864c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8650:	4a2c      	ldr	r2, [pc, #176]	; (8704 <Can_43_FLEXCAN_SetControllerMode+0x140>)
    8652:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8656:	2b01      	cmp	r3, #1
    8658:	d005      	beq.n	8666 <Can_43_FLEXCAN_SetControllerMode+0xa2>
    865a:	2b00      	cmp	r3, #0
    865c:	d029      	beq.n	86b2 <Can_43_FLEXCAN_SetControllerMode+0xee>
    865e:	3b02      	subs	r3, #2
    8660:	2b01      	cmp	r3, #1
    8662:	d826      	bhi.n	86b2 <Can_43_FLEXCAN_SetControllerMode+0xee>
    8664:	e015      	b.n	8692 <Can_43_FLEXCAN_SetControllerMode+0xce>
                                if ((Std_ReturnType)E_OK == Can_43_FLEXCAN_Ipw_SetControllerToStopMode(Can_pController))
    8666:	9803      	ldr	r0, [sp, #12]
    8668:	f000 ffde 	bl	9628 <Can_43_FLEXCAN_Ipw_SetControllerToStopMode>
    866c:	4603      	mov	r3, r0
    866e:	2b00      	cmp	r3, #0
    8670:	d121      	bne.n	86b6 <Can_43_FLEXCAN_SetControllerMode+0xf2>
                                    Can_eControllerState[Controller] = CAN_CS_STOPPED;
    8672:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8676:	4a23      	ldr	r2, [pc, #140]	; (8704 <Can_43_FLEXCAN_SetControllerMode+0x140>)
    8678:	2102      	movs	r1, #2
    867a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                                    CanIf_ControllerModeIndication(Can_pController->Can_u8AbstControllerID, CAN_CS_STOPPED);
    867e:	9b03      	ldr	r3, [sp, #12]
    8680:	781b      	ldrb	r3, [r3, #0]
    8682:	2102      	movs	r1, #2
    8684:	4618      	mov	r0, r3
    8686:	f00c f847 	bl	14718 <CanIf_ControllerModeIndication>
                                    eRetVal = E_OK;
    868a:	2300      	movs	r3, #0
    868c:	f88d 3017 	strb.w	r3, [sp, #23]
                                break;
    8690:	e011      	b.n	86b6 <Can_43_FLEXCAN_SetControllerMode+0xf2>
                                Can_eControllerState[Controller] = CAN_CS_STOPPED;
    8692:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8696:	4a1b      	ldr	r2, [pc, #108]	; (8704 <Can_43_FLEXCAN_SetControllerMode+0x140>)
    8698:	2102      	movs	r1, #2
    869a:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                                CanIf_ControllerModeIndication(Can_pController->Can_u8AbstControllerID, CAN_CS_STOPPED);
    869e:	9b03      	ldr	r3, [sp, #12]
    86a0:	781b      	ldrb	r3, [r3, #0]
    86a2:	2102      	movs	r1, #2
    86a4:	4618      	mov	r0, r3
    86a6:	f00c f837 	bl	14718 <CanIf_ControllerModeIndication>
                                eRetVal = E_OK;
    86aa:	2300      	movs	r3, #0
    86ac:	f88d 3017 	strb.w	r3, [sp, #23]
                                break;
    86b0:	e002      	b.n	86b8 <Can_43_FLEXCAN_SetControllerMode+0xf4>
                                break;
    86b2:	bf00      	nop
    86b4:	e01e      	b.n	86f4 <Can_43_FLEXCAN_SetControllerMode+0x130>
                                break;
    86b6:	bf00      	nop
                        break;
    86b8:	e01c      	b.n	86f4 <Can_43_FLEXCAN_SetControllerMode+0x130>
                        switch (Can_eControllerState[Controller])
    86ba:	f89d 3007 	ldrb.w	r3, [sp, #7]
    86be:	4a11      	ldr	r2, [pc, #68]	; (8704 <Can_43_FLEXCAN_SetControllerMode+0x140>)
    86c0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    86c4:	3b02      	subs	r3, #2
    86c6:	2b01      	cmp	r3, #1
    86c8:	d80f      	bhi.n	86ea <Can_43_FLEXCAN_SetControllerMode+0x126>
                                Can_eControllerState[Controller] = CAN_CS_SLEEP;
    86ca:	f89d 3007 	ldrb.w	r3, [sp, #7]
    86ce:	4a0d      	ldr	r2, [pc, #52]	; (8704 <Can_43_FLEXCAN_SetControllerMode+0x140>)
    86d0:	2103      	movs	r1, #3
    86d2:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                                CanIf_ControllerModeIndication(Can_pController->Can_u8AbstControllerID, CAN_CS_SLEEP);
    86d6:	9b03      	ldr	r3, [sp, #12]
    86d8:	781b      	ldrb	r3, [r3, #0]
    86da:	2103      	movs	r1, #3
    86dc:	4618      	mov	r0, r3
    86de:	f00c f81b 	bl	14718 <CanIf_ControllerModeIndication>
                                eRetVal = E_OK;
    86e2:	2300      	movs	r3, #0
    86e4:	f88d 3017 	strb.w	r3, [sp, #23]
                                break;
    86e8:	e000      	b.n	86ec <Can_43_FLEXCAN_SetControllerMode+0x128>
                                break;
    86ea:	bf00      	nop
                        break;
    86ec:	e002      	b.n	86f4 <Can_43_FLEXCAN_SetControllerMode+0x130>
                        break;
    86ee:	bf00      	nop
    86f0:	e000      	b.n	86f4 <Can_43_FLEXCAN_SetControllerMode+0x130>
                        break;
    86f2:	bf00      	nop
                    }
                }
#if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
    }
#endif
    return eRetVal;
    86f4:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    86f8:	4618      	mov	r0, r3
    86fa:	b007      	add	sp, #28
    86fc:	f85d fb04 	ldr.w	pc, [sp], #4
    8700:	1fff8da0 	.word	0x1fff8da0
    8704:	1fff8d9c 	.word	0x1fff8d9c

00008708 <Can_43_FLEXCAN_DisableControllerInterrupts>:
*
* @api
*/
/* implements     Can_DisableControllerInterrupts_Activity */
void Can_43_FLEXCAN_DisableControllerInterrupts(uint8 Controller)
{
    8708:	b500      	push	{lr}
    870a:	b085      	sub	sp, #20
    870c:	4603      	mov	r3, r0
    870e:	f88d 3007 	strb.w	r3, [sp, #7]
    uint32 u32CoreId = 0U;
    8712:	2300      	movs	r3, #0
    8714:	9303      	str	r3, [sp, #12]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    8716:	2300      	movs	r3, #0
    8718:	9302      	str	r3, [sp, #8]

    u32CoreId = Can_GetCoreID();
    871a:	2300      	movs	r3, #0
    871c:	9303      	str	r3, [sp, #12]
            }
            else
            {
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
#endif
                Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[Controller];
    871e:	4a10      	ldr	r2, [pc, #64]	; (8760 <Can_43_FLEXCAN_DisableControllerInterrupts+0x58>)
    8720:	9b03      	ldr	r3, [sp, #12]
    8722:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8726:	695a      	ldr	r2, [r3, #20]
    8728:	f89d 3007 	ldrb.w	r3, [sp, #7]
    872c:	009b      	lsls	r3, r3, #2
    872e:	4413      	add	r3, r2
    8730:	681b      	ldr	r3, [r3, #0]
    8732:	9302      	str	r3, [sp, #8]
                /* Start critical section: implementation depends on integrator */
                SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00();
    8734:	f009 fc08 	bl	11f48 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00>
                Can_au8DisableInterruptLevel[Controller] += 1U;
    8738:	f89d 3007 	ldrb.w	r3, [sp, #7]
    873c:	4a09      	ldr	r2, [pc, #36]	; (8764 <Can_43_FLEXCAN_DisableControllerInterrupts+0x5c>)
    873e:	5cd2      	ldrb	r2, [r2, r3]
    8740:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8744:	3201      	adds	r2, #1
    8746:	b2d1      	uxtb	r1, r2
    8748:	4a06      	ldr	r2, [pc, #24]	; (8764 <Can_43_FLEXCAN_DisableControllerInterrupts+0x5c>)
    874a:	54d1      	strb	r1, [r2, r3]
                /* End critical section: implementation depends on integrator */
                SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00();
    874c:	f009 fc28 	bl	11fa0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00>
                Can_43_FLEXCAN_Ipw_DisableControllerInterrupts(Can_pController);
    8750:	9802      	ldr	r0, [sp, #8]
    8752:	f000 ffe7 	bl	9724 <Can_43_FLEXCAN_Ipw_DisableControllerInterrupts>
            }
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
        }
    }
#endif
}
    8756:	bf00      	nop
    8758:	b005      	add	sp, #20
    875a:	f85d fb04 	ldr.w	pc, [sp], #4
    875e:	bf00      	nop
    8760:	1fff8da0 	.word	0x1fff8da0
    8764:	1fff8d98 	.word	0x1fff8d98

00008768 <Can_43_FLEXCAN_EnableControllerInterrupts>:
*
* @api
*/
/* implements     Can_EnableControllerInterrupts_Activity */
void Can_43_FLEXCAN_EnableControllerInterrupts(uint8 Controller)
{
    8768:	b500      	push	{lr}
    876a:	b085      	sub	sp, #20
    876c:	4603      	mov	r3, r0
    876e:	f88d 3007 	strb.w	r3, [sp, #7]
    uint32 u32CoreId = 0U;
    8772:	2300      	movs	r3, #0
    8774:	9303      	str	r3, [sp, #12]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    8776:	2300      	movs	r3, #0
    8778:	9302      	str	r3, [sp, #8]

    u32CoreId = Can_GetCoreID();
    877a:	2300      	movs	r3, #0
    877c:	9303      	str	r3, [sp, #12]
            }
            else
            {
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
#endif
                Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[Controller];
    877e:	4a16      	ldr	r2, [pc, #88]	; (87d8 <Can_43_FLEXCAN_EnableControllerInterrupts+0x70>)
    8780:	9b03      	ldr	r3, [sp, #12]
    8782:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8786:	695a      	ldr	r2, [r3, #20]
    8788:	f89d 3007 	ldrb.w	r3, [sp, #7]
    878c:	009b      	lsls	r3, r3, #2
    878e:	4413      	add	r3, r2
    8790:	681b      	ldr	r3, [r3, #0]
    8792:	9302      	str	r3, [sp, #8]
                /* Start critical section: implementation depends on integrator */
                SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01();
    8794:	f009 fc2a 	bl	11fec <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01>
                if (Can_au8DisableInterruptLevel[Controller] > 0U)
    8798:	f89d 3007 	ldrb.w	r3, [sp, #7]
    879c:	4a0f      	ldr	r2, [pc, #60]	; (87dc <Can_43_FLEXCAN_EnableControllerInterrupts+0x74>)
    879e:	5cd3      	ldrb	r3, [r2, r3]
    87a0:	2b00      	cmp	r3, #0
    87a2:	d009      	beq.n	87b8 <Can_43_FLEXCAN_EnableControllerInterrupts+0x50>
                {
                    Can_au8DisableInterruptLevel[Controller] -= 1U;
    87a4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    87a8:	4a0c      	ldr	r2, [pc, #48]	; (87dc <Can_43_FLEXCAN_EnableControllerInterrupts+0x74>)
    87aa:	5cd2      	ldrb	r2, [r2, r3]
    87ac:	f89d 3007 	ldrb.w	r3, [sp, #7]
    87b0:	3a01      	subs	r2, #1
    87b2:	b2d1      	uxtb	r1, r2
    87b4:	4a09      	ldr	r2, [pc, #36]	; (87dc <Can_43_FLEXCAN_EnableControllerInterrupts+0x74>)
    87b6:	54d1      	strb	r1, [r2, r3]
                }
                /* End critical section: implementation depends on integrator */
                SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01();
    87b8:	f009 fc44 	bl	12044 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01>

                if (0U == Can_au8DisableInterruptLevel[Controller])
    87bc:	f89d 3007 	ldrb.w	r3, [sp, #7]
    87c0:	4a06      	ldr	r2, [pc, #24]	; (87dc <Can_43_FLEXCAN_EnableControllerInterrupts+0x74>)
    87c2:	5cd3      	ldrb	r3, [r2, r3]
    87c4:	2b00      	cmp	r3, #0
    87c6:	d102      	bne.n	87ce <Can_43_FLEXCAN_EnableControllerInterrupts+0x66>
                {
                    Can_43_FLEXCAN_Ipw_EnableControllerInterrupts(Can_pController);
    87c8:	9802      	ldr	r0, [sp, #8]
    87ca:	f000 ffd5 	bl	9778 <Can_43_FLEXCAN_Ipw_EnableControllerInterrupts>
            }
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
        }
    }
#endif
}
    87ce:	bf00      	nop
    87d0:	b005      	add	sp, #20
    87d2:	f85d fb04 	ldr.w	pc, [sp], #4
    87d6:	bf00      	nop
    87d8:	1fff8da0 	.word	0x1fff8da0
    87dc:	1fff8d98 	.word	0x1fff8d98

000087e0 <Can_43_FLEXCAN_GetControllerErrorState>:
Std_ReturnType Can_43_FLEXCAN_GetControllerErrorState
(
    uint8 ControllerId,
    Can_ErrorStateType * ErrorStatePtr
)
{
    87e0:	b500      	push	{lr}
    87e2:	b087      	sub	sp, #28
    87e4:	4603      	mov	r3, r0
    87e6:	9100      	str	r1, [sp, #0]
    87e8:	f88d 3007 	strb.w	r3, [sp, #7]
    Std_ReturnType eRetVal = E_NOT_OK;
    87ec:	2301      	movs	r3, #1
    87ee:	f88d 3017 	strb.w	r3, [sp, #23]
    uint8 errorState = 0U;
    87f2:	2300      	movs	r3, #0
    87f4:	f88d 300b 	strb.w	r3, [sp, #11]
    uint32 u32CoreId = 0U;
    87f8:	2300      	movs	r3, #0
    87fa:	9304      	str	r3, [sp, #16]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    87fc:	2300      	movs	r3, #0
    87fe:	9303      	str	r3, [sp, #12]

    u32CoreId = Can_GetCoreID();
    8800:	2300      	movs	r3, #0
    8802:	9304      	str	r3, [sp, #16]
                    (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_GET_CONTROLLER_ERROR_STATE, CAN_43_FLEXCAN_E_PARAM_POINTER);
                }
                else
                {
#endif
                    Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[ControllerId];
    8804:	4a18      	ldr	r2, [pc, #96]	; (8868 <Can_43_FLEXCAN_GetControllerErrorState+0x88>)
    8806:	9b04      	ldr	r3, [sp, #16]
    8808:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    880c:	695a      	ldr	r2, [r3, #20]
    880e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8812:	009b      	lsls	r3, r3, #2
    8814:	4413      	add	r3, r2
    8816:	681b      	ldr	r3, [r3, #0]
    8818:	9303      	str	r3, [sp, #12]
                    eRetVal = Can_43_FLEXCAN_Ipw_GetControllerErrorState(Can_pController, &errorState);
    881a:	f10d 030b 	add.w	r3, sp, #11
    881e:	4619      	mov	r1, r3
    8820:	9803      	ldr	r0, [sp, #12]
    8822:	f000 ffd5 	bl	97d0 <Can_43_FLEXCAN_Ipw_GetControllerErrorState>
    8826:	4603      	mov	r3, r0
    8828:	f88d 3017 	strb.w	r3, [sp, #23]
                    if(eRetVal == (Std_ReturnType)E_OK)
    882c:	f89d 3017 	ldrb.w	r3, [sp, #23]
    8830:	2b00      	cmp	r3, #0
    8832:	d112      	bne.n	885a <Can_43_FLEXCAN_GetControllerErrorState+0x7a>
                    {
                        switch (errorState)
    8834:	f89d 300b 	ldrb.w	r3, [sp, #11]
    8838:	2b00      	cmp	r3, #0
    883a:	d002      	beq.n	8842 <Can_43_FLEXCAN_GetControllerErrorState+0x62>
    883c:	2b01      	cmp	r3, #1
    883e:	d004      	beq.n	884a <Can_43_FLEXCAN_GetControllerErrorState+0x6a>
    8840:	e007      	b.n	8852 <Can_43_FLEXCAN_GetControllerErrorState+0x72>
                        {
                            case 0x00U:
                            {
                                *ErrorStatePtr = CAN_ERRORSTATE_ACTIVE;
    8842:	9b00      	ldr	r3, [sp, #0]
    8844:	2200      	movs	r2, #0
    8846:	601a      	str	r2, [r3, #0]
                                break;
    8848:	e008      	b.n	885c <Can_43_FLEXCAN_GetControllerErrorState+0x7c>
                            }
                            case 0x01U:
                            {
                                *ErrorStatePtr = CAN_ERRORSTATE_PASSIVE;
    884a:	9b00      	ldr	r3, [sp, #0]
    884c:	2201      	movs	r2, #1
    884e:	601a      	str	r2, [r3, #0]
                                break;
    8850:	e004      	b.n	885c <Can_43_FLEXCAN_GetControllerErrorState+0x7c>
                            }
                            default:
                            {
                                *ErrorStatePtr = CAN_ERRORSTATE_BUSOFF;
    8852:	9b00      	ldr	r3, [sp, #0]
    8854:	2202      	movs	r2, #2
    8856:	601a      	str	r2, [r3, #0]
                                break;
    8858:	e000      	b.n	885c <Can_43_FLEXCAN_GetControllerErrorState+0x7c>
                            }
                        }
                    }
    885a:	bf00      	nop
#if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
                }
    }
#endif
    return eRetVal;
    885c:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    8860:	4618      	mov	r0, r3
    8862:	b007      	add	sp, #28
    8864:	f85d fb04 	ldr.w	pc, [sp], #4
    8868:	1fff8da0 	.word	0x1fff8da0

0000886c <Can_43_FLEXCAN_GetControllerMode>:
Std_ReturnType Can_43_FLEXCAN_GetControllerMode
(
    uint8 Controller,
    Can_ControllerStateType * ControllerModePtr
)
{
    886c:	b084      	sub	sp, #16
    886e:	4603      	mov	r3, r0
    8870:	9100      	str	r1, [sp, #0]
    8872:	f88d 3007 	strb.w	r3, [sp, #7]
    Std_ReturnType eRetVal = E_NOT_OK;
    8876:	2301      	movs	r3, #1
    8878:	f88d 300f 	strb.w	r3, [sp, #15]
                    (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_GET_CONTROLLER_MODE, CAN_43_FLEXCAN_E_PARAM_POINTER);
                }
                else
                {
#endif
                    *ControllerModePtr = Can_eControllerState[Controller];
    887c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8880:	4a06      	ldr	r2, [pc, #24]	; (889c <Can_43_FLEXCAN_GetControllerMode+0x30>)
    8882:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    8886:	9b00      	ldr	r3, [sp, #0]
    8888:	601a      	str	r2, [r3, #0]
                    eRetVal = E_OK;
    888a:	2300      	movs	r3, #0
    888c:	f88d 300f 	strb.w	r3, [sp, #15]
            }
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
        }
    }
#endif
    return eRetVal;
    8890:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    8894:	4618      	mov	r0, r3
    8896:	b004      	add	sp, #16
    8898:	4770      	bx	lr
    889a:	bf00      	nop
    889c:	1fff8d9c 	.word	0x1fff8d9c

000088a0 <Can_43_FLEXCAN_GetControllerRxErrorCounter>:
Std_ReturnType Can_43_FLEXCAN_GetControllerRxErrorCounter
(
    uint8 ControllerId,
    uint8 * RxErrorCounterPtr
)
{
    88a0:	b500      	push	{lr}
    88a2:	b087      	sub	sp, #28
    88a4:	4603      	mov	r3, r0
    88a6:	9100      	str	r1, [sp, #0]
    88a8:	f88d 3007 	strb.w	r3, [sp, #7]
    Std_ReturnType eRetVal = E_NOT_OK;
    88ac:	2301      	movs	r3, #1
    88ae:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32 u32CoreId = 0U;
    88b2:	2300      	movs	r3, #0
    88b4:	9304      	str	r3, [sp, #16]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    88b6:	2300      	movs	r3, #0
    88b8:	9303      	str	r3, [sp, #12]

    u32CoreId = Can_GetCoreID();
    88ba:	2300      	movs	r3, #0
    88bc:	9304      	str	r3, [sp, #16]
                    (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_GET_CONTROLLER_RX_ERROR_COUNTER, CAN_43_FLEXCAN_E_PARAM_POINTER);
                }
                else
                {
#endif
                    Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[ControllerId];
    88be:	4a0c      	ldr	r2, [pc, #48]	; (88f0 <Can_43_FLEXCAN_GetControllerRxErrorCounter+0x50>)
    88c0:	9b04      	ldr	r3, [sp, #16]
    88c2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    88c6:	695a      	ldr	r2, [r3, #20]
    88c8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    88cc:	009b      	lsls	r3, r3, #2
    88ce:	4413      	add	r3, r2
    88d0:	681b      	ldr	r3, [r3, #0]
    88d2:	9303      	str	r3, [sp, #12]
                    /*
                    *   [SWS_Can_00515]: When the API Can_GetControllerRxErrorCounter is called with
                    *   Controller Id as input parameter then Can driver shall read the Rx error counter
                    *   register of Can Controller and shall return the Rx error count to upper layer.
                    */
                    eRetVal = Can_43_FLEXCAN_Ipw_GetControllerRxErrorCounter(Can_pController, RxErrorCounterPtr);
    88d4:	9900      	ldr	r1, [sp, #0]
    88d6:	9803      	ldr	r0, [sp, #12]
    88d8:	f000 ffa5 	bl	9826 <Can_43_FLEXCAN_Ipw_GetControllerRxErrorCounter>
    88dc:	4603      	mov	r3, r0
    88de:	f88d 3017 	strb.w	r3, [sp, #23]
            }
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
        }
    }
#endif
    return eRetVal;
    88e2:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    88e6:	4618      	mov	r0, r3
    88e8:	b007      	add	sp, #28
    88ea:	f85d fb04 	ldr.w	pc, [sp], #4
    88ee:	bf00      	nop
    88f0:	1fff8da0 	.word	0x1fff8da0

000088f4 <Can_43_FLEXCAN_GetControllerTxErrorCounter>:
Std_ReturnType Can_43_FLEXCAN_GetControllerTxErrorCounter
(
    uint8 ControllerId,
    uint8 * TxErrorCounterPtr
)
{
    88f4:	b500      	push	{lr}
    88f6:	b087      	sub	sp, #28
    88f8:	4603      	mov	r3, r0
    88fa:	9100      	str	r1, [sp, #0]
    88fc:	f88d 3007 	strb.w	r3, [sp, #7]
    Std_ReturnType eRetVal = E_NOT_OK;
    8900:	2301      	movs	r3, #1
    8902:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32 u32CoreId = 0U;
    8906:	2300      	movs	r3, #0
    8908:	9304      	str	r3, [sp, #16]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    890a:	2300      	movs	r3, #0
    890c:	9303      	str	r3, [sp, #12]

    u32CoreId = Can_GetCoreID();
    890e:	2300      	movs	r3, #0
    8910:	9304      	str	r3, [sp, #16]
                    (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_GET_CONTROLLER_TX_ERROR_COUNTER, CAN_43_FLEXCAN_E_PARAM_POINTER);
                }
                else
                {
#endif /* CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON */
                    Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[ControllerId];
    8912:	4a0c      	ldr	r2, [pc, #48]	; (8944 <Can_43_FLEXCAN_GetControllerTxErrorCounter+0x50>)
    8914:	9b04      	ldr	r3, [sp, #16]
    8916:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    891a:	695a      	ldr	r2, [r3, #20]
    891c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8920:	009b      	lsls	r3, r3, #2
    8922:	4413      	add	r3, r2
    8924:	681b      	ldr	r3, [r3, #0]
    8926:	9303      	str	r3, [sp, #12]
                    /*
                    *   [SWS_Can_00520]: When the API Can_GetControllerTxErrorCounter is called with
                    *   Controller Id as input parameter then Can driver shall read the Tx error counter
                    *   register of Can Controller and shall return the Tx error count to upper layer.
                    */
                    eRetVal = Can_43_FLEXCAN_Ipw_GetControllerTxErrorCounter(Can_pController, TxErrorCounterPtr);
    8928:	9900      	ldr	r1, [sp, #0]
    892a:	9803      	ldr	r0, [sp, #12]
    892c:	f000 ff69 	bl	9802 <Can_43_FLEXCAN_Ipw_GetControllerTxErrorCounter>
    8930:	4603      	mov	r3, r0
    8932:	f88d 3017 	strb.w	r3, [sp, #23]
            }
        #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
        }
    }
#endif
    return eRetVal;
    8936:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    893a:	4618      	mov	r0, r3
    893c:	b007      	add	sp, #28
    893e:	f85d fb04 	ldr.w	pc, [sp], #4
    8942:	bf00      	nop
    8944:	1fff8da0 	.word	0x1fff8da0

00008948 <Can_43_FLEXCAN_Write>:
Std_ReturnType Can_43_FLEXCAN_Write
(
    Can_HwHandleType Hth,
    const Can_PduType * PduInfo
)
{
    8948:	b500      	push	{lr}
    894a:	b089      	sub	sp, #36	; 0x24
    894c:	4603      	mov	r3, r0
    894e:	9100      	str	r1, [sp, #0]
    8950:	f8ad 3006 	strh.w	r3, [sp, #6]
    Std_ReturnType eRetVal = E_NOT_OK;
    8954:	2301      	movs	r3, #1
    8956:	f88d 301f 	strb.w	r3, [sp, #31]
    uint8 u8ControllerID = 0U;
    895a:	2300      	movs	r3, #0
    895c:	f88d 301e 	strb.w	r3, [sp, #30]
    uint32 u32CoreId = 0U;
    8960:	2300      	movs	r3, #0
    8962:	9306      	str	r3, [sp, #24]
    Can_HwHandleType HwObjectID = 0U;
    8964:	2300      	movs	r3, #0
    8966:	f8ad 3016 	strh.w	r3, [sp, #22]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    896a:	2300      	movs	r3, #0
    896c:	9304      	str	r3, [sp, #16]
    const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject = NULL_PTR;
    896e:	2300      	movs	r3, #0
    8970:	9303      	str	r3, [sp, #12]

    u32CoreId = Can_GetCoreID();
    8972:	2300      	movs	r3, #0
    8974:	9306      	str	r3, [sp, #24]
    HwObjectID = Hth;
    8976:	f8bd 3006 	ldrh.w	r3, [sp, #6]
    897a:	f8ad 3016 	strh.w	r3, [sp, #22]
                (void)Det_ReportError((uint16)CAN_43_FLEXCAN_MODULE_ID, CAN_43_FLEXCAN_INSTANCE, CAN_43_FLEXCAN_SID_WRITE, CAN_43_FLEXCAN_E_PARAM_POINTER);
            }
            else
            {
#endif /* CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON */
                u8ControllerID = (Can_apxConfig[u32CoreId])->Can_pHwObjIDToCtrlIDMap[HwObjectID];
    897e:	4a1d      	ldr	r2, [pc, #116]	; (89f4 <Can_43_FLEXCAN_Write+0xac>)
    8980:	9b06      	ldr	r3, [sp, #24]
    8982:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8986:	68da      	ldr	r2, [r3, #12]
    8988:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    898c:	4413      	add	r3, r2
    898e:	781b      	ldrb	r3, [r3, #0]
    8990:	f88d 301e 	strb.w	r3, [sp, #30]
                Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID];
    8994:	4a17      	ldr	r2, [pc, #92]	; (89f4 <Can_43_FLEXCAN_Write+0xac>)
    8996:	9b06      	ldr	r3, [sp, #24]
    8998:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    899c:	695a      	ldr	r2, [r3, #20]
    899e:	f89d 301e 	ldrb.w	r3, [sp, #30]
    89a2:	009b      	lsls	r3, r3, #2
    89a4:	4413      	add	r3, r2
    89a6:	681b      	ldr	r3, [r3, #0]
    89a8:	9304      	str	r3, [sp, #16]
                if (NULL_PTR != Can_pController)
    89aa:	9b04      	ldr	r3, [sp, #16]
    89ac:	2b00      	cmp	r3, #0
    89ae:	d01b      	beq.n	89e8 <Can_43_FLEXCAN_Write+0xa0>
                {
                    Can_pHwObject = &((Can_apxConfig[u32CoreId])->Can_pHwObjectConfig[HwObjectID]);
    89b0:	4a10      	ldr	r2, [pc, #64]	; (89f4 <Can_43_FLEXCAN_Write+0xac>)
    89b2:	9b06      	ldr	r3, [sp, #24]
    89b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    89b8:	6919      	ldr	r1, [r3, #16]
    89ba:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    89be:	4613      	mov	r3, r2
    89c0:	00db      	lsls	r3, r3, #3
    89c2:	4413      	add	r3, r2
    89c4:	009b      	lsls	r3, r3, #2
    89c6:	440b      	add	r3, r1
    89c8:	9303      	str	r3, [sp, #12]
                #if (CAN_43_FLEXCAN_DEV_ERROR_DETECT == STD_ON)
                    if ((TRUE == Can_ValidatePdu(Can_pController, Can_pHwObject, PduInfo)) && (CAN_CS_STARTED == Can_eControllerState[u8ControllerID]))
                #else
                    /* avoid unexpected behaviour when accessing to RAM */
                    if (CAN_CS_STARTED == Can_eControllerState[u8ControllerID])
    89ca:	f89d 301e 	ldrb.w	r3, [sp, #30]
    89ce:	4a0a      	ldr	r2, [pc, #40]	; (89f8 <Can_43_FLEXCAN_Write+0xb0>)
    89d0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    89d4:	2b01      	cmp	r3, #1
    89d6:	d107      	bne.n	89e8 <Can_43_FLEXCAN_Write+0xa0>
                            eRetVal = CAN_BUSY;
                        }
                        else
                        {
                    #endif
                            eRetVal = Can_43_FLEXCAN_Ipw_Write(Can_pController, Can_pHwObject, PduInfo);
    89d8:	9a00      	ldr	r2, [sp, #0]
    89da:	9903      	ldr	r1, [sp, #12]
    89dc:	9804      	ldr	r0, [sp, #16]
    89de:	f000 ff34 	bl	984a <Can_43_FLEXCAN_Ipw_Write>
    89e2:	4603      	mov	r3, r0
    89e4:	f88d 301f 	strb.w	r3, [sp, #31]
                }
            #endif /* (CAN_43_FLEXCAN_MULTICORE_ENABLED == STD_ON) */
            }
    }
#endif
    return eRetVal;
    89e8:	f89d 301f 	ldrb.w	r3, [sp, #31]
}
    89ec:	4618      	mov	r0, r3
    89ee:	b009      	add	sp, #36	; 0x24
    89f0:	f85d fb04 	ldr.w	pc, [sp], #4
    89f4:	1fff8da0 	.word	0x1fff8da0
    89f8:	1fff8d9c 	.word	0x1fff8d9c

000089fc <Can_43_FLEXCAN_MainFunction_Write>:
                HwObjectID++;
            }
#endif /* (CAN_43_FLEXCAN_USE_CANEXCEL_IP  == STD_ON) */
        }
    #endif /* CAN_43_FLEXCAN_TX_POLLING_SUPPORT == STD_ON */
    }
    89fc:	bf00      	nop
    89fe:	4770      	bx	lr

00008a00 <Can_43_FLEXCAN_MainFunction_Read>:
                HwObjectID++;
            }
#endif /* (CAN_43_FLEXCAN_USE_CANEXCEL_IP  == STD_ON) */
        }
    #endif /* CAN_43_FLEXCAN_RX_POLLING_SUPPORT == STD_ON */
    }
    8a00:	bf00      	nop
    8a02:	4770      	bx	lr

00008a04 <Can_43_FLEXCAN_MainFunction_BusOff>:
            }
            u8ControllerID++;
        }
    }
#endif /* CAN_43_FLEXCAN_BUSOFF_POLLING_SUPPORT == STD_ON */
}
    8a04:	bf00      	nop
    8a06:	4770      	bx	lr

00008a08 <Can_43_FLEXCAN_MainFunction_Mode>:
*
* @api
*/
/* implements     Can_MainFunction_Mode_Activity */
void Can_43_FLEXCAN_MainFunction_Mode(void)
{
    8a08:	b500      	push	{lr}
    8a0a:	b085      	sub	sp, #20
    uint8 u8ControllerID = 0U;
    8a0c:	2300      	movs	r3, #0
    8a0e:	f88d 300f 	strb.w	r3, [sp, #15]
    uint32 u32CoreId = 0U;
    8a12:	2300      	movs	r3, #0
    8a14:	9302      	str	r3, [sp, #8]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    8a16:	2300      	movs	r3, #0
    8a18:	9301      	str	r3, [sp, #4]

    u32CoreId = Can_GetCoreID();
    8a1a:	2300      	movs	r3, #0
    8a1c:	9302      	str	r3, [sp, #8]
    if (NULL_PTR != (Can_apxConfig[u32CoreId]))
    8a1e:	4a17      	ldr	r2, [pc, #92]	; (8a7c <Can_43_FLEXCAN_MainFunction_Mode+0x74>)
    8a20:	9b02      	ldr	r3, [sp, #8]
    8a22:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8a26:	2b00      	cmp	r3, #0
    8a28:	d024      	beq.n	8a74 <Can_43_FLEXCAN_MainFunction_Mode+0x6c>
    {
        while (u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT)
    8a2a:	e01f      	b.n	8a6c <Can_43_FLEXCAN_MainFunction_Mode+0x64>
        {
            Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID];
    8a2c:	4a13      	ldr	r2, [pc, #76]	; (8a7c <Can_43_FLEXCAN_MainFunction_Mode+0x74>)
    8a2e:	9b02      	ldr	r3, [sp, #8]
    8a30:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8a34:	695a      	ldr	r2, [r3, #20]
    8a36:	f89d 300f 	ldrb.w	r3, [sp, #15]
    8a3a:	009b      	lsls	r3, r3, #2
    8a3c:	4413      	add	r3, r2
    8a3e:	681b      	ldr	r3, [r3, #0]
    8a40:	9301      	str	r3, [sp, #4]
            if (NULL_PTR != Can_pController)
    8a42:	9b01      	ldr	r3, [sp, #4]
    8a44:	2b00      	cmp	r3, #0
    8a46:	d00c      	beq.n	8a62 <Can_43_FLEXCAN_MainFunction_Mode+0x5a>
            {
                if (TRUE == Can_pController->Can_bActivation)
    8a48:	9b01      	ldr	r3, [sp, #4]
    8a4a:	7a1b      	ldrb	r3, [r3, #8]
    8a4c:	2b00      	cmp	r3, #0
    8a4e:	d008      	beq.n	8a62 <Can_43_FLEXCAN_MainFunction_Mode+0x5a>
                {
                    Can_43_FLEXCAN_Ipw_MainFunction_Mode(Can_pController, &Can_eControllerState[u8ControllerID]);
    8a50:	f89d 300f 	ldrb.w	r3, [sp, #15]
    8a54:	009b      	lsls	r3, r3, #2
    8a56:	4a0a      	ldr	r2, [pc, #40]	; (8a80 <Can_43_FLEXCAN_MainFunction_Mode+0x78>)
    8a58:	4413      	add	r3, r2
    8a5a:	4619      	mov	r1, r3
    8a5c:	9801      	ldr	r0, [sp, #4]
    8a5e:	f000 fff4 	bl	9a4a <Can_43_FLEXCAN_Ipw_MainFunction_Mode>
                }
            }
            u8ControllerID++;
    8a62:	f89d 300f 	ldrb.w	r3, [sp, #15]
    8a66:	3301      	adds	r3, #1
    8a68:	f88d 300f 	strb.w	r3, [sp, #15]
        while (u8ControllerID < CAN_43_FLEXCAN_CONTROLLER_CONFIG_COUNT)
    8a6c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    8a70:	2b00      	cmp	r3, #0
    8a72:	d0db      	beq.n	8a2c <Can_43_FLEXCAN_MainFunction_Mode+0x24>
        }
    }
}
    8a74:	bf00      	nop
    8a76:	b005      	add	sp, #20
    8a78:	f85d fb04 	ldr.w	pc, [sp], #4
    8a7c:	1fff8da0 	.word	0x1fff8da0
    8a80:	1fff8d9c 	.word	0x1fff8d9c

00008a84 <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt>:
(
    uint8 u8CtrlOffset,
    uint8 u8MbIdx,
    Can_43_FLEXCAN_MbType mbType
)
{
    8a84:	b500      	push	{lr}
    8a86:	b087      	sub	sp, #28
    8a88:	4603      	mov	r3, r0
    8a8a:	9200      	str	r2, [sp, #0]
    8a8c:	f88d 3007 	strb.w	r3, [sp, #7]
    8a90:	460b      	mov	r3, r1
    8a92:	f88d 3006 	strb.w	r3, [sp, #6]
    uint8 u8ControllerID = 0U;
    8a96:	2300      	movs	r3, #0
    8a98:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32 u32CoreId = 0U;
    8a9c:	2300      	movs	r3, #0
    8a9e:	9304      	str	r3, [sp, #16]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    8aa0:	2300      	movs	r3, #0
    8aa2:	9303      	str	r3, [sp, #12]

    MCAL_FAULT_INJECTION_POINT(CAN_FIP_2_CHANGE_DRIVER_TO_UNINITIALIZED);
    u32CoreId = Can_GetCoreID();
    8aa4:	2300      	movs	r3, #0
    8aa6:	9304      	str	r3, [sp, #16]
    if (NULL_PTR != Can_apxConfig[u32CoreId])
    8aa8:	4a16      	ldr	r2, [pc, #88]	; (8b04 <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt+0x80>)
    8aaa:	9b04      	ldr	r3, [sp, #16]
    8aac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8ab0:	2b00      	cmp	r3, #0
    8ab2:	d022      	beq.n	8afa <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt+0x76>
    {
        u8ControllerID = (Can_apxConfig[u32CoreId])->Can_pCtrlOffsetToCtrlIDMap[u8CtrlOffset];
    8ab4:	4a13      	ldr	r2, [pc, #76]	; (8b04 <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt+0x80>)
    8ab6:	9b04      	ldr	r3, [sp, #16]
    8ab8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8abc:	689a      	ldr	r2, [r3, #8]
    8abe:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8ac2:	4413      	add	r3, r2
    8ac4:	781b      	ldrb	r3, [r3, #0]
    8ac6:	f88d 3017 	strb.w	r3, [sp, #23]
        Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID];
    8aca:	4a0e      	ldr	r2, [pc, #56]	; (8b04 <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt+0x80>)
    8acc:	9b04      	ldr	r3, [sp, #16]
    8ace:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8ad2:	695a      	ldr	r2, [r3, #20]
    8ad4:	f89d 3017 	ldrb.w	r3, [sp, #23]
    8ad8:	009b      	lsls	r3, r3, #2
    8ada:	4413      	add	r3, r2
    8adc:	681b      	ldr	r3, [r3, #0]
    8ade:	9303      	str	r3, [sp, #12]
        if (NULL_PTR != Can_pController)
    8ae0:	9b03      	ldr	r3, [sp, #12]
    8ae2:	2b00      	cmp	r3, #0
    8ae4:	d009      	beq.n	8afa <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt+0x76>
        {
            Can_43_FLEXCAN_Ipw_ProcessHwObject(Can_pController, (Can_apxConfig[u32CoreId]), u8MbIdx, mbType);
    8ae6:	4a07      	ldr	r2, [pc, #28]	; (8b04 <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt+0x80>)
    8ae8:	9b04      	ldr	r3, [sp, #16]
    8aea:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    8aee:	f89d 2006 	ldrb.w	r2, [sp, #6]
    8af2:	9b00      	ldr	r3, [sp, #0]
    8af4:	9803      	ldr	r0, [sp, #12]
    8af6:	f000 ffde 	bl	9ab6 <Can_43_FLEXCAN_Ipw_ProcessHwObject>
        }

    }
}
    8afa:	bf00      	nop
    8afc:	b007      	add	sp, #28
    8afe:	f85d fb04 	ldr.w	pc, [sp], #4
    8b02:	bf00      	nop
    8b04:	1fff8da0 	.word	0x1fff8da0

00008b08 <Can_43_FLEXCAN_ProcessBusOffInterrupt>:
*/
void Can_43_FLEXCAN_ProcessBusOffInterrupt
(
    uint8 u8CtrlOffset
)
{
    8b08:	b500      	push	{lr}
    8b0a:	b087      	sub	sp, #28
    8b0c:	4603      	mov	r3, r0
    8b0e:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 u8ControllerID = 0U;
    8b12:	2300      	movs	r3, #0
    8b14:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32 u32CoreId = 0U;
    8b18:	2300      	movs	r3, #0
    8b1a:	9304      	str	r3, [sp, #16]
    const Can_43_FLEXCAN_ControllerConfigType * Can_pController = NULL_PTR;
    8b1c:	2300      	movs	r3, #0
    8b1e:	9303      	str	r3, [sp, #12]

    u32CoreId = Can_GetCoreID();
    8b20:	2300      	movs	r3, #0
    8b22:	9304      	str	r3, [sp, #16]
    if (NULL_PTR != Can_apxConfig[u32CoreId])
    8b24:	4a19      	ldr	r2, [pc, #100]	; (8b8c <Can_43_FLEXCAN_ProcessBusOffInterrupt+0x84>)
    8b26:	9b04      	ldr	r3, [sp, #16]
    8b28:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8b2c:	2b00      	cmp	r3, #0
    8b2e:	d029      	beq.n	8b84 <Can_43_FLEXCAN_ProcessBusOffInterrupt+0x7c>
    {
        u8ControllerID = (Can_apxConfig[u32CoreId])->Can_pCtrlOffsetToCtrlIDMap[u8CtrlOffset];
    8b30:	4a16      	ldr	r2, [pc, #88]	; (8b8c <Can_43_FLEXCAN_ProcessBusOffInterrupt+0x84>)
    8b32:	9b04      	ldr	r3, [sp, #16]
    8b34:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8b38:	689a      	ldr	r2, [r3, #8]
    8b3a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    8b3e:	4413      	add	r3, r2
    8b40:	781b      	ldrb	r3, [r3, #0]
    8b42:	f88d 3017 	strb.w	r3, [sp, #23]
        Can_pController = (Can_apxConfig[u32CoreId])->Can_ppController[u8ControllerID];
    8b46:	4a11      	ldr	r2, [pc, #68]	; (8b8c <Can_43_FLEXCAN_ProcessBusOffInterrupt+0x84>)
    8b48:	9b04      	ldr	r3, [sp, #16]
    8b4a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    8b4e:	695a      	ldr	r2, [r3, #20]
    8b50:	f89d 3017 	ldrb.w	r3, [sp, #23]
    8b54:	009b      	lsls	r3, r3, #2
    8b56:	4413      	add	r3, r2
    8b58:	681b      	ldr	r3, [r3, #0]
    8b5a:	9303      	str	r3, [sp, #12]
        if (NULL_PTR != Can_pController)
    8b5c:	9b03      	ldr	r3, [sp, #12]
    8b5e:	2b00      	cmp	r3, #0
    8b60:	d010      	beq.n	8b84 <Can_43_FLEXCAN_ProcessBusOffInterrupt+0x7c>
        {
            if ((Std_ReturnType)E_OK == Can_43_FLEXCAN_Ipw_SetControllerToStopMode(Can_pController))
    8b62:	9803      	ldr	r0, [sp, #12]
    8b64:	f000 fd60 	bl	9628 <Can_43_FLEXCAN_Ipw_SetControllerToStopMode>
    8b68:	4603      	mov	r3, r0
    8b6a:	2b00      	cmp	r3, #0
    8b6c:	d10a      	bne.n	8b84 <Can_43_FLEXCAN_ProcessBusOffInterrupt+0x7c>
            {
                Can_eControllerState[u8ControllerID] = CAN_CS_STOPPED;
    8b6e:	f89d 3017 	ldrb.w	r3, [sp, #23]
    8b72:	4a07      	ldr	r2, [pc, #28]	; (8b90 <Can_43_FLEXCAN_ProcessBusOffInterrupt+0x88>)
    8b74:	2102      	movs	r1, #2
    8b76:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
                CanIf_ControllerBusOff(Can_pController->Can_u8AbstControllerID);
    8b7a:	9b03      	ldr	r3, [sp, #12]
    8b7c:	781b      	ldrb	r3, [r3, #0]
    8b7e:	4618      	mov	r0, r3
    8b80:	f00b fdd2 	bl	14728 <CanIf_ControllerBusOff>
            }
        }
    }
}
    8b84:	bf00      	nop
    8b86:	b007      	add	sp, #28
    8b88:	f85d fb04 	ldr.w	pc, [sp], #4
    8b8c:	1fff8da0 	.word	0x1fff8da0
    8b90:	1fff8d9c 	.word	0x1fff8d9c

00008b94 <Can_Ipw_ParseData>:
    PduInfoType * CanIf_PduInfo,
    Flexcan_Ip_MsgBuffType * pReceivedDataBuffer,
    const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig,
    const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObjectConfig
)
{
    8b94:	b500      	push	{lr}
    8b96:	b085      	sub	sp, #20
    8b98:	9003      	str	r0, [sp, #12]
    8b9a:	9102      	str	r1, [sp, #8]
    8b9c:	9201      	str	r2, [sp, #4]
    8b9e:	9300      	str	r3, [sp, #0]
    CanIf_Mailbox->CanId = pReceivedDataBuffer->msgId;
    8ba0:	9b01      	ldr	r3, [sp, #4]
    8ba2:	685a      	ldr	r2, [r3, #4]
    8ba4:	9b03      	ldr	r3, [sp, #12]
    8ba6:	601a      	str	r2, [r3, #0]
    * convert the ID to a standardized format since the Upper layer (CANIF) does not know
    * whether the received CAN frame is a Standard CAN frame or Extended CAN frame.
    * In case of an Extended CAN frame, MSB of a received CAN frame ID needs to be
    * made as 1 to mark the received CAN frame as Extended.
    */
    if (((pReceivedDataBuffer->cs) & CAN_IPW_CS_IDE_MASK) != 0U)
    8ba8:	9b01      	ldr	r3, [sp, #4]
    8baa:	681b      	ldr	r3, [r3, #0]
    8bac:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
    8bb0:	2b00      	cmp	r3, #0
    8bb2:	d005      	beq.n	8bc0 <Can_Ipw_ParseData+0x2c>
    {
        CanIf_Mailbox->CanId |= (uint32)0x80000000U;
    8bb4:	9b03      	ldr	r3, [sp, #12]
    8bb6:	681b      	ldr	r3, [r3, #0]
    8bb8:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
    8bbc:	9b03      	ldr	r3, [sp, #12]
    8bbe:	601a      	str	r2, [r3, #0]
    }

    if (CAN_RX_NORMAL == Can_pHwObjectConfig->Can_eReceiveType)
    8bc0:	9b06      	ldr	r3, [sp, #24]
    8bc2:	699b      	ldr	r3, [r3, #24]
    8bc4:	2b00      	cmp	r3, #0
    8bc6:	d10c      	bne.n	8be2 <Can_Ipw_ParseData+0x4e>
    {
        /* Check if Mb Overrun */
        if ((uint32)(0x06000000U) == (pReceivedDataBuffer->cs & CAN_IPW_CS_CODE_MASK))
    8bc8:	9b01      	ldr	r3, [sp, #4]
    8bca:	681b      	ldr	r3, [r3, #0]
    8bcc:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    8bd0:	f1b3 6fc0 	cmp.w	r3, #100663296	; 0x6000000
    8bd4:	d105      	bne.n	8be2 <Can_Ipw_ParseData+0x4e>
        {
            (void)Det_ReportRuntimeError((uint16)CAN_43_FLEXCAN_IPW_MODULE_ID, (uint8)CAN_43_FLEXCAN_INSTANCE, (uint8)CAN_43_FLEXCAN_SID_MAIN_FUNCTION_READ, (uint8)CAN_43_FLEXCAN_E_DATALOST);
    8bd6:	2301      	movs	r3, #1
    8bd8:	2208      	movs	r2, #8
    8bda:	2100      	movs	r1, #0
    8bdc:	2050      	movs	r0, #80	; 0x50
    8bde:	f00b fc03 	bl	143e8 <Det_ReportRuntimeError>
        }
    }

    /* when legacy fifo enabled, FD must be disabled */
    if (CAN_RX_LEGACY_FIFO != Can_pHwObjectConfig->Can_eReceiveType)
    8be2:	9b06      	ldr	r3, [sp, #24]
    8be4:	699b      	ldr	r3, [r3, #24]
    8be6:	2b01      	cmp	r3, #1
    8be8:	d009      	beq.n	8bfe <Can_Ipw_ParseData+0x6a>
    {
        /*
        * [SWS_Can_00501]  CanDrv shall indicate whether the received message is a
        * conventional CAN frame or a CAN FD frame as described in Can_IdType.
        */
        if (((pReceivedDataBuffer->cs) & CAN_IPW_CS_EDL_MASK) != 0U)
    8bea:	9b01      	ldr	r3, [sp, #4]
    8bec:	681b      	ldr	r3, [r3, #0]
    8bee:	2b00      	cmp	r3, #0
    8bf0:	da05      	bge.n	8bfe <Can_Ipw_ParseData+0x6a>
        {
            CanIf_Mailbox->CanId |= (uint32)0x40000000U;
    8bf2:	9b03      	ldr	r3, [sp, #12]
    8bf4:	681b      	ldr	r3, [r3, #0]
    8bf6:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
    8bfa:	9b03      	ldr	r3, [sp, #12]
    8bfc:	601a      	str	r2, [r3, #0]
        }
    }

    if (Can_pHwObjectConfig->Can_u8PayloadLength <= pReceivedDataBuffer->dataLen)
    8bfe:	9b06      	ldr	r3, [sp, #24]
    8c00:	7c1a      	ldrb	r2, [r3, #16]
    8c02:	9b01      	ldr	r3, [sp, #4]
    8c04:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
    8c08:	429a      	cmp	r2, r3
    8c0a:	d805      	bhi.n	8c18 <Can_Ipw_ParseData+0x84>
    {
        CanIf_PduInfo->SduLength = Can_pHwObjectConfig->Can_u8PayloadLength;
    8c0c:	9b06      	ldr	r3, [sp, #24]
    8c0e:	7c1b      	ldrb	r3, [r3, #16]
    8c10:	461a      	mov	r2, r3
    8c12:	9b02      	ldr	r3, [sp, #8]
    8c14:	609a      	str	r2, [r3, #8]
    8c16:	e005      	b.n	8c24 <Can_Ipw_ParseData+0x90>
    }
    else
    {
        CanIf_PduInfo->SduLength = pReceivedDataBuffer->dataLen;
    8c18:	9b01      	ldr	r3, [sp, #4]
    8c1a:	f893 3048 	ldrb.w	r3, [r3, #72]	; 0x48
    8c1e:	461a      	mov	r2, r3
    8c20:	9b02      	ldr	r3, [sp, #8]
    8c22:	609a      	str	r2, [r3, #8]
                                                      CanIf_PduInfo->SduLength, \
                                                      &pReceivedDataBuffer->data[0]) \
                                                     )
    {
#endif
    CanIf_Mailbox->Hoh = Can_pHwObjectConfig->Can_HwObjectID;
    8c24:	9b06      	ldr	r3, [sp, #24]
    8c26:	881a      	ldrh	r2, [r3, #0]
    8c28:	9b03      	ldr	r3, [sp, #12]
    8c2a:	809a      	strh	r2, [r3, #4]
    CanIf_Mailbox->ControllerId = Can_pControllerConfig->Can_u8AbstControllerID;
    8c2c:	9b00      	ldr	r3, [sp, #0]
    8c2e:	781a      	ldrb	r2, [r3, #0]
    8c30:	9b03      	ldr	r3, [sp, #12]
    8c32:	719a      	strb	r2, [r3, #6]
    CanIf_PduInfo->SduDataPtr = &pReceivedDataBuffer->data[0];
    8c34:	9b01      	ldr	r3, [sp, #4]
    8c36:	f103 0208 	add.w	r2, r3, #8
    8c3a:	9b02      	ldr	r3, [sp, #8]
    8c3c:	601a      	str	r2, [r3, #0]
    CanIf_RxIndication(CanIf_Mailbox, CanIf_PduInfo);
    8c3e:	9902      	ldr	r1, [sp, #8]
    8c40:	9803      	ldr	r0, [sp, #12]
    8c42:	f00b fcff 	bl	14644 <CanIf_RxIndication>
#if (CAN_43_FLEXCAN_LPDU_CALLOUT_SUPPORT == STD_ON)
    }
#endif
}
    8c46:	bf00      	nop
    8c48:	b005      	add	sp, #20
    8c4a:	f85d fb04 	ldr.w	pc, [sp], #4

00008c4e <Can_Ipw_InitLegacyFifoFilter>:

static void Can_Ipw_InitLegacyFifoFilter(const Can_43_FLEXCAN_ControllerConfigType * Can_pController, const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject)
{
    8c4e:	b500      	push	{lr}
    8c50:	f2ad 4d1c 	subw	sp, sp, #1052	; 0x41c
    8c54:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8c58:	f2a3 4314 	subw	r3, r3, #1044	; 0x414
    8c5c:	6018      	str	r0, [r3, #0]
    8c5e:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8c62:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    8c66:	6019      	str	r1, [r3, #0]
    uint8 u8FilterIdx=0U;
    8c68:	2300      	movs	r3, #0
    8c6a:	f88d 3417 	strb.w	r3, [sp, #1047]	; 0x417
    uint8 u8HwFilterCount = 0U;
    8c6e:	2300      	movs	r3, #0
    8c70:	f88d 3416 	strb.w	r3, [sp, #1046]	; 0x416
    uint32 u32HwFilterMask = (uint32)0x00000000U;
    8c74:	2300      	movs	r3, #0
    8c76:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
    /* The max FIFO id filter affected by Rx individual masks*/
    uint8 u8FiFoFilterIndvCount = 0U;
    8c7a:	2300      	movs	r3, #0
    8c7c:	f88d 340f 	strb.w	r3, [sp, #1039]	; 0x40f
    Flexcan_Ip_RxFifoIdElementFormatType eElementFormat = FLEXCAN_RX_FIFO_ID_FORMAT_A;
    8c80:	2300      	movs	r3, #0
    8c82:	f8cd 3408 	str.w	r3, [sp, #1032]	; 0x408
    /* Need to alocate a filter array with elemnets no as defined in HwObject */
    Flexcan_Ip_IdTableType RxFifoFilters[128];

    if (((Can_pHwObject->Can_u8HwFilterCount / 4U) + 6U) <= 32U)
    8c86:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8c8a:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    8c8e:	681b      	ldr	r3, [r3, #0]
    8c90:	7c9b      	ldrb	r3, [r3, #18]
    8c92:	089b      	lsrs	r3, r3, #2
    8c94:	b2db      	uxtb	r3, r3
    8c96:	3306      	adds	r3, #6
    8c98:	2b20      	cmp	r3, #32
    8c9a:	d80b      	bhi.n	8cb4 <Can_Ipw_InitLegacyFifoFilter+0x66>
    {
        u8FiFoFilterIndvCount = (Can_pHwObject->Can_u8HwFilterCount / 4U) + 6U;
    8c9c:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8ca0:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    8ca4:	681b      	ldr	r3, [r3, #0]
    8ca6:	7c9b      	ldrb	r3, [r3, #18]
    8ca8:	089b      	lsrs	r3, r3, #2
    8caa:	b2db      	uxtb	r3, r3
    8cac:	3306      	adds	r3, #6
    8cae:	f88d 340f 	strb.w	r3, [sp, #1039]	; 0x40f
    8cb2:	e002      	b.n	8cba <Can_Ipw_InitLegacyFifoFilter+0x6c>
    }
    else
    {
        u8FiFoFilterIndvCount = 32U;
    8cb4:	2320      	movs	r3, #32
    8cb6:	f88d 340f 	strb.w	r3, [sp, #1039]	; 0x40f
    }
    for (u8FilterIdx=0U; ((u8FilterIdx < u8FiFoFilterIndvCount) && (u8FilterIdx < Can_pHwObject->Can_u8HwFilterCount)); u8FilterIdx++)
    8cba:	2300      	movs	r3, #0
    8cbc:	f88d 3417 	strb.w	r3, [sp, #1047]	; 0x417
    8cc0:	e169      	b.n	8f96 <Can_Ipw_InitLegacyFifoFilter+0x348>
    {
            if (CAN_LEGACY_FIFO_FORMAT_A == Can_pController->Can_eLegacyAcceptanceMode)
    8cc2:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8cc6:	f2a3 4314 	subw	r3, r3, #1044	; 0x414
    8cca:	681b      	ldr	r3, [r3, #0]
    8ccc:	691b      	ldr	r3, [r3, #16]
    8cce:	2b00      	cmp	r3, #0
    8cd0:	d13a      	bne.n	8d48 <Can_Ipw_InitLegacyFifoFilter+0xfa>
            {
                u8HwFilterCount =  Can_pHwObject->Can_u8HwFilterCount;
    8cd2:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8cd6:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    8cda:	681b      	ldr	r3, [r3, #0]
    8cdc:	7c9b      	ldrb	r3, [r3, #18]
    8cde:	f88d 3416 	strb.w	r3, [sp, #1046]	; 0x416
                u32HwFilterMask = (uint32)0xC0000000U;
    8ce2:	f04f 4340 	mov.w	r3, #3221225472	; 0xc0000000
    8ce6:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                eElementFormat = FLEXCAN_RX_FIFO_ID_FORMAT_A;
    8cea:	2300      	movs	r3, #0
    8cec:	f8cd 3408 	str.w	r3, [sp, #1032]	; 0x408
                if (Can_pHwObject->Can_IdMessage != CAN_STANDARD)
    8cf0:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8cf4:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    8cf8:	681b      	ldr	r3, [r3, #0]
    8cfa:	689b      	ldr	r3, [r3, #8]
    8cfc:	2b00      	cmp	r3, #0
    8cfe:	d011      	beq.n	8d24 <Can_Ipw_InitLegacyFifoFilter+0xd6>
                {
                    u32HwFilterMask |= Can_pHwObject->Can_pHwFilterConfig[u8FilterIdx].Can_u32HwFilterMask << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATA_EXT_SHIFT;
    8d00:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8d04:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    8d08:	681b      	ldr	r3, [r3, #0]
    8d0a:	695a      	ldr	r2, [r3, #20]
    8d0c:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    8d10:	00db      	lsls	r3, r3, #3
    8d12:	4413      	add	r3, r2
    8d14:	685b      	ldr	r3, [r3, #4]
    8d16:	005b      	lsls	r3, r3, #1
    8d18:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    8d1c:	4313      	orrs	r3, r2
    8d1e:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
    8d22:	e126      	b.n	8f72 <Can_Ipw_InitLegacyFifoFilter+0x324>
                }
                else
                {
                    u32HwFilterMask |= Can_pHwObject->Can_pHwFilterConfig[u8FilterIdx].Can_u32HwFilterMask << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATA_STD_SHIFT;
    8d24:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8d28:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    8d2c:	681b      	ldr	r3, [r3, #0]
    8d2e:	695a      	ldr	r2, [r3, #20]
    8d30:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    8d34:	00db      	lsls	r3, r3, #3
    8d36:	4413      	add	r3, r2
    8d38:	685b      	ldr	r3, [r3, #4]
    8d3a:	04db      	lsls	r3, r3, #19
    8d3c:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    8d40:	4313      	orrs	r3, r2
    8d42:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
    8d46:	e114      	b.n	8f72 <Can_Ipw_InitLegacyFifoFilter+0x324>
                }
            }
            else if (CAN_LEGACY_FIFO_FORMAT_B == Can_pController->Can_eLegacyAcceptanceMode)
    8d48:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8d4c:	f2a3 4314 	subw	r3, r3, #1044	; 0x414
    8d50:	681b      	ldr	r3, [r3, #0]
    8d52:	691b      	ldr	r3, [r3, #16]
    8d54:	2b01      	cmp	r3, #1
    8d56:	d160      	bne.n	8e1a <Can_Ipw_InitLegacyFifoFilter+0x1cc>
            {
                u8HwFilterCount = Can_pHwObject->Can_u8HwFilterCount * 2U ;
    8d58:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8d5c:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    8d60:	681b      	ldr	r3, [r3, #0]
    8d62:	7c9b      	ldrb	r3, [r3, #18]
    8d64:	005b      	lsls	r3, r3, #1
    8d66:	f88d 3416 	strb.w	r3, [sp, #1046]	; 0x416
                u32HwFilterMask = (uint32)0xC000C000U;
    8d6a:	f04f 23c0 	mov.w	r3, #3221274624	; 0xc000c000
    8d6e:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                eElementFormat = FLEXCAN_RX_FIFO_ID_FORMAT_B;
    8d72:	2301      	movs	r3, #1
    8d74:	f8cd 3408 	str.w	r3, [sp, #1032]	; 0x408
                if (Can_pHwObject->Can_IdMessage != CAN_STANDARD)
    8d78:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8d7c:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    8d80:	681b      	ldr	r3, [r3, #0]
    8d82:	689b      	ldr	r3, [r3, #8]
    8d84:	2b00      	cmp	r3, #0
    8d86:	d024      	beq.n	8dd2 <Can_Ipw_InitLegacyFifoFilter+0x184>
                {
                    u32HwFilterMask |= (Can_pHwObject->Can_pHwFilterConfig[u8FilterIdx * 2U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATB_EXT_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATB_EXT_SHIFT1;
    8d88:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8d8c:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    8d90:	681b      	ldr	r3, [r3, #0]
    8d92:	695a      	ldr	r2, [r3, #20]
    8d94:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    8d98:	011b      	lsls	r3, r3, #4
    8d9a:	4413      	add	r3, r2
    8d9c:	685b      	ldr	r3, [r3, #4]
    8d9e:	0bdb      	lsrs	r3, r3, #15
    8da0:	041b      	lsls	r3, r3, #16
    8da2:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    8da6:	4313      	orrs	r3, r2
    8da8:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= (Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 2U) + 1U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATB_EXT_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATB_EXT_SHIFT2;
    8dac:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8db0:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    8db4:	681b      	ldr	r3, [r3, #0]
    8db6:	695a      	ldr	r2, [r3, #20]
    8db8:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    8dbc:	011b      	lsls	r3, r3, #4
    8dbe:	3308      	adds	r3, #8
    8dc0:	4413      	add	r3, r2
    8dc2:	685b      	ldr	r3, [r3, #4]
    8dc4:	0bdb      	lsrs	r3, r3, #15
    8dc6:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    8dca:	4313      	orrs	r3, r2
    8dcc:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
    8dd0:	e0cf      	b.n	8f72 <Can_Ipw_InitLegacyFifoFilter+0x324>
                }
                else
                {
                    u32HwFilterMask |= Can_pHwObject->Can_pHwFilterConfig[u8FilterIdx * 2U].Can_u32HwFilterMask << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATB_STD_SHIFT1;
    8dd2:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8dd6:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    8dda:	681b      	ldr	r3, [r3, #0]
    8ddc:	695a      	ldr	r2, [r3, #20]
    8dde:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    8de2:	011b      	lsls	r3, r3, #4
    8de4:	4413      	add	r3, r2
    8de6:	685b      	ldr	r3, [r3, #4]
    8de8:	04db      	lsls	r3, r3, #19
    8dea:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    8dee:	4313      	orrs	r3, r2
    8df0:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 2U) + 1U].Can_u32HwFilterMask << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATB_STD_SHIFT2;
    8df4:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8df8:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    8dfc:	681b      	ldr	r3, [r3, #0]
    8dfe:	695a      	ldr	r2, [r3, #20]
    8e00:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    8e04:	011b      	lsls	r3, r3, #4
    8e06:	3308      	adds	r3, #8
    8e08:	4413      	add	r3, r2
    8e0a:	685b      	ldr	r3, [r3, #4]
    8e0c:	00db      	lsls	r3, r3, #3
    8e0e:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    8e12:	4313      	orrs	r3, r2
    8e14:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
    8e18:	e0ab      	b.n	8f72 <Can_Ipw_InitLegacyFifoFilter+0x324>
                }
            }
            else /*CAN_LEGACY_FIFO_FORMAT_C == Can_pController->Can_eLegacyAcceptanceMode */
            {
                u8HwFilterCount =  Can_pHwObject->Can_u8HwFilterCount * 4U ;
    8e1a:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8e1e:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    8e22:	681b      	ldr	r3, [r3, #0]
    8e24:	7c9b      	ldrb	r3, [r3, #18]
    8e26:	009b      	lsls	r3, r3, #2
    8e28:	f88d 3416 	strb.w	r3, [sp, #1046]	; 0x416
                u32HwFilterMask = (uint32)0x00000000U;
    8e2c:	2300      	movs	r3, #0
    8e2e:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                eElementFormat = FLEXCAN_RX_FIFO_ID_FORMAT_C;
    8e32:	2302      	movs	r3, #2
    8e34:	f8cd 3408 	str.w	r3, [sp, #1032]	; 0x408
                if (Can_pHwObject->Can_IdMessage != CAN_STANDARD)
    8e38:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8e3c:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    8e40:	681b      	ldr	r3, [r3, #0]
    8e42:	689b      	ldr	r3, [r3, #8]
    8e44:	2b00      	cmp	r3, #0
    8e46:	d04a      	beq.n	8ede <Can_Ipw_InitLegacyFifoFilter+0x290>
                {
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[u8FilterIdx * 4U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT1;
    8e48:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8e4c:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    8e50:	681b      	ldr	r3, [r3, #0]
    8e52:	695a      	ldr	r2, [r3, #20]
    8e54:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    8e58:	015b      	lsls	r3, r3, #5
    8e5a:	4413      	add	r3, r2
    8e5c:	685b      	ldr	r3, [r3, #4]
    8e5e:	0d5b      	lsrs	r3, r3, #21
    8e60:	061b      	lsls	r3, r3, #24
    8e62:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    8e66:	4313      	orrs	r3, r2
    8e68:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 4U) + 1U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT2;
    8e6c:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8e70:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    8e74:	681b      	ldr	r3, [r3, #0]
    8e76:	695a      	ldr	r2, [r3, #20]
    8e78:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    8e7c:	015b      	lsls	r3, r3, #5
    8e7e:	3308      	adds	r3, #8
    8e80:	4413      	add	r3, r2
    8e82:	685b      	ldr	r3, [r3, #4]
    8e84:	0d5b      	lsrs	r3, r3, #21
    8e86:	041b      	lsls	r3, r3, #16
    8e88:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    8e8c:	4313      	orrs	r3, r2
    8e8e:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 4U) + 2U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT3;
    8e92:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8e96:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    8e9a:	681b      	ldr	r3, [r3, #0]
    8e9c:	695a      	ldr	r2, [r3, #20]
    8e9e:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    8ea2:	015b      	lsls	r3, r3, #5
    8ea4:	3310      	adds	r3, #16
    8ea6:	4413      	add	r3, r2
    8ea8:	685b      	ldr	r3, [r3, #4]
    8eaa:	0d5b      	lsrs	r3, r3, #21
    8eac:	021b      	lsls	r3, r3, #8
    8eae:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    8eb2:	4313      	orrs	r3, r2
    8eb4:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 4U) + 3U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT4;
    8eb8:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8ebc:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    8ec0:	681b      	ldr	r3, [r3, #0]
    8ec2:	695a      	ldr	r2, [r3, #20]
    8ec4:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    8ec8:	015b      	lsls	r3, r3, #5
    8eca:	3318      	adds	r3, #24
    8ecc:	4413      	add	r3, r2
    8ece:	685b      	ldr	r3, [r3, #4]
    8ed0:	0d5b      	lsrs	r3, r3, #21
    8ed2:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    8ed6:	4313      	orrs	r3, r2
    8ed8:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
    8edc:	e049      	b.n	8f72 <Can_Ipw_InitLegacyFifoFilter+0x324>
                }
                else
                {
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[u8FilterIdx * 4U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT1;
    8ede:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8ee2:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    8ee6:	681b      	ldr	r3, [r3, #0]
    8ee8:	695a      	ldr	r2, [r3, #20]
    8eea:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    8eee:	015b      	lsls	r3, r3, #5
    8ef0:	4413      	add	r3, r2
    8ef2:	685b      	ldr	r3, [r3, #4]
    8ef4:	08db      	lsrs	r3, r3, #3
    8ef6:	061b      	lsls	r3, r3, #24
    8ef8:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    8efc:	4313      	orrs	r3, r2
    8efe:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 4U) + 1U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT2;
    8f02:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8f06:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    8f0a:	681b      	ldr	r3, [r3, #0]
    8f0c:	695a      	ldr	r2, [r3, #20]
    8f0e:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    8f12:	015b      	lsls	r3, r3, #5
    8f14:	3308      	adds	r3, #8
    8f16:	4413      	add	r3, r2
    8f18:	685b      	ldr	r3, [r3, #4]
    8f1a:	08db      	lsrs	r3, r3, #3
    8f1c:	041b      	lsls	r3, r3, #16
    8f1e:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    8f22:	4313      	orrs	r3, r2
    8f24:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 4U) + 2U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT3;
    8f28:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8f2c:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    8f30:	681b      	ldr	r3, [r3, #0]
    8f32:	695a      	ldr	r2, [r3, #20]
    8f34:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    8f38:	015b      	lsls	r3, r3, #5
    8f3a:	3310      	adds	r3, #16
    8f3c:	4413      	add	r3, r2
    8f3e:	685b      	ldr	r3, [r3, #4]
    8f40:	08db      	lsrs	r3, r3, #3
    8f42:	021b      	lsls	r3, r3, #8
    8f44:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    8f48:	4313      	orrs	r3, r2
    8f4a:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                    u32HwFilterMask |= (uint32)(Can_pHwObject->Can_pHwFilterConfig[(u8FilterIdx * 4U) + 3U].Can_u32HwFilterMask >> CAN_IPW_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT) << CAN_IPW_RX_FIFO_MASK_FILTER_FORMATC_STD_EXT_SHIFT4;
    8f4e:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8f52:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    8f56:	681b      	ldr	r3, [r3, #0]
    8f58:	695a      	ldr	r2, [r3, #20]
    8f5a:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    8f5e:	015b      	lsls	r3, r3, #5
    8f60:	3318      	adds	r3, #24
    8f62:	4413      	add	r3, r2
    8f64:	685b      	ldr	r3, [r3, #4]
    8f66:	08db      	lsrs	r3, r3, #3
    8f68:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    8f6c:	4313      	orrs	r3, r2
    8f6e:	f8cd 3410 	str.w	r3, [sp, #1040]	; 0x410
                }
            }
            /* Already in freeze mode */
            (void)FlexCAN_Ip_SetRxIndividualMask(Can_pController->Can_u8ControllerOffset, u8FilterIdx, u32HwFilterMask);
    8f72:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8f76:	f2a3 4314 	subw	r3, r3, #1044	; 0x414
    8f7a:	681b      	ldr	r3, [r3, #0]
    8f7c:	789b      	ldrb	r3, [r3, #2]
    8f7e:	f89d 1417 	ldrb.w	r1, [sp, #1047]	; 0x417
    8f82:	f8dd 2410 	ldr.w	r2, [sp, #1040]	; 0x410
    8f86:	4618      	mov	r0, r3
    8f88:	f002 fd0e 	bl	b9a8 <FlexCAN_Ip_SetRxIndividualMask_Privileged>
    for (u8FilterIdx=0U; ((u8FilterIdx < u8FiFoFilterIndvCount) && (u8FilterIdx < Can_pHwObject->Can_u8HwFilterCount)); u8FilterIdx++)
    8f8c:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    8f90:	3301      	adds	r3, #1
    8f92:	f88d 3417 	strb.w	r3, [sp, #1047]	; 0x417
    8f96:	f89d 2417 	ldrb.w	r2, [sp, #1047]	; 0x417
    8f9a:	f89d 340f 	ldrb.w	r3, [sp, #1039]	; 0x40f
    8f9e:	429a      	cmp	r2, r3
    8fa0:	d20a      	bcs.n	8fb8 <Can_Ipw_InitLegacyFifoFilter+0x36a>
    8fa2:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8fa6:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    8faa:	681b      	ldr	r3, [r3, #0]
    8fac:	7c9b      	ldrb	r3, [r3, #18]
    8fae:	f89d 2417 	ldrb.w	r2, [sp, #1047]	; 0x417
    8fb2:	429a      	cmp	r2, r3
    8fb4:	f4ff ae85 	bcc.w	8cc2 <Can_Ipw_InitLegacyFifoFilter+0x74>
    }

    (void)FlexCAN_Ip_SetRxFifoGlobalMask(Can_pController->Can_u8ControllerOffset, Can_pController->Can_u32LegacyGlobalMask);
    8fb8:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8fbc:	f2a3 4314 	subw	r3, r3, #1044	; 0x414
    8fc0:	681b      	ldr	r3, [r3, #0]
    8fc2:	789a      	ldrb	r2, [r3, #2]
    8fc4:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8fc8:	f2a3 4314 	subw	r3, r3, #1044	; 0x414
    8fcc:	681b      	ldr	r3, [r3, #0]
    8fce:	68db      	ldr	r3, [r3, #12]
    8fd0:	4619      	mov	r1, r3
    8fd2:	4610      	mov	r0, r2
    8fd4:	f002 fd36 	bl	ba44 <FlexCAN_Ip_SetRxFifoGlobalMask_Privileged>
    
    if (u8HwFilterCount != 0U)
    8fd8:	f89d 3416 	ldrb.w	r3, [sp, #1046]	; 0x416
    8fdc:	2b00      	cmp	r3, #0
    8fde:	d054      	beq.n	908a <Can_Ipw_InitLegacyFifoFilter+0x43c>
    {
        for (u8FilterIdx=0U; u8FilterIdx < u8HwFilterCount; u8FilterIdx++)
    8fe0:	2300      	movs	r3, #0
    8fe2:	f88d 3417 	strb.w	r3, [sp, #1047]	; 0x417
    8fe6:	e03e      	b.n	9066 <Can_Ipw_InitLegacyFifoFilter+0x418>
        {
            RxFifoFilters[u8FilterIdx].id = Can_pHwObject->Can_pHwFilterConfig[u8FilterIdx].Can_u32HwFilterCode;
    8fe8:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    8fec:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    8ff0:	681b      	ldr	r3, [r3, #0]
    8ff2:	695a      	ldr	r2, [r3, #20]
    8ff4:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    8ff8:	00db      	lsls	r3, r3, #3
    8ffa:	441a      	add	r2, r3
    8ffc:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    9000:	6812      	ldr	r2, [r2, #0]
    9002:	f50d 6183 	add.w	r1, sp, #1048	; 0x418
    9006:	f5a1 6182 	sub.w	r1, r1, #1040	; 0x410
    900a:	00db      	lsls	r3, r3, #3
    900c:	440b      	add	r3, r1
    900e:	605a      	str	r2, [r3, #4]
            if (Can_pHwObject->Can_IdMessage != CAN_STANDARD)
    9010:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    9014:	f5a3 6383 	sub.w	r3, r3, #1048	; 0x418
    9018:	681b      	ldr	r3, [r3, #0]
    901a:	689b      	ldr	r3, [r3, #8]
    901c:	2b00      	cmp	r3, #0
    901e:	d00a      	beq.n	9036 <Can_Ipw_InitLegacyFifoFilter+0x3e8>
            {
                RxFifoFilters[u8FilterIdx].isExtendedFrame = TRUE;
    9020:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    9024:	f50d 6283 	add.w	r2, sp, #1048	; 0x418
    9028:	f5a2 6282 	sub.w	r2, r2, #1040	; 0x410
    902c:	00db      	lsls	r3, r3, #3
    902e:	4413      	add	r3, r2
    9030:	2201      	movs	r2, #1
    9032:	705a      	strb	r2, [r3, #1]
    9034:	e009      	b.n	904a <Can_Ipw_InitLegacyFifoFilter+0x3fc>
            }
            else
            {
                RxFifoFilters[u8FilterIdx].isExtendedFrame = FALSE;
    9036:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    903a:	f50d 6283 	add.w	r2, sp, #1048	; 0x418
    903e:	f5a2 6282 	sub.w	r2, r2, #1040	; 0x410
    9042:	00db      	lsls	r3, r3, #3
    9044:	4413      	add	r3, r2
    9046:	2200      	movs	r2, #0
    9048:	705a      	strb	r2, [r3, #1]
            }
            RxFifoFilters[u8FilterIdx].isRemoteFrame = FALSE;
    904a:	f89d 2417 	ldrb.w	r2, [sp, #1047]	; 0x417
    904e:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    9052:	f5a3 6382 	sub.w	r3, r3, #1040	; 0x410
    9056:	2100      	movs	r1, #0
    9058:	f803 1032 	strb.w	r1, [r3, r2, lsl #3]
        for (u8FilterIdx=0U; u8FilterIdx < u8HwFilterCount; u8FilterIdx++)
    905c:	f89d 3417 	ldrb.w	r3, [sp, #1047]	; 0x417
    9060:	3301      	adds	r3, #1
    9062:	f88d 3417 	strb.w	r3, [sp, #1047]	; 0x417
    9066:	f89d 2417 	ldrb.w	r2, [sp, #1047]	; 0x417
    906a:	f89d 3416 	ldrb.w	r3, [sp, #1046]	; 0x416
    906e:	429a      	cmp	r2, r3
    9070:	d3ba      	bcc.n	8fe8 <Can_Ipw_InitLegacyFifoFilter+0x39a>
        }

        (void)FlexCAN_Ip_ConfigRxFifo(Can_pController->Can_u8ControllerOffset, eElementFormat, RxFifoFilters);
    9072:	f50d 6383 	add.w	r3, sp, #1048	; 0x418
    9076:	f2a3 4314 	subw	r3, r3, #1044	; 0x414
    907a:	681b      	ldr	r3, [r3, #0]
    907c:	789b      	ldrb	r3, [r3, #2]
    907e:	aa02      	add	r2, sp, #8
    9080:	f8dd 1408 	ldr.w	r1, [sp, #1032]	; 0x408
    9084:	4618      	mov	r0, r3
    9086:	f002 f872 	bl	b16e <FlexCAN_Ip_ConfigRxFifo_Privileged>
    }
    
}
    908a:	bf00      	nop
    908c:	f20d 4d1c 	addw	sp, sp, #1052	; 0x41c
    9090:	f85d fb04 	ldr.w	pc, [sp], #4

00009094 <Can_Ipw_InitBaudrate>:

#endif /* (CAN_43_FLEXCAN_RX_POLLING_SUPPORT == STD_ON) */

/* Init baudrate for controller */
static void Can_Ipw_InitBaudrate(const Can_43_FLEXCAN_ControllerConfigType * ControllerConfig)
{
    9094:	b510      	push	{r4, lr}
    9096:	b084      	sub	sp, #16
    9098:	9001      	str	r0, [sp, #4]
#if (CAN_43_FLEXCAN_SET_BAUDRATE_API == STD_ON)
    uint16 BaudRateConfigID = Can_au16ControllerBaudRateSel[ControllerConfig->Can_u8ControllerID];
#else
    uint16 BaudRateConfigID = ControllerConfig->Can_u16DefaultBaudrateID;
    909a:	9b01      	ldr	r3, [sp, #4]
    909c:	8b9b      	ldrh	r3, [r3, #28]
    909e:	f8ad 300e 	strh.w	r3, [sp, #14]
        FlexCANTimeSeg.phaseSeg1  = ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_NominalBitRate.Can_u8PhaseSeg1;
        FlexCANTimeSeg.phaseSeg2  = ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_NominalBitRate.Can_u8PhaseSeg2;
        FlexCANTimeSeg.rJumpwidth = ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_NominalBitRate.Can_u8ResyncJumpWidth;
        (void)FlexCAN_Ip_SetBitrate(ControllerConfig->Can_u8ControllerOffset, &FlexCANTimeSeg, FALSE);
#endif /* ((CAN_43_FLEXCAN_DUAL_CLOCK_MODE == STD_ON) || (CAN_43_FLEXCAN_SET_BAUDRATE_API == STD_ON)) */
        if (TRUE == ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_bFDFrame)
    90a2:	9b01      	ldr	r3, [sp, #4]
    90a4:	6a1a      	ldr	r2, [r3, #32]
    90a6:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    90aa:	2116      	movs	r1, #22
    90ac:	fb01 f303 	mul.w	r3, r1, r3
    90b0:	4413      	add	r3, r2
    90b2:	785b      	ldrb	r3, [r3, #1]
    90b4:	2b00      	cmp	r3, #0
    90b6:	d016      	beq.n	90e6 <Can_Ipw_InitBaudrate+0x52>
            FlexCANTimeSeg.phaseSeg2  = ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_DataBitRate.Can_u8PhaseSeg2;
            FlexCANTimeSeg.rJumpwidth = ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_DataBitRate.Can_u8ResyncJumpWidth;

            (void)FlexCAN_Ip_SetBitrateCbt(ControllerConfig->Can_u8ControllerOffset, &FlexCANTimeSeg, ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_bBitRateSwitch);
    #endif /* ((CAN_43_FLEXCAN_DUAL_CLOCK_MODE == STD_ON) || (CAN_43_FLEXCAN_SET_BAUDRATE_API == STD_ON)) */
            (void)FlexCAN_Ip_SetTDCOffset(ControllerConfig->Can_u8ControllerOffset, \
    90b8:	9b01      	ldr	r3, [sp, #4]
    90ba:	7898      	ldrb	r0, [r3, #2]
    90bc:	9b01      	ldr	r3, [sp, #4]
    90be:	6a1a      	ldr	r2, [r3, #32]
    90c0:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    90c4:	2116      	movs	r1, #22
    90c6:	fb01 f303 	mul.w	r3, r1, r3
    90ca:	4413      	add	r3, r2
    90cc:	7cd9      	ldrb	r1, [r3, #19]
    90ce:	9b01      	ldr	r3, [sp, #4]
    90d0:	6a1a      	ldr	r2, [r3, #32]
    90d2:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    90d6:	2416      	movs	r4, #22
    90d8:	fb04 f303 	mul.w	r3, r4, r3
    90dc:	4413      	add	r3, r2
    90de:	7d1b      	ldrb	r3, [r3, #20]
    90e0:	461a      	mov	r2, r3
    90e2:	f003 f829 	bl	c138 <FlexCAN_Ip_SetTDCOffset_Privileged>
                                          ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_bTrcvDelayEnable, \
                                          ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_u8TrcvDelayCompOffset);
        }
        (void)FlexCAN_Ip_SetTxArbitrationStartDelay(ControllerConfig->Can_u8ControllerOffset, ControllerConfig->Can_pBaudrateConfig[BaudRateConfigID].Can_u8TxArbitrationStartDelay);
    90e6:	9b01      	ldr	r3, [sp, #4]
    90e8:	7898      	ldrb	r0, [r3, #2]
    90ea:	9b01      	ldr	r3, [sp, #4]
    90ec:	6a1a      	ldr	r2, [r3, #32]
    90ee:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    90f2:	2116      	movs	r1, #22
    90f4:	fb01 f303 	mul.w	r3, r1, r3
    90f8:	4413      	add	r3, r2
    90fa:	7c9b      	ldrb	r3, [r3, #18]
    90fc:	4619      	mov	r1, r3
    90fe:	f003 f86f 	bl	c1e0 <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged>
}
    9102:	bf00      	nop
    9104:	b004      	add	sp, #16
    9106:	bd10      	pop	{r4, pc}

00009108 <Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer>:
    (
        const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig,
        const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObjectConfig,
        uint8 u8MbIdx
    )
    {
    9108:	b500      	push	{lr}
    910a:	b087      	sub	sp, #28
    910c:	9003      	str	r0, [sp, #12]
    910e:	9102      	str	r1, [sp, #8]
    9110:	4613      	mov	r3, r2
    9112:	f88d 3007 	strb.w	r3, [sp, #7]
        Can_HwHandleType u8HwObjectID = 0U;
    9116:	2300      	movs	r3, #0
    9118:	f8ad 3016 	strh.w	r3, [sp, #22]

        u8HwObjectID = Can_Ipw_au16MbIdxToObjIDMap[Can_pControllerConfig->Can_u8ControllerID][u8MbIdx];
    911c:	9b03      	ldr	r3, [sp, #12]
    911e:	785b      	ldrb	r3, [r3, #1]
    9120:	461a      	mov	r2, r3
    9122:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9126:	491c      	ldr	r1, [pc, #112]	; (9198 <Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer+0x90>)
    9128:	0152      	lsls	r2, r2, #5
    912a:	4413      	add	r3, r2
    912c:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
    9130:	f8ad 3016 	strh.w	r3, [sp, #22]
        if ((CAN_43_FLEXCAN_HWOBJ_UNMAPPED != u8HwObjectID) && (FALSE == Can_pHwObjectConfig[u8HwObjectID].Can_bHwObjectUsesPolling))
    9134:	f8bd 3016 	ldrh.w	r3, [sp, #22]
    9138:	f64f 72ff 	movw	r2, #65535	; 0xffff
    913c:	4293      	cmp	r3, r2
    913e:	d027      	beq.n	9190 <Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer+0x88>
    9140:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    9144:	4613      	mov	r3, r2
    9146:	00db      	lsls	r3, r3, #3
    9148:	4413      	add	r3, r2
    914a:	009b      	lsls	r3, r3, #2
    914c:	461a      	mov	r2, r3
    914e:	9b02      	ldr	r3, [sp, #8]
    9150:	4413      	add	r3, r2
    9152:	7b1b      	ldrb	r3, [r3, #12]
    9154:	f083 0301 	eor.w	r3, r3, #1
    9158:	b2db      	uxtb	r3, r3
    915a:	2b00      	cmp	r3, #0
    915c:	d018      	beq.n	9190 <Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer+0x88>
        {
            if (CAN_TX_NORMAL == Can_pHwObjectConfig[u8HwObjectID].Can_eReceiveType)
    915e:	f8bd 2016 	ldrh.w	r2, [sp, #22]
    9162:	4613      	mov	r3, r2
    9164:	00db      	lsls	r3, r3, #3
    9166:	4413      	add	r3, r2
    9168:	009b      	lsls	r3, r3, #2
    916a:	461a      	mov	r2, r3
    916c:	9b02      	ldr	r3, [sp, #8]
    916e:	4413      	add	r3, r2
    9170:	699b      	ldr	r3, [r3, #24]
    9172:	2b03      	cmp	r3, #3
    9174:	d10c      	bne.n	9190 <Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer+0x88>
            {
                CanIf_TxConfirmation(Can_Ipw_au16TxPduId[Can_pControllerConfig->Can_u8ControllerID][u8MbIdx]);
    9176:	9b03      	ldr	r3, [sp, #12]
    9178:	785b      	ldrb	r3, [r3, #1]
    917a:	461a      	mov	r2, r3
    917c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    9180:	4906      	ldr	r1, [pc, #24]	; (919c <Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer+0x94>)
    9182:	0152      	lsls	r2, r2, #5
    9184:	4413      	add	r3, r2
    9186:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
    918a:	4618      	mov	r0, r3
    918c:	f00b fa26 	bl	145dc <CanIf_TxConfirmation>
            }
        }
    }
    9190:	bf00      	nop
    9192:	b007      	add	sp, #28
    9194:	f85d fb04 	ldr.w	pc, [sp], #4
    9198:	1fff9004 	.word	0x1fff9004
    919c:	1fff8fc4 	.word	0x1fff8fc4

000091a0 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer>:
    (
        const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig,
        const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObjectConfig,
        uint8 u8MbIdx
    )
    {
    91a0:	b500      	push	{lr}
    91a2:	b08f      	sub	sp, #60	; 0x3c
    91a4:	9005      	str	r0, [sp, #20]
    91a6:	9104      	str	r1, [sp, #16]
    91a8:	4613      	mov	r3, r2
    91aa:	f88d 300f 	strb.w	r3, [sp, #15]
        Can_HwHandleType u8HwObjectID = 0U;
    91ae:	2300      	movs	r3, #0
    91b0:	f8ad 3036 	strh.w	r3, [sp, #54]	; 0x36
        Can_HwType CanIf_Mailbox;
        PduInfoType CanIf_PduInfo;
        const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject = NULL_PTR;
    91b4:	2300      	movs	r3, #0
    91b6:	930c      	str	r3, [sp, #48]	; 0x30
        Flexcan_Ip_MsgBuffType * pReceivedDataBuffer = NULL_PTR;
    91b8:	2300      	movs	r3, #0
    91ba:	930b      	str	r3, [sp, #44]	; 0x2c

        u8HwObjectID = Can_Ipw_au16MbIdxToObjIDMap[Can_pControllerConfig->Can_u8ControllerID][u8MbIdx];
    91bc:	9b05      	ldr	r3, [sp, #20]
    91be:	785b      	ldrb	r3, [r3, #1]
    91c0:	461a      	mov	r2, r3
    91c2:	f89d 300f 	ldrb.w	r3, [sp, #15]
    91c6:	493f      	ldr	r1, [pc, #252]	; (92c4 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x124>)
    91c8:	0152      	lsls	r2, r2, #5
    91ca:	4413      	add	r3, r2
    91cc:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
    91d0:	f8ad 3036 	strh.w	r3, [sp, #54]	; 0x36
        if ((CAN_43_FLEXCAN_HWOBJ_UNMAPPED != u8HwObjectID) && (FALSE == Can_pHwObjectConfig[u8HwObjectID].Can_bHwObjectUsesPolling))
    91d4:	f8bd 3036 	ldrh.w	r3, [sp, #54]	; 0x36
    91d8:	f64f 72ff 	movw	r2, #65535	; 0xffff
    91dc:	4293      	cmp	r3, r2
    91de:	d06c      	beq.n	92ba <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x11a>
    91e0:	f8bd 2036 	ldrh.w	r2, [sp, #54]	; 0x36
    91e4:	4613      	mov	r3, r2
    91e6:	00db      	lsls	r3, r3, #3
    91e8:	4413      	add	r3, r2
    91ea:	009b      	lsls	r3, r3, #2
    91ec:	461a      	mov	r2, r3
    91ee:	9b04      	ldr	r3, [sp, #16]
    91f0:	4413      	add	r3, r2
    91f2:	7b1b      	ldrb	r3, [r3, #12]
    91f4:	f083 0301 	eor.w	r3, r3, #1
    91f8:	b2db      	uxtb	r3, r3
    91fa:	2b00      	cmp	r3, #0
    91fc:	d05d      	beq.n	92ba <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x11a>
        {
            Can_pHwObject = &Can_pHwObjectConfig[u8HwObjectID];
    91fe:	f8bd 2036 	ldrh.w	r2, [sp, #54]	; 0x36
    9202:	4613      	mov	r3, r2
    9204:	00db      	lsls	r3, r3, #3
    9206:	4413      	add	r3, r2
    9208:	009b      	lsls	r3, r3, #2
    920a:	461a      	mov	r2, r3
    920c:	9b04      	ldr	r3, [sp, #16]
    920e:	4413      	add	r3, r2
    9210:	930c      	str	r3, [sp, #48]	; 0x30

            if (CAN_RX_NORMAL == Can_pHwObject->Can_eReceiveType)
    9212:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    9214:	699b      	ldr	r3, [r3, #24]
    9216:	2b00      	cmp	r3, #0
    9218:	d118      	bne.n	924c <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0xac>
            {
                pReceivedDataBuffer = (Can_Ipw_apxStatus[Can_pControllerConfig->Can_u8ControllerID])->mbs[Can_pHwObject->Can_u8HwBufferIndex].pMBmessage;
    921a:	4a2b      	ldr	r2, [pc, #172]	; (92c8 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x128>)
    921c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    921e:	7f1b      	ldrb	r3, [r3, #28]
    9220:	011b      	lsls	r3, r3, #4
    9222:	4413      	add	r3, r2
    9224:	681b      	ldr	r3, [r3, #0]
    9226:	930b      	str	r3, [sp, #44]	; 0x2c
                Can_Ipw_ParseData(&CanIf_Mailbox, \
    9228:	a906      	add	r1, sp, #24
    922a:	a809      	add	r0, sp, #36	; 0x24
    922c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    922e:	9300      	str	r3, [sp, #0]
    9230:	9b05      	ldr	r3, [sp, #20]
    9232:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    9234:	f7ff fcae 	bl	8b94 <Can_Ipw_ParseData>
                                  pReceivedDataBuffer, \
                                  Can_pControllerConfig, \
                                  Can_pHwObject \
                                 );
                /* ready to receive in next time */
                (void)FlexCAN_Ip_Receive(Can_pControllerConfig->Can_u8ControllerOffset, \
    9238:	9b05      	ldr	r3, [sp, #20]
    923a:	7898      	ldrb	r0, [r3, #2]
    923c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    923e:	7f19      	ldrb	r1, [r3, #28]
    9240:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    9242:	7b1b      	ldrb	r3, [r3, #12]
    9244:	2200      	movs	r2, #0
    9246:	f001 fe61 	bl	af0c <FlexCAN_Ip_Receive>
            else
            {
                /* prevent misra */
            }
        }
    }
    924a:	e036      	b.n	92ba <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x11a>
            else if (CAN_RX_LEGACY_FIFO == Can_pHwObject->Can_eReceiveType)
    924c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    924e:	699b      	ldr	r3, [r3, #24]
    9250:	2b01      	cmp	r3, #1
    9252:	d132      	bne.n	92ba <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x11a>
                if ((uint8)7U == u8MbIdx)
    9254:	f89d 300f 	ldrb.w	r3, [sp, #15]
    9258:	2b07      	cmp	r3, #7
    925a:	d10d      	bne.n	9278 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0xd8>
                    (void)Det_ReportRuntimeError((uint16)CAN_43_FLEXCAN_IPW_MODULE_ID, (uint8)CAN_43_FLEXCAN_INSTANCE, (uint8)CAN_43_FLEXCAN_SID_MAIN_FUNCTION_READ, (uint8)CAN_43_FLEXCAN_E_DATALOST);
    925c:	2301      	movs	r3, #1
    925e:	2208      	movs	r2, #8
    9260:	2100      	movs	r1, #0
    9262:	2050      	movs	r0, #80	; 0x50
    9264:	f00b f8c0 	bl	143e8 <Det_ReportRuntimeError>
                    if (NULL_PTR != Can_pControllerConfig->Can_pLegacyFiFoOvfNotif)
    9268:	9b05      	ldr	r3, [sp, #20]
    926a:	699b      	ldr	r3, [r3, #24]
    926c:	2b00      	cmp	r3, #0
    926e:	d024      	beq.n	92ba <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x11a>
                        Can_pControllerConfig->Can_pLegacyFiFoOvfNotif();
    9270:	9b05      	ldr	r3, [sp, #20]
    9272:	699b      	ldr	r3, [r3, #24]
    9274:	4798      	blx	r3
    }
    9276:	e020      	b.n	92ba <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x11a>
                else if ((uint8)6U == u8MbIdx)
    9278:	f89d 300f 	ldrb.w	r3, [sp, #15]
    927c:	2b06      	cmp	r3, #6
    927e:	d107      	bne.n	9290 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0xf0>
                    if (NULL_PTR != Can_pControllerConfig->Can_pLegacyFiFoWarnNotif)
    9280:	9b05      	ldr	r3, [sp, #20]
    9282:	695b      	ldr	r3, [r3, #20]
    9284:	2b00      	cmp	r3, #0
    9286:	d018      	beq.n	92ba <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x11a>
                        Can_pControllerConfig->Can_pLegacyFiFoWarnNotif();
    9288:	9b05      	ldr	r3, [sp, #20]
    928a:	695b      	ldr	r3, [r3, #20]
    928c:	4798      	blx	r3
    }
    928e:	e014      	b.n	92ba <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x11a>
                    pReceivedDataBuffer = (Can_Ipw_apxStatus[Can_pControllerConfig->Can_u8ControllerID])->mbs[Can_pHwObject->Can_u8HwBufferIndex].pMBmessage;
    9290:	4a0d      	ldr	r2, [pc, #52]	; (92c8 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer+0x128>)
    9292:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    9294:	7f1b      	ldrb	r3, [r3, #28]
    9296:	011b      	lsls	r3, r3, #4
    9298:	4413      	add	r3, r2
    929a:	681b      	ldr	r3, [r3, #0]
    929c:	930b      	str	r3, [sp, #44]	; 0x2c
                    Can_Ipw_ParseData(&CanIf_Mailbox, \
    929e:	a906      	add	r1, sp, #24
    92a0:	a809      	add	r0, sp, #36	; 0x24
    92a2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    92a4:	9300      	str	r3, [sp, #0]
    92a6:	9b05      	ldr	r3, [sp, #20]
    92a8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    92aa:	f7ff fc73 	bl	8b94 <Can_Ipw_ParseData>
                    (void)FlexCAN_Ip_RxFifo(Can_pControllerConfig->Can_u8ControllerOffset, NULL_PTR);
    92ae:	9b05      	ldr	r3, [sp, #20]
    92b0:	789b      	ldrb	r3, [r3, #2]
    92b2:	2100      	movs	r1, #0
    92b4:	4618      	mov	r0, r3
    92b6:	f001 ff27 	bl	b108 <FlexCAN_Ip_RxFifo>
    }
    92ba:	bf00      	nop
    92bc:	b00f      	add	sp, #60	; 0x3c
    92be:	f85d fb04 	ldr.w	pc, [sp], #4
    92c2:	bf00      	nop
    92c4:	1fff9004 	.word	0x1fff9004
    92c8:	1fff8da4 	.word	0x1fff8da4

000092cc <Can_43_FLEXCAN_Ipw_Init>:
#endif /* (CAN_43_FLEXCAN_MB_INTERRUPT_SUPPORT == STD_ON) */
/*==================================================================================================
*                                       GLOBAL FUNCTIONS
==================================================================================================*/
Std_ReturnType Can_43_FLEXCAN_Ipw_Init(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
    92cc:	b510      	push	{r4, lr}
    92ce:	b084      	sub	sp, #16
    92d0:	9001      	str	r0, [sp, #4]
    Std_ReturnType eRetVal = (Std_ReturnType)FLEXCAN_STATUS_ERROR;
    92d2:	2301      	movs	r3, #1
    92d4:	f88d 300c 	strb.w	r3, [sp, #12]
#if (CAN_43_FLEXCAN_MB_INTERRUPT_SUPPORT == STD_ON)
    /* The Index of Hoh in a group that refer to a controller */
    uint8 u8HwObjRefIdx = 0U;
    92d8:	2300      	movs	r3, #0
    92da:	f88d 300f 	strb.w	r3, [sp, #15]
    uint8 u8ObjIdx = 0U;
    92de:	2300      	movs	r3, #0
    92e0:	f88d 300e 	strb.w	r3, [sp, #14]
    const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject = NULL_PTR;
    92e4:	2300      	movs	r3, #0
    92e6:	9302      	str	r3, [sp, #8]
    uint8 u8HwBufferCount = 0U;
    92e8:	2300      	movs	r3, #0
    92ea:	f88d 300d 	strb.w	r3, [sp, #13]
    {
        Can_Ipw_u32Seconds = 0U;
    }
#endif
    /* @violates @ref Can_Ipw_c_REF_3 MISRA 2012 Advisory Rule 12.3 */
    eRetVal = (Std_ReturnType)Call_Can_FlexCan_Init(Can_pControllerConfig->Can_u8ControllerOffset, Can_Ipw_apxStatus[Can_pControllerConfig->Can_u8ControllerID], Can_pControllerConfig->HwChannelIpConfig->pFlexcanIpHwConfig);
    92ee:	9b01      	ldr	r3, [sp, #4]
    92f0:	7898      	ldrb	r0, [r3, #2]
    92f2:	4976      	ldr	r1, [pc, #472]	; (94cc <Can_43_FLEXCAN_Ipw_Init+0x200>)
    92f4:	9b01      	ldr	r3, [sp, #4]
    92f6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    92f8:	681b      	ldr	r3, [r3, #0]
    92fa:	461a      	mov	r2, r3
    92fc:	f001 fcfa 	bl	acf4 <FlexCAN_Ip_Init_Privileged>
    9300:	4603      	mov	r3, r0
    9302:	f88d 300c 	strb.w	r3, [sp, #12]
    
    /* by defaut, enable interrupt when setcontroller to start */
    Can_Ipw_abIsInterruptEnabled[Can_pControllerConfig->Can_u8ControllerID] = TRUE;
    9306:	9b01      	ldr	r3, [sp, #4]
    9308:	785b      	ldrb	r3, [r3, #1]
    930a:	461a      	mov	r2, r3
    930c:	4b70      	ldr	r3, [pc, #448]	; (94d0 <Can_43_FLEXCAN_Ipw_Init+0x204>)
    930e:	2101      	movs	r1, #1
    9310:	5499      	strb	r1, [r3, r2]
    if ((Std_ReturnType)FLEXCAN_STATUS_SUCCESS == eRetVal)
    9312:	f89d 300c 	ldrb.w	r3, [sp, #12]
    9316:	2b00      	cmp	r3, #0
    9318:	d13b      	bne.n	9392 <Can_43_FLEXCAN_Ipw_Init+0xc6>
    {
        /* disable all interrupts */
        (void)FlexCAN_Ip_DisableInterrupts(Can_pControllerConfig->Can_u8ControllerOffset);
    931a:	9b01      	ldr	r3, [sp, #4]
    931c:	789b      	ldrb	r3, [r3, #2]
    931e:	4618      	mov	r0, r3
    9320:	f003 f81c 	bl	c35c <FlexCAN_Ip_DisableInterrupts_Privileged>

        /* If the FlexCAN_Init retuns SUCCESS then the module is already in freezemode, and FlexCAN_Ip_SetTDCOffset and FlexCAN_Ip_SetTxArbitrationStartDelay will always retun success */
        if (Can_pControllerConfig->Can_pBaudrateConfig[Can_pControllerConfig->Can_u16DefaultBaudrateID].Can_bFDFrame)
    9324:	9b01      	ldr	r3, [sp, #4]
    9326:	6a1a      	ldr	r2, [r3, #32]
    9328:	9b01      	ldr	r3, [sp, #4]
    932a:	8b9b      	ldrh	r3, [r3, #28]
    932c:	4619      	mov	r1, r3
    932e:	2316      	movs	r3, #22
    9330:	fb01 f303 	mul.w	r3, r1, r3
    9334:	4413      	add	r3, r2
    9336:	785b      	ldrb	r3, [r3, #1]
    9338:	2b00      	cmp	r3, #0
    933a:	d018      	beq.n	936e <Can_43_FLEXCAN_Ipw_Init+0xa2>
        {
            (void)FlexCAN_Ip_SetTDCOffset(Can_pControllerConfig->Can_u8ControllerOffset, \
    933c:	9b01      	ldr	r3, [sp, #4]
    933e:	7898      	ldrb	r0, [r3, #2]
    9340:	9b01      	ldr	r3, [sp, #4]
    9342:	6a1a      	ldr	r2, [r3, #32]
    9344:	9b01      	ldr	r3, [sp, #4]
    9346:	8b9b      	ldrh	r3, [r3, #28]
    9348:	4619      	mov	r1, r3
    934a:	2316      	movs	r3, #22
    934c:	fb01 f303 	mul.w	r3, r1, r3
    9350:	4413      	add	r3, r2
    9352:	7cd9      	ldrb	r1, [r3, #19]
    9354:	9b01      	ldr	r3, [sp, #4]
    9356:	6a1a      	ldr	r2, [r3, #32]
    9358:	9b01      	ldr	r3, [sp, #4]
    935a:	8b9b      	ldrh	r3, [r3, #28]
    935c:	461c      	mov	r4, r3
    935e:	2316      	movs	r3, #22
    9360:	fb04 f303 	mul.w	r3, r4, r3
    9364:	4413      	add	r3, r2
    9366:	7d1b      	ldrb	r3, [r3, #20]
    9368:	461a      	mov	r2, r3
    936a:	f002 fee5 	bl	c138 <FlexCAN_Ip_SetTDCOffset_Privileged>
                                          Can_pControllerConfig->Can_pBaudrateConfig[Can_pControllerConfig->Can_u16DefaultBaudrateID].Can_bTrcvDelayEnable, \
                                          Can_pControllerConfig->Can_pBaudrateConfig[Can_pControllerConfig->Can_u16DefaultBaudrateID].Can_u8TrcvDelayCompOffset);
        }
        (void)FlexCAN_Ip_SetTxArbitrationStartDelay(Can_pControllerConfig->Can_u8ControllerOffset, \
    936e:	9b01      	ldr	r3, [sp, #4]
    9370:	7898      	ldrb	r0, [r3, #2]
    9372:	9b01      	ldr	r3, [sp, #4]
    9374:	6a1a      	ldr	r2, [r3, #32]
    9376:	9b01      	ldr	r3, [sp, #4]
    9378:	8b9b      	ldrh	r3, [r3, #28]
    937a:	4619      	mov	r1, r3
    937c:	2316      	movs	r3, #22
    937e:	fb01 f303 	mul.w	r3, r1, r3
    9382:	4413      	add	r3, r2
    9384:	7c9b      	ldrb	r3, [r3, #18]
    9386:	4619      	mov	r1, r3
    9388:	f002 ff2a 	bl	c1e0 <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged>
                                                    Can_pControllerConfig->Can_pBaudrateConfig[Can_pControllerConfig->Can_u16DefaultBaudrateID].Can_u8TxArbitrationStartDelay);
        
        /* Init all Rx objects */
        Can_Ipw_InitRx(Can_pControllerConfig);
    938c:	9801      	ldr	r0, [sp, #4]
    938e:	f000 fb05 	bl	999c <Can_Ipw_InitRx>
    }

#if (CAN_43_FLEXCAN_MB_INTERRUPT_SUPPORT == STD_ON)
    for (u8HwBufferCount = 0U; u8HwBufferCount < CAN_43_FLEXCAN_HWMB_COUNT; u8HwBufferCount++)
    9392:	2300      	movs	r3, #0
    9394:	f88d 300d 	strb.w	r3, [sp, #13]
    9398:	e010      	b.n	93bc <Can_43_FLEXCAN_Ipw_Init+0xf0>
    {
        Can_Ipw_au16MbIdxToObjIDMap[Can_pControllerConfig->Can_u8ControllerID][u8HwBufferCount] = CAN_43_FLEXCAN_HWOBJ_UNMAPPED;
    939a:	9b01      	ldr	r3, [sp, #4]
    939c:	785b      	ldrb	r3, [r3, #1]
    939e:	461a      	mov	r2, r3
    93a0:	f89d 300d 	ldrb.w	r3, [sp, #13]
    93a4:	494b      	ldr	r1, [pc, #300]	; (94d4 <Can_43_FLEXCAN_Ipw_Init+0x208>)
    93a6:	0152      	lsls	r2, r2, #5
    93a8:	4413      	add	r3, r2
    93aa:	f64f 72ff 	movw	r2, #65535	; 0xffff
    93ae:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
    for (u8HwBufferCount = 0U; u8HwBufferCount < CAN_43_FLEXCAN_HWMB_COUNT; u8HwBufferCount++)
    93b2:	f89d 300d 	ldrb.w	r3, [sp, #13]
    93b6:	3301      	adds	r3, #1
    93b8:	f88d 300d 	strb.w	r3, [sp, #13]
    93bc:	f89d 300d 	ldrb.w	r3, [sp, #13]
    93c0:	2b1f      	cmp	r3, #31
    93c2:	d9ea      	bls.n	939a <Can_43_FLEXCAN_Ipw_Init+0xce>
    }
    /* Map MB index to hardware object ID */
    for (u8HwObjRefIdx = 0U; u8HwObjRefIdx < Can_pControllerConfig->Can_u8HwObjectRefCount; u8HwObjRefIdx++)
    93c4:	2300      	movs	r3, #0
    93c6:	f88d 300f 	strb.w	r3, [sp, #15]
    93ca:	e06b      	b.n	94a4 <Can_43_FLEXCAN_Ipw_Init+0x1d8>
    {
        Can_pHwObject = Can_pControllerConfig->Can_ppHwObject[u8HwObjRefIdx];
    93cc:	9b01      	ldr	r3, [sp, #4]
    93ce:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    93d0:	f89d 300f 	ldrb.w	r3, [sp, #15]
    93d4:	009b      	lsls	r3, r3, #2
    93d6:	4413      	add	r3, r2
    93d8:	681b      	ldr	r3, [r3, #0]
    93da:	9302      	str	r3, [sp, #8]
        switch (Can_pHwObject->Can_eReceiveType)
    93dc:	9b02      	ldr	r3, [sp, #8]
    93de:	699b      	ldr	r3, [r3, #24]
    93e0:	2b03      	cmp	r3, #3
    93e2:	d006      	beq.n	93f2 <Can_43_FLEXCAN_Ipw_Init+0x126>
    93e4:	2b03      	cmp	r3, #3
    93e6:	d857      	bhi.n	9498 <Can_43_FLEXCAN_Ipw_Init+0x1cc>
    93e8:	2b00      	cmp	r3, #0
    93ea:	d023      	beq.n	9434 <Can_43_FLEXCAN_Ipw_Init+0x168>
    93ec:	2b01      	cmp	r3, #1
    93ee:	d02f      	beq.n	9450 <Can_43_FLEXCAN_Ipw_Init+0x184>
                break;
            }
            default:
            {
                /* don't map for enhance fifo object because of out of message buffer memory */
                break;
    93f0:	e052      	b.n	9498 <Can_43_FLEXCAN_Ipw_Init+0x1cc>
                for (u8ObjIdx = 0U; u8ObjIdx < Can_pHwObject->Can_u8ObjectCount; u8ObjIdx++)
    93f2:	2300      	movs	r3, #0
    93f4:	f88d 300e 	strb.w	r3, [sp, #14]
    93f8:	e015      	b.n	9426 <Can_43_FLEXCAN_Ipw_Init+0x15a>
                    Can_Ipw_au16MbIdxToObjIDMap[Can_pControllerConfig->Can_u8ControllerID][Can_pHwObject->Can_u8HwBufferIndex + u8ObjIdx] = Can_pHwObject->Can_HwObjectID;
    93fa:	9b01      	ldr	r3, [sp, #4]
    93fc:	785b      	ldrb	r3, [r3, #1]
    93fe:	461c      	mov	r4, r3
    9400:	9b02      	ldr	r3, [sp, #8]
    9402:	7f1b      	ldrb	r3, [r3, #28]
    9404:	461a      	mov	r2, r3
    9406:	f89d 300e 	ldrb.w	r3, [sp, #14]
    940a:	4413      	add	r3, r2
    940c:	9a02      	ldr	r2, [sp, #8]
    940e:	8810      	ldrh	r0, [r2, #0]
    9410:	4930      	ldr	r1, [pc, #192]	; (94d4 <Can_43_FLEXCAN_Ipw_Init+0x208>)
    9412:	0162      	lsls	r2, r4, #5
    9414:	4413      	add	r3, r2
    9416:	4602      	mov	r2, r0
    9418:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
                for (u8ObjIdx = 0U; u8ObjIdx < Can_pHwObject->Can_u8ObjectCount; u8ObjIdx++)
    941c:	f89d 300e 	ldrb.w	r3, [sp, #14]
    9420:	3301      	adds	r3, #1
    9422:	f88d 300e 	strb.w	r3, [sp, #14]
    9426:	9b02      	ldr	r3, [sp, #8]
    9428:	7b9b      	ldrb	r3, [r3, #14]
    942a:	f89d 200e 	ldrb.w	r2, [sp, #14]
    942e:	429a      	cmp	r2, r3
    9430:	d3e3      	bcc.n	93fa <Can_43_FLEXCAN_Ipw_Init+0x12e>
                break;
    9432:	e032      	b.n	949a <Can_43_FLEXCAN_Ipw_Init+0x1ce>
                Can_Ipw_au16MbIdxToObjIDMap[Can_pControllerConfig->Can_u8ControllerID][Can_pHwObject->Can_u8HwBufferIndex] = Can_pHwObject->Can_HwObjectID;
    9434:	9b01      	ldr	r3, [sp, #4]
    9436:	785b      	ldrb	r3, [r3, #1]
    9438:	461c      	mov	r4, r3
    943a:	9b02      	ldr	r3, [sp, #8]
    943c:	7f1b      	ldrb	r3, [r3, #28]
    943e:	4618      	mov	r0, r3
    9440:	9b02      	ldr	r3, [sp, #8]
    9442:	8819      	ldrh	r1, [r3, #0]
    9444:	4a23      	ldr	r2, [pc, #140]	; (94d4 <Can_43_FLEXCAN_Ipw_Init+0x208>)
    9446:	0163      	lsls	r3, r4, #5
    9448:	4403      	add	r3, r0
    944a:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
                break;
    944e:	e024      	b.n	949a <Can_43_FLEXCAN_Ipw_Init+0x1ce>
                Can_Ipw_au16MbIdxToObjIDMap[Can_pControllerConfig->Can_u8ControllerID][Can_pHwObject->Can_u8HwBufferIndex] = Can_pHwObject->Can_HwObjectID;
    9450:	9b01      	ldr	r3, [sp, #4]
    9452:	785b      	ldrb	r3, [r3, #1]
    9454:	461c      	mov	r4, r3
    9456:	9b02      	ldr	r3, [sp, #8]
    9458:	7f1b      	ldrb	r3, [r3, #28]
    945a:	4618      	mov	r0, r3
    945c:	9b02      	ldr	r3, [sp, #8]
    945e:	8819      	ldrh	r1, [r3, #0]
    9460:	4a1c      	ldr	r2, [pc, #112]	; (94d4 <Can_43_FLEXCAN_Ipw_Init+0x208>)
    9462:	0163      	lsls	r3, r4, #5
    9464:	4403      	add	r3, r0
    9466:	f822 1013 	strh.w	r1, [r2, r3, lsl #1]
                Can_Ipw_au16MbIdxToObjIDMap[Can_pControllerConfig->Can_u8ControllerID][6U] = Can_pHwObject->Can_HwObjectID;
    946a:	9b01      	ldr	r3, [sp, #4]
    946c:	785b      	ldrb	r3, [r3, #1]
    946e:	4618      	mov	r0, r3
    9470:	9b02      	ldr	r3, [sp, #8]
    9472:	8819      	ldrh	r1, [r3, #0]
    9474:	4a17      	ldr	r2, [pc, #92]	; (94d4 <Can_43_FLEXCAN_Ipw_Init+0x208>)
    9476:	0183      	lsls	r3, r0, #6
    9478:	4413      	add	r3, r2
    947a:	330c      	adds	r3, #12
    947c:	460a      	mov	r2, r1
    947e:	801a      	strh	r2, [r3, #0]
                Can_Ipw_au16MbIdxToObjIDMap[Can_pControllerConfig->Can_u8ControllerID][7U] = Can_pHwObject->Can_HwObjectID;
    9480:	9b01      	ldr	r3, [sp, #4]
    9482:	785b      	ldrb	r3, [r3, #1]
    9484:	4618      	mov	r0, r3
    9486:	9b02      	ldr	r3, [sp, #8]
    9488:	8819      	ldrh	r1, [r3, #0]
    948a:	4a12      	ldr	r2, [pc, #72]	; (94d4 <Can_43_FLEXCAN_Ipw_Init+0x208>)
    948c:	0183      	lsls	r3, r0, #6
    948e:	4413      	add	r3, r2
    9490:	330e      	adds	r3, #14
    9492:	460a      	mov	r2, r1
    9494:	801a      	strh	r2, [r3, #0]
                break;
    9496:	e000      	b.n	949a <Can_43_FLEXCAN_Ipw_Init+0x1ce>
                break;
    9498:	bf00      	nop
    for (u8HwObjRefIdx = 0U; u8HwObjRefIdx < Can_pControllerConfig->Can_u8HwObjectRefCount; u8HwObjRefIdx++)
    949a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    949e:	3301      	adds	r3, #1
    94a0:	f88d 300f 	strb.w	r3, [sp, #15]
    94a4:	9b01      	ldr	r3, [sp, #4]
    94a6:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
    94aa:	f89d 200f 	ldrb.w	r2, [sp, #15]
    94ae:	429a      	cmp	r2, r3
    94b0:	d38c      	bcc.n	93cc <Can_43_FLEXCAN_Ipw_Init+0x100>
            }
        }
    }
#endif /* MB_INTERRUPT_SUPPORT */
    eRetVal = (Std_ReturnType)FlexCAN_Ip_SetStopMode(Can_pControllerConfig->Can_u8ControllerOffset);
    94b2:	9b01      	ldr	r3, [sp, #4]
    94b4:	789b      	ldrb	r3, [r3, #2]
    94b6:	4618      	mov	r0, r3
    94b8:	f002 fca0 	bl	bdfc <FlexCAN_Ip_SetStopMode_Privileged>
    94bc:	4603      	mov	r3, r0
    94be:	f88d 300c 	strb.w	r3, [sp, #12]

    return (Std_ReturnType)eRetVal;
    94c2:	f89d 300c 	ldrb.w	r3, [sp, #12]
}
    94c6:	4618      	mov	r0, r3
    94c8:	b004      	add	sp, #16
    94ca:	bd10      	pop	{r4, pc}
    94cc:	1fff8da4 	.word	0x1fff8da4
    94d0:	1fff9044 	.word	0x1fff9044
    94d4:	1fff9004 	.word	0x1fff9004

000094d8 <Can_43_FLEXCAN_Ipw_DeInit>:

/**
*   @brief      De-Initialize Controller
*/
void Can_43_FLEXCAN_Ipw_DeInit(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
    94d8:	b500      	push	{lr}
    94da:	b083      	sub	sp, #12
    94dc:	9001      	str	r0, [sp, #4]
    /* @violates @ref Can_43_FLEXCAN_Ipw_c_REF_3 MISRA 2012 Advisory Rule 12.3 */
    (void)FlexCAN_Ip_Deinit(Can_pControllerConfig->Can_u8ControllerOffset);
    94de:	9b01      	ldr	r3, [sp, #4]
    94e0:	789b      	ldrb	r3, [r3, #2]
    94e2:	4618      	mov	r0, r3
    94e4:	f002 faf6 	bl	bad4 <FlexCAN_Ip_Deinit_Privileged>
}
    94e8:	bf00      	nop
    94ea:	b003      	add	sp, #12
    94ec:	f85d fb04 	ldr.w	pc, [sp], #4

000094f0 <Can_43_FLEXCAN_Ipw_SetControlerErrorInit>:

/**
*   @brief      Set Error Initialization and set Controller to start Mode.
*/
static Std_ReturnType Can_43_FLEXCAN_Ipw_SetControlerErrorInit(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
    94f0:	b500      	push	{lr}
    94f2:	b085      	sub	sp, #20
    94f4:	9001      	str	r0, [sp, #4]
    Flexcan_Ip_StatusType eRetVal = FLEXCAN_STATUS_SUCCESS;
    94f6:	2300      	movs	r3, #0
    94f8:	9303      	str	r3, [sp, #12]

    if (TRUE == Can_Ipw_abIsInterruptEnabled[Can_pControllerConfig->Can_u8ControllerID])
    94fa:	9b01      	ldr	r3, [sp, #4]
    94fc:	785b      	ldrb	r3, [r3, #1]
    94fe:	461a      	mov	r2, r3
    9500:	4b11      	ldr	r3, [pc, #68]	; (9548 <Can_43_FLEXCAN_Ipw_SetControlerErrorInit+0x58>)
    9502:	5c9b      	ldrb	r3, [r3, r2]
    9504:	2b00      	cmp	r3, #0
    9506:	d012      	beq.n	952e <Can_43_FLEXCAN_Ipw_SetControlerErrorInit+0x3e>
    {
#if (CAN_43_FLEXCAN_ERROR_INTERRUPT_SUPPORT == STD_ON)
        (void)FlexCAN_Ip_SetErrorInt(Can_pControllerConfig->Can_u8ControllerOffset, FLEXCAN_IP_INT_ERR, TRUE);
#endif /* ERROR_INTERRUPT_SUPPORT */
#if (CAN_43_FLEXCAN_BUSOFF_INTERRUPT_SUPPORT == STD_ON)
        if (FALSE == Can_pControllerConfig->Can_bBusOffUsesPolling)
    9508:	9b01      	ldr	r3, [sp, #4]
    950a:	7a5b      	ldrb	r3, [r3, #9]
    950c:	f083 0301 	eor.w	r3, r3, #1
    9510:	b2db      	uxtb	r3, r3
    9512:	2b00      	cmp	r3, #0
    9514:	d006      	beq.n	9524 <Can_43_FLEXCAN_Ipw_SetControlerErrorInit+0x34>
        {
            (void)FlexCAN_Ip_SetErrorInt(Can_pControllerConfig->Can_u8ControllerOffset, FLEXCAN_IP_INT_BUSOFF, TRUE);
    9516:	9b01      	ldr	r3, [sp, #4]
    9518:	789b      	ldrb	r3, [r3, #2]
    951a:	2201      	movs	r2, #1
    951c:	2104      	movs	r1, #4
    951e:	4618      	mov	r0, r3
    9520:	f002 ff48 	bl	c3b4 <FlexCAN_Ip_SetErrorInt_Privileged>
        }
#endif  /* BUSOFF_INTERRUPT_SUPPORT */
        (void)FlexCAN_Ip_EnableInterrupts(Can_pControllerConfig->Can_u8ControllerOffset);
    9524:	9b01      	ldr	r3, [sp, #4]
    9526:	789b      	ldrb	r3, [r3, #2]
    9528:	4618      	mov	r0, r3
    952a:	f002 fee9 	bl	c300 <FlexCAN_Ip_EnableInterrupts_Privileged>
    }
    eRetVal = FlexCAN_Ip_SetStartMode(Can_pControllerConfig->Can_u8ControllerOffset);
    952e:	9b01      	ldr	r3, [sp, #4]
    9530:	789b      	ldrb	r3, [r3, #2]
    9532:	4618      	mov	r0, r3
    9534:	f002 fc42 	bl	bdbc <FlexCAN_Ip_SetStartMode_Privileged>
    9538:	9003      	str	r0, [sp, #12]

    return (Std_ReturnType)eRetVal;
    953a:	9b03      	ldr	r3, [sp, #12]
    953c:	b2db      	uxtb	r3, r3
}
    953e:	4618      	mov	r0, r3
    9540:	b005      	add	sp, #20
    9542:	f85d fb04 	ldr.w	pc, [sp], #4
    9546:	bf00      	nop
    9548:	1fff9044 	.word	0x1fff9044

0000954c <Can_43_FLEXCAN_Ipw_SetControllerToStartMode>:

/**
*   @brief      Set Controller to participate the CAN network
*/
Std_ReturnType Can_43_FLEXCAN_Ipw_SetControllerToStartMode(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
    954c:	b500      	push	{lr}
    954e:	b087      	sub	sp, #28
    9550:	9001      	str	r0, [sp, #4]
#if (CAN_43_FLEXCAN_MB_INTERRUPT_SUPPORT == STD_ON)
    uint8 u8HwObjRefIdx = 0U;
    9552:	2300      	movs	r3, #0
    9554:	f88d 3017 	strb.w	r3, [sp, #23]
    const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject = NULL_PTR;
    9558:	2300      	movs	r3, #0
    955a:	9303      	str	r3, [sp, #12]
        {
            Can_Ipw_u32CurrentCompareVal = Stm_Ip_GetCompareValue(CAN_43_FLEXCAN_TS_STM_INSTANCE, CAN_43_FLEXCAN_TS_STM_CHANNEL);
        }
    }
#endif
    eRetVal = FlexCAN_Ip_Init(Can_pControllerConfig->Can_u8ControllerOffset, \
    955c:	9b01      	ldr	r3, [sp, #4]
    955e:	7898      	ldrb	r0, [r3, #2]
    9560:	4930      	ldr	r1, [pc, #192]	; (9624 <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0xd8>)
    9562:	9b01      	ldr	r3, [sp, #4]
    9564:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    9566:	681b      	ldr	r3, [r3, #0]
    9568:	461a      	mov	r2, r3
    956a:	f001 fbc3 	bl	acf4 <FlexCAN_Ip_Init_Privileged>
    956e:	9004      	str	r0, [sp, #16]
                                                    Can_Ipw_apxStatus[Can_pControllerConfig->Can_u8ControllerID], \
                                                    Can_pControllerConfig->HwChannelIpConfig->pFlexcanIpHwConfig);

    if (FLEXCAN_STATUS_SUCCESS == eRetVal)
    9570:	9b04      	ldr	r3, [sp, #16]
    9572:	2b00      	cmp	r3, #0
    9574:	d14f      	bne.n	9616 <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0xca>
    {
        /* disable all interrupts */
        (void)FlexCAN_Ip_DisableInterrupts(Can_pControllerConfig->Can_u8ControllerOffset);
    9576:	9b01      	ldr	r3, [sp, #4]
    9578:	789b      	ldrb	r3, [r3, #2]
    957a:	4618      	mov	r0, r3
    957c:	f002 feee 	bl	c35c <FlexCAN_Ip_DisableInterrupts_Privileged>

        /* Re-Init baudrate */
        Can_Ipw_InitBaudrate(Can_pControllerConfig);
    9580:	9801      	ldr	r0, [sp, #4]
    9582:	f7ff fd87 	bl	9094 <Can_Ipw_InitBaudrate>

        /* Re-Init all Rx Objects */
        Can_Ipw_InitRx(Can_pControllerConfig);
    9586:	9801      	ldr	r0, [sp, #4]
    9588:	f000 fa08 	bl	999c <Can_Ipw_InitRx>
            Can_Ipw_abIsTxPduReady[Can_pControllerConfig->Can_u8ControllerID][MbIdx] = FALSE;
        }
    #endif /* ((CAN_43_FLEXCAN_TIMESTAMP_ENABLE == STD_ON) && ((CAN_43_FLEXCAN_TX_POLLING_SUPPORT == STD_ON) || (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON))) */

    #if (CAN_43_FLEXCAN_MB_INTERRUPT_SUPPORT == STD_ON)
        for (u8HwObjRefIdx = 0U; u8HwObjRefIdx < Can_pControllerConfig->Can_u8HwObjectRefCount; u8HwObjRefIdx++)
    958c:	2300      	movs	r3, #0
    958e:	f88d 3017 	strb.w	r3, [sp, #23]
    9592:	e02f      	b.n	95f4 <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0xa8>
        {
            Can_pHwObject = (const Can_43_FLEXCAN_HwObjectConfigType *)Can_pControllerConfig->Can_ppHwObject[u8HwObjRefIdx];
    9594:	9b01      	ldr	r3, [sp, #4]
    9596:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    9598:	f89d 3017 	ldrb.w	r3, [sp, #23]
    959c:	009b      	lsls	r3, r3, #2
    959e:	4413      	add	r3, r2
    95a0:	681b      	ldr	r3, [r3, #0]
    95a2:	9303      	str	r3, [sp, #12]

            if (FALSE == Can_pHwObject->Can_bHwObjectUsesPolling)
    95a4:	9b03      	ldr	r3, [sp, #12]
    95a6:	7b1b      	ldrb	r3, [r3, #12]
    95a8:	f083 0301 	eor.w	r3, r3, #1
    95ac:	b2db      	uxtb	r3, r3
    95ae:	2b00      	cmp	r3, #0
    95b0:	d018      	beq.n	95e4 <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0x98>
            {
                switch (Can_pHwObject->Can_eReceiveType)
    95b2:	9b03      	ldr	r3, [sp, #12]
    95b4:	699b      	ldr	r3, [r3, #24]
    95b6:	2b00      	cmp	r3, #0
    95b8:	d003      	beq.n	95c2 <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0x76>
    95ba:	3b01      	subs	r3, #1
    95bc:	2b01      	cmp	r3, #1
    95be:	d813      	bhi.n	95e8 <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0x9c>
    95c0:	e009      	b.n	95d6 <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0x8a>
                {
                    case CAN_RX_NORMAL:
                    {
                        (void)FlexCAN_Ip_Receive(Can_pControllerConfig->Can_u8ControllerOffset, \
    95c2:	9b01      	ldr	r3, [sp, #4]
    95c4:	7898      	ldrb	r0, [r3, #2]
    95c6:	9b03      	ldr	r3, [sp, #12]
    95c8:	7f19      	ldrb	r1, [r3, #28]
    95ca:	9b03      	ldr	r3, [sp, #12]
    95cc:	7b1b      	ldrb	r3, [r3, #12]
    95ce:	2200      	movs	r2, #0
    95d0:	f001 fc9c 	bl	af0c <FlexCAN_Ip_Receive>
                                                 Can_pHwObject->Can_u8HwBufferIndex, \
                                                 NULL_PTR, \
                                                 Can_pHwObject->Can_bHwObjectUsesPolling \
                                                );
                        break;
    95d4:	e009      	b.n	95ea <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0x9e>
                            (void)FlexCAN_Ip_RxFifo(Can_pControllerConfig->Can_u8ControllerOffset, Can_pControllerConfig->pDmaDstAddr);
                        }
                        else
                    #endif
                        {
                            (void)FlexCAN_Ip_RxFifo(Can_pControllerConfig->Can_u8ControllerOffset, NULL_PTR);
    95d6:	9b01      	ldr	r3, [sp, #4]
    95d8:	789b      	ldrb	r3, [r3, #2]
    95da:	2100      	movs	r1, #0
    95dc:	4618      	mov	r0, r3
    95de:	f001 fd93 	bl	b108 <FlexCAN_Ip_RxFifo>
                        }
                        break;
    95e2:	e002      	b.n	95ea <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0x9e>
                    {
                        /* nothing to do(TX object) */
                        break;
                    }
                }
            }
    95e4:	bf00      	nop
    95e6:	e000      	b.n	95ea <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0x9e>
                        break;
    95e8:	bf00      	nop
        for (u8HwObjRefIdx = 0U; u8HwObjRefIdx < Can_pControllerConfig->Can_u8HwObjectRefCount; u8HwObjRefIdx++)
    95ea:	f89d 3017 	ldrb.w	r3, [sp, #23]
    95ee:	3301      	adds	r3, #1
    95f0:	f88d 3017 	strb.w	r3, [sp, #23]
    95f4:	9b01      	ldr	r3, [sp, #4]
    95f6:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
    95fa:	f89d 2017 	ldrb.w	r2, [sp, #23]
    95fe:	429a      	cmp	r2, r3
    9600:	d3c8      	bcc.n	9594 <Can_43_FLEXCAN_Ipw_SetControllerToStartMode+0x48>
        }
    #endif /* CAN_43_FLEXCAN_MB_INTERRUPT_SUPPORT == STD_ON */
        eRetVal = ((Std_ReturnType)E_OK == Can_43_FLEXCAN_Ipw_SetControlerErrorInit(Can_pControllerConfig)) ? (FLEXCAN_STATUS_SUCCESS) : (FLEXCAN_STATUS_ERROR);
    9602:	9801      	ldr	r0, [sp, #4]
    9604:	f7ff ff74 	bl	94f0 <Can_43_FLEXCAN_Ipw_SetControlerErrorInit>
    9608:	4603      	mov	r3, r0
    960a:	2b00      	cmp	r3, #0
    960c:	bf14      	ite	ne
    960e:	2301      	movne	r3, #1
    9610:	2300      	moveq	r3, #0
    9612:	b2db      	uxtb	r3, r3
    9614:	9304      	str	r3, [sp, #16]
    }
    return (Std_ReturnType)eRetVal;
    9616:	9b04      	ldr	r3, [sp, #16]
    9618:	b2db      	uxtb	r3, r3
}
    961a:	4618      	mov	r0, r3
    961c:	b007      	add	sp, #28
    961e:	f85d fb04 	ldr.w	pc, [sp], #4
    9622:	bf00      	nop
    9624:	1fff8da4 	.word	0x1fff8da4

00009628 <Can_43_FLEXCAN_Ipw_SetControllerToStopMode>:

/**
*   @brief      Set Controller to stop participating the CAN network
*/
Std_ReturnType Can_43_FLEXCAN_Ipw_SetControllerToStopMode(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
    9628:	b500      	push	{lr}
    962a:	b085      	sub	sp, #20
    962c:	9001      	str	r0, [sp, #4]
    * that are not allowed in the new state. 
    * [SWS_Can_00426]  Disabling of CAN interrupts shall not be executed, when CAN
    * interrupts have been disabled by function Can_DisableControllerInterrupts.
    */
    Std_ReturnType eReturnValue;
    uint8 u8HwObjRefIdx = 0U;
    962e:	2300      	movs	r3, #0
    9630:	f88d 300e 	strb.w	r3, [sp, #14]
    const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject;
    uint8 u8Idx = 0U;
    9634:	2300      	movs	r3, #0
    9636:	f88d 300d 	strb.w	r3, [sp, #13]

    if (FLEXCAN_STATUS_SUCCESS == FlexCAN_Ip_EnterFreezeMode(Can_pControllerConfig->Can_u8ControllerOffset))
    963a:	9b01      	ldr	r3, [sp, #4]
    963c:	789b      	ldrb	r3, [r3, #2]
    963e:	4618      	mov	r0, r3
    9640:	f002 f986 	bl	b950 <FlexCAN_Ip_EnterFreezeMode_Privileged>
    9644:	4603      	mov	r3, r0
    9646:	2b00      	cmp	r3, #0
    9648:	d160      	bne.n	970c <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0xe4>
    {
    #if (CAN_43_FLEXCAN_PUBLIC_ICOM_SUPPORT == STD_ON)
        (void)FlexCAN_Ip_ConfigPN(Can_pControllerConfig->Can_u8ControllerOffset, FALSE, NULL_PTR);
    #endif

    if (TRUE == Can_Ipw_abIsInterruptEnabled[Can_pControllerConfig->Can_u8ControllerID])
    964a:	9b01      	ldr	r3, [sp, #4]
    964c:	785b      	ldrb	r3, [r3, #1]
    964e:	461a      	mov	r2, r3
    9650:	4b33      	ldr	r3, [pc, #204]	; (9720 <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0xf8>)
    9652:	5c9b      	ldrb	r3, [r3, r2]
    9654:	2b00      	cmp	r3, #0
    9656:	d012      	beq.n	967e <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0x56>
    {
        (void)FlexCAN_Ip_DisableInterrupts(Can_pControllerConfig->Can_u8ControllerOffset);
    9658:	9b01      	ldr	r3, [sp, #4]
    965a:	789b      	ldrb	r3, [r3, #2]
    965c:	4618      	mov	r0, r3
    965e:	f002 fe7d 	bl	c35c <FlexCAN_Ip_DisableInterrupts_Privileged>
#if (CAN_43_FLEXCAN_ERROR_INTERRUPT_SUPPORT == STD_ON)
        (void)FlexCAN_Ip_SetErrorInt(Can_pControllerConfig->Can_u8ControllerOffset, FLEXCAN_IP_INT_ERR, FALSE);
#endif  /*  ERROR_INTERRUPT_SUPPORT */
#if (CAN_43_FLEXCAN_BUSOFF_INTERRUPT_SUPPORT == STD_ON)
        if (FALSE == Can_pControllerConfig->Can_bBusOffUsesPolling)
    9662:	9b01      	ldr	r3, [sp, #4]
    9664:	7a5b      	ldrb	r3, [r3, #9]
    9666:	f083 0301 	eor.w	r3, r3, #1
    966a:	b2db      	uxtb	r3, r3
    966c:	2b00      	cmp	r3, #0
    966e:	d006      	beq.n	967e <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0x56>
        {
            (void)FlexCAN_Ip_SetErrorInt(Can_pControllerConfig->Can_u8ControllerOffset, FLEXCAN_IP_INT_BUSOFF, FALSE);
    9670:	9b01      	ldr	r3, [sp, #4]
    9672:	789b      	ldrb	r3, [r3, #2]
    9674:	2200      	movs	r2, #0
    9676:	2104      	movs	r1, #4
    9678:	4618      	mov	r0, r3
    967a:	f002 fe9b 	bl	c3b4 <FlexCAN_Ip_SetErrorInt_Privileged>
        }
#endif /* BUSOFF_INTERRUPT_SUPPORT */
    }
    for (u8HwObjRefIdx = 0U; u8HwObjRefIdx < Can_pControllerConfig->Can_u8HwObjectRefCount; u8HwObjRefIdx++)
    967e:	2300      	movs	r3, #0
    9680:	f88d 300e 	strb.w	r3, [sp, #14]
    9684:	e032      	b.n	96ec <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0xc4>
    {
        Can_pHwObject = (const Can_43_FLEXCAN_HwObjectConfigType *)Can_pControllerConfig->Can_ppHwObject[u8HwObjRefIdx];
    9686:	9b01      	ldr	r3, [sp, #4]
    9688:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    968a:	f89d 300e 	ldrb.w	r3, [sp, #14]
    968e:	009b      	lsls	r3, r3, #2
    9690:	4413      	add	r3, r2
    9692:	681b      	ldr	r3, [r3, #0]
    9694:	9302      	str	r3, [sp, #8]

        if (CAN_TX_NORMAL == Can_pHwObject->Can_eReceiveType)
    9696:	9b02      	ldr	r3, [sp, #8]
    9698:	699b      	ldr	r3, [r3, #24]
    969a:	2b03      	cmp	r3, #3
    969c:	d119      	bne.n	96d2 <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0xaa>
        {
            u8Idx = 0U;
    969e:	2300      	movs	r3, #0
    96a0:	f88d 300d 	strb.w	r3, [sp, #13]
            do
            {
                (void)FlexCAN_Ip_AbortTransfer(Can_pControllerConfig->Can_u8ControllerOffset, Can_pHwObject->Can_u8HwBufferIndex + u8Idx);
    96a4:	9b01      	ldr	r3, [sp, #4]
    96a6:	7898      	ldrb	r0, [r3, #2]
    96a8:	9b02      	ldr	r3, [sp, #8]
    96aa:	7f1a      	ldrb	r2, [r3, #28]
    96ac:	f89d 300d 	ldrb.w	r3, [sp, #13]
    96b0:	4413      	add	r3, r2
    96b2:	b2db      	uxtb	r3, r3
    96b4:	4619      	mov	r1, r3
    96b6:	f002 ff03 	bl	c4c0 <FlexCAN_Ip_AbortTransfer>
                u8Idx++;
    96ba:	f89d 300d 	ldrb.w	r3, [sp, #13]
    96be:	3301      	adds	r3, #1
    96c0:	f88d 300d 	strb.w	r3, [sp, #13]
            }while (u8Idx < Can_pHwObject->Can_u8ObjectCount);
    96c4:	9b02      	ldr	r3, [sp, #8]
    96c6:	7b9b      	ldrb	r3, [r3, #14]
    96c8:	f89d 200d 	ldrb.w	r2, [sp, #13]
    96cc:	429a      	cmp	r2, r3
    96ce:	d3e9      	bcc.n	96a4 <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0x7c>
    96d0:	e007      	b.n	96e2 <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0xba>
        }
        else
        {
            (void)FlexCAN_Ip_AbortTransfer(Can_pControllerConfig->Can_u8ControllerOffset, Can_pHwObject->Can_u8HwBufferIndex);
    96d2:	9b01      	ldr	r3, [sp, #4]
    96d4:	789a      	ldrb	r2, [r3, #2]
    96d6:	9b02      	ldr	r3, [sp, #8]
    96d8:	7f1b      	ldrb	r3, [r3, #28]
    96da:	4619      	mov	r1, r3
    96dc:	4610      	mov	r0, r2
    96de:	f002 feef 	bl	c4c0 <FlexCAN_Ip_AbortTransfer>
    for (u8HwObjRefIdx = 0U; u8HwObjRefIdx < Can_pControllerConfig->Can_u8HwObjectRefCount; u8HwObjRefIdx++)
    96e2:	f89d 300e 	ldrb.w	r3, [sp, #14]
    96e6:	3301      	adds	r3, #1
    96e8:	f88d 300e 	strb.w	r3, [sp, #14]
    96ec:	9b01      	ldr	r3, [sp, #4]
    96ee:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
    96f2:	f89d 200e 	ldrb.w	r2, [sp, #14]
    96f6:	429a      	cmp	r2, r3
    96f8:	d3c5      	bcc.n	9686 <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0x5e>
        }
    }
    eReturnValue = (Std_ReturnType)FlexCAN_Ip_SetStopMode(Can_pControllerConfig->Can_u8ControllerOffset);
    96fa:	9b01      	ldr	r3, [sp, #4]
    96fc:	789b      	ldrb	r3, [r3, #2]
    96fe:	4618      	mov	r0, r3
    9700:	f002 fb7c 	bl	bdfc <FlexCAN_Ip_SetStopMode_Privileged>
    9704:	4603      	mov	r3, r0
    9706:	f88d 300f 	strb.w	r3, [sp, #15]
    970a:	e002      	b.n	9712 <Can_43_FLEXCAN_Ipw_SetControllerToStopMode+0xea>
    }
    else
    {
        eReturnValue = E_NOT_OK;
    970c:	2301      	movs	r3, #1
    970e:	f88d 300f 	strb.w	r3, [sp, #15]
    }

    return eReturnValue;
    9712:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    9716:	4618      	mov	r0, r3
    9718:	b005      	add	sp, #20
    971a:	f85d fb04 	ldr.w	pc, [sp], #4
    971e:	bf00      	nop
    9720:	1fff9044 	.word	0x1fff9044

00009724 <Can_43_FLEXCAN_Ipw_DisableControllerInterrupts>:
/**
*   @brief      Disable Can Controller Interrupts
*/
void Can_43_FLEXCAN_Ipw_DisableControllerInterrupts(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
    9724:	b500      	push	{lr}
    9726:	b083      	sub	sp, #12
    9728:	9001      	str	r0, [sp, #4]
    if (TRUE == Can_Ipw_abIsInterruptEnabled[Can_pControllerConfig->Can_u8ControllerID])
    972a:	9b01      	ldr	r3, [sp, #4]
    972c:	785b      	ldrb	r3, [r3, #1]
    972e:	461a      	mov	r2, r3
    9730:	4b10      	ldr	r3, [pc, #64]	; (9774 <Can_43_FLEXCAN_Ipw_DisableControllerInterrupts+0x50>)
    9732:	5c9b      	ldrb	r3, [r3, r2]
    9734:	2b00      	cmp	r3, #0
    9736:	d018      	beq.n	976a <Can_43_FLEXCAN_Ipw_DisableControllerInterrupts+0x46>
    {
        /* @violates @ref Can_43_FLEXCAN_Ipw_c_REF_3 MISRA 2012 Advisory Rule 12.3 */
        (void)FlexCAN_Ip_DisableInterrupts(Can_pControllerConfig->Can_u8ControllerOffset);
    9738:	9b01      	ldr	r3, [sp, #4]
    973a:	789b      	ldrb	r3, [r3, #2]
    973c:	4618      	mov	r0, r3
    973e:	f002 fe0d 	bl	c35c <FlexCAN_Ip_DisableInterrupts_Privileged>
        Can_Ipw_abIsInterruptEnabled[Can_pControllerConfig->Can_u8ControllerID] = FALSE;
    9742:	9b01      	ldr	r3, [sp, #4]
    9744:	785b      	ldrb	r3, [r3, #1]
    9746:	461a      	mov	r2, r3
    9748:	4b0a      	ldr	r3, [pc, #40]	; (9774 <Can_43_FLEXCAN_Ipw_DisableControllerInterrupts+0x50>)
    974a:	2100      	movs	r1, #0
    974c:	5499      	strb	r1, [r3, r2]
#if (CAN_43_FLEXCAN_ERROR_INTERRUPT_SUPPORT == STD_ON)
        (void)FlexCAN_Ip_SetErrorInt(Can_pControllerConfig->Can_u8ControllerOffset, FLEXCAN_IP_INT_ERR, FALSE);
#endif  /*  ERROR_INTERRUPT_SUPPORT */
#if (CAN_43_FLEXCAN_BUSOFF_INTERRUPT_SUPPORT == STD_ON)
        if (FALSE == Can_pControllerConfig->Can_bBusOffUsesPolling)
    974e:	9b01      	ldr	r3, [sp, #4]
    9750:	7a5b      	ldrb	r3, [r3, #9]
    9752:	f083 0301 	eor.w	r3, r3, #1
    9756:	b2db      	uxtb	r3, r3
    9758:	2b00      	cmp	r3, #0
    975a:	d006      	beq.n	976a <Can_43_FLEXCAN_Ipw_DisableControllerInterrupts+0x46>
        {
            (void)FlexCAN_Ip_SetErrorInt(Can_pControllerConfig->Can_u8ControllerOffset, FLEXCAN_IP_INT_BUSOFF, FALSE);
    975c:	9b01      	ldr	r3, [sp, #4]
    975e:	789b      	ldrb	r3, [r3, #2]
    9760:	2200      	movs	r2, #0
    9762:	2104      	movs	r1, #4
    9764:	4618      	mov	r0, r3
    9766:	f002 fe25 	bl	c3b4 <FlexCAN_Ip_SetErrorInt_Privileged>
        }
#endif /* BUSOFF_INTERRUPT_SUPPORT */
    }
}
    976a:	bf00      	nop
    976c:	b003      	add	sp, #12
    976e:	f85d fb04 	ldr.w	pc, [sp], #4
    9772:	bf00      	nop
    9774:	1fff9044 	.word	0x1fff9044

00009778 <Can_43_FLEXCAN_Ipw_EnableControllerInterrupts>:

/**
*   @brief      Enable Can Controller Interrupts
*/
void Can_43_FLEXCAN_Ipw_EnableControllerInterrupts(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig)
{
    9778:	b500      	push	{lr}
    977a:	b083      	sub	sp, #12
    977c:	9001      	str	r0, [sp, #4]
    /*
    * [SWS_Can_00208]  The function Can_EnableControllerInterrupts shall perform no
    * action when Can_DisableControllerInterrupts has not been called before.
    */
    if (FALSE == Can_Ipw_abIsInterruptEnabled[Can_pControllerConfig->Can_u8ControllerID])
    977e:	9b01      	ldr	r3, [sp, #4]
    9780:	785b      	ldrb	r3, [r3, #1]
    9782:	461a      	mov	r2, r3
    9784:	4b11      	ldr	r3, [pc, #68]	; (97cc <Can_43_FLEXCAN_Ipw_EnableControllerInterrupts+0x54>)
    9786:	5c9b      	ldrb	r3, [r3, r2]
    9788:	f083 0301 	eor.w	r3, r3, #1
    978c:	b2db      	uxtb	r3, r3
    978e:	2b00      	cmp	r3, #0
    9790:	d018      	beq.n	97c4 <Can_43_FLEXCAN_Ipw_EnableControllerInterrupts+0x4c>
    {
        /* @violates @ref Can_43_FLEXCAN_Ipw_c_REF_3 MISRA 2012 Advisory Rule 12.3 */
        (void)FlexCAN_Ip_EnableInterrupts(Can_pControllerConfig->Can_u8ControllerOffset);
    9792:	9b01      	ldr	r3, [sp, #4]
    9794:	789b      	ldrb	r3, [r3, #2]
    9796:	4618      	mov	r0, r3
    9798:	f002 fdb2 	bl	c300 <FlexCAN_Ip_EnableInterrupts_Privileged>
#if (CAN_43_FLEXCAN_ERROR_INTERRUPT_SUPPORT == STD_ON)
        (void)FlexCAN_Ip_SetErrorInt(Can_pControllerConfig->Can_u8ControllerOffset, FLEXCAN_IP_INT_ERR, TRUE);
#endif /* ERROR_INTERRUPT_SUPPORT */
#if (CAN_43_FLEXCAN_BUSOFF_INTERRUPT_SUPPORT == STD_ON)
        if (FALSE == Can_pControllerConfig->Can_bBusOffUsesPolling)
    979c:	9b01      	ldr	r3, [sp, #4]
    979e:	7a5b      	ldrb	r3, [r3, #9]
    97a0:	f083 0301 	eor.w	r3, r3, #1
    97a4:	b2db      	uxtb	r3, r3
    97a6:	2b00      	cmp	r3, #0
    97a8:	d006      	beq.n	97b8 <Can_43_FLEXCAN_Ipw_EnableControllerInterrupts+0x40>
        {
            (void)FlexCAN_Ip_SetErrorInt(Can_pControllerConfig->Can_u8ControllerOffset, FLEXCAN_IP_INT_BUSOFF, TRUE);
    97aa:	9b01      	ldr	r3, [sp, #4]
    97ac:	789b      	ldrb	r3, [r3, #2]
    97ae:	2201      	movs	r2, #1
    97b0:	2104      	movs	r1, #4
    97b2:	4618      	mov	r0, r3
    97b4:	f002 fdfe 	bl	c3b4 <FlexCAN_Ip_SetErrorInt_Privileged>
        }
#endif  /* BUSOFF_INTERRUPT_SUPPORT */
        /* update status */
        Can_Ipw_abIsInterruptEnabled[Can_pControllerConfig->Can_u8ControllerID] = TRUE;
    97b8:	9b01      	ldr	r3, [sp, #4]
    97ba:	785b      	ldrb	r3, [r3, #1]
    97bc:	461a      	mov	r2, r3
    97be:	4b03      	ldr	r3, [pc, #12]	; (97cc <Can_43_FLEXCAN_Ipw_EnableControllerInterrupts+0x54>)
    97c0:	2101      	movs	r1, #1
    97c2:	5499      	strb	r1, [r3, r2]
    }
}
    97c4:	bf00      	nop
    97c6:	b003      	add	sp, #12
    97c8:	f85d fb04 	ldr.w	pc, [sp], #4
    97cc:	1fff9044 	.word	0x1fff9044

000097d0 <Can_43_FLEXCAN_Ipw_GetControllerErrorState>:

/**
*   @brief      Get Controller Error State
*/
Std_ReturnType Can_43_FLEXCAN_Ipw_GetControllerErrorState(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig, uint8 * pValue)
{
    97d0:	b500      	push	{lr}
    97d2:	b085      	sub	sp, #20
    97d4:	9001      	str	r0, [sp, #4]
    97d6:	9100      	str	r1, [sp, #0]
    uint32 Error = 0U;
    97d8:	2300      	movs	r3, #0
    97da:	9303      	str	r3, [sp, #12]

    Error = FlexCAN_Ip_GetErrorStatus(Can_pControllerConfig->Can_u8ControllerOffset);
    97dc:	9b01      	ldr	r3, [sp, #4]
    97de:	789b      	ldrb	r3, [r3, #2]
    97e0:	4618      	mov	r0, r3
    97e2:	f001 fe81 	bl	b4e8 <FlexCAN_Ip_GetErrorStatus>
    97e6:	9003      	str	r0, [sp, #12]

    *pValue = (uint8)((Error & FLEXCAN_ESR1_FLTCONF_MASK)>>FLEXCAN_ESR1_FLTCONF_SHIFT);
    97e8:	9b03      	ldr	r3, [sp, #12]
    97ea:	091b      	lsrs	r3, r3, #4
    97ec:	b2db      	uxtb	r3, r3
    97ee:	f003 0303 	and.w	r3, r3, #3
    97f2:	b2da      	uxtb	r2, r3
    97f4:	9b00      	ldr	r3, [sp, #0]
    97f6:	701a      	strb	r2, [r3, #0]
    return E_OK;
    97f8:	2300      	movs	r3, #0
}
    97fa:	4618      	mov	r0, r3
    97fc:	b005      	add	sp, #20
    97fe:	f85d fb04 	ldr.w	pc, [sp], #4

00009802 <Can_43_FLEXCAN_Ipw_GetControllerTxErrorCounter>:

/**
*   @brief      Get Controller Tx Error Counter
*/
Std_ReturnType Can_43_FLEXCAN_Ipw_GetControllerTxErrorCounter(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig, uint8 * pValue)
{
    9802:	b500      	push	{lr}
    9804:	b083      	sub	sp, #12
    9806:	9001      	str	r0, [sp, #4]
    9808:	9100      	str	r1, [sp, #0]
     *pValue = FlexCAN_Ip_GetControllerTxErrorCounter(Can_pControllerConfig->Can_u8ControllerOffset);
    980a:	9b01      	ldr	r3, [sp, #4]
    980c:	789b      	ldrb	r3, [r3, #2]
    980e:	4618      	mov	r0, r3
    9810:	f001 fe7c 	bl	b50c <FlexCAN_Ip_GetControllerTxErrorCounter>
    9814:	4603      	mov	r3, r0
    9816:	461a      	mov	r2, r3
    9818:	9b00      	ldr	r3, [sp, #0]
    981a:	701a      	strb	r2, [r3, #0]
     return E_OK;
    981c:	2300      	movs	r3, #0
}
    981e:	4618      	mov	r0, r3
    9820:	b003      	add	sp, #12
    9822:	f85d fb04 	ldr.w	pc, [sp], #4

00009826 <Can_43_FLEXCAN_Ipw_GetControllerRxErrorCounter>:

/**
*   @brief      Get Controller Rx Error Counter
*/
Std_ReturnType Can_43_FLEXCAN_Ipw_GetControllerRxErrorCounter(const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig, uint8 * pValue)
{
    9826:	b500      	push	{lr}
    9828:	b083      	sub	sp, #12
    982a:	9001      	str	r0, [sp, #4]
    982c:	9100      	str	r1, [sp, #0]

    *pValue = FlexCAN_Ip_GetControllerRxErrorCounter(Can_pControllerConfig->Can_u8ControllerOffset);
    982e:	9b01      	ldr	r3, [sp, #4]
    9830:	789b      	ldrb	r3, [r3, #2]
    9832:	4618      	mov	r0, r3
    9834:	f001 fe7c 	bl	b530 <FlexCAN_Ip_GetControllerRxErrorCounter>
    9838:	4603      	mov	r3, r0
    983a:	461a      	mov	r2, r3
    983c:	9b00      	ldr	r3, [sp, #0]
    983e:	701a      	strb	r2, [r3, #0]
    return E_OK;
    9840:	2300      	movs	r3, #0
}
    9842:	4618      	mov	r0, r3
    9844:	b003      	add	sp, #12
    9846:	f85d fb04 	ldr.w	pc, [sp], #4

0000984a <Can_43_FLEXCAN_Ipw_Write>:
(
    const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig,
    const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObjectConfig,
    const Can_PduType * PduInfo
)
{
    984a:	b510      	push	{r4, lr}
    984c:	b08c      	sub	sp, #48	; 0x30
    984e:	9005      	str	r0, [sp, #20]
    9850:	9104      	str	r1, [sp, #16]
    9852:	9203      	str	r2, [sp, #12]
    Flexcan_Ip_StatusType eRetVal = FLEXCAN_STATUS_ERROR;
    9854:	2301      	movs	r3, #1
    9856:	930b      	str	r3, [sp, #44]	; 0x2c
    Flexcan_Ip_DataInfoType DataInfo;
    uint8 u8ObjIdx = 0U;
    9858:	2300      	movs	r3, #0
    985a:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
#if (CAN_43_FLEXCAN_TRIGGER_TRANSMIT_USED == STD_ON)
    PduInfoType CanIf_PduInfo;
    uint8 Data[64U];
#endif

    DataInfo.msg_id_type = FLEXCAN_MSG_ID_STD;
    985e:	2300      	movs	r3, #0
    9860:	9306      	str	r3, [sp, #24]
    DataInfo.data_length = 0U;
    9862:	2300      	movs	r3, #0
    9864:	9307      	str	r3, [sp, #28]
    DataInfo.fd_padding = 0U;
    9866:	2300      	movs	r3, #0
    9868:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
    DataInfo.fd_enable = FALSE;
    986c:	2300      	movs	r3, #0
    986e:	f88d 3020 	strb.w	r3, [sp, #32]
    DataInfo.enable_brs = FALSE;
    9872:	2300      	movs	r3, #0
    9874:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    DataInfo.is_remote = FALSE;
    9878:	2300      	movs	r3, #0
    987a:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    DataInfo.is_polling = FALSE;
    987e:	2300      	movs	r3, #0
    9880:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
    if (CAN_TX_NORMAL == Can_pHwObjectConfig->Can_eReceiveType)
    9884:	9b04      	ldr	r3, [sp, #16]
    9886:	699b      	ldr	r3, [r3, #24]
    9888:	2b03      	cmp	r3, #3
    988a:	d173      	bne.n	9974 <Can_43_FLEXCAN_Ipw_Write+0x12a>
    {
        DataInfo.msg_id_type = ((PduInfo->id & CAN_43_FLEXCAN_EXTENDED_ID_U32) != 0U) ? FLEXCAN_MSG_ID_EXT : FLEXCAN_MSG_ID_STD;
    988c:	9b03      	ldr	r3, [sp, #12]
    988e:	681b      	ldr	r3, [r3, #0]
    9890:	0fdb      	lsrs	r3, r3, #31
    9892:	9306      	str	r3, [sp, #24]
        if (Can_pHwObjectConfig->Can_u8PayloadLength <=  PduInfo->length)
    9894:	9b04      	ldr	r3, [sp, #16]
    9896:	7c1a      	ldrb	r2, [r3, #16]
    9898:	9b03      	ldr	r3, [sp, #12]
    989a:	799b      	ldrb	r3, [r3, #6]
    989c:	429a      	cmp	r2, r3
    989e:	d803      	bhi.n	98a8 <Can_43_FLEXCAN_Ipw_Write+0x5e>
        {
            DataInfo.data_length = Can_pHwObjectConfig->Can_u8PayloadLength;
    98a0:	9b04      	ldr	r3, [sp, #16]
    98a2:	7c1b      	ldrb	r3, [r3, #16]
    98a4:	9307      	str	r3, [sp, #28]
    98a6:	e002      	b.n	98ae <Can_43_FLEXCAN_Ipw_Write+0x64>
        }
        else
        {
            DataInfo.data_length = PduInfo->length;
    98a8:	9b03      	ldr	r3, [sp, #12]
    98aa:	799b      	ldrb	r3, [r3, #6]
    98ac:	9307      	str	r3, [sp, #28]
        }
#if (CAN_43_FLEXCAN_FEATURE_HAS_FD == STD_ON)
        DataInfo.fd_padding = Can_pHwObjectConfig->Can_u8PaddingValue;
    98ae:	9b04      	ldr	r3, [sp, #16]
    98b0:	7c5b      	ldrb	r3, [r3, #17]
    98b2:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
        DataInfo.fd_enable = ((PduInfo->id & CAN_43_FLEXCAN_FD_FRAME_U32) != 0U) ? TRUE : FALSE;
    98b6:	9b03      	ldr	r3, [sp, #12]
    98b8:	681b      	ldr	r3, [r3, #0]
    98ba:	0f9b      	lsrs	r3, r3, #30
    98bc:	f003 0301 	and.w	r3, r3, #1
    98c0:	2b00      	cmp	r3, #0
    98c2:	bf14      	ite	ne
    98c4:	2301      	movne	r3, #1
    98c6:	2300      	moveq	r3, #0
    98c8:	b2db      	uxtb	r3, r3
    98ca:	f88d 3020 	strb.w	r3, [sp, #32]
    #if (CAN_43_FLEXCAN_SET_BAUDRATE_API == STD_ON)
            DataInfo.enable_brs = Can_pControllerConfig->Can_pBaudrateConfig[Can_au16ControllerBaudRateSel[Can_pControllerConfig->Can_u8ControllerID]].Can_bBitRateSwitch;
    #else
        DataInfo.enable_brs = Can_pControllerConfig->Can_pBaudrateConfig[Can_pControllerConfig->Can_u16DefaultBaudrateID].Can_bBitRateSwitch;
    98ce:	9b05      	ldr	r3, [sp, #20]
    98d0:	6a1a      	ldr	r2, [r3, #32]
    98d2:	9b05      	ldr	r3, [sp, #20]
    98d4:	8b9b      	ldrh	r3, [r3, #28]
    98d6:	4619      	mov	r1, r3
    98d8:	2316      	movs	r3, #22
    98da:	fb01 f303 	mul.w	r3, r1, r3
    98de:	4413      	add	r3, r2
    98e0:	781b      	ldrb	r3, [r3, #0]
    98e2:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    #endif
#endif
        DataInfo.is_remote = FALSE;
    98e6:	2300      	movs	r3, #0
    98e8:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
        DataInfo.is_polling = Can_pHwObjectConfig->Can_bHwObjectUsesPolling;
    98ec:	9b04      	ldr	r3, [sp, #16]
    98ee:	7b1b      	ldrb	r3, [r3, #12]
    98f0:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
        do
        {
            eRetVal = FlexCAN_Ip_GetTransferStatus(Can_pControllerConfig->Can_u8ControllerOffset, Can_pHwObjectConfig->Can_u8HwBufferIndex + u8ObjIdx);
    98f4:	9b05      	ldr	r3, [sp, #20]
    98f6:	7898      	ldrb	r0, [r3, #2]
    98f8:	9b04      	ldr	r3, [sp, #16]
    98fa:	7f1a      	ldrb	r2, [r3, #28]
    98fc:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
    9900:	4413      	add	r3, r2
    9902:	b2db      	uxtb	r3, r3
    9904:	4619      	mov	r1, r3
    9906:	f001 fcdd 	bl	b2c4 <FlexCAN_Ip_GetTransferStatus>
    990a:	900b      	str	r0, [sp, #44]	; 0x2c
            if (FLEXCAN_STATUS_SUCCESS == eRetVal)
    990c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    990e:	2b00      	cmp	r3, #0
    9910:	d122      	bne.n	9958 <Can_43_FLEXCAN_Ipw_Write+0x10e>
            {
                #if ((CAN_43_FLEXCAN_TX_POLLING_SUPPORT == STD_ON) || (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON))
                Can_Ipw_au16TxPduId[Can_pControllerConfig->Can_u8ControllerID][Can_pHwObjectConfig->Can_u8HwBufferIndex+u8ObjIdx] = PduInfo->swPduHandle;
    9912:	9b05      	ldr	r3, [sp, #20]
    9914:	785b      	ldrb	r3, [r3, #1]
    9916:	461c      	mov	r4, r3
    9918:	9b04      	ldr	r3, [sp, #16]
    991a:	7f1b      	ldrb	r3, [r3, #28]
    991c:	461a      	mov	r2, r3
    991e:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
    9922:	4413      	add	r3, r2
    9924:	9a03      	ldr	r2, [sp, #12]
    9926:	8890      	ldrh	r0, [r2, #4]
    9928:	491b      	ldr	r1, [pc, #108]	; (9998 <Can_43_FLEXCAN_Ipw_Write+0x14e>)
    992a:	0162      	lsls	r2, r4, #5
    992c:	4413      	add	r3, r2
    992e:	4602      	mov	r2, r0
    9930:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
                    }
                }
                else
                {
            #endif
                    eRetVal = FlexCAN_Ip_Send(Can_pControllerConfig->Can_u8ControllerOffset, Can_pHwObjectConfig->Can_u8HwBufferIndex + u8ObjIdx, &DataInfo, PduInfo->id, PduInfo->sdu);
    9934:	9b05      	ldr	r3, [sp, #20]
    9936:	7898      	ldrb	r0, [r3, #2]
    9938:	9b04      	ldr	r3, [sp, #16]
    993a:	7f1a      	ldrb	r2, [r3, #28]
    993c:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
    9940:	4413      	add	r3, r2
    9942:	b2d9      	uxtb	r1, r3
    9944:	9b03      	ldr	r3, [sp, #12]
    9946:	681c      	ldr	r4, [r3, #0]
    9948:	9b03      	ldr	r3, [sp, #12]
    994a:	689b      	ldr	r3, [r3, #8]
    994c:	aa06      	add	r2, sp, #24
    994e:	9300      	str	r3, [sp, #0]
    9950:	4623      	mov	r3, r4
    9952:	f001 fa4b 	bl	adec <FlexCAN_Ip_Send>
    9956:	900b      	str	r0, [sp, #44]	; 0x2c
                /* Revert to FALSE due to the MB was not transmitted successfully */
                Can_Ipw_abIsTxPduReady[Can_pControllerConfig->Can_u8ControllerID][Can_pHwObjectConfig->Can_u8HwBufferIndex+u8ObjIdx] = FALSE;
            }
            #endif /* ((CAN_43_FLEXCAN_TIMESTAMP_ENABLE == STD_ON) && ((CAN_43_FLEXCAN_TX_POLLING_SUPPORT == STD_ON) || (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON))) */
            }
            u8ObjIdx++;
    9958:	f89d 302b 	ldrb.w	r3, [sp, #43]	; 0x2b
    995c:	3301      	adds	r3, #1
    995e:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
        } while ((u8ObjIdx < Can_pHwObjectConfig->Can_u8ObjectCount) && (FLEXCAN_STATUS_BUSY == eRetVal));
    9962:	9b04      	ldr	r3, [sp, #16]
    9964:	7b9b      	ldrb	r3, [r3, #14]
    9966:	f89d 202b 	ldrb.w	r2, [sp, #43]	; 0x2b
    996a:	429a      	cmp	r2, r3
    996c:	d202      	bcs.n	9974 <Can_43_FLEXCAN_Ipw_Write+0x12a>
    996e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    9970:	2b02      	cmp	r3, #2
    9972:	d0bf      	beq.n	98f4 <Can_43_FLEXCAN_Ipw_Write+0xaa>
    }

    if ((FLEXCAN_STATUS_SUCCESS != eRetVal) && (FLEXCAN_STATUS_BUSY != eRetVal))
    9974:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    9976:	2b00      	cmp	r3, #0
    9978:	d004      	beq.n	9984 <Can_43_FLEXCAN_Ipw_Write+0x13a>
    997a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    997c:	2b02      	cmp	r3, #2
    997e:	d001      	beq.n	9984 <Can_43_FLEXCAN_Ipw_Write+0x13a>
    {
        eRetVal = FLEXCAN_STATUS_ERROR;
    9980:	2301      	movs	r3, #1
    9982:	930b      	str	r3, [sp, #44]	; 0x2c
    }

    return ((FLEXCAN_STATUS_BUSY == eRetVal) ? ((Std_ReturnType)CAN_BUSY) : ((Std_ReturnType)eRetVal));
    9984:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    9986:	2b02      	cmp	r3, #2
    9988:	d002      	beq.n	9990 <Can_43_FLEXCAN_Ipw_Write+0x146>
    998a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    998c:	b2db      	uxtb	r3, r3
    998e:	e000      	b.n	9992 <Can_43_FLEXCAN_Ipw_Write+0x148>
    9990:	2302      	movs	r3, #2
}
    9992:	4618      	mov	r0, r3
    9994:	b00c      	add	sp, #48	; 0x30
    9996:	bd10      	pop	{r4, pc}
    9998:	1fff8fc4 	.word	0x1fff8fc4

0000999c <Can_Ipw_InitRx>:

static void Can_Ipw_InitRx(const Can_43_FLEXCAN_ControllerConfigType * Can_pController)
{
    999c:	b500      	push	{lr}
    999e:	b089      	sub	sp, #36	; 0x24
    99a0:	9001      	str	r0, [sp, #4]
    uint8 u8HwObjRefIdx = 0U;
    99a2:	2300      	movs	r3, #0
    99a4:	f88d 301f 	strb.w	r3, [sp, #31]
    const Can_43_FLEXCAN_HwObjectConfigType * Can_pHwObject;
    Flexcan_Ip_DataInfoType DataInfo;

    /* This function just is called only if controller is in freeze mode */
    /* Always enable individual mask , Already in freeze mode */
    (void)FlexCAN_Ip_SetRxMaskType(Can_pController->Can_u8ControllerOffset, FLEXCAN_RX_MASK_INDIVIDUAL);
    99a8:	9b01      	ldr	r3, [sp, #4]
    99aa:	789b      	ldrb	r3, [r3, #2]
    99ac:	2101      	movs	r1, #1
    99ae:	4618      	mov	r0, r3
    99b0:	f002 fa42 	bl	be38 <FlexCAN_Ip_SetRxMaskType_Privileged>

    for (u8HwObjRefIdx = 0U; u8HwObjRefIdx < Can_pController->Can_u8HwObjectRefCount; u8HwObjRefIdx++)
    99b4:	2300      	movs	r3, #0
    99b6:	f88d 301f 	strb.w	r3, [sp, #31]
    99ba:	e03a      	b.n	9a32 <Can_Ipw_InitRx+0x96>
    {
        Can_pHwObject = (const Can_43_FLEXCAN_HwObjectConfigType *)Can_pController->Can_ppHwObject[u8HwObjRefIdx];
    99bc:	9b01      	ldr	r3, [sp, #4]
    99be:	6ada      	ldr	r2, [r3, #44]	; 0x2c
    99c0:	f89d 301f 	ldrb.w	r3, [sp, #31]
    99c4:	009b      	lsls	r3, r3, #2
    99c6:	4413      	add	r3, r2
    99c8:	681b      	ldr	r3, [r3, #0]
    99ca:	9306      	str	r3, [sp, #24]

        if (CAN_RX_NORMAL == Can_pHwObject->Can_eReceiveType)
    99cc:	9b06      	ldr	r3, [sp, #24]
    99ce:	699b      	ldr	r3, [r3, #24]
    99d0:	2b00      	cmp	r3, #0
    99d2:	d121      	bne.n	9a18 <Can_Ipw_InitRx+0x7c>
        {
            DataInfo.fd_enable = FALSE;
    99d4:	2300      	movs	r3, #0
    99d6:	f88d 3010 	strb.w	r3, [sp, #16]
            DataInfo.data_length = 0U;
    99da:	2300      	movs	r3, #0
    99dc:	9303      	str	r3, [sp, #12]
            if (Can_pHwObject->Can_IdMessage != CAN_STANDARD)
    99de:	9b06      	ldr	r3, [sp, #24]
    99e0:	689b      	ldr	r3, [r3, #8]
    99e2:	2b00      	cmp	r3, #0
    99e4:	d002      	beq.n	99ec <Can_Ipw_InitRx+0x50>
            {
                DataInfo.msg_id_type = FLEXCAN_MSG_ID_EXT;
    99e6:	2301      	movs	r3, #1
    99e8:	9302      	str	r3, [sp, #8]
    99ea:	e001      	b.n	99f0 <Can_Ipw_InitRx+0x54>
            }
            else
            {
                DataInfo.msg_id_type = FLEXCAN_MSG_ID_STD;
    99ec:	2300      	movs	r3, #0
    99ee:	9302      	str	r3, [sp, #8]
            }
            (void)FlexCAN_Ip_ConfigRxMb(Can_pController->Can_u8ControllerOffset, Can_pHwObject->Can_u8HwBufferIndex, &DataInfo, Can_pHwObject->Can_pHwFilterConfig->Can_u32HwFilterCode);
    99f0:	9b01      	ldr	r3, [sp, #4]
    99f2:	7898      	ldrb	r0, [r3, #2]
    99f4:	9b06      	ldr	r3, [sp, #24]
    99f6:	7f19      	ldrb	r1, [r3, #28]
    99f8:	9b06      	ldr	r3, [sp, #24]
    99fa:	695b      	ldr	r3, [r3, #20]
    99fc:	681b      	ldr	r3, [r3, #0]
    99fe:	aa02      	add	r2, sp, #8
    9a00:	f001 fa40 	bl	ae84 <FlexCAN_Ip_ConfigRxMb>
            /* Already in freeze mode */
            (void)FlexCAN_Ip_SetRxIndividualMask(Can_pController->Can_u8ControllerOffset, Can_pHwObject->Can_u8HwBufferIndex, Can_pHwObject->Can_pHwFilterConfig->Can_u32HwFilterMask);
    9a04:	9b01      	ldr	r3, [sp, #4]
    9a06:	7898      	ldrb	r0, [r3, #2]
    9a08:	9b06      	ldr	r3, [sp, #24]
    9a0a:	7f19      	ldrb	r1, [r3, #28]
    9a0c:	9b06      	ldr	r3, [sp, #24]
    9a0e:	695b      	ldr	r3, [r3, #20]
    9a10:	685b      	ldr	r3, [r3, #4]
    9a12:	461a      	mov	r2, r3
    9a14:	f001 ffc8 	bl	b9a8 <FlexCAN_Ip_SetRxIndividualMask_Privileged>
        }

        if (CAN_RX_LEGACY_FIFO == Can_pHwObject->Can_eReceiveType)
    9a18:	9b06      	ldr	r3, [sp, #24]
    9a1a:	699b      	ldr	r3, [r3, #24]
    9a1c:	2b01      	cmp	r3, #1
    9a1e:	d103      	bne.n	9a28 <Can_Ipw_InitRx+0x8c>
        {
            Can_Ipw_InitLegacyFifoFilter(Can_pController, Can_pHwObject);
    9a20:	9906      	ldr	r1, [sp, #24]
    9a22:	9801      	ldr	r0, [sp, #4]
    9a24:	f7ff f913 	bl	8c4e <Can_Ipw_InitLegacyFifoFilter>
    for (u8HwObjRefIdx = 0U; u8HwObjRefIdx < Can_pController->Can_u8HwObjectRefCount; u8HwObjRefIdx++)
    9a28:	f89d 301f 	ldrb.w	r3, [sp, #31]
    9a2c:	3301      	adds	r3, #1
    9a2e:	f88d 301f 	strb.w	r3, [sp, #31]
    9a32:	9b01      	ldr	r3, [sp, #4]
    9a34:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
    9a38:	f89d 201f 	ldrb.w	r2, [sp, #31]
    9a3c:	429a      	cmp	r2, r3
    9a3e:	d3bd      	bcc.n	99bc <Can_Ipw_InitRx+0x20>
        }
    }
}
    9a40:	bf00      	nop
    9a42:	bf00      	nop
    9a44:	b009      	add	sp, #36	; 0x24
    9a46:	f85d fb04 	ldr.w	pc, [sp], #4

00009a4a <Can_43_FLEXCAN_Ipw_MainFunction_Mode>:
void Can_43_FLEXCAN_Ipw_MainFunction_Mode
(
    const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig,
    Can_ControllerStateType * Can_pControllerState
)
{
    9a4a:	b500      	push	{lr}
    9a4c:	b083      	sub	sp, #12
    9a4e:	9001      	str	r0, [sp, #4]
    9a50:	9100      	str	r1, [sp, #0]
    /* @violates @ref Can_43_FLEXCAN_Ipw_c_REF_3 MISRA 2012 Advisory Rule 12.3 */
    if (CAN_CS_STARTED == *Can_pControllerState)
    9a52:	9b00      	ldr	r3, [sp, #0]
    9a54:	681b      	ldr	r3, [r3, #0]
    9a56:	2b01      	cmp	r3, #1
    9a58:	d114      	bne.n	9a84 <Can_43_FLEXCAN_Ipw_MainFunction_Mode+0x3a>
    {
        if (FALSE == FlexCAN_Ip_GetStartMode(Can_pControllerConfig->Can_u8ControllerOffset))
    9a5a:	9b01      	ldr	r3, [sp, #4]
    9a5c:	789b      	ldrb	r3, [r3, #2]
    9a5e:	4618      	mov	r0, r3
    9a60:	f002 f994 	bl	bd8c <FlexCAN_Ip_GetStartMode_Privileged>
    9a64:	4603      	mov	r3, r0
    9a66:	f083 0301 	eor.w	r3, r3, #1
    9a6a:	b2db      	uxtb	r3, r3
    9a6c:	2b00      	cmp	r3, #0
    9a6e:	d01e      	beq.n	9aae <Can_43_FLEXCAN_Ipw_MainFunction_Mode+0x64>
        {
            *Can_pControllerState = CAN_CS_STOPPED;
    9a70:	9b00      	ldr	r3, [sp, #0]
    9a72:	2202      	movs	r2, #2
    9a74:	601a      	str	r2, [r3, #0]
            CanIf_ControllerModeIndication(Can_pControllerConfig->Can_u8AbstControllerID, CAN_CS_STOPPED);
    9a76:	9b01      	ldr	r3, [sp, #4]
    9a78:	781b      	ldrb	r3, [r3, #0]
    9a7a:	2102      	movs	r1, #2
    9a7c:	4618      	mov	r0, r3
    9a7e:	f00a fe4b 	bl	14718 <CanIf_ControllerModeIndication>
    }
    else
    {
        /* nothing to do */
    }
}
    9a82:	e014      	b.n	9aae <Can_43_FLEXCAN_Ipw_MainFunction_Mode+0x64>
    else if (CAN_CS_STOPPED == *Can_pControllerState)
    9a84:	9b00      	ldr	r3, [sp, #0]
    9a86:	681b      	ldr	r3, [r3, #0]
    9a88:	2b02      	cmp	r3, #2
    9a8a:	d110      	bne.n	9aae <Can_43_FLEXCAN_Ipw_MainFunction_Mode+0x64>
        if (TRUE == FlexCAN_Ip_GetStartMode(Can_pControllerConfig->Can_u8ControllerOffset))
    9a8c:	9b01      	ldr	r3, [sp, #4]
    9a8e:	789b      	ldrb	r3, [r3, #2]
    9a90:	4618      	mov	r0, r3
    9a92:	f002 f97b 	bl	bd8c <FlexCAN_Ip_GetStartMode_Privileged>
    9a96:	4603      	mov	r3, r0
    9a98:	2b00      	cmp	r3, #0
    9a9a:	d008      	beq.n	9aae <Can_43_FLEXCAN_Ipw_MainFunction_Mode+0x64>
            *Can_pControllerState = CAN_CS_STARTED;
    9a9c:	9b00      	ldr	r3, [sp, #0]
    9a9e:	2201      	movs	r2, #1
    9aa0:	601a      	str	r2, [r3, #0]
            CanIf_ControllerModeIndication(Can_pControllerConfig->Can_u8AbstControllerID, CAN_CS_STARTED);
    9aa2:	9b01      	ldr	r3, [sp, #4]
    9aa4:	781b      	ldrb	r3, [r3, #0]
    9aa6:	2101      	movs	r1, #1
    9aa8:	4618      	mov	r0, r3
    9aaa:	f00a fe35 	bl	14718 <CanIf_ControllerModeIndication>
}
    9aae:	bf00      	nop
    9ab0:	b003      	add	sp, #12
    9ab2:	f85d fb04 	ldr.w	pc, [sp], #4

00009ab6 <Can_43_FLEXCAN_Ipw_ProcessHwObject>:
        const Can_43_FLEXCAN_ControllerConfigType * Can_pControllerConfig,
        const Can_43_FLEXCAN_ConfigType * Can_pConfig,
        uint8 u8MbIdx,
        Can_43_FLEXCAN_MbType mbType
    )
    {
    9ab6:	b500      	push	{lr}
    9ab8:	b085      	sub	sp, #20
    9aba:	9003      	str	r0, [sp, #12]
    9abc:	9102      	str	r1, [sp, #8]
    9abe:	9300      	str	r3, [sp, #0]
    9ac0:	4613      	mov	r3, r2
    9ac2:	f88d 3007 	strb.w	r3, [sp, #7]
        switch (mbType)
    9ac6:	9b00      	ldr	r3, [sp, #0]
    9ac8:	2b03      	cmp	r3, #3
    9aca:	d009      	beq.n	9ae0 <Can_43_FLEXCAN_Ipw_ProcessHwObject+0x2a>
    9acc:	9b00      	ldr	r3, [sp, #0]
    9ace:	2b03      	cmp	r3, #3
    9ad0:	d821      	bhi.n	9b16 <Can_43_FLEXCAN_Ipw_ProcessHwObject+0x60>
    9ad2:	9b00      	ldr	r3, [sp, #0]
    9ad4:	2b00      	cmp	r3, #0
    9ad6:	d00c      	beq.n	9af2 <Can_43_FLEXCAN_Ipw_ProcessHwObject+0x3c>
    9ad8:	9b00      	ldr	r3, [sp, #0]
    9ada:	2b01      	cmp	r3, #1
    9adc:	d012      	beq.n	9b04 <Can_43_FLEXCAN_Ipw_ProcessHwObject+0x4e>
                break;
            }
            default:
            {
                /* prevent misra */
                break;
    9ade:	e01a      	b.n	9b16 <Can_43_FLEXCAN_Ipw_ProcessHwObject+0x60>
                Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer(Can_pControllerConfig, Can_pConfig->Can_pHwObjectConfig, u8MbIdx);
    9ae0:	9b02      	ldr	r3, [sp, #8]
    9ae2:	691b      	ldr	r3, [r3, #16]
    9ae4:	f89d 2007 	ldrb.w	r2, [sp, #7]
    9ae8:	4619      	mov	r1, r3
    9aea:	9803      	ldr	r0, [sp, #12]
    9aec:	f7ff fb0c 	bl	9108 <Can_43_FLEXCAN_Ipw_ProcessTxMesgBuffer>
                break;
    9af0:	e012      	b.n	9b18 <Can_43_FLEXCAN_Ipw_ProcessHwObject+0x62>
                Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer(Can_pControllerConfig, Can_pConfig->Can_pHwObjectConfig, u8MbIdx);
    9af2:	9b02      	ldr	r3, [sp, #8]
    9af4:	691b      	ldr	r3, [r3, #16]
    9af6:	f89d 2007 	ldrb.w	r2, [sp, #7]
    9afa:	4619      	mov	r1, r3
    9afc:	9803      	ldr	r0, [sp, #12]
    9afe:	f7ff fb4f 	bl	91a0 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer>
                break;
    9b02:	e009      	b.n	9b18 <Can_43_FLEXCAN_Ipw_ProcessHwObject+0x62>
                    Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer(Can_pControllerConfig, Can_pConfig->Can_pHwObjectConfig, u8MbIdx);
    9b04:	9b02      	ldr	r3, [sp, #8]
    9b06:	691b      	ldr	r3, [r3, #16]
    9b08:	f89d 2007 	ldrb.w	r2, [sp, #7]
    9b0c:	4619      	mov	r1, r3
    9b0e:	9803      	ldr	r0, [sp, #12]
    9b10:	f7ff fb46 	bl	91a0 <Can_43_FLEXCAN_Ipw_ProcessRxMesgBuffer>
                break;
    9b14:	e000      	b.n	9b18 <Can_43_FLEXCAN_Ipw_ProcessHwObject+0x62>
                break;
    9b16:	bf00      	nop
            }
        }
    }
    9b18:	bf00      	nop
    9b1a:	b005      	add	sp, #20
    9b1c:	f85d fb04 	ldr.w	pc, [sp], #4

00009b20 <Can_43_FLEXCAN_CommonIrqCallback>:
void Can_43_FLEXCAN_CommonIrqCallback(uint8 u8Instance,
                           Flexcan_Ip_EventType event,
                           uint32 u32buffIdx,
                           const Flexcan_Ip_StateType *driverState
                          )
{
    9b20:	b500      	push	{lr}
    9b22:	b085      	sub	sp, #20
    9b24:	9102      	str	r1, [sp, #8]
    9b26:	9201      	str	r2, [sp, #4]
    9b28:	9300      	str	r3, [sp, #0]
    9b2a:	4603      	mov	r3, r0
    9b2c:	f88d 300f 	strb.w	r3, [sp, #15]
    else
    {
#endif /* CAN_43_FLEXCAN_FEATURE_HAS_ENHANCED_RX_FIFO */
    #if (CAN_43_FLEXCAN_MB_INTERRUPT_SUPPORT == STD_ON)
        /* This callback is just used for interrupt buffter */
        if (FALSE == (driverState->mbs[u32buffIdx].isPolling))
    9b30:	9a00      	ldr	r2, [sp, #0]
    9b32:	9b01      	ldr	r3, [sp, #4]
    9b34:	011b      	lsls	r3, r3, #4
    9b36:	4413      	add	r3, r2
    9b38:	3308      	adds	r3, #8
    9b3a:	781b      	ldrb	r3, [r3, #0]
    9b3c:	f083 0301 	eor.w	r3, r3, #1
    9b40:	b2db      	uxtb	r3, r3
    9b42:	2b00      	cmp	r3, #0
    9b44:	d03b      	beq.n	9bbe <Can_43_FLEXCAN_CommonIrqCallback+0x9e>
    9b46:	9b02      	ldr	r3, [sp, #8]
    9b48:	2b04      	cmp	r3, #4
    9b4a:	d83a      	bhi.n	9bc2 <Can_43_FLEXCAN_CommonIrqCallback+0xa2>
    9b4c:	a201      	add	r2, pc, #4	; (adr r2, 9b54 <Can_43_FLEXCAN_CommonIrqCallback+0x34>)
    9b4e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    9b52:	bf00      	nop
    9b54:	00009b7b 	.word	0x00009b7b
    9b58:	00009b8d 	.word	0x00009b8d
    9b5c:	00009b9f 	.word	0x00009b9f
    9b60:	00009baf 	.word	0x00009baf
    9b64:	00009b69 	.word	0x00009b69
        {
            switch (event)
            {
                case FLEXCAN_EVENT_TX_COMPLETE:
                {
                    Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt(u8Instance, (uint8)u32buffIdx, CAN_TX_NORMAL);
    9b68:	9b01      	ldr	r3, [sp, #4]
    9b6a:	b2d9      	uxtb	r1, r3
    9b6c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    9b70:	2203      	movs	r2, #3
    9b72:	4618      	mov	r0, r3
    9b74:	f7fe ff86 	bl	8a84 <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt>
                    break;
    9b78:	e024      	b.n	9bc4 <Can_43_FLEXCAN_CommonIrqCallback+0xa4>
                }
                case FLEXCAN_EVENT_RX_COMPLETE:
                {
                    Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt(u8Instance, (uint8)u32buffIdx, CAN_RX_NORMAL);
    9b7a:	9b01      	ldr	r3, [sp, #4]
    9b7c:	b2d9      	uxtb	r1, r3
    9b7e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    9b82:	2200      	movs	r2, #0
    9b84:	4618      	mov	r0, r3
    9b86:	f7fe ff7d 	bl	8a84 <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt>
                    break;
    9b8a:	e01b      	b.n	9bc4 <Can_43_FLEXCAN_CommonIrqCallback+0xa4>
                }
                case FLEXCAN_EVENT_RXFIFO_COMPLETE:
                {
                    Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt(u8Instance, (uint8)u32buffIdx, CAN_RX_LEGACY_FIFO);
    9b8c:	9b01      	ldr	r3, [sp, #4]
    9b8e:	b2d9      	uxtb	r1, r3
    9b90:	f89d 300f 	ldrb.w	r3, [sp, #15]
    9b94:	2201      	movs	r2, #1
    9b96:	4618      	mov	r0, r3
    9b98:	f7fe ff74 	bl	8a84 <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt>
                    break;
    9b9c:	e012      	b.n	9bc4 <Can_43_FLEXCAN_CommonIrqCallback+0xa4>
                }
                case FLEXCAN_EVENT_RXFIFO_WARNING:
                {
                    Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt(u8Instance, 6U, CAN_RX_LEGACY_FIFO);
    9b9e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    9ba2:	2201      	movs	r2, #1
    9ba4:	2106      	movs	r1, #6
    9ba6:	4618      	mov	r0, r3
    9ba8:	f7fe ff6c 	bl	8a84 <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt>
                    break;
    9bac:	e00a      	b.n	9bc4 <Can_43_FLEXCAN_CommonIrqCallback+0xa4>
                }
                case FLEXCAN_EVENT_RXFIFO_OVERFLOW:
                {
                    Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt(u8Instance, 7U, CAN_RX_LEGACY_FIFO);
    9bae:	f89d 300f 	ldrb.w	r3, [sp, #15]
    9bb2:	2201      	movs	r2, #1
    9bb4:	2107      	movs	r1, #7
    9bb6:	4618      	mov	r0, r3
    9bb8:	f7fe ff64 	bl	8a84 <Can_43_FLEXCAN_ProcessMesgBufferCommonInterrupt>
                    break;
    9bbc:	e002      	b.n	9bc4 <Can_43_FLEXCAN_CommonIrqCallback+0xa4>
                {
                    /* nothing to do */
                    break;
                }
            }
        }
    9bbe:	bf00      	nop
    9bc0:	e000      	b.n	9bc4 <Can_43_FLEXCAN_CommonIrqCallback+0xa4>
                    break;
    9bc2:	bf00      	nop
        Can_43_FLEXCAN_ProcessPNInterrupt(u8Instance);
    }
#endif /* (CAN_43_FLEXCAN_FEATURE_HAS_PRETENDED_NETWORKING == STD_ON) */
    (void)u32buffIdx;
    (void)driverState;
}
    9bc4:	bf00      	nop
    9bc6:	b005      	add	sp, #20
    9bc8:	f85d fb04 	ldr.w	pc, [sp], #4

00009bcc <Can_43_FLEXCAN_ErrorIrqCallback>:
void Can_43_FLEXCAN_ErrorIrqCallback(uint8 u8Instance,
                          Flexcan_Ip_EventType event,
                          uint32 u32ErrStatus,
                          const Flexcan_Ip_StateType *driverState
                         )
{
    9bcc:	b500      	push	{lr}
    9bce:	b085      	sub	sp, #20
    9bd0:	9102      	str	r1, [sp, #8]
    9bd2:	9201      	str	r2, [sp, #4]
    9bd4:	9300      	str	r3, [sp, #0]
    9bd6:	4603      	mov	r3, r0
    9bd8:	f88d 300f 	strb.w	r3, [sp, #15]
    (void) driverState; /* not used yet */
#if (CAN_43_FLEXCAN_ERROR_INTERRUPT_SUPPORT != STD_ON)
    (void) u32ErrStatus; /* prevent compiler warning */
#endif /* (CAN_43_FLEXCAN_ERROR_INTERRUPT_SUPPORT != STD_ON) */

    switch (event)
    9bdc:	9b02      	ldr	r3, [sp, #8]
    9bde:	2b07      	cmp	r3, #7
    9be0:	d105      	bne.n	9bee <Can_43_FLEXCAN_ErrorIrqCallback+0x22>
        }
#endif /* (CAN_43_FLEXCAN_ERROR_INTERRUPT_SUPPORT == STD_ON) */
        /* this function is called for both interrupt & polling */
        case FLEXCAN_EVENT_BUSOFF:
        {
            Can_43_FLEXCAN_ProcessBusOffInterrupt(u8Instance);
    9be2:	f89d 300f 	ldrb.w	r3, [sp, #15]
    9be6:	4618      	mov	r0, r3
    9be8:	f7fe ff8e 	bl	8b08 <Can_43_FLEXCAN_ProcessBusOffInterrupt>
            break;
    9bec:	e000      	b.n	9bf0 <Can_43_FLEXCAN_ErrorIrqCallback+0x24>
        }
        default:
        {
            /* nothing to do */
            break;
    9bee:	bf00      	nop
        }
    }
}
    9bf0:	bf00      	nop
    9bf2:	b005      	add	sp, #20
    9bf4:	f85d fb04 	ldr.w	pc, [sp], #4

00009bf8 <FlexCAN_SetRxFifoGlobalMask>:
 *
 * @param[in]   base  The FlexCAN base address
 * @param[in]   Mask     Sets mask
 */
static inline void FlexCAN_SetRxFifoGlobalMask(FLEXCAN_Type * base, uint32 Mask)
{
    9bf8:	b082      	sub	sp, #8
    9bfa:	9001      	str	r0, [sp, #4]
    9bfc:	9100      	str	r1, [sp, #0]
    (base->RXFGMASK) = Mask;
    9bfe:	9b01      	ldr	r3, [sp, #4]
    9c00:	9a00      	ldr	r2, [sp, #0]
    9c02:	649a      	str	r2, [r3, #72]	; 0x48
}
    9c04:	bf00      	nop
    9c06:	b002      	add	sp, #8
    9c08:	4770      	bx	lr

00009c0a <FlexCAN_SetTDCOffset>:
 */
static inline void FlexCAN_SetTDCOffset(FLEXCAN_Type * base,
                                        boolean enable,
                                        uint8 offset
                                       )
{
    9c0a:	b084      	sub	sp, #16
    9c0c:	9001      	str	r0, [sp, #4]
    9c0e:	460b      	mov	r3, r1
    9c10:	f88d 3003 	strb.w	r3, [sp, #3]
    9c14:	4613      	mov	r3, r2
    9c16:	f88d 3002 	strb.w	r3, [sp, #2]
    uint32 tmp;

    tmp = base->FDCTRL;
    9c1a:	9b01      	ldr	r3, [sp, #4]
    9c1c:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    9c20:	9303      	str	r3, [sp, #12]
    tmp &= ~(FLEXCAN_FDCTRL_TDCEN_MASK | FLEXCAN_FDCTRL_TDCOFF_MASK);
    9c22:	9b03      	ldr	r3, [sp, #12]
    9c24:	f423 431f 	bic.w	r3, r3, #40704	; 0x9f00
    9c28:	9303      	str	r3, [sp, #12]

    if (enable)
    9c2a:	f89d 3003 	ldrb.w	r3, [sp, #3]
    9c2e:	2b00      	cmp	r3, #0
    9c30:	d00b      	beq.n	9c4a <FlexCAN_SetTDCOffset+0x40>
    {
        tmp = tmp | FLEXCAN_FDCTRL_TDCEN_MASK;
    9c32:	9b03      	ldr	r3, [sp, #12]
    9c34:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    9c38:	9303      	str	r3, [sp, #12]
        tmp = tmp | FLEXCAN_FDCTRL_TDCOFF(offset);
    9c3a:	f89d 3002 	ldrb.w	r3, [sp, #2]
    9c3e:	021b      	lsls	r3, r3, #8
    9c40:	f403 53f8 	and.w	r3, r3, #7936	; 0x1f00
    9c44:	9a03      	ldr	r2, [sp, #12]
    9c46:	4313      	orrs	r3, r2
    9c48:	9303      	str	r3, [sp, #12]
    }

    base->FDCTRL = tmp;
    9c4a:	9b01      	ldr	r3, [sp, #4]
    9c4c:	9a03      	ldr	r2, [sp, #12]
    9c4e:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
}
    9c52:	bf00      	nop
    9c54:	b004      	add	sp, #16
    9c56:	4770      	bx	lr

00009c58 <FlexCAN_IsEnabled>:
 *
 * @param   base    The FlexCAN base address
 * @return  TRUE if enabled; FALSE if disabled
 */
static inline boolean FlexCAN_IsEnabled(const FLEXCAN_Type * pBase)
{
    9c58:	b082      	sub	sp, #8
    9c5a:	9001      	str	r0, [sp, #4]
    return (((pBase->MCR & FLEXCAN_MCR_MDIS_MASK) >> FLEXCAN_MCR_MDIS_SHIFT) != 0U) ? FALSE : TRUE;
    9c5c:	9b01      	ldr	r3, [sp, #4]
    9c5e:	681b      	ldr	r3, [r3, #0]
    9c60:	43db      	mvns	r3, r3
    9c62:	0fdb      	lsrs	r3, r3, #31
    9c64:	b2db      	uxtb	r3, r3
}
    9c66:	4618      	mov	r0, r3
    9c68:	b002      	add	sp, #8
    9c6a:	4770      	bx	lr

00009c6c <FlexCAN_SetFDEnabled>:
 */
static inline void FlexCAN_SetFDEnabled(FLEXCAN_Type * base,
                                        boolean enableFD,
                                        boolean enableBRS
                                       )
{
    9c6c:	b082      	sub	sp, #8
    9c6e:	9001      	str	r0, [sp, #4]
    9c70:	460b      	mov	r3, r1
    9c72:	f88d 3003 	strb.w	r3, [sp, #3]
    9c76:	4613      	mov	r3, r2
    9c78:	f88d 3002 	strb.w	r3, [sp, #2]
    base->MCR = (base->MCR & ~FLEXCAN_MCR_FDEN_MASK) | FLEXCAN_MCR_FDEN(enableFD ? 1UL : 0UL);
    9c7c:	9b01      	ldr	r3, [sp, #4]
    9c7e:	681b      	ldr	r3, [r3, #0]
    9c80:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    9c84:	f89d 2003 	ldrb.w	r2, [sp, #3]
    9c88:	2a00      	cmp	r2, #0
    9c8a:	d002      	beq.n	9c92 <FlexCAN_SetFDEnabled+0x26>
    9c8c:	f44f 6200 	mov.w	r2, #2048	; 0x800
    9c90:	e000      	b.n	9c94 <FlexCAN_SetFDEnabled+0x28>
    9c92:	2200      	movs	r2, #0
    9c94:	431a      	orrs	r2, r3
    9c96:	9b01      	ldr	r3, [sp, #4]
    9c98:	601a      	str	r2, [r3, #0]

    /* Enable BitRate Switch support from BRS_TX_MB field or ignore it */
    base->FDCTRL = (base->FDCTRL & ~FLEXCAN_FDCTRL_FDRATE_MASK) | FLEXCAN_FDCTRL_FDRATE(enableBRS ? 1UL : 0UL);
    9c9a:	9b01      	ldr	r3, [sp, #4]
    9c9c:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    9ca0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    9ca4:	f89d 2002 	ldrb.w	r2, [sp, #2]
    9ca8:	2a00      	cmp	r2, #0
    9caa:	d002      	beq.n	9cb2 <FlexCAN_SetFDEnabled+0x46>
    9cac:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    9cb0:	e000      	b.n	9cb4 <FlexCAN_SetFDEnabled+0x48>
    9cb2:	2200      	movs	r2, #0
    9cb4:	431a      	orrs	r2, r3
    9cb6:	9b01      	ldr	r3, [sp, #4]
    9cb8:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00

    /* Disable Transmission Delay Compensation by default */
    base->FDCTRL &= ~(FLEXCAN_FDCTRL_TDCEN_MASK | FLEXCAN_FDCTRL_TDCOFF_MASK);
    9cbc:	9b01      	ldr	r3, [sp, #4]
    9cbe:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    9cc2:	f423 421f 	bic.w	r2, r3, #40704	; 0x9f00
    9cc6:	9b01      	ldr	r3, [sp, #4]
    9cc8:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
}
    9ccc:	bf00      	nop
    9cce:	b002      	add	sp, #8
    9cd0:	4770      	bx	lr

00009cd2 <FlexCAN_SetListenOnlyMode>:
 *
 * @param   base    The FlexCAN base address
 * @param   enable  TRUE to enable; FALSE to disable
 */
static inline void FlexCAN_SetListenOnlyMode(FLEXCAN_Type * base, boolean enableListenOnly)
{
    9cd2:	b082      	sub	sp, #8
    9cd4:	9001      	str	r0, [sp, #4]
    9cd6:	460b      	mov	r3, r1
    9cd8:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_LOM_MASK) | FLEXCAN_CTRL1_LOM(enableListenOnly ? 1UL : 0UL);
    9cdc:	9b01      	ldr	r3, [sp, #4]
    9cde:	685b      	ldr	r3, [r3, #4]
    9ce0:	f023 0308 	bic.w	r3, r3, #8
    9ce4:	f89d 2003 	ldrb.w	r2, [sp, #3]
    9ce8:	2a00      	cmp	r2, #0
    9cea:	d001      	beq.n	9cf0 <FlexCAN_SetListenOnlyMode+0x1e>
    9cec:	2208      	movs	r2, #8
    9cee:	e000      	b.n	9cf2 <FlexCAN_SetListenOnlyMode+0x20>
    9cf0:	2200      	movs	r2, #0
    9cf2:	431a      	orrs	r2, r3
    9cf4:	9b01      	ldr	r3, [sp, #4]
    9cf6:	605a      	str	r2, [r3, #4]
}
    9cf8:	bf00      	nop
    9cfa:	b002      	add	sp, #8
    9cfc:	4770      	bx	lr

00009cfe <FlexCAN_UnlockRxMsgBuff>:
 * @brief Unlocks the FlexCAN Rx message buffer.
 *
 * @param   base     The FlexCAN base address
 */
static inline void FlexCAN_UnlockRxMsgBuff(const FLEXCAN_Type * base)
{
    9cfe:	b082      	sub	sp, #8
    9d00:	9001      	str	r0, [sp, #4]
    /* Unlock the mailbox by reading the free running timer */
    (void)base->TIMER;
    9d02:	9b01      	ldr	r3, [sp, #4]
    9d04:	689b      	ldr	r3, [r3, #8]
}
    9d06:	bf00      	nop
    9d08:	b002      	add	sp, #8
    9d0a:	4770      	bx	lr

00009d0c <FlexCAN_ClearMsgBuffIntStatusFlag>:
 *
 * @param   base        The FlexCAN base address
 * @param   msgBuffIdx  Index of the message buffer
 */
static inline void FlexCAN_ClearMsgBuffIntStatusFlag(FLEXCAN_Type * base, uint32 msgBuffIdx)
{
    9d0c:	b084      	sub	sp, #16
    9d0e:	9001      	str	r0, [sp, #4]
    9d10:	9100      	str	r1, [sp, #0]
    uint32 flag = ((uint32)1U << (msgBuffIdx % 32U));
    9d12:	9b00      	ldr	r3, [sp, #0]
    9d14:	f003 031f 	and.w	r3, r3, #31
    9d18:	2201      	movs	r2, #1
    9d1a:	fa02 f303 	lsl.w	r3, r2, r3
    9d1e:	9303      	str	r3, [sp, #12]

    /* Clear the corresponding message buffer interrupt flag*/
    if (msgBuffIdx < 32U)
    9d20:	9b00      	ldr	r3, [sp, #0]
    9d22:	2b1f      	cmp	r3, #31
    9d24:	d802      	bhi.n	9d2c <FlexCAN_ClearMsgBuffIntStatusFlag+0x20>
    {
        (base->IFLAG1) = (flag);
    9d26:	9b01      	ldr	r3, [sp, #4]
    9d28:	9a03      	ldr	r2, [sp, #12]
    9d2a:	631a      	str	r2, [r3, #48]	; 0x30
    else
    {
        (base->IFLAG4) = (flag);
    }
#endif
}
    9d2c:	bf00      	nop
    9d2e:	b004      	add	sp, #16
    9d30:	4770      	bx	lr

00009d32 <FlexCAN_GetBuffStatusFlag>:
 * @param   base                The FlexCAN base address
 * @param   msgBuffIdx  Index of the message buffer
 * @return  flag        The value of interrupt flag of the message buffer.
 */
static inline uint8 FlexCAN_GetBuffStatusFlag(const FLEXCAN_Type * base, uint32 msgBuffIdx)
{
    9d32:	b084      	sub	sp, #16
    9d34:	9001      	str	r0, [sp, #4]
    9d36:	9100      	str	r1, [sp, #0]
    uint32 flag = 0U;
    9d38:	2300      	movs	r3, #0
    9d3a:	9303      	str	r3, [sp, #12]

    if (msgBuffIdx < 32U)
    9d3c:	9b00      	ldr	r3, [sp, #0]
    9d3e:	2b1f      	cmp	r3, #31
    9d40:	d80e      	bhi.n	9d60 <FlexCAN_GetBuffStatusFlag+0x2e>
    {
        flag = ((base->IFLAG1 & ((uint32)1U << (msgBuffIdx % 32U))) >> (msgBuffIdx % 32U));
    9d42:	9b01      	ldr	r3, [sp, #4]
    9d44:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    9d46:	9b00      	ldr	r3, [sp, #0]
    9d48:	f003 031f 	and.w	r3, r3, #31
    9d4c:	2101      	movs	r1, #1
    9d4e:	fa01 f303 	lsl.w	r3, r1, r3
    9d52:	401a      	ands	r2, r3
    9d54:	9b00      	ldr	r3, [sp, #0]
    9d56:	f003 031f 	and.w	r3, r3, #31
    9d5a:	fa22 f303 	lsr.w	r3, r2, r3
    9d5e:	9303      	str	r3, [sp, #12]
    {
        flag = ((base->IFLAG4 & ((uint32)1U << (msgBuffIdx % 32U))) >> (msgBuffIdx % 32U));
    }
#endif

    return (uint8)flag;
    9d60:	9b03      	ldr	r3, [sp, #12]
    9d62:	b2db      	uxtb	r3, r3
}
    9d64:	4618      	mov	r0, r3
    9d66:	b004      	add	sp, #16
    9d68:	4770      	bx	lr

00009d6a <FlexCAN_SetFDTimeSegments>:
 *
 * @param   base The FlexCAN base address
 * @param   timeSeg    FlexCAN time segments, which need to be set for the bit rate.
 */
static inline void FlexCAN_SetFDTimeSegments(FLEXCAN_Type * base, const Flexcan_Ip_TimeSegmentType * timeSeg)
{
    9d6a:	b082      	sub	sp, #8
    9d6c:	9001      	str	r0, [sp, #4]
    9d6e:	9100      	str	r1, [sp, #0]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(timeSeg != NULL_PTR);
#endif
    /* Set FlexCAN time segments*/
    (base->FDCBT) = ((base->FDCBT) & ~((FLEXCAN_FDCBT_FPROPSEG_MASK | FLEXCAN_FDCBT_FPSEG2_MASK |
    9d70:	9b01      	ldr	r3, [sp, #4]
    9d72:	f8d3 2c04 	ldr.w	r2, [r3, #3076]	; 0xc04
    9d76:	4b15      	ldr	r3, [pc, #84]	; (9dcc <FlexCAN_SetFDTimeSegments+0x62>)
    9d78:	4013      	ands	r3, r2
    9d7a:	9a01      	ldr	r2, [sp, #4]
    9d7c:	f8c2 3c04 	str.w	r3, [r2, #3076]	; 0xc04
                                        FLEXCAN_FDCBT_FPSEG1_MASK | FLEXCAN_FDCBT_FPRESDIV_MASK
                                       ) | FLEXCAN_FDCBT_FRJW_MASK
                                      )
                    );

    (base->FDCBT) = ((base->FDCBT) | (FLEXCAN_FDCBT_FPROPSEG(timeSeg->propSeg) |
    9d80:	9b01      	ldr	r3, [sp, #4]
    9d82:	f8d3 2c04 	ldr.w	r2, [r3, #3076]	; 0xc04
    9d86:	9b00      	ldr	r3, [sp, #0]
    9d88:	681b      	ldr	r3, [r3, #0]
    9d8a:	029b      	lsls	r3, r3, #10
    9d8c:	f403 41f8 	and.w	r1, r3, #31744	; 0x7c00
                                      FLEXCAN_FDCBT_FPSEG2(timeSeg->phaseSeg2) |
    9d90:	9b00      	ldr	r3, [sp, #0]
    9d92:	689b      	ldr	r3, [r3, #8]
    9d94:	f003 0307 	and.w	r3, r3, #7
    (base->FDCBT) = ((base->FDCBT) | (FLEXCAN_FDCBT_FPROPSEG(timeSeg->propSeg) |
    9d98:	4319      	orrs	r1, r3
                                      FLEXCAN_FDCBT_FPSEG1(timeSeg->phaseSeg1) |
    9d9a:	9b00      	ldr	r3, [sp, #0]
    9d9c:	685b      	ldr	r3, [r3, #4]
    9d9e:	015b      	lsls	r3, r3, #5
    9da0:	b2db      	uxtb	r3, r3
                                      FLEXCAN_FDCBT_FPSEG2(timeSeg->phaseSeg2) |
    9da2:	4319      	orrs	r1, r3
                                      FLEXCAN_FDCBT_FPRESDIV(timeSeg->preDivider) |
    9da4:	9b00      	ldr	r3, [sp, #0]
    9da6:	68db      	ldr	r3, [r3, #12]
    9da8:	0518      	lsls	r0, r3, #20
    9daa:	4b09      	ldr	r3, [pc, #36]	; (9dd0 <FlexCAN_SetFDTimeSegments+0x66>)
    9dac:	4003      	ands	r3, r0
                                      FLEXCAN_FDCBT_FPSEG1(timeSeg->phaseSeg1) |
    9dae:	4319      	orrs	r1, r3
                                      FLEXCAN_FDCBT_FRJW(timeSeg->rJumpwidth)
    9db0:	9b00      	ldr	r3, [sp, #0]
    9db2:	691b      	ldr	r3, [r3, #16]
    9db4:	041b      	lsls	r3, r3, #16
    9db6:	f403 23e0 	and.w	r3, r3, #458752	; 0x70000
                                      FLEXCAN_FDCBT_FPRESDIV(timeSeg->preDivider) |
    9dba:	430b      	orrs	r3, r1
    (base->FDCBT) = ((base->FDCBT) | (FLEXCAN_FDCBT_FPROPSEG(timeSeg->propSeg) |
    9dbc:	431a      	orrs	r2, r3
    9dbe:	9b01      	ldr	r3, [sp, #4]
    9dc0:	f8c3 2c04 	str.w	r2, [r3, #3076]	; 0xc04
                                     )
                    );
}
    9dc4:	bf00      	nop
    9dc6:	b002      	add	sp, #8
    9dc8:	4770      	bx	lr
    9dca:	bf00      	nop
    9dcc:	c0088318 	.word	0xc0088318
    9dd0:	3ff00000 	.word	0x3ff00000

00009dd4 <FlexCAN_SetTimeSegments>:
 *
 * @param   base The FlexCAN base address
 * @param   timeSeg    FlexCAN time segments, which need to be set for the bit rate.
 */
static inline void FlexCAN_SetTimeSegments(FLEXCAN_Type * base, const Flexcan_Ip_TimeSegmentType * timeSeg)
{
    9dd4:	b082      	sub	sp, #8
    9dd6:	9001      	str	r0, [sp, #4]
    9dd8:	9100      	str	r1, [sp, #0]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(timeSeg != NULL_PTR);
#endif
    (base->CTRL1) = ((base->CTRL1) & ~((FLEXCAN_CTRL1_PROPSEG_MASK | FLEXCAN_CTRL1_PSEG2_MASK |
    9dda:	9b01      	ldr	r3, [sp, #4]
    9ddc:	685a      	ldr	r2, [r3, #4]
    9dde:	f64f 73f8 	movw	r3, #65528	; 0xfff8
    9de2:	4013      	ands	r3, r2
    9de4:	9a01      	ldr	r2, [sp, #4]
    9de6:	6053      	str	r3, [r2, #4]
                                        FLEXCAN_CTRL1_PSEG1_MASK | FLEXCAN_CTRL1_PRESDIV_MASK
                                       ) | FLEXCAN_CTRL1_RJW_MASK
                                      )
                    );

    (base->CTRL1) = ((base->CTRL1) | (FLEXCAN_CTRL1_PROPSEG(timeSeg->propSeg) |
    9de8:	9b01      	ldr	r3, [sp, #4]
    9dea:	685a      	ldr	r2, [r3, #4]
    9dec:	9b00      	ldr	r3, [sp, #0]
    9dee:	681b      	ldr	r3, [r3, #0]
    9df0:	f003 0107 	and.w	r1, r3, #7
                                      FLEXCAN_CTRL1_PSEG2(timeSeg->phaseSeg2) |
    9df4:	9b00      	ldr	r3, [sp, #0]
    9df6:	689b      	ldr	r3, [r3, #8]
    9df8:	041b      	lsls	r3, r3, #16
    9dfa:	f403 23e0 	and.w	r3, r3, #458752	; 0x70000
    (base->CTRL1) = ((base->CTRL1) | (FLEXCAN_CTRL1_PROPSEG(timeSeg->propSeg) |
    9dfe:	4319      	orrs	r1, r3
                                      FLEXCAN_CTRL1_PSEG1(timeSeg->phaseSeg1) |
    9e00:	9b00      	ldr	r3, [sp, #0]
    9e02:	685b      	ldr	r3, [r3, #4]
    9e04:	04db      	lsls	r3, r3, #19
    9e06:	f403 1360 	and.w	r3, r3, #3670016	; 0x380000
                                      FLEXCAN_CTRL1_PSEG2(timeSeg->phaseSeg2) |
    9e0a:	4319      	orrs	r1, r3
                                      FLEXCAN_CTRL1_PRESDIV(timeSeg->preDivider) |
    9e0c:	9b00      	ldr	r3, [sp, #0]
    9e0e:	68db      	ldr	r3, [r3, #12]
    9e10:	061b      	lsls	r3, r3, #24
                                      FLEXCAN_CTRL1_PSEG1(timeSeg->phaseSeg1) |
    9e12:	4319      	orrs	r1, r3
                                      FLEXCAN_CTRL1_RJW(timeSeg->rJumpwidth)
    9e14:	9b00      	ldr	r3, [sp, #0]
    9e16:	691b      	ldr	r3, [r3, #16]
    9e18:	059b      	lsls	r3, r3, #22
    9e1a:	f403 0340 	and.w	r3, r3, #12582912	; 0xc00000
                                      FLEXCAN_CTRL1_PRESDIV(timeSeg->preDivider) |
    9e1e:	430b      	orrs	r3, r1
    (base->CTRL1) = ((base->CTRL1) | (FLEXCAN_CTRL1_PROPSEG(timeSeg->propSeg) |
    9e20:	431a      	orrs	r2, r3
    9e22:	9b01      	ldr	r3, [sp, #4]
    9e24:	605a      	str	r2, [r3, #4]
                                     )
                    );
}
    9e26:	bf00      	nop
    9e28:	b002      	add	sp, #8
    9e2a:	4770      	bx	lr

00009e2c <FlexCAN_SetExtendedTimeSegments>:
 *
 * @param   base The FlexCAN base address
 * @param   timeSeg    FlexCAN time segments, which need to be set for the bit rate.
 */
static inline void FlexCAN_SetExtendedTimeSegments(FLEXCAN_Type * base, const Flexcan_Ip_TimeSegmentType * timeSeg)
{
    9e2c:	b082      	sub	sp, #8
    9e2e:	9001      	str	r0, [sp, #4]
    9e30:	9100      	str	r1, [sp, #0]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(timeSeg != NULL_PTR);
#endif
    /* If extended bit time definitions are enabled, use CBT register */
    (base->CBT) = ((base->CBT) & ~((FLEXCAN_CBT_EPROPSEG_MASK | FLEXCAN_CBT_EPSEG2_MASK |
    9e32:	9b01      	ldr	r3, [sp, #4]
    9e34:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    9e36:	f003 4200 	and.w	r2, r3, #2147483648	; 0x80000000
    9e3a:	9b01      	ldr	r3, [sp, #4]
    9e3c:	651a      	str	r2, [r3, #80]	; 0x50
                                    FLEXCAN_CBT_EPSEG1_MASK | FLEXCAN_CBT_EPRESDIV_MASK
                                   ) | FLEXCAN_CBT_ERJW_MASK
                                  )
                  );

    (base->CBT) = ((base->CBT) | (FLEXCAN_CBT_EPROPSEG(timeSeg->propSeg) |
    9e3e:	9b01      	ldr	r3, [sp, #4]
    9e40:	6d1a      	ldr	r2, [r3, #80]	; 0x50
    9e42:	9b00      	ldr	r3, [sp, #0]
    9e44:	681b      	ldr	r3, [r3, #0]
    9e46:	029b      	lsls	r3, r3, #10
    9e48:	b299      	uxth	r1, r3
                                  FLEXCAN_CBT_EPSEG2(timeSeg->phaseSeg2) |
    9e4a:	9b00      	ldr	r3, [sp, #0]
    9e4c:	689b      	ldr	r3, [r3, #8]
    9e4e:	f003 031f 	and.w	r3, r3, #31
    (base->CBT) = ((base->CBT) | (FLEXCAN_CBT_EPROPSEG(timeSeg->propSeg) |
    9e52:	4319      	orrs	r1, r3
                                  FLEXCAN_CBT_EPSEG1(timeSeg->phaseSeg1) |
    9e54:	9b00      	ldr	r3, [sp, #0]
    9e56:	685b      	ldr	r3, [r3, #4]
    9e58:	015b      	lsls	r3, r3, #5
    9e5a:	f403 7378 	and.w	r3, r3, #992	; 0x3e0
                                  FLEXCAN_CBT_EPSEG2(timeSeg->phaseSeg2) |
    9e5e:	4319      	orrs	r1, r3
                                  FLEXCAN_CBT_EPRESDIV(timeSeg->preDivider) |
    9e60:	9b00      	ldr	r3, [sp, #0]
    9e62:	68db      	ldr	r3, [r3, #12]
    9e64:	0558      	lsls	r0, r3, #21
    9e66:	4b07      	ldr	r3, [pc, #28]	; (9e84 <FlexCAN_SetExtendedTimeSegments+0x58>)
    9e68:	4003      	ands	r3, r0
                                  FLEXCAN_CBT_EPSEG1(timeSeg->phaseSeg1) |
    9e6a:	4319      	orrs	r1, r3
                                  FLEXCAN_CBT_ERJW(timeSeg->rJumpwidth)
    9e6c:	9b00      	ldr	r3, [sp, #0]
    9e6e:	691b      	ldr	r3, [r3, #16]
    9e70:	041b      	lsls	r3, r3, #16
    9e72:	f403 13f8 	and.w	r3, r3, #2031616	; 0x1f0000
                                  FLEXCAN_CBT_EPRESDIV(timeSeg->preDivider) |
    9e76:	430b      	orrs	r3, r1
    (base->CBT) = ((base->CBT) | (FLEXCAN_CBT_EPROPSEG(timeSeg->propSeg) |
    9e78:	431a      	orrs	r2, r3
    9e7a:	9b01      	ldr	r3, [sp, #4]
    9e7c:	651a      	str	r2, [r3, #80]	; 0x50
                                 )
                  );
}
    9e7e:	bf00      	nop
    9e80:	b002      	add	sp, #8
    9e82:	4770      	bx	lr
    9e84:	7fe00000 	.word	0x7fe00000

00009e88 <FlexCAN_GetExtendedTimeSegments>:
 *
 * @param[in]   base The FlexCAN base address
 * @param[out]   timeSeg    FlexCAN time segments read for bit rate
 */
static inline void FlexCAN_GetExtendedTimeSegments(const FLEXCAN_Type * base, Flexcan_Ip_TimeSegmentType * timeSeg)
{
    9e88:	b082      	sub	sp, #8
    9e8a:	9001      	str	r0, [sp, #4]
    9e8c:	9100      	str	r1, [sp, #0]
    timeSeg->preDivider = ((base->CBT) & FLEXCAN_CBT_EPRESDIV_MASK) >> FLEXCAN_CBT_EPRESDIV_SHIFT;
    9e8e:	9b01      	ldr	r3, [sp, #4]
    9e90:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    9e92:	0d5b      	lsrs	r3, r3, #21
    9e94:	f3c3 0209 	ubfx	r2, r3, #0, #10
    9e98:	9b00      	ldr	r3, [sp, #0]
    9e9a:	60da      	str	r2, [r3, #12]
    timeSeg->propSeg = ((base->CBT) & FLEXCAN_CBT_EPROPSEG_MASK) >> FLEXCAN_CBT_EPROPSEG_SHIFT;
    9e9c:	9b01      	ldr	r3, [sp, #4]
    9e9e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    9ea0:	0a9b      	lsrs	r3, r3, #10
    9ea2:	f003 023f 	and.w	r2, r3, #63	; 0x3f
    9ea6:	9b00      	ldr	r3, [sp, #0]
    9ea8:	601a      	str	r2, [r3, #0]
    timeSeg->phaseSeg1 = ((base->CBT) & FLEXCAN_CBT_EPSEG1_MASK) >> FLEXCAN_CBT_EPSEG1_SHIFT;
    9eaa:	9b01      	ldr	r3, [sp, #4]
    9eac:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    9eae:	095b      	lsrs	r3, r3, #5
    9eb0:	f003 021f 	and.w	r2, r3, #31
    9eb4:	9b00      	ldr	r3, [sp, #0]
    9eb6:	605a      	str	r2, [r3, #4]
    timeSeg->phaseSeg2 = ((base->CBT) & FLEXCAN_CBT_EPSEG2_MASK) >> FLEXCAN_CBT_EPSEG2_SHIFT;
    9eb8:	9b01      	ldr	r3, [sp, #4]
    9eba:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    9ebc:	f003 021f 	and.w	r2, r3, #31
    9ec0:	9b00      	ldr	r3, [sp, #0]
    9ec2:	609a      	str	r2, [r3, #8]
    timeSeg->rJumpwidth = ((base->CBT) & FLEXCAN_CBT_ERJW_MASK) >> FLEXCAN_CBT_ERJW_SHIFT;
    9ec4:	9b01      	ldr	r3, [sp, #4]
    9ec6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    9ec8:	0c1b      	lsrs	r3, r3, #16
    9eca:	f003 021f 	and.w	r2, r3, #31
    9ece:	9b00      	ldr	r3, [sp, #0]
    9ed0:	611a      	str	r2, [r3, #16]
}
    9ed2:	bf00      	nop
    9ed4:	b002      	add	sp, #8
    9ed6:	4770      	bx	lr

00009ed8 <FlexCAN_GetTimeSegments>:
 *
 * @param[in]   base The FlexCAN base address
 * @param[out]   timeSeg    FlexCAN time segments read for bit rate
 */
static inline void FlexCAN_GetTimeSegments(const FLEXCAN_Type * base, Flexcan_Ip_TimeSegmentType * timeSeg)
{
    9ed8:	b082      	sub	sp, #8
    9eda:	9001      	str	r0, [sp, #4]
    9edc:	9100      	str	r1, [sp, #0]
    timeSeg->preDivider = ((base->CTRL1) & FLEXCAN_CTRL1_PRESDIV_MASK) >> FLEXCAN_CTRL1_PRESDIV_SHIFT;
    9ede:	9b01      	ldr	r3, [sp, #4]
    9ee0:	685b      	ldr	r3, [r3, #4]
    9ee2:	0e1b      	lsrs	r3, r3, #24
    9ee4:	b2da      	uxtb	r2, r3
    9ee6:	9b00      	ldr	r3, [sp, #0]
    9ee8:	60da      	str	r2, [r3, #12]
    timeSeg->propSeg = ((base->CTRL1) & FLEXCAN_CTRL1_PROPSEG_MASK) >> FLEXCAN_CTRL1_PROPSEG_SHIFT;
    9eea:	9b01      	ldr	r3, [sp, #4]
    9eec:	685b      	ldr	r3, [r3, #4]
    9eee:	f003 0207 	and.w	r2, r3, #7
    9ef2:	9b00      	ldr	r3, [sp, #0]
    9ef4:	601a      	str	r2, [r3, #0]
    timeSeg->phaseSeg1 = ((base->CTRL1) & FLEXCAN_CTRL1_PSEG1_MASK) >> FLEXCAN_CTRL1_PSEG1_SHIFT;
    9ef6:	9b01      	ldr	r3, [sp, #4]
    9ef8:	685b      	ldr	r3, [r3, #4]
    9efa:	0cdb      	lsrs	r3, r3, #19
    9efc:	f003 0207 	and.w	r2, r3, #7
    9f00:	9b00      	ldr	r3, [sp, #0]
    9f02:	605a      	str	r2, [r3, #4]
    timeSeg->phaseSeg2 = ((base->CTRL1) & FLEXCAN_CTRL1_PSEG2_MASK) >> FLEXCAN_CTRL1_PSEG2_SHIFT;
    9f04:	9b01      	ldr	r3, [sp, #4]
    9f06:	685b      	ldr	r3, [r3, #4]
    9f08:	0c1b      	lsrs	r3, r3, #16
    9f0a:	f003 0207 	and.w	r2, r3, #7
    9f0e:	9b00      	ldr	r3, [sp, #0]
    9f10:	609a      	str	r2, [r3, #8]
    timeSeg->rJumpwidth = ((base->CTRL1) & FLEXCAN_CTRL1_RJW_MASK) >> FLEXCAN_CTRL1_RJW_SHIFT;
    9f12:	9b01      	ldr	r3, [sp, #4]
    9f14:	685b      	ldr	r3, [r3, #4]
    9f16:	0d9b      	lsrs	r3, r3, #22
    9f18:	f003 0203 	and.w	r2, r3, #3
    9f1c:	9b00      	ldr	r3, [sp, #0]
    9f1e:	611a      	str	r2, [r3, #16]
}
    9f20:	bf00      	nop
    9f22:	b002      	add	sp, #8
    9f24:	4770      	bx	lr

00009f26 <FlexCAN_GetFDTimeSegments>:
 *
 * @param   base The FlexCAN base address
 * @param   timeSeg    FlexCAN time segments read for bit rate
 */
static inline void FlexCAN_GetFDTimeSegments(const FLEXCAN_Type * base, Flexcan_Ip_TimeSegmentType * timeSeg)
{
    9f26:	b082      	sub	sp, #8
    9f28:	9001      	str	r0, [sp, #4]
    9f2a:	9100      	str	r1, [sp, #0]
    timeSeg->preDivider = ((base->FDCBT) & FLEXCAN_FDCBT_FPRESDIV_MASK) >> FLEXCAN_FDCBT_FPRESDIV_SHIFT;
    9f2c:	9b01      	ldr	r3, [sp, #4]
    9f2e:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	; 0xc04
    9f32:	0d1b      	lsrs	r3, r3, #20
    9f34:	f3c3 0209 	ubfx	r2, r3, #0, #10
    9f38:	9b00      	ldr	r3, [sp, #0]
    9f3a:	60da      	str	r2, [r3, #12]
    timeSeg->propSeg = ((base->FDCBT) & FLEXCAN_FDCBT_FPROPSEG_MASK) >> FLEXCAN_FDCBT_FPROPSEG_SHIFT;
    9f3c:	9b01      	ldr	r3, [sp, #4]
    9f3e:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	; 0xc04
    9f42:	0a9b      	lsrs	r3, r3, #10
    9f44:	f003 021f 	and.w	r2, r3, #31
    9f48:	9b00      	ldr	r3, [sp, #0]
    9f4a:	601a      	str	r2, [r3, #0]
    timeSeg->phaseSeg1 = ((base->FDCBT) & FLEXCAN_FDCBT_FPSEG1_MASK) >> FLEXCAN_FDCBT_FPSEG1_SHIFT;
    9f4c:	9b01      	ldr	r3, [sp, #4]
    9f4e:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	; 0xc04
    9f52:	095b      	lsrs	r3, r3, #5
    9f54:	f003 0207 	and.w	r2, r3, #7
    9f58:	9b00      	ldr	r3, [sp, #0]
    9f5a:	605a      	str	r2, [r3, #4]
    timeSeg->phaseSeg2 = ((base->FDCBT) & FLEXCAN_FDCBT_FPSEG2_MASK) >> FLEXCAN_FDCBT_FPSEG2_SHIFT;
    9f5c:	9b01      	ldr	r3, [sp, #4]
    9f5e:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	; 0xc04
    9f62:	f003 0207 	and.w	r2, r3, #7
    9f66:	9b00      	ldr	r3, [sp, #0]
    9f68:	609a      	str	r2, [r3, #8]
    timeSeg->rJumpwidth = ((base->FDCBT) & FLEXCAN_FDCBT_FRJW_MASK) >> FLEXCAN_FDCBT_FRJW_SHIFT;
    9f6a:	9b01      	ldr	r3, [sp, #4]
    9f6c:	f8d3 3c04 	ldr.w	r3, [r3, #3076]	; 0xc04
    9f70:	0c1b      	lsrs	r3, r3, #16
    9f72:	f003 0207 	and.w	r2, r3, #7
    9f76:	9b00      	ldr	r3, [sp, #0]
    9f78:	611a      	str	r2, [r3, #16]
}
    9f7a:	bf00      	nop
    9f7c:	b002      	add	sp, #8
    9f7e:	4770      	bx	lr

00009f80 <FlexCAN_IsExCbtEnabled>:
 *
 * @param   base    The FlexCAN base address
 * @return  TRUE if enabled; FALSE if disabled
 */
static inline boolean FlexCAN_IsExCbtEnabled(const FLEXCAN_Type * pBase)
{
    9f80:	b082      	sub	sp, #8
    9f82:	9001      	str	r0, [sp, #4]
    return (0U == ((pBase->CBT & FLEXCAN_CBT_BTF_MASK) >> FLEXCAN_CBT_BTF_SHIFT)) ? FALSE : TRUE;
    9f84:	9b01      	ldr	r3, [sp, #4]
    9f86:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    9f88:	0fdb      	lsrs	r3, r3, #31
    9f8a:	b2db      	uxtb	r3, r3
}
    9f8c:	4618      	mov	r0, r3
    9f8e:	b002      	add	sp, #8
    9f90:	4770      	bx	lr

00009f92 <FlexCAN_EnableExtCbt>:
 *
 * @param   base    The FlexCAN base address
 * @param   enableCBT Enable/Disable use of Extent Time Segments
 */
static inline void FlexCAN_EnableExtCbt(FLEXCAN_Type * base, boolean enableCBT)
{   /* Enable the use of extended bit time definitions */
    9f92:	b082      	sub	sp, #8
    9f94:	9001      	str	r0, [sp, #4]
    9f96:	460b      	mov	r3, r1
    9f98:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CBT = (base->CBT & ~FLEXCAN_CBT_BTF_MASK) | FLEXCAN_CBT_BTF(enableCBT ? 1UL : 0UL);
    9f9c:	9b01      	ldr	r3, [sp, #4]
    9f9e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
    9fa0:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    9fa4:	f89d 2003 	ldrb.w	r2, [sp, #3]
    9fa8:	2a00      	cmp	r2, #0
    9faa:	d002      	beq.n	9fb2 <FlexCAN_EnableExtCbt+0x20>
    9fac:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    9fb0:	e000      	b.n	9fb4 <FlexCAN_EnableExtCbt+0x22>
    9fb2:	2200      	movs	r2, #0
    9fb4:	431a      	orrs	r2, r3
    9fb6:	9b01      	ldr	r3, [sp, #4]
    9fb8:	651a      	str	r2, [r3, #80]	; 0x50
}
    9fba:	bf00      	nop
    9fbc:	b002      	add	sp, #8
    9fbe:	4770      	bx	lr

00009fc0 <FlexCAN_SetSelfReception>:
 *
 * @param   base  The FlexCAN base address
 * @param   enable Enable/Disable Self Reception
 */
static inline void FlexCAN_SetSelfReception(FLEXCAN_Type * base, boolean enable)
{
    9fc0:	b082      	sub	sp, #8
    9fc2:	9001      	str	r0, [sp, #4]
    9fc4:	460b      	mov	r3, r1
    9fc6:	f88d 3003 	strb.w	r3, [sp, #3]
    base->MCR = (base->MCR & ~FLEXCAN_MCR_SRXDIS_MASK) | FLEXCAN_MCR_SRXDIS(enable ? 0UL : 1UL);
    9fca:	9b01      	ldr	r3, [sp, #4]
    9fcc:	681b      	ldr	r3, [r3, #0]
    9fce:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    9fd2:	f89d 2003 	ldrb.w	r2, [sp, #3]
    9fd6:	2a00      	cmp	r2, #0
    9fd8:	d001      	beq.n	9fde <FlexCAN_SetSelfReception+0x1e>
    9fda:	2200      	movs	r2, #0
    9fdc:	e001      	b.n	9fe2 <FlexCAN_SetSelfReception+0x22>
    9fde:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    9fe2:	431a      	orrs	r2, r3
    9fe4:	9b01      	ldr	r3, [sp, #4]
    9fe6:	601a      	str	r2, [r3, #0]
}
    9fe8:	bf00      	nop
    9fea:	b002      	add	sp, #8
    9fec:	4770      	bx	lr

00009fee <FlexCAN_IsFDEnabled>:
 *
 * @param   base    The FlexCAN base address
 * @return  TRUE if enabled; FALSE if disabled
 */
static inline boolean FlexCAN_IsFDEnabled(const FLEXCAN_Type * base)
{
    9fee:	b082      	sub	sp, #8
    9ff0:	9001      	str	r0, [sp, #4]
    return ((base->MCR & FLEXCAN_MCR_FDEN_MASK) >> FLEXCAN_MCR_FDEN_SHIFT) != 0U;
    9ff2:	9b01      	ldr	r3, [sp, #4]
    9ff4:	681b      	ldr	r3, [r3, #0]
    9ff6:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    9ffa:	2b00      	cmp	r3, #0
    9ffc:	bf14      	ite	ne
    9ffe:	2301      	movne	r3, #1
    a000:	2300      	moveq	r3, #0
    a002:	b2db      	uxtb	r3, r3
}
    a004:	4618      	mov	r0, r3
    a006:	b002      	add	sp, #8
    a008:	4770      	bx	lr

0000a00a <FlexCAN_IsListenOnlyModeEnabled>:
 *
 * @param   base    The FlexCAN base address
 * @return  TRUE if enabled; FALSE if disabled
 */
static inline boolean FlexCAN_IsListenOnlyModeEnabled(const FLEXCAN_Type * base)
{
    a00a:	b082      	sub	sp, #8
    a00c:	9001      	str	r0, [sp, #4]
    return (((base->CTRL1 & (FLEXCAN_CTRL1_LOM_MASK)) != 0U) ? TRUE : FALSE);
    a00e:	9b01      	ldr	r3, [sp, #4]
    a010:	685b      	ldr	r3, [r3, #4]
    a012:	f003 0308 	and.w	r3, r3, #8
    a016:	2b00      	cmp	r3, #0
    a018:	bf14      	ite	ne
    a01a:	2301      	movne	r3, #1
    a01c:	2300      	moveq	r3, #0
    a01e:	b2db      	uxtb	r3, r3
}
    a020:	4618      	mov	r0, r3
    a022:	b002      	add	sp, #8
    a024:	4770      	bx	lr

0000a026 <RxFifoOcuppiedLastMsgBuff>:
 *
 * @param   x    Number of Configured RxFIFO Filters
 * @return  number of last MB occupied by RxFIFO
 */
static inline uint32 RxFifoOcuppiedLastMsgBuff(uint8 x)
{
    a026:	b082      	sub	sp, #8
    a028:	4603      	mov	r3, r0
    a02a:	f88d 3007 	strb.w	r3, [sp, #7]
    return 5U + (((((uint32)x) + 1U) * 8U) / 4U);
    a02e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a032:	3301      	adds	r3, #1
    a034:	00db      	lsls	r3, r3, #3
    a036:	089b      	lsrs	r3, r3, #2
    a038:	3305      	adds	r3, #5
}
    a03a:	4618      	mov	r0, r3
    a03c:	b002      	add	sp, #8
    a03e:	4770      	bx	lr

0000a040 <FlexCAN_SetClkSrc>:
 *
 * @param   base  The FlexCAN base address
 * @param   enable Specifies if The CAN engine clock source is the oscillator clock(FALSE) or peripheral clock(TRUE).
 */
static inline void FlexCAN_SetClkSrc(FLEXCAN_Type * base, boolean enable)
{
    a040:	b082      	sub	sp, #8
    a042:	9001      	str	r0, [sp, #4]
    a044:	460b      	mov	r3, r1
    a046:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_CLKSRC_MASK) | FLEXCAN_CTRL1_CLKSRC(enable ? 1UL : 0UL);
    a04a:	9b01      	ldr	r3, [sp, #4]
    a04c:	685b      	ldr	r3, [r3, #4]
    a04e:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
    a052:	f89d 2003 	ldrb.w	r2, [sp, #3]
    a056:	2a00      	cmp	r2, #0
    a058:	d002      	beq.n	a060 <FlexCAN_SetClkSrc+0x20>
    a05a:	f44f 5200 	mov.w	r2, #8192	; 0x2000
    a05e:	e000      	b.n	a062 <FlexCAN_SetClkSrc+0x22>
    a060:	2200      	movs	r2, #0
    a062:	431a      	orrs	r2, r3
    a064:	9b01      	ldr	r3, [sp, #4]
    a066:	605a      	str	r2, [r3, #4]
}
    a068:	bf00      	nop
    a06a:	b002      	add	sp, #8
    a06c:	4770      	bx	lr

0000a06e <FlexCAN_GetMsgBuffIntStatusFlag>:
 * @param   base  The FlexCAN base address
 * @param   msgBuffIdx       Index of the message buffer
 * @return  the individual Message Buffer interrupt flag (0 and 1 are the flag value)
 */
static inline uint8 FlexCAN_GetMsgBuffIntStatusFlag(const FLEXCAN_Type * base, uint32 msgBuffIdx)
{
    a06e:	b084      	sub	sp, #16
    a070:	9001      	str	r0, [sp, #4]
    a072:	9100      	str	r1, [sp, #0]
    /* TODO: This need to be protected multithread access*/
    uint8 flag = 0;
    a074:	2300      	movs	r3, #0
    a076:	f88d 300f 	strb.w	r3, [sp, #15]
    uint32 mask;

    if (msgBuffIdx < 32U)
    a07a:	9b00      	ldr	r3, [sp, #0]
    a07c:	2b1f      	cmp	r3, #31
    a07e:	d810      	bhi.n	a0a2 <FlexCAN_GetMsgBuffIntStatusFlag+0x34>
    {
        mask = base->IMASK1 & FLEXCAN_IMASK1_BUF31TO0M_MASK;
    a080:	9b01      	ldr	r3, [sp, #4]
    a082:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    a084:	9302      	str	r3, [sp, #8]
        flag = (uint8)(((base->IFLAG1 & mask) >> (msgBuffIdx % 32U)) & 1U);
    a086:	9b01      	ldr	r3, [sp, #4]
    a088:	6b1a      	ldr	r2, [r3, #48]	; 0x30
    a08a:	9b02      	ldr	r3, [sp, #8]
    a08c:	401a      	ands	r2, r3
    a08e:	9b00      	ldr	r3, [sp, #0]
    a090:	f003 031f 	and.w	r3, r3, #31
    a094:	fa22 f303 	lsr.w	r3, r2, r3
    a098:	b2db      	uxtb	r3, r3
    a09a:	f003 0301 	and.w	r3, r3, #1
    a09e:	f88d 300f 	strb.w	r3, [sp, #15]
        mask = base->IMASK4 & FLEXCAN_IMASK4_BUF127TO96M_MASK;
        flag = (uint8)(((base->IFLAG4 & mask) >> (msgBuffIdx % 32U)) & 1U);
    }
#endif

    return flag;
    a0a2:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    a0a6:	4618      	mov	r0, r3
    a0a8:	b004      	add	sp, #16
    a0aa:	4770      	bx	lr

0000a0ac <FlexCAN_SetRxMsgBuffGlobalMask>:
 *
 * @param   base  The FlexCAN base address
 * @param   Mask  Mask Value
 */
static inline void FlexCAN_SetRxMsgBuffGlobalMask(FLEXCAN_Type * base, uint32 Mask)
{
    a0ac:	b082      	sub	sp, #8
    a0ae:	9001      	str	r0, [sp, #4]
    a0b0:	9100      	str	r1, [sp, #0]
    (base->RXMGMASK) = Mask;
    a0b2:	9b01      	ldr	r3, [sp, #4]
    a0b4:	9a00      	ldr	r2, [sp, #0]
    a0b6:	611a      	str	r2, [r3, #16]
}
    a0b8:	bf00      	nop
    a0ba:	b002      	add	sp, #8
    a0bc:	4770      	bx	lr

0000a0be <FlexCAN_SetRxIndividualMask>:
 */
static inline void FlexCAN_SetRxIndividualMask(FLEXCAN_Type * base,
                                               uint32 msgBuffIdx,
                                               uint32 mask
                                              )
{
    a0be:	b084      	sub	sp, #16
    a0c0:	9003      	str	r0, [sp, #12]
    a0c2:	9102      	str	r1, [sp, #8]
    a0c4:	9201      	str	r2, [sp, #4]
    base->RXIMR[msgBuffIdx] = mask;
    a0c6:	9b03      	ldr	r3, [sp, #12]
    a0c8:	9a02      	ldr	r2, [sp, #8]
    a0ca:	f502 7208 	add.w	r2, r2, #544	; 0x220
    a0ce:	9901      	ldr	r1, [sp, #4]
    a0d0:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
    a0d4:	bf00      	nop
    a0d6:	b004      	add	sp, #16
    a0d8:	4770      	bx	lr

0000a0da <FlexCAN_SetTxArbitrationStartDelay>:
 *
 * @param   base  The FlexCAN base address
 * @param   tasd  The Tx arbitration start delay value
 */
static inline void FlexCAN_SetTxArbitrationStartDelay(FLEXCAN_Type * base, uint8 tasd)
{
    a0da:	b082      	sub	sp, #8
    a0dc:	9001      	str	r0, [sp, #4]
    a0de:	460b      	mov	r3, r1
    a0e0:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_TASD_MASK) | FLEXCAN_CTRL2_TASD(tasd);
    a0e4:	9b01      	ldr	r3, [sp, #4]
    a0e6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    a0e8:	f423 0278 	bic.w	r2, r3, #16252928	; 0xf80000
    a0ec:	f89d 3003 	ldrb.w	r3, [sp, #3]
    a0f0:	04db      	lsls	r3, r3, #19
    a0f2:	f403 0378 	and.w	r3, r3, #16252928	; 0xf80000
    a0f6:	431a      	orrs	r2, r3
    a0f8:	9b01      	ldr	r3, [sp, #4]
    a0fa:	635a      	str	r2, [r3, #52]	; 0x34
}
    a0fc:	bf00      	nop
    a0fe:	b002      	add	sp, #8
    a100:	4770      	bx	lr

0000a102 <FlexCAN_SetRxMaskType>:
 *
 * @param   base  The FlexCAN base address
 * @param   type         The FlexCAN Rx mask type
 */
static inline void FlexCAN_SetRxMaskType(FLEXCAN_Type * base, Flexcan_Ip_RxMaskType type)
{
    a102:	b082      	sub	sp, #8
    a104:	9001      	str	r0, [sp, #4]
    a106:	9100      	str	r1, [sp, #0]
    /* Set RX masking type (RX global mask or RX individual mask)*/
    if (FLEXCAN_RX_MASK_GLOBAL == type)
    a108:	9b00      	ldr	r3, [sp, #0]
    a10a:	2b00      	cmp	r3, #0
    a10c:	d106      	bne.n	a11c <FlexCAN_SetRxMaskType+0x1a>
    {
        /* Enable Global RX masking */
        base->MCR = (base->MCR & ~FLEXCAN_MCR_IRMQ_MASK) | FLEXCAN_MCR_IRMQ(0U);
    a10e:	9b01      	ldr	r3, [sp, #4]
    a110:	681b      	ldr	r3, [r3, #0]
    a112:	f423 3280 	bic.w	r2, r3, #65536	; 0x10000
    a116:	9b01      	ldr	r3, [sp, #4]
    a118:	601a      	str	r2, [r3, #0]
    else
    {
        /* Enable Individual Rx Masking and Queue */
        base->MCR = (base->MCR & ~FLEXCAN_MCR_IRMQ_MASK) | FLEXCAN_MCR_IRMQ(1U);
    }
}
    a11a:	e005      	b.n	a128 <FlexCAN_SetRxMaskType+0x26>
        base->MCR = (base->MCR & ~FLEXCAN_MCR_IRMQ_MASK) | FLEXCAN_MCR_IRMQ(1U);
    a11c:	9b01      	ldr	r3, [sp, #4]
    a11e:	681b      	ldr	r3, [r3, #0]
    a120:	f443 3280 	orr.w	r2, r3, #65536	; 0x10000
    a124:	9b01      	ldr	r3, [sp, #4]
    a126:	601a      	str	r2, [r3, #0]
}
    a128:	bf00      	nop
    a12a:	b002      	add	sp, #8
    a12c:	4770      	bx	lr

0000a12e <FlexCAN_SetRegDefaultVal>:
 * @brief Will set Flexcan Peripheral Register to default val.
 *
 * @param   base    The FlexCAN base address
 */
static inline void FlexCAN_SetRegDefaultVal(FLEXCAN_Type * base)
{
    a12e:	b500      	push	{lr}
    a130:	b083      	sub	sp, #12
    a132:	9001      	str	r0, [sp, #4]
        base->ERFCR = FLEXCAN_IP_ERFCR_DEFAULT_VALUE_U32;
    }
#endif /* (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) */
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
    #if defined(CAN_FEATURE_S32K1XX)
    if (TRUE == FlexCAN_IsFDAvailable(base))
    a134:	9801      	ldr	r0, [sp, #4]
    a136:	f002 ff85 	bl	d044 <FlexCAN_IsFDAvailable>
    a13a:	4603      	mov	r3, r0
    a13c:	2b00      	cmp	r3, #0
    a13e:	d007      	beq.n	a150 <FlexCAN_SetRegDefaultVal+0x22>
    {
    #endif /* defined(CAN_FEATURE_S32K1XX) */
        base->FDCBT = FLEXCAN_IP_FDCBT_DEFAULT_VALUE_U32;
    a140:	9b01      	ldr	r3, [sp, #4]
    a142:	2200      	movs	r2, #0
    a144:	f8c3 2c04 	str.w	r2, [r3, #3076]	; 0xc04
        base->FDCTRL = FLEXCAN_IP_FDCTRL_DEFAULT_VALUE_U32;
    a148:	9b01      	ldr	r3, [sp, #4]
    a14a:	4a12      	ldr	r2, [pc, #72]	; (a194 <FlexCAN_SetRegDefaultVal+0x66>)
    a14c:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
    {
        base->IFLAG2 = FLEXCAN_IP_IFLAG_DEFAULT_VALUE_U32;
        base->IMASK2 = FLEXCAN_IP_IMASK_DEFAULT_VALUE_U32;
    }
#endif /* (FLEXCAN_IP_FEATURE_MAX_MB_NUM > 32U) */
    base->IFLAG1 = FLEXCAN_IP_IFLAG_DEFAULT_VALUE_U32;
    a150:	9b01      	ldr	r3, [sp, #4]
    a152:	f04f 32ff 	mov.w	r2, #4294967295
    a156:	631a      	str	r2, [r3, #48]	; 0x30
    base->IMASK1 = FLEXCAN_IP_IMASK_DEFAULT_VALUE_U32;
    a158:	9b01      	ldr	r3, [sp, #4]
    a15a:	2200      	movs	r2, #0
    a15c:	629a      	str	r2, [r3, #40]	; 0x28
    base->CBT = FLEXCAN_IP_CBT_DEFAULT_VALUE_U32;
    a15e:	9b01      	ldr	r3, [sp, #4]
    a160:	2200      	movs	r2, #0
    a162:	651a      	str	r2, [r3, #80]	; 0x50
    base->CTRL2 = FLEXCAN_IP_CTRL2_DEFAULT_VALUE_U32;
    a164:	9b01      	ldr	r3, [sp, #4]
    a166:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    a16a:	635a      	str	r2, [r3, #52]	; 0x34
    base->ESR1 = FLEXCAN_IP_ESR1_DEFAULT_VALUE_U32;
    a16c:	9b01      	ldr	r3, [sp, #4]
    a16e:	4a0a      	ldr	r2, [pc, #40]	; (a198 <FlexCAN_SetRegDefaultVal+0x6a>)
    a170:	621a      	str	r2, [r3, #32]
    base->ECR = FLEXCAN_IP_ECR_DEFAULT_VALUE_U32;
    a172:	9b01      	ldr	r3, [sp, #4]
    a174:	2200      	movs	r2, #0
    a176:	61da      	str	r2, [r3, #28]
    base->TIMER = FLEXCAN_IP_TIMER_DEFAULT_VALUE_U32;
    a178:	9b01      	ldr	r3, [sp, #4]
    a17a:	2200      	movs	r2, #0
    a17c:	609a      	str	r2, [r3, #8]
    base->CTRL1 = FLEXCAN_IP_CTRL1_DEFAULT_VALUE_U32;
    a17e:	9b01      	ldr	r3, [sp, #4]
    a180:	2200      	movs	r2, #0
    a182:	605a      	str	r2, [r3, #4]
    base->EPRS  = FLEXCAN_IP_EPRS_DEFAULT_VALUE_U32;
    base->ENCBT = FLEXCAN_IP_ENCBT_DEFAULT_VALUE_U32;
    base->EDCBT = FLEXCAN_IP_EDCBT_DEFAULT_VALUE_U32;
    base->ETDC  = FLEXCAN_IP_ETDC_DEFAULT_VALUE_U32;
#endif
    base->MCR = FLEXCAN_IP_MCR_DEFAULT_VALUE_U32;
    a184:	9b01      	ldr	r3, [sp, #4]
    a186:	4a05      	ldr	r2, [pc, #20]	; (a19c <FlexCAN_SetRegDefaultVal+0x6e>)
    a188:	601a      	str	r2, [r3, #0]
}
    a18a:	bf00      	nop
    a18c:	b003      	add	sp, #12
    a18e:	f85d fb04 	ldr.w	pc, [sp], #4
    a192:	bf00      	nop
    a194:	80004100 	.word	0x80004100
    a198:	0003b006 	.word	0x0003b006
    a19c:	d890000f 	.word	0xd890000f

0000a1a0 <FlexCAN_InitRxFifo>:
 * Description   : Initialize fifo and dma if requested.
 *
 * This is not a public API as it is called from other driver functions.
 *END**************************************************************************/
static Flexcan_Ip_StatusType FlexCAN_InitRxFifo(FLEXCAN_Type * pBase, const Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
    a1a0:	b500      	push	{lr}
    a1a2:	b085      	sub	sp, #20
    a1a4:	9001      	str	r0, [sp, #4]
    a1a6:	9100      	str	r1, [sp, #0]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    a1a8:	2300      	movs	r3, #0
    a1aa:	9303      	str	r3, [sp, #12]

    /* Enable RxFIFO feature, if requested. This might fail if the FD mode is enabled. */
    if (Flexcan_Ip_pData->is_rx_fifo_needed)
    a1ac:	9b00      	ldr	r3, [sp, #0]
    a1ae:	7a1b      	ldrb	r3, [r3, #8]
    a1b0:	2b00      	cmp	r3, #0
    a1b2:	d006      	beq.n	a1c2 <FlexCAN_InitRxFifo+0x22>
    {
        eResult = FlexCAN_EnableRxFifo(pBase, (uint32)Flexcan_Ip_pData->num_id_filters);
    a1b4:	9b00      	ldr	r3, [sp, #0]
    a1b6:	685b      	ldr	r3, [r3, #4]
    a1b8:	4619      	mov	r1, r3
    a1ba:	9801      	ldr	r0, [sp, #4]
    a1bc:	f002 fefe 	bl	cfbc <FlexCAN_EnableRxFifo>
    a1c0:	9003      	str	r0, [sp, #12]
        FlexCAN_SetRxFifoDMA(pBase, FALSE);
    }
    }
#endif /* FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */

    return eResult;
    a1c2:	9b03      	ldr	r3, [sp, #12]
}
    a1c4:	4618      	mov	r0, r3
    a1c6:	b005      	add	sp, #20
    a1c8:	f85d fb04 	ldr.w	pc, [sp], #4

0000a1cc <FlexCAN_InitCtroll>:
 * Description   : Initialize basically controller.
 *
 * This is not a public API as it is called from other driver functions.
 *END**************************************************************************/
static Flexcan_Ip_StatusType FlexCAN_InitCtroll(FLEXCAN_Type * pBase, const Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
    a1cc:	b500      	push	{lr}
    a1ce:	b085      	sub	sp, #20
    a1d0:	9001      	str	r0, [sp, #4]
    a1d2:	9100      	str	r1, [sp, #0]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    a1d4:	2300      	movs	r3, #0
    a1d6:	9303      	str	r3, [sp, #12]
    /* Disable the self reception feature if FlexCAN is not in loopback mode. */
    if (Flexcan_Ip_pData->flexcanMode != FLEXCAN_LOOPBACK_MODE)
    a1d8:	9b00      	ldr	r3, [sp, #0]
    a1da:	68db      	ldr	r3, [r3, #12]
    a1dc:	2b02      	cmp	r3, #2
    a1de:	d003      	beq.n	a1e8 <FlexCAN_InitCtroll+0x1c>
    {
        FlexCAN_SetSelfReception(pBase, FALSE);
    a1e0:	2100      	movs	r1, #0
    a1e2:	9801      	ldr	r0, [sp, #4]
    a1e4:	f7ff feec 	bl	9fc0 <FlexCAN_SetSelfReception>
    }

    /* Init legacy fifo, enhanced fifo if requested. */
    eResult = FlexCAN_InitRxFifo(pBase, Flexcan_Ip_pData);
    a1e8:	9900      	ldr	r1, [sp, #0]
    a1ea:	9801      	ldr	r0, [sp, #4]
    a1ec:	f7ff ffd8 	bl	a1a0 <FlexCAN_InitRxFifo>
    a1f0:	9003      	str	r0, [sp, #12]
    if (eResult != FLEXCAN_STATUS_SUCCESS)
    a1f2:	9b03      	ldr	r3, [sp, #12]
    a1f4:	2b00      	cmp	r3, #0
    a1f6:	d006      	beq.n	a206 <FlexCAN_InitCtroll+0x3a>
    {
        /* To enter Disable Mode requires FreezMode first */
        (void)FlexCAN_EnterFreezeMode(pBase);
    a1f8:	9801      	ldr	r0, [sp, #4]
    a1fa:	f002 fd03 	bl	cc04 <FlexCAN_EnterFreezeMode>
        (void)FlexCAN_Disable(pBase);
    a1fe:	9801      	ldr	r0, [sp, #4]
    a200:	f002 fdca 	bl	cd98 <FlexCAN_Disable>
    a204:	e00b      	b.n	a21e <FlexCAN_InitCtroll+0x52>
    }
    else
    {
    #if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        /* Set payload size. */
        FlexCAN_SetPayloadSize(pBase, &Flexcan_Ip_pData->payload);
    a206:	9b00      	ldr	r3, [sp, #0]
    a208:	3314      	adds	r3, #20
    a20a:	4619      	mov	r1, r3
    a20c:	9801      	ldr	r0, [sp, #4]
    a20e:	f002 ff3b 	bl	d088 <FlexCAN_SetPayloadSize>
            /* To enter Disable Mode requires FreezMode first */
            (void)FlexCAN_EnterFreezeMode(pBase);
            (void)FlexCAN_Disable(pBase);
        }
    #else
        (void)FlexCAN_SetMaxMsgBuffNum(pBase, Flexcan_Ip_pData->max_num_mb);
    a212:	9b00      	ldr	r3, [sp, #0]
    a214:	681b      	ldr	r3, [r3, #0]
    a216:	4619      	mov	r1, r3
    a218:	9801      	ldr	r0, [sp, #4]
    a21a:	f003 fab7 	bl	d78c <FlexCAN_SetMaxMsgBuffNum>
    #endif /* FLEXCAN_IP_DEV_ERROR_DETECT */
    }
    return eResult;
    a21e:	9b03      	ldr	r3, [sp, #12]
}
    a220:	4618      	mov	r0, r3
    a222:	b005      	add	sp, #20
    a224:	f85d fb04 	ldr.w	pc, [sp], #4

0000a228 <FlexCAN_InitController>:
 * Description   : Initialize basically controller.
 *
 * This is not a public API as it is called from other driver functions.
 *END**************************************************************************/
static Flexcan_Ip_StatusType FlexCAN_InitController(uint8 Instance, FLEXCAN_Type * pBase, const Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
    a228:	b500      	push	{lr}
    a22a:	b087      	sub	sp, #28
    a22c:	4603      	mov	r3, r0
    a22e:	9102      	str	r1, [sp, #8]
    a230:	9201      	str	r2, [sp, #4]
    a232:	f88d 300f 	strb.w	r3, [sp, #15]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    a236:	2300      	movs	r3, #0
    a238:	9305      	str	r3, [sp, #20]

    if (FlexCAN_IsEnabled(pBase))
    a23a:	9802      	ldr	r0, [sp, #8]
    a23c:	f7ff fd0c 	bl	9c58 <FlexCAN_IsEnabled>
    a240:	4603      	mov	r3, r0
    a242:	2b00      	cmp	r3, #0
    a244:	d00a      	beq.n	a25c <FlexCAN_InitController+0x34>
    {
        /* To enter Disable Mode requires FreezMode first */
        eResult = FlexCAN_EnterFreezeMode(pBase);
    a246:	9802      	ldr	r0, [sp, #8]
    a248:	f002 fcdc 	bl	cc04 <FlexCAN_EnterFreezeMode>
    a24c:	9005      	str	r0, [sp, #20]
        if (FLEXCAN_STATUS_SUCCESS == eResult)
    a24e:	9b05      	ldr	r3, [sp, #20]
    a250:	2b00      	cmp	r3, #0
    a252:	d103      	bne.n	a25c <FlexCAN_InitController+0x34>
        {
            eResult = FlexCAN_Disable(pBase);
    a254:	9802      	ldr	r0, [sp, #8]
    a256:	f002 fd9f 	bl	cd98 <FlexCAN_Disable>
    a25a:	9005      	str	r0, [sp, #20]
        }
    }

    if (FLEXCAN_STATUS_SUCCESS == eResult)
    a25c:	9b05      	ldr	r3, [sp, #20]
    a25e:	2b00      	cmp	r3, #0
    a260:	d137      	bne.n	a2d2 <FlexCAN_InitController+0xaa>
    {
    #if (FLEXCAN_IP_FEATURE_HAS_PE_CLKSRC_SELECT == STD_ON)
        /* Select a source clock for the FlexCAN engine */
        FlexCAN_SetClkSrc(pBase, Flexcan_Ip_pData->is_pe_clock);
    a262:	9b01      	ldr	r3, [sp, #4]
    a264:	7e5b      	ldrb	r3, [r3, #25]
    a266:	4619      	mov	r1, r3
    a268:	9802      	ldr	r0, [sp, #8]
    a26a:	f7ff fee9 	bl	a040 <FlexCAN_SetClkSrc>
    #endif
        /* Enable FlexCAN Module need to perform SoftReset & ClearRam */
        pBase->MCR &= ~FLEXCAN_MCR_MDIS_MASK;
    a26e:	9b02      	ldr	r3, [sp, #8]
    a270:	681b      	ldr	r3, [r3, #0]
    a272:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
    a276:	9b02      	ldr	r3, [sp, #8]
    a278:	601a      	str	r2, [r3, #0]
        /* Initialize FLEXCAN device */
        eResult = FlexCAN_Init(pBase);
    a27a:	9802      	ldr	r0, [sp, #8]
    a27c:	f002 fe28 	bl	ced0 <FlexCAN_Init>
    a280:	9005      	str	r0, [sp, #20]
        if (eResult != FLEXCAN_STATUS_SUCCESS)
    a282:	9b05      	ldr	r3, [sp, #20]
    a284:	2b00      	cmp	r3, #0
    a286:	d006      	beq.n	a296 <FlexCAN_InitController+0x6e>
        {
            /* To enter Disable Mode requires FreezMode first */
            (void)FlexCAN_EnterFreezeMode(pBase);
    a288:	9802      	ldr	r0, [sp, #8]
    a28a:	f002 fcbb 	bl	cc04 <FlexCAN_EnterFreezeMode>
            (void)FlexCAN_Disable(pBase);
    a28e:	9802      	ldr	r0, [sp, #8]
    a290:	f002 fd82 	bl	cd98 <FlexCAN_Disable>
    a294:	e01d      	b.n	a2d2 <FlexCAN_InitController+0xaa>
            /* Disable the Protection again because is enabled by soft reset */
            FlexCAN_DisableMemErrorDetection(pBase);
        #endif

        #if defined(CAN_FEATURE_S32K1XX)
            if (TRUE == FlexCAN_IsFDAvailable(pBase))
    a296:	9802      	ldr	r0, [sp, #8]
    a298:	f002 fed4 	bl	d044 <FlexCAN_IsFDAvailable>
    a29c:	4603      	mov	r3, r0
    a29e:	2b00      	cmp	r3, #0
    a2a0:	d007      	beq.n	a2b2 <FlexCAN_InitController+0x8a>
            {
        #endif /* defined(CAN_FEATURE_S32K1XX) */
                /* Enable/Disable FD and check FD was set as expected. Setting FD as enabled
                 * might fail if the current CAN instance does not support FD. */
                FlexCAN_SetFDEnabled(pBase, Flexcan_Ip_pData->fd_enable, Flexcan_Ip_pData->bitRateSwitch);
    a2a2:	9b01      	ldr	r3, [sp, #4]
    a2a4:	7e19      	ldrb	r1, [r3, #24]
    a2a6:	9b01      	ldr	r3, [sp, #4]
    a2a8:	7edb      	ldrb	r3, [r3, #27]
    a2aa:	461a      	mov	r2, r3
    a2ac:	9802      	ldr	r0, [sp, #8]
    a2ae:	f7ff fcdd 	bl	9c6c <FlexCAN_SetFDEnabled>
                }*/
        #if defined(CAN_FEATURE_S32K1XX)
            }
        #endif /* defined(CAN_FEATURE_S32K1XX) */
            /* configure depends on controller options. */
            FlexCAN_ConfigCtrlOptions(pBase, Flexcan_Ip_pData->ctrlOptions);
    a2b2:	9b01      	ldr	r3, [sp, #4]
    a2b4:	691b      	ldr	r3, [r3, #16]
    a2b6:	4619      	mov	r1, r3
    a2b8:	9802      	ldr	r0, [sp, #8]
    a2ba:	f003 fdeb 	bl	de94 <FlexCAN_ConfigCtrlOptions>
            /* reset Imask buffers */
            FlexCAN_ResetImaskBuff(Instance);
    a2be:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a2c2:	4618      	mov	r0, r3
    a2c4:	f003 fe56 	bl	df74 <FlexCAN_ResetImaskBuff>
            eResult = FlexCAN_InitCtroll(pBase, Flexcan_Ip_pData);
    a2c8:	9901      	ldr	r1, [sp, #4]
    a2ca:	9802      	ldr	r0, [sp, #8]
    a2cc:	f7ff ff7e 	bl	a1cc <FlexCAN_InitCtroll>
    a2d0:	9005      	str	r0, [sp, #20]
        }
    }
    return eResult;
    a2d2:	9b05      	ldr	r3, [sp, #20]
}
    a2d4:	4618      	mov	r0, r3
    a2d6:	b007      	add	sp, #28
    a2d8:	f85d fb04 	ldr.w	pc, [sp], #4

0000a2dc <FlexCAN_InitBaudrate>:
 * Description   : Init baudrate for given controller.
 * This is not a public API as it is called from other driver functions.
 *
 *END**************************************************************************/
static void FlexCAN_InitBaudrate(FLEXCAN_Type * pBase, const Flexcan_Ip_ConfigType * Flexcan_Ip_pData)
{
    a2dc:	b500      	push	{lr}
    a2de:	b083      	sub	sp, #12
    a2e0:	9001      	str	r0, [sp, #4]
    a2e2:	9100      	str	r1, [sp, #0]
    /* Enable the use of extended bit time definitions */
    FlexCAN_EnableExtCbt(pBase, Flexcan_Ip_pData->fd_enable);
    a2e4:	9b00      	ldr	r3, [sp, #0]
    a2e6:	7e1b      	ldrb	r3, [r3, #24]
    a2e8:	4619      	mov	r1, r3
    a2ea:	9801      	ldr	r0, [sp, #4]
    a2ec:	f7ff fe51 	bl	9f92 <FlexCAN_EnableExtCbt>
        /* Disable Enhanced CBT time segments */
        pBase->CTRL2 &= ~FLEXCAN_CTRL2_BTE_MASK;
#endif
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        /* Set bit rate. */
        if (Flexcan_Ip_pData->fd_enable)
    a2f0:	9b00      	ldr	r3, [sp, #0]
    a2f2:	7e1b      	ldrb	r3, [r3, #24]
    a2f4:	2b00      	cmp	r3, #0
    a2f6:	d00c      	beq.n	a312 <FlexCAN_InitBaudrate+0x36>
        {
            /* Write Normal bit time configuration to CBT register */
            FlexCAN_SetExtendedTimeSegments(pBase, &Flexcan_Ip_pData->bitrate);
    a2f8:	9b00      	ldr	r3, [sp, #0]
    a2fa:	331c      	adds	r3, #28
    a2fc:	4619      	mov	r1, r3
    a2fe:	9801      	ldr	r0, [sp, #4]
    a300:	f7ff fd94 	bl	9e2c <FlexCAN_SetExtendedTimeSegments>
            /* Write Data bit time configuration to FDCBT register */
            FlexCAN_SetFDTimeSegments(pBase, &Flexcan_Ip_pData->bitrate_cbt);
    a304:	9b00      	ldr	r3, [sp, #0]
    a306:	3330      	adds	r3, #48	; 0x30
    a308:	4619      	mov	r1, r3
    a30a:	9801      	ldr	r0, [sp, #4]
    a30c:	f7ff fd2d 	bl	9d6a <FlexCAN_SetFDTimeSegments>
            /* Write Normal bit time configuration to CTRL1 register */
            FlexCAN_SetTimeSegments(pBase, &Flexcan_Ip_pData->bitrate);
        }
#endif
    }
}
    a310:	e005      	b.n	a31e <FlexCAN_InitBaudrate+0x42>
            FlexCAN_SetTimeSegments(pBase, &Flexcan_Ip_pData->bitrate);
    a312:	9b00      	ldr	r3, [sp, #0]
    a314:	331c      	adds	r3, #28
    a316:	4619      	mov	r1, r3
    a318:	9801      	ldr	r0, [sp, #4]
    a31a:	f7ff fd5b 	bl	9dd4 <FlexCAN_SetTimeSegments>
}
    a31e:	bf00      	nop
    a320:	b003      	add	sp, #12
    a322:	f85d fb04 	ldr.w	pc, [sp], #4

0000a326 <FlexCAN_ProccessLegacyRxFIFO>:
 * Description   : This function will process the enhanced RxFIFO in blocking mode.
 * This is not a public API as it is called from other driver functions.
 *
 *END**************************************************************************/
static Flexcan_Ip_StatusType FlexCAN_ProccessLegacyRxFIFO(uint8 u8Instance, uint32 u32TimeoutMs)
{
    a326:	b500      	push	{lr}
    a328:	b08d      	sub	sp, #52	; 0x34
    a32a:	4603      	mov	r3, r0
    a32c:	9102      	str	r1, [sp, #8]
    a32e:	f88d 300f 	strb.w	r3, [sp, #15]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    a332:	2300      	movs	r3, #0
    a334:	930b      	str	r3, [sp, #44]	; 0x2c
    Flexcan_Ip_StateType * pState = Flexcan_Ip_apxState[u8Instance];
    a336:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a33a:	4a46      	ldr	r2, [pc, #280]	; (a454 <FlexCAN_ProccessLegacyRxFIFO+0x12e>)
    a33c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a340:	9308      	str	r3, [sp, #32]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    a342:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a346:	4a44      	ldr	r2, [pc, #272]	; (a458 <FlexCAN_ProccessLegacyRxFIFO+0x132>)
    a348:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a34c:	9307      	str	r3, [sp, #28]
    uint32 timeStart = 0U;
    a34e:	2300      	movs	r3, #0
    a350:	9305      	str	r3, [sp, #20]
    uint32 timeElapsed = 0U;
    a352:	2300      	movs	r3, #0
    a354:	930a      	str	r3, [sp, #40]	; 0x28
    uint32 mS2Ticks = OsIf_MicrosToTicks((u32TimeoutMs * 1000U), FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    a356:	9b02      	ldr	r3, [sp, #8]
    a358:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    a35c:	fb02 f303 	mul.w	r3, r2, r3
    a360:	2100      	movs	r1, #0
    a362:	4618      	mov	r0, r3
    a364:	f7f7 fd66 	bl	1e34 <OsIf_MicrosToTicks>
    a368:	9006      	str	r0, [sp, #24]
    uint32 u32intType = 0U;
    a36a:	2300      	movs	r3, #0
    a36c:	9309      	str	r3, [sp, #36]	; 0x24

        timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    a36e:	2000      	movs	r0, #0
    a370:	f7f7 fd14 	bl	1d9c <OsIf_GetCounter>
    a374:	4603      	mov	r3, r0
    a376:	9305      	str	r3, [sp, #20]

        while (FLEXCAN_MB_RX_BUSY == pState->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state)
    a378:	e02a      	b.n	a3d0 <FlexCAN_ProccessLegacyRxFIFO+0xaa>
        {
            if (FLEXCAN_RXFIFO_USING_POLLING == pState->transferType)
    a37a:	9b08      	ldr	r3, [sp, #32]
    a37c:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
    a380:	2b01      	cmp	r3, #1
    a382:	d115      	bne.n	a3b0 <FlexCAN_ProccessLegacyRxFIFO+0x8a>
            {
                for (u32intType = FLEXCAN_IP_LEGACY_RXFIFO_OVERFLOW; \
    a384:	2307      	movs	r3, #7
    a386:	9309      	str	r3, [sp, #36]	; 0x24
    a388:	e00f      	b.n	a3aa <FlexCAN_ProccessLegacyRxFIFO+0x84>
                     u32intType >= FLEXCAN_IP_LEGACY_RXFIFO_FRAME_AVAILABLE; \
                     u32intType--)
                {
                    if (FlexCAN_GetBuffStatusFlag(pBase, u32intType) != 0U)
    a38a:	9909      	ldr	r1, [sp, #36]	; 0x24
    a38c:	9807      	ldr	r0, [sp, #28]
    a38e:	f7ff fcd0 	bl	9d32 <FlexCAN_GetBuffStatusFlag>
    a392:	4603      	mov	r3, r0
    a394:	2b00      	cmp	r3, #0
    a396:	d005      	beq.n	a3a4 <FlexCAN_ProccessLegacyRxFIFO+0x7e>
                    {
                        FlexCAN_IRQHandlerRxFIFO(u8Instance, u32intType);
    a398:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a39c:	9909      	ldr	r1, [sp, #36]	; 0x24
    a39e:	4618      	mov	r0, r3
    a3a0:	f000 fb06 	bl	a9b0 <FlexCAN_IRQHandlerRxFIFO>
                     u32intType--)
    a3a4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a3a6:	3b01      	subs	r3, #1
    a3a8:	9309      	str	r3, [sp, #36]	; 0x24
                for (u32intType = FLEXCAN_IP_LEGACY_RXFIFO_OVERFLOW; \
    a3aa:	9b09      	ldr	r3, [sp, #36]	; 0x24
    a3ac:	2b04      	cmp	r3, #4
    a3ae:	d8ec      	bhi.n	a38a <FlexCAN_ProccessLegacyRxFIFO+0x64>
                    }
                }
            }

            timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    a3b0:	ab05      	add	r3, sp, #20
    a3b2:	2100      	movs	r1, #0
    a3b4:	4618      	mov	r0, r3
    a3b6:	f7f7 fd0a 	bl	1dce <OsIf_GetElapsed>
    a3ba:	4602      	mov	r2, r0
    a3bc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    a3be:	4413      	add	r3, r2
    a3c0:	930a      	str	r3, [sp, #40]	; 0x28
            if (timeElapsed >= mS2Ticks)
    a3c2:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    a3c4:	9b06      	ldr	r3, [sp, #24]
    a3c6:	429a      	cmp	r2, r3
    a3c8:	d302      	bcc.n	a3d0 <FlexCAN_ProccessLegacyRxFIFO+0xaa>
            {
                eResult = FLEXCAN_STATUS_TIMEOUT;
    a3ca:	2303      	movs	r3, #3
    a3cc:	930b      	str	r3, [sp, #44]	; 0x2c
                break;
    a3ce:	e003      	b.n	a3d8 <FlexCAN_ProccessLegacyRxFIFO+0xb2>
        while (FLEXCAN_MB_RX_BUSY == pState->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state)
    a3d0:	9b08      	ldr	r3, [sp, #32]
    a3d2:	685b      	ldr	r3, [r3, #4]
    a3d4:	2b01      	cmp	r3, #1
    a3d6:	d0d0      	beq.n	a37a <FlexCAN_ProccessLegacyRxFIFO+0x54>
            }
        }

        if ((FLEXCAN_STATUS_TIMEOUT == eResult) && (FLEXCAN_RXFIFO_USING_POLLING != pState->transferType))
    a3d8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    a3da:	2b03      	cmp	r3, #3
    a3dc:	d125      	bne.n	a42a <FlexCAN_ProccessLegacyRxFIFO+0x104>
    a3de:	9b08      	ldr	r3, [sp, #32]
    a3e0:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
    a3e4:	2b01      	cmp	r3, #1
    a3e6:	d020      	beq.n	a42a <FlexCAN_ProccessLegacyRxFIFO+0x104>
        {
            /* Disable RX FIFO interrupts*/
            (void)FlexCAN_SetMsgBuffIntCmd(pBase, u8Instance, FLEXCAN_IP_LEGACY_RXFIFO_FRAME_AVAILABLE, FALSE, pState->isIntActive);
    a3e8:	9b08      	ldr	r3, [sp, #32]
    a3ea:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    a3ee:	f89d 100f 	ldrb.w	r1, [sp, #15]
    a3f2:	9300      	str	r3, [sp, #0]
    a3f4:	2300      	movs	r3, #0
    a3f6:	2205      	movs	r2, #5
    a3f8:	9807      	ldr	r0, [sp, #28]
    a3fa:	f002 feef 	bl	d1dc <FlexCAN_SetMsgBuffIntCmd>
            (void)FlexCAN_SetMsgBuffIntCmd(pBase, u8Instance, FLEXCAN_IP_LEGACY_RXFIFO_WARNING, FALSE, pState->isIntActive);
    a3fe:	9b08      	ldr	r3, [sp, #32]
    a400:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    a404:	f89d 100f 	ldrb.w	r1, [sp, #15]
    a408:	9300      	str	r3, [sp, #0]
    a40a:	2300      	movs	r3, #0
    a40c:	2206      	movs	r2, #6
    a40e:	9807      	ldr	r0, [sp, #28]
    a410:	f002 fee4 	bl	d1dc <FlexCAN_SetMsgBuffIntCmd>
            (void)FlexCAN_SetMsgBuffIntCmd(pBase, u8Instance, FLEXCAN_IP_LEGACY_RXFIFO_OVERFLOW, FALSE, pState->isIntActive);
    a414:	9b08      	ldr	r3, [sp, #32]
    a416:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    a41a:	f89d 100f 	ldrb.w	r1, [sp, #15]
    a41e:	9300      	str	r3, [sp, #0]
    a420:	2300      	movs	r3, #0
    a422:	2207      	movs	r2, #7
    a424:	9807      	ldr	r0, [sp, #28]
    a426:	f002 fed9 	bl	d1dc <FlexCAN_SetMsgBuffIntCmd>
                (void)Dma_Ip_SetLogicChannelCommand(pState->rxFifoDMAChannel, DMA_IP_CH_CLEAR_HARDWARE_REQUEST);
            }
#endif
        }

        switch (pState->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state)
    a42a:	9b08      	ldr	r3, [sp, #32]
    a42c:	685b      	ldr	r3, [r3, #4]
    a42e:	2b00      	cmp	r3, #0
    a430:	d005      	beq.n	a43e <FlexCAN_ProccessLegacyRxFIFO+0x118>
    a432:	2b01      	cmp	r3, #1
    a434:	d106      	bne.n	a444 <FlexCAN_ProccessLegacyRxFIFO+0x11e>
        {
            case FLEXCAN_MB_RX_BUSY:
                pState->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state = FLEXCAN_MB_IDLE;
    a436:	9b08      	ldr	r3, [sp, #32]
    a438:	2200      	movs	r2, #0
    a43a:	605a      	str	r2, [r3, #4]
                break;
    a43c:	e005      	b.n	a44a <FlexCAN_ProccessLegacyRxFIFO+0x124>
            case FLEXCAN_MB_IDLE:
                eResult = FLEXCAN_STATUS_SUCCESS;
    a43e:	2300      	movs	r3, #0
    a440:	930b      	str	r3, [sp, #44]	; 0x2c
                break;
    a442:	e002      	b.n	a44a <FlexCAN_ProccessLegacyRxFIFO+0x124>
            case FLEXCAN_MB_DMA_ERROR:
                eResult = FLEXCAN_STATUS_ERROR;
                break;
#endif /* if FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */
            default:
                eResult = FLEXCAN_STATUS_ERROR;
    a444:	2301      	movs	r3, #1
    a446:	930b      	str	r3, [sp, #44]	; 0x2c
                break;
    a448:	bf00      	nop
        }

    return eResult;
    a44a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
}
    a44c:	4618      	mov	r0, r3
    a44e:	b00d      	add	sp, #52	; 0x34
    a450:	f85d fb04 	ldr.w	pc, [sp], #4
    a454:	1fff9048 	.word	0x1fff9048
    a458:	00015be8 	.word	0x00015be8

0000a45c <FlexCAN_StartRxMessageBufferData>:
static Flexcan_Ip_StatusType FlexCAN_StartRxMessageBufferData(uint8 instance,
                                                              uint8 mb_idx,
                                                              Flexcan_Ip_MsgBuffType * data,
                                                              boolean isPolling
                                                             )
{
    a45c:	b084      	sub	sp, #16
    a45e:	9200      	str	r2, [sp, #0]
    a460:	461a      	mov	r2, r3
    a462:	4603      	mov	r3, r0
    a464:	f88d 3007 	strb.w	r3, [sp, #7]
    a468:	460b      	mov	r3, r1
    a46a:	f88d 3006 	strb.w	r3, [sp, #6]
    a46e:	4613      	mov	r3, r2
    a470:	f88d 3005 	strb.w	r3, [sp, #5]

    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    a474:	2300      	movs	r3, #0
    a476:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
#endif
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    a478:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a47c:	4a15      	ldr	r2, [pc, #84]	; (a4d4 <FlexCAN_StartRxMessageBufferData+0x78>)
    a47e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a482:	9302      	str	r3, [sp, #8]
    }
    else
    {
#endif
        /* Start receiving mailbox */
        if (state->mbs[mb_idx].state != FLEXCAN_MB_IDLE)
    a484:	f89d 3006 	ldrb.w	r3, [sp, #6]
    a488:	9a02      	ldr	r2, [sp, #8]
    a48a:	011b      	lsls	r3, r3, #4
    a48c:	4413      	add	r3, r2
    a48e:	3304      	adds	r3, #4
    a490:	681b      	ldr	r3, [r3, #0]
    a492:	2b00      	cmp	r3, #0
    a494:	d002      	beq.n	a49c <FlexCAN_StartRxMessageBufferData+0x40>
        {
            result = FLEXCAN_STATUS_BUSY;
    a496:	2302      	movs	r3, #2
    a498:	9303      	str	r3, [sp, #12]
    a49a:	e017      	b.n	a4cc <FlexCAN_StartRxMessageBufferData+0x70>
        }
        else
        {
            state->mbs[mb_idx].state = FLEXCAN_MB_RX_BUSY;
    a49c:	f89d 3006 	ldrb.w	r3, [sp, #6]
    a4a0:	9a02      	ldr	r2, [sp, #8]
    a4a2:	011b      	lsls	r3, r3, #4
    a4a4:	4413      	add	r3, r2
    a4a6:	3304      	adds	r3, #4
    a4a8:	2201      	movs	r2, #1
    a4aa:	601a      	str	r2, [r3, #0]
            state->mbs[mb_idx].pMBmessage = data;
    a4ac:	f89d 3006 	ldrb.w	r3, [sp, #6]
    a4b0:	9a02      	ldr	r2, [sp, #8]
    a4b2:	011b      	lsls	r3, r3, #4
    a4b4:	4413      	add	r3, r2
    a4b6:	9a00      	ldr	r2, [sp, #0]
    a4b8:	601a      	str	r2, [r3, #0]
            state->mbs[mb_idx].isPolling = isPolling;
    a4ba:	f89d 3006 	ldrb.w	r3, [sp, #6]
    a4be:	9a02      	ldr	r2, [sp, #8]
    a4c0:	011b      	lsls	r3, r3, #4
    a4c2:	4413      	add	r3, r2
    a4c4:	3308      	adds	r3, #8
    a4c6:	f89d 2005 	ldrb.w	r2, [sp, #5]
    a4ca:	701a      	strb	r2, [r3, #0]
        }
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    }
#endif
    return result;
    a4cc:	9b03      	ldr	r3, [sp, #12]
}
    a4ce:	4618      	mov	r0, r3
    a4d0:	b004      	add	sp, #16
    a4d2:	4770      	bx	lr
    a4d4:	1fff9048 	.word	0x1fff9048

0000a4d8 <FlexCAN_StartSendData>:
                                                   uint8 mb_idx,
                                                   const Flexcan_Ip_DataInfoType * tx_info,
                                                   uint32 msg_id,
                                                   const uint8 * mb_data
                                                  )
{
    a4d8:	b500      	push	{lr}
    a4da:	b08f      	sub	sp, #60	; 0x3c
    a4dc:	9204      	str	r2, [sp, #16]
    a4de:	9303      	str	r3, [sp, #12]
    a4e0:	4603      	mov	r3, r0
    a4e2:	f88d 3017 	strb.w	r3, [sp, #23]
    a4e6:	460b      	mov	r3, r1
    a4e8:	f88d 3016 	strb.w	r3, [sp, #22]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    a4ec:	2300      	movs	r3, #0
    a4ee:	930d      	str	r3, [sp, #52]	; 0x34
    Flexcan_Ip_MsbuffCodeStatusType cs;
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[Flexcan_Ip_u8Instance];
    a4f0:	f89d 3017 	ldrb.w	r3, [sp, #23]
    a4f4:	4a38      	ldr	r2, [pc, #224]	; (a5d8 <FlexCAN_StartSendData+0x100>)
    a4f6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a4fa:	930c      	str	r3, [sp, #48]	; 0x30
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[Flexcan_Ip_u8Instance];
    a4fc:	f89d 3017 	ldrb.w	r3, [sp, #23]
    a500:	4a36      	ldr	r2, [pc, #216]	; (a5dc <FlexCAN_StartSendData+0x104>)
    a502:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a506:	930b      	str	r3, [sp, #44]	; 0x2c
    volatile uint32 * pMbAddr = NULL_PTR;
    a508:	2300      	movs	r3, #0
    a50a:	930a      	str	r3, [sp, #40]	; 0x28
        eResult = FLEXCAN_STATUS_BUFF_OUT_OF_RANGE;
    }
    else
    {
#endif
        if (state->mbs[mb_idx].state != FLEXCAN_MB_IDLE)
    a50c:	f89d 3016 	ldrb.w	r3, [sp, #22]
    a510:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    a512:	011b      	lsls	r3, r3, #4
    a514:	4413      	add	r3, r2
    a516:	3304      	adds	r3, #4
    a518:	681b      	ldr	r3, [r3, #0]
    a51a:	2b00      	cmp	r3, #0
    a51c:	d002      	beq.n	a524 <FlexCAN_StartSendData+0x4c>
        {
            eResult = FLEXCAN_STATUS_BUSY;
    a51e:	2302      	movs	r3, #2
    a520:	930d      	str	r3, [sp, #52]	; 0x34
    a522:	e053      	b.n	a5cc <FlexCAN_StartSendData+0xf4>
        }
        else
        {
            /* Clear message buffer flag */
            FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    a524:	f89d 3016 	ldrb.w	r3, [sp, #22]
    a528:	4619      	mov	r1, r3
    a52a:	980b      	ldr	r0, [sp, #44]	; 0x2c
    a52c:	f7ff fbee 	bl	9d0c <FlexCAN_ClearMsgBuffIntStatusFlag>

            state->mbs[mb_idx].state = FLEXCAN_MB_TX_BUSY;
    a530:	f89d 3016 	ldrb.w	r3, [sp, #22]
    a534:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    a536:	011b      	lsls	r3, r3, #4
    a538:	4413      	add	r3, r2
    a53a:	3304      	adds	r3, #4
    a53c:	2202      	movs	r2, #2
    a53e:	601a      	str	r2, [r3, #0]
            state->mbs[mb_idx].time_stamp = 0U;
    a540:	f89d 3016 	ldrb.w	r3, [sp, #22]
    a544:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    a546:	011b      	lsls	r3, r3, #4
    a548:	4413      	add	r3, r2
    a54a:	330c      	adds	r3, #12
    a54c:	2200      	movs	r2, #0
    a54e:	601a      	str	r2, [r3, #0]
            state->mbs[mb_idx].isPolling = tx_info->is_polling;
    a550:	f89d 3016 	ldrb.w	r3, [sp, #22]
    a554:	9a04      	ldr	r2, [sp, #16]
    a556:	7b11      	ldrb	r1, [r2, #12]
    a558:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    a55a:	011b      	lsls	r3, r3, #4
    a55c:	4413      	add	r3, r2
    a55e:	3308      	adds	r3, #8
    a560:	460a      	mov	r2, r1
    a562:	701a      	strb	r2, [r3, #0]
            state->mbs[mb_idx].isRemote = tx_info->is_remote;
    a564:	f89d 3016 	ldrb.w	r3, [sp, #22]
    a568:	9a04      	ldr	r2, [sp, #16]
    a56a:	7ad1      	ldrb	r1, [r2, #11]
    a56c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    a56e:	011b      	lsls	r3, r3, #4
    a570:	4413      	add	r3, r2
    a572:	3309      	adds	r3, #9
    a574:	460a      	mov	r2, r1
    a576:	701a      	strb	r2, [r3, #0]

            cs.dataLen = tx_info->data_length;
    a578:	9b04      	ldr	r3, [sp, #16]
    a57a:	685b      	ldr	r3, [r3, #4]
    a57c:	9308      	str	r3, [sp, #32]

            cs.msgIdType = tx_info->msg_id_type;
    a57e:	9b04      	ldr	r3, [sp, #16]
    a580:	681b      	ldr	r3, [r3, #0]
    a582:	9307      	str	r3, [sp, #28]

        #if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
            cs.fd_enable = tx_info->fd_enable;
    a584:	9b04      	ldr	r3, [sp, #16]
    a586:	7a1b      	ldrb	r3, [r3, #8]
    a588:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
            cs.fd_padding = tx_info->fd_padding;
    a58c:	9b04      	ldr	r3, [sp, #16]
    a58e:	7a5b      	ldrb	r3, [r3, #9]
    a590:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
            cs.enable_brs = tx_info->enable_brs;
    a594:	9b04      	ldr	r3, [sp, #16]
    a596:	7a9b      	ldrb	r3, [r3, #10]
    a598:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
        #endif

            if (tx_info->is_remote)
    a59c:	9b04      	ldr	r3, [sp, #16]
    a59e:	7adb      	ldrb	r3, [r3, #11]
    a5a0:	2b00      	cmp	r3, #0
    a5a2:	d002      	beq.n	a5aa <FlexCAN_StartSendData+0xd2>
            {
                cs.code = (uint32)FLEXCAN_TX_REMOTE;
    a5a4:	231c      	movs	r3, #28
    a5a6:	9306      	str	r3, [sp, #24]
    a5a8:	e001      	b.n	a5ae <FlexCAN_StartSendData+0xd6>
            }
            else
            {
                cs.code = (uint32)FLEXCAN_TX_DATA;
    a5aa:	230c      	movs	r3, #12
    a5ac:	9306      	str	r3, [sp, #24]
            }
            pMbAddr = FlexCAN_GetMsgBuffRegion(base, mb_idx);
    a5ae:	f89d 3016 	ldrb.w	r3, [sp, #22]
    a5b2:	4619      	mov	r1, r3
    a5b4:	980b      	ldr	r0, [sp, #44]	; 0x2c
    a5b6:	f002 fa89 	bl	cacc <FlexCAN_GetMsgBuffRegion>
    a5ba:	900a      	str	r0, [sp, #40]	; 0x28
            FlexCAN_SetTxMsgBuff(pMbAddr, &cs, msg_id, mb_data, FALSE);
    a5bc:	a906      	add	r1, sp, #24
    a5be:	2300      	movs	r3, #0
    a5c0:	9300      	str	r3, [sp, #0]
    a5c2:	9b10      	ldr	r3, [sp, #64]	; 0x40
    a5c4:	9a03      	ldr	r2, [sp, #12]
    a5c6:	980a      	ldr	r0, [sp, #40]	; 0x28
    a5c8:	f002 ffd2 	bl	d570 <FlexCAN_SetTxMsgBuff>
        }
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    }
#endif
    return eResult;
    a5cc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
}
    a5ce:	4618      	mov	r0, r3
    a5d0:	b00f      	add	sp, #60	; 0x3c
    a5d2:	f85d fb04 	ldr.w	pc, [sp], #4
    a5d6:	bf00      	nop
    a5d8:	1fff9048 	.word	0x1fff9048
    a5dc:	00015be8 	.word	0x00015be8

0000a5e0 <FlexCAN_StartRxMessageFifoData>:
 * receiving data and enabling the interrupt.
 * This is not a public API as it is called from other driver functions.
 *
 *END**************************************************************************/
static Flexcan_Ip_StatusType FlexCAN_StartRxMessageFifoData(uint8 instance, Flexcan_Ip_MsgBuffType * data)
{
    a5e0:	b500      	push	{lr}
    a5e2:	b089      	sub	sp, #36	; 0x24
    a5e4:	4603      	mov	r3, r0
    a5e6:	9102      	str	r1, [sp, #8]
    a5e8:	f88d 300f 	strb.w	r3, [sp, #15]

    FLEXCAN_Type * base = NULL_PTR;
    a5ec:	2300      	movs	r3, #0
    a5ee:	9306      	str	r3, [sp, #24]
    Flexcan_Ip_StateType * state = NULL_PTR;
    a5f0:	2300      	movs	r3, #0
    a5f2:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    a5f4:	2300      	movs	r3, #0
    a5f6:	9307      	str	r3, [sp, #28]

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    base = Flexcan_Ip_apxBase[instance];
    a5f8:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a5fc:	4a26      	ldr	r2, [pc, #152]	; (a698 <FlexCAN_StartRxMessageFifoData+0xb8>)
    a5fe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a602:	9306      	str	r3, [sp, #24]
    state = Flexcan_Ip_apxState[instance];
    a604:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a608:	4a24      	ldr	r2, [pc, #144]	; (a69c <FlexCAN_StartRxMessageFifoData+0xbc>)
    a60a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a60e:	9305      	str	r3, [sp, #20]
    #endif
    }
#endif /* FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */

    /* Start receiving fifo */
    if (state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state == FLEXCAN_MB_RX_BUSY)
    a610:	9b05      	ldr	r3, [sp, #20]
    a612:	685b      	ldr	r3, [r3, #4]
    a614:	2b01      	cmp	r3, #1
    a616:	d102      	bne.n	a61e <FlexCAN_StartRxMessageFifoData+0x3e>
    {
        eResult = FLEXCAN_STATUS_BUSY;
    a618:	2302      	movs	r3, #2
    a61a:	9307      	str	r3, [sp, #28]
    a61c:	e036      	b.n	a68c <FlexCAN_StartRxMessageFifoData+0xac>
    }
    else
    {
    state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state = FLEXCAN_MB_RX_BUSY;
    a61e:	9b05      	ldr	r3, [sp, #20]
    a620:	2201      	movs	r2, #1
    a622:	605a      	str	r2, [r3, #4]
    if (FLEXCAN_RXFIFO_USING_POLLING == state->transferType)
    a624:	9b05      	ldr	r3, [sp, #20]
    a626:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
    a62a:	2b01      	cmp	r3, #1
    a62c:	d102      	bne.n	a634 <FlexCAN_StartRxMessageFifoData+0x54>
    {
        state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].isPolling = TRUE;
    a62e:	9b05      	ldr	r3, [sp, #20]
    a630:	2201      	movs	r2, #1
    a632:	721a      	strb	r2, [r3, #8]
    }

    /* This will get filled by the interrupt handler */
    state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].pMBmessage = data;
    a634:	9b05      	ldr	r3, [sp, #20]
    a636:	9a02      	ldr	r2, [sp, #8]
    a638:	601a      	str	r2, [r3, #0]

    if (FLEXCAN_RXFIFO_USING_INTERRUPTS == state->transferType)
    a63a:	9b05      	ldr	r3, [sp, #20]
    a63c:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
    a640:	2b00      	cmp	r3, #0
    a642:	d123      	bne.n	a68c <FlexCAN_StartRxMessageFifoData+0xac>
    {
        state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].isPolling = FALSE;
    a644:	9b05      	ldr	r3, [sp, #20]
    a646:	2200      	movs	r2, #0
    a648:	721a      	strb	r2, [r3, #8]
        /* Enable RX FIFO interrupts*/
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, FLEXCAN_IP_LEGACY_RXFIFO_WARNING, TRUE, state->isIntActive);
    a64a:	9b05      	ldr	r3, [sp, #20]
    a64c:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    a650:	f89d 100f 	ldrb.w	r1, [sp, #15]
    a654:	9300      	str	r3, [sp, #0]
    a656:	2301      	movs	r3, #1
    a658:	2206      	movs	r2, #6
    a65a:	9806      	ldr	r0, [sp, #24]
    a65c:	f002 fdbe 	bl	d1dc <FlexCAN_SetMsgBuffIntCmd>
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, FLEXCAN_IP_LEGACY_RXFIFO_OVERFLOW, TRUE, state->isIntActive);
    a660:	9b05      	ldr	r3, [sp, #20]
    a662:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    a666:	f89d 100f 	ldrb.w	r1, [sp, #15]
    a66a:	9300      	str	r3, [sp, #0]
    a66c:	2301      	movs	r3, #1
    a66e:	2207      	movs	r2, #7
    a670:	9806      	ldr	r0, [sp, #24]
    a672:	f002 fdb3 	bl	d1dc <FlexCAN_SetMsgBuffIntCmd>
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, FLEXCAN_IP_LEGACY_RXFIFO_FRAME_AVAILABLE, TRUE, state->isIntActive);
    a676:	9b05      	ldr	r3, [sp, #20]
    a678:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    a67c:	f89d 100f 	ldrb.w	r1, [sp, #15]
    a680:	9300      	str	r3, [sp, #0]
    a682:	2301      	movs	r3, #1
    a684:	2205      	movs	r2, #5
    a686:	9806      	ldr	r0, [sp, #24]
    a688:	f002 fda8 	bl	d1dc <FlexCAN_SetMsgBuffIntCmd>
#endif /* if FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */
    }
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    }
#endif
    return eResult;
    a68c:	9b07      	ldr	r3, [sp, #28]
}
    a68e:	4618      	mov	r0, r3
    a690:	b009      	add	sp, #36	; 0x24
    a692:	f85d fb04 	ldr.w	pc, [sp], #4
    a696:	bf00      	nop
    a698:	00015be8 	.word	0x00015be8
    a69c:	1fff9048 	.word	0x1fff9048

0000a6a0 <FlexCAN_IRQHandlerRxMB>:
 *
 * This is not a public API as it is called whenever an interrupt and receive
 * individual MB occurs
 *END**************************************************************************/
static void FlexCAN_IRQHandlerRxMB(uint8 instance, uint32 mb_idx)
{
    a6a0:	b510      	push	{r4, lr}
    a6a2:	b09e      	sub	sp, #120	; 0x78
    a6a4:	4603      	mov	r3, r0
    a6a6:	9102      	str	r1, [sp, #8]
    a6a8:	f88d 300f 	strb.w	r3, [sp, #15]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    a6ac:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a6b0:	4a70      	ldr	r2, [pc, #448]	; (a874 <FlexCAN_IRQHandlerRxMB+0x1d4>)
    a6b2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a6b6:	931c      	str	r3, [sp, #112]	; 0x70
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    a6b8:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a6bc:	4a6e      	ldr	r2, [pc, #440]	; (a878 <FlexCAN_IRQHandlerRxMB+0x1d8>)
    a6be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a6c2:	931b      	str	r3, [sp, #108]	; 0x6c
    Flexcan_Ip_MsgBuffType data;
    boolean bCurrentIntStat = FALSE;
    a6c4:	2300      	movs	r3, #0
    a6c6:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b

    /* If use pass NULL_PTR, they can get data in callback function by getting state->mbs[mb_idx].pMBmessage  */
    if (NULL_PTR == state->mbs[mb_idx].pMBmessage)
    a6ca:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    a6cc:	9b02      	ldr	r3, [sp, #8]
    a6ce:	011b      	lsls	r3, r3, #4
    a6d0:	4413      	add	r3, r2
    a6d2:	681b      	ldr	r3, [r3, #0]
    a6d4:	2b00      	cmp	r3, #0
    a6d6:	d105      	bne.n	a6e4 <FlexCAN_IRQHandlerRxMB+0x44>
    {
        state->mbs[mb_idx].pMBmessage = &data;
    a6d8:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    a6da:	9b02      	ldr	r3, [sp, #8]
    a6dc:	011b      	lsls	r3, r3, #4
    a6de:	4413      	add	r3, r2
    a6e0:	aa05      	add	r2, sp, #20
    a6e2:	601a      	str	r2, [r3, #0]
    }

#if (defined (ERR_IPV_FLEXCAN_E050246) || defined (ERR_IPV_FLEXCAN_E050630))
    boolean bIsCriticalSectionNeeded = FALSE;
    a6e4:	2300      	movs	r3, #0
    a6e6:	f88d 3077 	strb.w	r3, [sp, #119]	; 0x77

    /* Expectation: the sequence will not be interrupted when it already in interupt context */
    if (TRUE == state->mbs[mb_idx].isPolling)
    a6ea:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    a6ec:	9b02      	ldr	r3, [sp, #8]
    a6ee:	011b      	lsls	r3, r3, #4
    a6f0:	4413      	add	r3, r2
    a6f2:	3308      	adds	r3, #8
    a6f4:	781b      	ldrb	r3, [r3, #0]
    a6f6:	2b00      	cmp	r3, #0
    a6f8:	d008      	beq.n	a70c <FlexCAN_IRQHandlerRxMB+0x6c>
        if ((state->bIsLegacyFifoEn ||  state->bIsEnhancedFifoEn) && (0U != (base->CTRL2 & FLEXCAN_CTRL2_TSTAMPCAP_MASK)))
        #else
        if ((state->bIsLegacyFifoEn) && (0U != (base->CTRL2 & FLEXCAN_CTRL2_TSTAMPCAP_MASK)))
        #endif /* (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) */
    #elif defined (ERR_IPV_FLEXCAN_E050246)
        if (state->bIsLegacyFifoEn)
    a6fa:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    a6fc:	f893 3214 	ldrb.w	r3, [r3, #532]	; 0x214
    a700:	2b00      	cmp	r3, #0
    a702:	d003      	beq.n	a70c <FlexCAN_IRQHandlerRxMB+0x6c>
    #endif
        {
            bIsCriticalSectionNeeded = TRUE;
    a704:	2301      	movs	r3, #1
    a706:	f88d 3077 	strb.w	r3, [sp, #119]	; 0x77
            /* Disable all IRQs */
            OsIf_SuspendAllInterrupts();
    a70a:	b672      	cpsid	i
        }
    }
#endif /* (defined(ERR_IPV_FLEXCAN_E050246) || defined(ERR_IPV_FLEXCAN_E050630)) */

    /* Lock RX message buffer and RX FIFO*/
    FlexCAN_LockRxMsgBuff(base, mb_idx);
    a70c:	9902      	ldr	r1, [sp, #8]
    a70e:	981c      	ldr	r0, [sp, #112]	; 0x70
    a710:	f002 fd55 	bl	d1be <FlexCAN_LockRxMsgBuff>

    /* Get RX MB field values*/
    FlexCAN_GetMsgBuff(base, mb_idx, state->mbs[mb_idx].pMBmessage);
    a714:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    a716:	9b02      	ldr	r3, [sp, #8]
    a718:	011b      	lsls	r3, r3, #4
    a71a:	4413      	add	r3, r2
    a71c:	681b      	ldr	r3, [r3, #0]
    a71e:	461a      	mov	r2, r3
    a720:	9902      	ldr	r1, [sp, #8]
    a722:	981c      	ldr	r0, [sp, #112]	; 0x70
    a724:	f002 fe7a 	bl	d41c <FlexCAN_GetMsgBuff>

    FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    a728:	9902      	ldr	r1, [sp, #8]
    a72a:	981c      	ldr	r0, [sp, #112]	; 0x70
    a72c:	f7ff faee 	bl	9d0c <FlexCAN_ClearMsgBuffIntStatusFlag>

#if defined (ERR_IPV_FLEXCAN_E050246)
    /* the CODE field is updated with an incorrect value when MBx is locked by software for more than 20 CAN bit times and FIFO enable.
    When the CODE field is corrupted, it's probably updated with any value that is invalid. Except EMPTY, FULL and OVERRUN other values can not make MB unlocked and move-in process. */
    if ((state->bIsLegacyFifoEn) && \
    a730:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    a732:	f893 3214 	ldrb.w	r3, [r3, #532]	; 0x214
    a736:	2b00      	cmp	r3, #0
    a738:	d032      	beq.n	a7a0 <FlexCAN_IRQHandlerRxMB+0x100>
    ((uint32)FLEXCAN_RX_FULL != ((state->mbs[mb_idx].pMBmessage->cs & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT)) && \
    a73a:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    a73c:	9b02      	ldr	r3, [sp, #8]
    a73e:	011b      	lsls	r3, r3, #4
    a740:	4413      	add	r3, r2
    a742:	681b      	ldr	r3, [r3, #0]
    a744:	681b      	ldr	r3, [r3, #0]
    a746:	0e1b      	lsrs	r3, r3, #24
    a748:	f003 030f 	and.w	r3, r3, #15
    if ((state->bIsLegacyFifoEn) && \
    a74c:	2b02      	cmp	r3, #2
    a74e:	d027      	beq.n	a7a0 <FlexCAN_IRQHandlerRxMB+0x100>
    ((uint32)FLEXCAN_RX_EMPTY != ((state->mbs[mb_idx].pMBmessage->cs & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT)) && \
    a750:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    a752:	9b02      	ldr	r3, [sp, #8]
    a754:	011b      	lsls	r3, r3, #4
    a756:	4413      	add	r3, r2
    a758:	681b      	ldr	r3, [r3, #0]
    a75a:	681b      	ldr	r3, [r3, #0]
    a75c:	0e1b      	lsrs	r3, r3, #24
    a75e:	f003 030f 	and.w	r3, r3, #15
    ((uint32)FLEXCAN_RX_FULL != ((state->mbs[mb_idx].pMBmessage->cs & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT)) && \
    a762:	2b04      	cmp	r3, #4
    a764:	d01c      	beq.n	a7a0 <FlexCAN_IRQHandlerRxMB+0x100>
    ((uint32)FLEXCAN_RX_OVERRUN != ((state->mbs[mb_idx].pMBmessage->cs & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT)))
    a766:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    a768:	9b02      	ldr	r3, [sp, #8]
    a76a:	011b      	lsls	r3, r3, #4
    a76c:	4413      	add	r3, r2
    a76e:	681b      	ldr	r3, [r3, #0]
    a770:	681b      	ldr	r3, [r3, #0]
    a772:	0e1b      	lsrs	r3, r3, #24
    a774:	f003 030f 	and.w	r3, r3, #15
    ((uint32)FLEXCAN_RX_EMPTY != ((state->mbs[mb_idx].pMBmessage->cs & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT)) && \
    a778:	2b06      	cmp	r3, #6
    a77a:	d011      	beq.n	a7a0 <FlexCAN_IRQHandlerRxMB+0x100>
    {
        /* Update the cs code for next sequence move in MB.
        A CPU write into the C/S word also unlocks the MB */
        volatile uint32 *flexcan_mb = FlexCAN_GetMsgBuffRegion(base, mb_idx);
    a77c:	9902      	ldr	r1, [sp, #8]
    a77e:	981c      	ldr	r0, [sp, #112]	; 0x70
    a780:	f002 f9a4 	bl	cacc <FlexCAN_GetMsgBuffRegion>
    a784:	9019      	str	r0, [sp, #100]	; 0x64
        *flexcan_mb &= ~FLEXCAN_IP_CS_CODE_MASK;
    a786:	9b19      	ldr	r3, [sp, #100]	; 0x64
    a788:	681b      	ldr	r3, [r3, #0]
    a78a:	f023 6270 	bic.w	r2, r3, #251658240	; 0xf000000
    a78e:	9b19      	ldr	r3, [sp, #100]	; 0x64
    a790:	601a      	str	r2, [r3, #0]
        *flexcan_mb |= (((uint32)FLEXCAN_RX_EMPTY) << FLEXCAN_IP_CS_CODE_SHIFT) & FLEXCAN_IP_CS_CODE_MASK;
    a792:	9b19      	ldr	r3, [sp, #100]	; 0x64
    a794:	681b      	ldr	r3, [r3, #0]
    a796:	f043 6280 	orr.w	r2, r3, #67108864	; 0x4000000
    a79a:	9b19      	ldr	r3, [sp, #100]	; 0x64
    a79c:	601a      	str	r2, [r3, #0]
    {
    a79e:	e002      	b.n	a7a6 <FlexCAN_IRQHandlerRxMB+0x106>
    }
    else
#endif
    {
    /* Unlock RX message buffer and RX FIFO*/
    FlexCAN_UnlockRxMsgBuff(base);
    a7a0:	981c      	ldr	r0, [sp, #112]	; 0x70
    a7a2:	f7ff faac 	bl	9cfe <FlexCAN_UnlockRxMsgBuff>
    }

#if (defined (ERR_IPV_FLEXCAN_E050246) || defined (ERR_IPV_FLEXCAN_E050630))
    /* To ensure that interrupts are resumed when they are suspended */
    if (TRUE == bIsCriticalSectionNeeded)
    a7a6:	f89d 3077 	ldrb.w	r3, [sp, #119]	; 0x77
    a7aa:	2b00      	cmp	r3, #0
    a7ac:	d000      	beq.n	a7b0 <FlexCAN_IRQHandlerRxMB+0x110>
    {
        /* Enable all IRQs */
        OsIf_ResumeAllInterrupts();
    a7ae:	b662      	cpsie	i
    }
#endif /* (defined(ERR_IPV_FLEXCAN_E050246) || defined(ERR_IPV_FLEXCAN_E050630)) */

    state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;
    a7b0:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    a7b2:	9b02      	ldr	r3, [sp, #8]
    a7b4:	011b      	lsls	r3, r3, #4
    a7b6:	4413      	add	r3, r2
    a7b8:	3304      	adds	r3, #4
    a7ba:	2200      	movs	r2, #0
    a7bc:	601a      	str	r2, [r3, #0]

    bCurrentIntStat = state->mbs[mb_idx].isPolling;
    a7be:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    a7c0:	9b02      	ldr	r3, [sp, #8]
    a7c2:	011b      	lsls	r3, r3, #4
    a7c4:	4413      	add	r3, r2
    a7c6:	3308      	adds	r3, #8
    a7c8:	781b      	ldrb	r3, [r3, #0]
    a7ca:	f88d 306b 	strb.w	r3, [sp, #107]	; 0x6b

    /* Invoke callback */
    if (state->callback != NULL_PTR)
    a7ce:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    a7d0:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    a7d4:	2b00      	cmp	r3, #0
    a7d6:	d008      	beq.n	a7ea <FlexCAN_IRQHandlerRxMB+0x14a>
    {
        state->callback(instance, FLEXCAN_EVENT_RX_COMPLETE, mb_idx, state);
    a7d8:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    a7da:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    a7de:	f89d 000f 	ldrb.w	r0, [sp, #15]
    a7e2:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    a7e4:	9a02      	ldr	r2, [sp, #8]
    a7e6:	2100      	movs	r1, #0
    a7e8:	47a0      	blx	r4
    }

    if ((FLEXCAN_MB_IDLE == state->mbs[mb_idx].state) && (FALSE == state->mbs[mb_idx].isPolling))
    a7ea:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    a7ec:	9b02      	ldr	r3, [sp, #8]
    a7ee:	011b      	lsls	r3, r3, #4
    a7f0:	4413      	add	r3, r2
    a7f2:	3304      	adds	r3, #4
    a7f4:	681b      	ldr	r3, [r3, #0]
    a7f6:	2b00      	cmp	r3, #0
    a7f8:	d11e      	bne.n	a838 <FlexCAN_IRQHandlerRxMB+0x198>
    a7fa:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    a7fc:	9b02      	ldr	r3, [sp, #8]
    a7fe:	011b      	lsls	r3, r3, #4
    a800:	4413      	add	r3, r2
    a802:	3308      	adds	r3, #8
    a804:	781b      	ldrb	r3, [r3, #0]
    a806:	f083 0301 	eor.w	r3, r3, #1
    a80a:	b2db      	uxtb	r3, r3
    a80c:	2b00      	cmp	r3, #0
    a80e:	d013      	beq.n	a838 <FlexCAN_IRQHandlerRxMB+0x198>
    {
        /* callback is not called, need to reset to default value */
        state->mbs[mb_idx].isPolling = TRUE;
    a810:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    a812:	9b02      	ldr	r3, [sp, #8]
    a814:	011b      	lsls	r3, r3, #4
    a816:	4413      	add	r3, r2
    a818:	3308      	adds	r3, #8
    a81a:	2201      	movs	r2, #1
    a81c:	701a      	strb	r2, [r3, #0]
        /* Disable the transmitter data register empty interrupt for case: mb is interrupt (it was not use in above callback with the same index) */
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, mb_idx, FALSE, state->isIntActive);
    a81e:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    a820:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    a824:	f89d 100f 	ldrb.w	r1, [sp, #15]
    a828:	9300      	str	r3, [sp, #0]
    a82a:	2300      	movs	r3, #0
    a82c:	9a02      	ldr	r2, [sp, #8]
    a82e:	981c      	ldr	r0, [sp, #112]	; 0x70
    a830:	f002 fcd4 	bl	d1dc <FlexCAN_SetMsgBuffIntCmd>
    a834:	bf00      	nop
    else
    {
        /* Prevent misra */
        /* When processing type change from POLL->POLL or INTERRUPT -> INTERRUPT(this Mb is used continously in callback), no need to disable interrupt in the ISR */
    }
}
    a836:	e019      	b.n	a86c <FlexCAN_IRQHandlerRxMB+0x1cc>
    else if ((FALSE == bCurrentIntStat) && (TRUE == state->mbs[mb_idx].isPolling))
    a838:	f89d 306b 	ldrb.w	r3, [sp, #107]	; 0x6b
    a83c:	f083 0301 	eor.w	r3, r3, #1
    a840:	b2db      	uxtb	r3, r3
    a842:	2b00      	cmp	r3, #0
    a844:	d012      	beq.n	a86c <FlexCAN_IRQHandlerRxMB+0x1cc>
    a846:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
    a848:	9b02      	ldr	r3, [sp, #8]
    a84a:	011b      	lsls	r3, r3, #4
    a84c:	4413      	add	r3, r2
    a84e:	3308      	adds	r3, #8
    a850:	781b      	ldrb	r3, [r3, #0]
    a852:	2b00      	cmp	r3, #0
    a854:	d00a      	beq.n	a86c <FlexCAN_IRQHandlerRxMB+0x1cc>
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, mb_idx, FALSE, state->isIntActive);
    a856:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
    a858:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    a85c:	f89d 100f 	ldrb.w	r1, [sp, #15]
    a860:	9300      	str	r3, [sp, #0]
    a862:	2300      	movs	r3, #0
    a864:	9a02      	ldr	r2, [sp, #8]
    a866:	981c      	ldr	r0, [sp, #112]	; 0x70
    a868:	f002 fcb8 	bl	d1dc <FlexCAN_SetMsgBuffIntCmd>
}
    a86c:	bf00      	nop
    a86e:	b01e      	add	sp, #120	; 0x78
    a870:	bd10      	pop	{r4, pc}
    a872:	bf00      	nop
    a874:	00015be8 	.word	0x00015be8
    a878:	1fff9048 	.word	0x1fff9048

0000a87c <FlexCAN_IRQHandlerTxMB>:
 * note: just using in interrupt mode
 * This is not a public API as it is called whenever an interrupt and receive
 * individual MB occurs
 *END**************************************************************************/
static void FlexCAN_IRQHandlerTxMB(uint8 u8Instance, uint32 u32MbIdx)
{
    a87c:	b510      	push	{r4, lr}
    a87e:	b09a      	sub	sp, #104	; 0x68
    a880:	4603      	mov	r3, r0
    a882:	9102      	str	r1, [sp, #8]
    a884:	f88d 300f 	strb.w	r3, [sp, #15]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    a888:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a88c:	4a46      	ldr	r2, [pc, #280]	; (a9a8 <FlexCAN_IRQHandlerTxMB+0x12c>)
    a88e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a892:	9319      	str	r3, [sp, #100]	; 0x64
    Flexcan_Ip_StateType * pState = Flexcan_Ip_apxState[u8Instance];
    a894:	f89d 300f 	ldrb.w	r3, [sp, #15]
    a898:	4a44      	ldr	r2, [pc, #272]	; (a9ac <FlexCAN_IRQHandlerTxMB+0x130>)
    a89a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a89e:	9318      	str	r3, [sp, #96]	; 0x60
    Flexcan_Ip_MsgBuffType mb;
    mb.cs = 0U;
    a8a0:	2300      	movs	r3, #0
    a8a2:	9304      	str	r3, [sp, #16]
    mb.time_stamp = 0U;
    a8a4:	2300      	movs	r3, #0
    a8a6:	9317      	str	r3, [sp, #92]	; 0x5c
    if (pState->mbs[u32MbIdx].isRemote)
    a8a8:	9a18      	ldr	r2, [sp, #96]	; 0x60
    a8aa:	9b02      	ldr	r3, [sp, #8]
    a8ac:	011b      	lsls	r3, r3, #4
    a8ae:	4413      	add	r3, r2
    a8b0:	3309      	adds	r3, #9
    a8b2:	781b      	ldrb	r3, [r3, #0]
    a8b4:	2b00      	cmp	r3, #0
    a8b6:	d01e      	beq.n	a8f6 <FlexCAN_IRQHandlerTxMB+0x7a>
    {
        FlexCAN_LockRxMsgBuff(pBase, u32MbIdx);
    a8b8:	9902      	ldr	r1, [sp, #8]
    a8ba:	9819      	ldr	r0, [sp, #100]	; 0x64
    a8bc:	f002 fc7f 	bl	d1be <FlexCAN_LockRxMsgBuff>
        FlexCAN_GetMsgBuff(pBase, u32MbIdx, &mb);
    a8c0:	ab04      	add	r3, sp, #16
    a8c2:	461a      	mov	r2, r3
    a8c4:	9902      	ldr	r1, [sp, #8]
    a8c6:	9819      	ldr	r0, [sp, #100]	; 0x64
    a8c8:	f002 fda8 	bl	d41c <FlexCAN_GetMsgBuff>
        FlexCAN_UnlockRxMsgBuff(pBase);
    a8cc:	9819      	ldr	r0, [sp, #100]	; 0x64
    a8ce:	f7ff fa16 	bl	9cfe <FlexCAN_UnlockRxMsgBuff>
        pState->mbs[u32MbIdx].time_stamp = mb.time_stamp;
    a8d2:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    a8d4:	9918      	ldr	r1, [sp, #96]	; 0x60
    a8d6:	9b02      	ldr	r3, [sp, #8]
    a8d8:	011b      	lsls	r3, r3, #4
    a8da:	440b      	add	r3, r1
    a8dc:	330c      	adds	r3, #12
    a8de:	601a      	str	r2, [r3, #0]
        /* If the frame was a remote frame, clear the flag only if the response was
        * not received yet. If the response was received, leave the flag set in order
        * to be handled when the user calls FLEXCAN_DRV_RxMessageBuffer. */
        if ((uint32)FLEXCAN_RX_EMPTY == ((mb.cs & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT))
    a8e0:	9b04      	ldr	r3, [sp, #16]
    a8e2:	0e1b      	lsrs	r3, r3, #24
    a8e4:	f003 030f 	and.w	r3, r3, #15
    a8e8:	2b04      	cmp	r3, #4
    a8ea:	d116      	bne.n	a91a <FlexCAN_IRQHandlerTxMB+0x9e>
        {
            FlexCAN_ClearMsgBuffIntStatusFlag(pBase, u32MbIdx);
    a8ec:	9902      	ldr	r1, [sp, #8]
    a8ee:	9819      	ldr	r0, [sp, #100]	; 0x64
    a8f0:	f7ff fa0c 	bl	9d0c <FlexCAN_ClearMsgBuffIntStatusFlag>
    a8f4:	e011      	b.n	a91a <FlexCAN_IRQHandlerTxMB+0x9e>
        }
    }
    else
    {
        pState->mbs[u32MbIdx].time_stamp = FlexCAN_GetMsgBuffTimestamp(pBase, u32MbIdx);
    a8f6:	9902      	ldr	r1, [sp, #8]
    a8f8:	9819      	ldr	r0, [sp, #100]	; 0x64
    a8fa:	f002 fd7b 	bl	d3f4 <FlexCAN_GetMsgBuffTimestamp>
    a8fe:	4601      	mov	r1, r0
    a900:	9a18      	ldr	r2, [sp, #96]	; 0x60
    a902:	9b02      	ldr	r3, [sp, #8]
    a904:	011b      	lsls	r3, r3, #4
    a906:	4413      	add	r3, r2
    a908:	330c      	adds	r3, #12
    a90a:	6019      	str	r1, [r3, #0]
        FlexCAN_UnlockRxMsgBuff(pBase);
    a90c:	9819      	ldr	r0, [sp, #100]	; 0x64
    a90e:	f7ff f9f6 	bl	9cfe <FlexCAN_UnlockRxMsgBuff>
        FlexCAN_ClearMsgBuffIntStatusFlag(pBase, u32MbIdx);
    a912:	9902      	ldr	r1, [sp, #8]
    a914:	9819      	ldr	r0, [sp, #100]	; 0x64
    a916:	f7ff f9f9 	bl	9d0c <FlexCAN_ClearMsgBuffIntStatusFlag>
    }

    pState->mbs[u32MbIdx].state = FLEXCAN_MB_IDLE;
    a91a:	9a18      	ldr	r2, [sp, #96]	; 0x60
    a91c:	9b02      	ldr	r3, [sp, #8]
    a91e:	011b      	lsls	r3, r3, #4
    a920:	4413      	add	r3, r2
    a922:	3304      	adds	r3, #4
    a924:	2200      	movs	r2, #0
    a926:	601a      	str	r2, [r3, #0]

    /* Invoke callback */
    if (pState->callback != NULL_PTR)
    a928:	9b18      	ldr	r3, [sp, #96]	; 0x60
    a92a:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    a92e:	2b00      	cmp	r3, #0
    a930:	d008      	beq.n	a944 <FlexCAN_IRQHandlerTxMB+0xc8>
    {
        pState->callback(u8Instance, FLEXCAN_EVENT_TX_COMPLETE, u32MbIdx, pState);
    a932:	9b18      	ldr	r3, [sp, #96]	; 0x60
    a934:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    a938:	f89d 000f 	ldrb.w	r0, [sp, #15]
    a93c:	9b18      	ldr	r3, [sp, #96]	; 0x60
    a93e:	9a02      	ldr	r2, [sp, #8]
    a940:	2104      	movs	r1, #4
    a942:	47a0      	blx	r4
    }

    if (FLEXCAN_MB_IDLE == pState->mbs[u32MbIdx].state)
    a944:	9a18      	ldr	r2, [sp, #96]	; 0x60
    a946:	9b02      	ldr	r3, [sp, #8]
    a948:	011b      	lsls	r3, r3, #4
    a94a:	4413      	add	r3, r2
    a94c:	3304      	adds	r3, #4
    a94e:	681b      	ldr	r3, [r3, #0]
    a950:	2b00      	cmp	r3, #0
    a952:	d112      	bne.n	a97a <FlexCAN_IRQHandlerTxMB+0xfe>
    {
        /* callback is not called, need to reset to default value */
        pState->mbs[u32MbIdx].isPolling = TRUE;
    a954:	9a18      	ldr	r2, [sp, #96]	; 0x60
    a956:	9b02      	ldr	r3, [sp, #8]
    a958:	011b      	lsls	r3, r3, #4
    a95a:	4413      	add	r3, r2
    a95c:	3308      	adds	r3, #8
    a95e:	2201      	movs	r2, #1
    a960:	701a      	strb	r2, [r3, #0]
        /* Disable the transmitter data register empty interrupt for case: mb is interrupt (it was not use in above callback with the same index) */
        (void)FlexCAN_SetMsgBuffIntCmd(pBase, u8Instance, u32MbIdx, FALSE, pState->isIntActive);
    a962:	9b18      	ldr	r3, [sp, #96]	; 0x60
    a964:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    a968:	f89d 100f 	ldrb.w	r1, [sp, #15]
    a96c:	9300      	str	r3, [sp, #0]
    a96e:	2300      	movs	r3, #0
    a970:	9a02      	ldr	r2, [sp, #8]
    a972:	9819      	ldr	r0, [sp, #100]	; 0x64
    a974:	f002 fc32 	bl	d1dc <FlexCAN_SetMsgBuffIntCmd>
    else
    {
        /* Prevent misra */
        /* When processing type change from POLL->POLL or INTERRUPT -> INTERRUPT(this Mb is used continously in callback), no need to disable interrupt in the ISR */
    }
}
    a978:	e012      	b.n	a9a0 <FlexCAN_IRQHandlerTxMB+0x124>
    else if (TRUE == pState->mbs[u32MbIdx].isPolling)
    a97a:	9a18      	ldr	r2, [sp, #96]	; 0x60
    a97c:	9b02      	ldr	r3, [sp, #8]
    a97e:	011b      	lsls	r3, r3, #4
    a980:	4413      	add	r3, r2
    a982:	3308      	adds	r3, #8
    a984:	781b      	ldrb	r3, [r3, #0]
    a986:	2b00      	cmp	r3, #0
    a988:	d00a      	beq.n	a9a0 <FlexCAN_IRQHandlerTxMB+0x124>
        (void)FlexCAN_SetMsgBuffIntCmd(pBase, u8Instance, u32MbIdx, FALSE, pState->isIntActive);
    a98a:	9b18      	ldr	r3, [sp, #96]	; 0x60
    a98c:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    a990:	f89d 100f 	ldrb.w	r1, [sp, #15]
    a994:	9300      	str	r3, [sp, #0]
    a996:	2300      	movs	r3, #0
    a998:	9a02      	ldr	r2, [sp, #8]
    a99a:	9819      	ldr	r0, [sp, #100]	; 0x64
    a99c:	f002 fc1e 	bl	d1dc <FlexCAN_SetMsgBuffIntCmd>
}
    a9a0:	bf00      	nop
    a9a2:	b01a      	add	sp, #104	; 0x68
    a9a4:	bd10      	pop	{r4, pc}
    a9a6:	bf00      	nop
    a9a8:	00015be8 	.word	0x00015be8
    a9ac:	1fff9048 	.word	0x1fff9048

0000a9b0 <FlexCAN_IRQHandlerRxFIFO>:
 * Function Name : FlexCAN_IRQHandlerRxFIFO
 * Description   : Process IRQHandler in case of RxFIFO mode selection for CAN interface.
 *
 *END**************************************************************************/
static inline void FlexCAN_IRQHandlerRxFIFO(uint8 instance, uint32 mb_idx)
{
    a9b0:	b510      	push	{r4, lr}
    a9b2:	b098      	sub	sp, #96	; 0x60
    a9b4:	4603      	mov	r3, r0
    a9b6:	9100      	str	r1, [sp, #0]
    a9b8:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    a9bc:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a9c0:	4a3c      	ldr	r2, [pc, #240]	; (aab4 <FlexCAN_IRQHandlerRxFIFO+0x104>)
    a9c2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a9c6:	9317      	str	r3, [sp, #92]	; 0x5c
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    a9c8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    a9cc:	4a3a      	ldr	r2, [pc, #232]	; (aab8 <FlexCAN_IRQHandlerRxFIFO+0x108>)
    a9ce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    a9d2:	9316      	str	r3, [sp, #88]	; 0x58
    Flexcan_Ip_MsgBuffType data;

    /* If use pass NULL_PTR, they can get data in callback function by getting state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].pMBmessage  */
    if (NULL_PTR == state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].pMBmessage)
    a9d4:	9b16      	ldr	r3, [sp, #88]	; 0x58
    a9d6:	681b      	ldr	r3, [r3, #0]
    a9d8:	2b00      	cmp	r3, #0
    a9da:	d102      	bne.n	a9e2 <FlexCAN_IRQHandlerRxFIFO+0x32>
    {
        state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].pMBmessage = &data;
    a9dc:	9b16      	ldr	r3, [sp, #88]	; 0x58
    a9de:	aa02      	add	r2, sp, #8
    a9e0:	601a      	str	r2, [r3, #0]
    }
    switch (mb_idx)
    a9e2:	9b00      	ldr	r3, [sp, #0]
    a9e4:	2b07      	cmp	r3, #7
    a9e6:	d048      	beq.n	aa7a <FlexCAN_IRQHandlerRxFIFO+0xca>
    a9e8:	9b00      	ldr	r3, [sp, #0]
    a9ea:	2b07      	cmp	r3, #7
    a9ec:	d858      	bhi.n	aaa0 <FlexCAN_IRQHandlerRxFIFO+0xf0>
    a9ee:	9b00      	ldr	r3, [sp, #0]
    a9f0:	2b05      	cmp	r3, #5
    a9f2:	d003      	beq.n	a9fc <FlexCAN_IRQHandlerRxFIFO+0x4c>
    a9f4:	9b00      	ldr	r3, [sp, #0]
    a9f6:	2b06      	cmp	r3, #6
    a9f8:	d02c      	beq.n	aa54 <FlexCAN_IRQHandlerRxFIFO+0xa4>
            }

            break;
        default:
            /* Do Nothing */
            break;
    a9fa:	e051      	b.n	aaa0 <FlexCAN_IRQHandlerRxFIFO+0xf0>
            if (FLEXCAN_MB_RX_BUSY == state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state)
    a9fc:	9b16      	ldr	r3, [sp, #88]	; 0x58
    a9fe:	685b      	ldr	r3, [r3, #4]
    aa00:	2b01      	cmp	r3, #1
    aa02:	d14f      	bne.n	aaa4 <FlexCAN_IRQHandlerRxFIFO+0xf4>
                FlexCAN_ReadRxFifo(base, state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].pMBmessage);
    aa04:	9b16      	ldr	r3, [sp, #88]	; 0x58
    aa06:	681b      	ldr	r3, [r3, #0]
    aa08:	4619      	mov	r1, r3
    aa0a:	9817      	ldr	r0, [sp, #92]	; 0x5c
    aa0c:	f003 f98d 	bl	dd2a <FlexCAN_ReadRxFifo>
                FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    aa10:	9900      	ldr	r1, [sp, #0]
    aa12:	9817      	ldr	r0, [sp, #92]	; 0x5c
    aa14:	f7ff f97a 	bl	9d0c <FlexCAN_ClearMsgBuffIntStatusFlag>
                state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state = FLEXCAN_MB_IDLE;
    aa18:	9b16      	ldr	r3, [sp, #88]	; 0x58
    aa1a:	2200      	movs	r2, #0
    aa1c:	605a      	str	r2, [r3, #4]
                if (state->callback != NULL_PTR)
    aa1e:	9b16      	ldr	r3, [sp, #88]	; 0x58
    aa20:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    aa24:	2b00      	cmp	r3, #0
    aa26:	d008      	beq.n	aa3a <FlexCAN_IRQHandlerRxFIFO+0x8a>
                    state->callback(instance, FLEXCAN_EVENT_RXFIFO_COMPLETE, FLEXCAN_IP_MB_HANDLE_RXFIFO, state);
    aa28:	9b16      	ldr	r3, [sp, #88]	; 0x58
    aa2a:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    aa2e:	f89d 0007 	ldrb.w	r0, [sp, #7]
    aa32:	9b16      	ldr	r3, [sp, #88]	; 0x58
    aa34:	2200      	movs	r2, #0
    aa36:	2101      	movs	r1, #1
    aa38:	47a0      	blx	r4
                if (FLEXCAN_MB_IDLE == state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state)
    aa3a:	9b16      	ldr	r3, [sp, #88]	; 0x58
    aa3c:	685b      	ldr	r3, [r3, #4]
    aa3e:	2b00      	cmp	r3, #0
    aa40:	d130      	bne.n	aaa4 <FlexCAN_IRQHandlerRxFIFO+0xf4>
                    state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].isPolling = TRUE;
    aa42:	9b16      	ldr	r3, [sp, #88]	; 0x58
    aa44:	2201      	movs	r2, #1
    aa46:	721a      	strb	r2, [r3, #8]
                    FlexCAN_CompleteRxMessageFifoData(instance);
    aa48:	f89d 3007 	ldrb.w	r3, [sp, #7]
    aa4c:	4618      	mov	r0, r3
    aa4e:	f000 fc61 	bl	b314 <FlexCAN_CompleteRxMessageFifoData>
            break;
    aa52:	e027      	b.n	aaa4 <FlexCAN_IRQHandlerRxFIFO+0xf4>
            FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    aa54:	9900      	ldr	r1, [sp, #0]
    aa56:	9817      	ldr	r0, [sp, #92]	; 0x5c
    aa58:	f7ff f958 	bl	9d0c <FlexCAN_ClearMsgBuffIntStatusFlag>
            if (state->callback != NULL_PTR)
    aa5c:	9b16      	ldr	r3, [sp, #88]	; 0x58
    aa5e:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    aa62:	2b00      	cmp	r3, #0
    aa64:	d020      	beq.n	aaa8 <FlexCAN_IRQHandlerRxFIFO+0xf8>
                state->callback(instance, FLEXCAN_EVENT_RXFIFO_WARNING, FLEXCAN_IP_MB_HANDLE_RXFIFO, state);
    aa66:	9b16      	ldr	r3, [sp, #88]	; 0x58
    aa68:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    aa6c:	f89d 0007 	ldrb.w	r0, [sp, #7]
    aa70:	9b16      	ldr	r3, [sp, #88]	; 0x58
    aa72:	2200      	movs	r2, #0
    aa74:	2102      	movs	r1, #2
    aa76:	47a0      	blx	r4
            break;
    aa78:	e016      	b.n	aaa8 <FlexCAN_IRQHandlerRxFIFO+0xf8>
            FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    aa7a:	9900      	ldr	r1, [sp, #0]
    aa7c:	9817      	ldr	r0, [sp, #92]	; 0x5c
    aa7e:	f7ff f945 	bl	9d0c <FlexCAN_ClearMsgBuffIntStatusFlag>
            if (state->callback != NULL_PTR)
    aa82:	9b16      	ldr	r3, [sp, #88]	; 0x58
    aa84:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    aa88:	2b00      	cmp	r3, #0
    aa8a:	d00f      	beq.n	aaac <FlexCAN_IRQHandlerRxFIFO+0xfc>
                state->callback(instance, FLEXCAN_EVENT_RXFIFO_OVERFLOW, FLEXCAN_IP_MB_HANDLE_RXFIFO, state);
    aa8c:	9b16      	ldr	r3, [sp, #88]	; 0x58
    aa8e:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    aa92:	f89d 0007 	ldrb.w	r0, [sp, #7]
    aa96:	9b16      	ldr	r3, [sp, #88]	; 0x58
    aa98:	2200      	movs	r2, #0
    aa9a:	2103      	movs	r1, #3
    aa9c:	47a0      	blx	r4
            break;
    aa9e:	e005      	b.n	aaac <FlexCAN_IRQHandlerRxFIFO+0xfc>
            break;
    aaa0:	bf00      	nop
    aaa2:	e004      	b.n	aaae <FlexCAN_IRQHandlerRxFIFO+0xfe>
            break;
    aaa4:	bf00      	nop
    aaa6:	e002      	b.n	aaae <FlexCAN_IRQHandlerRxFIFO+0xfe>
            break;
    aaa8:	bf00      	nop
    aaaa:	e000      	b.n	aaae <FlexCAN_IRQHandlerRxFIFO+0xfe>
            break;
    aaac:	bf00      	nop
    }
}
    aaae:	bf00      	nop
    aab0:	b018      	add	sp, #96	; 0x60
    aab2:	bd10      	pop	{r4, pc}
    aab4:	00015be8 	.word	0x00015be8
    aab8:	1fff9048 	.word	0x1fff9048

0000aabc <FlexCAN_AbortTxTransfer>:
 * Description   : Abort transfer for Tx buffer.
 *
 * This is not a public API as it is called from other driver functions.
 *END**************************************************************************/
static Flexcan_Ip_StatusType FlexCAN_AbortTxTransfer(uint8 u8Instance, uint8 mb_idx)
{
    aabc:	b500      	push	{lr}
    aabe:	b08b      	sub	sp, #44	; 0x2c
    aac0:	4603      	mov	r3, r0
    aac2:	460a      	mov	r2, r1
    aac4:	f88d 3007 	strb.w	r3, [sp, #7]
    aac8:	4613      	mov	r3, r2
    aaca:	f88d 3006 	strb.w	r3, [sp, #6]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    aace:	f89d 3007 	ldrb.w	r3, [sp, #7]
    aad2:	4a3c      	ldr	r2, [pc, #240]	; (abc4 <FlexCAN_AbortTxTransfer+0x108>)
    aad4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    aad8:	9307      	str	r3, [sp, #28]
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[u8Instance];
    aada:	f89d 3007 	ldrb.w	r3, [sp, #7]
    aade:	4a3a      	ldr	r2, [pc, #232]	; (abc8 <FlexCAN_AbortTxTransfer+0x10c>)
    aae0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    aae4:	9306      	str	r3, [sp, #24]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    aae6:	2300      	movs	r3, #0
    aae8:	9309      	str	r3, [sp, #36]	; 0x24

    uint32 timeStart = 0U;
    aaea:	2300      	movs	r3, #0
    aaec:	9302      	str	r3, [sp, #8]
    uint32 timeElapsed = 0U;
    aaee:	2300      	movs	r3, #0
    aaf0:	9308      	str	r3, [sp, #32]
    uint32 flexcan_mb_config = 0;
    aaf2:	2300      	movs	r3, #0
    aaf4:	9305      	str	r3, [sp, #20]
    uint32 uS2Ticks = 0U;
    aaf6:	2300      	movs	r3, #0
    aaf8:	9304      	str	r3, [sp, #16]
    volatile uint32 * flexcan_mb = NULL_PTR;
    aafa:	2300      	movs	r3, #0
    aafc:	9303      	str	r3, [sp, #12]

    flexcan_mb = FlexCAN_GetMsgBuffRegion(pBase, mb_idx);
    aafe:	f89d 3006 	ldrb.w	r3, [sp, #6]
    ab02:	4619      	mov	r1, r3
    ab04:	9807      	ldr	r0, [sp, #28]
    ab06:	f001 ffe1 	bl	cacc <FlexCAN_GetMsgBuffRegion>
    ab0a:	9003      	str	r0, [sp, #12]
    flexcan_mb_config = * flexcan_mb;
    ab0c:	9b03      	ldr	r3, [sp, #12]
    ab0e:	681b      	ldr	r3, [r3, #0]
    ab10:	9305      	str	r3, [sp, #20]
    /* Reset the code */
    flexcan_mb_config &= (~FLEXCAN_IP_CS_CODE_MASK);
    ab12:	9b05      	ldr	r3, [sp, #20]
    ab14:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    ab18:	9305      	str	r3, [sp, #20]
    flexcan_mb_config |= (uint32)(((uint32)FLEXCAN_TX_ABORT & (uint32)0x1F) << (uint8)FLEXCAN_IP_CS_CODE_SHIFT) & (uint32)FLEXCAN_IP_CS_CODE_MASK;
    ab1a:	9b05      	ldr	r3, [sp, #20]
    ab1c:	f043 6310 	orr.w	r3, r3, #150994944	; 0x9000000
    ab20:	9305      	str	r3, [sp, #20]
    *flexcan_mb = flexcan_mb_config;
    ab22:	9b03      	ldr	r3, [sp, #12]
    ab24:	9a05      	ldr	r2, [sp, #20]
    ab26:	601a      	str	r2, [r3, #0]

    /* Wait to finish abort operation */
    uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    ab28:	2100      	movs	r1, #0
    ab2a:	4828      	ldr	r0, [pc, #160]	; (abcc <FlexCAN_AbortTxTransfer+0x110>)
    ab2c:	f7f7 f982 	bl	1e34 <OsIf_MicrosToTicks>
    ab30:	9004      	str	r0, [sp, #16]
    timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    ab32:	2000      	movs	r0, #0
    ab34:	f7f7 f932 	bl	1d9c <OsIf_GetCounter>
    ab38:	4603      	mov	r3, r0
    ab3a:	9302      	str	r3, [sp, #8]
    while (0U == FlexCAN_GetBuffStatusFlag(pBase, mb_idx))
    ab3c:	e00f      	b.n	ab5e <FlexCAN_AbortTxTransfer+0xa2>
    {
        timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    ab3e:	ab02      	add	r3, sp, #8
    ab40:	2100      	movs	r1, #0
    ab42:	4618      	mov	r0, r3
    ab44:	f7f7 f943 	bl	1dce <OsIf_GetElapsed>
    ab48:	4602      	mov	r2, r0
    ab4a:	9b08      	ldr	r3, [sp, #32]
    ab4c:	4413      	add	r3, r2
    ab4e:	9308      	str	r3, [sp, #32]
        if (timeElapsed >= uS2Ticks)
    ab50:	9a08      	ldr	r2, [sp, #32]
    ab52:	9b04      	ldr	r3, [sp, #16]
    ab54:	429a      	cmp	r2, r3
    ab56:	d302      	bcc.n	ab5e <FlexCAN_AbortTxTransfer+0xa2>
        {
            result = FLEXCAN_STATUS_TIMEOUT;
    ab58:	2303      	movs	r3, #3
    ab5a:	9309      	str	r3, [sp, #36]	; 0x24
            break;
    ab5c:	e008      	b.n	ab70 <FlexCAN_AbortTxTransfer+0xb4>
    while (0U == FlexCAN_GetBuffStatusFlag(pBase, mb_idx))
    ab5e:	f89d 3006 	ldrb.w	r3, [sp, #6]
    ab62:	4619      	mov	r1, r3
    ab64:	9807      	ldr	r0, [sp, #28]
    ab66:	f7ff f8e4 	bl	9d32 <FlexCAN_GetBuffStatusFlag>
    ab6a:	4603      	mov	r3, r0
    ab6c:	2b00      	cmp	r3, #0
    ab6e:	d0e6      	beq.n	ab3e <FlexCAN_AbortTxTransfer+0x82>
        }
    }
    if (result != FLEXCAN_STATUS_TIMEOUT)
    ab70:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ab72:	2b03      	cmp	r3, #3
    ab74:	d012      	beq.n	ab9c <FlexCAN_AbortTxTransfer+0xe0>
    {
        flexcan_mb_config = *flexcan_mb;
    ab76:	9b03      	ldr	r3, [sp, #12]
    ab78:	681b      	ldr	r3, [r3, #0]
    ab7a:	9305      	str	r3, [sp, #20]
        /* Check if the MBs have been safely Inactivated */
        if ((uint32)FLEXCAN_TX_INACTIVE == ((flexcan_mb_config & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT))
    ab7c:	9b05      	ldr	r3, [sp, #20]
    ab7e:	0e1b      	lsrs	r3, r3, #24
    ab80:	f003 030f 	and.w	r3, r3, #15
    ab84:	2b08      	cmp	r3, #8
    ab86:	d101      	bne.n	ab8c <FlexCAN_AbortTxTransfer+0xd0>
        {
            /* Transmission have occurred */
            result = FLEXCAN_STATUS_NO_TRANSFER_IN_PROGRESS;
    ab88:	2305      	movs	r3, #5
    ab8a:	9309      	str	r3, [sp, #36]	; 0x24
        }

        if ((uint32)FLEXCAN_TX_ABORT == ((flexcan_mb_config & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT))
    ab8c:	9b05      	ldr	r3, [sp, #20]
    ab8e:	0e1b      	lsrs	r3, r3, #24
    ab90:	f003 030f 	and.w	r3, r3, #15
    ab94:	2b09      	cmp	r3, #9
    ab96:	d101      	bne.n	ab9c <FlexCAN_AbortTxTransfer+0xe0>
        {
            /* Transmission have been aborted */
            result = FLEXCAN_STATUS_SUCCESS;
    ab98:	2300      	movs	r3, #0
    ab9a:	9309      	str	r3, [sp, #36]	; 0x24
        }
    }
    /* Clear message buffer flag */
    FlexCAN_ClearMsgBuffIntStatusFlag(pBase, mb_idx);
    ab9c:	f89d 3006 	ldrb.w	r3, [sp, #6]
    aba0:	4619      	mov	r1, r3
    aba2:	9807      	ldr	r0, [sp, #28]
    aba4:	f7ff f8b2 	bl	9d0c <FlexCAN_ClearMsgBuffIntStatusFlag>
    state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;
    aba8:	f89d 3006 	ldrb.w	r3, [sp, #6]
    abac:	9a06      	ldr	r2, [sp, #24]
    abae:	011b      	lsls	r3, r3, #4
    abb0:	4413      	add	r3, r2
    abb2:	3304      	adds	r3, #4
    abb4:	2200      	movs	r2, #0
    abb6:	601a      	str	r2, [r3, #0]

    return result;
    abb8:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    abba:	4618      	mov	r0, r3
    abbc:	b00b      	add	sp, #44	; 0x2c
    abbe:	f85d fb04 	ldr.w	pc, [sp], #4
    abc2:	bf00      	nop
    abc4:	00015be8 	.word	0x00015be8
    abc8:	1fff9048 	.word	0x1fff9048
    abcc:	000f4240 	.word	0x000f4240

0000abd0 <FlexCAN_AbortRxTransfer>:
 * Description   : Abort transfer for Rx normal or legacy fifo if enabled.
 *
 * This is not a public API as it is called from other driver functions.
 *END**************************************************************************/
static void FlexCAN_AbortRxTransfer(uint8 u8Instance, uint8 mb_idx)
{
    abd0:	b500      	push	{lr}
    abd2:	b089      	sub	sp, #36	; 0x24
    abd4:	4603      	mov	r3, r0
    abd6:	460a      	mov	r2, r1
    abd8:	f88d 3007 	strb.w	r3, [sp, #7]
    abdc:	4613      	mov	r3, r2
    abde:	f88d 3006 	strb.w	r3, [sp, #6]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    abe2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    abe6:	4a41      	ldr	r2, [pc, #260]	; (acec <FlexCAN_AbortRxTransfer+0x11c>)
    abe8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    abec:	9307      	str	r3, [sp, #28]
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[u8Instance];
    abee:	f89d 3007 	ldrb.w	r3, [sp, #7]
    abf2:	4a3f      	ldr	r2, [pc, #252]	; (acf0 <FlexCAN_AbortRxTransfer+0x120>)
    abf4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    abf8:	9306      	str	r3, [sp, #24]
    uint8 val1 = 0U;
    abfa:	2300      	movs	r3, #0
    abfc:	f88d 3017 	strb.w	r3, [sp, #23]
    uint32 val2 = 0U;
    ac00:	2300      	movs	r3, #0
    ac02:	9304      	str	r3, [sp, #16]
    uint32 flexcan_mb_config = 0;
    ac04:	2300      	movs	r3, #0
    ac06:	9303      	str	r3, [sp, #12]
    volatile uint32 * flexcan_mb = NULL_PTR;
    ac08:	2300      	movs	r3, #0
    ac0a:	9302      	str	r3, [sp, #8]

    state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;
    ac0c:	f89d 3006 	ldrb.w	r3, [sp, #6]
    ac10:	9a06      	ldr	r2, [sp, #24]
    ac12:	011b      	lsls	r3, r3, #4
    ac14:	4413      	add	r3, r2
    ac16:	3304      	adds	r3, #4
    ac18:	2200      	movs	r2, #0
    ac1a:	601a      	str	r2, [r3, #0]
    /* Check if fifo enabled */
    if (TRUE == state->bIsLegacyFifoEn)
    ac1c:	9b06      	ldr	r3, [sp, #24]
    ac1e:	f893 3214 	ldrb.w	r3, [r3, #532]	; 0x214
    ac22:	2b00      	cmp	r3, #0
    ac24:	d03c      	beq.n	aca0 <FlexCAN_AbortRxTransfer+0xd0>
    {
        /* Get the number of RX FIFO Filters*/
        val1 = (uint8)(((pBase->CTRL2) & FLEXCAN_CTRL2_RFFN_MASK) >> FLEXCAN_CTRL2_RFFN_SHIFT);
    ac26:	9b07      	ldr	r3, [sp, #28]
    ac28:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    ac2a:	0e1b      	lsrs	r3, r3, #24
    ac2c:	b2db      	uxtb	r3, r3
    ac2e:	f003 030f 	and.w	r3, r3, #15
    ac32:	f88d 3017 	strb.w	r3, [sp, #23]
        /* Get the number if MBs occupied by RX FIFO and ID filter table*/
        /* the Rx FIFO occupies the memory space originally reserved for MB0-5*/
        /* Every number of RFFN means 8 number of RX FIFO filters*/
        /* and every 4 number of RX FIFO filters occupied one MB*/
        val2 = RxFifoOcuppiedLastMsgBuff(val1);
    ac36:	f89d 3017 	ldrb.w	r3, [sp, #23]
    ac3a:	4618      	mov	r0, r3
    ac3c:	f7ff f9f3 	bl	a026 <RxFifoOcuppiedLastMsgBuff>
    ac40:	9004      	str	r0, [sp, #16]
        if (mb_idx > val2)
    ac42:	f89d 3006 	ldrb.w	r3, [sp, #6]
    ac46:	9a04      	ldr	r2, [sp, #16]
    ac48:	429a      	cmp	r2, r3
    ac4a:	d21b      	bcs.n	ac84 <FlexCAN_AbortRxTransfer+0xb4>
        {
            /* This operation is not allowed for MB that are part of RxFIFO */
            flexcan_mb = FlexCAN_GetMsgBuffRegion(pBase, mb_idx);
    ac4c:	f89d 3006 	ldrb.w	r3, [sp, #6]
    ac50:	4619      	mov	r1, r3
    ac52:	9807      	ldr	r0, [sp, #28]
    ac54:	f001 ff3a 	bl	cacc <FlexCAN_GetMsgBuffRegion>
    ac58:	9002      	str	r0, [sp, #8]
            flexcan_mb_config = * flexcan_mb;
    ac5a:	9b02      	ldr	r3, [sp, #8]
    ac5c:	681b      	ldr	r3, [r3, #0]
    ac5e:	9303      	str	r3, [sp, #12]
            /* Reset the code and unlock the MB */
            flexcan_mb_config &= (uint32)(~FLEXCAN_IP_CS_CODE_MASK);
    ac60:	9b03      	ldr	r3, [sp, #12]
    ac62:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    ac66:	9303      	str	r3, [sp, #12]
            flexcan_mb_config |= (uint32)(((uint32)FLEXCAN_RX_INACTIVE & (uint32)0x1F) << (uint8)FLEXCAN_IP_CS_CODE_SHIFT) & (uint32)FLEXCAN_IP_CS_CODE_MASK;
            *flexcan_mb = flexcan_mb_config;
    ac68:	9b02      	ldr	r3, [sp, #8]
    ac6a:	9a03      	ldr	r2, [sp, #12]
    ac6c:	601a      	str	r2, [r3, #0]
            /* Reconfigure The MB as left by RxMBconfig */
            flexcan_mb_config &= (~FLEXCAN_IP_CS_CODE_MASK);
    ac6e:	9b03      	ldr	r3, [sp, #12]
    ac70:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    ac74:	9303      	str	r3, [sp, #12]
            flexcan_mb_config |= (uint32)(((uint32)FLEXCAN_RX_EMPTY & (uint32)0x1F) << (uint8)FLEXCAN_IP_CS_CODE_SHIFT) & (uint32)FLEXCAN_IP_CS_CODE_MASK;
    ac76:	9b03      	ldr	r3, [sp, #12]
    ac78:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
    ac7c:	9303      	str	r3, [sp, #12]
            *flexcan_mb = flexcan_mb_config;
    ac7e:	9b02      	ldr	r3, [sp, #8]
    ac80:	9a03      	ldr	r2, [sp, #12]
    ac82:	601a      	str	r2, [r3, #0]
        }
        if (FLEXCAN_IP_MB_HANDLE_RXFIFO == mb_idx)
    ac84:	f89d 3006 	ldrb.w	r3, [sp, #6]
    ac88:	2b00      	cmp	r3, #0
    ac8a:	d125      	bne.n	acd8 <FlexCAN_AbortRxTransfer+0x108>
        {
            FLEXCAN_ClearMsgBuffIntCmd(pBase, u8Instance, FLEXCAN_IP_LEGACY_RXFIFO_FRAME_AVAILABLE, state->isIntActive);
    ac8c:	9b06      	ldr	r3, [sp, #24]
    ac8e:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    ac92:	f89d 1007 	ldrb.w	r1, [sp, #7]
    ac96:	2205      	movs	r2, #5
    ac98:	9807      	ldr	r0, [sp, #28]
    ac9a:	f002 faf5 	bl	d288 <FLEXCAN_ClearMsgBuffIntCmd>
    ac9e:	e01b      	b.n	acd8 <FlexCAN_AbortRxTransfer+0x108>
        }
    }
    else
    {
        /* This operation is not allowed for MB that are part of RxFIFO */
        flexcan_mb = FlexCAN_GetMsgBuffRegion(pBase, mb_idx);
    aca0:	f89d 3006 	ldrb.w	r3, [sp, #6]
    aca4:	4619      	mov	r1, r3
    aca6:	9807      	ldr	r0, [sp, #28]
    aca8:	f001 ff10 	bl	cacc <FlexCAN_GetMsgBuffRegion>
    acac:	9002      	str	r0, [sp, #8]
        flexcan_mb_config = * flexcan_mb;
    acae:	9b02      	ldr	r3, [sp, #8]
    acb0:	681b      	ldr	r3, [r3, #0]
    acb2:	9303      	str	r3, [sp, #12]
        /* Reset the code and unlock the MB */
        flexcan_mb_config &= (~FLEXCAN_IP_CS_CODE_MASK);
    acb4:	9b03      	ldr	r3, [sp, #12]
    acb6:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    acba:	9303      	str	r3, [sp, #12]
        flexcan_mb_config |= (uint32)(((uint32)FLEXCAN_RX_INACTIVE & (uint32)0x1F) << (uint8)FLEXCAN_IP_CS_CODE_SHIFT) & (uint32)FLEXCAN_IP_CS_CODE_MASK;
        *flexcan_mb = flexcan_mb_config;
    acbc:	9b02      	ldr	r3, [sp, #8]
    acbe:	9a03      	ldr	r2, [sp, #12]
    acc0:	601a      	str	r2, [r3, #0]
        /* Reconfigure The MB as left by RxMBconfig */
        flexcan_mb_config &= (~FLEXCAN_IP_CS_CODE_MASK);
    acc2:	9b03      	ldr	r3, [sp, #12]
    acc4:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    acc8:	9303      	str	r3, [sp, #12]
        flexcan_mb_config |= (uint32)(((uint32)FLEXCAN_RX_EMPTY & (uint32)0x1F) << (uint8)FLEXCAN_IP_CS_CODE_SHIFT) & (uint32)FLEXCAN_IP_CS_CODE_MASK;
    acca:	9b03      	ldr	r3, [sp, #12]
    accc:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
    acd0:	9303      	str	r3, [sp, #12]
        *flexcan_mb = flexcan_mb_config;
    acd2:	9b02      	ldr	r3, [sp, #8]
    acd4:	9a03      	ldr	r2, [sp, #12]
    acd6:	601a      	str	r2, [r3, #0]
    }
    /* Clear message buffer flag */
    FlexCAN_ClearMsgBuffIntStatusFlag(pBase, mb_idx);
    acd8:	f89d 3006 	ldrb.w	r3, [sp, #6]
    acdc:	4619      	mov	r1, r3
    acde:	9807      	ldr	r0, [sp, #28]
    ace0:	f7ff f814 	bl	9d0c <FlexCAN_ClearMsgBuffIntStatusFlag>
}
    ace4:	bf00      	nop
    ace6:	b009      	add	sp, #36	; 0x24
    ace8:	f85d fb04 	ldr.w	pc, [sp], #4
    acec:	00015be8 	.word	0x00015be8
    acf0:	1fff9048 	.word	0x1fff9048

0000acf4 <FlexCAN_Ip_Init_Privileged>:
/* implements FlexCAN_Ip_Init_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_Init_Privileged(uint8 Flexcan_Ip_u8Instance,
                                                 Flexcan_Ip_StateType * Flexcan_Ip_pState,
                                                 const Flexcan_Ip_ConfigType * Flexcan_Ip_pData
                                                )
{
    acf4:	b500      	push	{lr}
    acf6:	b089      	sub	sp, #36	; 0x24
    acf8:	4603      	mov	r3, r0
    acfa:	9102      	str	r1, [sp, #8]
    acfc:	9201      	str	r2, [sp, #4]
    acfe:	f88d 300f 	strb.w	r3, [sp, #15]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    ad02:	2300      	movs	r3, #0
    ad04:	9306      	str	r3, [sp, #24]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[Flexcan_Ip_u8Instance];
    ad06:	f89d 300f 	ldrb.w	r3, [sp, #15]
    ad0a:	4a36      	ldr	r2, [pc, #216]	; (ade4 <FlexCAN_Ip_Init_Privileged+0xf0>)
    ad0c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ad10:	9305      	str	r3, [sp, #20]
    {
        OsIf_Trusted_Call1param(FlexCAN_SetUserAccessAllowed, pBase);
    }
#endif

    eResult = FlexCAN_InitController(Flexcan_Ip_u8Instance, pBase, Flexcan_Ip_pData);
    ad12:	f89d 300f 	ldrb.w	r3, [sp, #15]
    ad16:	9a01      	ldr	r2, [sp, #4]
    ad18:	9905      	ldr	r1, [sp, #20]
    ad1a:	4618      	mov	r0, r3
    ad1c:	f7ff fa84 	bl	a228 <FlexCAN_InitController>
    ad20:	9006      	str	r0, [sp, #24]
    if (FLEXCAN_STATUS_SUCCESS == eResult)
    ad22:	9b06      	ldr	r3, [sp, #24]
    ad24:	2b00      	cmp	r3, #0
    ad26:	d158      	bne.n	adda <FlexCAN_Ip_Init_Privileged+0xe6>
    {
        /* Init Baudrate */
        FlexCAN_InitBaudrate(pBase, Flexcan_Ip_pData);
    ad28:	9901      	ldr	r1, [sp, #4]
    ad2a:	9805      	ldr	r0, [sp, #20]
    ad2c:	f7ff fad6 	bl	a2dc <FlexCAN_InitBaudrate>
        /* Select mode */
        FlexCAN_SetOperationMode(pBase, Flexcan_Ip_pData->flexcanMode);
    ad30:	9b01      	ldr	r3, [sp, #4]
    ad32:	68db      	ldr	r3, [r3, #12]
    ad34:	4619      	mov	r1, r3
    ad36:	9805      	ldr	r0, [sp, #20]
    ad38:	f002 fdb8 	bl	d8ac <FlexCAN_SetOperationMode>

#if (FLEXCAN_IP_FEATURE_HAS_TS_ENABLE == STD_ON)
        FlexCAN_ConfigTimestamp(Flexcan_Ip_u8Instance, pBase, (const Flexcan_Ip_TimeStampConfigType *)(&Flexcan_Ip_pData->time_stamp));
#endif   /* (FLEXCAN_IP_FEATURE_HAS_TS_ENABLE == STD_ON) */

        for (i = 0; i < (uint8)FLEXCAN_IP_FEATURE_MAX_MB_NUM; i++)
    ad3c:	2300      	movs	r3, #0
    ad3e:	9307      	str	r3, [sp, #28]
    ad40:	e01d      	b.n	ad7e <FlexCAN_Ip_Init_Privileged+0x8a>
        {
            /* Check if blocking need to be any more present in sync\async discussions */
            /* Sync up isPolling status with hw (Imask), at the begining all Imask = 0 => isPolling = TRUE */
            Flexcan_Ip_pState->mbs[i].isPolling = TRUE;
    ad42:	9a02      	ldr	r2, [sp, #8]
    ad44:	9b07      	ldr	r3, [sp, #28]
    ad46:	011b      	lsls	r3, r3, #4
    ad48:	4413      	add	r3, r2
    ad4a:	3308      	adds	r3, #8
    ad4c:	2201      	movs	r2, #1
    ad4e:	701a      	strb	r2, [r3, #0]
            Flexcan_Ip_pState->mbs[i].pMBmessage = NULL_PTR;
    ad50:	9a02      	ldr	r2, [sp, #8]
    ad52:	9b07      	ldr	r3, [sp, #28]
    ad54:	011b      	lsls	r3, r3, #4
    ad56:	4413      	add	r3, r2
    ad58:	2200      	movs	r2, #0
    ad5a:	601a      	str	r2, [r3, #0]
            Flexcan_Ip_pState->mbs[i].state = FLEXCAN_MB_IDLE;
    ad5c:	9a02      	ldr	r2, [sp, #8]
    ad5e:	9b07      	ldr	r3, [sp, #28]
    ad60:	011b      	lsls	r3, r3, #4
    ad62:	4413      	add	r3, r2
    ad64:	3304      	adds	r3, #4
    ad66:	2200      	movs	r2, #0
    ad68:	601a      	str	r2, [r3, #0]
            Flexcan_Ip_pState->mbs[i].time_stamp = 0U;
    ad6a:	9a02      	ldr	r2, [sp, #8]
    ad6c:	9b07      	ldr	r3, [sp, #28]
    ad6e:	011b      	lsls	r3, r3, #4
    ad70:	4413      	add	r3, r2
    ad72:	330c      	adds	r3, #12
    ad74:	2200      	movs	r2, #0
    ad76:	601a      	str	r2, [r3, #0]
        for (i = 0; i < (uint8)FLEXCAN_IP_FEATURE_MAX_MB_NUM; i++)
    ad78:	9b07      	ldr	r3, [sp, #28]
    ad7a:	3301      	adds	r3, #1
    ad7c:	9307      	str	r3, [sp, #28]
    ad7e:	9b07      	ldr	r3, [sp, #28]
    ad80:	2b1f      	cmp	r3, #31
    ad82:	d9de      	bls.n	ad42 <FlexCAN_Ip_Init_Privileged+0x4e>
        /* Sync up isPolling status with hw (Imask), at the begining all Imask = 0 => isPolling = TRUE */
        Flexcan_Ip_pState->enhancedFifoOutput.isPolling = TRUE;
        Flexcan_Ip_pState->enhancedFifoOutput.state = FLEXCAN_MB_IDLE;
#endif

        Flexcan_Ip_pState->transferType = Flexcan_Ip_pData->transfer_type;
    ad84:	9b01      	ldr	r3, [sp, #4]
    ad86:	6c5a      	ldr	r2, [r3, #68]	; 0x44
    ad88:	9b02      	ldr	r3, [sp, #8]
    ad8a:	f8c3 2210 	str.w	r2, [r3, #528]	; 0x210
        Flexcan_Ip_pState->u32NumOfMbTransferByDMA = Flexcan_Ip_pData->num_enhanced_watermark;
#endif /* FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO */
#endif /* FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */

        /* Clear Callbacks in case of autovariables garbage */
        Flexcan_Ip_pState->callback = Flexcan_Ip_pData->Callback;
    ad8e:	9b01      	ldr	r3, [sp, #4]
    ad90:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    ad92:	9b02      	ldr	r3, [sp, #8]
    ad94:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
        Flexcan_Ip_pState->callbackParam = NULL_PTR;
    ad98:	9b02      	ldr	r3, [sp, #8]
    ad9a:	2200      	movs	r2, #0
    ad9c:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
        Flexcan_Ip_pState->error_callback = Flexcan_Ip_pData->ErrorCallback;
    ada0:	9b01      	ldr	r3, [sp, #4]
    ada2:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    ada4:	9b02      	ldr	r3, [sp, #8]
    ada6:	f8c3 2208 	str.w	r2, [r3, #520]	; 0x208
        Flexcan_Ip_pState->errorCallbackParam = NULL_PTR;
    adaa:	9b02      	ldr	r3, [sp, #8]
    adac:	2200      	movs	r2, #0
    adae:	f8c3 220c 	str.w	r2, [r3, #524]	; 0x20c
        Flexcan_Ip_pState->bIsLegacyFifoEn = Flexcan_Ip_pData->is_rx_fifo_needed;
    adb2:	9b01      	ldr	r3, [sp, #4]
    adb4:	7a1a      	ldrb	r2, [r3, #8]
    adb6:	9b02      	ldr	r3, [sp, #8]
    adb8:	f883 2214 	strb.w	r2, [r3, #532]	; 0x214
#if (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON)
        Flexcan_Ip_pState->bIsEnhancedFifoEn = Flexcan_Ip_pData->is_enhanced_rx_fifo_needed;
#endif /* FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO */
        Flexcan_Ip_pState->u32MaxMbNum = Flexcan_Ip_pData->max_num_mb;
    adbc:	9b01      	ldr	r3, [sp, #4]
    adbe:	681a      	ldr	r2, [r3, #0]
    adc0:	9b02      	ldr	r3, [sp, #8]
    adc2:	f8c3 2218 	str.w	r2, [r3, #536]	; 0x218
        Flexcan_Ip_pState->isIntActive = TRUE;
    adc6:	9b02      	ldr	r3, [sp, #8]
    adc8:	2201      	movs	r2, #1
    adca:	f883 221c 	strb.w	r2, [r3, #540]	; 0x21c
        /* Save runtime structure pointers so irq handler can point to the correct state structure */
        Flexcan_Ip_apxState[Flexcan_Ip_u8Instance] = Flexcan_Ip_pState;
    adce:	f89d 300f 	ldrb.w	r3, [sp, #15]
    add2:	4905      	ldr	r1, [pc, #20]	; (ade8 <FlexCAN_Ip_Init_Privileged+0xf4>)
    add4:	9a02      	ldr	r2, [sp, #8]
    add6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    return eResult;
    adda:	9b06      	ldr	r3, [sp, #24]
}
    addc:	4618      	mov	r0, r3
    adde:	b009      	add	sp, #36	; 0x24
    ade0:	f85d fb04 	ldr.w	pc, [sp], #4
    ade4:	00015be8 	.word	0x00015be8
    ade8:	1fff9048 	.word	0x1fff9048

0000adec <FlexCAN_Ip_Send>:
                                      uint8 mb_idx,
                                      const Flexcan_Ip_DataInfoType * tx_info,
                                      uint32 msg_id,
                                      const uint8 * mb_data
                                     )
{
    adec:	b500      	push	{lr}
    adee:	b08b      	sub	sp, #44	; 0x2c
    adf0:	9204      	str	r2, [sp, #16]
    adf2:	9303      	str	r3, [sp, #12]
    adf4:	4603      	mov	r3, r0
    adf6:	f88d 3017 	strb.w	r3, [sp, #23]
    adfa:	460b      	mov	r3, r1
    adfc:	f88d 3016 	strb.w	r3, [sp, #22]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_ERROR;
    ae00:	2301      	movs	r3, #1
    ae02:	9309      	str	r3, [sp, #36]	; 0x24
#if (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON)
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    ae04:	f89d 3017 	ldrb.w	r3, [sp, #23]
    ae08:	4a1c      	ldr	r2, [pc, #112]	; (ae7c <FlexCAN_Ip_Send+0x90>)
    ae0a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ae0e:	9308      	str	r3, [sp, #32]
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    ae10:	f89d 3017 	ldrb.w	r3, [sp, #23]
    ae14:	4a1a      	ldr	r2, [pc, #104]	; (ae80 <FlexCAN_Ip_Send+0x94>)
    ae16:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ae1a:	9307      	str	r3, [sp, #28]

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert(tx_info != NULL_PTR);
#endif
    if (!FlexCAN_IsListenOnlyModeEnabled(base))
    ae1c:	9808      	ldr	r0, [sp, #32]
    ae1e:	f7ff f8f4 	bl	a00a <FlexCAN_IsListenOnlyModeEnabled>
    ae22:	4603      	mov	r3, r0
    ae24:	f083 0301 	eor.w	r3, r3, #1
    ae28:	b2db      	uxtb	r3, r3
    ae2a:	2b00      	cmp	r3, #0
    ae2c:	d021      	beq.n	ae72 <FlexCAN_Ip_Send+0x86>
    {
        result = FlexCAN_StartSendData(instance, mb_idx, tx_info, msg_id, mb_data);
    ae2e:	f89d 1016 	ldrb.w	r1, [sp, #22]
    ae32:	f89d 0017 	ldrb.w	r0, [sp, #23]
    ae36:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    ae38:	9300      	str	r3, [sp, #0]
    ae3a:	9b03      	ldr	r3, [sp, #12]
    ae3c:	9a04      	ldr	r2, [sp, #16]
    ae3e:	f7ff fb4b 	bl	a4d8 <FlexCAN_StartSendData>
    ae42:	9009      	str	r0, [sp, #36]	; 0x24
#if (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON)
        if ((FLEXCAN_STATUS_SUCCESS ==  result) && (FALSE == tx_info->is_polling))
    ae44:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ae46:	2b00      	cmp	r3, #0
    ae48:	d113      	bne.n	ae72 <FlexCAN_Ip_Send+0x86>
    ae4a:	9b04      	ldr	r3, [sp, #16]
    ae4c:	7b1b      	ldrb	r3, [r3, #12]
    ae4e:	f083 0301 	eor.w	r3, r3, #1
    ae52:	b2db      	uxtb	r3, r3
    ae54:	2b00      	cmp	r3, #0
    ae56:	d00c      	beq.n	ae72 <FlexCAN_Ip_Send+0x86>
        {
            /* Enable message buffer interrupt*/
            result = FlexCAN_SetMsgBuffIntCmd(base, instance, mb_idx, TRUE, state->isIntActive);
    ae58:	f89d 2016 	ldrb.w	r2, [sp, #22]
    ae5c:	9b07      	ldr	r3, [sp, #28]
    ae5e:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    ae62:	f89d 1017 	ldrb.w	r1, [sp, #23]
    ae66:	9300      	str	r3, [sp, #0]
    ae68:	2301      	movs	r3, #1
    ae6a:	9808      	ldr	r0, [sp, #32]
    ae6c:	f002 f9b6 	bl	d1dc <FlexCAN_SetMsgBuffIntCmd>
    ae70:	9009      	str	r0, [sp, #36]	; 0x24
        }
#endif
    }
    return result;
    ae72:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    ae74:	4618      	mov	r0, r3
    ae76:	b00b      	add	sp, #44	; 0x2c
    ae78:	f85d fb04 	ldr.w	pc, [sp], #4
    ae7c:	00015be8 	.word	0x00015be8
    ae80:	1fff9048 	.word	0x1fff9048

0000ae84 <FlexCAN_Ip_ConfigRxMb>:
Flexcan_Ip_StatusType FlexCAN_Ip_ConfigRxMb(uint8 instance,
                                            uint8 mb_idx,
                                            const Flexcan_Ip_DataInfoType * rx_info,
                                            uint32 msg_id
                                           )
{
    ae84:	b500      	push	{lr}
    ae86:	b08b      	sub	sp, #44	; 0x2c
    ae88:	9202      	str	r2, [sp, #8]
    ae8a:	9301      	str	r3, [sp, #4]
    ae8c:	4603      	mov	r3, r0
    ae8e:	f88d 300f 	strb.w	r3, [sp, #15]
    ae92:	460b      	mov	r3, r1
    ae94:	f88d 300e 	strb.w	r3, [sp, #14]
    Flexcan_Ip_StatusType eResult = FLEXCAN_STATUS_SUCCESS;
    ae98:	2300      	movs	r3, #0
    ae9a:	9309      	str	r3, [sp, #36]	; 0x24
    Flexcan_Ip_MsbuffCodeStatusType cs;
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    ae9c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    aea0:	4a19      	ldr	r2, [pc, #100]	; (af08 <FlexCAN_Ip_ConfigRxMb+0x84>)
    aea2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    aea6:	9308      	str	r3, [sp, #32]
    }
    else
    {
#endif
        /* Clear the message buffer flag if previous remained triggered */
        FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    aea8:	f89d 300e 	ldrb.w	r3, [sp, #14]
    aeac:	4619      	mov	r1, r3
    aeae:	9808      	ldr	r0, [sp, #32]
    aeb0:	f7fe ff2c 	bl	9d0c <FlexCAN_ClearMsgBuffIntStatusFlag>

        cs.dataLen = rx_info->data_length;
    aeb4:	9b02      	ldr	r3, [sp, #8]
    aeb6:	685b      	ldr	r3, [r3, #4]
    aeb8:	9306      	str	r3, [sp, #24]
        cs.msgIdType = rx_info->msg_id_type;
    aeba:	9b02      	ldr	r3, [sp, #8]
    aebc:	681b      	ldr	r3, [r3, #0]
    aebe:	9305      	str	r3, [sp, #20]
    #if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        cs.fd_enable = rx_info->fd_enable;
    aec0:	9b02      	ldr	r3, [sp, #8]
    aec2:	7a1b      	ldrb	r3, [r3, #8]
    aec4:	f88d 301c 	strb.w	r3, [sp, #28]
    #endif

        /* Initialize rx mb*/
        cs.code = (uint32)FLEXCAN_RX_NOT_USED;
    aec8:	230f      	movs	r3, #15
    aeca:	9304      	str	r3, [sp, #16]
        FlexCAN_SetRxMsgBuff(base, mb_idx, &cs, msg_id);
    aecc:	f89d 100e 	ldrb.w	r1, [sp, #14]
    aed0:	aa04      	add	r2, sp, #16
    aed2:	9b01      	ldr	r3, [sp, #4]
    aed4:	9808      	ldr	r0, [sp, #32]
    aed6:	f002 fa25 	bl	d324 <FlexCAN_SetRxMsgBuff>

        /* Initialize receive MB*/
        cs.code = (uint32)FLEXCAN_RX_INACTIVE;
    aeda:	2300      	movs	r3, #0
    aedc:	9304      	str	r3, [sp, #16]
        FlexCAN_SetRxMsgBuff(base, mb_idx, &cs, msg_id);
    aede:	f89d 100e 	ldrb.w	r1, [sp, #14]
    aee2:	aa04      	add	r2, sp, #16
    aee4:	9b01      	ldr	r3, [sp, #4]
    aee6:	9808      	ldr	r0, [sp, #32]
    aee8:	f002 fa1c 	bl	d324 <FlexCAN_SetRxMsgBuff>

        /* Set up FlexCAN message buffer fields for receiving data*/
        cs.code = (uint32)FLEXCAN_RX_EMPTY;
    aeec:	2304      	movs	r3, #4
    aeee:	9304      	str	r3, [sp, #16]
        FlexCAN_SetRxMsgBuff(base, mb_idx, &cs, msg_id);
    aef0:	f89d 100e 	ldrb.w	r1, [sp, #14]
    aef4:	aa04      	add	r2, sp, #16
    aef6:	9b01      	ldr	r3, [sp, #4]
    aef8:	9808      	ldr	r0, [sp, #32]
    aefa:	f002 fa13 	bl	d324 <FlexCAN_SetRxMsgBuff>
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    }
#endif
    return eResult;
    aefe:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    af00:	4618      	mov	r0, r3
    af02:	b00b      	add	sp, #44	; 0x2c
    af04:	f85d fb04 	ldr.w	pc, [sp], #4
    af08:	00015be8 	.word	0x00015be8

0000af0c <FlexCAN_Ip_Receive>:
Flexcan_Ip_StatusType FlexCAN_Ip_Receive(uint8 instance,
                                         uint8 mb_idx,
                                         Flexcan_Ip_MsgBuffType * data,
                                         boolean isPolling
                                        )
{
    af0c:	b500      	push	{lr}
    af0e:	b089      	sub	sp, #36	; 0x24
    af10:	9202      	str	r2, [sp, #8]
    af12:	461a      	mov	r2, r3
    af14:	4603      	mov	r3, r0
    af16:	f88d 300f 	strb.w	r3, [sp, #15]
    af1a:	460b      	mov	r3, r1
    af1c:	f88d 300e 	strb.w	r3, [sp, #14]
    af20:	4613      	mov	r3, r2
    af22:	f88d 300d 	strb.w	r3, [sp, #13]

    Flexcan_Ip_StatusType result;
#if (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON)
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    af26:	f89d 300f 	ldrb.w	r3, [sp, #15]
    af2a:	4a18      	ldr	r2, [pc, #96]	; (af8c <FlexCAN_Ip_Receive+0x80>)
    af2c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    af30:	9306      	str	r3, [sp, #24]
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    af32:	f89d 300f 	ldrb.w	r3, [sp, #15]
    af36:	4a16      	ldr	r2, [pc, #88]	; (af90 <FlexCAN_Ip_Receive+0x84>)
    af38:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    af3c:	9305      	str	r3, [sp, #20]
#endif
    #if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    #endif

    result = FlexCAN_StartRxMessageBufferData(instance, mb_idx, data, isPolling);
    af3e:	f89d 300d 	ldrb.w	r3, [sp, #13]
    af42:	f89d 100e 	ldrb.w	r1, [sp, #14]
    af46:	f89d 000f 	ldrb.w	r0, [sp, #15]
    af4a:	9a02      	ldr	r2, [sp, #8]
    af4c:	f7ff fa86 	bl	a45c <FlexCAN_StartRxMessageBufferData>
    af50:	9007      	str	r0, [sp, #28]
#if (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON)
    if ((FLEXCAN_STATUS_SUCCESS == result) && (FALSE == isPolling))
    af52:	9b07      	ldr	r3, [sp, #28]
    af54:	2b00      	cmp	r3, #0
    af56:	d113      	bne.n	af80 <FlexCAN_Ip_Receive+0x74>
    af58:	f89d 300d 	ldrb.w	r3, [sp, #13]
    af5c:	f083 0301 	eor.w	r3, r3, #1
    af60:	b2db      	uxtb	r3, r3
    af62:	2b00      	cmp	r3, #0
    af64:	d00c      	beq.n	af80 <FlexCAN_Ip_Receive+0x74>
    {
        /* Enable MB interrupt*/
        result = FlexCAN_SetMsgBuffIntCmd(base, instance, mb_idx, TRUE, state->isIntActive);
    af66:	f89d 200e 	ldrb.w	r2, [sp, #14]
    af6a:	9b05      	ldr	r3, [sp, #20]
    af6c:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    af70:	f89d 100f 	ldrb.w	r1, [sp, #15]
    af74:	9300      	str	r3, [sp, #0]
    af76:	2301      	movs	r3, #1
    af78:	9806      	ldr	r0, [sp, #24]
    af7a:	f002 f92f 	bl	d1dc <FlexCAN_SetMsgBuffIntCmd>
    af7e:	9007      	str	r0, [sp, #28]
    }
#endif
    return result;
    af80:	9b07      	ldr	r3, [sp, #28]
}
    af82:	4618      	mov	r0, r3
    af84:	b009      	add	sp, #36	; 0x24
    af86:	f85d fb04 	ldr.w	pc, [sp], #4
    af8a:	bf00      	nop
    af8c:	00015be8 	.word	0x00015be8
    af90:	1fff9048 	.word	0x1fff9048

0000af94 <FlexCAN_Ip_ReceiveBlocking>:
                                                 uint8 mb_idx,
                                                 Flexcan_Ip_MsgBuffType * data,
                                                 boolean isPolling,
                                                 uint32 u32TimeoutMs
                                                )
{
    af94:	b500      	push	{lr}
    af96:	b08b      	sub	sp, #44	; 0x2c
    af98:	9202      	str	r2, [sp, #8]
    af9a:	461a      	mov	r2, r3
    af9c:	4603      	mov	r3, r0
    af9e:	f88d 300f 	strb.w	r3, [sp, #15]
    afa2:	460b      	mov	r3, r1
    afa4:	f88d 300e 	strb.w	r3, [sp, #14]
    afa8:	4613      	mov	r3, r2
    afaa:	f88d 300d 	strb.w	r3, [sp, #13]
    Flexcan_Ip_StatusType result;
    uint32 timeStart = 0U;
    afae:	2300      	movs	r3, #0
    afb0:	9304      	str	r3, [sp, #16]
    uint32 timeElapsed = 0U;
    afb2:	2300      	movs	r3, #0
    afb4:	9308      	str	r3, [sp, #32]
    uint32 mS2Ticks = OsIf_MicrosToTicks((u32TimeoutMs * 1000U), FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    afb6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    afb8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    afbc:	fb02 f303 	mul.w	r3, r2, r3
    afc0:	2100      	movs	r1, #0
    afc2:	4618      	mov	r0, r3
    afc4:	f7f6 ff36 	bl	1e34 <OsIf_MicrosToTicks>
    afc8:	9007      	str	r0, [sp, #28]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    afca:	f89d 300f 	ldrb.w	r3, [sp, #15]
    afce:	4a4c      	ldr	r2, [pc, #304]	; (b100 <FlexCAN_Ip_ReceiveBlocking+0x16c>)
    afd0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    afd4:	9306      	str	r3, [sp, #24]
#if (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON)
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    afd6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    afda:	4a4a      	ldr	r2, [pc, #296]	; (b104 <FlexCAN_Ip_ReceiveBlocking+0x170>)
    afdc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    afe0:	9305      	str	r3, [sp, #20]
#else
    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
#endif
    result = FlexCAN_StartRxMessageBufferData(instance, mb_idx, data, isPolling);
    afe2:	f89d 300d 	ldrb.w	r3, [sp, #13]
    afe6:	f89d 100e 	ldrb.w	r1, [sp, #14]
    afea:	f89d 000f 	ldrb.w	r0, [sp, #15]
    afee:	9a02      	ldr	r2, [sp, #8]
    aff0:	f7ff fa34 	bl	a45c <FlexCAN_StartRxMessageBufferData>
    aff4:	9009      	str	r0, [sp, #36]	; 0x24
#if (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON)
    if ((FLEXCAN_STATUS_SUCCESS == result) && (FALSE == isPolling))
    aff6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    aff8:	2b00      	cmp	r3, #0
    affa:	d113      	bne.n	b024 <FlexCAN_Ip_ReceiveBlocking+0x90>
    affc:	f89d 300d 	ldrb.w	r3, [sp, #13]
    b000:	f083 0301 	eor.w	r3, r3, #1
    b004:	b2db      	uxtb	r3, r3
    b006:	2b00      	cmp	r3, #0
    b008:	d00c      	beq.n	b024 <FlexCAN_Ip_ReceiveBlocking+0x90>
    {
        /* Enable MB interrupt*/
        result = FlexCAN_SetMsgBuffIntCmd(base, instance, mb_idx, TRUE, state->isIntActive);
    b00a:	f89d 200e 	ldrb.w	r2, [sp, #14]
    b00e:	9b06      	ldr	r3, [sp, #24]
    b010:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    b014:	f89d 100f 	ldrb.w	r1, [sp, #15]
    b018:	9300      	str	r3, [sp, #0]
    b01a:	2301      	movs	r3, #1
    b01c:	9805      	ldr	r0, [sp, #20]
    b01e:	f002 f8dd 	bl	d1dc <FlexCAN_SetMsgBuffIntCmd>
    b022:	9009      	str	r0, [sp, #36]	; 0x24
    }
#endif
    if (FLEXCAN_STATUS_SUCCESS == result)
    b024:	9b09      	ldr	r3, [sp, #36]	; 0x24
    b026:	2b00      	cmp	r3, #0
    b028:	d133      	bne.n	b092 <FlexCAN_Ip_ReceiveBlocking+0xfe>
    {
        timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    b02a:	2000      	movs	r0, #0
    b02c:	f7f6 feb6 	bl	1d9c <OsIf_GetCounter>
    b030:	4603      	mov	r3, r0
    b032:	9304      	str	r3, [sp, #16]
        while (FLEXCAN_MB_RX_BUSY == state->mbs[mb_idx].state)
    b034:	e024      	b.n	b080 <FlexCAN_Ip_ReceiveBlocking+0xec>
        {
            if (TRUE == isPolling)
    b036:	f89d 300d 	ldrb.w	r3, [sp, #13]
    b03a:	2b00      	cmp	r3, #0
    b03c:	d010      	beq.n	b060 <FlexCAN_Ip_ReceiveBlocking+0xcc>
            {
                if (FlexCAN_GetBuffStatusFlag(base, mb_idx) != 0U)
    b03e:	f89d 300e 	ldrb.w	r3, [sp, #14]
    b042:	4619      	mov	r1, r3
    b044:	9805      	ldr	r0, [sp, #20]
    b046:	f7fe fe74 	bl	9d32 <FlexCAN_GetBuffStatusFlag>
    b04a:	4603      	mov	r3, r0
    b04c:	2b00      	cmp	r3, #0
    b04e:	d007      	beq.n	b060 <FlexCAN_Ip_ReceiveBlocking+0xcc>
                {
                    FlexCAN_IRQHandlerRxMB(instance, mb_idx);
    b050:	f89d 200e 	ldrb.w	r2, [sp, #14]
    b054:	f89d 300f 	ldrb.w	r3, [sp, #15]
    b058:	4611      	mov	r1, r2
    b05a:	4618      	mov	r0, r3
    b05c:	f7ff fb20 	bl	a6a0 <FlexCAN_IRQHandlerRxMB>
                }
            }
            timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    b060:	ab04      	add	r3, sp, #16
    b062:	2100      	movs	r1, #0
    b064:	4618      	mov	r0, r3
    b066:	f7f6 feb2 	bl	1dce <OsIf_GetElapsed>
    b06a:	4602      	mov	r2, r0
    b06c:	9b08      	ldr	r3, [sp, #32]
    b06e:	4413      	add	r3, r2
    b070:	9308      	str	r3, [sp, #32]
            if (timeElapsed >= mS2Ticks)
    b072:	9a08      	ldr	r2, [sp, #32]
    b074:	9b07      	ldr	r3, [sp, #28]
    b076:	429a      	cmp	r2, r3
    b078:	d302      	bcc.n	b080 <FlexCAN_Ip_ReceiveBlocking+0xec>
            {
                result = FLEXCAN_STATUS_TIMEOUT;
    b07a:	2303      	movs	r3, #3
    b07c:	9309      	str	r3, [sp, #36]	; 0x24
                break;
    b07e:	e008      	b.n	b092 <FlexCAN_Ip_ReceiveBlocking+0xfe>
        while (FLEXCAN_MB_RX_BUSY == state->mbs[mb_idx].state)
    b080:	f89d 300e 	ldrb.w	r3, [sp, #14]
    b084:	9a06      	ldr	r2, [sp, #24]
    b086:	011b      	lsls	r3, r3, #4
    b088:	4413      	add	r3, r2
    b08a:	3304      	adds	r3, #4
    b08c:	681b      	ldr	r3, [r3, #0]
    b08e:	2b01      	cmp	r3, #1
    b090:	d0d1      	beq.n	b036 <FlexCAN_Ip_ReceiveBlocking+0xa2>
            }
        }
    }

    if ((FLEXCAN_STATUS_TIMEOUT == result) && (FALSE == isPolling))
    b092:	9b09      	ldr	r3, [sp, #36]	; 0x24
    b094:	2b03      	cmp	r3, #3
    b096:	d112      	bne.n	b0be <FlexCAN_Ip_ReceiveBlocking+0x12a>
    b098:	f89d 300d 	ldrb.w	r3, [sp, #13]
    b09c:	f083 0301 	eor.w	r3, r3, #1
    b0a0:	b2db      	uxtb	r3, r3
    b0a2:	2b00      	cmp	r3, #0
    b0a4:	d00b      	beq.n	b0be <FlexCAN_Ip_ReceiveBlocking+0x12a>
    {
#if (FLEXCAN_IP_MB_INTERRUPT_SUPPORT == STD_ON)
        /* Disable Mb interrupt*/
       (void)FlexCAN_SetMsgBuffIntCmd(base, instance, mb_idx, FALSE, state->isIntActive);
    b0a6:	f89d 200e 	ldrb.w	r2, [sp, #14]
    b0aa:	9b06      	ldr	r3, [sp, #24]
    b0ac:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    b0b0:	f89d 100f 	ldrb.w	r1, [sp, #15]
    b0b4:	9300      	str	r3, [sp, #0]
    b0b6:	2300      	movs	r3, #0
    b0b8:	9805      	ldr	r0, [sp, #20]
    b0ba:	f002 f88f 	bl	d1dc <FlexCAN_SetMsgBuffIntCmd>
#endif
    }

    if ((FLEXCAN_STATUS_BUFF_OUT_OF_RANGE != result) && (FLEXCAN_STATUS_BUSY != result))
    b0be:	9b09      	ldr	r3, [sp, #36]	; 0x24
    b0c0:	2b04      	cmp	r3, #4
    b0c2:	d018      	beq.n	b0f6 <FlexCAN_Ip_ReceiveBlocking+0x162>
    b0c4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    b0c6:	2b02      	cmp	r3, #2
    b0c8:	d015      	beq.n	b0f6 <FlexCAN_Ip_ReceiveBlocking+0x162>
    {
        if ((FLEXCAN_MB_IDLE == state->mbs[mb_idx].state))
    b0ca:	f89d 300e 	ldrb.w	r3, [sp, #14]
    b0ce:	9a06      	ldr	r2, [sp, #24]
    b0d0:	011b      	lsls	r3, r3, #4
    b0d2:	4413      	add	r3, r2
    b0d4:	3304      	adds	r3, #4
    b0d6:	681b      	ldr	r3, [r3, #0]
    b0d8:	2b00      	cmp	r3, #0
    b0da:	d102      	bne.n	b0e2 <FlexCAN_Ip_ReceiveBlocking+0x14e>
        {
            result = FLEXCAN_STATUS_SUCCESS;
    b0dc:	2300      	movs	r3, #0
    b0de:	9309      	str	r3, [sp, #36]	; 0x24
    b0e0:	e009      	b.n	b0f6 <FlexCAN_Ip_ReceiveBlocking+0x162>
        }
        else
        {
            state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;
    b0e2:	f89d 300e 	ldrb.w	r3, [sp, #14]
    b0e6:	9a06      	ldr	r2, [sp, #24]
    b0e8:	011b      	lsls	r3, r3, #4
    b0ea:	4413      	add	r3, r2
    b0ec:	3304      	adds	r3, #4
    b0ee:	2200      	movs	r2, #0
    b0f0:	601a      	str	r2, [r3, #0]
            result = FLEXCAN_STATUS_TIMEOUT;
    b0f2:	2303      	movs	r3, #3
    b0f4:	9309      	str	r3, [sp, #36]	; 0x24
        }
    }
    return result;
    b0f6:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
    b0f8:	4618      	mov	r0, r3
    b0fa:	b00b      	add	sp, #44	; 0x2c
    b0fc:	f85d fb04 	ldr.w	pc, [sp], #4
    b100:	1fff9048 	.word	0x1fff9048
    b104:	00015be8 	.word	0x00015be8

0000b108 <FlexCAN_Ip_RxFifo>:
 * after the frame was received and read into the specified buffer.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_RxFifo_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_RxFifo(uint8 instance, Flexcan_Ip_MsgBuffType * data)
{
    b108:	b500      	push	{lr}
    b10a:	b085      	sub	sp, #20
    b10c:	4603      	mov	r3, r0
    b10e:	9100      	str	r1, [sp, #0]
    b110:	f88d 3007 	strb.w	r3, [sp, #7]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    b114:	2300      	movs	r3, #0
    b116:	9303      	str	r3, [sp, #12]
        }
    }
    else
#endif /*FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO*/
    {
        result = FlexCAN_StartRxMessageFifoData(instance, data);
    b118:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b11c:	9900      	ldr	r1, [sp, #0]
    b11e:	4618      	mov	r0, r3
    b120:	f7ff fa5e 	bl	a5e0 <FlexCAN_StartRxMessageFifoData>
    b124:	9003      	str	r0, [sp, #12]
    }
    return result;
    b126:	9b03      	ldr	r3, [sp, #12]
}
    b128:	4618      	mov	r0, r3
    b12a:	b005      	add	sp, #20
    b12c:	f85d fb04 	ldr.w	pc, [sp], #4

0000b130 <FlexCAN_Ip_RxFifoBlocking>:
 *
 *END**************************************************************************/

/* implements FlexCAN_Ip_RxFifoBlocking_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_RxFifoBlocking(uint8 instance, Flexcan_Ip_MsgBuffType *data, uint32 timeout)
{
    b130:	b500      	push	{lr}
    b132:	b087      	sub	sp, #28
    b134:	4603      	mov	r3, r0
    b136:	9102      	str	r1, [sp, #8]
    b138:	9201      	str	r2, [sp, #4]
    b13a:	f88d 300f 	strb.w	r3, [sp, #15]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    b13e:	2300      	movs	r3, #0
    b140:	9305      	str	r3, [sp, #20]
        }
    }
    else
#endif /*FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO*/
    {
        result = FlexCAN_StartRxMessageFifoData(instance, data);
    b142:	f89d 300f 	ldrb.w	r3, [sp, #15]
    b146:	9902      	ldr	r1, [sp, #8]
    b148:	4618      	mov	r0, r3
    b14a:	f7ff fa49 	bl	a5e0 <FlexCAN_StartRxMessageFifoData>
    b14e:	9005      	str	r0, [sp, #20]
        if (FLEXCAN_STATUS_SUCCESS == result)
    b150:	9b05      	ldr	r3, [sp, #20]
    b152:	2b00      	cmp	r3, #0
    b154:	d106      	bne.n	b164 <FlexCAN_Ip_RxFifoBlocking+0x34>
        {
            result = FlexCAN_ProccessLegacyRxFIFO(instance, timeout);
    b156:	f89d 300f 	ldrb.w	r3, [sp, #15]
    b15a:	9901      	ldr	r1, [sp, #4]
    b15c:	4618      	mov	r0, r3
    b15e:	f7ff f8e2 	bl	a326 <FlexCAN_ProccessLegacyRxFIFO>
    b162:	9005      	str	r0, [sp, #20]
        }
    }
    return result;
    b164:	9b05      	ldr	r3, [sp, #20]
}
    b166:	4618      	mov	r0, r3
    b168:	b007      	add	sp, #28
    b16a:	f85d fb04 	ldr.w	pc, [sp], #4

0000b16e <FlexCAN_Ip_ConfigRxFifo_Privileged>:
/* implements FlexCAN_Ip_ConfigRxFifo_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_ConfigRxFifo_Privileged(uint8 instance,
                                                         Flexcan_Ip_RxFifoIdElementFormatType id_format,
                                                         const Flexcan_Ip_IdTableType * id_filter_table
                                                        )
{
    b16e:	b500      	push	{lr}
    b170:	b089      	sub	sp, #36	; 0x24
    b172:	4603      	mov	r3, r0
    b174:	9102      	str	r1, [sp, #8]
    b176:	9201      	str	r2, [sp, #4]
    b178:	f88d 300f 	strb.w	r3, [sp, #15]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    b17c:	2300      	movs	r3, #0
    b17e:	9307      	str	r3, [sp, #28]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    b180:	2300      	movs	r3, #0
    b182:	9306      	str	r3, [sp, #24]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    b184:	f89d 300f 	ldrb.w	r3, [sp, #15]
    b188:	4a1c      	ldr	r2, [pc, #112]	; (b1fc <FlexCAN_Ip_ConfigRxFifo_Privileged+0x8e>)
    b18a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b18e:	9305      	str	r3, [sp, #20]
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    b190:	9805      	ldr	r0, [sp, #20]
    b192:	f7fe fd61 	bl	9c58 <FlexCAN_IsEnabled>
    b196:	4603      	mov	r3, r0
    b198:	2b00      	cmp	r3, #0
    b19a:	bf14      	ite	ne
    b19c:	2301      	movne	r3, #1
    b19e:	2300      	moveq	r3, #0
    b1a0:	b2db      	uxtb	r3, r3
    b1a2:	f083 0301 	eor.w	r3, r3, #1
    b1a6:	b2db      	uxtb	r3, r3
    b1a8:	f88d 3013 	strb.w	r3, [sp, #19]
    b1ac:	f89d 3013 	ldrb.w	r3, [sp, #19]
    b1b0:	f003 0301 	and.w	r3, r3, #1
    b1b4:	f88d 3013 	strb.w	r3, [sp, #19]

    if (TRUE == disabled)
    b1b8:	f89d 3013 	ldrb.w	r3, [sp, #19]
    b1bc:	2b00      	cmp	r3, #0
    b1be:	d003      	beq.n	b1c8 <FlexCAN_Ip_ConfigRxFifo_Privileged+0x5a>
    {
        result = FlexCAN_Enable(pBase);
    b1c0:	9805      	ldr	r0, [sp, #20]
    b1c2:	f001 fd6b 	bl	cc9c <FlexCAN_Enable>
    b1c6:	9007      	str	r0, [sp, #28]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    b1c8:	9b07      	ldr	r3, [sp, #28]
    b1ca:	2b00      	cmp	r3, #0
    b1cc:	d104      	bne.n	b1d8 <FlexCAN_Ip_ConfigRxFifo_Privileged+0x6a>
    {
        /* Initialize rx fifo*/
        FlexCAN_SetRxFifoFilter(pBase, id_format, id_filter_table);
    b1ce:	9a01      	ldr	r2, [sp, #4]
    b1d0:	9902      	ldr	r1, [sp, #8]
    b1d2:	9805      	ldr	r0, [sp, #20]
    b1d4:	f002 fba5 	bl	d922 <FlexCAN_SetRxFifoFilter>
    }

    if (TRUE == disabled)
    b1d8:	f89d 3013 	ldrb.w	r3, [sp, #19]
    b1dc:	2b00      	cmp	r3, #0
    b1de:	d008      	beq.n	b1f2 <FlexCAN_Ip_ConfigRxFifo_Privileged+0x84>
    {
        status = FlexCAN_Disable(pBase);
    b1e0:	9805      	ldr	r0, [sp, #20]
    b1e2:	f001 fdd9 	bl	cd98 <FlexCAN_Disable>
    b1e6:	9006      	str	r0, [sp, #24]
        if (FLEXCAN_STATUS_SUCCESS != status)
    b1e8:	9b06      	ldr	r3, [sp, #24]
    b1ea:	2b00      	cmp	r3, #0
    b1ec:	d001      	beq.n	b1f2 <FlexCAN_Ip_ConfigRxFifo_Privileged+0x84>
        {
            result = status;
    b1ee:	9b06      	ldr	r3, [sp, #24]
    b1f0:	9307      	str	r3, [sp, #28]
        }
    }

    return result;
    b1f2:	9b07      	ldr	r3, [sp, #28]
}
    b1f4:	4618      	mov	r0, r3
    b1f6:	b009      	add	sp, #36	; 0x24
    b1f8:	f85d fb04 	ldr.w	pc, [sp], #4
    b1fc:	00015be8 	.word	0x00015be8

0000b200 <FlexCAN_Ip_ConfigRemoteResponseMb>:
                                                        uint8 mb_idx,
                                                        const Flexcan_Ip_DataInfoType *tx_info,
                                                        uint32 msg_id,
                                                        const uint8 *mb_data
                                                       )
{
    b200:	b500      	push	{lr}
    b202:	b08f      	sub	sp, #60	; 0x3c
    b204:	9204      	str	r2, [sp, #16]
    b206:	9303      	str	r3, [sp, #12]
    b208:	4603      	mov	r3, r0
    b20a:	f88d 3017 	strb.w	r3, [sp, #23]
    b20e:	460b      	mov	r3, r1
    b210:	f88d 3016 	strb.w	r3, [sp, #22]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    b214:	2300      	movs	r3, #0
    b216:	930d      	str	r3, [sp, #52]	; 0x34
    Flexcan_Ip_MsbuffCodeStatusType cs;
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    b218:	f89d 3017 	ldrb.w	r3, [sp, #23]
    b21c:	4a27      	ldr	r2, [pc, #156]	; (b2bc <FlexCAN_Ip_ConfigRemoteResponseMb+0xbc>)
    b21e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b222:	930c      	str	r3, [sp, #48]	; 0x30
    const Flexcan_Ip_StateType * const state = Flexcan_Ip_apxState[instance];
    b224:	f89d 3017 	ldrb.w	r3, [sp, #23]
    b228:	4a25      	ldr	r2, [pc, #148]	; (b2c0 <FlexCAN_Ip_ConfigRemoteResponseMb+0xc0>)
    b22a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b22e:	930b      	str	r3, [sp, #44]	; 0x2c
    volatile uint32 * pMbAddr = NULL_PTR;
    b230:	2300      	movs	r3, #0
    b232:	930a      	str	r3, [sp, #40]	; 0x28
    if (TRUE == FlexCAN_IsMbOutOfRange(pBase, mb_idx, state->bIsLegacyFifoEn, state->u32MaxMbNum))
    {
        result = FLEXCAN_STATUS_BUFF_OUT_OF_RANGE;
    }
#endif
    if (FLEXCAN_STATUS_SUCCESS == result)
    b234:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    b236:	2b00      	cmp	r3, #0
    b238:	d13a      	bne.n	b2b0 <FlexCAN_Ip_ConfigRemoteResponseMb+0xb0>
    {
        /* Initialize transmit mb*/
        cs.dataLen = tx_info->data_length;
    b23a:	9b04      	ldr	r3, [sp, #16]
    b23c:	685b      	ldr	r3, [r3, #4]
    b23e:	9308      	str	r3, [sp, #32]
        cs.msgIdType = tx_info->msg_id_type;
    b240:	9b04      	ldr	r3, [sp, #16]
    b242:	681b      	ldr	r3, [r3, #0]
    b244:	9307      	str	r3, [sp, #28]
        cs.code = (uint32)FLEXCAN_RX_RANSWER;
    b246:	230a      	movs	r3, #10
    b248:	9306      	str	r3, [sp, #24]
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        cs.fd_enable = FALSE;
    b24a:	2300      	movs	r3, #0
    b24c:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
        cs.enable_brs = FALSE;
    b250:	2300      	movs	r3, #0
    b252:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
        cs.fd_padding = 0x00U;
    b256:	2300      	movs	r3, #0
    b258:	f88d 3025 	strb.w	r3, [sp, #37]	; 0x25
#endif
        FlexCAN_ClearMsgBuffIntStatusFlag(pBase, mb_idx);
    b25c:	f89d 3016 	ldrb.w	r3, [sp, #22]
    b260:	4619      	mov	r1, r3
    b262:	980c      	ldr	r0, [sp, #48]	; 0x30
    b264:	f7fe fd52 	bl	9d0c <FlexCAN_ClearMsgBuffIntStatusFlag>
        pMbAddr = FlexCAN_GetMsgBuffRegion(pBase, mb_idx);
    b268:	f89d 3016 	ldrb.w	r3, [sp, #22]
    b26c:	4619      	mov	r1, r3
    b26e:	980c      	ldr	r0, [sp, #48]	; 0x30
    b270:	f001 fc2c 	bl	cacc <FlexCAN_GetMsgBuffRegion>
    b274:	900a      	str	r0, [sp, #40]	; 0x28
        FlexCAN_SetTxMsgBuff(pMbAddr, &cs, msg_id, mb_data, tx_info->is_remote);
    b276:	9b04      	ldr	r3, [sp, #16]
    b278:	7adb      	ldrb	r3, [r3, #11]
    b27a:	a906      	add	r1, sp, #24
    b27c:	9300      	str	r3, [sp, #0]
    b27e:	9b10      	ldr	r3, [sp, #64]	; 0x40
    b280:	9a03      	ldr	r2, [sp, #12]
    b282:	980a      	ldr	r0, [sp, #40]	; 0x28
    b284:	f002 f974 	bl	d570 <FlexCAN_SetTxMsgBuff>
        if (FALSE == tx_info->is_polling)
    b288:	9b04      	ldr	r3, [sp, #16]
    b28a:	7b1b      	ldrb	r3, [r3, #12]
    b28c:	f083 0301 	eor.w	r3, r3, #1
    b290:	b2db      	uxtb	r3, r3
    b292:	2b00      	cmp	r3, #0
    b294:	d00c      	beq.n	b2b0 <FlexCAN_Ip_ConfigRemoteResponseMb+0xb0>
        {
            /* Enable MB interrupt*/
            result = FlexCAN_SetMsgBuffIntCmd(pBase, instance, mb_idx, TRUE, state->isIntActive);
    b296:	f89d 2016 	ldrb.w	r2, [sp, #22]
    b29a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    b29c:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    b2a0:	f89d 1017 	ldrb.w	r1, [sp, #23]
    b2a4:	9300      	str	r3, [sp, #0]
    b2a6:	2301      	movs	r3, #1
    b2a8:	980c      	ldr	r0, [sp, #48]	; 0x30
    b2aa:	f001 ff97 	bl	d1dc <FlexCAN_SetMsgBuffIntCmd>
    b2ae:	900d      	str	r0, [sp, #52]	; 0x34
        }
    }
    return result;
    b2b0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
}
    b2b2:	4618      	mov	r0, r3
    b2b4:	b00f      	add	sp, #60	; 0x3c
    b2b6:	f85d fb04 	ldr.w	pc, [sp], #4
    b2ba:	bf00      	nop
    b2bc:	00015be8 	.word	0x00015be8
    b2c0:	1fff9048 	.word	0x1fff9048

0000b2c4 <FlexCAN_Ip_GetTransferStatus>:
 * or complete (success). In case Enhanced Rx Fifo, mb_idx will be 255.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetTransferStatus_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_GetTransferStatus(uint8 instance, uint8 mb_idx)
{
    b2c4:	b084      	sub	sp, #16
    b2c6:	4603      	mov	r3, r0
    b2c8:	460a      	mov	r2, r1
    b2ca:	f88d 3007 	strb.w	r3, [sp, #7]
    b2ce:	4613      	mov	r3, r2
    b2d0:	f88d 3006 	strb.w	r3, [sp, #6]

    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    b2d4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b2d8:	4a0d      	ldr	r2, [pc, #52]	; (b310 <FlexCAN_Ip_GetTransferStatus+0x4c>)
    b2da:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b2de:	9302      	str	r3, [sp, #8]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_ERROR;
    b2e0:	2301      	movs	r3, #1
    b2e2:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert((mb_idx < (uint8)FLEXCAN_IP_FEATURE_MAX_MB_NUM) || (255u == mb_idx));
#endif

    if (mb_idx < (uint8)FLEXCAN_IP_FEATURE_MAX_MB_NUM)
    b2e4:	f89d 3006 	ldrb.w	r3, [sp, #6]
    b2e8:	2b1f      	cmp	r3, #31
    b2ea:	d80d      	bhi.n	b308 <FlexCAN_Ip_GetTransferStatus+0x44>
    {
        if (FLEXCAN_MB_IDLE == state->mbs[mb_idx].state)
    b2ec:	f89d 3006 	ldrb.w	r3, [sp, #6]
    b2f0:	9a02      	ldr	r2, [sp, #8]
    b2f2:	011b      	lsls	r3, r3, #4
    b2f4:	4413      	add	r3, r2
    b2f6:	3304      	adds	r3, #4
    b2f8:	681b      	ldr	r3, [r3, #0]
    b2fa:	2b00      	cmp	r3, #0
    b2fc:	d102      	bne.n	b304 <FlexCAN_Ip_GetTransferStatus+0x40>
        {
            status = FLEXCAN_STATUS_SUCCESS;
    b2fe:	2300      	movs	r3, #0
    b300:	9303      	str	r3, [sp, #12]
    b302:	e001      	b.n	b308 <FlexCAN_Ip_GetTransferStatus+0x44>
            status = FLEXCAN_STATUS_ERROR;
        }
#endif
        else
        {
            status = FLEXCAN_STATUS_BUSY;
    b304:	2302      	movs	r3, #2
    b306:	9303      	str	r3, [sp, #12]
            status = FLEXCAN_STATUS_BUSY;
        }
    }
#endif /* FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO */

    return status;
    b308:	9b03      	ldr	r3, [sp, #12]
}
    b30a:	4618      	mov	r0, r3
    b30c:	b004      	add	sp, #16
    b30e:	4770      	bx	lr
    b310:	1fff9048 	.word	0x1fff9048

0000b314 <FlexCAN_CompleteRxMessageFifoData>:
 * data and disabling the interrupt.
 * This is not a public API as it is called from other driver functions.
 *
 *END**************************************************************************/
static void FlexCAN_CompleteRxMessageFifoData(uint8 instance)
{
    b314:	b500      	push	{lr}
    b316:	b087      	sub	sp, #28
    b318:	4603      	mov	r3, r0
    b31a:	f88d 300f 	strb.w	r3, [sp, #15]

    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    b31e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    b322:	4a1d      	ldr	r2, [pc, #116]	; (b398 <FlexCAN_CompleteRxMessageFifoData+0x84>)
    b324:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b328:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    b32a:	f89d 300f 	ldrb.w	r3, [sp, #15]
    b32e:	4a1b      	ldr	r2, [pc, #108]	; (b39c <FlexCAN_CompleteRxMessageFifoData+0x88>)
    b330:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b334:	9304      	str	r3, [sp, #16]

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    if (FLEXCAN_RXFIFO_USING_INTERRUPTS == state->transferType)
    b336:	9b04      	ldr	r3, [sp, #16]
    b338:	f8d3 3210 	ldr.w	r3, [r3, #528]	; 0x210
    b33c:	2b00      	cmp	r3, #0
    b33e:	d120      	bne.n	b382 <FlexCAN_CompleteRxMessageFifoData+0x6e>
    {
        /* Disable RX FIFO interrupts*/
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, FLEXCAN_IP_LEGACY_RXFIFO_FRAME_AVAILABLE, FALSE, state->isIntActive);
    b340:	9b04      	ldr	r3, [sp, #16]
    b342:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    b346:	f89d 100f 	ldrb.w	r1, [sp, #15]
    b34a:	9300      	str	r3, [sp, #0]
    b34c:	2300      	movs	r3, #0
    b34e:	2205      	movs	r2, #5
    b350:	9805      	ldr	r0, [sp, #20]
    b352:	f001 ff43 	bl	d1dc <FlexCAN_SetMsgBuffIntCmd>
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, FLEXCAN_IP_LEGACY_RXFIFO_WARNING, FALSE, state->isIntActive);
    b356:	9b04      	ldr	r3, [sp, #16]
    b358:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    b35c:	f89d 100f 	ldrb.w	r1, [sp, #15]
    b360:	9300      	str	r3, [sp, #0]
    b362:	2300      	movs	r3, #0
    b364:	2206      	movs	r2, #6
    b366:	9805      	ldr	r0, [sp, #20]
    b368:	f001 ff38 	bl	d1dc <FlexCAN_SetMsgBuffIntCmd>
        (void)FlexCAN_SetMsgBuffIntCmd(base, instance, FLEXCAN_IP_LEGACY_RXFIFO_OVERFLOW, FALSE, state->isIntActive);
    b36c:	9b04      	ldr	r3, [sp, #16]
    b36e:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    b372:	f89d 100f 	ldrb.w	r1, [sp, #15]
    b376:	9300      	str	r3, [sp, #0]
    b378:	2300      	movs	r3, #0
    b37a:	2207      	movs	r2, #7
    b37c:	9805      	ldr	r0, [sp, #20]
    b37e:	f001 ff2d 	bl	d1dc <FlexCAN_SetMsgBuffIntCmd>
    {
        /* do nothing when transferType is POLLING */
    }
#endif /* if FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */
    /* Clear fifo message*/
    state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].pMBmessage = NULL_PTR;
    b382:	9b04      	ldr	r3, [sp, #16]
    b384:	2200      	movs	r2, #0
    b386:	601a      	str	r2, [r3, #0]
            state->callback(instance, FLEXCAN_EVENT_DMA_ERROR, FLEXCAN_IP_MB_HANDLE_RXFIFO, state);
        }
    }

#else
    state->mbs[FLEXCAN_IP_MB_HANDLE_RXFIFO].state = FLEXCAN_MB_IDLE;
    b388:	9b04      	ldr	r3, [sp, #16]
    b38a:	2200      	movs	r2, #0
    b38c:	605a      	str	r2, [r3, #4]
#endif /* if FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */
}
    b38e:	bf00      	nop
    b390:	b007      	add	sp, #28
    b392:	f85d fb04 	ldr.w	pc, [sp], #4
    b396:	bf00      	nop
    b398:	00015be8 	.word	0x00015be8
    b39c:	1fff9048 	.word	0x1fff9048

0000b3a0 <FlexCAN_IRQHandler>:
    uint32 endMbIdx
    #if (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON)
    ,boolean bEnhancedFifoExisted
    #endif
)
{
    b3a0:	b500      	push	{lr}
    b3a2:	b08b      	sub	sp, #44	; 0x2c
    b3a4:	4603      	mov	r3, r0
    b3a6:	9102      	str	r1, [sp, #8]
    b3a8:	9201      	str	r2, [sp, #4]
    b3aa:	f88d 300f 	strb.w	r3, [sp, #15]
    uint32 u32MbHandle = 0U;
    b3ae:	2300      	movs	r3, #0
    b3b0:	9309      	str	r3, [sp, #36]	; 0x24
    uint32 flag_reg = 0;
    b3b2:	2300      	movs	r3, #0
    b3b4:	9308      	str	r3, [sp, #32]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    b3b6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    b3ba:	4a3f      	ldr	r2, [pc, #252]	; (b4b8 <FlexCAN_IRQHandler+0x118>)
    b3bc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b3c0:	9306      	str	r3, [sp, #24]
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    b3c2:	f89d 300f 	ldrb.w	r3, [sp, #15]
    b3c6:	4a3d      	ldr	r2, [pc, #244]	; (b4bc <FlexCAN_IRQHandler+0x11c>)
    b3c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b3cc:	9305      	str	r3, [sp, #20]

    /* Get the interrupts that are enabled and ready */
    uint32 mb_idx = endMbIdx;
    b3ce:	9b01      	ldr	r3, [sp, #4]
    b3d0:	9307      	str	r3, [sp, #28]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert(endMbIdx < (uint8)FLEXCAN_IP_FEATURE_MAX_MB_NUM);
#endif
    /* Check if instance initialized */
    if (NULL_PTR != state)
    b3d2:	9b05      	ldr	r3, [sp, #20]
    b3d4:	2b00      	cmp	r3, #0
    b3d6:	d05c      	beq.n	b492 <FlexCAN_IRQHandler+0xf2>
    {
        flag_reg = FlexCAN_GetMsgBuffIntStatusFlag(base, mb_idx);
    b3d8:	9907      	ldr	r1, [sp, #28]
    b3da:	9806      	ldr	r0, [sp, #24]
    b3dc:	f7fe fe47 	bl	a06e <FlexCAN_GetMsgBuffIntStatusFlag>
    b3e0:	4603      	mov	r3, r0
    b3e2:	9308      	str	r3, [sp, #32]

        while ((0U == flag_reg) && (mb_idx > startMbIdx))
    b3e4:	e008      	b.n	b3f8 <FlexCAN_IRQHandler+0x58>
        {
            mb_idx--;
    b3e6:	9b07      	ldr	r3, [sp, #28]
    b3e8:	3b01      	subs	r3, #1
    b3ea:	9307      	str	r3, [sp, #28]
            flag_reg = FlexCAN_GetMsgBuffIntStatusFlag(base, mb_idx);
    b3ec:	9907      	ldr	r1, [sp, #28]
    b3ee:	9806      	ldr	r0, [sp, #24]
    b3f0:	f7fe fe3d 	bl	a06e <FlexCAN_GetMsgBuffIntStatusFlag>
    b3f4:	4603      	mov	r3, r0
    b3f6:	9308      	str	r3, [sp, #32]
        while ((0U == flag_reg) && (mb_idx > startMbIdx))
    b3f8:	9b08      	ldr	r3, [sp, #32]
    b3fa:	2b00      	cmp	r3, #0
    b3fc:	d103      	bne.n	b406 <FlexCAN_IRQHandler+0x66>
    b3fe:	9a07      	ldr	r2, [sp, #28]
    b400:	9b02      	ldr	r3, [sp, #8]
    b402:	429a      	cmp	r2, r3
    b404:	d8ef      	bhi.n	b3e6 <FlexCAN_IRQHandler+0x46>
        }

        /* Check Tx/Rx interrupt flag and clear the interrupt */
        if (flag_reg != 0U)
    b406:	9b08      	ldr	r3, [sp, #32]
    b408:	2b00      	cmp	r3, #0
    b40a:	d050      	beq.n	b4ae <FlexCAN_IRQHandler+0x10e>
        {
            /* For legacy fifo, mb handler is FLEXCAN_IP_MB_HANDLE_RXFIFO(0) */
            u32MbHandle = mb_idx;
    b40c:	9b07      	ldr	r3, [sp, #28]
    b40e:	9309      	str	r3, [sp, #36]	; 0x24

            if ((TRUE == state->bIsLegacyFifoEn) && (mb_idx <= FLEXCAN_IP_LEGACY_RXFIFO_OVERFLOW))
    b410:	9b05      	ldr	r3, [sp, #20]
    b412:	f893 3214 	ldrb.w	r3, [r3, #532]	; 0x214
    b416:	2b00      	cmp	r3, #0
    b418:	d00b      	beq.n	b432 <FlexCAN_IRQHandler+0x92>
    b41a:	9b07      	ldr	r3, [sp, #28]
    b41c:	2b07      	cmp	r3, #7
    b41e:	d808      	bhi.n	b432 <FlexCAN_IRQHandler+0x92>
            {
                FlexCAN_IRQHandlerRxFIFO(instance, mb_idx);
    b420:	f89d 300f 	ldrb.w	r3, [sp, #15]
    b424:	9907      	ldr	r1, [sp, #28]
    b426:	4618      	mov	r0, r3
    b428:	f7ff fac2 	bl	a9b0 <FlexCAN_IRQHandlerRxFIFO>
                u32MbHandle = (uint32)FLEXCAN_IP_MB_HANDLE_RXFIFO;
    b42c:	2300      	movs	r3, #0
    b42e:	9309      	str	r3, [sp, #36]	; 0x24
    b430:	e00d      	b.n	b44e <FlexCAN_IRQHandler+0xae>
            }
            else
            {
                /* Check mailbox completed reception */
                if (FLEXCAN_MB_RX_BUSY == state->mbs[u32MbHandle].state)
    b432:	9a05      	ldr	r2, [sp, #20]
    b434:	9b09      	ldr	r3, [sp, #36]	; 0x24
    b436:	011b      	lsls	r3, r3, #4
    b438:	4413      	add	r3, r2
    b43a:	3304      	adds	r3, #4
    b43c:	681b      	ldr	r3, [r3, #0]
    b43e:	2b01      	cmp	r3, #1
    b440:	d105      	bne.n	b44e <FlexCAN_IRQHandler+0xae>
                {
                    FlexCAN_IRQHandlerRxMB(instance, mb_idx);
    b442:	f89d 300f 	ldrb.w	r3, [sp, #15]
    b446:	9907      	ldr	r1, [sp, #28]
    b448:	4618      	mov	r0, r3
    b44a:	f7ff f929 	bl	a6a0 <FlexCAN_IRQHandlerRxMB>
                }
            }

            /* Check mailbox completed transmission */
            if (FLEXCAN_MB_TX_BUSY == state->mbs[u32MbHandle].state)
    b44e:	9a05      	ldr	r2, [sp, #20]
    b450:	9b09      	ldr	r3, [sp, #36]	; 0x24
    b452:	011b      	lsls	r3, r3, #4
    b454:	4413      	add	r3, r2
    b456:	3304      	adds	r3, #4
    b458:	681b      	ldr	r3, [r3, #0]
    b45a:	2b02      	cmp	r3, #2
    b45c:	d105      	bne.n	b46a <FlexCAN_IRQHandler+0xca>
            {
                FlexCAN_IRQHandlerTxMB(instance, mb_idx);
    b45e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    b462:	9907      	ldr	r1, [sp, #28]
    b464:	4618      	mov	r0, r3
    b466:	f7ff fa09 	bl	a87c <FlexCAN_IRQHandlerTxMB>
            }

            /* Check for spurious interrupt */
            if (FlexCAN_GetMsgBuffIntStatusFlag(base, mb_idx) != 0U)
    b46a:	9907      	ldr	r1, [sp, #28]
    b46c:	9806      	ldr	r0, [sp, #24]
    b46e:	f7fe fdfe 	bl	a06e <FlexCAN_GetMsgBuffIntStatusFlag>
    b472:	4603      	mov	r3, r0
    b474:	2b00      	cmp	r3, #0
    b476:	d01a      	beq.n	b4ae <FlexCAN_IRQHandler+0x10e>
            {
                if (state->mbs[u32MbHandle].state == FLEXCAN_MB_IDLE)
    b478:	9a05      	ldr	r2, [sp, #20]
    b47a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    b47c:	011b      	lsls	r3, r3, #4
    b47e:	4413      	add	r3, r2
    b480:	3304      	adds	r3, #4
    b482:	681b      	ldr	r3, [r3, #0]
    b484:	2b00      	cmp	r3, #0
    b486:	d112      	bne.n	b4ae <FlexCAN_IRQHandler+0x10e>
                {
                    /* In case of desynchronized status of the MB to avoid trapping in ISR
                    * clear the MB flag */
                    FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    b488:	9907      	ldr	r1, [sp, #28]
    b48a:	9806      	ldr	r0, [sp, #24]
    b48c:	f7fe fc3e 	bl	9d0c <FlexCAN_ClearMsgBuffIntStatusFlag>
            FlexCAN_ClearEnhancedRxFifoIntStatusFlag(base, FLEXCAN_IP_ENHANCED_RXFIFO_OVERFLOW);
            FlexCAN_ClearEnhancedRxFifoIntStatusFlag(base, FLEXCAN_IP_ENHANCED_RXFIFO_UNDERFLOW);
        }
    #endif /* End of (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) */
    }
}
    b490:	e00d      	b.n	b4ae <FlexCAN_IRQHandler+0x10e>
        for (mb_idx = startMbIdx; mb_idx <= endMbIdx; mb_idx++)
    b492:	9b02      	ldr	r3, [sp, #8]
    b494:	9307      	str	r3, [sp, #28]
    b496:	e006      	b.n	b4a6 <FlexCAN_IRQHandler+0x106>
            FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    b498:	9907      	ldr	r1, [sp, #28]
    b49a:	9806      	ldr	r0, [sp, #24]
    b49c:	f7fe fc36 	bl	9d0c <FlexCAN_ClearMsgBuffIntStatusFlag>
        for (mb_idx = startMbIdx; mb_idx <= endMbIdx; mb_idx++)
    b4a0:	9b07      	ldr	r3, [sp, #28]
    b4a2:	3301      	adds	r3, #1
    b4a4:	9307      	str	r3, [sp, #28]
    b4a6:	9a07      	ldr	r2, [sp, #28]
    b4a8:	9b01      	ldr	r3, [sp, #4]
    b4aa:	429a      	cmp	r2, r3
    b4ac:	d9f4      	bls.n	b498 <FlexCAN_IRQHandler+0xf8>
}
    b4ae:	bf00      	nop
    b4b0:	b00b      	add	sp, #44	; 0x2c
    b4b2:	f85d fb04 	ldr.w	pc, [sp], #4
    b4b6:	bf00      	nop
    b4b8:	00015be8 	.word	0x00015be8
    b4bc:	1fff9048 	.word	0x1fff9048

0000b4c0 <FlexCAN_Ip_ClearErrorStatus>:
 *                 transmission of a CAN frame.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_ClearErrorStatus_Activity */
void FlexCAN_Ip_ClearErrorStatus(uint8 instance, uint32 error)
{
    b4c0:	b084      	sub	sp, #16
    b4c2:	4603      	mov	r3, r0
    b4c4:	9100      	str	r1, [sp, #0]
    b4c6:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    b4ca:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b4ce:	4a05      	ldr	r2, [pc, #20]	; (b4e4 <FlexCAN_Ip_ClearErrorStatus+0x24>)
    b4d0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b4d4:	9303      	str	r3, [sp, #12]

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    base->ESR1 = error;
    b4d6:	9b03      	ldr	r3, [sp, #12]
    b4d8:	9a00      	ldr	r2, [sp, #0]
    b4da:	621a      	str	r2, [r3, #32]
}
    b4dc:	bf00      	nop
    b4de:	b004      	add	sp, #16
    b4e0:	4770      	bx	lr
    b4e2:	bf00      	nop
    b4e4:	00015be8 	.word	0x00015be8

0000b4e8 <FlexCAN_Ip_GetErrorStatus>:
 *                 transmission of a CAN frame and some general status of the device.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetErrorStatus_Activity */
uint32 FlexCAN_Ip_GetErrorStatus(uint8 instance)
{
    b4e8:	b084      	sub	sp, #16
    b4ea:	4603      	mov	r3, r0
    b4ec:	f88d 3007 	strb.w	r3, [sp, #7]

    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    b4f0:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b4f4:	4a04      	ldr	r2, [pc, #16]	; (b508 <FlexCAN_Ip_GetErrorStatus+0x20>)
    b4f6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b4fa:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    return (uint32)(base->ESR1);
    b4fc:	9b03      	ldr	r3, [sp, #12]
    b4fe:	6a1b      	ldr	r3, [r3, #32]
}
    b500:	4618      	mov	r0, r3
    b502:	b004      	add	sp, #16
    b504:	4770      	bx	lr
    b506:	bf00      	nop
    b508:	00015be8 	.word	0x00015be8

0000b50c <FlexCAN_Ip_GetControllerTxErrorCounter>:
 *                 transmitted messages.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetControllerTxErrorCounter_Activity */
uint8 FlexCAN_Ip_GetControllerTxErrorCounter(uint8 instance)
{
    b50c:	b084      	sub	sp, #16
    b50e:	4603      	mov	r3, r0
    b510:	f88d 3007 	strb.w	r3, [sp, #7]

    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    b514:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b518:	4a04      	ldr	r2, [pc, #16]	; (b52c <FlexCAN_Ip_GetControllerTxErrorCounter+0x20>)
    b51a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b51e:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    return (uint8)((base->ECR & FLEXCAN_ECR_TXERRCNT_MASK) >> FLEXCAN_ECR_TXERRCNT_SHIFT);
    b520:	9b03      	ldr	r3, [sp, #12]
    b522:	69db      	ldr	r3, [r3, #28]
    b524:	b2db      	uxtb	r3, r3
}
    b526:	4618      	mov	r0, r3
    b528:	b004      	add	sp, #16
    b52a:	4770      	bx	lr
    b52c:	00015be8 	.word	0x00015be8

0000b530 <FlexCAN_Ip_GetControllerRxErrorCounter>:
 *                 received messages.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetControllerRxErrorCounter_Activity */
uint8 FlexCAN_Ip_GetControllerRxErrorCounter(uint8 instance)
{
    b530:	b084      	sub	sp, #16
    b532:	4603      	mov	r3, r0
    b534:	f88d 3007 	strb.w	r3, [sp, #7]

    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    b538:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b53c:	4a05      	ldr	r2, [pc, #20]	; (b554 <FlexCAN_Ip_GetControllerRxErrorCounter+0x24>)
    b53e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b542:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    return (uint8)((base->ECR & FLEXCAN_ECR_RXERRCNT_MASK) >> FLEXCAN_ECR_RXERRCNT_SHIFT);
    b544:	9b03      	ldr	r3, [sp, #12]
    b546:	69db      	ldr	r3, [r3, #28]
    b548:	0a1b      	lsrs	r3, r3, #8
    b54a:	b2db      	uxtb	r3, r3
}
    b54c:	4618      	mov	r0, r3
    b54e:	b004      	add	sp, #16
    b550:	4770      	bx	lr
    b552:	bf00      	nop
    b554:	00015be8 	.word	0x00015be8

0000b558 <FlexCAN_Error_IRQHandler>:
 * This is not a public API as it is called whenever an interrupt occurs.
 *
 *END**************************************************************************/
/* implements  CAN_X_ERROR_ISR_Activity */
void FlexCAN_Error_IRQHandler(uint8 instance)
{
    b558:	b510      	push	{r4, lr}
    b55a:	b086      	sub	sp, #24
    b55c:	4603      	mov	r3, r0
    b55e:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    b562:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b566:	4a29      	ldr	r2, [pc, #164]	; (b60c <FlexCAN_Error_IRQHandler+0xb4>)
    b568:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b56c:	9304      	str	r3, [sp, #16]
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    b56e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b572:	4a27      	ldr	r2, [pc, #156]	; (b610 <FlexCAN_Error_IRQHandler+0xb8>)
    b574:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b578:	9303      	str	r3, [sp, #12]
    uint32 u32ErrStatus = 0U;
    b57a:	2300      	movs	r3, #0
    b57c:	9305      	str	r3, [sp, #20]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    /* Check if the instance initialized */
    if (NULL_PTR != state)
    b57e:	9b03      	ldr	r3, [sp, #12]
    b580:	2b00      	cmp	r3, #0
    b582:	d03d      	beq.n	b600 <FlexCAN_Error_IRQHandler+0xa8>
    {
        /* Get error status to get value updated */
        u32ErrStatus = pBase->ESR1;
    b584:	9b04      	ldr	r3, [sp, #16]
    b586:	6a1b      	ldr	r3, [r3, #32]
    b588:	9305      	str	r3, [sp, #20]

        /* Check spurious interrupt */
        if (((uint32)0U != (u32ErrStatus & ((uint32)FLEXCAN_ESR1_ERRINT_MASK))) && ((uint32)0U != (pBase->CTRL1 & ((uint32)FLEXCAN_CTRL1_ERRMSK_MASK))))
    b58a:	9b05      	ldr	r3, [sp, #20]
    b58c:	f003 0302 	and.w	r3, r3, #2
    b590:	2b00      	cmp	r3, #0
    b592:	d019      	beq.n	b5c8 <FlexCAN_Error_IRQHandler+0x70>
    b594:	9b04      	ldr	r3, [sp, #16]
    b596:	685b      	ldr	r3, [r3, #4]
    b598:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
    b59c:	2b00      	cmp	r3, #0
    b59e:	d013      	beq.n	b5c8 <FlexCAN_Error_IRQHandler+0x70>
        {
            pBase->ESR1 = FLEXCAN_ESR1_ERRINT_MASK;
    b5a0:	9b04      	ldr	r3, [sp, #16]
    b5a2:	2202      	movs	r2, #2
    b5a4:	621a      	str	r2, [r3, #32]
            /* Invoke callback */
            if (state->error_callback != NULL_PTR)
    b5a6:	9b03      	ldr	r3, [sp, #12]
    b5a8:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
    b5ac:	2b00      	cmp	r3, #0
    b5ae:	d00b      	beq.n	b5c8 <FlexCAN_Error_IRQHandler+0x70>
            {
                state->error_callback(instance, FLEXCAN_EVENT_ERROR, u32ErrStatus, state);
    b5b0:	9b03      	ldr	r3, [sp, #12]
    b5b2:	f8d3 4208 	ldr.w	r4, [r3, #520]	; 0x208
    b5b6:	f89d 0007 	ldrb.w	r0, [sp, #7]
    b5ba:	9b03      	ldr	r3, [sp, #12]
    b5bc:	9a05      	ldr	r2, [sp, #20]
    b5be:	2105      	movs	r1, #5
    b5c0:	47a0      	blx	r4
            #if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
                /* Get error status to get value updated due to user may handle ESR1 register */
                u32ErrStatus = pBase->ESR1;
    b5c2:	9b04      	ldr	r3, [sp, #16]
    b5c4:	6a1b      	ldr	r3, [r3, #32]
    b5c6:	9305      	str	r3, [sp, #20]
            }
        }

    #if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        /* Check if this is spurious interrupt */
        if (((uint32)0U != (u32ErrStatus & ((uint32)FLEXCAN_ESR1_ERRINT_FAST_MASK))) && ((uint32)0U != (pBase->CTRL2 & ((uint32)FLEXCAN_CTRL2_ERRMSK_FAST_MASK))))
    b5c8:	9b05      	ldr	r3, [sp, #20]
    b5ca:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    b5ce:	2b00      	cmp	r3, #0
    b5d0:	d019      	beq.n	b606 <FlexCAN_Error_IRQHandler+0xae>
    b5d2:	9b04      	ldr	r3, [sp, #16]
    b5d4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    b5d6:	2b00      	cmp	r3, #0
    b5d8:	da15      	bge.n	b606 <FlexCAN_Error_IRQHandler+0xae>
        {
            pBase->ESR1 = FLEXCAN_ESR1_ERRINT_FAST_MASK;
    b5da:	9b04      	ldr	r3, [sp, #16]
    b5dc:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    b5e0:	621a      	str	r2, [r3, #32]
            /* Invoke callback */
            if (state->error_callback != NULL_PTR)
    b5e2:	9b03      	ldr	r3, [sp, #12]
    b5e4:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
    b5e8:	2b00      	cmp	r3, #0
    b5ea:	d00c      	beq.n	b606 <FlexCAN_Error_IRQHandler+0xae>
            {
                state->error_callback(instance, FLEXCAN_EVENT_ERROR_FAST, u32ErrStatus, state);
    b5ec:	9b03      	ldr	r3, [sp, #12]
    b5ee:	f8d3 4208 	ldr.w	r4, [r3, #520]	; 0x208
    b5f2:	f89d 0007 	ldrb.w	r0, [sp, #7]
    b5f6:	9b03      	ldr	r3, [sp, #12]
    b5f8:	9a05      	ldr	r2, [sp, #20]
    b5fa:	2106      	movs	r1, #6
    b5fc:	47a0      	blx	r4
    }
    else
    {
        (pBase->ESR1) = FLEXCAN_IP_ERROR_INT;
    }
}
    b5fe:	e002      	b.n	b606 <FlexCAN_Error_IRQHandler+0xae>
        (pBase->ESR1) = FLEXCAN_IP_ERROR_INT;
    b600:	9b04      	ldr	r3, [sp, #16]
    b602:	4a04      	ldr	r2, [pc, #16]	; (b614 <FlexCAN_Error_IRQHandler+0xbc>)
    b604:	621a      	str	r2, [r3, #32]
}
    b606:	bf00      	nop
    b608:	b006      	add	sp, #24
    b60a:	bd10      	pop	{r4, pc}
    b60c:	00015be8 	.word	0x00015be8
    b610:	1fff9048 	.word	0x1fff9048
    b614:	00300002 	.word	0x00300002

0000b618 <FlexCAN_BusOff_IRQHandler>:
 * This is not a public API as it is called whenever an interrupt occurs.
 *
 *END**************************************************************************/
/* implements CAN_X_BUSOFF_ISR_Activity */
void FlexCAN_BusOff_IRQHandler(uint8 instance)
{
    b618:	b510      	push	{r4, lr}
    b61a:	b086      	sub	sp, #24
    b61c:	4603      	mov	r3, r0
    b61e:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    b622:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b626:	4a3a      	ldr	r2, [pc, #232]	; (b710 <FlexCAN_BusOff_IRQHandler+0xf8>)
    b628:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b62c:	9304      	str	r3, [sp, #16]
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    b62e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b632:	4a38      	ldr	r2, [pc, #224]	; (b714 <FlexCAN_BusOff_IRQHandler+0xfc>)
    b634:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b638:	9303      	str	r3, [sp, #12]
    uint32 u32ErrStatus = 0U;
    b63a:	2300      	movs	r3, #0
    b63c:	9305      	str	r3, [sp, #20]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    /* Check If Driver initialized */
    if (NULL_PTR != state)
    b63e:	9b03      	ldr	r3, [sp, #12]
    b640:	2b00      	cmp	r3, #0
    b642:	d05f      	beq.n	b704 <FlexCAN_BusOff_IRQHandler+0xec>
    {
        /* Get error status to get value updated */
        u32ErrStatus = base->ESR1;
    b644:	9b04      	ldr	r3, [sp, #16]
    b646:	6a1b      	ldr	r3, [r3, #32]
    b648:	9305      	str	r3, [sp, #20]

        /* Check spurious interrupt */
        if (((uint32)0U != (u32ErrStatus & ((uint32)FLEXCAN_ESR1_TWRNINT_MASK))) && (0U != (base->CTRL1 & ((uint32)FLEXCAN_CTRL1_TWRNMSK_MASK))))
    b64a:	9b05      	ldr	r3, [sp, #20]
    b64c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
    b650:	2b00      	cmp	r3, #0
    b652:	d01a      	beq.n	b68a <FlexCAN_BusOff_IRQHandler+0x72>
    b654:	9b04      	ldr	r3, [sp, #16]
    b656:	685b      	ldr	r3, [r3, #4]
    b658:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    b65c:	2b00      	cmp	r3, #0
    b65e:	d014      	beq.n	b68a <FlexCAN_BusOff_IRQHandler+0x72>
        {
            base->ESR1 = FLEXCAN_ESR1_TWRNINT_MASK;
    b660:	9b04      	ldr	r3, [sp, #16]
    b662:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    b666:	621a      	str	r2, [r3, #32]
            /* Invoke callback */
            if (state->error_callback != NULL_PTR)
    b668:	9b03      	ldr	r3, [sp, #12]
    b66a:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
    b66e:	2b00      	cmp	r3, #0
    b670:	d00b      	beq.n	b68a <FlexCAN_BusOff_IRQHandler+0x72>
            {
                state->error_callback(instance, FLEXCAN_EVENT_TX_WARNING, u32ErrStatus, state);
    b672:	9b03      	ldr	r3, [sp, #12]
    b674:	f8d3 4208 	ldr.w	r4, [r3, #520]	; 0x208
    b678:	f89d 0007 	ldrb.w	r0, [sp, #7]
    b67c:	9b03      	ldr	r3, [sp, #12]
    b67e:	9a05      	ldr	r2, [sp, #20]
    b680:	2109      	movs	r1, #9
    b682:	47a0      	blx	r4
                /* Get error status to get value updated due to user may handle ESR1 register */
                u32ErrStatus = base->ESR1;
    b684:	9b04      	ldr	r3, [sp, #16]
    b686:	6a1b      	ldr	r3, [r3, #32]
    b688:	9305      	str	r3, [sp, #20]
            }
        }

        /* Check spurious interrupt */
        if (((uint32)0U != (u32ErrStatus & ((uint32)FLEXCAN_ESR1_RWRNINT_MASK))) && (0U != (base->CTRL1 & ((uint32)FLEXCAN_CTRL1_RWRNMSK_MASK))))
    b68a:	9b05      	ldr	r3, [sp, #20]
    b68c:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
    b690:	2b00      	cmp	r3, #0
    b692:	d01a      	beq.n	b6ca <FlexCAN_BusOff_IRQHandler+0xb2>
    b694:	9b04      	ldr	r3, [sp, #16]
    b696:	685b      	ldr	r3, [r3, #4]
    b698:	f403 6380 	and.w	r3, r3, #1024	; 0x400
    b69c:	2b00      	cmp	r3, #0
    b69e:	d014      	beq.n	b6ca <FlexCAN_BusOff_IRQHandler+0xb2>
        {
            base->ESR1 = FLEXCAN_ESR1_RWRNINT_MASK;
    b6a0:	9b04      	ldr	r3, [sp, #16]
    b6a2:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    b6a6:	621a      	str	r2, [r3, #32]
            /* Invoke callback */
            if (state->error_callback != NULL_PTR)
    b6a8:	9b03      	ldr	r3, [sp, #12]
    b6aa:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
    b6ae:	2b00      	cmp	r3, #0
    b6b0:	d00b      	beq.n	b6ca <FlexCAN_BusOff_IRQHandler+0xb2>
            {
                state->error_callback(instance, FLEXCAN_EVENT_RX_WARNING, u32ErrStatus, state);
    b6b2:	9b03      	ldr	r3, [sp, #12]
    b6b4:	f8d3 4208 	ldr.w	r4, [r3, #520]	; 0x208
    b6b8:	f89d 0007 	ldrb.w	r0, [sp, #7]
    b6bc:	9b03      	ldr	r3, [sp, #12]
    b6be:	9a05      	ldr	r2, [sp, #20]
    b6c0:	2108      	movs	r1, #8
    b6c2:	47a0      	blx	r4
                /* Get error status to get value updated due to user may handle ESR1 register */
                u32ErrStatus = base->ESR1;
    b6c4:	9b04      	ldr	r3, [sp, #16]
    b6c6:	6a1b      	ldr	r3, [r3, #32]
    b6c8:	9305      	str	r3, [sp, #20]
            }
        }

        /* Check spurious interrupt */
        if (((uint32)0U != (u32ErrStatus & ((uint32)FLEXCAN_ESR1_BOFFINT_MASK))) && ((uint32)0U != (base->CTRL1 & ((uint32)FLEXCAN_CTRL1_BOFFMSK_MASK))))
    b6ca:	9b05      	ldr	r3, [sp, #20]
    b6cc:	f003 0304 	and.w	r3, r3, #4
    b6d0:	2b00      	cmp	r3, #0
    b6d2:	d01a      	beq.n	b70a <FlexCAN_BusOff_IRQHandler+0xf2>
    b6d4:	9b04      	ldr	r3, [sp, #16]
    b6d6:	685b      	ldr	r3, [r3, #4]
    b6d8:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
    b6dc:	2b00      	cmp	r3, #0
    b6de:	d014      	beq.n	b70a <FlexCAN_BusOff_IRQHandler+0xf2>
        {
            base->ESR1 = FLEXCAN_ESR1_BOFFINT_MASK;
    b6e0:	9b04      	ldr	r3, [sp, #16]
    b6e2:	2204      	movs	r2, #4
    b6e4:	621a      	str	r2, [r3, #32]
            /* Invoke callback */
            if (state->error_callback != NULL_PTR)
    b6e6:	9b03      	ldr	r3, [sp, #12]
    b6e8:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
    b6ec:	2b00      	cmp	r3, #0
    b6ee:	d00c      	beq.n	b70a <FlexCAN_BusOff_IRQHandler+0xf2>
            {
                state->error_callback(instance, FLEXCAN_EVENT_BUSOFF, u32ErrStatus, state);
    b6f0:	9b03      	ldr	r3, [sp, #12]
    b6f2:	f8d3 4208 	ldr.w	r4, [r3, #520]	; 0x208
    b6f6:	f89d 0007 	ldrb.w	r0, [sp, #7]
    b6fa:	9b03      	ldr	r3, [sp, #12]
    b6fc:	9a05      	ldr	r2, [sp, #20]
    b6fe:	2107      	movs	r1, #7
    b700:	47a0      	blx	r4
    }
    else
    {
        base->ESR1 = FLEXCAN_IP_BUS_OFF_INT;
    }
}
    b702:	e002      	b.n	b70a <FlexCAN_BusOff_IRQHandler+0xf2>
        base->ESR1 = FLEXCAN_IP_BUS_OFF_INT;
    b704:	9b04      	ldr	r3, [sp, #16]
    b706:	4a04      	ldr	r2, [pc, #16]	; (b718 <FlexCAN_BusOff_IRQHandler+0x100>)
    b708:	621a      	str	r2, [r3, #32]
}
    b70a:	bf00      	nop
    b70c:	b006      	add	sp, #24
    b70e:	bd10      	pop	{r4, pc}
    b710:	00015be8 	.word	0x00015be8
    b714:	1fff9048 	.word	0x1fff9048
    b718:	000b0004 	.word	0x000b0004

0000b71c <FlexCAN_Ip_SendBlocking>:
                                              const Flexcan_Ip_DataInfoType * tx_info,
                                              uint32 msg_id,
                                              const uint8 * mb_data,
                                              uint32 timeout_ms
                                             )
{
    b71c:	b500      	push	{lr}
    b71e:	b091      	sub	sp, #68	; 0x44
    b720:	9204      	str	r2, [sp, #16]
    b722:	9303      	str	r3, [sp, #12]
    b724:	4603      	mov	r3, r0
    b726:	f88d 3017 	strb.w	r3, [sp, #23]
    b72a:	460b      	mov	r3, r1
    b72c:	f88d 3016 	strb.w	r3, [sp, #22]
    Flexcan_Ip_StatusType result;
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    b730:	f89d 3017 	ldrb.w	r3, [sp, #23]
    b734:	4a5f      	ldr	r2, [pc, #380]	; (b8b4 <FlexCAN_Ip_SendBlocking+0x198>)
    b736:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b73a:	930d      	str	r3, [sp, #52]	; 0x34
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    b73c:	f89d 3017 	ldrb.w	r3, [sp, #23]
    b740:	4a5d      	ldr	r2, [pc, #372]	; (b8b8 <FlexCAN_Ip_SendBlocking+0x19c>)
    b742:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b746:	930c      	str	r3, [sp, #48]	; 0x30

    uint32 timeStart = 0U;
    b748:	2300      	movs	r3, #0
    b74a:	9307      	str	r3, [sp, #28]
    uint32 timeElapsed = 0U;
    b74c:	2300      	movs	r3, #0
    b74e:	930e      	str	r3, [sp, #56]	; 0x38
    uint32 mS2Ticks = OsIf_MicrosToTicks((timeout_ms * 1000U), FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    b750:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    b752:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
    b756:	fb02 f303 	mul.w	r3, r2, r3
    b75a:	2100      	movs	r1, #0
    b75c:	4618      	mov	r0, r3
    b75e:	f7f6 fb69 	bl	1e34 <OsIf_MicrosToTicks>
    b762:	900b      	str	r0, [sp, #44]	; 0x2c
    uint32 uS2Ticks = 0U;
    b764:	2300      	movs	r3, #0
    b766:	930a      	str	r3, [sp, #40]	; 0x28
    uint32 flexcan_mb_config = 0;
    b768:	2300      	movs	r3, #0
    b76a:	9309      	str	r3, [sp, #36]	; 0x24

    volatile uint32 * flexcan_mb = NULL_PTR;
    b76c:	2300      	movs	r3, #0
    b76e:	9308      	str	r3, [sp, #32]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert(tx_info != NULL_PTR);
#endif

    result = FlexCAN_StartSendData(instance, mb_idx, tx_info, msg_id, mb_data);
    b770:	f89d 1016 	ldrb.w	r1, [sp, #22]
    b774:	f89d 0017 	ldrb.w	r0, [sp, #23]
    b778:	9b12      	ldr	r3, [sp, #72]	; 0x48
    b77a:	9300      	str	r3, [sp, #0]
    b77c:	9b03      	ldr	r3, [sp, #12]
    b77e:	9a04      	ldr	r2, [sp, #16]
    b780:	f7fe feaa 	bl	a4d8 <FlexCAN_StartSendData>
    b784:	900f      	str	r0, [sp, #60]	; 0x3c

    if (FLEXCAN_STATUS_SUCCESS == result)
    b786:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    b788:	2b00      	cmp	r3, #0
    b78a:	f040 808d 	bne.w	b8a8 <FlexCAN_Ip_SendBlocking+0x18c>
    {
        timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    b78e:	2000      	movs	r0, #0
    b790:	f7f6 fb04 	bl	1d9c <OsIf_GetCounter>
    b794:	4603      	mov	r3, r0
    b796:	9307      	str	r3, [sp, #28]
        while (FlexCAN_GetBuffStatusFlag(base, mb_idx) != 1U)
    b798:	e00f      	b.n	b7ba <FlexCAN_Ip_SendBlocking+0x9e>
        {
            timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    b79a:	ab07      	add	r3, sp, #28
    b79c:	2100      	movs	r1, #0
    b79e:	4618      	mov	r0, r3
    b7a0:	f7f6 fb15 	bl	1dce <OsIf_GetElapsed>
    b7a4:	4602      	mov	r2, r0
    b7a6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    b7a8:	4413      	add	r3, r2
    b7aa:	930e      	str	r3, [sp, #56]	; 0x38
            if (timeElapsed >= mS2Ticks)
    b7ac:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    b7ae:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    b7b0:	429a      	cmp	r2, r3
    b7b2:	d302      	bcc.n	b7ba <FlexCAN_Ip_SendBlocking+0x9e>
            {
                result = FLEXCAN_STATUS_TIMEOUT;
    b7b4:	2303      	movs	r3, #3
    b7b6:	930f      	str	r3, [sp, #60]	; 0x3c
                break;
    b7b8:	e008      	b.n	b7cc <FlexCAN_Ip_SendBlocking+0xb0>
        while (FlexCAN_GetBuffStatusFlag(base, mb_idx) != 1U)
    b7ba:	f89d 3016 	ldrb.w	r3, [sp, #22]
    b7be:	4619      	mov	r1, r3
    b7c0:	980d      	ldr	r0, [sp, #52]	; 0x34
    b7c2:	f7fe fab6 	bl	9d32 <FlexCAN_GetBuffStatusFlag>
    b7c6:	4603      	mov	r3, r0
    b7c8:	2b01      	cmp	r3, #1
    b7ca:	d1e6      	bne.n	b79a <FlexCAN_Ip_SendBlocking+0x7e>
            }
        }

        if ((FLEXCAN_STATUS_TIMEOUT == result) && (state->mbs[mb_idx].state != FLEXCAN_MB_IDLE))
    b7cc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    b7ce:	2b03      	cmp	r3, #3
    b7d0:	d15c      	bne.n	b88c <FlexCAN_Ip_SendBlocking+0x170>
    b7d2:	f89d 3016 	ldrb.w	r3, [sp, #22]
    b7d6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    b7d8:	011b      	lsls	r3, r3, #4
    b7da:	4413      	add	r3, r2
    b7dc:	3304      	adds	r3, #4
    b7de:	681b      	ldr	r3, [r3, #0]
    b7e0:	2b00      	cmp	r3, #0
    b7e2:	d053      	beq.n	b88c <FlexCAN_Ip_SendBlocking+0x170>
        {
                /* Clear message buffer flag */
                FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    b7e4:	f89d 3016 	ldrb.w	r3, [sp, #22]
    b7e8:	4619      	mov	r1, r3
    b7ea:	980d      	ldr	r0, [sp, #52]	; 0x34
    b7ec:	f7fe fa8e 	bl	9d0c <FlexCAN_ClearMsgBuffIntStatusFlag>
                flexcan_mb = FlexCAN_GetMsgBuffRegion(base, mb_idx);
    b7f0:	f89d 3016 	ldrb.w	r3, [sp, #22]
    b7f4:	4619      	mov	r1, r3
    b7f6:	980d      	ldr	r0, [sp, #52]	; 0x34
    b7f8:	f001 f968 	bl	cacc <FlexCAN_GetMsgBuffRegion>
    b7fc:	9008      	str	r0, [sp, #32]
                flexcan_mb_config = * flexcan_mb;
    b7fe:	9b08      	ldr	r3, [sp, #32]
    b800:	681b      	ldr	r3, [r3, #0]
    b802:	9309      	str	r3, [sp, #36]	; 0x24
                /* Reset the code */
                flexcan_mb_config &= (uint32)(~FLEXCAN_IP_CS_CODE_MASK);
    b804:	9b09      	ldr	r3, [sp, #36]	; 0x24
    b806:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    b80a:	9309      	str	r3, [sp, #36]	; 0x24
                flexcan_mb_config |= ((uint32)(((uint32)FLEXCAN_TX_ABORT & (uint32)0x1F) << (uint8)FLEXCAN_IP_CS_CODE_SHIFT) & (uint32)FLEXCAN_IP_CS_CODE_MASK);
    b80c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    b80e:	f043 6310 	orr.w	r3, r3, #150994944	; 0x9000000
    b812:	9309      	str	r3, [sp, #36]	; 0x24
                *flexcan_mb = flexcan_mb_config;
    b814:	9b08      	ldr	r3, [sp, #32]
    b816:	9a09      	ldr	r2, [sp, #36]	; 0x24
    b818:	601a      	str	r2, [r3, #0]

                /* Wait to finish abort operation */
                uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    b81a:	2100      	movs	r1, #0
    b81c:	4827      	ldr	r0, [pc, #156]	; (b8bc <FlexCAN_Ip_SendBlocking+0x1a0>)
    b81e:	f7f6 fb09 	bl	1e34 <OsIf_MicrosToTicks>
    b822:	900a      	str	r0, [sp, #40]	; 0x28
                timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    b824:	2000      	movs	r0, #0
    b826:	f7f6 fab9 	bl	1d9c <OsIf_GetCounter>
    b82a:	4603      	mov	r3, r0
    b82c:	9307      	str	r3, [sp, #28]
                 timeElapsed = 0U;
    b82e:	2300      	movs	r3, #0
    b830:	930e      	str	r3, [sp, #56]	; 0x38
                while (0U == FlexCAN_GetBuffStatusFlag(base, mb_idx))
    b832:	e00f      	b.n	b854 <FlexCAN_Ip_SendBlocking+0x138>
                {
                    timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    b834:	ab07      	add	r3, sp, #28
    b836:	2100      	movs	r1, #0
    b838:	4618      	mov	r0, r3
    b83a:	f7f6 fac8 	bl	1dce <OsIf_GetElapsed>
    b83e:	4602      	mov	r2, r0
    b840:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    b842:	4413      	add	r3, r2
    b844:	930e      	str	r3, [sp, #56]	; 0x38
                    if (timeElapsed >= uS2Ticks)
    b846:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    b848:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    b84a:	429a      	cmp	r2, r3
    b84c:	d302      	bcc.n	b854 <FlexCAN_Ip_SendBlocking+0x138>
                    {
                        result = FLEXCAN_STATUS_TIMEOUT;
    b84e:	2303      	movs	r3, #3
    b850:	930f      	str	r3, [sp, #60]	; 0x3c
                        break;
    b852:	e008      	b.n	b866 <FlexCAN_Ip_SendBlocking+0x14a>
                while (0U == FlexCAN_GetBuffStatusFlag(base, mb_idx))
    b854:	f89d 3016 	ldrb.w	r3, [sp, #22]
    b858:	4619      	mov	r1, r3
    b85a:	980d      	ldr	r0, [sp, #52]	; 0x34
    b85c:	f7fe fa69 	bl	9d32 <FlexCAN_GetBuffStatusFlag>
    b860:	4603      	mov	r3, r0
    b862:	2b00      	cmp	r3, #0
    b864:	d0e6      	beq.n	b834 <FlexCAN_Ip_SendBlocking+0x118>
                    }
                }

                flexcan_mb_config = *flexcan_mb;
    b866:	9b08      	ldr	r3, [sp, #32]
    b868:	681b      	ldr	r3, [r3, #0]
    b86a:	9309      	str	r3, [sp, #36]	; 0x24
                /* Check if the MBs have been safely Inactivated */
                if ((uint32)FLEXCAN_TX_INACTIVE == ((flexcan_mb_config & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT))
    b86c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    b86e:	0e1b      	lsrs	r3, r3, #24
    b870:	f003 030f 	and.w	r3, r3, #15
    b874:	2b08      	cmp	r3, #8
    b876:	d101      	bne.n	b87c <FlexCAN_Ip_SendBlocking+0x160>
                {
                    /* Transmission have occurred */
                    result = FLEXCAN_STATUS_SUCCESS;
    b878:	2300      	movs	r3, #0
    b87a:	930f      	str	r3, [sp, #60]	; 0x3c
                }

                if ((uint32)FLEXCAN_TX_ABORT == ((flexcan_mb_config & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT))
    b87c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    b87e:	0e1b      	lsrs	r3, r3, #24
    b880:	f003 030f 	and.w	r3, r3, #15
    b884:	2b09      	cmp	r3, #9
    b886:	d101      	bne.n	b88c <FlexCAN_Ip_SendBlocking+0x170>
                {
                    /* Transmission have been aborted */
                    result = FLEXCAN_STATUS_TIMEOUT;
    b888:	2303      	movs	r3, #3
    b88a:	930f      	str	r3, [sp, #60]	; 0x3c
                }
        }

        /* Clear message buffer flag */
        FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    b88c:	f89d 3016 	ldrb.w	r3, [sp, #22]
    b890:	4619      	mov	r1, r3
    b892:	980d      	ldr	r0, [sp, #52]	; 0x34
    b894:	f7fe fa3a 	bl	9d0c <FlexCAN_ClearMsgBuffIntStatusFlag>

        state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;
    b898:	f89d 3016 	ldrb.w	r3, [sp, #22]
    b89c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    b89e:	011b      	lsls	r3, r3, #4
    b8a0:	4413      	add	r3, r2
    b8a2:	3304      	adds	r3, #4
    b8a4:	2200      	movs	r2, #0
    b8a6:	601a      	str	r2, [r3, #0]
    }
    return result;
    b8a8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
}
    b8aa:	4618      	mov	r0, r3
    b8ac:	b011      	add	sp, #68	; 0x44
    b8ae:	f85d fb04 	ldr.w	pc, [sp], #4
    b8b2:	bf00      	nop
    b8b4:	00015be8 	.word	0x00015be8
    b8b8:	1fff9048 	.word	0x1fff9048
    b8bc:	000f4240 	.word	0x000f4240

0000b8c0 <FlexCAN_Ip_SetRxMbGlobalMask_Privileged>:
 *
 *END**************************************************************************/

/* implements FlexCAN_Ip_SetRxMbGlobalMask_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetRxMbGlobalMask_Privileged(uint8 instance, uint32 mask)
{
    b8c0:	b500      	push	{lr}
    b8c2:	b087      	sub	sp, #28
    b8c4:	4603      	mov	r3, r0
    b8c6:	9100      	str	r1, [sp, #0]
    b8c8:	f88d 3007 	strb.w	r3, [sp, #7]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    b8cc:	2300      	movs	r3, #0
    b8ce:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    b8d0:	2300      	movs	r3, #0
    b8d2:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    b8d4:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b8d8:	4a1c      	ldr	r2, [pc, #112]	; (b94c <FlexCAN_Ip_SetRxMbGlobalMask_Privileged+0x8c>)
    b8da:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b8de:	9303      	str	r3, [sp, #12]
#endif

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    b8e0:	9803      	ldr	r0, [sp, #12]
    b8e2:	f7fe f9b9 	bl	9c58 <FlexCAN_IsEnabled>
    b8e6:	4603      	mov	r3, r0
    b8e8:	2b00      	cmp	r3, #0
    b8ea:	bf14      	ite	ne
    b8ec:	2301      	movne	r3, #1
    b8ee:	2300      	moveq	r3, #0
    b8f0:	b2db      	uxtb	r3, r3
    b8f2:	f083 0301 	eor.w	r3, r3, #1
    b8f6:	b2db      	uxtb	r3, r3
    b8f8:	f88d 300b 	strb.w	r3, [sp, #11]
    b8fc:	f89d 300b 	ldrb.w	r3, [sp, #11]
    b900:	f003 0301 	and.w	r3, r3, #1
    b904:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    b908:	f89d 300b 	ldrb.w	r3, [sp, #11]
    b90c:	2b00      	cmp	r3, #0
    b90e:	d003      	beq.n	b918 <FlexCAN_Ip_SetRxMbGlobalMask_Privileged+0x58>
    {
        result = FlexCAN_Enable(pBase);
    b910:	9803      	ldr	r0, [sp, #12]
    b912:	f001 f9c3 	bl	cc9c <FlexCAN_Enable>
    b916:	9005      	str	r0, [sp, #20]
    if ((FALSE == freeze) && (FLEXCAN_STATUS_SUCCESS == result))
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif
    if (FLEXCAN_STATUS_SUCCESS == result)
    b918:	9b05      	ldr	r3, [sp, #20]
    b91a:	2b00      	cmp	r3, #0
    b91c:	d103      	bne.n	b926 <FlexCAN_Ip_SetRxMbGlobalMask_Privileged+0x66>
    {
        FlexCAN_SetRxMsgBuffGlobalMask(pBase, mask);
    b91e:	9900      	ldr	r1, [sp, #0]
    b920:	9803      	ldr	r0, [sp, #12]
    b922:	f7fe fbc3 	bl	a0ac <FlexCAN_SetRxMsgBuffGlobalMask>
    }

    if (TRUE == disabled)
    b926:	f89d 300b 	ldrb.w	r3, [sp, #11]
    b92a:	2b00      	cmp	r3, #0
    b92c:	d008      	beq.n	b940 <FlexCAN_Ip_SetRxMbGlobalMask_Privileged+0x80>
    {
        status = FlexCAN_Disable(pBase);
    b92e:	9803      	ldr	r0, [sp, #12]
    b930:	f001 fa32 	bl	cd98 <FlexCAN_Disable>
    b934:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    b936:	9b04      	ldr	r3, [sp, #16]
    b938:	2b00      	cmp	r3, #0
    b93a:	d001      	beq.n	b940 <FlexCAN_Ip_SetRxMbGlobalMask_Privileged+0x80>
        {
            result = status;
    b93c:	9b04      	ldr	r3, [sp, #16]
    b93e:	9305      	str	r3, [sp, #20]
        }
    }
    return result;
    b940:	9b05      	ldr	r3, [sp, #20]
}
    b942:	4618      	mov	r0, r3
    b944:	b007      	add	sp, #28
    b946:	f85d fb04 	ldr.w	pc, [sp], #4
    b94a:	bf00      	nop
    b94c:	00015be8 	.word	0x00015be8

0000b950 <FlexCAN_Ip_EnterFreezeMode_Privileged>:
 * Description   : Enter Driver In freeze Mode.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_EnterFreezeMode_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_EnterFreezeMode_Privileged(uint8 instance)
{
    b950:	b500      	push	{lr}
    b952:	b085      	sub	sp, #20
    b954:	4603      	mov	r3, r0
    b956:	f88d 3007 	strb.w	r3, [sp, #7]
        FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    b95a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b95e:	4a06      	ldr	r2, [pc, #24]	; (b978 <FlexCAN_Ip_EnterFreezeMode_Privileged+0x28>)
    b960:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b964:	9303      	str	r3, [sp, #12]
        return FlexCAN_EnterFreezeMode(base);
    b966:	9803      	ldr	r0, [sp, #12]
    b968:	f001 f94c 	bl	cc04 <FlexCAN_EnterFreezeMode>
    b96c:	4603      	mov	r3, r0
}
    b96e:	4618      	mov	r0, r3
    b970:	b005      	add	sp, #20
    b972:	f85d fb04 	ldr.w	pc, [sp], #4
    b976:	bf00      	nop
    b978:	00015be8 	.word	0x00015be8

0000b97c <FlexCAN_Ip_ExitFreezeMode_Privileged>:
 * Description   : Exit Driver from freeze Mode.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_ExitFreezeMode_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_ExitFreezeMode_Privileged(uint8 instance)
{
    b97c:	b500      	push	{lr}
    b97e:	b085      	sub	sp, #20
    b980:	4603      	mov	r3, r0
    b982:	f88d 3007 	strb.w	r3, [sp, #7]
        FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    b986:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b98a:	4a06      	ldr	r2, [pc, #24]	; (b9a4 <FlexCAN_Ip_ExitFreezeMode_Privileged+0x28>)
    b98c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b990:	9303      	str	r3, [sp, #12]
        return FlexCAN_ExitFreezeMode(base);
    b992:	9803      	ldr	r0, [sp, #12]
    b994:	f001 f9be 	bl	cd14 <FlexCAN_ExitFreezeMode>
    b998:	4603      	mov	r3, r0
}
    b99a:	4618      	mov	r0, r3
    b99c:	b005      	add	sp, #20
    b99e:	f85d fb04 	ldr.w	pc, [sp], #4
    b9a2:	bf00      	nop
    b9a4:	00015be8 	.word	0x00015be8

0000b9a8 <FlexCAN_Ip_SetRxIndividualMask_Privileged>:
 * Description   : Set Rx individual mask as absolute value provided by mask parameter
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetRxIndividualMask_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetRxIndividualMask_Privileged(uint8 instance, uint8 mb_idx, uint32 mask)
{
    b9a8:	b500      	push	{lr}
    b9aa:	b087      	sub	sp, #28
    b9ac:	4603      	mov	r3, r0
    b9ae:	9200      	str	r2, [sp, #0]
    b9b0:	f88d 3007 	strb.w	r3, [sp, #7]
    b9b4:	460b      	mov	r3, r1
    b9b6:	f88d 3006 	strb.w	r3, [sp, #6]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    b9ba:	2300      	movs	r3, #0
    b9bc:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    b9be:	2300      	movs	r3, #0
    b9c0:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    b9c2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    b9c6:	4a1e      	ldr	r2, [pc, #120]	; (ba40 <FlexCAN_Ip_SetRxIndividualMask_Privileged+0x98>)
    b9c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    b9cc:	9303      	str	r3, [sp, #12]
    }
    else
    {
#endif

    boolean disabled = !FlexCAN_IsEnabled(pBase);
    b9ce:	9803      	ldr	r0, [sp, #12]
    b9d0:	f7fe f942 	bl	9c58 <FlexCAN_IsEnabled>
    b9d4:	4603      	mov	r3, r0
    b9d6:	2b00      	cmp	r3, #0
    b9d8:	bf14      	ite	ne
    b9da:	2301      	movne	r3, #1
    b9dc:	2300      	moveq	r3, #0
    b9de:	b2db      	uxtb	r3, r3
    b9e0:	f083 0301 	eor.w	r3, r3, #1
    b9e4:	b2db      	uxtb	r3, r3
    b9e6:	f88d 300b 	strb.w	r3, [sp, #11]
    b9ea:	f89d 300b 	ldrb.w	r3, [sp, #11]
    b9ee:	f003 0301 	and.w	r3, r3, #1
    b9f2:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    b9f6:	f89d 300b 	ldrb.w	r3, [sp, #11]
    b9fa:	2b00      	cmp	r3, #0
    b9fc:	d003      	beq.n	ba06 <FlexCAN_Ip_SetRxIndividualMask_Privileged+0x5e>
    {
        result = FlexCAN_Enable(pBase);
    b9fe:	9803      	ldr	r0, [sp, #12]
    ba00:	f001 f94c 	bl	cc9c <FlexCAN_Enable>
    ba04:	9005      	str	r0, [sp, #20]
    if ((FALSE == freeze) && (FLEXCAN_STATUS_SUCCESS == result))
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif
    if (FLEXCAN_STATUS_SUCCESS == result)
    ba06:	9b05      	ldr	r3, [sp, #20]
    ba08:	2b00      	cmp	r3, #0
    ba0a:	d106      	bne.n	ba1a <FlexCAN_Ip_SetRxIndividualMask_Privileged+0x72>
    {
        FlexCAN_SetRxIndividualMask(pBase, mb_idx, mask);
    ba0c:	f89d 3006 	ldrb.w	r3, [sp, #6]
    ba10:	9a00      	ldr	r2, [sp, #0]
    ba12:	4619      	mov	r1, r3
    ba14:	9803      	ldr	r0, [sp, #12]
    ba16:	f7fe fb52 	bl	a0be <FlexCAN_SetRxIndividualMask>
    }

    if (TRUE == disabled)
    ba1a:	f89d 300b 	ldrb.w	r3, [sp, #11]
    ba1e:	2b00      	cmp	r3, #0
    ba20:	d008      	beq.n	ba34 <FlexCAN_Ip_SetRxIndividualMask_Privileged+0x8c>
    {
        status = FlexCAN_Disable(pBase);
    ba22:	9803      	ldr	r0, [sp, #12]
    ba24:	f001 f9b8 	bl	cd98 <FlexCAN_Disable>
    ba28:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    ba2a:	9b04      	ldr	r3, [sp, #16]
    ba2c:	2b00      	cmp	r3, #0
    ba2e:	d001      	beq.n	ba34 <FlexCAN_Ip_SetRxIndividualMask_Privileged+0x8c>
        {
            result = status;
    ba30:	9b04      	ldr	r3, [sp, #16]
    ba32:	9305      	str	r3, [sp, #20]
        }
    }
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    }
#endif
    return result;
    ba34:	9b05      	ldr	r3, [sp, #20]
}
    ba36:	4618      	mov	r0, r3
    ba38:	b007      	add	sp, #28
    ba3a:	f85d fb04 	ldr.w	pc, [sp], #4
    ba3e:	bf00      	nop
    ba40:	00015be8 	.word	0x00015be8

0000ba44 <FlexCAN_Ip_SetRxFifoGlobalMask_Privileged>:
 * Description   : Set RxFifo Global Mask.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetRxFifoGlobalMask_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetRxFifoGlobalMask_Privileged(uint8 instance, uint32 mask)
{
    ba44:	b500      	push	{lr}
    ba46:	b087      	sub	sp, #28
    ba48:	4603      	mov	r3, r0
    ba4a:	9100      	str	r1, [sp, #0]
    ba4c:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    ba50:	2300      	movs	r3, #0
    ba52:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    ba54:	2300      	movs	r3, #0
    ba56:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    ba58:	f89d 3007 	ldrb.w	r3, [sp, #7]
    ba5c:	4a1c      	ldr	r2, [pc, #112]	; (bad0 <FlexCAN_Ip_SetRxFifoGlobalMask_Privileged+0x8c>)
    ba5e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ba62:	9303      	str	r3, [sp, #12]
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    ba64:	9803      	ldr	r0, [sp, #12]
    ba66:	f7fe f8f7 	bl	9c58 <FlexCAN_IsEnabled>
    ba6a:	4603      	mov	r3, r0
    ba6c:	2b00      	cmp	r3, #0
    ba6e:	bf14      	ite	ne
    ba70:	2301      	movne	r3, #1
    ba72:	2300      	moveq	r3, #0
    ba74:	b2db      	uxtb	r3, r3
    ba76:	f083 0301 	eor.w	r3, r3, #1
    ba7a:	b2db      	uxtb	r3, r3
    ba7c:	f88d 300b 	strb.w	r3, [sp, #11]
    ba80:	f89d 300b 	ldrb.w	r3, [sp, #11]
    ba84:	f003 0301 	and.w	r3, r3, #1
    ba88:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    ba8c:	f89d 300b 	ldrb.w	r3, [sp, #11]
    ba90:	2b00      	cmp	r3, #0
    ba92:	d003      	beq.n	ba9c <FlexCAN_Ip_SetRxFifoGlobalMask_Privileged+0x58>
    {
        result = FlexCAN_Enable(pBase);
    ba94:	9803      	ldr	r0, [sp, #12]
    ba96:	f001 f901 	bl	cc9c <FlexCAN_Enable>
    ba9a:	9005      	str	r0, [sp, #20]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    ba9c:	9b05      	ldr	r3, [sp, #20]
    ba9e:	2b00      	cmp	r3, #0
    baa0:	d103      	bne.n	baaa <FlexCAN_Ip_SetRxFifoGlobalMask_Privileged+0x66>
    {
        FlexCAN_SetRxFifoGlobalMask(pBase, mask);
    baa2:	9900      	ldr	r1, [sp, #0]
    baa4:	9803      	ldr	r0, [sp, #12]
    baa6:	f7fe f8a7 	bl	9bf8 <FlexCAN_SetRxFifoGlobalMask>
    }

    if (TRUE == disabled)
    baaa:	f89d 300b 	ldrb.w	r3, [sp, #11]
    baae:	2b00      	cmp	r3, #0
    bab0:	d008      	beq.n	bac4 <FlexCAN_Ip_SetRxFifoGlobalMask_Privileged+0x80>
    {
        status = FlexCAN_Disable(pBase);
    bab2:	9803      	ldr	r0, [sp, #12]
    bab4:	f001 f970 	bl	cd98 <FlexCAN_Disable>
    bab8:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    baba:	9b04      	ldr	r3, [sp, #16]
    babc:	2b00      	cmp	r3, #0
    babe:	d001      	beq.n	bac4 <FlexCAN_Ip_SetRxFifoGlobalMask_Privileged+0x80>
        {
            result = status;
    bac0:	9b04      	ldr	r3, [sp, #16]
    bac2:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    bac4:	9b05      	ldr	r3, [sp, #20]
}
    bac6:	4618      	mov	r0, r3
    bac8:	b007      	add	sp, #28
    baca:	f85d fb04 	ldr.w	pc, [sp], #4
    bace:	bf00      	nop
    bad0:	00015be8 	.word	0x00015be8

0000bad4 <FlexCAN_Ip_Deinit_Privileged>:
 * This function will disable all FlexCAN interrupts, and disable the FlexCAN.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_Deinit_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_Deinit_Privileged(uint8 instance)
{
    bad4:	b500      	push	{lr}
    bad6:	b085      	sub	sp, #20
    bad8:	4603      	mov	r3, r0
    bada:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    bade:	f89d 3007 	ldrb.w	r3, [sp, #7]
    bae2:	4a0e      	ldr	r2, [pc, #56]	; (bb1c <FlexCAN_Ip_Deinit_Privileged+0x48>)
    bae4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bae8:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    /* Enter Freeze Mode Required before to enter Disabled Mode */
    result = FlexCAN_EnterFreezeMode(base);
    baea:	9803      	ldr	r0, [sp, #12]
    baec:	f001 f88a 	bl	cc04 <FlexCAN_EnterFreezeMode>
    baf0:	9002      	str	r0, [sp, #8]
    if (FLEXCAN_STATUS_SUCCESS == result)
    baf2:	9b02      	ldr	r3, [sp, #8]
    baf4:	2b00      	cmp	r3, #0
    baf6:	d10b      	bne.n	bb10 <FlexCAN_Ip_Deinit_Privileged+0x3c>
    {
        /* Reset registers */
        FlexCAN_SetRegDefaultVal(base);
    baf8:	9803      	ldr	r0, [sp, #12]
    bafa:	f7fe fb18 	bl	a12e <FlexCAN_SetRegDefaultVal>
        /* wait for disable */
        (void)FlexCAN_Disable(base);
    bafe:	9803      	ldr	r0, [sp, #12]
    bb00:	f001 f94a 	bl	cd98 <FlexCAN_Disable>
        /* Clear state pointer that is checked by FLEXCAN_DRV_Init */
        Flexcan_Ip_apxState[instance] = NULL_PTR;
    bb04:	f89d 3007 	ldrb.w	r3, [sp, #7]
    bb08:	4a05      	ldr	r2, [pc, #20]	; (bb20 <FlexCAN_Ip_Deinit_Privileged+0x4c>)
    bb0a:	2100      	movs	r1, #0
    bb0c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
            OsIf_Trusted_Call1param(FlexCAN_ClrUserAccessAllowed, base);
        }
    #endif
    }

    return result;
    bb10:	9b02      	ldr	r3, [sp, #8]
}
    bb12:	4618      	mov	r0, r3
    bb14:	b005      	add	sp, #20
    bb16:	f85d fb04 	ldr.w	pc, [sp], #4
    bb1a:	bf00      	nop
    bb1c:	00015be8 	.word	0x00015be8
    bb20:	1fff9048 	.word	0x1fff9048

0000bb24 <FlexCAN_Ip_MainFunctionRead>:
 * This function read the messages received as pulling or if the Interrupts are disabled.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_MainFunctionRead_Activity */
void FlexCAN_Ip_MainFunctionRead(uint8 instance, uint8 mb_idx)
{
    bb24:	b500      	push	{lr}
    bb26:	b085      	sub	sp, #20
    bb28:	4603      	mov	r3, r0
    bb2a:	460a      	mov	r2, r1
    bb2c:	f88d 3007 	strb.w	r3, [sp, #7]
    bb30:	4613      	mov	r3, r2
    bb32:	f88d 3006 	strb.w	r3, [sp, #6]
    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    bb36:	f89d 3007 	ldrb.w	r3, [sp, #7]
    bb3a:	4a22      	ldr	r2, [pc, #136]	; (bbc4 <FlexCAN_Ip_MainFunctionRead+0xa0>)
    bb3c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bb40:	9303      	str	r3, [sp, #12]
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    bb42:	f89d 3007 	ldrb.w	r3, [sp, #7]
    bb46:	4a20      	ldr	r2, [pc, #128]	; (bbc8 <FlexCAN_Ip_MainFunctionRead+0xa4>)
    bb48:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bb4c:	9302      	str	r3, [sp, #8]
        }
    }
    else
    {
#endif /* (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) */
        if ((TRUE == state->bIsLegacyFifoEn) && (mb_idx <= FLEXCAN_IP_LEGACY_RXFIFO_OVERFLOW))
    bb4e:	9b02      	ldr	r3, [sp, #8]
    bb50:	f893 3214 	ldrb.w	r3, [r3, #532]	; 0x214
    bb54:	2b00      	cmp	r3, #0
    bb56:	d015      	beq.n	bb84 <FlexCAN_Ip_MainFunctionRead+0x60>
    bb58:	f89d 3006 	ldrb.w	r3, [sp, #6]
    bb5c:	2b07      	cmp	r3, #7
    bb5e:	d811      	bhi.n	bb84 <FlexCAN_Ip_MainFunctionRead+0x60>
        {
            /* just process available legacy fifo event only */
            if ((uint8)FLEXCAN_IP_MB_HANDLE_RXFIFO == mb_idx)
    bb60:	f89d 3006 	ldrb.w	r3, [sp, #6]
    bb64:	2b00      	cmp	r3, #0
    bb66:	d128      	bne.n	bbba <FlexCAN_Ip_MainFunctionRead+0x96>
            {
                if (FlexCAN_GetBuffStatusFlag(base, FLEXCAN_IP_LEGACY_RXFIFO_FRAME_AVAILABLE) != 0U)
    bb68:	2105      	movs	r1, #5
    bb6a:	9803      	ldr	r0, [sp, #12]
    bb6c:	f7fe f8e1 	bl	9d32 <FlexCAN_GetBuffStatusFlag>
    bb70:	4603      	mov	r3, r0
    bb72:	2b00      	cmp	r3, #0
    bb74:	d021      	beq.n	bbba <FlexCAN_Ip_MainFunctionRead+0x96>
                {
                    FlexCAN_IRQHandlerRxFIFO(instance, FLEXCAN_IP_LEGACY_RXFIFO_FRAME_AVAILABLE);
    bb76:	f89d 3007 	ldrb.w	r3, [sp, #7]
    bb7a:	2105      	movs	r1, #5
    bb7c:	4618      	mov	r0, r3
    bb7e:	f7fe ff17 	bl	a9b0 <FlexCAN_IRQHandlerRxFIFO>
            if ((uint8)FLEXCAN_IP_MB_HANDLE_RXFIFO == mb_idx)
    bb82:	e01a      	b.n	bbba <FlexCAN_Ip_MainFunctionRead+0x96>
                }
            }
        }
        else
        {
            if (FlexCAN_GetBuffStatusFlag(base, mb_idx) != 0U)
    bb84:	f89d 3006 	ldrb.w	r3, [sp, #6]
    bb88:	4619      	mov	r1, r3
    bb8a:	9803      	ldr	r0, [sp, #12]
    bb8c:	f7fe f8d1 	bl	9d32 <FlexCAN_GetBuffStatusFlag>
    bb90:	4603      	mov	r3, r0
    bb92:	2b00      	cmp	r3, #0
    bb94:	d012      	beq.n	bbbc <FlexCAN_Ip_MainFunctionRead+0x98>
            {
                /* Check mailbox completed reception */
                if (FLEXCAN_MB_RX_BUSY == state->mbs[mb_idx].state)
    bb96:	f89d 3006 	ldrb.w	r3, [sp, #6]
    bb9a:	9a02      	ldr	r2, [sp, #8]
    bb9c:	011b      	lsls	r3, r3, #4
    bb9e:	4413      	add	r3, r2
    bba0:	3304      	adds	r3, #4
    bba2:	681b      	ldr	r3, [r3, #0]
    bba4:	2b01      	cmp	r3, #1
    bba6:	d109      	bne.n	bbbc <FlexCAN_Ip_MainFunctionRead+0x98>
                {
                    FlexCAN_IRQHandlerRxMB(instance, mb_idx);
    bba8:	f89d 2006 	ldrb.w	r2, [sp, #6]
    bbac:	f89d 3007 	ldrb.w	r3, [sp, #7]
    bbb0:	4611      	mov	r1, r2
    bbb2:	4618      	mov	r0, r3
    bbb4:	f7fe fd74 	bl	a6a0 <FlexCAN_IRQHandlerRxMB>
            }
        }
#if (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON)
    }
#endif /* (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) */
}
    bbb8:	e000      	b.n	bbbc <FlexCAN_Ip_MainFunctionRead+0x98>
            if ((uint8)FLEXCAN_IP_MB_HANDLE_RXFIFO == mb_idx)
    bbba:	bf00      	nop
}
    bbbc:	bf00      	nop
    bbbe:	b005      	add	sp, #20
    bbc0:	f85d fb04 	ldr.w	pc, [sp], #4
    bbc4:	00015be8 	.word	0x00015be8
    bbc8:	1fff9048 	.word	0x1fff9048

0000bbcc <FlexCAN_Ip_MainFunctionBusOff_Privileged>:
 * This function check the bus off event.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_MainFunctionBusOff_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_MainFunctionBusOff_Privileged(uint8 instance)
{
    bbcc:	b510      	push	{r4, lr}
    bbce:	b086      	sub	sp, #24
    bbd0:	4603      	mov	r3, r0
    bbd2:	f88d 3007 	strb.w	r3, [sp, #7]
    Flexcan_Ip_StatusType eRetVal = FLEXCAN_STATUS_ERROR;
    bbd6:	2301      	movs	r3, #1
    bbd8:	9305      	str	r3, [sp, #20]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    bbda:	f89d 3007 	ldrb.w	r3, [sp, #7]
    bbde:	4a15      	ldr	r2, [pc, #84]	; (bc34 <FlexCAN_Ip_MainFunctionBusOff_Privileged+0x68>)
    bbe0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bbe4:	9304      	str	r3, [sp, #16]
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    bbe6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    bbea:	4a13      	ldr	r2, [pc, #76]	; (bc38 <FlexCAN_Ip_MainFunctionBusOff_Privileged+0x6c>)
    bbec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bbf0:	9303      	str	r3, [sp, #12]
    uint32 u32ErrStatus = 0U;
    bbf2:	2300      	movs	r3, #0
    bbf4:	9302      	str	r3, [sp, #8]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    /* Get error status */
    u32ErrStatus = base->ESR1;
    bbf6:	9b04      	ldr	r3, [sp, #16]
    bbf8:	6a1b      	ldr	r3, [r3, #32]
    bbfa:	9302      	str	r3, [sp, #8]

    if (0U != (u32ErrStatus & FLEXCAN_ESR1_BOFFINT_MASK))
    bbfc:	9b02      	ldr	r3, [sp, #8]
    bbfe:	f003 0304 	and.w	r3, r3, #4
    bc02:	2b00      	cmp	r3, #0
    bc04:	d012      	beq.n	bc2c <FlexCAN_Ip_MainFunctionBusOff_Privileged+0x60>
    {
        /* Invoke callback */
        if (state->error_callback != NULL_PTR)
    bc06:	9b03      	ldr	r3, [sp, #12]
    bc08:	f8d3 3208 	ldr.w	r3, [r3, #520]	; 0x208
    bc0c:	2b00      	cmp	r3, #0
    bc0e:	d008      	beq.n	bc22 <FlexCAN_Ip_MainFunctionBusOff_Privileged+0x56>
        {
            state->error_callback(instance, FLEXCAN_EVENT_BUSOFF, u32ErrStatus, state);
    bc10:	9b03      	ldr	r3, [sp, #12]
    bc12:	f8d3 4208 	ldr.w	r4, [r3, #520]	; 0x208
    bc16:	f89d 0007 	ldrb.w	r0, [sp, #7]
    bc1a:	9b03      	ldr	r3, [sp, #12]
    bc1c:	9a02      	ldr	r2, [sp, #8]
    bc1e:	2107      	movs	r1, #7
    bc20:	47a0      	blx	r4
        }
        /* Clear BusOff Status Flag */
        base->ESR1 = FLEXCAN_ESR1_BOFFINT_MASK;
    bc22:	9b04      	ldr	r3, [sp, #16]
    bc24:	2204      	movs	r2, #4
    bc26:	621a      	str	r2, [r3, #32]
        eRetVal = FLEXCAN_STATUS_SUCCESS;
    bc28:	2300      	movs	r3, #0
    bc2a:	9305      	str	r3, [sp, #20]
    }
    return eRetVal;
    bc2c:	9b05      	ldr	r3, [sp, #20]
}
    bc2e:	4618      	mov	r0, r3
    bc30:	b006      	add	sp, #24
    bc32:	bd10      	pop	{r4, pc}
    bc34:	00015be8 	.word	0x00015be8
    bc38:	1fff9048 	.word	0x1fff9048

0000bc3c <FlexCAN_Ip_MainFunctionWrite>:
 * This function check the message if have been sent.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_MainFunctionWrite_Activity */
void FlexCAN_Ip_MainFunctionWrite(uint8 instance, uint8 mb_idx)
{
    bc3c:	b510      	push	{r4, lr}
    bc3e:	b098      	sub	sp, #96	; 0x60
    bc40:	4603      	mov	r3, r0
    bc42:	460a      	mov	r2, r1
    bc44:	f88d 3007 	strb.w	r3, [sp, #7]
    bc48:	4613      	mov	r3, r2
    bc4a:	f88d 3006 	strb.w	r3, [sp, #6]
    FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    bc4e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    bc52:	4a3f      	ldr	r2, [pc, #252]	; (bd50 <FlexCAN_Ip_MainFunctionWrite+0x114>)
    bc54:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bc58:	9317      	str	r3, [sp, #92]	; 0x5c
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[instance];
    bc5a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    bc5e:	4a3d      	ldr	r2, [pc, #244]	; (bd54 <FlexCAN_Ip_MainFunctionWrite+0x118>)
    bc60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bc64:	9316      	str	r3, [sp, #88]	; 0x58

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif

    if (FlexCAN_GetBuffStatusFlag(base, mb_idx) != 0U)
    bc66:	f89d 3006 	ldrb.w	r3, [sp, #6]
    bc6a:	4619      	mov	r1, r3
    bc6c:	9817      	ldr	r0, [sp, #92]	; 0x5c
    bc6e:	f7fe f860 	bl	9d32 <FlexCAN_GetBuffStatusFlag>
    bc72:	4603      	mov	r3, r0
    bc74:	2b00      	cmp	r3, #0
    bc76:	d068      	beq.n	bd4a <FlexCAN_Ip_MainFunctionWrite+0x10e>
    {
        if (FLEXCAN_MB_TX_BUSY == state->mbs[mb_idx].state)
    bc78:	f89d 3006 	ldrb.w	r3, [sp, #6]
    bc7c:	9a16      	ldr	r2, [sp, #88]	; 0x58
    bc7e:	011b      	lsls	r3, r3, #4
    bc80:	4413      	add	r3, r2
    bc82:	3304      	adds	r3, #4
    bc84:	681b      	ldr	r3, [r3, #0]
    bc86:	2b02      	cmp	r3, #2
    bc88:	d15f      	bne.n	bd4a <FlexCAN_Ip_MainFunctionWrite+0x10e>
        {
            if (state->mbs[mb_idx].isRemote)
    bc8a:	f89d 3006 	ldrb.w	r3, [sp, #6]
    bc8e:	9a16      	ldr	r2, [sp, #88]	; 0x58
    bc90:	011b      	lsls	r3, r3, #4
    bc92:	4413      	add	r3, r2
    bc94:	3309      	adds	r3, #9
    bc96:	781b      	ldrb	r3, [r3, #0]
    bc98:	2b00      	cmp	r3, #0
    bc9a:	d028      	beq.n	bcee <FlexCAN_Ip_MainFunctionWrite+0xb2>
            {
                Flexcan_Ip_MsgBuffType mb;
                mb.cs = 0U;
    bc9c:	2300      	movs	r3, #0
    bc9e:	9302      	str	r3, [sp, #8]
                mb.time_stamp = 0U;
    bca0:	2300      	movs	r3, #0
    bca2:	9315      	str	r3, [sp, #84]	; 0x54
                FlexCAN_LockRxMsgBuff(base, mb_idx);
    bca4:	f89d 3006 	ldrb.w	r3, [sp, #6]
    bca8:	4619      	mov	r1, r3
    bcaa:	9817      	ldr	r0, [sp, #92]	; 0x5c
    bcac:	f001 fa87 	bl	d1be <FlexCAN_LockRxMsgBuff>
                FlexCAN_GetMsgBuff(base, mb_idx, &mb);
    bcb0:	f89d 3006 	ldrb.w	r3, [sp, #6]
    bcb4:	aa02      	add	r2, sp, #8
    bcb6:	4619      	mov	r1, r3
    bcb8:	9817      	ldr	r0, [sp, #92]	; 0x5c
    bcba:	f001 fbaf 	bl	d41c <FlexCAN_GetMsgBuff>
                FlexCAN_UnlockRxMsgBuff(base);
    bcbe:	9817      	ldr	r0, [sp, #92]	; 0x5c
    bcc0:	f7fe f81d 	bl	9cfe <FlexCAN_UnlockRxMsgBuff>
                state->mbs[mb_idx].time_stamp = mb.time_stamp;
    bcc4:	f89d 3006 	ldrb.w	r3, [sp, #6]
    bcc8:	9a15      	ldr	r2, [sp, #84]	; 0x54
    bcca:	9916      	ldr	r1, [sp, #88]	; 0x58
    bccc:	011b      	lsls	r3, r3, #4
    bcce:	440b      	add	r3, r1
    bcd0:	330c      	adds	r3, #12
    bcd2:	601a      	str	r2, [r3, #0]
                /* If the frame was a remote frame, clear the flag only if the response was
                * not received yet. If the response was received, leave the flag set in order
                * to be handled when the user calls FLEXCAN_DRV_RxMessageBuffer. */
                if ((uint32)FLEXCAN_RX_EMPTY == ((mb.cs & FLEXCAN_IP_CS_CODE_MASK) >> FLEXCAN_IP_CS_CODE_SHIFT))
    bcd4:	9b02      	ldr	r3, [sp, #8]
    bcd6:	0e1b      	lsrs	r3, r3, #24
    bcd8:	f003 030f 	and.w	r3, r3, #15
    bcdc:	2b04      	cmp	r3, #4
    bcde:	d11d      	bne.n	bd1c <FlexCAN_Ip_MainFunctionWrite+0xe0>
                {
                    FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    bce0:	f89d 3006 	ldrb.w	r3, [sp, #6]
    bce4:	4619      	mov	r1, r3
    bce6:	9817      	ldr	r0, [sp, #92]	; 0x5c
    bce8:	f7fe f810 	bl	9d0c <FlexCAN_ClearMsgBuffIntStatusFlag>
    bcec:	e016      	b.n	bd1c <FlexCAN_Ip_MainFunctionWrite+0xe0>
                }
            }
            else
            {
                state->mbs[mb_idx].time_stamp = FlexCAN_GetMsgBuffTimestamp(base, mb_idx);
    bcee:	f89d 3006 	ldrb.w	r3, [sp, #6]
    bcf2:	f89d 4006 	ldrb.w	r4, [sp, #6]
    bcf6:	4619      	mov	r1, r3
    bcf8:	9817      	ldr	r0, [sp, #92]	; 0x5c
    bcfa:	f001 fb7b 	bl	d3f4 <FlexCAN_GetMsgBuffTimestamp>
    bcfe:	4601      	mov	r1, r0
    bd00:	9a16      	ldr	r2, [sp, #88]	; 0x58
    bd02:	0123      	lsls	r3, r4, #4
    bd04:	4413      	add	r3, r2
    bd06:	330c      	adds	r3, #12
    bd08:	6019      	str	r1, [r3, #0]
                FlexCAN_UnlockRxMsgBuff(base);
    bd0a:	9817      	ldr	r0, [sp, #92]	; 0x5c
    bd0c:	f7fd fff7 	bl	9cfe <FlexCAN_UnlockRxMsgBuff>
                /* Clear message buffer flag */
                FlexCAN_ClearMsgBuffIntStatusFlag(base, mb_idx);
    bd10:	f89d 3006 	ldrb.w	r3, [sp, #6]
    bd14:	4619      	mov	r1, r3
    bd16:	9817      	ldr	r0, [sp, #92]	; 0x5c
    bd18:	f7fd fff8 	bl	9d0c <FlexCAN_ClearMsgBuffIntStatusFlag>
            }

            state->mbs[mb_idx].state = FLEXCAN_MB_IDLE;
    bd1c:	f89d 3006 	ldrb.w	r3, [sp, #6]
    bd20:	9a16      	ldr	r2, [sp, #88]	; 0x58
    bd22:	011b      	lsls	r3, r3, #4
    bd24:	4413      	add	r3, r2
    bd26:	3304      	adds	r3, #4
    bd28:	2200      	movs	r2, #0
    bd2a:	601a      	str	r2, [r3, #0]

            /* Invoke callback */
            if (state->callback != NULL_PTR)
    bd2c:	9b16      	ldr	r3, [sp, #88]	; 0x58
    bd2e:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
    bd32:	2b00      	cmp	r3, #0
    bd34:	d009      	beq.n	bd4a <FlexCAN_Ip_MainFunctionWrite+0x10e>
            {
                state->callback(instance, FLEXCAN_EVENT_TX_COMPLETE, mb_idx, state);
    bd36:	9b16      	ldr	r3, [sp, #88]	; 0x58
    bd38:	f8d3 4200 	ldr.w	r4, [r3, #512]	; 0x200
    bd3c:	f89d 2006 	ldrb.w	r2, [sp, #6]
    bd40:	f89d 0007 	ldrb.w	r0, [sp, #7]
    bd44:	9b16      	ldr	r3, [sp, #88]	; 0x58
    bd46:	2104      	movs	r1, #4
    bd48:	47a0      	blx	r4
            }
        }
    }
}
    bd4a:	bf00      	nop
    bd4c:	b018      	add	sp, #96	; 0x60
    bd4e:	bd10      	pop	{r4, pc}
    bd50:	00015be8 	.word	0x00015be8
    bd54:	1fff9048 	.word	0x1fff9048

0000bd58 <FlexCAN_Ip_GetStopMode_Privileged>:
 * Description   : Check if the FlexCAN instance is STOPPED.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetStopMode_Activity */
boolean FlexCAN_Ip_GetStopMode_Privileged(uint8 instance)
{
    bd58:	b084      	sub	sp, #16
    bd5a:	4603      	mov	r3, r0
    bd5c:	f88d 3007 	strb.w	r3, [sp, #7]
    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    bd60:	f89d 3007 	ldrb.w	r3, [sp, #7]
    bd64:	4a08      	ldr	r2, [pc, #32]	; (bd88 <FlexCAN_Ip_GetStopMode_Privileged+0x30>)
    bd66:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bd6a:	9303      	str	r3, [sp, #12]
    return ((FLEXCAN_MCR_LPMACK_MASK == (base->MCR & FLEXCAN_MCR_LPMACK_MASK)) ? TRUE : FALSE);
    bd6c:	9b03      	ldr	r3, [sp, #12]
    bd6e:	681b      	ldr	r3, [r3, #0]
    bd70:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    bd74:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
    bd78:	bf0c      	ite	eq
    bd7a:	2301      	moveq	r3, #1
    bd7c:	2300      	movne	r3, #0
    bd7e:	b2db      	uxtb	r3, r3
}
    bd80:	4618      	mov	r0, r3
    bd82:	b004      	add	sp, #16
    bd84:	4770      	bx	lr
    bd86:	bf00      	nop
    bd88:	00015be8 	.word	0x00015be8

0000bd8c <FlexCAN_Ip_GetStartMode_Privileged>:
 * Description   : Check if the FlexCAN instance is STARTED.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetStartMode_Activity */
boolean FlexCAN_Ip_GetStartMode_Privileged(uint8 instance)
{
    bd8c:	b084      	sub	sp, #16
    bd8e:	4603      	mov	r3, r0
    bd90:	f88d 3007 	strb.w	r3, [sp, #7]
    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    bd94:	f89d 3007 	ldrb.w	r3, [sp, #7]
    bd98:	4a07      	ldr	r2, [pc, #28]	; (bdb8 <FlexCAN_Ip_GetStartMode_Privileged+0x2c>)
    bd9a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bd9e:	9303      	str	r3, [sp, #12]
    return ((0U == (base->MCR & (FLEXCAN_MCR_LPMACK_MASK | FLEXCAN_MCR_FRZACK_MASK))) ? TRUE : FALSE);
    bda0:	9b03      	ldr	r3, [sp, #12]
    bda2:	681b      	ldr	r3, [r3, #0]
    bda4:	f003 7388 	and.w	r3, r3, #17825792	; 0x1100000
    bda8:	2b00      	cmp	r3, #0
    bdaa:	bf0c      	ite	eq
    bdac:	2301      	moveq	r3, #1
    bdae:	2300      	movne	r3, #0
    bdb0:	b2db      	uxtb	r3, r3
}
    bdb2:	4618      	mov	r0, r3
    bdb4:	b004      	add	sp, #16
    bdb6:	4770      	bx	lr
    bdb8:	00015be8 	.word	0x00015be8

0000bdbc <FlexCAN_Ip_SetStartMode_Privileged>:
 * Description   : Set the FlexCAN instance in START mode.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetStartMode_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetStartMode_Privileged(uint8 instance)
{
    bdbc:	b500      	push	{lr}
    bdbe:	b085      	sub	sp, #20
    bdc0:	4603      	mov	r3, r0
    bdc2:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    bdc6:	f89d 3007 	ldrb.w	r3, [sp, #7]
    bdca:	4a0b      	ldr	r2, [pc, #44]	; (bdf8 <FlexCAN_Ip_SetStartMode_Privileged+0x3c>)
    bdcc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bdd0:	9303      	str	r3, [sp, #12]
    /* Start critical section: implementation depends on integrator */
    SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07();
    bdd2:	f006 faf7 	bl	123c4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07>
    /* Enable Flexcan Module */
    pBase->MCR &= ~FLEXCAN_MCR_MDIS_MASK;
    bdd6:	9b03      	ldr	r3, [sp, #12]
    bdd8:	681b      	ldr	r3, [r3, #0]
    bdda:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
    bdde:	9b03      	ldr	r3, [sp, #12]
    bde0:	601a      	str	r2, [r3, #0]
    /* End critical section: implementation depends on integrator */
    SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07();
    bde2:	f006 fb1b 	bl	1241c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07>

    return (FlexCAN_ExitFreezeMode(pBase));
    bde6:	9803      	ldr	r0, [sp, #12]
    bde8:	f000 ff94 	bl	cd14 <FlexCAN_ExitFreezeMode>
    bdec:	4603      	mov	r3, r0
}
    bdee:	4618      	mov	r0, r3
    bdf0:	b005      	add	sp, #20
    bdf2:	f85d fb04 	ldr.w	pc, [sp], #4
    bdf6:	bf00      	nop
    bdf8:	00015be8 	.word	0x00015be8

0000bdfc <FlexCAN_Ip_SetStopMode_Privileged>:
 * Description   : Set the FlexCAN instance in STOP mode.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetStopMode_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetStopMode_Privileged(uint8 instance)
{
    bdfc:	b500      	push	{lr}
    bdfe:	b085      	sub	sp, #20
    be00:	4603      	mov	r3, r0
    be02:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    be06:	f89d 3007 	ldrb.w	r3, [sp, #7]
    be0a:	4a0a      	ldr	r2, [pc, #40]	; (be34 <FlexCAN_Ip_SetStopMode_Privileged+0x38>)
    be0c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    be10:	9302      	str	r3, [sp, #8]
    Flexcan_Ip_StatusType status;
    status = FlexCAN_EnterFreezeMode(pBase);
    be12:	9802      	ldr	r0, [sp, #8]
    be14:	f000 fef6 	bl	cc04 <FlexCAN_EnterFreezeMode>
    be18:	9003      	str	r0, [sp, #12]
    if (FLEXCAN_STATUS_SUCCESS == status)
    be1a:	9b03      	ldr	r3, [sp, #12]
    be1c:	2b00      	cmp	r3, #0
    be1e:	d103      	bne.n	be28 <FlexCAN_Ip_SetStopMode_Privileged+0x2c>

        /* TODO: reset MB status */

        /* TODO: disable all interrupt */

        status = FlexCAN_Disable(pBase);
    be20:	9802      	ldr	r0, [sp, #8]
    be22:	f000 ffb9 	bl	cd98 <FlexCAN_Disable>
    be26:	9003      	str	r0, [sp, #12]
    }
    return status;
    be28:	9b03      	ldr	r3, [sp, #12]
}
    be2a:	4618      	mov	r0, r3
    be2c:	b005      	add	sp, #20
    be2e:	f85d fb04 	ldr.w	pc, [sp], #4
    be32:	bf00      	nop
    be34:	00015be8 	.word	0x00015be8

0000be38 <FlexCAN_Ip_SetRxMaskType_Privileged>:
 * mask.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetRxMaskType_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetRxMaskType_Privileged(uint8 instance, Flexcan_Ip_RxMaskType type)
{
    be38:	b500      	push	{lr}
    be3a:	b087      	sub	sp, #28
    be3c:	4603      	mov	r3, r0
    be3e:	9100      	str	r1, [sp, #0]
    be40:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    be44:	2300      	movs	r3, #0
    be46:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    be48:	2300      	movs	r3, #0
    be4a:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    be4c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    be50:	4a1e      	ldr	r2, [pc, #120]	; (becc <FlexCAN_Ip_SetRxMaskType_Privileged+0x94>)
    be52:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    be56:	9303      	str	r3, [sp, #12]
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    be58:	9803      	ldr	r0, [sp, #12]
    be5a:	f7fd fefd 	bl	9c58 <FlexCAN_IsEnabled>
    be5e:	4603      	mov	r3, r0
    be60:	2b00      	cmp	r3, #0
    be62:	bf14      	ite	ne
    be64:	2301      	movne	r3, #1
    be66:	2300      	moveq	r3, #0
    be68:	b2db      	uxtb	r3, r3
    be6a:	f083 0301 	eor.w	r3, r3, #1
    be6e:	b2db      	uxtb	r3, r3
    be70:	f88d 300b 	strb.w	r3, [sp, #11]
    be74:	f89d 300b 	ldrb.w	r3, [sp, #11]
    be78:	f003 0301 	and.w	r3, r3, #1
    be7c:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    be80:	f89d 300b 	ldrb.w	r3, [sp, #11]
    be84:	2b00      	cmp	r3, #0
    be86:	d003      	beq.n	be90 <FlexCAN_Ip_SetRxMaskType_Privileged+0x58>
    {
        result = FlexCAN_Enable(pBase);
    be88:	9803      	ldr	r0, [sp, #12]
    be8a:	f000 ff07 	bl	cc9c <FlexCAN_Enable>
    be8e:	9005      	str	r0, [sp, #20]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    be90:	9b05      	ldr	r3, [sp, #20]
    be92:	2b00      	cmp	r3, #0
    be94:	d107      	bne.n	bea6 <FlexCAN_Ip_SetRxMaskType_Privileged+0x6e>
    {
        /* Start critical section: implementation depends on integrator */
        SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08();
    be96:	f006 fae7 	bl	12468 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08>
        FlexCAN_SetRxMaskType(pBase, type);
    be9a:	9900      	ldr	r1, [sp, #0]
    be9c:	9803      	ldr	r0, [sp, #12]
    be9e:	f7fe f930 	bl	a102 <FlexCAN_SetRxMaskType>
        /* End critical section: implementation depends on integrator */
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08();
    bea2:	f006 fb0d 	bl	124c0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08>
    }

    if (TRUE == disabled)
    bea6:	f89d 300b 	ldrb.w	r3, [sp, #11]
    beaa:	2b00      	cmp	r3, #0
    beac:	d008      	beq.n	bec0 <FlexCAN_Ip_SetRxMaskType_Privileged+0x88>
    {
        status = FlexCAN_Disable(pBase);
    beae:	9803      	ldr	r0, [sp, #12]
    beb0:	f000 ff72 	bl	cd98 <FlexCAN_Disable>
    beb4:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    beb6:	9b04      	ldr	r3, [sp, #16]
    beb8:	2b00      	cmp	r3, #0
    beba:	d001      	beq.n	bec0 <FlexCAN_Ip_SetRxMaskType_Privileged+0x88>
        {
            result = status;
    bebc:	9b04      	ldr	r3, [sp, #16]
    bebe:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    bec0:	9b05      	ldr	r3, [sp, #20]
}
    bec2:	4618      	mov	r0, r3
    bec4:	b007      	add	sp, #28
    bec6:	f85d fb04 	ldr.w	pc, [sp], #4
    beca:	bf00      	nop
    becc:	00015be8 	.word	0x00015be8

0000bed0 <FlexCAN_Ip_SetBitrate_Privileged>:
 *
 *END**************************************************************************/

/* implements  FlexCAN_Ip_SetBitrate_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetBitrate_Privileged(uint8 instance, const Flexcan_Ip_TimeSegmentType * bitrate, boolean enhExt)
{
    bed0:	b500      	push	{lr}
    bed2:	b087      	sub	sp, #28
    bed4:	4603      	mov	r3, r0
    bed6:	9100      	str	r1, [sp, #0]
    bed8:	f88d 3007 	strb.w	r3, [sp, #7]
    bedc:	4613      	mov	r3, r2
    bede:	f88d 3006 	strb.w	r3, [sp, #6]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert(bitrate != NULL_PTR);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    bee2:	2300      	movs	r3, #0
    bee4:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    bee6:	2300      	movs	r3, #0
    bee8:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    beea:	f89d 3007 	ldrb.w	r3, [sp, #7]
    beee:	4a1c      	ldr	r2, [pc, #112]	; (bf60 <FlexCAN_Ip_SetBitrate_Privileged+0x90>)
    bef0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bef4:	9303      	str	r3, [sp, #12]
    /* Check if the FlexCAN is enabled or not */
    boolean disabled = ((pBase->MCR & FLEXCAN_MCR_MDIS_MASK) != 0U) ? TRUE : FALSE;
    bef6:	9b03      	ldr	r3, [sp, #12]
    bef8:	681b      	ldr	r3, [r3, #0]
    befa:	0fdb      	lsrs	r3, r3, #31
    befc:	f88d 300b 	strb.w	r3, [sp, #11]
#if (FLEXCAN_IP_FEATURE_HAS_ENHANCE_CBT == STD_OFF)
    (void)enhExt;
#endif
    if (TRUE == disabled)
    bf00:	f89d 300b 	ldrb.w	r3, [sp, #11]
    bf04:	2b00      	cmp	r3, #0
    bf06:	d003      	beq.n	bf10 <FlexCAN_Ip_SetBitrate_Privileged+0x40>
    {
        result = FlexCAN_Enable(pBase);
    bf08:	9803      	ldr	r0, [sp, #12]
    bf0a:	f000 fec7 	bl	cc9c <FlexCAN_Enable>
    bf0e:	9005      	str	r0, [sp, #20]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    bf10:	9b05      	ldr	r3, [sp, #20]
    bf12:	2b00      	cmp	r3, #0
    bf14:	d112      	bne.n	bf3c <FlexCAN_Ip_SetBitrate_Privileged+0x6c>
    {
        /* Start critical section: implementation depends on integrator */
        SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14();
    bf16:	f006 fc93 	bl	12840 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14>
            FlexCAN_SetEnhancedNominalTimeSegments(pBase, bitrate);
        }
        else
#endif
        {
            if (TRUE == FlexCAN_IsExCbtEnabled(pBase))
    bf1a:	9803      	ldr	r0, [sp, #12]
    bf1c:	f7fe f830 	bl	9f80 <FlexCAN_IsExCbtEnabled>
    bf20:	4603      	mov	r3, r0
    bf22:	2b00      	cmp	r3, #0
    bf24:	d004      	beq.n	bf30 <FlexCAN_Ip_SetBitrate_Privileged+0x60>
            {
                FlexCAN_SetExtendedTimeSegments(pBase, bitrate);
    bf26:	9900      	ldr	r1, [sp, #0]
    bf28:	9803      	ldr	r0, [sp, #12]
    bf2a:	f7fd ff7f 	bl	9e2c <FlexCAN_SetExtendedTimeSegments>
    bf2e:	e003      	b.n	bf38 <FlexCAN_Ip_SetBitrate_Privileged+0x68>
            }
            else
            {
                FlexCAN_SetTimeSegments(pBase, bitrate);
    bf30:	9900      	ldr	r1, [sp, #0]
    bf32:	9803      	ldr	r0, [sp, #12]
    bf34:	f7fd ff4e 	bl	9dd4 <FlexCAN_SetTimeSegments>
            }
        }
        /* End critical section: implementation depends on integrator */
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14();
    bf38:	f006 fcae 	bl	12898 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14>
    }

    if (TRUE == disabled)
    bf3c:	f89d 300b 	ldrb.w	r3, [sp, #11]
    bf40:	2b00      	cmp	r3, #0
    bf42:	d008      	beq.n	bf56 <FlexCAN_Ip_SetBitrate_Privileged+0x86>
    {
        status = FlexCAN_Disable(pBase);
    bf44:	9803      	ldr	r0, [sp, #12]
    bf46:	f000 ff27 	bl	cd98 <FlexCAN_Disable>
    bf4a:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    bf4c:	9b04      	ldr	r3, [sp, #16]
    bf4e:	2b00      	cmp	r3, #0
    bf50:	d001      	beq.n	bf56 <FlexCAN_Ip_SetBitrate_Privileged+0x86>
        {
            result = status;
    bf52:	9b04      	ldr	r3, [sp, #16]
    bf54:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    bf56:	9b05      	ldr	r3, [sp, #20]
}
    bf58:	4618      	mov	r0, r3
    bf5a:	b007      	add	sp, #28
    bf5c:	f85d fb04 	ldr.w	pc, [sp], #4
    bf60:	00015be8 	.word	0x00015be8

0000bf64 <FlexCAN_Ip_GetBitrate>:
 * or the arbitration phase of FD frames.
 *
 *END**************************************************************************/
 /* implements   FlexCAN_Ip_GetBitrate_Activity */
boolean FlexCAN_Ip_GetBitrate(uint8 instance, Flexcan_Ip_TimeSegmentType * bitrate)
{
    bf64:	b500      	push	{lr}
    bf66:	b085      	sub	sp, #20
    bf68:	4603      	mov	r3, r0
    bf6a:	9100      	str	r1, [sp, #0]
    bf6c:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert(bitrate != NULL_PTR);
#endif
    const FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    bf70:	f89d 3007 	ldrb.w	r3, [sp, #7]
    bf74:	4a0d      	ldr	r2, [pc, #52]	; (bfac <FlexCAN_Ip_GetBitrate+0x48>)
    bf76:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bf7a:	9303      	str	r3, [sp, #12]
    boolean enhCbt = FALSE;
    bf7c:	2300      	movs	r3, #0
    bf7e:	f88d 300b 	strb.w	r3, [sp, #11]
        FlexCAN_GetEnhancedNominalTimeSegments(pBase, bitrate);
    }
    else
#endif
    {
        if (TRUE == FlexCAN_IsExCbtEnabled(pBase))
    bf82:	9803      	ldr	r0, [sp, #12]
    bf84:	f7fd fffc 	bl	9f80 <FlexCAN_IsExCbtEnabled>
    bf88:	4603      	mov	r3, r0
    bf8a:	2b00      	cmp	r3, #0
    bf8c:	d004      	beq.n	bf98 <FlexCAN_Ip_GetBitrate+0x34>
        {
            /* Get the Extended time segments*/
            FlexCAN_GetExtendedTimeSegments(pBase, bitrate);
    bf8e:	9900      	ldr	r1, [sp, #0]
    bf90:	9803      	ldr	r0, [sp, #12]
    bf92:	f7fd ff79 	bl	9e88 <FlexCAN_GetExtendedTimeSegments>
    bf96:	e003      	b.n	bfa0 <FlexCAN_Ip_GetBitrate+0x3c>
        }
        else
        {
            /* Get the time segments*/
            FlexCAN_GetTimeSegments(pBase, bitrate);
    bf98:	9900      	ldr	r1, [sp, #0]
    bf9a:	9803      	ldr	r0, [sp, #12]
    bf9c:	f7fd ff9c 	bl	9ed8 <FlexCAN_GetTimeSegments>
        }
    }
    return enhCbt;
    bfa0:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
    bfa4:	4618      	mov	r0, r3
    bfa6:	b005      	add	sp, #20
    bfa8:	f85d fb04 	ldr.w	pc, [sp], #4
    bfac:	00015be8 	.word	0x00015be8

0000bfb0 <FlexCAN_Ip_ClearTDCFail>:
 * Description   : This function clear the TDC Fail flag.
 *
 *END**************************************************************************/
/* implements   FlexCAN_Ip_ClearTDCFail_Activity */
void FlexCAN_Ip_ClearTDCFail(uint8 u8Instance)
{
    bfb0:	b500      	push	{lr}
    bfb2:	b085      	sub	sp, #20
    bfb4:	4603      	mov	r3, r0
    bfb6:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(u8Instance < FLEXCAN_INSTANCE_COUNT);
#endif
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    bfba:	f89d 3007 	ldrb.w	r3, [sp, #7]
    bfbe:	4a0a      	ldr	r2, [pc, #40]	; (bfe8 <FlexCAN_Ip_ClearTDCFail+0x38>)
    bfc0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    bfc4:	9303      	str	r3, [sp, #12]
    /* Start critical section: implementation depends on integrator */
    SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09();
    bfc6:	f006 faa1 	bl	1250c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09>
        pBase->ETDC |=  FLEXCAN_ETDC_ETDCFAIL_MASK;
    }
    else
#endif
    {
        pBase->FDCTRL |= FLEXCAN_FDCTRL_TDCFAIL_MASK;
    bfca:	9b03      	ldr	r3, [sp, #12]
    bfcc:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    bfd0:	f443 4280 	orr.w	r2, r3, #16384	; 0x4000
    bfd4:	9b03      	ldr	r3, [sp, #12]
    bfd6:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
    }
    /* End critical section: implementation depends on integrator */
    SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09();
    bfda:	f006 fac3 	bl	12564 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09>
}
    bfde:	bf00      	nop
    bfe0:	b005      	add	sp, #20
    bfe2:	f85d fb04 	ldr.w	pc, [sp], #4
    bfe6:	bf00      	nop
    bfe8:	00015be8 	.word	0x00015be8

0000bfec <FlexCAN_Ip_GetTDCFail>:
 *
 *END**************************************************************************/

/* implements    FlexCAN_Ip_GetTDCFail_Activity */
boolean FlexCAN_Ip_GetTDCFail(uint8 u8Instance)
{
    bfec:	b084      	sub	sp, #16
    bfee:	4603      	mov	r3, r0
    bff0:	f88d 3007 	strb.w	r3, [sp, #7]
    boolean value=FALSE;
    bff4:	2300      	movs	r3, #0
    bff6:	f88d 300f 	strb.w	r3, [sp, #15]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(u8Instance < FLEXCAN_INSTANCE_COUNT);
#endif
    const FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    bffa:	f89d 3007 	ldrb.w	r3, [sp, #7]
    bffe:	4a0a      	ldr	r2, [pc, #40]	; (c028 <FlexCAN_Ip_GetTDCFail+0x3c>)
    c000:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c004:	9302      	str	r3, [sp, #8]
        value = ((pBase->ETDC & FLEXCAN_ETDC_ETDCFAIL_MASK) == FLEXCAN_ETDC_ETDCFAIL_MASK) ? TRUE : FALSE;
    }
    else
#endif
    {
        value = ((pBase->FDCTRL & FLEXCAN_FDCTRL_TDCFAIL_MASK) == FLEXCAN_FDCTRL_TDCFAIL_MASK) ? TRUE : FALSE;
    c006:	9b02      	ldr	r3, [sp, #8]
    c008:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    c00c:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
    c010:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
    c014:	bf0c      	ite	eq
    c016:	2301      	moveq	r3, #1
    c018:	2300      	movne	r3, #0
    c01a:	f88d 300f 	strb.w	r3, [sp, #15]
    }
    return value;
    c01e:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    c022:	4618      	mov	r0, r3
    c024:	b004      	add	sp, #16
    c026:	4770      	bx	lr
    c028:	00015be8 	.word	0x00015be8

0000c02c <FlexCAN_Ip_GetTDCValue>:
 *
 *END**************************************************************************/

/* implements FlexCAN_Ip_GetTDCValue_Activity */
uint8 FlexCAN_Ip_GetTDCValue(uint8 u8Instance)
{
    c02c:	b084      	sub	sp, #16
    c02e:	4603      	mov	r3, r0
    c030:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 value = 0;
    c034:	2300      	movs	r3, #0
    c036:	f88d 300f 	strb.w	r3, [sp, #15]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(u8Instance < FLEXCAN_INSTANCE_COUNT);
#endif
    const FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    c03a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c03e:	4a08      	ldr	r2, [pc, #32]	; (c060 <FlexCAN_Ip_GetTDCValue+0x34>)
    c040:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c044:	9302      	str	r3, [sp, #8]
        value = (uint8)((pBase->ETDC& FLEXCAN_ETDC_ETDCVAL_MASK) >> FLEXCAN_ETDC_ETDCVAL_SHIFT);
    }
    else
#endif
    {
        value = (uint8)((pBase->FDCTRL & FLEXCAN_FDCTRL_TDCVAL_MASK) >> FLEXCAN_FDCTRL_TDCVAL_SHIFT);
    c046:	9b02      	ldr	r3, [sp, #8]
    c048:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    c04c:	b2db      	uxtb	r3, r3
    c04e:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    c052:	f88d 300f 	strb.w	r3, [sp, #15]
    }
    return value;
    c056:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    c05a:	4618      	mov	r0, r3
    c05c:	b004      	add	sp, #16
    c05e:	4770      	bx	lr
    c060:	00015be8 	.word	0x00015be8

0000c064 <FlexCAN_Ip_SetBitrateCbt_Privileged>:
 *
 *END**************************************************************************/

/* implements  FlexCAN_Ip_SetBitrateCbt_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetBitrateCbt_Privileged(uint8 instance, const Flexcan_Ip_TimeSegmentType * bitrate, boolean bitRateSwitch)
{
    c064:	b500      	push	{lr}
    c066:	b087      	sub	sp, #28
    c068:	4603      	mov	r3, r0
    c06a:	9100      	str	r1, [sp, #0]
    c06c:	f88d 3007 	strb.w	r3, [sp, #7]
    c070:	4613      	mov	r3, r2
    c072:	f88d 3006 	strb.w	r3, [sp, #6]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert(bitrate != NULL_PTR);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    c076:	2300      	movs	r3, #0
    c078:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    c07a:	2300      	movs	r3, #0
    c07c:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    c07e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c082:	4a1e      	ldr	r2, [pc, #120]	; (c0fc <FlexCAN_Ip_SetBitrateCbt_Privileged+0x98>)
    c084:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c088:	9303      	str	r3, [sp, #12]
    boolean fd_enable = FlexCAN_IsFDEnabled(pBase);
    c08a:	9803      	ldr	r0, [sp, #12]
    c08c:	f7fd ffaf 	bl	9fee <FlexCAN_IsFDEnabled>
    c090:	4603      	mov	r3, r0
    c092:	f88d 300b 	strb.w	r3, [sp, #11]
    /* Check if the FlexCAN is enabled or not */
    boolean disabled = ((pBase->MCR & FLEXCAN_MCR_MDIS_MASK) != 0U) ? TRUE : FALSE;
    c096:	9b03      	ldr	r3, [sp, #12]
    c098:	681b      	ldr	r3, [r3, #0]
    c09a:	0fdb      	lsrs	r3, r3, #31
    c09c:	f88d 300a 	strb.w	r3, [sp, #10]

    if (TRUE == disabled)
    c0a0:	f89d 300a 	ldrb.w	r3, [sp, #10]
    c0a4:	2b00      	cmp	r3, #0
    c0a6:	d003      	beq.n	c0b0 <FlexCAN_Ip_SetBitrateCbt_Privileged+0x4c>
    {
        result = FlexCAN_Enable(pBase);
    c0a8:	9803      	ldr	r0, [sp, #12]
    c0aa:	f000 fdf7 	bl	cc9c <FlexCAN_Enable>
    c0ae:	9005      	str	r0, [sp, #20]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    c0b0:	9b05      	ldr	r3, [sp, #20]
    c0b2:	2b00      	cmp	r3, #0
    c0b4:	d10f      	bne.n	c0d6 <FlexCAN_Ip_SetBitrateCbt_Privileged+0x72>
    {
#if (FLEXCAN_IP_FEATURE_HAS_ENHANCE_CBT == STD_ON)
        boolean enhCbt = FlexCAN_IsEnhCbtEnabled(pBase);
#endif
        /* Start critical section: implementation depends on integrator */
        SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15();
    c0b6:	f006 fc15 	bl	128e4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15>
        FlexCAN_SetFDEnabled(pBase, fd_enable, bitRateSwitch);
    c0ba:	f89d 2006 	ldrb.w	r2, [sp, #6]
    c0be:	f89d 300b 	ldrb.w	r3, [sp, #11]
    c0c2:	4619      	mov	r1, r3
    c0c4:	9803      	ldr	r0, [sp, #12]
    c0c6:	f7fd fdd1 	bl	9c6c <FlexCAN_SetFDEnabled>
        }
        else
#endif
        {
            /* Set time segments*/
            FlexCAN_SetFDTimeSegments(pBase, bitrate);
    c0ca:	9900      	ldr	r1, [sp, #0]
    c0cc:	9803      	ldr	r0, [sp, #12]
    c0ce:	f7fd fe4c 	bl	9d6a <FlexCAN_SetFDTimeSegments>
        }
        /* End critical section: implementation depends on integrator */
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15();
    c0d2:	f006 fc33 	bl	1293c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15>
    }

    if (TRUE == disabled)
    c0d6:	f89d 300a 	ldrb.w	r3, [sp, #10]
    c0da:	2b00      	cmp	r3, #0
    c0dc:	d008      	beq.n	c0f0 <FlexCAN_Ip_SetBitrateCbt_Privileged+0x8c>
    {
        status = FlexCAN_Disable(pBase);
    c0de:	9803      	ldr	r0, [sp, #12]
    c0e0:	f000 fe5a 	bl	cd98 <FlexCAN_Disable>
    c0e4:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    c0e6:	9b04      	ldr	r3, [sp, #16]
    c0e8:	2b00      	cmp	r3, #0
    c0ea:	d001      	beq.n	c0f0 <FlexCAN_Ip_SetBitrateCbt_Privileged+0x8c>
        {
            result = status;
    c0ec:	9b04      	ldr	r3, [sp, #16]
    c0ee:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    c0f0:	9b05      	ldr	r3, [sp, #20]
}
    c0f2:	4618      	mov	r0, r3
    c0f4:	b007      	add	sp, #28
    c0f6:	f85d fb04 	ldr.w	pc, [sp], #4
    c0fa:	bf00      	nop
    c0fc:	00015be8 	.word	0x00015be8

0000c100 <FlexCAN_Ip_GetBitrateFD>:
 * of FD frames.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetBitrateFD_Activity */
boolean FlexCAN_Ip_GetBitrateFD(uint8 instance, Flexcan_Ip_TimeSegmentType * bitrate)
{
    c100:	b500      	push	{lr}
    c102:	b085      	sub	sp, #20
    c104:	4603      	mov	r3, r0
    c106:	9100      	str	r1, [sp, #0]
    c108:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
    DevAssert(bitrate != NULL_PTR);
#endif
    const FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    c10c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c110:	4a08      	ldr	r2, [pc, #32]	; (c134 <FlexCAN_Ip_GetBitrateFD+0x34>)
    c112:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c116:	9303      	str	r3, [sp, #12]
    boolean enhCbt = FALSE;
    c118:	2300      	movs	r3, #0
    c11a:	f88d 300b 	strb.w	r3, [sp, #11]
    }
    else
#endif
    {
        /* Get the time segments*/
        FlexCAN_GetFDTimeSegments(pBase, bitrate);
    c11e:	9900      	ldr	r1, [sp, #0]
    c120:	9803      	ldr	r0, [sp, #12]
    c122:	f7fd ff00 	bl	9f26 <FlexCAN_GetFDTimeSegments>
    }
    return enhCbt;
    c126:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
    c12a:	4618      	mov	r0, r3
    c12c:	b005      	add	sp, #20
    c12e:	f85d fb04 	ldr.w	pc, [sp], #4
    c132:	bf00      	nop
    c134:	00015be8 	.word	0x00015be8

0000c138 <FlexCAN_Ip_SetTDCOffset_Privileged>:
 * the Transceiver Delay Compensation Offset.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetTDCOffset_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetTDCOffset_Privileged(uint8 instance, boolean enable, uint8 offset)
{
    c138:	b500      	push	{lr}
    c13a:	b087      	sub	sp, #28
    c13c:	4603      	mov	r3, r0
    c13e:	f88d 3007 	strb.w	r3, [sp, #7]
    c142:	460b      	mov	r3, r1
    c144:	f88d 3006 	strb.w	r3, [sp, #6]
    c148:	4613      	mov	r3, r2
    c14a:	f88d 3005 	strb.w	r3, [sp, #5]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    c14e:	2300      	movs	r3, #0
    c150:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    c152:	2300      	movs	r3, #0
    c154:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    c156:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c15a:	4a20      	ldr	r2, [pc, #128]	; (c1dc <FlexCAN_Ip_SetTDCOffset_Privileged+0xa4>)
    c15c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c160:	9303      	str	r3, [sp, #12]
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    c162:	9803      	ldr	r0, [sp, #12]
    c164:	f7fd fd78 	bl	9c58 <FlexCAN_IsEnabled>
    c168:	4603      	mov	r3, r0
    c16a:	2b00      	cmp	r3, #0
    c16c:	bf14      	ite	ne
    c16e:	2301      	movne	r3, #1
    c170:	2300      	moveq	r3, #0
    c172:	b2db      	uxtb	r3, r3
    c174:	f083 0301 	eor.w	r3, r3, #1
    c178:	b2db      	uxtb	r3, r3
    c17a:	f88d 300b 	strb.w	r3, [sp, #11]
    c17e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    c182:	f003 0301 	and.w	r3, r3, #1
    c186:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    c18a:	f89d 300b 	ldrb.w	r3, [sp, #11]
    c18e:	2b00      	cmp	r3, #0
    c190:	d003      	beq.n	c19a <FlexCAN_Ip_SetTDCOffset_Privileged+0x62>
    {
        result = FlexCAN_Enable(pBase);
    c192:	9803      	ldr	r0, [sp, #12]
    c194:	f000 fd82 	bl	cc9c <FlexCAN_Enable>
    c198:	9005      	str	r0, [sp, #20]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    c19a:	9b05      	ldr	r3, [sp, #20]
    c19c:	2b00      	cmp	r3, #0
    c19e:	d10b      	bne.n	c1b8 <FlexCAN_Ip_SetTDCOffset_Privileged+0x80>
    {
        /* Check if enhaced CBT is Enabled */
        SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16();
    c1a0:	f006 fbf2 	bl	12988 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16>
        }
        else
#endif
        {
            /* Enable/Disable TDC and set the TDC Offset */
            FlexCAN_SetTDCOffset(pBase, enable, offset);
    c1a4:	f89d 2005 	ldrb.w	r2, [sp, #5]
    c1a8:	f89d 3006 	ldrb.w	r3, [sp, #6]
    c1ac:	4619      	mov	r1, r3
    c1ae:	9803      	ldr	r0, [sp, #12]
    c1b0:	f7fd fd2b 	bl	9c0a <FlexCAN_SetTDCOffset>
        }
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16();
    c1b4:	f006 fc14 	bl	129e0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16>
        /* Check if enhaced CBT is Enabled */
    }

    if (TRUE == disabled)
    c1b8:	f89d 300b 	ldrb.w	r3, [sp, #11]
    c1bc:	2b00      	cmp	r3, #0
    c1be:	d008      	beq.n	c1d2 <FlexCAN_Ip_SetTDCOffset_Privileged+0x9a>
    {
        status = FlexCAN_Disable(pBase);
    c1c0:	9803      	ldr	r0, [sp, #12]
    c1c2:	f000 fde9 	bl	cd98 <FlexCAN_Disable>
    c1c6:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    c1c8:	9b04      	ldr	r3, [sp, #16]
    c1ca:	2b00      	cmp	r3, #0
    c1cc:	d001      	beq.n	c1d2 <FlexCAN_Ip_SetTDCOffset_Privileged+0x9a>
        {
            result = status;
    c1ce:	9b04      	ldr	r3, [sp, #16]
    c1d0:	9305      	str	r3, [sp, #20]
        }
    }
    return result;
    c1d2:	9b05      	ldr	r3, [sp, #20]
}
    c1d4:	4618      	mov	r0, r3
    c1d6:	b007      	add	sp, #28
    c1d8:	f85d fb04 	ldr.w	pc, [sp], #4
    c1dc:	00015be8 	.word	0x00015be8

0000c1e0 <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged>:
 * be delayed from the first bit of CRC field on CAN bus.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetTxArbitrationStartDelay_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged(uint8 instance,  uint8 value)
{
    c1e0:	b500      	push	{lr}
    c1e2:	b087      	sub	sp, #28
    c1e4:	4603      	mov	r3, r0
    c1e6:	460a      	mov	r2, r1
    c1e8:	f88d 3007 	strb.w	r3, [sp, #7]
    c1ec:	4613      	mov	r3, r2
    c1ee:	f88d 3006 	strb.w	r3, [sp, #6]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    c1f2:	2300      	movs	r3, #0
    c1f4:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    c1f6:	2300      	movs	r3, #0
    c1f8:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    c1fa:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c1fe:	4a1f      	ldr	r2, [pc, #124]	; (c27c <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged+0x9c>)
    c200:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c204:	9303      	str	r3, [sp, #12]
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    c206:	9803      	ldr	r0, [sp, #12]
    c208:	f7fd fd26 	bl	9c58 <FlexCAN_IsEnabled>
    c20c:	4603      	mov	r3, r0
    c20e:	2b00      	cmp	r3, #0
    c210:	bf14      	ite	ne
    c212:	2301      	movne	r3, #1
    c214:	2300      	moveq	r3, #0
    c216:	b2db      	uxtb	r3, r3
    c218:	f083 0301 	eor.w	r3, r3, #1
    c21c:	b2db      	uxtb	r3, r3
    c21e:	f88d 300b 	strb.w	r3, [sp, #11]
    c222:	f89d 300b 	ldrb.w	r3, [sp, #11]
    c226:	f003 0301 	and.w	r3, r3, #1
    c22a:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    c22e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    c232:	2b00      	cmp	r3, #0
    c234:	d003      	beq.n	c23e <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged+0x5e>
    {
        result = FlexCAN_Enable(pBase);
    c236:	9803      	ldr	r0, [sp, #12]
    c238:	f000 fd30 	bl	cc9c <FlexCAN_Enable>
    c23c:	9005      	str	r0, [sp, #20]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    c23e:	9b05      	ldr	r3, [sp, #20]
    c240:	2b00      	cmp	r3, #0
    c242:	d109      	bne.n	c258 <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged+0x78>
    {
        /* Start critical section: implementation depends on integrator */
        SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17();
    c244:	f006 fbf2 	bl	12a2c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17>
        FlexCAN_SetTxArbitrationStartDelay(pBase, value);
    c248:	f89d 3006 	ldrb.w	r3, [sp, #6]
    c24c:	4619      	mov	r1, r3
    c24e:	9803      	ldr	r0, [sp, #12]
    c250:	f7fd ff43 	bl	a0da <FlexCAN_SetTxArbitrationStartDelay>
        /* End critical section: implementation depends on integrator */
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17();
    c254:	f006 fc16 	bl	12a84 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17>
    }

    if (TRUE == disabled)
    c258:	f89d 300b 	ldrb.w	r3, [sp, #11]
    c25c:	2b00      	cmp	r3, #0
    c25e:	d008      	beq.n	c272 <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged+0x92>
    {
        status = FlexCAN_Disable(pBase);
    c260:	9803      	ldr	r0, [sp, #12]
    c262:	f000 fd99 	bl	cd98 <FlexCAN_Disable>
    c266:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    c268:	9b04      	ldr	r3, [sp, #16]
    c26a:	2b00      	cmp	r3, #0
    c26c:	d001      	beq.n	c272 <FlexCAN_Ip_SetTxArbitrationStartDelay_Privileged+0x92>
        {
            result = status;
    c26e:	9b04      	ldr	r3, [sp, #16]
    c270:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    c272:	9b05      	ldr	r3, [sp, #20]
}
    c274:	4618      	mov	r0, r3
    c276:	b007      	add	sp, #28
    c278:	f85d fb04 	ldr.w	pc, [sp], #4
    c27c:	00015be8 	.word	0x00015be8

0000c280 <FlexCAN_Ip_GetBuffStatusFlag>:
 * In case of a complete operation this flag is set.
 * In case msgBuff is 255 will return Enhanced Overflow Status Flag.
 *END**************************************************************************/
/* implements FlexCAN_Ip_GetBuffStatusFlag_Activity */
boolean FlexCAN_Ip_GetBuffStatusFlag(uint8 instance, uint8 msgBuffIdx)
{
    c280:	b500      	push	{lr}
    c282:	b085      	sub	sp, #20
    c284:	4603      	mov	r3, r0
    c286:	460a      	mov	r2, r1
    c288:	f88d 3007 	strb.w	r3, [sp, #7]
    c28c:	4613      	mov	r3, r2
    c28e:	f88d 3006 	strb.w	r3, [sp, #6]
    boolean returnResult;
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    const FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    c292:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c296:	4a0b      	ldr	r2, [pc, #44]	; (c2c4 <FlexCAN_Ip_GetBuffStatusFlag+0x44>)
    c298:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c29c:	9303      	str	r3, [sp, #12]
        returnResult = ((1U == FlexCAN_GetEnhancedRxFIFOStatusFlag(pBase, FLEXCAN_IP_ENHANCED_RXFIFO_OVERFLOW)) ? TRUE : FALSE);
    }
    else
#endif
    {
        returnResult = ((1U == FlexCAN_GetBuffStatusFlag(pBase, msgBuffIdx)) ? TRUE : FALSE);
    c29e:	f89d 3006 	ldrb.w	r3, [sp, #6]
    c2a2:	4619      	mov	r1, r3
    c2a4:	9803      	ldr	r0, [sp, #12]
    c2a6:	f7fd fd44 	bl	9d32 <FlexCAN_GetBuffStatusFlag>
    c2aa:	4603      	mov	r3, r0
    c2ac:	2b01      	cmp	r3, #1
    c2ae:	bf0c      	ite	eq
    c2b0:	2301      	moveq	r3, #1
    c2b2:	2300      	movne	r3, #0
    c2b4:	f88d 300b 	strb.w	r3, [sp, #11]
    }
    return returnResult;
    c2b8:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
    c2bc:	4618      	mov	r0, r3
    c2be:	b005      	add	sp, #20
    c2c0:	f85d fb04 	ldr.w	pc, [sp], #4
    c2c4:	00015be8 	.word	0x00015be8

0000c2c8 <FlexCAN_Ip_ClearBuffStatusFlag>:
 * Description   : Clear FlexCAN Message Buffer Status Flag.
 * In case msgBuff is 255 will clear Enhanced Overflow Status Flag.
 *END**************************************************************************/
/* implements FlexCAN_Ip_ClearBuffStatusFlag_Activity */
void FlexCAN_Ip_ClearBuffStatusFlag(uint8 instance, uint8 msgBuffIdx)
{
    c2c8:	b500      	push	{lr}
    c2ca:	b085      	sub	sp, #20
    c2cc:	4603      	mov	r3, r0
    c2ce:	460a      	mov	r2, r1
    c2d0:	f88d 3007 	strb.w	r3, [sp, #7]
    c2d4:	4613      	mov	r3, r2
    c2d6:	f88d 3006 	strb.w	r3, [sp, #6]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    c2da:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c2de:	4a07      	ldr	r2, [pc, #28]	; (c2fc <FlexCAN_Ip_ClearBuffStatusFlag+0x34>)
    c2e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c2e4:	9303      	str	r3, [sp, #12]
        FlexCAN_ClearEnhancedRxFifoIntStatusFlag(pBase, FLEXCAN_IP_ENHANCED_RXFIFO_OVERFLOW);
    }
    else
#endif
    {
        FlexCAN_ClearMsgBuffIntStatusFlag(pBase, msgBuffIdx);
    c2e6:	f89d 3006 	ldrb.w	r3, [sp, #6]
    c2ea:	4619      	mov	r1, r3
    c2ec:	9803      	ldr	r0, [sp, #12]
    c2ee:	f7fd fd0d 	bl	9d0c <FlexCAN_ClearMsgBuffIntStatusFlag>
    }
}
    c2f2:	bf00      	nop
    c2f4:	b005      	add	sp, #20
    c2f6:	f85d fb04 	ldr.w	pc, [sp], #4
    c2fa:	bf00      	nop
    c2fc:	00015be8 	.word	0x00015be8

0000c300 <FlexCAN_Ip_EnableInterrupts_Privileged>:
 * Description   : Enable all mb interrupts configured.
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_EnableInterrupts_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_EnableInterrupts_Privileged(uint8 u8Instance)
{
    c300:	b500      	push	{lr}
    c302:	b087      	sub	sp, #28
    c304:	4603      	mov	r3, r0
    c306:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    c30a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c30e:	4a11      	ldr	r2, [pc, #68]	; (c354 <FlexCAN_Ip_EnableInterrupts_Privileged+0x54>)
    c310:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c314:	9304      	str	r3, [sp, #16]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_ERROR;
    c316:	2301      	movs	r3, #1
    c318:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[u8Instance];
    c31a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c31e:	4a0e      	ldr	r2, [pc, #56]	; (c358 <FlexCAN_Ip_EnableInterrupts_Privileged+0x58>)
    c320:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c324:	9303      	str	r3, [sp, #12]

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(u8Instance < FLEXCAN_INSTANCE_COUNT);
#endif

    if (TRUE == FlexCAN_IsEnabled(pBase))
    c326:	9804      	ldr	r0, [sp, #16]
    c328:	f7fd fc96 	bl	9c58 <FlexCAN_IsEnabled>
    c32c:	4603      	mov	r3, r0
    c32e:	2b00      	cmp	r3, #0
    c330:	d00b      	beq.n	c34a <FlexCAN_Ip_EnableInterrupts_Privileged+0x4a>
    {
        FlexCAN_EnableInterrupts(pBase, u8Instance);
    c332:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c336:	4619      	mov	r1, r3
    c338:	9804      	ldr	r0, [sp, #16]
    c33a:	f000 ffe1 	bl	d300 <FlexCAN_EnableInterrupts>
            {
                FlexCAN_SetEnhancedRxFifoIntAll(pBase, TRUE);
            }
        }
    #endif
        state->isIntActive = TRUE;
    c33e:	9b03      	ldr	r3, [sp, #12]
    c340:	2201      	movs	r2, #1
    c342:	f883 221c 	strb.w	r2, [r3, #540]	; 0x21c
        result = FLEXCAN_STATUS_SUCCESS;
    c346:	2300      	movs	r3, #0
    c348:	9305      	str	r3, [sp, #20]
    }

    return result;
    c34a:	9b05      	ldr	r3, [sp, #20]
}
    c34c:	4618      	mov	r0, r3
    c34e:	b007      	add	sp, #28
    c350:	f85d fb04 	ldr.w	pc, [sp], #4
    c354:	00015be8 	.word	0x00015be8
    c358:	1fff9048 	.word	0x1fff9048

0000c35c <FlexCAN_Ip_DisableInterrupts_Privileged>:
 * Description   : Enable all interrupts configured.
 *
 *END**************************************************************************/
 /* implements FlexCAN_Ip_DisableInterrupts_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_DisableInterrupts_Privileged(uint8 u8Instance)
{
    c35c:	b500      	push	{lr}
    c35e:	b087      	sub	sp, #28
    c360:	4603      	mov	r3, r0
    c362:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    c366:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c36a:	4a10      	ldr	r2, [pc, #64]	; (c3ac <FlexCAN_Ip_DisableInterrupts_Privileged+0x50>)
    c36c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c370:	9304      	str	r3, [sp, #16]
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_ERROR;
    c372:	2301      	movs	r3, #1
    c374:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[u8Instance];
    c376:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c37a:	4a0d      	ldr	r2, [pc, #52]	; (c3b0 <FlexCAN_Ip_DisableInterrupts_Privileged+0x54>)
    c37c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c380:	9303      	str	r3, [sp, #12]

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(u8Instance < FLEXCAN_INSTANCE_COUNT);
#endif

    if (TRUE == FlexCAN_IsEnabled(pBase))
    c382:	9804      	ldr	r0, [sp, #16]
    c384:	f7fd fc68 	bl	9c58 <FlexCAN_IsEnabled>
    c388:	4603      	mov	r3, r0
    c38a:	2b00      	cmp	r3, #0
    c38c:	d008      	beq.n	c3a0 <FlexCAN_Ip_DisableInterrupts_Privileged+0x44>
    {
        FlexCAN_DisableInterrupts(pBase);
    c38e:	9804      	ldr	r0, [sp, #16]
    c390:	f000 ffae 	bl	d2f0 <FlexCAN_DisableInterrupts>
            {
                FlexCAN_SetEnhancedRxFifoIntAll(pBase, FALSE);
            }
        }
#endif
        state->isIntActive = FALSE;
    c394:	9b03      	ldr	r3, [sp, #12]
    c396:	2200      	movs	r2, #0
    c398:	f883 221c 	strb.w	r2, [r3, #540]	; 0x21c
        result = FLEXCAN_STATUS_SUCCESS;
    c39c:	2300      	movs	r3, #0
    c39e:	9305      	str	r3, [sp, #20]
    }

    return result;
    c3a0:	9b05      	ldr	r3, [sp, #20]
}
    c3a2:	4618      	mov	r0, r3
    c3a4:	b007      	add	sp, #28
    c3a6:	f85d fb04 	ldr.w	pc, [sp], #4
    c3aa:	bf00      	nop
    c3ac:	00015be8 	.word	0x00015be8
    c3b0:	1fff9048 	.word	0x1fff9048

0000c3b4 <FlexCAN_Ip_SetErrorInt_Privileged>:
 * Description   : Enable\Disable Error or BusOff Interrupt
 *
 *END**************************************************************************/
/* implements FlexCAN_Ip_SetErrorInt_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetErrorInt_Privileged(uint8 u8Instance, Flexcan_Ip_ErrorIntType type, boolean enable)
{
    c3b4:	b500      	push	{lr}
    c3b6:	b087      	sub	sp, #28
    c3b8:	4603      	mov	r3, r0
    c3ba:	9100      	str	r1, [sp, #0]
    c3bc:	f88d 3007 	strb.w	r3, [sp, #7]
    c3c0:	4613      	mov	r3, r2
    c3c2:	f88d 3006 	strb.w	r3, [sp, #6]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(u8Instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    c3c6:	2300      	movs	r3, #0
    c3c8:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    c3ca:	2300      	movs	r3, #0
    c3cc:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    c3ce:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c3d2:	4a3a      	ldr	r2, [pc, #232]	; (c4bc <FlexCAN_Ip_SetErrorInt_Privileged+0x108>)
    c3d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c3d8:	9303      	str	r3, [sp, #12]
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    c3da:	9803      	ldr	r0, [sp, #12]
    c3dc:	f7fd fc3c 	bl	9c58 <FlexCAN_IsEnabled>
    c3e0:	4603      	mov	r3, r0
    c3e2:	2b00      	cmp	r3, #0
    c3e4:	bf14      	ite	ne
    c3e6:	2301      	movne	r3, #1
    c3e8:	2300      	moveq	r3, #0
    c3ea:	b2db      	uxtb	r3, r3
    c3ec:	f083 0301 	eor.w	r3, r3, #1
    c3f0:	b2db      	uxtb	r3, r3
    c3f2:	f88d 300b 	strb.w	r3, [sp, #11]
    c3f6:	f89d 300b 	ldrb.w	r3, [sp, #11]
    c3fa:	f003 0301 	and.w	r3, r3, #1
    c3fe:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    c402:	f89d 300b 	ldrb.w	r3, [sp, #11]
    c406:	2b00      	cmp	r3, #0
    c408:	d003      	beq.n	c412 <FlexCAN_Ip_SetErrorInt_Privileged+0x5e>
    {
        result = FlexCAN_Enable(pBase);
    c40a:	9803      	ldr	r0, [sp, #12]
    c40c:	f000 fc46 	bl	cc9c <FlexCAN_Enable>
    c410:	9005      	str	r0, [sp, #20]
    }

    if (FLEXCAN_STATUS_SUCCESS == result)
    c412:	9b05      	ldr	r3, [sp, #20]
    c414:	2b00      	cmp	r3, #0
    c416:	d13c      	bne.n	c492 <FlexCAN_Ip_SetErrorInt_Privileged+0xde>
    c418:	9b00      	ldr	r3, [sp, #0]
    c41a:	2b04      	cmp	r3, #4
    c41c:	d83b      	bhi.n	c496 <FlexCAN_Ip_SetErrorInt_Privileged+0xe2>
    c41e:	a201      	add	r2, pc, #4	; (adr r2, c424 <FlexCAN_Ip_SetErrorInt_Privileged+0x70>)
    c420:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    c424:	0000c46f 	.word	0x0000c46f
    c428:	0000c481 	.word	0x0000c481
    c42c:	0000c44b 	.word	0x0000c44b
    c430:	0000c45d 	.word	0x0000c45d
    c434:	0000c439 	.word	0x0000c439
    {
        switch (type)
        {
            case FLEXCAN_IP_INT_BUSOFF:
            {
                FlexCAN_SetErrIntCmd(pBase, FLEXCAN_INT_BUSOFF, enable);
    c438:	f89d 3006 	ldrb.w	r3, [sp, #6]
    c43c:	461a      	mov	r2, r3
    c43e:	f44f 4100 	mov.w	r1, #32768	; 0x8000
    c442:	9803      	ldr	r0, [sp, #12]
    c444:	f000 fce8 	bl	ce18 <FlexCAN_SetErrIntCmd>
                break;
    c448:	e026      	b.n	c498 <FlexCAN_Ip_SetErrorInt_Privileged+0xe4>
            }
            case FLEXCAN_IP_INT_ERR:
            {
                FlexCAN_SetErrIntCmd(pBase, FLEXCAN_INT_ERR, enable);
    c44a:	f89d 3006 	ldrb.w	r3, [sp, #6]
    c44e:	461a      	mov	r2, r3
    c450:	f44f 4180 	mov.w	r1, #16384	; 0x4000
    c454:	9803      	ldr	r0, [sp, #12]
    c456:	f000 fcdf 	bl	ce18 <FlexCAN_SetErrIntCmd>
                break;
    c45a:	e01d      	b.n	c498 <FlexCAN_Ip_SetErrorInt_Privileged+0xe4>
            }
            case FLEXCAN_IP_INT_ERR_FAST :
            {
                FlexCAN_SetErrIntCmd(pBase, FLEXCAN_INT_ERR_FAST, enable);
    c45c:	f89d 3006 	ldrb.w	r3, [sp, #6]
    c460:	461a      	mov	r2, r3
    c462:	f244 0101 	movw	r1, #16385	; 0x4001
    c466:	9803      	ldr	r0, [sp, #12]
    c468:	f000 fcd6 	bl	ce18 <FlexCAN_SetErrIntCmd>
                break;
    c46c:	e014      	b.n	c498 <FlexCAN_Ip_SetErrorInt_Privileged+0xe4>
                    {
                        result = FLEXCAN_STATUS_ERROR;
                    }else
                #endif
                {
                    FlexCAN_SetErrIntCmd(pBase, FLEXCAN_INT_RX_WARNING, enable);
    c46e:	f89d 3006 	ldrb.w	r3, [sp, #6]
    c472:	461a      	mov	r2, r3
    c474:	f44f 6180 	mov.w	r1, #1024	; 0x400
    c478:	9803      	ldr	r0, [sp, #12]
    c47a:	f000 fccd 	bl	ce18 <FlexCAN_SetErrIntCmd>
                }
                break;
    c47e:	e00b      	b.n	c498 <FlexCAN_Ip_SetErrorInt_Privileged+0xe4>
                    {
                        result = FLEXCAN_STATUS_ERROR;
                    }else
                #endif
                {
                    FlexCAN_SetErrIntCmd(pBase, FLEXCAN_INT_TX_WARNING, enable);
    c480:	f89d 3006 	ldrb.w	r3, [sp, #6]
    c484:	461a      	mov	r2, r3
    c486:	f44f 6100 	mov.w	r1, #2048	; 0x800
    c48a:	9803      	ldr	r0, [sp, #12]
    c48c:	f000 fcc4 	bl	ce18 <FlexCAN_SetErrIntCmd>
                }
                break;
    c490:	e002      	b.n	c498 <FlexCAN_Ip_SetErrorInt_Privileged+0xe4>
                    /* Should not get here */
                #endif
                break;
            }
        }
    }
    c492:	bf00      	nop
    c494:	e000      	b.n	c498 <FlexCAN_Ip_SetErrorInt_Privileged+0xe4>
                break;
    c496:	bf00      	nop

    if (TRUE == disabled)
    c498:	f89d 300b 	ldrb.w	r3, [sp, #11]
    c49c:	2b00      	cmp	r3, #0
    c49e:	d008      	beq.n	c4b2 <FlexCAN_Ip_SetErrorInt_Privileged+0xfe>
    {
        status = FlexCAN_Disable(pBase);
    c4a0:	9803      	ldr	r0, [sp, #12]
    c4a2:	f000 fc79 	bl	cd98 <FlexCAN_Disable>
    c4a6:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    c4a8:	9b04      	ldr	r3, [sp, #16]
    c4aa:	2b00      	cmp	r3, #0
    c4ac:	d001      	beq.n	c4b2 <FlexCAN_Ip_SetErrorInt_Privileged+0xfe>
        {
            result = status;
    c4ae:	9b04      	ldr	r3, [sp, #16]
    c4b0:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    c4b2:	9b05      	ldr	r3, [sp, #20]
}
    c4b4:	4618      	mov	r0, r3
    c4b6:	b007      	add	sp, #28
    c4b8:	f85d fb04 	ldr.w	pc, [sp], #4
    c4bc:	00015be8 	.word	0x00015be8

0000c4c0 <FlexCAN_Ip_AbortTransfer>:
 * receiver.
 *
 *END**************************************************************************/
/* implements    FlexCAN_Ip_AbortTransfer_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_AbortTransfer(uint8 u8Instance, uint8 mb_idx)
{
    c4c0:	b500      	push	{lr}
    c4c2:	b087      	sub	sp, #28
    c4c4:	4603      	mov	r3, r0
    c4c6:	460a      	mov	r2, r1
    c4c8:	f88d 3007 	strb.w	r3, [sp, #7]
    c4cc:	4613      	mov	r3, r2
    c4ce:	f88d 3006 	strb.w	r3, [sp, #6]
    #if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
        DevAssert(u8Instance < FLEXCAN_INSTANCE_COUNT);
        DevAssert((mb_idx < (uint8)FLEXCAN_IP_FEATURE_MAX_MB_NUM) || (255u == mb_idx));
    #endif
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[u8Instance];
    c4d2:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c4d6:	4a27      	ldr	r2, [pc, #156]	; (c574 <FlexCAN_Ip_AbortTransfer+0xb4>)
    c4d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c4dc:	9304      	str	r3, [sp, #16]
#if ((FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) && (FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE == STD_ON))
    Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[u8Instance];
#else
    const Flexcan_Ip_StateType * state = Flexcan_Ip_apxState[u8Instance];
    c4de:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c4e2:	4a25      	ldr	r2, [pc, #148]	; (c578 <FlexCAN_Ip_AbortTransfer+0xb8>)
    c4e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c4e8:	9303      	str	r3, [sp, #12]
#endif /* (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) && (FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE == STD_ON) */
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    c4ea:	2300      	movs	r3, #0
    c4ec:	9305      	str	r3, [sp, #20]

    if (mb_idx < (uint8)FLEXCAN_IP_FEATURE_MAX_MB_NUM)
    c4ee:	f89d 3006 	ldrb.w	r3, [sp, #6]
    c4f2:	2b1f      	cmp	r3, #31
    c4f4:	d838      	bhi.n	c568 <FlexCAN_Ip_AbortTransfer+0xa8>
    {

    if (FLEXCAN_MB_IDLE == state->mbs[mb_idx].state)
    c4f6:	f89d 3006 	ldrb.w	r3, [sp, #6]
    c4fa:	9a03      	ldr	r2, [sp, #12]
    c4fc:	011b      	lsls	r3, r3, #4
    c4fe:	4413      	add	r3, r2
    c500:	3304      	adds	r3, #4
    c502:	681b      	ldr	r3, [r3, #0]
    c504:	2b00      	cmp	r3, #0
    c506:	d102      	bne.n	c50e <FlexCAN_Ip_AbortTransfer+0x4e>
    {
        result = FLEXCAN_STATUS_NO_TRANSFER_IN_PROGRESS;
    c508:	2305      	movs	r3, #5
    c50a:	9305      	str	r3, [sp, #20]
    c50c:	e02c      	b.n	c568 <FlexCAN_Ip_AbortTransfer+0xa8>
    }
    else
    {
        FLEXCAN_ClearMsgBuffIntCmd(pBase, u8Instance, mb_idx, state->isIntActive);
    c50e:	f89d 2006 	ldrb.w	r2, [sp, #6]
    c512:	9b03      	ldr	r3, [sp, #12]
    c514:	f893 321c 	ldrb.w	r3, [r3, #540]	; 0x21c
    c518:	f89d 1007 	ldrb.w	r1, [sp, #7]
    c51c:	9804      	ldr	r0, [sp, #16]
    c51e:	f000 feb3 	bl	d288 <FLEXCAN_ClearMsgBuffIntCmd>
        if (FLEXCAN_MB_TX_BUSY == state->mbs[mb_idx].state)
    c522:	f89d 3006 	ldrb.w	r3, [sp, #6]
    c526:	9a03      	ldr	r2, [sp, #12]
    c528:	011b      	lsls	r3, r3, #4
    c52a:	4413      	add	r3, r2
    c52c:	3304      	adds	r3, #4
    c52e:	681b      	ldr	r3, [r3, #0]
    c530:	2b02      	cmp	r3, #2
    c532:	d108      	bne.n	c546 <FlexCAN_Ip_AbortTransfer+0x86>
        {
            result = FlexCAN_AbortTxTransfer(u8Instance, mb_idx);
    c534:	f89d 2006 	ldrb.w	r2, [sp, #6]
    c538:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c53c:	4611      	mov	r1, r2
    c53e:	4618      	mov	r0, r3
    c540:	f7fe fabc 	bl	aabc <FlexCAN_AbortTxTransfer>
    c544:	9005      	str	r0, [sp, #20]
        }

        if (FLEXCAN_MB_RX_BUSY == state->mbs[mb_idx].state)
    c546:	f89d 3006 	ldrb.w	r3, [sp, #6]
    c54a:	9a03      	ldr	r2, [sp, #12]
    c54c:	011b      	lsls	r3, r3, #4
    c54e:	4413      	add	r3, r2
    c550:	3304      	adds	r3, #4
    c552:	681b      	ldr	r3, [r3, #0]
    c554:	2b01      	cmp	r3, #1
    c556:	d107      	bne.n	c568 <FlexCAN_Ip_AbortTransfer+0xa8>
        {
            FlexCAN_AbortRxTransfer(u8Instance, mb_idx);
    c558:	f89d 2006 	ldrb.w	r2, [sp, #6]
    c55c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c560:	4611      	mov	r1, r2
    c562:	4618      	mov	r0, r3
    c564:	f7fe fb34 	bl	abd0 <FlexCAN_AbortRxTransfer>
        }
    }
#endif /* if FLEXCAN_IP_FEATURE_HAS_DMA_ENABLE */
#endif /* if FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO */

    return result;
    c568:	9b05      	ldr	r3, [sp, #20]
}
    c56a:	4618      	mov	r0, r3
    c56c:	b007      	add	sp, #28
    c56e:	f85d fb04 	ldr.w	pc, [sp], #4
    c572:	bf00      	nop
    c574:	00015be8 	.word	0x00015be8
    c578:	1fff9048 	.word	0x1fff9048

0000c57c <FlexCAN_Ip_SetRxMb14Mask_Privileged>:

/* implements    FlexCAN_Ip_SetRxMb14Mask_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetRxMb14Mask_Privileged(uint8 instance, uint32 mask)
{
    c57c:	b500      	push	{lr}
    c57e:	b087      	sub	sp, #28
    c580:	4603      	mov	r3, r0
    c582:	9100      	str	r1, [sp, #0]
    c584:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    c588:	2300      	movs	r3, #0
    c58a:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    c58c:	2300      	movs	r3, #0
    c58e:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    c590:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c594:	4a1b      	ldr	r2, [pc, #108]	; (c604 <FlexCAN_Ip_SetRxMb14Mask_Privileged+0x88>)
    c596:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c59a:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    boolean freeze = FALSE;
#endif
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    c59c:	9803      	ldr	r0, [sp, #12]
    c59e:	f7fd fb5b 	bl	9c58 <FlexCAN_IsEnabled>
    c5a2:	4603      	mov	r3, r0
    c5a4:	2b00      	cmp	r3, #0
    c5a6:	bf14      	ite	ne
    c5a8:	2301      	movne	r3, #1
    c5aa:	2300      	moveq	r3, #0
    c5ac:	b2db      	uxtb	r3, r3
    c5ae:	f083 0301 	eor.w	r3, r3, #1
    c5b2:	b2db      	uxtb	r3, r3
    c5b4:	f88d 300b 	strb.w	r3, [sp, #11]
    c5b8:	f89d 300b 	ldrb.w	r3, [sp, #11]
    c5bc:	f003 0301 	and.w	r3, r3, #1
    c5c0:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    c5c4:	f89d 300b 	ldrb.w	r3, [sp, #11]
    c5c8:	2b00      	cmp	r3, #0
    c5ca:	d003      	beq.n	c5d4 <FlexCAN_Ip_SetRxMb14Mask_Privileged+0x58>
    {
        result = FlexCAN_Enable(pBase);
    c5cc:	9803      	ldr	r0, [sp, #12]
    c5ce:	f000 fb65 	bl	cc9c <FlexCAN_Enable>
    c5d2:	9005      	str	r0, [sp, #20]
    if ((FALSE == freeze) && (FLEXCAN_STATUS_SUCCESS == result))
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif
    if (FLEXCAN_STATUS_SUCCESS == result)
    c5d4:	9b05      	ldr	r3, [sp, #20]
    c5d6:	2b00      	cmp	r3, #0
    c5d8:	d102      	bne.n	c5e0 <FlexCAN_Ip_SetRxMb14Mask_Privileged+0x64>
    {
        pBase->RX14MASK = mask;
    c5da:	9b03      	ldr	r3, [sp, #12]
    c5dc:	9a00      	ldr	r2, [sp, #0]
    c5de:	615a      	str	r2, [r3, #20]
    }
    if (TRUE == disabled)
    c5e0:	f89d 300b 	ldrb.w	r3, [sp, #11]
    c5e4:	2b00      	cmp	r3, #0
    c5e6:	d008      	beq.n	c5fa <FlexCAN_Ip_SetRxMb14Mask_Privileged+0x7e>
    {
        status = FlexCAN_Disable(pBase);
    c5e8:	9803      	ldr	r0, [sp, #12]
    c5ea:	f000 fbd5 	bl	cd98 <FlexCAN_Disable>
    c5ee:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    c5f0:	9b04      	ldr	r3, [sp, #16]
    c5f2:	2b00      	cmp	r3, #0
    c5f4:	d001      	beq.n	c5fa <FlexCAN_Ip_SetRxMb14Mask_Privileged+0x7e>
        {
            result = status;
    c5f6:	9b04      	ldr	r3, [sp, #16]
    c5f8:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    c5fa:	9b05      	ldr	r3, [sp, #20]
}
    c5fc:	4618      	mov	r0, r3
    c5fe:	b007      	add	sp, #28
    c600:	f85d fb04 	ldr.w	pc, [sp], #4
    c604:	00015be8 	.word	0x00015be8

0000c608 <FlexCAN_Ip_SetRxMb15Mask_Privileged>:

/* implements    FlexCAN_Ip_SetRxMb15Mask_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetRxMb15Mask_Privileged(uint8 instance, uint32 mask)
{
    c608:	b500      	push	{lr}
    c60a:	b087      	sub	sp, #28
    c60c:	4603      	mov	r3, r0
    c60e:	9100      	str	r1, [sp, #0]
    c610:	f88d 3007 	strb.w	r3, [sp, #7]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    c614:	2300      	movs	r3, #0
    c616:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    c618:	2300      	movs	r3, #0
    c61a:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    c61c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c620:	4a1b      	ldr	r2, [pc, #108]	; (c690 <FlexCAN_Ip_SetRxMb15Mask_Privileged+0x88>)
    c622:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c626:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    boolean freeze = FALSE;
#endif
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    c628:	9803      	ldr	r0, [sp, #12]
    c62a:	f7fd fb15 	bl	9c58 <FlexCAN_IsEnabled>
    c62e:	4603      	mov	r3, r0
    c630:	2b00      	cmp	r3, #0
    c632:	bf14      	ite	ne
    c634:	2301      	movne	r3, #1
    c636:	2300      	moveq	r3, #0
    c638:	b2db      	uxtb	r3, r3
    c63a:	f083 0301 	eor.w	r3, r3, #1
    c63e:	b2db      	uxtb	r3, r3
    c640:	f88d 300b 	strb.w	r3, [sp, #11]
    c644:	f89d 300b 	ldrb.w	r3, [sp, #11]
    c648:	f003 0301 	and.w	r3, r3, #1
    c64c:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    c650:	f89d 300b 	ldrb.w	r3, [sp, #11]
    c654:	2b00      	cmp	r3, #0
    c656:	d003      	beq.n	c660 <FlexCAN_Ip_SetRxMb15Mask_Privileged+0x58>
    {
        result = FlexCAN_Enable(pBase);
    c658:	9803      	ldr	r0, [sp, #12]
    c65a:	f000 fb1f 	bl	cc9c <FlexCAN_Enable>
    c65e:	9005      	str	r0, [sp, #20]
    if ((FALSE == freeze) && (FLEXCAN_STATUS_SUCCESS == result))
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif
    if (FLEXCAN_STATUS_SUCCESS == result)
    c660:	9b05      	ldr	r3, [sp, #20]
    c662:	2b00      	cmp	r3, #0
    c664:	d102      	bne.n	c66c <FlexCAN_Ip_SetRxMb15Mask_Privileged+0x64>
    {
        pBase->RX15MASK = mask;
    c666:	9b03      	ldr	r3, [sp, #12]
    c668:	9a00      	ldr	r2, [sp, #0]
    c66a:	619a      	str	r2, [r3, #24]
    }

    if (TRUE == disabled)
    c66c:	f89d 300b 	ldrb.w	r3, [sp, #11]
    c670:	2b00      	cmp	r3, #0
    c672:	d008      	beq.n	c686 <FlexCAN_Ip_SetRxMb15Mask_Privileged+0x7e>
    {
        status = FlexCAN_Disable(pBase);
    c674:	9803      	ldr	r0, [sp, #12]
    c676:	f000 fb8f 	bl	cd98 <FlexCAN_Disable>
    c67a:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    c67c:	9b04      	ldr	r3, [sp, #16]
    c67e:	2b00      	cmp	r3, #0
    c680:	d001      	beq.n	c686 <FlexCAN_Ip_SetRxMb15Mask_Privileged+0x7e>
        {
            result = status;
    c682:	9b04      	ldr	r3, [sp, #16]
    c684:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    c686:	9b05      	ldr	r3, [sp, #20]
}
    c688:	4618      	mov	r0, r3
    c68a:	b007      	add	sp, #28
    c68c:	f85d fb04 	ldr.w	pc, [sp], #4
    c690:	00015be8 	.word	0x00015be8

0000c694 <FlexCAN_Ip_SetListenOnlyMode_Privileged>:
 * This function will enable or disable Listen Only mode.
 *
 *END**************************************************************************/
/* implements  FlexCAN_Ip_SetListenOnlyMode_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_SetListenOnlyMode_Privileged(uint8 instance, const boolean enable)
{
    c694:	b500      	push	{lr}
    c696:	b087      	sub	sp, #28
    c698:	4603      	mov	r3, r0
    c69a:	460a      	mov	r2, r1
    c69c:	f88d 3007 	strb.w	r3, [sp, #7]
    c6a0:	4613      	mov	r3, r2
    c6a2:	f88d 3006 	strb.w	r3, [sp, #6]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(instance < FLEXCAN_INSTANCE_COUNT);
#endif
    Flexcan_Ip_StatusType result = FLEXCAN_STATUS_SUCCESS;
    c6a6:	2300      	movs	r3, #0
    c6a8:	9305      	str	r3, [sp, #20]
    Flexcan_Ip_StatusType status = FLEXCAN_STATUS_SUCCESS;
    c6aa:	2300      	movs	r3, #0
    c6ac:	9304      	str	r3, [sp, #16]
    FLEXCAN_Type * pBase = Flexcan_Ip_apxBase[instance];
    c6ae:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c6b2:	4a1f      	ldr	r2, [pc, #124]	; (c730 <FlexCAN_Ip_SetListenOnlyMode_Privileged+0x9c>)
    c6b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c6b8:	9303      	str	r3, [sp, #12]
    boolean disabled = !FlexCAN_IsEnabled(pBase);
    c6ba:	9803      	ldr	r0, [sp, #12]
    c6bc:	f7fd facc 	bl	9c58 <FlexCAN_IsEnabled>
    c6c0:	4603      	mov	r3, r0
    c6c2:	2b00      	cmp	r3, #0
    c6c4:	bf14      	ite	ne
    c6c6:	2301      	movne	r3, #1
    c6c8:	2300      	moveq	r3, #0
    c6ca:	b2db      	uxtb	r3, r3
    c6cc:	f083 0301 	eor.w	r3, r3, #1
    c6d0:	b2db      	uxtb	r3, r3
    c6d2:	f88d 300b 	strb.w	r3, [sp, #11]
    c6d6:	f89d 300b 	ldrb.w	r3, [sp, #11]
    c6da:	f003 0301 	and.w	r3, r3, #1
    c6de:	f88d 300b 	strb.w	r3, [sp, #11]

    if (TRUE == disabled)
    c6e2:	f89d 300b 	ldrb.w	r3, [sp, #11]
    c6e6:	2b00      	cmp	r3, #0
    c6e8:	d003      	beq.n	c6f2 <FlexCAN_Ip_SetListenOnlyMode_Privileged+0x5e>
    {
        result = FlexCAN_Enable(pBase);
    c6ea:	9803      	ldr	r0, [sp, #12]
    c6ec:	f000 fad6 	bl	cc9c <FlexCAN_Enable>
    c6f0:	9005      	str	r0, [sp, #20]
    {
        result = FLEXCAN_STATUS_ERROR;
    }
#endif

    if (FLEXCAN_STATUS_SUCCESS == result)
    c6f2:	9b05      	ldr	r3, [sp, #20]
    c6f4:	2b00      	cmp	r3, #0
    c6f6:	d109      	bne.n	c70c <FlexCAN_Ip_SetListenOnlyMode_Privileged+0x78>
    {
        /* Start critical section: implementation depends on integrator */
        SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10();
    c6f8:	f005 ff5a 	bl	125b0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10>
        FlexCAN_SetListenOnlyMode(pBase, enable);
    c6fc:	f89d 3006 	ldrb.w	r3, [sp, #6]
    c700:	4619      	mov	r1, r3
    c702:	9803      	ldr	r0, [sp, #12]
    c704:	f7fd fae5 	bl	9cd2 <FlexCAN_SetListenOnlyMode>
        /* End critical section: implementation depends on integrator */
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10();
    c708:	f005 ff7e 	bl	12608 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10>
    }

    if (TRUE == disabled)
    c70c:	f89d 300b 	ldrb.w	r3, [sp, #11]
    c710:	2b00      	cmp	r3, #0
    c712:	d008      	beq.n	c726 <FlexCAN_Ip_SetListenOnlyMode_Privileged+0x92>
    {
        status = FlexCAN_Disable(pBase);
    c714:	9803      	ldr	r0, [sp, #12]
    c716:	f000 fb3f 	bl	cd98 <FlexCAN_Disable>
    c71a:	9004      	str	r0, [sp, #16]
        if (FLEXCAN_STATUS_SUCCESS != status)
    c71c:	9b04      	ldr	r3, [sp, #16]
    c71e:	2b00      	cmp	r3, #0
    c720:	d001      	beq.n	c726 <FlexCAN_Ip_SetListenOnlyMode_Privileged+0x92>
        {
            result = status;
    c722:	9b04      	ldr	r3, [sp, #16]
    c724:	9305      	str	r3, [sp, #20]
        }
    }

    return result;
    c726:	9b05      	ldr	r3, [sp, #20]
}
    c728:	4618      	mov	r0, r3
    c72a:	b007      	add	sp, #28
    c72c:	f85d fb04 	ldr.w	pc, [sp], #4
    c730:	00015be8 	.word	0x00015be8

0000c734 <FlexCAN_Ip_GetListenOnlyMode>:
 * Description   : Check if Listen Only mode is ENABLE.
 *
 *END**************************************************************************/
/* implements  FlexCAN_Ip_GetListenOnlyMode_Activity */
boolean FlexCAN_Ip_GetListenOnlyMode(uint8 instance)
{
    c734:	b500      	push	{lr}
    c736:	b085      	sub	sp, #20
    c738:	4603      	mov	r3, r0
    c73a:	f88d 3007 	strb.w	r3, [sp, #7]
    const FLEXCAN_Type * base = Flexcan_Ip_apxBase[instance];
    c73e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c742:	4a06      	ldr	r2, [pc, #24]	; (c75c <FlexCAN_Ip_GetListenOnlyMode+0x28>)
    c744:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c748:	9303      	str	r3, [sp, #12]
    return FlexCAN_IsListenOnlyModeEnabled(base);
    c74a:	9803      	ldr	r0, [sp, #12]
    c74c:	f7fd fc5d 	bl	a00a <FlexCAN_IsListenOnlyModeEnabled>
    c750:	4603      	mov	r3, r0
}
    c752:	4618      	mov	r0, r3
    c754:	b005      	add	sp, #20
    c756:	f85d fb04 	ldr.w	pc, [sp], #4
    c75a:	bf00      	nop
    c75c:	00015be8 	.word	0x00015be8

0000c760 <FlexCAN_Ip_ManualBusOffRecovery>:
 * Description   : Recover manually from bus-off if possible.
 *
 *END**************************************************************************/
/* implements  FlexCAN_Ip_ManualBusOffRecovery_Activity */
Flexcan_Ip_StatusType FlexCAN_Ip_ManualBusOffRecovery(uint8 Instance)
{
    c760:	b500      	push	{lr}
    c762:	b089      	sub	sp, #36	; 0x24
    c764:	4603      	mov	r3, r0
    c766:	f88d 3007 	strb.w	r3, [sp, #7]
    FLEXCAN_Type * Base = Flexcan_Ip_apxBase[Instance];
    c76a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c76e:	4a27      	ldr	r2, [pc, #156]	; (c80c <FlexCAN_Ip_ManualBusOffRecovery+0xac>)
    c770:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    c774:	9305      	str	r3, [sp, #20]
    uint32 timeStart = 0U;
    c776:	2300      	movs	r3, #0
    c778:	9303      	str	r3, [sp, #12]
    uint32 timeElapsed = 0U;
    c77a:	2300      	movs	r3, #0
    c77c:	9307      	str	r3, [sp, #28]
    uint32 uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    c77e:	2100      	movs	r1, #0
    c780:	4823      	ldr	r0, [pc, #140]	; (c810 <FlexCAN_Ip_ManualBusOffRecovery+0xb0>)
    c782:	f7f5 fb57 	bl	1e34 <OsIf_MicrosToTicks>
    c786:	9004      	str	r0, [sp, #16]
    Flexcan_Ip_StatusType RetVal = FLEXCAN_STATUS_ERROR;
    c788:	2301      	movs	r3, #1
    c78a:	9306      	str	r3, [sp, #24]
#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(Instance < FLEXCAN_INSTANCE_COUNT);
#endif

    /* Recover from bus-off when Automatic recovering from Bus Off state disabled. */
    if ((Base->CTRL1 & FLEXCAN_CTRL1_BOFFREC_MASK) != 0U)
    c78c:	9b05      	ldr	r3, [sp, #20]
    c78e:	685b      	ldr	r3, [r3, #4]
    c790:	f003 0340 	and.w	r3, r3, #64	; 0x40
    c794:	2b00      	cmp	r3, #0
    c796:	d033      	beq.n	c800 <FlexCAN_Ip_ManualBusOffRecovery+0xa0>
    {
        RetVal = FLEXCAN_STATUS_SUCCESS;
    c798:	2300      	movs	r3, #0
    c79a:	9306      	str	r3, [sp, #24]
        /* return success if the controller is not in bus-off */
        if ((Base->ESR1 & FLEXCAN_IP_ESR1_FLTCONF_BUS_OFF) != 0U)
    c79c:	9b05      	ldr	r3, [sp, #20]
    c79e:	6a1b      	ldr	r3, [r3, #32]
    c7a0:	f003 0320 	and.w	r3, r3, #32
    c7a4:	2b00      	cmp	r3, #0
    c7a6:	d02b      	beq.n	c800 <FlexCAN_Ip_ManualBusOffRecovery+0xa0>
        {
            SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20();
    c7a8:	f006 fa36 	bl	12c18 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20>
            /* negate to recover from bus-off */
            Base->CTRL1 &= ~FLEXCAN_CTRL1_BOFFREC_MASK;
    c7ac:	9b05      	ldr	r3, [sp, #20]
    c7ae:	685b      	ldr	r3, [r3, #4]
    c7b0:	f023 0240 	bic.w	r2, r3, #64	; 0x40
    c7b4:	9b05      	ldr	r3, [sp, #20]
    c7b6:	605a      	str	r2, [r3, #4]
            /* re-assert to disable bus-off auto reocvery */
            Base->CTRL1 |= FLEXCAN_CTRL1_BOFFREC_MASK;
    c7b8:	9b05      	ldr	r3, [sp, #20]
    c7ba:	685b      	ldr	r3, [r3, #4]
    c7bc:	f043 0240 	orr.w	r2, r3, #64	; 0x40
    c7c0:	9b05      	ldr	r3, [sp, #20]
    c7c2:	605a      	str	r2, [r3, #4]
            SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20();
    c7c4:	f006 fa54 	bl	12c70 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20>
            /* Wait till exit bus-off */
            timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    c7c8:	2000      	movs	r0, #0
    c7ca:	f7f5 fae7 	bl	1d9c <OsIf_GetCounter>
    c7ce:	4603      	mov	r3, r0
    c7d0:	9303      	str	r3, [sp, #12]

            while ((Base->ESR1 & FLEXCAN_IP_ESR1_FLTCONF_BUS_OFF) != 0U)
    c7d2:	e00f      	b.n	c7f4 <FlexCAN_Ip_ManualBusOffRecovery+0x94>
            {
                timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    c7d4:	ab03      	add	r3, sp, #12
    c7d6:	2100      	movs	r1, #0
    c7d8:	4618      	mov	r0, r3
    c7da:	f7f5 faf8 	bl	1dce <OsIf_GetElapsed>
    c7de:	4602      	mov	r2, r0
    c7e0:	9b07      	ldr	r3, [sp, #28]
    c7e2:	4413      	add	r3, r2
    c7e4:	9307      	str	r3, [sp, #28]
                if (timeElapsed >= uS2Ticks)
    c7e6:	9a07      	ldr	r2, [sp, #28]
    c7e8:	9b04      	ldr	r3, [sp, #16]
    c7ea:	429a      	cmp	r2, r3
    c7ec:	d302      	bcc.n	c7f4 <FlexCAN_Ip_ManualBusOffRecovery+0x94>
                {
                    RetVal = FLEXCAN_STATUS_TIMEOUT;
    c7ee:	2303      	movs	r3, #3
    c7f0:	9306      	str	r3, [sp, #24]
                    break;
    c7f2:	e005      	b.n	c800 <FlexCAN_Ip_ManualBusOffRecovery+0xa0>
            while ((Base->ESR1 & FLEXCAN_IP_ESR1_FLTCONF_BUS_OFF) != 0U)
    c7f4:	9b05      	ldr	r3, [sp, #20]
    c7f6:	6a1b      	ldr	r3, [r3, #32]
    c7f8:	f003 0320 	and.w	r3, r3, #32
    c7fc:	2b00      	cmp	r3, #0
    c7fe:	d1e9      	bne.n	c7d4 <FlexCAN_Ip_ManualBusOffRecovery+0x74>
                }
            }
        }
    }

    return RetVal;
    c800:	9b06      	ldr	r3, [sp, #24]
}
    c802:	4618      	mov	r0, r3
    c804:	b009      	add	sp, #36	; 0x24
    c806:	f85d fb04 	ldr.w	pc, [sp], #4
    c80a:	bf00      	nop
    c80c:	00015be8 	.word	0x00015be8
    c810:	000f4240 	.word	0x000f4240

0000c814 <FlexCAN_SetSelfReception>:
{
    c814:	b082      	sub	sp, #8
    c816:	9001      	str	r0, [sp, #4]
    c818:	460b      	mov	r3, r1
    c81a:	f88d 3003 	strb.w	r3, [sp, #3]
    base->MCR = (base->MCR & ~FLEXCAN_MCR_SRXDIS_MASK) | FLEXCAN_MCR_SRXDIS(enable ? 0UL : 1UL);
    c81e:	9b01      	ldr	r3, [sp, #4]
    c820:	681b      	ldr	r3, [r3, #0]
    c822:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    c826:	f89d 2003 	ldrb.w	r2, [sp, #3]
    c82a:	2a00      	cmp	r2, #0
    c82c:	d001      	beq.n	c832 <FlexCAN_SetSelfReception+0x1e>
    c82e:	2200      	movs	r2, #0
    c830:	e001      	b.n	c836 <FlexCAN_SetSelfReception+0x22>
    c832:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    c836:	431a      	orrs	r2, r3
    c838:	9b01      	ldr	r3, [sp, #4]
    c83a:	601a      	str	r2, [r3, #0]
}
    c83c:	bf00      	nop
    c83e:	b002      	add	sp, #8
    c840:	4770      	bx	lr

0000c842 <FlexCAN_IsFDEnabled>:
{
    c842:	b082      	sub	sp, #8
    c844:	9001      	str	r0, [sp, #4]
    return ((base->MCR & FLEXCAN_MCR_FDEN_MASK) >> FLEXCAN_MCR_FDEN_SHIFT) != 0U;
    c846:	9b01      	ldr	r3, [sp, #4]
    c848:	681b      	ldr	r3, [r3, #0]
    c84a:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    c84e:	2b00      	cmp	r3, #0
    c850:	bf14      	ite	ne
    c852:	2301      	movne	r3, #1
    c854:	2300      	moveq	r3, #0
    c856:	b2db      	uxtb	r3, r3
}
    c858:	4618      	mov	r0, r3
    c85a:	b002      	add	sp, #8
    c85c:	4770      	bx	lr

0000c85e <FlexCAN_SetIsoCan>:
{
    c85e:	b082      	sub	sp, #8
    c860:	9001      	str	r0, [sp, #4]
    c862:	460b      	mov	r3, r1
    c864:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_ISOCANFDEN_MASK) | FLEXCAN_CTRL2_ISOCANFDEN(enable ? 1UL : 0UL);
    c868:	9b01      	ldr	r3, [sp, #4]
    c86a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    c86c:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
    c870:	f89d 2003 	ldrb.w	r2, [sp, #3]
    c874:	2a00      	cmp	r2, #0
    c876:	d002      	beq.n	c87e <FlexCAN_SetIsoCan+0x20>
    c878:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    c87c:	e000      	b.n	c880 <FlexCAN_SetIsoCan+0x22>
    c87e:	2200      	movs	r2, #0
    c880:	431a      	orrs	r2, r3
    c882:	9b01      	ldr	r3, [sp, #4]
    c884:	635a      	str	r2, [r3, #52]	; 0x34
}
    c886:	bf00      	nop
    c888:	b002      	add	sp, #8
    c88a:	4770      	bx	lr

0000c88c <FlexCAN_SetEntireFrameArbitrationFieldComparison>:
{
    c88c:	b082      	sub	sp, #8
    c88e:	9001      	str	r0, [sp, #4]
    c890:	460b      	mov	r3, r1
    c892:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_EACEN_MASK) | FLEXCAN_CTRL2_EACEN(enable ? 1UL : 0UL);
    c896:	9b01      	ldr	r3, [sp, #4]
    c898:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    c89a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
    c89e:	f89d 2003 	ldrb.w	r2, [sp, #3]
    c8a2:	2a00      	cmp	r2, #0
    c8a4:	d002      	beq.n	c8ac <FlexCAN_SetEntireFrameArbitrationFieldComparison+0x20>
    c8a6:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    c8aa:	e000      	b.n	c8ae <FlexCAN_SetEntireFrameArbitrationFieldComparison+0x22>
    c8ac:	2200      	movs	r2, #0
    c8ae:	431a      	orrs	r2, r3
    c8b0:	9b01      	ldr	r3, [sp, #4]
    c8b2:	635a      	str	r2, [r3, #52]	; 0x34
}
    c8b4:	bf00      	nop
    c8b6:	b002      	add	sp, #8
    c8b8:	4770      	bx	lr

0000c8ba <FlexCAN_SetProtocolException>:
{
    c8ba:	b082      	sub	sp, #8
    c8bc:	9001      	str	r0, [sp, #4]
    c8be:	460b      	mov	r3, r1
    c8c0:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_PREXCEN_MASK) | FLEXCAN_CTRL2_PREXCEN(enable ? 1UL : 0UL);
    c8c4:	9b01      	ldr	r3, [sp, #4]
    c8c6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    c8c8:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
    c8cc:	f89d 2003 	ldrb.w	r2, [sp, #3]
    c8d0:	2a00      	cmp	r2, #0
    c8d2:	d002      	beq.n	c8da <FlexCAN_SetProtocolException+0x20>
    c8d4:	f44f 4280 	mov.w	r2, #16384	; 0x4000
    c8d8:	e000      	b.n	c8dc <FlexCAN_SetProtocolException+0x22>
    c8da:	2200      	movs	r2, #0
    c8dc:	431a      	orrs	r2, r3
    c8de:	9b01      	ldr	r3, [sp, #4]
    c8e0:	635a      	str	r2, [r3, #52]	; 0x34
}
    c8e2:	bf00      	nop
    c8e4:	b002      	add	sp, #8
    c8e6:	4770      	bx	lr

0000c8e8 <FlexCAN_SetRemoteReqStore>:
{
    c8e8:	b082      	sub	sp, #8
    c8ea:	9001      	str	r0, [sp, #4]
    c8ec:	460b      	mov	r3, r1
    c8ee:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_RRS_MASK) | FLEXCAN_CTRL2_RRS(enable ? 1UL : 0UL);
    c8f2:	9b01      	ldr	r3, [sp, #4]
    c8f4:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    c8f6:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
    c8fa:	f89d 2003 	ldrb.w	r2, [sp, #3]
    c8fe:	2a00      	cmp	r2, #0
    c900:	d002      	beq.n	c908 <FlexCAN_SetRemoteReqStore+0x20>
    c902:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    c906:	e000      	b.n	c90a <FlexCAN_SetRemoteReqStore+0x22>
    c908:	2200      	movs	r2, #0
    c90a:	431a      	orrs	r2, r3
    c90c:	9b01      	ldr	r3, [sp, #4]
    c90e:	635a      	str	r2, [r3, #52]	; 0x34
}
    c910:	bf00      	nop
    c912:	b002      	add	sp, #8
    c914:	4770      	bx	lr

0000c916 <FlexCAN_SetBusOffAutorecovery>:
{
    c916:	b082      	sub	sp, #8
    c918:	9001      	str	r0, [sp, #4]
    c91a:	460b      	mov	r3, r1
    c91c:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_BOFFREC_MASK) | FLEXCAN_CTRL1_BOFFREC(enable ? 0UL : 1UL);
    c920:	9b01      	ldr	r3, [sp, #4]
    c922:	685b      	ldr	r3, [r3, #4]
    c924:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    c928:	f89d 2003 	ldrb.w	r2, [sp, #3]
    c92c:	2a00      	cmp	r2, #0
    c92e:	d001      	beq.n	c934 <FlexCAN_SetBusOffAutorecovery+0x1e>
    c930:	2200      	movs	r2, #0
    c932:	e000      	b.n	c936 <FlexCAN_SetBusOffAutorecovery+0x20>
    c934:	2240      	movs	r2, #64	; 0x40
    c936:	431a      	orrs	r2, r3
    c938:	9b01      	ldr	r3, [sp, #4]
    c93a:	605a      	str	r2, [r3, #4]
}
    c93c:	bf00      	nop
    c93e:	b002      	add	sp, #8
    c940:	4770      	bx	lr

0000c942 <FlexCAN_SetEdgeFilter>:
{
    c942:	b082      	sub	sp, #8
    c944:	9001      	str	r0, [sp, #4]
    c946:	460b      	mov	r3, r1
    c948:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_EDFLTDIS_MASK) | FLEXCAN_CTRL2_EDFLTDIS(enable ? 0UL : 1UL);
    c94c:	9b01      	ldr	r3, [sp, #4]
    c94e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    c950:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
    c954:	f89d 2003 	ldrb.w	r2, [sp, #3]
    c958:	2a00      	cmp	r2, #0
    c95a:	d001      	beq.n	c960 <FlexCAN_SetEdgeFilter+0x1e>
    c95c:	2200      	movs	r2, #0
    c95e:	e001      	b.n	c964 <FlexCAN_SetEdgeFilter+0x22>
    c960:	f44f 6200 	mov.w	r2, #2048	; 0x800
    c964:	431a      	orrs	r2, r3
    c966:	9b01      	ldr	r3, [sp, #4]
    c968:	635a      	str	r2, [r3, #52]	; 0x34
}
    c96a:	bf00      	nop
    c96c:	b002      	add	sp, #8
    c96e:	4770      	bx	lr

0000c970 <FlexCAN_CanBitSampling>:
{
    c970:	b082      	sub	sp, #8
    c972:	9001      	str	r0, [sp, #4]
    c974:	460b      	mov	r3, r1
    c976:	f88d 3003 	strb.w	r3, [sp, #3]
    base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_SMP_MASK) | FLEXCAN_CTRL1_SMP(enable ? 1UL : 0UL);
    c97a:	9b01      	ldr	r3, [sp, #4]
    c97c:	685b      	ldr	r3, [r3, #4]
    c97e:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    c982:	f89d 2003 	ldrb.w	r2, [sp, #3]
    c986:	2a00      	cmp	r2, #0
    c988:	d001      	beq.n	c98e <FlexCAN_CanBitSampling+0x1e>
    c98a:	2280      	movs	r2, #128	; 0x80
    c98c:	e000      	b.n	c990 <FlexCAN_CanBitSampling+0x20>
    c98e:	2200      	movs	r2, #0
    c990:	431a      	orrs	r2, r3
    c992:	9b01      	ldr	r3, [sp, #4]
    c994:	605a      	str	r2, [r3, #4]
}
    c996:	bf00      	nop
    c998:	b002      	add	sp, #8
    c99a:	4770      	bx	lr

0000c99c <FlexCAN_ComputeDLCValue>:
 * Function Name: FLEXCAN_ComputeDLCValue
 * Description  : Computes the DLC field value, given a payload size (in bytes).
 *
 *END**************************************************************************/
static uint8 FlexCAN_ComputeDLCValue(uint8 payloadSize)
{
    c99c:	b084      	sub	sp, #16
    c99e:	4603      	mov	r3, r0
    c9a0:	f88d 3007 	strb.w	r3, [sp, #7]
    uint32 ret = 0xFFU;                   /* 0,  1,  2,  3,  4,  5,  6,  7,  8, */
    c9a4:	23ff      	movs	r3, #255	; 0xff
    c9a6:	9303      	str	r3, [sp, #12]
                                           FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES,
                                           FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES,
                                           FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES, FLEXCAN_IP_DLC_VALUE_64_BYTES
                                          };

    if (payloadSize <= 64U)
    c9a8:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c9ac:	2b40      	cmp	r3, #64	; 0x40
    c9ae:	d804      	bhi.n	c9ba <FlexCAN_ComputeDLCValue+0x1e>
    {
        ret = payload_code[payloadSize];
    c9b0:	f89d 3007 	ldrb.w	r3, [sp, #7]
    c9b4:	4a03      	ldr	r2, [pc, #12]	; (c9c4 <FlexCAN_ComputeDLCValue+0x28>)
    c9b6:	5cd3      	ldrb	r3, [r2, r3]
    c9b8:	9303      	str	r3, [sp, #12]
    else
    {
        /* The argument is not a valid payload size will return 0xFF*/
    }

    return (uint8)ret;
    c9ba:	9b03      	ldr	r3, [sp, #12]
    c9bc:	b2db      	uxtb	r3, r3
}
    c9be:	4618      	mov	r0, r3
    c9c0:	b004      	add	sp, #16
    c9c2:	4770      	bx	lr
    c9c4:	00015bf4 	.word	0x00015bf4

0000c9c8 <FlexCAN_ClearRAM>:
 * Function Name : FLEXCAN_ClearRAM
 * Description   : Clears FlexCAN memory positions that require initialization.
 *
 *END**************************************************************************/
static void FlexCAN_ClearRAM(FLEXCAN_Type * base)
{
    c9c8:	b500      	push	{lr}
    c9ca:	b087      	sub	sp, #28
    c9cc:	9001      	str	r0, [sp, #4]
    uint32 databyte;
    uint32 RAM_size   = FlexCAN_GetMaxMbNum(base) * 4U;
    c9ce:	9801      	ldr	r0, [sp, #4]
    c9d0:	f000 f8f6 	bl	cbc0 <FlexCAN_GetMaxMbNum>
    c9d4:	4603      	mov	r3, r0
    c9d6:	009b      	lsls	r3, r3, #2
    c9d8:	9304      	str	r3, [sp, #16]
    uint32 RXIMR_size = FlexCAN_GetMaxMbNum(base);
    c9da:	9801      	ldr	r0, [sp, #4]
    c9dc:	f000 f8f0 	bl	cbc0 <FlexCAN_GetMaxMbNum>
    c9e0:	9003      	str	r0, [sp, #12]
    /* Address of base + ram offset to point to MB start address */
    volatile uint32 * RAM = (uint32 *)((Flexcan_Ip_PtrSizeType)base + (uint32)FLEXCAN_IP_FEATURE_RAM_OFFSET);
    c9e2:	9b01      	ldr	r3, [sp, #4]
    c9e4:	3380      	adds	r3, #128	; 0x80
    c9e6:	9302      	str	r3, [sp, #8]
    /* Clear MB region */
    for (databyte = 0U; databyte < RAM_size; databyte++)
    c9e8:	2300      	movs	r3, #0
    c9ea:	9305      	str	r3, [sp, #20]
    c9ec:	e008      	b.n	ca00 <FlexCAN_ClearRAM+0x38>
    {
        RAM[databyte] = 0x0U;
    c9ee:	9b05      	ldr	r3, [sp, #20]
    c9f0:	009b      	lsls	r3, r3, #2
    c9f2:	9a02      	ldr	r2, [sp, #8]
    c9f4:	4413      	add	r3, r2
    c9f6:	2200      	movs	r2, #0
    c9f8:	601a      	str	r2, [r3, #0]
    for (databyte = 0U; databyte < RAM_size; databyte++)
    c9fa:	9b05      	ldr	r3, [sp, #20]
    c9fc:	3301      	adds	r3, #1
    c9fe:	9305      	str	r3, [sp, #20]
    ca00:	9a05      	ldr	r2, [sp, #20]
    ca02:	9b04      	ldr	r3, [sp, #16]
    ca04:	429a      	cmp	r2, r3
    ca06:	d3f2      	bcc.n	c9ee <FlexCAN_ClearRAM+0x26>
    }
    RAM = (volatile uint32 *)base->RXIMR;
    ca08:	9b01      	ldr	r3, [sp, #4]
    ca0a:	f503 6308 	add.w	r3, r3, #2176	; 0x880
    ca0e:	9302      	str	r3, [sp, #8]
    /* Clear RXIMR region */
    for (databyte = 0U; databyte < RXIMR_size; databyte++)
    ca10:	2300      	movs	r3, #0
    ca12:	9305      	str	r3, [sp, #20]
    ca14:	e008      	b.n	ca28 <FlexCAN_ClearRAM+0x60>
    {
        RAM[databyte] = 0x0U;
    ca16:	9b05      	ldr	r3, [sp, #20]
    ca18:	009b      	lsls	r3, r3, #2
    ca1a:	9a02      	ldr	r2, [sp, #8]
    ca1c:	4413      	add	r3, r2
    ca1e:	2200      	movs	r2, #0
    ca20:	601a      	str	r2, [r3, #0]
    for (databyte = 0U; databyte < RXIMR_size; databyte++)
    ca22:	9b05      	ldr	r3, [sp, #20]
    ca24:	3301      	adds	r3, #1
    ca26:	9305      	str	r3, [sp, #20]
    ca28:	9a05      	ldr	r2, [sp, #20]
    ca2a:	9b03      	ldr	r3, [sp, #12]
    ca2c:	429a      	cmp	r2, r3
    ca2e:	d3f2      	bcc.n	ca16 <FlexCAN_ClearRAM+0x4e>
    }
#endif
    /* Clear WRMFRZ bit in CTRL2 Register to restrict write access to memory */
    base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_WRMFRZ_MASK) | FLEXCAN_CTRL2_WRMFRZ(0U);
#endif /* if FLEXCAN_IP_FEATURE_HAS_MEM_ERR_DET */
}
    ca30:	bf00      	nop
    ca32:	bf00      	nop
    ca34:	b007      	add	sp, #28
    ca36:	f85d fb04 	ldr.w	pc, [sp], #4

0000ca3a <FlexCAN_ComputePayloadSize>:
#if (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON)
uint8 FlexCAN_ComputePayloadSize(uint8 dlcValue)
#else
static uint8 FlexCAN_ComputePayloadSize(uint8 dlcValue)
#endif /* (FLEXCAN_IP_FEATURE_HAS_ENHANCED_RX_FIFO == STD_ON) */
{
    ca3a:	b084      	sub	sp, #16
    ca3c:	4603      	mov	r3, r0
    ca3e:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 ret = 8U;
    ca42:	2308      	movs	r3, #8
    ca44:	f88d 300f 	strb.w	r3, [sp, #15]

    if (dlcValue <= 8U)
    ca48:	f89d 3007 	ldrb.w	r3, [sp, #7]
    ca4c:	2b08      	cmp	r3, #8
    ca4e:	d804      	bhi.n	ca5a <FlexCAN_ComputePayloadSize+0x20>
    {
        ret = dlcValue;
    ca50:	f89d 3007 	ldrb.w	r3, [sp, #7]
    ca54:	f88d 300f 	strb.w	r3, [sp, #15]
    ca58:	e033      	b.n	cac2 <FlexCAN_ComputePayloadSize+0x88>
    }
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
    else
    {
        switch (dlcValue)
    ca5a:	f89d 3007 	ldrb.w	r3, [sp, #7]
    ca5e:	3b09      	subs	r3, #9
    ca60:	2b06      	cmp	r3, #6
    ca62:	d82d      	bhi.n	cac0 <FlexCAN_ComputePayloadSize+0x86>
    ca64:	a201      	add	r2, pc, #4	; (adr r2, ca6c <FlexCAN_ComputePayloadSize+0x32>)
    ca66:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    ca6a:	bf00      	nop
    ca6c:	0000ca89 	.word	0x0000ca89
    ca70:	0000ca91 	.word	0x0000ca91
    ca74:	0000ca99 	.word	0x0000ca99
    ca78:	0000caa1 	.word	0x0000caa1
    ca7c:	0000caa9 	.word	0x0000caa9
    ca80:	0000cab1 	.word	0x0000cab1
    ca84:	0000cab9 	.word	0x0000cab9
        {
            case FLEXCAN_IP_DLC_VALUE_12_BYTES:
                ret = 12U;
    ca88:	230c      	movs	r3, #12
    ca8a:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    ca8e:	e018      	b.n	cac2 <FlexCAN_ComputePayloadSize+0x88>
            case FLEXCAN_IP_DLC_VALUE_16_BYTES:
                ret = 16U;
    ca90:	2310      	movs	r3, #16
    ca92:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    ca96:	e014      	b.n	cac2 <FlexCAN_ComputePayloadSize+0x88>
            case FLEXCAN_IP_DLC_VALUE_20_BYTES:
                ret = 20U;
    ca98:	2314      	movs	r3, #20
    ca9a:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    ca9e:	e010      	b.n	cac2 <FlexCAN_ComputePayloadSize+0x88>
            case FLEXCAN_IP_DLC_VALUE_24_BYTES:
                ret = 24U;
    caa0:	2318      	movs	r3, #24
    caa2:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    caa6:	e00c      	b.n	cac2 <FlexCAN_ComputePayloadSize+0x88>
            case FLEXCAN_IP_DLC_VALUE_32_BYTES:
                ret = 32U;
    caa8:	2320      	movs	r3, #32
    caaa:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    caae:	e008      	b.n	cac2 <FlexCAN_ComputePayloadSize+0x88>
            case FLEXCAN_IP_DLC_VALUE_48_BYTES:
                ret = 48U;
    cab0:	2330      	movs	r3, #48	; 0x30
    cab2:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    cab6:	e004      	b.n	cac2 <FlexCAN_ComputePayloadSize+0x88>
            case FLEXCAN_IP_DLC_VALUE_64_BYTES:
                ret = 64U;
    cab8:	2340      	movs	r3, #64	; 0x40
    caba:	f88d 300f 	strb.w	r3, [sp, #15]
                break;
    cabe:	e000      	b.n	cac2 <FlexCAN_ComputePayloadSize+0x88>
            default:
                /* The argument is not a valid DLC size */
                break;
    cac0:	bf00      	nop
        }
    }
#endif /* FLEXCAN_IP_FEATURE_HAS_FD */

    return ret;
    cac2:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
    cac6:	4618      	mov	r0, r3
    cac8:	b004      	add	sp, #16
    caca:	4770      	bx	lr

0000cacc <FlexCAN_GetMsgBuffRegion>:
 * Function Name : FLEXCAN_GetMsgBuffRegion
 * Description   : Returns the start of a MB area, based on its index.
 *
 *END**************************************************************************/
volatile uint32 * FlexCAN_GetMsgBuffRegion(const FLEXCAN_Type * base, uint32 msgBuffIdx)
{
    cacc:	b500      	push	{lr}
    cace:	b08b      	sub	sp, #44	; 0x2c
    cad0:	9001      	str	r0, [sp, #4]
    cad2:	9100      	str	r1, [sp, #0]
    uint8 arbitration_field_size = 8U;
    cad4:	2308      	movs	r3, #8
    cad6:	f88d 3020 	strb.w	r3, [sp, #32]
    uint8 mb_size = 0U;
    cada:	2300      	movs	r3, #0
    cadc:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    uint32 ramBlockSize = 512U;
    cae0:	f44f 7300 	mov.w	r3, #512	; 0x200
    cae4:	9307      	str	r3, [sp, #28]
    uint16 ramBlockOffset = 0;
    cae6:	2300      	movs	r3, #0
    cae8:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    uint8 msgBuffIdxBackup = (uint8)msgBuffIdx;
    caec:	9b00      	ldr	r3, [sp, #0]
    caee:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    uint8 i=0U;
    caf2:	2300      	movs	r3, #0
    caf4:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    uint8 maxMbNum=0U;
    caf8:	2300      	movs	r3, #0
    cafa:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
    uint32 mb_index=0U;
    cafe:	2300      	movs	r3, #0
    cb00:	9306      	str	r3, [sp, #24]
    uint8 payload_size=0U;
    cb02:	2300      	movs	r3, #0
    cb04:	f88d 3017 	strb.w	r3, [sp, #23]
    volatile uint32 * RAM = (uint32*)((Flexcan_Ip_PtrSizeType)base + (uint32)FLEXCAN_IP_FEATURE_RAM_OFFSET);
    cb08:	9b01      	ldr	r3, [sp, #4]
    cb0a:	3380      	adds	r3, #128	; 0x80
    cb0c:	9304      	str	r3, [sp, #16]
    volatile uint32 * pAddressRet = NULL_PTR;
    cb0e:	2300      	movs	r3, #0
    cb10:	9303      	str	r3, [sp, #12]
#if (FLEXCAN_IP_FEATURE_HAS_EXPANDABLE_MEMORY == STD_ON)
    volatile uint32 * RAM_EXPANDED = (uint32*)((Flexcan_Ip_PtrSizeType)base + (uint32)FLEXCAN_IP_FEATURE_EXP_RAM_OFFSET);
#endif

    for (i=0; i< (uint8)FLEXCAN_IP_FEATURE_MBDSR_COUNT; i++)
    cb12:	2300      	movs	r3, #0
    cb14:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    cb18:	e02d      	b.n	cb76 <FlexCAN_GetMsgBuffRegion+0xaa>
    {
        payload_size = FlexCAN_GetPayloadSize(base, i);
    cb1a:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
    cb1e:	4619      	mov	r1, r3
    cb20:	9801      	ldr	r0, [sp, #4]
    cb22:	f000 fad1 	bl	d0c8 <FlexCAN_GetPayloadSize>
    cb26:	4603      	mov	r3, r0
    cb28:	f88d 3017 	strb.w	r3, [sp, #23]
        mb_size = (uint8)(payload_size + arbitration_field_size);
    cb2c:	f89d 2017 	ldrb.w	r2, [sp, #23]
    cb30:	f89d 3020 	ldrb.w	r3, [sp, #32]
    cb34:	4413      	add	r3, r2
    cb36:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
        maxMbNum = (uint8)(ramBlockSize / mb_size);
    cb3a:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    cb3e:	9a07      	ldr	r2, [sp, #28]
    cb40:	fbb2 f3f3 	udiv	r3, r2, r3
    cb44:	f88d 3021 	strb.w	r3, [sp, #33]	; 0x21
        if (maxMbNum > msgBuffIdxBackup)
    cb48:	f89d 2021 	ldrb.w	r2, [sp, #33]	; 0x21
    cb4c:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    cb50:	429a      	cmp	r2, r3
    cb52:	d815      	bhi.n	cb80 <FlexCAN_GetMsgBuffRegion+0xb4>
        {
            break;
        }
        ramBlockOffset += 128U;
    cb54:	f8bd 3024 	ldrh.w	r3, [sp, #36]	; 0x24
    cb58:	3380      	adds	r3, #128	; 0x80
    cb5a:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
        msgBuffIdxBackup -= maxMbNum;
    cb5e:	f89d 2023 	ldrb.w	r2, [sp, #35]	; 0x23
    cb62:	f89d 3021 	ldrb.w	r3, [sp, #33]	; 0x21
    cb66:	1ad3      	subs	r3, r2, r3
    cb68:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    for (i=0; i< (uint8)FLEXCAN_IP_FEATURE_MBDSR_COUNT; i++)
    cb6c:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
    cb70:	3301      	adds	r3, #1
    cb72:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    cb76:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
    cb7a:	2b00      	cmp	r3, #0
    cb7c:	d0cd      	beq.n	cb1a <FlexCAN_GetMsgBuffRegion+0x4e>
    cb7e:	e000      	b.n	cb82 <FlexCAN_GetMsgBuffRegion+0xb6>
            break;
    cb80:	bf00      	nop
    }
    else
#endif
    {
        /* Multiply the MB index by the MB size (in words) */
        mb_index = (uint32)ramBlockOffset + (((uint32)msgBuffIdxBackup % (uint32)maxMbNum) * ((uint32)mb_size >> 2U));
    cb82:	f8bd 1024 	ldrh.w	r1, [sp, #36]	; 0x24
    cb86:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    cb8a:	f89d 2021 	ldrb.w	r2, [sp, #33]	; 0x21
    cb8e:	fbb3 f0f2 	udiv	r0, r3, r2
    cb92:	fb00 f202 	mul.w	r2, r0, r2
    cb96:	1a9b      	subs	r3, r3, r2
    cb98:	b2db      	uxtb	r3, r3
    cb9a:	461a      	mov	r2, r3
    cb9c:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
    cba0:	089b      	lsrs	r3, r3, #2
    cba2:	b2db      	uxtb	r3, r3
    cba4:	fb02 f303 	mul.w	r3, r2, r3
    cba8:	440b      	add	r3, r1
    cbaa:	9306      	str	r3, [sp, #24]
        pAddressRet = &(RAM[mb_index]);
    cbac:	9b06      	ldr	r3, [sp, #24]
    cbae:	009b      	lsls	r3, r3, #2
    cbb0:	9a04      	ldr	r2, [sp, #16]
    cbb2:	4413      	add	r3, r2
    cbb4:	9303      	str	r3, [sp, #12]
    }

    return pAddressRet;
    cbb6:	9b03      	ldr	r3, [sp, #12]
}
    cbb8:	4618      	mov	r0, r3
    cbba:	b00b      	add	sp, #44	; 0x2c
    cbbc:	f85d fb04 	ldr.w	pc, [sp], #4

0000cbc0 <FlexCAN_GetMaxMbNum>:
 * Function Name : FlexCAN_GetMaxMbNum
 * Description   : Computes the maximum RAM size occupied by MBs.
 *
 *END**************************************************************************/
uint32 FlexCAN_GetMaxMbNum(const FLEXCAN_Type * base)
{
    cbc0:	b084      	sub	sp, #16
    cbc2:	9001      	str	r0, [sp, #4]
    uint32 i, ret = 0u;
    cbc4:	2300      	movs	r3, #0
    cbc6:	9302      	str	r3, [sp, #8]
    static FLEXCAN_Type * const flexcanBase[] = IP_FLEXCAN_BASE_PTRS;
    static const uint32 maxMbNum[] = FLEXCAN_IP_FEATURE_MAX_MB_NUM_ARRAY;

    for (i = 0u; i < FLEXCAN_INSTANCE_COUNT; i++)
    cbc8:	2300      	movs	r3, #0
    cbca:	9303      	str	r3, [sp, #12]
    cbcc:	e00e      	b.n	cbec <FlexCAN_GetMaxMbNum+0x2c>
    {
        if (base == flexcanBase[i])
    cbce:	4a0b      	ldr	r2, [pc, #44]	; (cbfc <FlexCAN_GetMaxMbNum+0x3c>)
    cbd0:	9b03      	ldr	r3, [sp, #12]
    cbd2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    cbd6:	9a01      	ldr	r2, [sp, #4]
    cbd8:	429a      	cmp	r2, r3
    cbda:	d104      	bne.n	cbe6 <FlexCAN_GetMaxMbNum+0x26>
        {
            ret = maxMbNum[i];
    cbdc:	4a08      	ldr	r2, [pc, #32]	; (cc00 <FlexCAN_GetMaxMbNum+0x40>)
    cbde:	9b03      	ldr	r3, [sp, #12]
    cbe0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    cbe4:	9302      	str	r3, [sp, #8]
    for (i = 0u; i < FLEXCAN_INSTANCE_COUNT; i++)
    cbe6:	9b03      	ldr	r3, [sp, #12]
    cbe8:	3301      	adds	r3, #1
    cbea:	9303      	str	r3, [sp, #12]
    cbec:	9b03      	ldr	r3, [sp, #12]
    cbee:	2b02      	cmp	r3, #2
    cbf0:	d9ed      	bls.n	cbce <FlexCAN_GetMaxMbNum+0xe>
        }
    }
    return ret;
    cbf2:	9b02      	ldr	r3, [sp, #8]
}
    cbf4:	4618      	mov	r0, r3
    cbf6:	b004      	add	sp, #16
    cbf8:	4770      	bx	lr
    cbfa:	bf00      	nop
    cbfc:	00015c38 	.word	0x00015c38
    cc00:	00015c44 	.word	0x00015c44

0000cc04 <FlexCAN_EnterFreezeMode>:
 * Function Name : FLEXCAN_EnterFreezeMode
 * Description   : Enter the freeze mode.
 *
 *END**************************************************************************/
Flexcan_Ip_StatusType FlexCAN_EnterFreezeMode(FLEXCAN_Type * base)
{
    cc04:	b500      	push	{lr}
    cc06:	b087      	sub	sp, #28
    cc08:	9001      	str	r0, [sp, #4]
    uint32 timeStart = 0U;
    cc0a:	2300      	movs	r3, #0
    cc0c:	9302      	str	r3, [sp, #8]
    uint32 timeElapsed = 0U;
    cc0e:	2300      	movs	r3, #0
    cc10:	9305      	str	r3, [sp, #20]
    uint32 uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    cc12:	2100      	movs	r1, #0
    cc14:	4820      	ldr	r0, [pc, #128]	; (cc98 <FlexCAN_EnterFreezeMode+0x94>)
    cc16:	f7f5 f90d 	bl	1e34 <OsIf_MicrosToTicks>
    cc1a:	9003      	str	r0, [sp, #12]
    Flexcan_Ip_StatusType returnResult = FLEXCAN_STATUS_SUCCESS;
    cc1c:	2300      	movs	r3, #0
    cc1e:	9304      	str	r3, [sp, #16]

    /* Start critical section: implementation depends on integrator */
    SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02();
    cc20:	f005 fa36 	bl	12090 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02>
    base->MCR = (base->MCR & ~FLEXCAN_MCR_FRZ_MASK) | FLEXCAN_MCR_FRZ(1U);
    cc24:	9b01      	ldr	r3, [sp, #4]
    cc26:	681b      	ldr	r3, [r3, #0]
    cc28:	f043 4280 	orr.w	r2, r3, #1073741824	; 0x40000000
    cc2c:	9b01      	ldr	r3, [sp, #4]
    cc2e:	601a      	str	r2, [r3, #0]
    base->MCR = (base->MCR & ~FLEXCAN_MCR_HALT_MASK) | FLEXCAN_MCR_HALT(1U);
    cc30:	9b01      	ldr	r3, [sp, #4]
    cc32:	681b      	ldr	r3, [r3, #0]
    cc34:	f043 5280 	orr.w	r2, r3, #268435456	; 0x10000000
    cc38:	9b01      	ldr	r3, [sp, #4]
    cc3a:	601a      	str	r2, [r3, #0]
    if (((base->MCR & FLEXCAN_MCR_MDIS_MASK) >> FLEXCAN_MCR_MDIS_SHIFT) != 0U)
    cc3c:	9b01      	ldr	r3, [sp, #4]
    cc3e:	681b      	ldr	r3, [r3, #0]
    cc40:	2b00      	cmp	r3, #0
    cc42:	da05      	bge.n	cc50 <FlexCAN_EnterFreezeMode+0x4c>
    {
        base->MCR &= ~FLEXCAN_MCR_MDIS_MASK;
    cc44:	9b01      	ldr	r3, [sp, #4]
    cc46:	681b      	ldr	r3, [r3, #0]
    cc48:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
    cc4c:	9b01      	ldr	r3, [sp, #4]
    cc4e:	601a      	str	r2, [r3, #0]
    }
    /* End critical section: implementation depends on integrator */
    SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02();
    cc50:	f005 fa4a 	bl	120e8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02>
    /* Wait for entering the freeze mode */
    timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    cc54:	2000      	movs	r0, #0
    cc56:	f7f5 f8a1 	bl	1d9c <OsIf_GetCounter>
    cc5a:	4603      	mov	r3, r0
    cc5c:	9302      	str	r3, [sp, #8]
    while (0U == ((base->MCR & FLEXCAN_MCR_FRZACK_MASK) >> FLEXCAN_MCR_FRZACK_SHIFT))
    cc5e:	e00f      	b.n	cc80 <FlexCAN_EnterFreezeMode+0x7c>
    {
        timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    cc60:	ab02      	add	r3, sp, #8
    cc62:	2100      	movs	r1, #0
    cc64:	4618      	mov	r0, r3
    cc66:	f7f5 f8b2 	bl	1dce <OsIf_GetElapsed>
    cc6a:	4602      	mov	r2, r0
    cc6c:	9b05      	ldr	r3, [sp, #20]
    cc6e:	4413      	add	r3, r2
    cc70:	9305      	str	r3, [sp, #20]
        if (timeElapsed >= uS2Ticks)
    cc72:	9a05      	ldr	r2, [sp, #20]
    cc74:	9b03      	ldr	r3, [sp, #12]
    cc76:	429a      	cmp	r2, r3
    cc78:	d302      	bcc.n	cc80 <FlexCAN_EnterFreezeMode+0x7c>
        {
            returnResult = FLEXCAN_STATUS_TIMEOUT;
    cc7a:	2303      	movs	r3, #3
    cc7c:	9304      	str	r3, [sp, #16]
            break;
    cc7e:	e005      	b.n	cc8c <FlexCAN_EnterFreezeMode+0x88>
    while (0U == ((base->MCR & FLEXCAN_MCR_FRZACK_MASK) >> FLEXCAN_MCR_FRZACK_SHIFT))
    cc80:	9b01      	ldr	r3, [sp, #4]
    cc82:	681b      	ldr	r3, [r3, #0]
    cc84:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
    cc88:	2b00      	cmp	r3, #0
    cc8a:	d0e9      	beq.n	cc60 <FlexCAN_EnterFreezeMode+0x5c>
        }
    }

    return returnResult;
    cc8c:	9b04      	ldr	r3, [sp, #16]
}
    cc8e:	4618      	mov	r0, r3
    cc90:	b007      	add	sp, #28
    cc92:	f85d fb04 	ldr.w	pc, [sp], #4
    cc96:	bf00      	nop
    cc98:	000f4240 	.word	0x000f4240

0000cc9c <FlexCAN_Enable>:
 * Function Name : FlexCAN_Enable
 * Description   : Enable the clock for FlexCAN Module.
 *
 *END**************************************************************************/
Flexcan_Ip_StatusType FlexCAN_Enable(FLEXCAN_Type * base)
{
    cc9c:	b500      	push	{lr}
    cc9e:	b087      	sub	sp, #28
    cca0:	9001      	str	r0, [sp, #4]
    uint32 timeStart = 0U;
    cca2:	2300      	movs	r3, #0
    cca4:	9302      	str	r3, [sp, #8]
    uint32 timeElapsed = 0U;
    cca6:	2300      	movs	r3, #0
    cca8:	9305      	str	r3, [sp, #20]
    uint32 uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    ccaa:	2100      	movs	r1, #0
    ccac:	4818      	ldr	r0, [pc, #96]	; (cd10 <FlexCAN_Enable+0x74>)
    ccae:	f7f5 f8c1 	bl	1e34 <OsIf_MicrosToTicks>
    ccb2:	9003      	str	r0, [sp, #12]
    Flexcan_Ip_StatusType returnValue = FLEXCAN_STATUS_SUCCESS;
    ccb4:	2300      	movs	r3, #0
    ccb6:	9304      	str	r3, [sp, #16]

    /* Start critical section: implementation depends on integrator */
    SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03();
    ccb8:	f005 fa3c 	bl	12134 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03>

    /* Enable Module */
    base->MCR &= ~FLEXCAN_MCR_MDIS_MASK;
    ccbc:	9b01      	ldr	r3, [sp, #4]
    ccbe:	681b      	ldr	r3, [r3, #0]
    ccc0:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
    ccc4:	9b01      	ldr	r3, [sp, #4]
    ccc6:	601a      	str	r2, [r3, #0]
    /* End critical section: implementation depends on integrator */
    SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03();
    ccc8:	f005 fa60 	bl	1218c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03>
    /* Wait for entering the freeze mode */
    timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    cccc:	2000      	movs	r0, #0
    ccce:	f7f5 f865 	bl	1d9c <OsIf_GetCounter>
    ccd2:	4603      	mov	r3, r0
    ccd4:	9302      	str	r3, [sp, #8]
    while (0U == ((base->MCR & FLEXCAN_MCR_FRZACK_MASK) >> FLEXCAN_MCR_FRZACK_SHIFT))
    ccd6:	e00f      	b.n	ccf8 <FlexCAN_Enable+0x5c>
    {
        timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    ccd8:	ab02      	add	r3, sp, #8
    ccda:	2100      	movs	r1, #0
    ccdc:	4618      	mov	r0, r3
    ccde:	f7f5 f876 	bl	1dce <OsIf_GetElapsed>
    cce2:	4602      	mov	r2, r0
    cce4:	9b05      	ldr	r3, [sp, #20]
    cce6:	4413      	add	r3, r2
    cce8:	9305      	str	r3, [sp, #20]
        if (timeElapsed >= uS2Ticks)
    ccea:	9a05      	ldr	r2, [sp, #20]
    ccec:	9b03      	ldr	r3, [sp, #12]
    ccee:	429a      	cmp	r2, r3
    ccf0:	d302      	bcc.n	ccf8 <FlexCAN_Enable+0x5c>
        {
            returnValue = FLEXCAN_STATUS_TIMEOUT;
    ccf2:	2303      	movs	r3, #3
    ccf4:	9304      	str	r3, [sp, #16]
            break;
    ccf6:	e005      	b.n	cd04 <FlexCAN_Enable+0x68>
    while (0U == ((base->MCR & FLEXCAN_MCR_FRZACK_MASK) >> FLEXCAN_MCR_FRZACK_SHIFT))
    ccf8:	9b01      	ldr	r3, [sp, #4]
    ccfa:	681b      	ldr	r3, [r3, #0]
    ccfc:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
    cd00:	2b00      	cmp	r3, #0
    cd02:	d0e9      	beq.n	ccd8 <FlexCAN_Enable+0x3c>
        }
    }
    return returnValue;
    cd04:	9b04      	ldr	r3, [sp, #16]
}
    cd06:	4618      	mov	r0, r3
    cd08:	b007      	add	sp, #28
    cd0a:	f85d fb04 	ldr.w	pc, [sp], #4
    cd0e:	bf00      	nop
    cd10:	000f4240 	.word	0x000f4240

0000cd14 <FlexCAN_ExitFreezeMode>:
 * Function Name : FLEXCAN_ExitFreezeMode
 * Description   : Exit of freeze mode.
 *
 *END**************************************************************************/
Flexcan_Ip_StatusType FlexCAN_ExitFreezeMode(FLEXCAN_Type * base)
{
    cd14:	b500      	push	{lr}
    cd16:	b087      	sub	sp, #28
    cd18:	9001      	str	r0, [sp, #4]
    uint32 timeStart = 0U;
    cd1a:	2300      	movs	r3, #0
    cd1c:	9302      	str	r3, [sp, #8]
    uint32 timeElapsed = 0U;
    cd1e:	2300      	movs	r3, #0
    cd20:	9305      	str	r3, [sp, #20]
    uint32 uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    cd22:	2100      	movs	r1, #0
    cd24:	481b      	ldr	r0, [pc, #108]	; (cd94 <FlexCAN_ExitFreezeMode+0x80>)
    cd26:	f7f5 f885 	bl	1e34 <OsIf_MicrosToTicks>
    cd2a:	9003      	str	r0, [sp, #12]
    Flexcan_Ip_StatusType returnValue = FLEXCAN_STATUS_SUCCESS;
    cd2c:	2300      	movs	r3, #0
    cd2e:	9304      	str	r3, [sp, #16]

    /* Start critical section: implementation depends on integrator */
    SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04();
    cd30:	f005 fa52 	bl	121d8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04>
    base->MCR = (base->MCR & ~FLEXCAN_MCR_HALT_MASK) | FLEXCAN_MCR_HALT(0U);
    cd34:	9b01      	ldr	r3, [sp, #4]
    cd36:	681b      	ldr	r3, [r3, #0]
    cd38:	f023 5280 	bic.w	r2, r3, #268435456	; 0x10000000
    cd3c:	9b01      	ldr	r3, [sp, #4]
    cd3e:	601a      	str	r2, [r3, #0]
    base->MCR = (base->MCR & ~FLEXCAN_MCR_FRZ_MASK) | FLEXCAN_MCR_FRZ(0U);
    cd40:	9b01      	ldr	r3, [sp, #4]
    cd42:	681b      	ldr	r3, [r3, #0]
    cd44:	f023 4280 	bic.w	r2, r3, #1073741824	; 0x40000000
    cd48:	9b01      	ldr	r3, [sp, #4]
    cd4a:	601a      	str	r2, [r3, #0]
    /* End critical section: implementation depends on integrator */
    SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04();
    cd4c:	f005 fa70 	bl	12230 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04>
    /* Wait till exit freeze mode */
    timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    cd50:	2000      	movs	r0, #0
    cd52:	f7f5 f823 	bl	1d9c <OsIf_GetCounter>
    cd56:	4603      	mov	r3, r0
    cd58:	9302      	str	r3, [sp, #8]
    while (((base->MCR & FLEXCAN_MCR_FRZACK_MASK) >> FLEXCAN_MCR_FRZACK_SHIFT) != 0U)
    cd5a:	e00f      	b.n	cd7c <FlexCAN_ExitFreezeMode+0x68>
    {
        timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    cd5c:	ab02      	add	r3, sp, #8
    cd5e:	2100      	movs	r1, #0
    cd60:	4618      	mov	r0, r3
    cd62:	f7f5 f834 	bl	1dce <OsIf_GetElapsed>
    cd66:	4602      	mov	r2, r0
    cd68:	9b05      	ldr	r3, [sp, #20]
    cd6a:	4413      	add	r3, r2
    cd6c:	9305      	str	r3, [sp, #20]
        if (timeElapsed >= uS2Ticks)
    cd6e:	9a05      	ldr	r2, [sp, #20]
    cd70:	9b03      	ldr	r3, [sp, #12]
    cd72:	429a      	cmp	r2, r3
    cd74:	d302      	bcc.n	cd7c <FlexCAN_ExitFreezeMode+0x68>
        {
            returnValue = FLEXCAN_STATUS_TIMEOUT;
    cd76:	2303      	movs	r3, #3
    cd78:	9304      	str	r3, [sp, #16]
            break;
    cd7a:	e005      	b.n	cd88 <FlexCAN_ExitFreezeMode+0x74>
    while (((base->MCR & FLEXCAN_MCR_FRZACK_MASK) >> FLEXCAN_MCR_FRZACK_SHIFT) != 0U)
    cd7c:	9b01      	ldr	r3, [sp, #4]
    cd7e:	681b      	ldr	r3, [r3, #0]
    cd80:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
    cd84:	2b00      	cmp	r3, #0
    cd86:	d1e9      	bne.n	cd5c <FlexCAN_ExitFreezeMode+0x48>
        }
    }
    return returnValue;
    cd88:	9b04      	ldr	r3, [sp, #16]
}
    cd8a:	4618      	mov	r0, r3
    cd8c:	b007      	add	sp, #28
    cd8e:	f85d fb04 	ldr.w	pc, [sp], #4
    cd92:	bf00      	nop
    cd94:	000f4240 	.word	0x000f4240

0000cd98 <FlexCAN_Disable>:
 * Description   : Disable FlexCAN module.
 * This function will disable FlexCAN module.
 *
 *END**************************************************************************/
Flexcan_Ip_StatusType FlexCAN_Disable(FLEXCAN_Type * base)
{
    cd98:	b500      	push	{lr}
    cd9a:	b087      	sub	sp, #28
    cd9c:	9001      	str	r0, [sp, #4]
    uint32 timeStart = 0U;
    cd9e:	2300      	movs	r3, #0
    cda0:	9302      	str	r3, [sp, #8]
    uint32 timeElapsed = 0U;
    cda2:	2300      	movs	r3, #0
    cda4:	9305      	str	r3, [sp, #20]
    uint32 uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    cda6:	2100      	movs	r1, #0
    cda8:	481a      	ldr	r0, [pc, #104]	; (ce14 <FlexCAN_Disable+0x7c>)
    cdaa:	f7f5 f843 	bl	1e34 <OsIf_MicrosToTicks>
    cdae:	9003      	str	r0, [sp, #12]
    Flexcan_Ip_StatusType returnResult = FLEXCAN_STATUS_SUCCESS;
    cdb0:	2300      	movs	r3, #0
    cdb2:	9304      	str	r3, [sp, #16]

    /* To access the memory mapped registers */
    /* Enter disable mode (hard reset). */
    if (0U == ((base->MCR & FLEXCAN_MCR_MDIS_MASK) >> FLEXCAN_MCR_MDIS_SHIFT))
    cdb4:	9b01      	ldr	r3, [sp, #4]
    cdb6:	681b      	ldr	r3, [r3, #0]
    cdb8:	2b00      	cmp	r3, #0
    cdba:	db25      	blt.n	ce08 <FlexCAN_Disable+0x70>
    {
        /* Start critical section: implementation depends on integrator */
        SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05();
    cdbc:	f005 fa5e 	bl	1227c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05>
        /* Clock disable (module) */
        base->MCR = (base->MCR & ~FLEXCAN_MCR_MDIS_MASK) | FLEXCAN_MCR_MDIS(1U);
    cdc0:	9b01      	ldr	r3, [sp, #4]
    cdc2:	681b      	ldr	r3, [r3, #0]
    cdc4:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
    cdc8:	9b01      	ldr	r3, [sp, #4]
    cdca:	601a      	str	r2, [r3, #0]
        /* End critical section: implementation depends on integrator */
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05();
    cdcc:	f005 fa82 	bl	122d4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05>
        /* Wait until disable mode acknowledged */
        timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    cdd0:	2000      	movs	r0, #0
    cdd2:	f7f4 ffe3 	bl	1d9c <OsIf_GetCounter>
    cdd6:	4603      	mov	r3, r0
    cdd8:	9302      	str	r3, [sp, #8]
        while (0U == ((base->MCR & FLEXCAN_MCR_LPMACK_MASK) >> FLEXCAN_MCR_LPMACK_SHIFT))
    cdda:	e00f      	b.n	cdfc <FlexCAN_Disable+0x64>
        {
            timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    cddc:	ab02      	add	r3, sp, #8
    cdde:	2100      	movs	r1, #0
    cde0:	4618      	mov	r0, r3
    cde2:	f7f4 fff4 	bl	1dce <OsIf_GetElapsed>
    cde6:	4602      	mov	r2, r0
    cde8:	9b05      	ldr	r3, [sp, #20]
    cdea:	4413      	add	r3, r2
    cdec:	9305      	str	r3, [sp, #20]
            if (timeElapsed >= uS2Ticks)
    cdee:	9a05      	ldr	r2, [sp, #20]
    cdf0:	9b03      	ldr	r3, [sp, #12]
    cdf2:	429a      	cmp	r2, r3
    cdf4:	d302      	bcc.n	cdfc <FlexCAN_Disable+0x64>
            {
                returnResult = FLEXCAN_STATUS_TIMEOUT;
    cdf6:	2303      	movs	r3, #3
    cdf8:	9304      	str	r3, [sp, #16]
                break;
    cdfa:	e005      	b.n	ce08 <FlexCAN_Disable+0x70>
        while (0U == ((base->MCR & FLEXCAN_MCR_LPMACK_MASK) >> FLEXCAN_MCR_LPMACK_SHIFT))
    cdfc:	9b01      	ldr	r3, [sp, #4]
    cdfe:	681b      	ldr	r3, [r3, #0]
    ce00:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
    ce04:	2b00      	cmp	r3, #0
    ce06:	d0e9      	beq.n	cddc <FlexCAN_Disable+0x44>
            }
        }
    }
    return returnResult;
    ce08:	9b04      	ldr	r3, [sp, #16]
}
    ce0a:	4618      	mov	r0, r3
    ce0c:	b007      	add	sp, #28
    ce0e:	f85d fb04 	ldr.w	pc, [sp], #4
    ce12:	bf00      	nop
    ce14:	000f4240 	.word	0x000f4240

0000ce18 <FlexCAN_SetErrIntCmd>:
 * Description   : Enable the error interrupts.
 * This function will enable Error interrupt.
 *
 *END**************************************************************************/
void FlexCAN_SetErrIntCmd(FLEXCAN_Type * base, flexcan_int_type_t errType, boolean enable)
{
    ce18:	b500      	push	{lr}
    ce1a:	b087      	sub	sp, #28
    ce1c:	9003      	str	r0, [sp, #12]
    ce1e:	9102      	str	r1, [sp, #8]
    ce20:	4613      	mov	r3, r2
    ce22:	f88d 3007 	strb.w	r3, [sp, #7]
    uint32 temp = (uint32)errType;
    ce26:	9b02      	ldr	r3, [sp, #8]
    ce28:	9305      	str	r3, [sp, #20]

    /* Start critical section: implementation depends on integrator */
    SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06();
    ce2a:	f005 fa79 	bl	12320 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06>
    if (enable)
    ce2e:	f89d 3007 	ldrb.w	r3, [sp, #7]
    ce32:	2b00      	cmp	r3, #0
    ce34:	d020      	beq.n	ce78 <FlexCAN_SetErrIntCmd+0x60>
    {
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        if (FLEXCAN_INT_ERR_FAST == errType)
    ce36:	9b02      	ldr	r3, [sp, #8]
    ce38:	f244 0201 	movw	r2, #16385	; 0x4001
    ce3c:	4293      	cmp	r3, r2
    ce3e:	d106      	bne.n	ce4e <FlexCAN_SetErrIntCmd+0x36>
        {
            base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_ERRMSK_FAST_MASK) | FLEXCAN_CTRL2_ERRMSK_FAST(1U);
    ce40:	9b03      	ldr	r3, [sp, #12]
    ce42:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    ce44:	f043 4200 	orr.w	r2, r3, #2147483648	; 0x80000000
    ce48:	9b03      	ldr	r3, [sp, #12]
    ce4a:	635a      	str	r2, [r3, #52]	; 0x34
    ce4c:	e03a      	b.n	cec4 <FlexCAN_SetErrIntCmd+0xac>
            (void)temp;
        }
        else
#endif
        {
            if ((FLEXCAN_INT_RX_WARNING == errType) || (FLEXCAN_INT_TX_WARNING == errType))
    ce4e:	9b02      	ldr	r3, [sp, #8]
    ce50:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
    ce54:	d003      	beq.n	ce5e <FlexCAN_SetErrIntCmd+0x46>
    ce56:	9b02      	ldr	r3, [sp, #8]
    ce58:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
    ce5c:	d105      	bne.n	ce6a <FlexCAN_SetErrIntCmd+0x52>
            {
                base->MCR = (base->MCR & ~FLEXCAN_MCR_WRNEN_MASK) | FLEXCAN_MCR_WRNEN(1U);
    ce5e:	9b03      	ldr	r3, [sp, #12]
    ce60:	681b      	ldr	r3, [r3, #0]
    ce62:	f443 1200 	orr.w	r2, r3, #2097152	; 0x200000
    ce66:	9b03      	ldr	r3, [sp, #12]
    ce68:	601a      	str	r2, [r3, #0]
            }
            (base->CTRL1) = ((base->CTRL1) | (temp));
    ce6a:	9b03      	ldr	r3, [sp, #12]
    ce6c:	685a      	ldr	r2, [r3, #4]
    ce6e:	9b05      	ldr	r3, [sp, #20]
    ce70:	431a      	orrs	r2, r3
    ce72:	9b03      	ldr	r3, [sp, #12]
    ce74:	605a      	str	r2, [r3, #4]
    ce76:	e025      	b.n	cec4 <FlexCAN_SetErrIntCmd+0xac>
        }
    }
    else
    {
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        if (FLEXCAN_INT_ERR_FAST == errType)
    ce78:	9b02      	ldr	r3, [sp, #8]
    ce7a:	f244 0201 	movw	r2, #16385	; 0x4001
    ce7e:	4293      	cmp	r3, r2
    ce80:	d106      	bne.n	ce90 <FlexCAN_SetErrIntCmd+0x78>
        {
            base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_ERRMSK_FAST_MASK) | FLEXCAN_CTRL2_ERRMSK_FAST(0U);
    ce82:	9b03      	ldr	r3, [sp, #12]
    ce84:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    ce86:	f023 4200 	bic.w	r2, r3, #2147483648	; 0x80000000
    ce8a:	9b03      	ldr	r3, [sp, #12]
    ce8c:	635a      	str	r2, [r3, #52]	; 0x34
    ce8e:	e019      	b.n	cec4 <FlexCAN_SetErrIntCmd+0xac>
            (void)temp;
        }
        else
#endif
        {
            (base->CTRL1) = ((base->CTRL1) & ~(temp));
    ce90:	9b03      	ldr	r3, [sp, #12]
    ce92:	685a      	ldr	r2, [r3, #4]
    ce94:	9b05      	ldr	r3, [sp, #20]
    ce96:	43db      	mvns	r3, r3
    ce98:	401a      	ands	r2, r3
    ce9a:	9b03      	ldr	r3, [sp, #12]
    ce9c:	605a      	str	r2, [r3, #4]
            temp = base->CTRL1;
    ce9e:	9b03      	ldr	r3, [sp, #12]
    cea0:	685b      	ldr	r3, [r3, #4]
    cea2:	9305      	str	r3, [sp, #20]
            if ((0U == (temp & (uint32)FLEXCAN_INT_RX_WARNING)) && (0U == (temp & (uint32)FLEXCAN_INT_TX_WARNING)))
    cea4:	9b05      	ldr	r3, [sp, #20]
    cea6:	f403 6380 	and.w	r3, r3, #1024	; 0x400
    ceaa:	2b00      	cmp	r3, #0
    ceac:	d10a      	bne.n	cec4 <FlexCAN_SetErrIntCmd+0xac>
    ceae:	9b05      	ldr	r3, [sp, #20]
    ceb0:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    ceb4:	2b00      	cmp	r3, #0
    ceb6:	d105      	bne.n	cec4 <FlexCAN_SetErrIntCmd+0xac>
            {
                /* If WRNEN disabled then both FLEXCAN_INT_RX_WARNING and FLEXCAN_INT_TX_WARNING will be disabled */
                base->MCR = (base->MCR & ~FLEXCAN_MCR_WRNEN_MASK) | FLEXCAN_MCR_WRNEN(0U);
    ceb8:	9b03      	ldr	r3, [sp, #12]
    ceba:	681b      	ldr	r3, [r3, #0]
    cebc:	f423 1200 	bic.w	r2, r3, #2097152	; 0x200000
    cec0:	9b03      	ldr	r3, [sp, #12]
    cec2:	601a      	str	r2, [r3, #0]
            }
        }
    }
    /* End critical section: implementation depends on integrator */
    SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06();
    cec4:	f005 fa58 	bl	12378 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06>
}
    cec8:	bf00      	nop
    ceca:	b007      	add	sp, #28
    cecc:	f85d fb04 	ldr.w	pc, [sp], #4

0000ced0 <FlexCAN_Init>:
 * buffers, initialize all message buffers as inactive, enable RX FIFO
 * if needed, mask all mask bits, and disable all MB interrupts.
 *
 *END**************************************************************************/
Flexcan_Ip_StatusType FlexCAN_Init(FLEXCAN_Type * base)
{
    ced0:	b500      	push	{lr}
    ced2:	b087      	sub	sp, #28
    ced4:	9001      	str	r0, [sp, #4]
    uint32 timeStart = 0U;
    ced6:	2300      	movs	r3, #0
    ced8:	9302      	str	r3, [sp, #8]
    uint32 timeElapsed = 0U;
    ceda:	2300      	movs	r3, #0
    cedc:	9305      	str	r3, [sp, #20]
    uint32 uS2Ticks = OsIf_MicrosToTicks(FLEXCAN_IP_TIMEOUT_DURATION, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    cede:	2100      	movs	r1, #0
    cee0:	4833      	ldr	r0, [pc, #204]	; (cfb0 <FlexCAN_Init+0xe0>)
    cee2:	f7f4 ffa7 	bl	1e34 <OsIf_MicrosToTicks>
    cee6:	9003      	str	r0, [sp, #12]
    Flexcan_Ip_StatusType returnResult = FLEXCAN_STATUS_SUCCESS;
    cee8:	2300      	movs	r3, #0
    ceea:	9304      	str	r3, [sp, #16]

    /* Reset the FLEXCAN */
    base->MCR = (base->MCR & ~FLEXCAN_MCR_SOFTRST_MASK) | FLEXCAN_MCR_SOFTRST(1U);
    ceec:	9b01      	ldr	r3, [sp, #4]
    ceee:	681b      	ldr	r3, [r3, #0]
    cef0:	f043 7200 	orr.w	r2, r3, #33554432	; 0x2000000
    cef4:	9b01      	ldr	r3, [sp, #4]
    cef6:	601a      	str	r2, [r3, #0]
    /* Wait for reset cycle to complete */
    timeStart = OsIf_GetCounter(FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    cef8:	2000      	movs	r0, #0
    cefa:	f7f4 ff4f 	bl	1d9c <OsIf_GetCounter>
    cefe:	4603      	mov	r3, r0
    cf00:	9302      	str	r3, [sp, #8]
    while (((base->MCR & FLEXCAN_MCR_SOFTRST_MASK) >> FLEXCAN_MCR_SOFTRST_SHIFT) != 0U)
    cf02:	e00f      	b.n	cf24 <FlexCAN_Init+0x54>
    {
        timeElapsed += OsIf_GetElapsed(&timeStart, FLEXCAN_IP_SERVICE_TIMEOUT_TYPE);
    cf04:	ab02      	add	r3, sp, #8
    cf06:	2100      	movs	r1, #0
    cf08:	4618      	mov	r0, r3
    cf0a:	f7f4 ff60 	bl	1dce <OsIf_GetElapsed>
    cf0e:	4602      	mov	r2, r0
    cf10:	9b05      	ldr	r3, [sp, #20]
    cf12:	4413      	add	r3, r2
    cf14:	9305      	str	r3, [sp, #20]
        if (timeElapsed >= uS2Ticks)
    cf16:	9a05      	ldr	r2, [sp, #20]
    cf18:	9b03      	ldr	r3, [sp, #12]
    cf1a:	429a      	cmp	r2, r3
    cf1c:	d302      	bcc.n	cf24 <FlexCAN_Init+0x54>
        {
            returnResult = FLEXCAN_STATUS_TIMEOUT;
    cf1e:	2303      	movs	r3, #3
    cf20:	9304      	str	r3, [sp, #16]
            break;
    cf22:	e005      	b.n	cf30 <FlexCAN_Init+0x60>
    while (((base->MCR & FLEXCAN_MCR_SOFTRST_MASK) >> FLEXCAN_MCR_SOFTRST_SHIFT) != 0U)
    cf24:	9b01      	ldr	r3, [sp, #4]
    cf26:	681b      	ldr	r3, [r3, #0]
    cf28:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
    cf2c:	2b00      	cmp	r3, #0
    cf2e:	d1e9      	bne.n	cf04 <FlexCAN_Init+0x34>
        }
    }
    if (FLEXCAN_STATUS_SUCCESS == returnResult)
    cf30:	9b04      	ldr	r3, [sp, #16]
    cf32:	2b00      	cmp	r3, #0
    cf34:	d136      	bne.n	cfa4 <FlexCAN_Init+0xd4>
    {
        /* Avoid Abort Transmission, use Inactive MB */
        base->MCR = (base->MCR & ~FLEXCAN_MCR_AEN_MASK) | FLEXCAN_MCR_AEN(1U);
    cf36:	9b01      	ldr	r3, [sp, #4]
    cf38:	681b      	ldr	r3, [r3, #0]
    cf3a:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
    cf3e:	9b01      	ldr	r3, [sp, #4]
    cf40:	601a      	str	r2, [r3, #0]
        /* Clear FlexCAN memory */
        FlexCAN_ClearRAM(base);
    cf42:	9801      	ldr	r0, [sp, #4]
    cf44:	f7ff fd40 	bl	c9c8 <FlexCAN_ClearRAM>
        /* Rx global mask*/
        (base->RXMGMASK) = (uint32)(FLEXCAN_RXMGMASK_MG_MASK);
    cf48:	9b01      	ldr	r3, [sp, #4]
    cf4a:	f04f 32ff 	mov.w	r2, #4294967295
    cf4e:	611a      	str	r2, [r3, #16]
        /* Rx reg 14 mask*/
        (base->RX14MASK) =  (uint32)(FLEXCAN_RX14MASK_RX14M_MASK);
    cf50:	9b01      	ldr	r3, [sp, #4]
    cf52:	f04f 32ff 	mov.w	r2, #4294967295
    cf56:	615a      	str	r2, [r3, #20]
        /* Rx reg 15 mask*/
        (base->RX15MASK) = (uint32)(FLEXCAN_RX15MASK_RX15M_MASK);
    cf58:	9b01      	ldr	r3, [sp, #4]
    cf5a:	f04f 32ff 	mov.w	r2, #4294967295
    cf5e:	619a      	str	r2, [r3, #24]
        /* Disable all MB interrupts */
        (base->IMASK1) = 0x0;
    cf60:	9b01      	ldr	r3, [sp, #4]
    cf62:	2200      	movs	r2, #0
    cf64:	629a      	str	r2, [r3, #40]	; 0x28
        /* Clear all MB interrupt flags */
        (base->IFLAG1) = FLEXCAN_IMASK1_BUF31TO0M_MASK;
    cf66:	9b01      	ldr	r3, [sp, #4]
    cf68:	f04f 32ff 	mov.w	r2, #4294967295
    cf6c:	631a      	str	r2, [r3, #48]	; 0x30
            (base->IMASK4) = 0x0;
            (base->IFLAG4) = FLEXCAN_IMASK4_BUF127TO96M_MASK;
        }
#endif
        /* Clear all error interrupt flags */
        (base->ESR1) = FLEXCAN_IP_ALL_INT;
    cf6e:	9b01      	ldr	r3, [sp, #4]
    cf70:	4a10      	ldr	r2, [pc, #64]	; (cfb4 <FlexCAN_Init+0xe4>)
    cf72:	621a      	str	r2, [r3, #32]
        /* clear registers which are not effected by soft reset */
        base->CTRL1 = FLEXCAN_IP_CTRL1_DEFAULT_VALUE_U32;
    cf74:	9b01      	ldr	r3, [sp, #4]
    cf76:	2200      	movs	r2, #0
    cf78:	605a      	str	r2, [r3, #4]
        base->CTRL2 = FLEXCAN_IP_CTRL2_DEFAULT_VALUE_U32;
    cf7a:	9b01      	ldr	r3, [sp, #4]
    cf7c:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
    cf80:	635a      	str	r2, [r3, #52]	; 0x34
        base->CBT   = FLEXCAN_IP_CBT_DEFAULT_VALUE_U32;
    cf82:	9b01      	ldr	r3, [sp, #4]
    cf84:	2200      	movs	r2, #0
    cf86:	651a      	str	r2, [r3, #80]	; 0x50
        base->EDCBT = FLEXCAN_IP_EDCBT_DEFAULT_VALUE_U32;
        base->ETDC  = FLEXCAN_IP_ETDC_DEFAULT_VALUE_U32;
#endif
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
    #if defined(CAN_FEATURE_S32K1XX)
    if (TRUE == FlexCAN_IsFDAvailable(base))
    cf88:	9801      	ldr	r0, [sp, #4]
    cf8a:	f000 f85b 	bl	d044 <FlexCAN_IsFDAvailable>
    cf8e:	4603      	mov	r3, r0
    cf90:	2b00      	cmp	r3, #0
    cf92:	d007      	beq.n	cfa4 <FlexCAN_Init+0xd4>
    {
    #endif /* defined(CAN_FEATURE_S32K1XX) */
        base->FDCBT = FLEXCAN_IP_FDCBT_DEFAULT_VALUE_U32;
    cf94:	9b01      	ldr	r3, [sp, #4]
    cf96:	2200      	movs	r2, #0
    cf98:	f8c3 2c04 	str.w	r2, [r3, #3076]	; 0xc04
        base->FDCTRL = FLEXCAN_IP_FDCTRL_DEFAULT_VALUE_U32;
    cf9c:	9b01      	ldr	r3, [sp, #4]
    cf9e:	4a06      	ldr	r2, [pc, #24]	; (cfb8 <FlexCAN_Init+0xe8>)
    cfa0:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
    #if defined(CAN_FEATURE_S32K1XX)
    }
    #endif /* defined(CAN_FEATURE_S32K1XX) */
#endif /* (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON) */
    }
    return returnResult;
    cfa4:	9b04      	ldr	r3, [sp, #16]
}
    cfa6:	4618      	mov	r0, r3
    cfa8:	b007      	add	sp, #28
    cfaa:	f85d fb04 	ldr.w	pc, [sp], #4
    cfae:	bf00      	nop
    cfb0:	000f4240 	.word	0x000f4240
    cfb4:	003b0006 	.word	0x003b0006
    cfb8:	80004100 	.word	0x80004100

0000cfbc <FlexCAN_EnableRxFifo>:
 * This function will enable the Rx FIFO feature.
 *
 *END**************************************************************************/
Flexcan_Ip_StatusType FlexCAN_EnableRxFifo(FLEXCAN_Type * base,
                                         uint32 numOfFilters)
{
    cfbc:	b500      	push	{lr}
    cfbe:	b087      	sub	sp, #28
    cfc0:	9001      	str	r0, [sp, #4]
    cfc2:	9100      	str	r1, [sp, #0]
    uint32 i;
    uint16 noOfMbx = (uint16)FlexCAN_GetMaxMbNum(base);
    cfc4:	9801      	ldr	r0, [sp, #4]
    cfc6:	f7ff fdfb 	bl	cbc0 <FlexCAN_GetMaxMbNum>
    cfca:	4603      	mov	r3, r0
    cfcc:	f8ad 300e 	strh.w	r3, [sp, #14]
    Flexcan_Ip_StatusType stat = FLEXCAN_STATUS_SUCCESS;
    cfd0:	2300      	movs	r3, #0
    cfd2:	9304      	str	r3, [sp, #16]

    /* RxFIFO cannot be enabled if FD is enabled */
    if (((base->MCR & FLEXCAN_MCR_FDEN_MASK) >> FLEXCAN_MCR_FDEN_SHIFT) != 0U)
    cfd4:	9b01      	ldr	r3, [sp, #4]
    cfd6:	681b      	ldr	r3, [r3, #0]
    cfd8:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    cfdc:	2b00      	cmp	r3, #0
    cfde:	d001      	beq.n	cfe4 <FlexCAN_EnableRxFifo+0x28>
    {
        stat = FLEXCAN_STATUS_ERROR;
    cfe0:	2301      	movs	r3, #1
    cfe2:	9304      	str	r3, [sp, #16]
    }
    if (FLEXCAN_STATUS_SUCCESS == stat)
    cfe4:	9b04      	ldr	r3, [sp, #16]
    cfe6:	2b00      	cmp	r3, #0
    cfe8:	d127      	bne.n	d03a <FlexCAN_EnableRxFifo+0x7e>
    {
        /* Enable RX FIFO */
        base->MCR = (base->MCR & ~FLEXCAN_MCR_RFEN_MASK) | FLEXCAN_MCR_RFEN(1U);
    cfea:	9b01      	ldr	r3, [sp, #4]
    cfec:	681b      	ldr	r3, [r3, #0]
    cfee:	f043 5200 	orr.w	r2, r3, #536870912	; 0x20000000
    cff2:	9b01      	ldr	r3, [sp, #4]
    cff4:	601a      	str	r2, [r3, #0]
        /* Set the number of the RX FIFO filters needed */
        base->CTRL2 = (base->CTRL2 & ~FLEXCAN_CTRL2_RFFN_MASK) | ((numOfFilters << FLEXCAN_CTRL2_RFFN_SHIFT) & FLEXCAN_CTRL2_RFFN_MASK);
    cff6:	9b01      	ldr	r3, [sp, #4]
    cff8:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    cffa:	f023 6270 	bic.w	r2, r3, #251658240	; 0xf000000
    cffe:	9b00      	ldr	r3, [sp, #0]
    d000:	061b      	lsls	r3, r3, #24
    d002:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    d006:	431a      	orrs	r2, r3
    d008:	9b01      	ldr	r3, [sp, #4]
    d00a:	635a      	str	r2, [r3, #52]	; 0x34
        /* RX FIFO global mask, take in consideration all filter fields*/
        (base->RXFGMASK) = FLEXCAN_RXFGMASK_FGM_MASK;
    d00c:	9b01      	ldr	r3, [sp, #4]
    d00e:	f04f 32ff 	mov.w	r2, #4294967295
    d012:	649a      	str	r2, [r3, #72]	; 0x48

        for (i = 0U; i < noOfMbx; i++)
    d014:	2300      	movs	r3, #0
    d016:	9305      	str	r3, [sp, #20]
    d018:	e00a      	b.n	d030 <FlexCAN_EnableRxFifo+0x74>
        {
            /* RX individual mask */
            base->RXIMR[i] = (FLEXCAN_RXIMR_MI_MASK << FLEXCAN_IP_ID_EXT_SHIFT) & (FLEXCAN_IP_ID_STD_MASK | FLEXCAN_IP_ID_EXT_MASK);
    d01a:	9b01      	ldr	r3, [sp, #4]
    d01c:	9a05      	ldr	r2, [sp, #20]
    d01e:	f502 7208 	add.w	r2, r2, #544	; 0x220
    d022:	f06f 4160 	mvn.w	r1, #3758096384	; 0xe0000000
    d026:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
        for (i = 0U; i < noOfMbx; i++)
    d02a:	9b05      	ldr	r3, [sp, #20]
    d02c:	3301      	adds	r3, #1
    d02e:	9305      	str	r3, [sp, #20]
    d030:	f8bd 300e 	ldrh.w	r3, [sp, #14]
    d034:	9a05      	ldr	r2, [sp, #20]
    d036:	429a      	cmp	r2, r3
    d038:	d3ef      	bcc.n	d01a <FlexCAN_EnableRxFifo+0x5e>
        }
    }
    return stat;
    d03a:	9b04      	ldr	r3, [sp, #16]
}
    d03c:	4618      	mov	r0, r3
    d03e:	b007      	add	sp, #28
    d040:	f85d fb04 	ldr.w	pc, [sp], #4

0000d044 <FlexCAN_IsFDAvailable>:
 * Description   : Checks if FlexCAN has FD Support.
 * This function is private.
 *
 *END**************************************************************************/
boolean FlexCAN_IsFDAvailable(const FLEXCAN_Type * base)
{
    d044:	b084      	sub	sp, #16
    d046:	9001      	str	r0, [sp, #4]
    uint32 i=0U;
    d048:	2300      	movs	r3, #0
    d04a:	9303      	str	r3, [sp, #12]
    static FLEXCAN_Type * const flexcanBase[] = CAN_BASE_PTRS_HAS_FD;
    boolean returnValue = FALSE;
    d04c:	2300      	movs	r3, #0
    d04e:	f88d 300b 	strb.w	r3, [sp, #11]
    for (i = 0U; i < CAN_FEATURE_FD_INSTANCES; i++)
    d052:	2300      	movs	r3, #0
    d054:	9303      	str	r3, [sp, #12]
    d056:	e00d      	b.n	d074 <FlexCAN_IsFDAvailable+0x30>
    {
        if (base == flexcanBase[i])
    d058:	4a0a      	ldr	r2, [pc, #40]	; (d084 <FlexCAN_IsFDAvailable+0x40>)
    d05a:	9b03      	ldr	r3, [sp, #12]
    d05c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    d060:	9a01      	ldr	r2, [sp, #4]
    d062:	429a      	cmp	r2, r3
    d064:	d103      	bne.n	d06e <FlexCAN_IsFDAvailable+0x2a>
        {
            returnValue = TRUE;
    d066:	2301      	movs	r3, #1
    d068:	f88d 300b 	strb.w	r3, [sp, #11]
            break;
    d06c:	e005      	b.n	d07a <FlexCAN_IsFDAvailable+0x36>
    for (i = 0U; i < CAN_FEATURE_FD_INSTANCES; i++)
    d06e:	9b03      	ldr	r3, [sp, #12]
    d070:	3301      	adds	r3, #1
    d072:	9303      	str	r3, [sp, #12]
    d074:	9b03      	ldr	r3, [sp, #12]
    d076:	2b00      	cmp	r3, #0
    d078:	d0ee      	beq.n	d058 <FlexCAN_IsFDAvailable+0x14>
        }
    }

    return returnValue;
    d07a:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
    d07e:	4618      	mov	r0, r3
    d080:	b004      	add	sp, #16
    d082:	4770      	bx	lr
    d084:	00015c50 	.word	0x00015c50

0000d088 <FlexCAN_SetPayloadSize>:
 * Description   : Sets the payload size of the MBs.
 *
 *END**************************************************************************/
void FlexCAN_SetPayloadSize(FLEXCAN_Type * base,
                            const Flexcan_Ip_PayloadSizeType * payloadSize)
{
    d088:	b500      	push	{lr}
    d08a:	b085      	sub	sp, #20
    d08c:	9001      	str	r0, [sp, #4]
    d08e:	9100      	str	r1, [sp, #0]
    #if (FLEXCAN_IP_FEATURE_MBDSR_COUNT > 3U)
    DevAssert(FlexCAN_IsFDEnabled(base) || (FLEXCAN_PAYLOAD_SIZE_8 == payloadSize->payloadBlock3));
    #endif
#endif
    /* If FD is not enabled, only 8 bytes payload is supported */
    if (FlexCAN_IsFDEnabled(base))
    d090:	9801      	ldr	r0, [sp, #4]
    d092:	f7ff fbd6 	bl	c842 <FlexCAN_IsFDEnabled>
    d096:	4603      	mov	r3, r0
    d098:	2b00      	cmp	r3, #0
    d09a:	d011      	beq.n	d0c0 <FlexCAN_SetPayloadSize+0x38>
    {
        tmp = base->FDCTRL;
    d09c:	9b01      	ldr	r3, [sp, #4]
    d09e:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    d0a2:	9303      	str	r3, [sp, #12]
        tmp &= ~(FLEXCAN_FDCTRL_MBDSR0_MASK);
    d0a4:	9b03      	ldr	r3, [sp, #12]
    d0a6:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    d0aa:	9303      	str	r3, [sp, #12]
        tmp |= ((uint32)payloadSize->payloadBlock0) << FLEXCAN_FDCTRL_MBDSR0_SHIFT;
    d0ac:	9b00      	ldr	r3, [sp, #0]
    d0ae:	681b      	ldr	r3, [r3, #0]
    d0b0:	041b      	lsls	r3, r3, #16
    d0b2:	9a03      	ldr	r2, [sp, #12]
    d0b4:	4313      	orrs	r3, r2
    d0b6:	9303      	str	r3, [sp, #12]
#endif
#if (FLEXCAN_IP_FEATURE_MBDSR_COUNT > 3U)
        tmp &= ~(FLEXCAN_FDCTRL_MBDSR3_MASK);
        tmp |= ((uint32)payloadSize->payloadBlock3) << FLEXCAN_FDCTRL_MBDSR3_SHIFT;
#endif
        base->FDCTRL = tmp;
    d0b8:	9b01      	ldr	r3, [sp, #4]
    d0ba:	9a03      	ldr	r2, [sp, #12]
    d0bc:	f8c3 2c00 	str.w	r2, [r3, #3072]	; 0xc00
    }
}
    d0c0:	bf00      	nop
    d0c2:	b005      	add	sp, #20
    d0c4:	f85d fb04 	ldr.w	pc, [sp], #4

0000d0c8 <FlexCAN_GetPayloadSize>:
 * Function Name : FLEXCAN_GetPayloadSize
 * Description   : Returns the payload size of the MBs (in bytes).
 *
 *END**************************************************************************/
static uint8 FlexCAN_GetPayloadSize(const FLEXCAN_Type * base, uint8 mbdsrIdx)
{
    d0c8:	b500      	push	{lr}
    d0ca:	b085      	sub	sp, #20
    d0cc:	9001      	str	r0, [sp, #4]
    d0ce:	460b      	mov	r3, r1
    d0d0:	f88d 3003 	strb.w	r3, [sp, #3]
    uint32 payloadSize = 0U;
    d0d4:	2300      	movs	r3, #0
    d0d6:	9303      	str	r3, [sp, #12]

#if defined(CAN_FEATURE_S32K1XX)
    if (TRUE == FlexCAN_IsFDAvailable(base))
    d0d8:	9801      	ldr	r0, [sp, #4]
    d0da:	f7ff ffb3 	bl	d044 <FlexCAN_IsFDAvailable>
    d0de:	4603      	mov	r3, r0
    d0e0:	2b00      	cmp	r3, #0
    d0e2:	d019      	beq.n	d118 <FlexCAN_GetPayloadSize+0x50>
    {
#endif /* defined(CAN_FEATURE_S32K1XX) */
    switch (mbdsrIdx)
    d0e4:	f89d 3003 	ldrb.w	r3, [sp, #3]
    d0e8:	2b00      	cmp	r3, #0
    d0ea:	d10a      	bne.n	d102 <FlexCAN_GetPayloadSize+0x3a>
    {
        case 0 : {  payloadSize = 8UL << ((base->FDCTRL & FLEXCAN_FDCTRL_MBDSR0_MASK) >> FLEXCAN_FDCTRL_MBDSR0_SHIFT); } break;
    d0ec:	9b01      	ldr	r3, [sp, #4]
    d0ee:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    d0f2:	0c1b      	lsrs	r3, r3, #16
    d0f4:	f003 0303 	and.w	r3, r3, #3
    d0f8:	2208      	movs	r2, #8
    d0fa:	fa02 f303 	lsl.w	r3, r2, r3
    d0fe:	9303      	str	r3, [sp, #12]
    d100:	e00c      	b.n	d11c <FlexCAN_GetPayloadSize+0x54>
        case 2 : {  payloadSize = 8UL << ((base->FDCTRL & FLEXCAN_FDCTRL_MBDSR2_MASK) >> FLEXCAN_FDCTRL_MBDSR2_SHIFT); } break;
    #endif
    #if (FLEXCAN_IP_FEATURE_MBDSR_COUNT > 3U)
        case 3 : {  payloadSize = 8UL << ((base->FDCTRL & FLEXCAN_FDCTRL_MBDSR3_MASK) >> FLEXCAN_FDCTRL_MBDSR3_SHIFT); } break;
    #endif
        default :{  payloadSize = 8UL << ((base->FDCTRL & FLEXCAN_FDCTRL_MBDSR0_MASK) >> FLEXCAN_FDCTRL_MBDSR0_SHIFT); } break;
    d102:	9b01      	ldr	r3, [sp, #4]
    d104:	f8d3 3c00 	ldr.w	r3, [r3, #3072]	; 0xc00
    d108:	0c1b      	lsrs	r3, r3, #16
    d10a:	f003 0303 	and.w	r3, r3, #3
    d10e:	2208      	movs	r2, #8
    d110:	fa02 f303 	lsl.w	r3, r2, r3
    d114:	9303      	str	r3, [sp, #12]
    d116:	e001      	b.n	d11c <FlexCAN_GetPayloadSize+0x54>
    }
    #if defined(CAN_FEATURE_S32K1XX)
    }
    else
    {
        payloadSize = 8U;
    d118:	2308      	movs	r3, #8
    d11a:	9303      	str	r3, [sp, #12]
    }
    #endif /* defined(CAN_FEATURE_S32K1XX) */
    return (uint8)payloadSize;
    d11c:	9b03      	ldr	r3, [sp, #12]
    d11e:	b2db      	uxtb	r3, r3
}
    d120:	4618      	mov	r0, r3
    d122:	b005      	add	sp, #20
    d124:	f85d fb04 	ldr.w	pc, [sp], #4

0000d128 <FlexCAN_GetMbPayloadSize>:



uint8 FlexCAN_GetMbPayloadSize(const FLEXCAN_Type * base, uint32 maxMsgBuffNum)
{
    d128:	b500      	push	{lr}
    d12a:	b087      	sub	sp, #28
    d12c:	9001      	str	r0, [sp, #4]
    d12e:	9100      	str	r1, [sp, #0]
    uint8 arbitration_field_size = 8U;
    d130:	2308      	movs	r3, #8
    d132:	f88d 3014 	strb.w	r3, [sp, #20]
    uint32 ramBlockSize = 512U;
    d136:	f44f 7300 	mov.w	r3, #512	; 0x200
    d13a:	9304      	str	r3, [sp, #16]
    uint8 can_real_payload = 8U;
    d13c:	2308      	movs	r3, #8
    d13e:	f88d 3017 	strb.w	r3, [sp, #23]
    uint8 maxMbBlockNum = 0U;
    d142:	2300      	movs	r3, #0
    d144:	f88d 3016 	strb.w	r3, [sp, #22]
    uint8 i=0U;
    d148:	2300      	movs	r3, #0
    d14a:	f88d 3015 	strb.w	r3, [sp, #21]
    uint8 mb_size = 0U;
    d14e:	2300      	movs	r3, #0
    d150:	f88d 300f 	strb.w	r3, [sp, #15]

    for (i=0; i< (uint8)FLEXCAN_IP_FEATURE_MBDSR_COUNT; i++)
    d154:	2300      	movs	r3, #0
    d156:	f88d 3015 	strb.w	r3, [sp, #21]
    d15a:	e024      	b.n	d1a6 <FlexCAN_GetMbPayloadSize+0x7e>
    {
        /* Check that the number of MBs is supported based on the payload size*/
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
        can_real_payload = FlexCAN_GetPayloadSize(base, i);
    d15c:	f89d 3015 	ldrb.w	r3, [sp, #21]
    d160:	4619      	mov	r1, r3
    d162:	9801      	ldr	r0, [sp, #4]
    d164:	f7ff ffb0 	bl	d0c8 <FlexCAN_GetPayloadSize>
    d168:	4603      	mov	r3, r0
    d16a:	f88d 3017 	strb.w	r3, [sp, #23]
#endif /* Else can_real_payload will remain as 8 payload size */
        mb_size = (uint8)(can_real_payload + arbitration_field_size);
    d16e:	f89d 2017 	ldrb.w	r2, [sp, #23]
    d172:	f89d 3014 	ldrb.w	r3, [sp, #20]
    d176:	4413      	add	r3, r2
    d178:	f88d 300f 	strb.w	r3, [sp, #15]
        maxMbBlockNum += (uint8)(ramBlockSize / mb_size);
    d17c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    d180:	9a04      	ldr	r2, [sp, #16]
    d182:	fbb2 f3f3 	udiv	r3, r2, r3
    d186:	b2da      	uxtb	r2, r3
    d188:	f89d 3016 	ldrb.w	r3, [sp, #22]
    d18c:	4413      	add	r3, r2
    d18e:	f88d 3016 	strb.w	r3, [sp, #22]
        if (maxMbBlockNum > maxMsgBuffNum)
    d192:	f89d 3016 	ldrb.w	r3, [sp, #22]
    d196:	9a00      	ldr	r2, [sp, #0]
    d198:	429a      	cmp	r2, r3
    d19a:	d309      	bcc.n	d1b0 <FlexCAN_GetMbPayloadSize+0x88>
    for (i=0; i< (uint8)FLEXCAN_IP_FEATURE_MBDSR_COUNT; i++)
    d19c:	f89d 3015 	ldrb.w	r3, [sp, #21]
    d1a0:	3301      	adds	r3, #1
    d1a2:	f88d 3015 	strb.w	r3, [sp, #21]
    d1a6:	f89d 3015 	ldrb.w	r3, [sp, #21]
    d1aa:	2b00      	cmp	r3, #0
    d1ac:	d0d6      	beq.n	d15c <FlexCAN_GetMbPayloadSize+0x34>
    d1ae:	e000      	b.n	d1b2 <FlexCAN_GetMbPayloadSize+0x8a>
        {
            break;
    d1b0:	bf00      	nop
    {
        can_real_payload = 64U;
    }
 #endif

    return can_real_payload;
    d1b2:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
    d1b6:	4618      	mov	r0, r3
    d1b8:	b007      	add	sp, #28
    d1ba:	f85d fb04 	ldr.w	pc, [sp], #4

0000d1be <FlexCAN_LockRxMsgBuff>:
 * Description   : Lock the RX message buffer.
 * This function will lock the RX message buffer.
 *
 *END**************************************************************************/
void FlexCAN_LockRxMsgBuff(const FLEXCAN_Type * base, uint32 msgBuffIdx)
{
    d1be:	b500      	push	{lr}
    d1c0:	b085      	sub	sp, #20
    d1c2:	9001      	str	r0, [sp, #4]
    d1c4:	9100      	str	r1, [sp, #0]
    volatile const uint32 * flexcan_mb = FlexCAN_GetMsgBuffRegion(base, msgBuffIdx);
    d1c6:	9900      	ldr	r1, [sp, #0]
    d1c8:	9801      	ldr	r0, [sp, #4]
    d1ca:	f7ff fc7f 	bl	cacc <FlexCAN_GetMsgBuffRegion>
    d1ce:	9003      	str	r0, [sp, #12]

    /* Lock the mailbox by reading it */
    (void)*flexcan_mb;
    d1d0:	9b03      	ldr	r3, [sp, #12]
    d1d2:	681b      	ldr	r3, [r3, #0]
}
    d1d4:	bf00      	nop
    d1d6:	b005      	add	sp, #20
    d1d8:	f85d fb04 	ldr.w	pc, [sp], #4

0000d1dc <FlexCAN_SetMsgBuffIntCmd>:
                                               uint8 u8Instance,
                                               uint32 msgBuffIdx,
                                               boolean enable,
                                               boolean bIsIntActive
                                              )
{
    d1dc:	b500      	push	{lr}
    d1de:	b087      	sub	sp, #28
    d1e0:	9003      	str	r0, [sp, #12]
    d1e2:	9201      	str	r2, [sp, #4]
    d1e4:	461a      	mov	r2, r3
    d1e6:	460b      	mov	r3, r1
    d1e8:	f88d 300b 	strb.w	r3, [sp, #11]
    d1ec:	4613      	mov	r3, r2
    d1ee:	f88d 300a 	strb.w	r3, [sp, #10]
    uint32 temp;
    Flexcan_Ip_StatusType stat = FLEXCAN_STATUS_SUCCESS;
    d1f2:	2300      	movs	r3, #0
    d1f4:	9305      	str	r3, [sp, #20]

        /* Enable the corresponding message buffer Interrupt */
        temp = 1UL << (msgBuffIdx % 32U);
    d1f6:	9b01      	ldr	r3, [sp, #4]
    d1f8:	f003 031f 	and.w	r3, r3, #31
    d1fc:	2201      	movs	r2, #1
    d1fe:	fa02 f303 	lsl.w	r3, r2, r3
    d202:	9304      	str	r3, [sp, #16]
        if (msgBuffIdx < 32U)
    d204:	9b01      	ldr	r3, [sp, #4]
    d206:	2b1f      	cmp	r3, #31
    d208:	d837      	bhi.n	d27a <FlexCAN_SetMsgBuffIntCmd+0x9e>
        {
            if (enable)
    d20a:	f89d 300a 	ldrb.w	r3, [sp, #10]
    d20e:	2b00      	cmp	r3, #0
    d210:	d01b      	beq.n	d24a <FlexCAN_SetMsgBuffIntCmd+0x6e>
            {
                /* Start critical section: implementation depends on integrator */
                SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18();
    d212:	f005 fc5d 	bl	12ad0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18>
                FlexCAN_Ip_au32ImaskBuff[u8Instance][0U] = ((FlexCAN_Ip_au32ImaskBuff[u8Instance][0U]) | (temp));
    d216:	f89d 300b 	ldrb.w	r3, [sp, #11]
    d21a:	4a1a      	ldr	r2, [pc, #104]	; (d284 <FlexCAN_SetMsgBuffIntCmd+0xa8>)
    d21c:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    d220:	f89d 300b 	ldrb.w	r3, [sp, #11]
    d224:	9a04      	ldr	r2, [sp, #16]
    d226:	430a      	orrs	r2, r1
    d228:	4916      	ldr	r1, [pc, #88]	; (d284 <FlexCAN_SetMsgBuffIntCmd+0xa8>)
    d22a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                if (TRUE == bIsIntActive)
    d22e:	f89d 3020 	ldrb.w	r3, [sp, #32]
    d232:	2b00      	cmp	r3, #0
    d234:	d006      	beq.n	d244 <FlexCAN_SetMsgBuffIntCmd+0x68>
                {
                    base->IMASK1 = FlexCAN_Ip_au32ImaskBuff[u8Instance][0U];
    d236:	f89d 300b 	ldrb.w	r3, [sp, #11]
    d23a:	4a12      	ldr	r2, [pc, #72]	; (d284 <FlexCAN_SetMsgBuffIntCmd+0xa8>)
    d23c:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    d240:	9b03      	ldr	r3, [sp, #12]
    d242:	629a      	str	r2, [r3, #40]	; 0x28
                }
                /* End critical section: implementation depends on integrator */
                SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18();
    d244:	f005 fc70 	bl	12b28 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18>
    d248:	e017      	b.n	d27a <FlexCAN_SetMsgBuffIntCmd+0x9e>
            }
            else
            {
                /* Start critical section: implementation depends on integrator */
                SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18();
    d24a:	f005 fc41 	bl	12ad0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18>
                FlexCAN_Ip_au32ImaskBuff[u8Instance][0U] = ((FlexCAN_Ip_au32ImaskBuff[u8Instance][0U]) & ~(temp));
    d24e:	f89d 300b 	ldrb.w	r3, [sp, #11]
    d252:	4a0c      	ldr	r2, [pc, #48]	; (d284 <FlexCAN_SetMsgBuffIntCmd+0xa8>)
    d254:	f852 1023 	ldr.w	r1, [r2, r3, lsl #2]
    d258:	9b04      	ldr	r3, [sp, #16]
    d25a:	43da      	mvns	r2, r3
    d25c:	f89d 300b 	ldrb.w	r3, [sp, #11]
    d260:	400a      	ands	r2, r1
    d262:	4908      	ldr	r1, [pc, #32]	; (d284 <FlexCAN_SetMsgBuffIntCmd+0xa8>)
    d264:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
                base->IMASK1 = FlexCAN_Ip_au32ImaskBuff[u8Instance][0U];
    d268:	f89d 300b 	ldrb.w	r3, [sp, #11]
    d26c:	4a05      	ldr	r2, [pc, #20]	; (d284 <FlexCAN_SetMsgBuffIntCmd+0xa8>)
    d26e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    d272:	9b03      	ldr	r3, [sp, #12]
    d274:	629a      	str	r2, [r3, #40]	; 0x28
                /* End critical section: implementation depends on integrator */
                SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18();
    d276:	f005 fc57 	bl	12b28 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18>
                SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18();
            }
        }
#endif /* if FLEXCAN_IP_FEATURE_MAX_MB_NUM > 96U */

    return stat;
    d27a:	9b05      	ldr	r3, [sp, #20]
}
    d27c:	4618      	mov	r0, r3
    d27e:	b007      	add	sp, #28
    d280:	f85d fb04 	ldr.w	pc, [sp], #4
    d284:	1fff9054 	.word	0x1fff9054

0000d288 <FLEXCAN_ClearMsgBuffIntCmd>:
void FLEXCAN_ClearMsgBuffIntCmd(FLEXCAN_Type * pBase,
                                uint8 u8Instance,
                                uint32 mb_idx,
                                boolean bIsIntActive
                               )
{
    d288:	b500      	push	{lr}
    d28a:	b087      	sub	sp, #28
    d28c:	9003      	str	r0, [sp, #12]
    d28e:	9201      	str	r2, [sp, #4]
    d290:	461a      	mov	r2, r3
    d292:	460b      	mov	r3, r1
    d294:	f88d 300b 	strb.w	r3, [sp, #11]
    d298:	4613      	mov	r3, r2
    d29a:	f88d 300a 	strb.w	r3, [sp, #10]
    uint32 temp = (1UL << (mb_idx % 32U));
    d29e:	9b01      	ldr	r3, [sp, #4]
    d2a0:	f003 031f 	and.w	r3, r3, #31
    d2a4:	2201      	movs	r2, #1
    d2a6:	fa02 f303 	lsl.w	r3, r2, r3
    d2aa:	9305      	str	r3, [sp, #20]

 /* Stop the running transfer. */
    if (mb_idx < 32U)
    d2ac:	9b01      	ldr	r3, [sp, #4]
    d2ae:	2b1f      	cmp	r3, #31
    d2b0:	d818      	bhi.n	d2e4 <FLEXCAN_ClearMsgBuffIntCmd+0x5c>
    {
          /* Start critical section: implementation depends on integrator */
          SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11();
    d2b2:	f005 f9cf 	bl	12654 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11>
          FlexCAN_Ip_au32ImaskBuff[u8Instance][0U] = (pBase->IMASK1 & (~temp));
    d2b6:	9b03      	ldr	r3, [sp, #12]
    d2b8:	6a99      	ldr	r1, [r3, #40]	; 0x28
    d2ba:	9b05      	ldr	r3, [sp, #20]
    d2bc:	43da      	mvns	r2, r3
    d2be:	f89d 300b 	ldrb.w	r3, [sp, #11]
    d2c2:	400a      	ands	r2, r1
    d2c4:	4909      	ldr	r1, [pc, #36]	; (d2ec <FLEXCAN_ClearMsgBuffIntCmd+0x64>)
    d2c6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
          if (TRUE == bIsIntActive)
    d2ca:	f89d 300a 	ldrb.w	r3, [sp, #10]
    d2ce:	2b00      	cmp	r3, #0
    d2d0:	d006      	beq.n	d2e0 <FLEXCAN_ClearMsgBuffIntCmd+0x58>
          {
              pBase->IMASK1 = FlexCAN_Ip_au32ImaskBuff[u8Instance][0U];
    d2d2:	f89d 300b 	ldrb.w	r3, [sp, #11]
    d2d6:	4a05      	ldr	r2, [pc, #20]	; (d2ec <FLEXCAN_ClearMsgBuffIntCmd+0x64>)
    d2d8:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    d2dc:	9b03      	ldr	r3, [sp, #12]
    d2de:	629a      	str	r2, [r3, #40]	; 0x28
          }
          /* End critical section: implementation depends on integrator */
          SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11();
    d2e0:	f005 f9e4 	bl	126ac <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11>
        }
        /* End critical section: implementation depends on integrator */
        SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11();
    }
#endif /* #if FLEXCAN_IP_FEATURE_MAX_MB_NUM > 96U */
}
    d2e4:	bf00      	nop
    d2e6:	b007      	add	sp, #28
    d2e8:	f85d fb04 	ldr.w	pc, [sp], #4
    d2ec:	1fff9054 	.word	0x1fff9054

0000d2f0 <FlexCAN_DisableInterrupts>:


void FlexCAN_DisableInterrupts(FLEXCAN_Type * pBase)
{
    d2f0:	b082      	sub	sp, #8
    d2f2:	9001      	str	r0, [sp, #4]
#if (FLEXCAN_IP_FEATURE_MAX_MB_NUM > 32U)
    uint32 u32MaxMbCrtlNum = FlexCAN_GetMaxMbNum(pBase);
#endif /* (FLEXCAN_IP_FEATURE_MAX_MB_NUM > 32U) */

    pBase->IMASK1 = 0U;
    d2f4:	9b01      	ldr	r3, [sp, #4]
    d2f6:	2200      	movs	r2, #0
    d2f8:	629a      	str	r2, [r3, #40]	; 0x28
    if (u32MaxMbCrtlNum > 96U)
    {
        pBase->IMASK4 = 0U;
    }
#endif /* (FLEXCAN_IP_FEATURE_MAX_MB_NUM > 96U) */
}
    d2fa:	bf00      	nop
    d2fc:	b002      	add	sp, #8
    d2fe:	4770      	bx	lr

0000d300 <FlexCAN_EnableInterrupts>:

void FlexCAN_EnableInterrupts(FLEXCAN_Type * pBase, uint8 u8Instance)
{
    d300:	b082      	sub	sp, #8
    d302:	9001      	str	r0, [sp, #4]
    d304:	460b      	mov	r3, r1
    d306:	f88d 3003 	strb.w	r3, [sp, #3]
#if (FLEXCAN_IP_FEATURE_MAX_MB_NUM > 32U)
    uint32 u32MaxMbCrtlNum = FlexCAN_GetMaxMbNum(pBase);
#endif /* (FLEXCAN_IP_FEATURE_MAX_MB_NUM > 32U) */

    pBase->IMASK1 = FlexCAN_Ip_au32ImaskBuff[u8Instance][0U];
    d30a:	f89d 3003 	ldrb.w	r3, [sp, #3]
    d30e:	4a04      	ldr	r2, [pc, #16]	; (d320 <FlexCAN_EnableInterrupts+0x20>)
    d310:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
    d314:	9b01      	ldr	r3, [sp, #4]
    d316:	629a      	str	r2, [r3, #40]	; 0x28
    if (u32MaxMbCrtlNum > 96U)
    {
        pBase->IMASK4 = FlexCAN_Ip_au32ImaskBuff[u8Instance][3U];
    }
#endif /* (FLEXCAN_IP_FEATURE_MAX_MB_NUM > 96U) */
}
    d318:	bf00      	nop
    d31a:	b002      	add	sp, #8
    d31c:	4770      	bx	lr
    d31e:	bf00      	nop
    d320:	1fff9054 	.word	0x1fff9054

0000d324 <FlexCAN_SetRxMsgBuff>:
void FlexCAN_SetRxMsgBuff(const FLEXCAN_Type * base,
                          uint32 msgBuffIdx,
                          const Flexcan_Ip_MsbuffCodeStatusType * cs,
                          uint32 msgId
                         )
{
    d324:	b500      	push	{lr}
    d326:	b087      	sub	sp, #28
    d328:	9003      	str	r0, [sp, #12]
    d32a:	9102      	str	r1, [sp, #8]
    d32c:	9201      	str	r2, [sp, #4]
    d32e:	9300      	str	r3, [sp, #0]
    volatile uint32 * flexcan_mb = FlexCAN_GetMsgBuffRegion(base, msgBuffIdx);
    d330:	9902      	ldr	r1, [sp, #8]
    d332:	9803      	ldr	r0, [sp, #12]
    d334:	f7ff fbca 	bl	cacc <FlexCAN_GetMsgBuffRegion>
    d338:	9005      	str	r0, [sp, #20]
    volatile uint32 * flexcan_mb_id = &flexcan_mb[1];
    d33a:	9b05      	ldr	r3, [sp, #20]
    d33c:	3304      	adds	r3, #4
    d33e:	9304      	str	r3, [sp, #16]
    DevAssert(cs != NULL_PTR);
#endif


    /* Clean up the arbitration field area */
    *flexcan_mb = 0;
    d340:	9b05      	ldr	r3, [sp, #20]
    d342:	2200      	movs	r2, #0
    d344:	601a      	str	r2, [r3, #0]
    *flexcan_mb_id = 0;
    d346:	9b04      	ldr	r3, [sp, #16]
    d348:	2200      	movs	r2, #0
    d34a:	601a      	str	r2, [r3, #0]

    /* Set the ID according the format structure */
    if (FLEXCAN_MSG_ID_EXT == cs->msgIdType)
    d34c:	9b01      	ldr	r3, [sp, #4]
    d34e:	685b      	ldr	r3, [r3, #4]
    d350:	2b01      	cmp	r3, #1
    d352:	d119      	bne.n	d388 <FlexCAN_SetRxMsgBuff+0x64>
    {
        /* Set IDE */
        *flexcan_mb |= FLEXCAN_IP_CS_IDE_MASK;
    d354:	9b05      	ldr	r3, [sp, #20]
    d356:	681b      	ldr	r3, [r3, #0]
    d358:	f443 1200 	orr.w	r2, r3, #2097152	; 0x200000
    d35c:	9b05      	ldr	r3, [sp, #20]
    d35e:	601a      	str	r2, [r3, #0]

        /* Clear SRR bit */
        *flexcan_mb &= ~FLEXCAN_IP_CS_SRR_MASK;
    d360:	9b05      	ldr	r3, [sp, #20]
    d362:	681b      	ldr	r3, [r3, #0]
    d364:	f423 0280 	bic.w	r2, r3, #4194304	; 0x400000
    d368:	9b05      	ldr	r3, [sp, #20]
    d36a:	601a      	str	r2, [r3, #0]

        /* ID [28-0] */
        *flexcan_mb_id &= ~(FLEXCAN_IP_ID_STD_MASK | FLEXCAN_IP_ID_EXT_MASK);
    d36c:	9b04      	ldr	r3, [sp, #16]
    d36e:	681b      	ldr	r3, [r3, #0]
    d370:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
    d374:	9b04      	ldr	r3, [sp, #16]
    d376:	601a      	str	r2, [r3, #0]
        *flexcan_mb_id |= (msgId & (FLEXCAN_IP_ID_STD_MASK | FLEXCAN_IP_ID_EXT_MASK));
    d378:	9b04      	ldr	r3, [sp, #16]
    d37a:	681a      	ldr	r2, [r3, #0]
    d37c:	9b00      	ldr	r3, [sp, #0]
    d37e:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
    d382:	431a      	orrs	r2, r3
    d384:	9b04      	ldr	r3, [sp, #16]
    d386:	601a      	str	r2, [r3, #0]
    }

    if (FLEXCAN_MSG_ID_STD == cs->msgIdType)
    d388:	9b01      	ldr	r3, [sp, #4]
    d38a:	685b      	ldr	r3, [r3, #4]
    d38c:	2b00      	cmp	r3, #0
    d38e:	d116      	bne.n	d3be <FlexCAN_SetRxMsgBuff+0x9a>
    {
        /* Make sure IDE and SRR are not set */
        *flexcan_mb &= ~(FLEXCAN_IP_CS_IDE_MASK | FLEXCAN_IP_CS_SRR_MASK);
    d390:	9b05      	ldr	r3, [sp, #20]
    d392:	681b      	ldr	r3, [r3, #0]
    d394:	f423 02c0 	bic.w	r2, r3, #6291456	; 0x600000
    d398:	9b05      	ldr	r3, [sp, #20]
    d39a:	601a      	str	r2, [r3, #0]

        /* ID[28-18] */
        *flexcan_mb_id &= ~FLEXCAN_IP_ID_STD_MASK;
    d39c:	9b04      	ldr	r3, [sp, #16]
    d39e:	681b      	ldr	r3, [r3, #0]
    d3a0:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
    d3a4:	f423 13e0 	bic.w	r3, r3, #1835008	; 0x1c0000
    d3a8:	9a04      	ldr	r2, [sp, #16]
    d3aa:	6013      	str	r3, [r2, #0]
        *flexcan_mb_id |= (msgId << FLEXCAN_IP_ID_STD_SHIFT) & FLEXCAN_IP_ID_STD_MASK;
    d3ac:	9b04      	ldr	r3, [sp, #16]
    d3ae:	681a      	ldr	r2, [r3, #0]
    d3b0:	9b00      	ldr	r3, [sp, #0]
    d3b2:	0499      	lsls	r1, r3, #18
    d3b4:	4b0e      	ldr	r3, [pc, #56]	; (d3f0 <FlexCAN_SetRxMsgBuff+0xcc>)
    d3b6:	400b      	ands	r3, r1
    d3b8:	431a      	orrs	r2, r3
    d3ba:	9b04      	ldr	r3, [sp, #16]
    d3bc:	601a      	str	r2, [r3, #0]
    }

    /* Set MB CODE */
    if ((uint32)FLEXCAN_RX_NOT_USED != cs->code)
    d3be:	9b01      	ldr	r3, [sp, #4]
    d3c0:	681b      	ldr	r3, [r3, #0]
    d3c2:	2b0f      	cmp	r3, #15
    d3c4:	d00f      	beq.n	d3e6 <FlexCAN_SetRxMsgBuff+0xc2>
    {
        *flexcan_mb &= ~FLEXCAN_IP_CS_CODE_MASK;
    d3c6:	9b05      	ldr	r3, [sp, #20]
    d3c8:	681b      	ldr	r3, [r3, #0]
    d3ca:	f023 6270 	bic.w	r2, r3, #251658240	; 0xf000000
    d3ce:	9b05      	ldr	r3, [sp, #20]
    d3d0:	601a      	str	r2, [r3, #0]
        *flexcan_mb |= (cs->code << FLEXCAN_IP_CS_CODE_SHIFT) & FLEXCAN_IP_CS_CODE_MASK;
    d3d2:	9b05      	ldr	r3, [sp, #20]
    d3d4:	681a      	ldr	r2, [r3, #0]
    d3d6:	9b01      	ldr	r3, [sp, #4]
    d3d8:	681b      	ldr	r3, [r3, #0]
    d3da:	061b      	lsls	r3, r3, #24
    d3dc:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    d3e0:	431a      	orrs	r2, r3
    d3e2:	9b05      	ldr	r3, [sp, #20]
    d3e4:	601a      	str	r2, [r3, #0]
    }
}
    d3e6:	bf00      	nop
    d3e8:	b007      	add	sp, #28
    d3ea:	f85d fb04 	ldr.w	pc, [sp], #4
    d3ee:	bf00      	nop
    d3f0:	1ffc0000 	.word	0x1ffc0000

0000d3f4 <FlexCAN_GetMsgBuffTimestamp>:
 * Function Name : FlexCAN_GetMsgBuffTimestamp
 * Description   : Get a message buffer timestamp value.
 *
 *END**************************************************************************/
uint32 FlexCAN_GetMsgBuffTimestamp(const FLEXCAN_Type * base, uint32 msgBuffIdx)
{
    d3f4:	b500      	push	{lr}
    d3f6:	b085      	sub	sp, #20
    d3f8:	9001      	str	r0, [sp, #4]
    d3fa:	9100      	str	r1, [sp, #0]
    uint32 TimeStamp = 0U;
    d3fc:	2300      	movs	r3, #0
    d3fe:	9303      	str	r3, [sp, #12]
    volatile const uint32 * Flexcan_Mb = FlexCAN_GetMsgBuffRegion(base, msgBuffIdx);
    d400:	9900      	ldr	r1, [sp, #0]
    d402:	9801      	ldr	r0, [sp, #4]
    d404:	f7ff fb62 	bl	cacc <FlexCAN_GetMsgBuffRegion>
    d408:	9002      	str	r0, [sp, #8]
        TimeStamp = (uint32)base->HR_TIME_STAMP[msgBuffIdx];
    }
    else
#endif /* EATURE_CAN_HAS_HR_TIMER */
    {
        TimeStamp = (uint32)((*Flexcan_Mb & FLEXCAN_IP_CS_TIME_STAMP_MASK) >> FLEXCAN_IP_CS_TIME_STAMP_SHIFT);
    d40a:	9b02      	ldr	r3, [sp, #8]
    d40c:	681b      	ldr	r3, [r3, #0]
    d40e:	b29b      	uxth	r3, r3
    d410:	9303      	str	r3, [sp, #12]
    }
    return TimeStamp;
    d412:	9b03      	ldr	r3, [sp, #12]
}
    d414:	4618      	mov	r0, r3
    d416:	b005      	add	sp, #20
    d418:	f85d fb04 	ldr.w	pc, [sp], #4

0000d41c <FlexCAN_GetMsgBuff>:
 *END**************************************************************************/
void FlexCAN_GetMsgBuff(const FLEXCAN_Type * base,
                        uint32 msgBuffIdx,
                        Flexcan_Ip_MsgBuffType * msgBuff
                       )
{
    d41c:	b500      	push	{lr}
    d41e:	b08d      	sub	sp, #52	; 0x34
    d420:	9003      	str	r0, [sp, #12]
    d422:	9102      	str	r1, [sp, #8]
    d424:	9201      	str	r2, [sp, #4]

    uint8 i;
    volatile const uint32 * Flexcan_Mb = FlexCAN_GetMsgBuffRegion(base, msgBuffIdx);
    d426:	9902      	ldr	r1, [sp, #8]
    d428:	9803      	ldr	r0, [sp, #12]
    d42a:	f7ff fb4f 	bl	cacc <FlexCAN_GetMsgBuffRegion>
    d42e:	900a      	str	r0, [sp, #40]	; 0x28
    volatile const uint32 * Flexcan_Mb_Id   = &Flexcan_Mb[1];
    d430:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    d432:	3304      	adds	r3, #4
    d434:	9309      	str	r3, [sp, #36]	; 0x24
    volatile const uint8 * Flexcan_Mb_Data = (volatile const uint8 *)(&Flexcan_Mb[2]);
    d436:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    d438:	3308      	adds	r3, #8
    d43a:	9308      	str	r3, [sp, #32]
    volatile const uint32 * Flexcan_Mb_Data_32 = &Flexcan_Mb[2];
    d43c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    d43e:	3308      	adds	r3, #8
    d440:	9307      	str	r3, [sp, #28]
    uint32 * MsgBuff_Data_32 = NULL_PTR;
    d442:	2300      	movs	r3, #0
    d444:	9306      	str	r3, [sp, #24]
    uint32 MbWord;

    uint8 Flexcan_Mb_Dlc_Value = (uint8)(((*Flexcan_Mb) & FLEXCAN_IP_CS_DLC_MASK) >> 16);
    d446:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    d448:	681b      	ldr	r3, [r3, #0]
    d44a:	0c1b      	lsrs	r3, r3, #16
    d44c:	b2db      	uxtb	r3, r3
    d44e:	f003 030f 	and.w	r3, r3, #15
    d452:	f88d 3017 	strb.w	r3, [sp, #23]
    uint8 Payload_Size = FlexCAN_ComputePayloadSize(Flexcan_Mb_Dlc_Value);
    d456:	f89d 3017 	ldrb.w	r3, [sp, #23]
    d45a:	4618      	mov	r0, r3
    d45c:	f7ff faed 	bl	ca3a <FlexCAN_ComputePayloadSize>
    d460:	4603      	mov	r3, r0
    d462:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e

#if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
    DevAssert(msgBuff != NULL_PTR);
#endif
    /* Asign after NULL Check */
    MsgBuff_Data_32 = (uint32 *)(msgBuff->data);
    d466:	9b01      	ldr	r3, [sp, #4]
    d468:	3308      	adds	r3, #8
    d46a:	9306      	str	r3, [sp, #24]
#if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
    /* Payload Size is based on MBDSR for 1 MBDSR corresponds 32 * 8Bytes MBs  */
    if (Payload_Size > FlexCAN_GetMbPayloadSize(base, msgBuffIdx))
    d46c:	9902      	ldr	r1, [sp, #8]
    d46e:	9803      	ldr	r0, [sp, #12]
    d470:	f7ff fe5a 	bl	d128 <FlexCAN_GetMbPayloadSize>
    d474:	4603      	mov	r3, r0
    d476:	461a      	mov	r2, r3
    d478:	f89d 302e 	ldrb.w	r3, [sp, #46]	; 0x2e
    d47c:	4293      	cmp	r3, r2
    d47e:	d906      	bls.n	d48e <FlexCAN_GetMsgBuff+0x72>
    {
        Payload_Size = FlexCAN_GetMbPayloadSize(base, msgBuffIdx);
    d480:	9902      	ldr	r1, [sp, #8]
    d482:	9803      	ldr	r0, [sp, #12]
    d484:	f7ff fe50 	bl	d128 <FlexCAN_GetMbPayloadSize>
    d488:	4603      	mov	r3, r0
    d48a:	f88d 302e 	strb.w	r3, [sp, #46]	; 0x2e
    }
#endif /* FLEXCAN_IP_FEATURE_HAS_FD */

    msgBuff->dataLen = Payload_Size;
    d48e:	9b01      	ldr	r3, [sp, #4]
    d490:	f89d 202e 	ldrb.w	r2, [sp, #46]	; 0x2e
    d494:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
    /* Get a MB field values */
    msgBuff->cs = *Flexcan_Mb;
    d498:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    d49a:	681a      	ldr	r2, [r3, #0]
    d49c:	9b01      	ldr	r3, [sp, #4]
    d49e:	601a      	str	r2, [r3, #0]
    if ((msgBuff->cs & FLEXCAN_IP_CS_IDE_MASK) != 0U)
    d4a0:	9b01      	ldr	r3, [sp, #4]
    d4a2:	681b      	ldr	r3, [r3, #0]
    d4a4:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
    d4a8:	2b00      	cmp	r3, #0
    d4aa:	d004      	beq.n	d4b6 <FlexCAN_GetMsgBuff+0x9a>
    {
        msgBuff->msgId = (*Flexcan_Mb_Id);
    d4ac:	9b09      	ldr	r3, [sp, #36]	; 0x24
    d4ae:	681a      	ldr	r2, [r3, #0]
    d4b0:	9b01      	ldr	r3, [sp, #4]
    d4b2:	605a      	str	r2, [r3, #4]
    d4b4:	e004      	b.n	d4c0 <FlexCAN_GetMsgBuff+0xa4>
    }
    else
    {
        msgBuff->msgId = (*Flexcan_Mb_Id) >> FLEXCAN_IP_ID_STD_SHIFT;
    d4b6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    d4b8:	681b      	ldr	r3, [r3, #0]
    d4ba:	0c9a      	lsrs	r2, r3, #18
    d4bc:	9b01      	ldr	r3, [sp, #4]
    d4be:	605a      	str	r2, [r3, #4]
        msgBuff->time_stamp = (uint32)base->HR_TIME_STAMP[msgBuffIdx];
    }
    else
#endif /* EATURE_CAN_HAS_HR_TIMER */
    {
        msgBuff->time_stamp = (uint32)((msgBuff->cs & FLEXCAN_IP_CS_TIME_STAMP_MASK) >> FLEXCAN_IP_CS_TIME_STAMP_SHIFT);
    d4c0:	9b01      	ldr	r3, [sp, #4]
    d4c2:	681b      	ldr	r3, [r3, #0]
    d4c4:	b29a      	uxth	r2, r3
    d4c6:	9b01      	ldr	r3, [sp, #4]
    d4c8:	64da      	str	r2, [r3, #76]	; 0x4c
            FLEXCAN_IP_SWAP_BYTES_IN_WORD(MbWord, MsgBuff_Data_32[i >> 2U]);
        }
    }

#else  /* if (defined (CPU_S32K116) || defined (CPU_S32K118)) */
    for (i = 0U; i < (Payload_Size & ~3U); i += 4U)
    d4ca:	2300      	movs	r3, #0
    d4cc:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    d4d0:	e025      	b.n	d51e <FlexCAN_GetMsgBuff+0x102>
    {
        MbWord = Flexcan_Mb_Data_32[i >> 2U];
    d4d2:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
    d4d6:	089b      	lsrs	r3, r3, #2
    d4d8:	b2db      	uxtb	r3, r3
    d4da:	009b      	lsls	r3, r3, #2
    d4dc:	9a07      	ldr	r2, [sp, #28]
    d4de:	4413      	add	r3, r2
    d4e0:	681b      	ldr	r3, [r3, #0]
    d4e2:	9304      	str	r3, [sp, #16]
        FLEXCAN_IP_SWAP_BYTES_IN_WORD((MbWord), (MsgBuff_Data_32[i >> 2U]));
    d4e4:	9b04      	ldr	r3, [sp, #16]
    d4e6:	0e1a      	lsrs	r2, r3, #24
    d4e8:	9b04      	ldr	r3, [sp, #16]
    d4ea:	0a1b      	lsrs	r3, r3, #8
    d4ec:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    d4f0:	431a      	orrs	r2, r3
    d4f2:	9b04      	ldr	r3, [sp, #16]
    d4f4:	021b      	lsls	r3, r3, #8
    d4f6:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
    d4fa:	ea42 0103 	orr.w	r1, r2, r3
    d4fe:	9b04      	ldr	r3, [sp, #16]
    d500:	061a      	lsls	r2, r3, #24
    d502:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
    d506:	089b      	lsrs	r3, r3, #2
    d508:	b2db      	uxtb	r3, r3
    d50a:	009b      	lsls	r3, r3, #2
    d50c:	9806      	ldr	r0, [sp, #24]
    d50e:	4403      	add	r3, r0
    d510:	430a      	orrs	r2, r1
    d512:	601a      	str	r2, [r3, #0]
    for (i = 0U; i < (Payload_Size & ~3U); i += 4U)
    d514:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
    d518:	3304      	adds	r3, #4
    d51a:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    d51e:	f89d 202f 	ldrb.w	r2, [sp, #47]	; 0x2f
    d522:	f89d 302e 	ldrb.w	r3, [sp, #46]	; 0x2e
    d526:	f023 0303 	bic.w	r3, r3, #3
    d52a:	429a      	cmp	r2, r3
    d52c:	d3d1      	bcc.n	d4d2 <FlexCAN_GetMsgBuff+0xb6>
    }

#endif /* if (defined (CPU_S32K116) || defined (CPU_S32K118)) */
    for (; i < Payload_Size; i++)
    d52e:	e014      	b.n	d55a <FlexCAN_GetMsgBuff+0x13e>
    {   /* Max allowed value for index is 63 */
        msgBuff->data[i] = Flexcan_Mb_Data[FLEXCAN_IP_SWAP_BYTES_IN_WORD_INDEX(i)];
    d530:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
    d534:	f083 0303 	eor.w	r3, r3, #3
    d538:	b2db      	uxtb	r3, r3
    d53a:	461a      	mov	r2, r3
    d53c:	9b08      	ldr	r3, [sp, #32]
    d53e:	441a      	add	r2, r3
    d540:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
    d544:	7812      	ldrb	r2, [r2, #0]
    d546:	b2d1      	uxtb	r1, r2
    d548:	9a01      	ldr	r2, [sp, #4]
    d54a:	4413      	add	r3, r2
    d54c:	460a      	mov	r2, r1
    d54e:	721a      	strb	r2, [r3, #8]
    for (; i < Payload_Size; i++)
    d550:	f89d 302f 	ldrb.w	r3, [sp, #47]	; 0x2f
    d554:	3301      	adds	r3, #1
    d556:	f88d 302f 	strb.w	r3, [sp, #47]	; 0x2f
    d55a:	f89d 202f 	ldrb.w	r2, [sp, #47]	; 0x2f
    d55e:	f89d 302e 	ldrb.w	r3, [sp, #46]	; 0x2e
    d562:	429a      	cmp	r2, r3
    d564:	d3e4      	bcc.n	d530 <FlexCAN_GetMsgBuff+0x114>
    }
}
    d566:	bf00      	nop
    d568:	bf00      	nop
    d56a:	b00d      	add	sp, #52	; 0x34
    d56c:	f85d fb04 	ldr.w	pc, [sp], #4

0000d570 <FlexCAN_SetTxMsgBuff>:
                          const Flexcan_Ip_MsbuffCodeStatusType * cs,
                          uint32 msgId,
                          const uint8 * msgData,
                          const boolean isRemote
                         )
{
    d570:	b500      	push	{lr}
    d572:	b08d      	sub	sp, #52	; 0x34
    d574:	9003      	str	r0, [sp, #12]
    d576:	9102      	str	r1, [sp, #8]
    d578:	9201      	str	r2, [sp, #4]
    d57a:	9300      	str	r3, [sp, #0]
    uint32 Flexcan_Mb_Config = 0;
    d57c:	2300      	movs	r3, #0
    d57e:	930b      	str	r3, [sp, #44]	; 0x2c
    uint32 DataByte;
    uint8 Dlc_Value;
    uint8 Payload_Size;
    volatile uint32 * Flexcan_Mb = pMbAddr;
    d580:	9b03      	ldr	r3, [sp, #12]
    d582:	9309      	str	r3, [sp, #36]	; 0x24
    volatile uint32 * Flexcan_Mb_Id   = &Flexcan_Mb[1];
    d584:	9b09      	ldr	r3, [sp, #36]	; 0x24
    d586:	3304      	adds	r3, #4
    d588:	9308      	str	r3, [sp, #32]
    volatile uint8 * Flexcan_Mb_Data = (volatile uint8*)(&Flexcan_Mb[2]);
    d58a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    d58c:	3308      	adds	r3, #8
    d58e:	9307      	str	r3, [sp, #28]
    volatile uint32 * Flexcan_Mb_Data_32 = &Flexcan_Mb[2];
    d590:	9b09      	ldr	r3, [sp, #36]	; 0x24
    d592:	3308      	adds	r3, #8
    d594:	9306      	str	r3, [sp, #24]
    const uint32 * MsgData_32 = (const uint32*)msgData;
    d596:	9b00      	ldr	r3, [sp, #0]
    d598:	9305      	str	r3, [sp, #20]
    #if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
        DevAssert(cs != NULL_PTR);
    #endif

        /* Clean up the arbitration field area and set TxMB Inactive */
        *Flexcan_Mb = (uint32)((((uint32)FLEXCAN_TX_INACTIVE & (uint32)0x1F) << (uint8)FLEXCAN_IP_CS_CODE_SHIFT) & (uint32)FLEXCAN_IP_CS_CODE_MASK);
    d59a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    d59c:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
    d5a0:	601a      	str	r2, [r3, #0]
        *Flexcan_Mb_Id = 0;
    d5a2:	9b08      	ldr	r3, [sp, #32]
    d5a4:	2200      	movs	r2, #0
    d5a6:	601a      	str	r2, [r3, #0]

        /* Compute the value of the DLC field */
        Dlc_Value = FlexCAN_ComputeDLCValue((uint8)cs->dataLen);
    d5a8:	9b02      	ldr	r3, [sp, #8]
    d5aa:	689b      	ldr	r3, [r3, #8]
    d5ac:	b2db      	uxtb	r3, r3
    d5ae:	4618      	mov	r0, r3
    d5b0:	f7ff f9f4 	bl	c99c <FlexCAN_ComputeDLCValue>
    d5b4:	4603      	mov	r3, r0
    d5b6:	f88d 3013 	strb.w	r3, [sp, #19]
        /* Copy user's buffer into the message buffer data area */
        if (msgData != NULL_PTR)
    d5ba:	9b00      	ldr	r3, [sp, #0]
    d5bc:	2b00      	cmp	r3, #0
    d5be:	d065      	beq.n	d68c <FlexCAN_SetTxMsgBuff+0x11c>
        {
#if (defined(S32K116) || defined (S32K118))
            (void)MsgData_32;
            DataByte = FlexCAN_DataTransferTxMsgBuff(Flexcan_Mb_Data_32, cs, msgData);
#else
            for (DataByte = 0; DataByte < (cs->dataLen & ~3U); DataByte += 4U)
    d5c0:	2300      	movs	r3, #0
    d5c2:	930a      	str	r3, [sp, #40]	; 0x28
    d5c4:	e02c      	b.n	d620 <FlexCAN_SetTxMsgBuff+0xb0>
            {
                FLEXCAN_IP_SWAP_BYTES_IN_WORD((MsgData_32[DataByte >> 2U]), (Flexcan_Mb_Data_32[DataByte >> 2U]));
    d5c6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    d5c8:	089b      	lsrs	r3, r3, #2
    d5ca:	009b      	lsls	r3, r3, #2
    d5cc:	9a05      	ldr	r2, [sp, #20]
    d5ce:	4413      	add	r3, r2
    d5d0:	681b      	ldr	r3, [r3, #0]
    d5d2:	0e1a      	lsrs	r2, r3, #24
    d5d4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    d5d6:	089b      	lsrs	r3, r3, #2
    d5d8:	009b      	lsls	r3, r3, #2
    d5da:	9905      	ldr	r1, [sp, #20]
    d5dc:	440b      	add	r3, r1
    d5de:	681b      	ldr	r3, [r3, #0]
    d5e0:	0a1b      	lsrs	r3, r3, #8
    d5e2:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    d5e6:	431a      	orrs	r2, r3
    d5e8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    d5ea:	089b      	lsrs	r3, r3, #2
    d5ec:	009b      	lsls	r3, r3, #2
    d5ee:	9905      	ldr	r1, [sp, #20]
    d5f0:	440b      	add	r3, r1
    d5f2:	681b      	ldr	r3, [r3, #0]
    d5f4:	021b      	lsls	r3, r3, #8
    d5f6:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
    d5fa:	ea42 0103 	orr.w	r1, r2, r3
    d5fe:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    d600:	089b      	lsrs	r3, r3, #2
    d602:	009b      	lsls	r3, r3, #2
    d604:	9a05      	ldr	r2, [sp, #20]
    d606:	4413      	add	r3, r2
    d608:	681b      	ldr	r3, [r3, #0]
    d60a:	061a      	lsls	r2, r3, #24
    d60c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    d60e:	089b      	lsrs	r3, r3, #2
    d610:	009b      	lsls	r3, r3, #2
    d612:	9806      	ldr	r0, [sp, #24]
    d614:	4403      	add	r3, r0
    d616:	430a      	orrs	r2, r1
    d618:	601a      	str	r2, [r3, #0]
            for (DataByte = 0; DataByte < (cs->dataLen & ~3U); DataByte += 4U)
    d61a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    d61c:	3304      	adds	r3, #4
    d61e:	930a      	str	r3, [sp, #40]	; 0x28
    d620:	9b02      	ldr	r3, [sp, #8]
    d622:	689b      	ldr	r3, [r3, #8]
    d624:	f023 0303 	bic.w	r3, r3, #3
    d628:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    d62a:	429a      	cmp	r2, r3
    d62c:	d3cb      	bcc.n	d5c6 <FlexCAN_SetTxMsgBuff+0x56>
            }
#endif /* (defined(S32K116) || defined (S32K118)) */
            for ( ; DataByte < cs->dataLen; DataByte++)
    d62e:	e00c      	b.n	d64a <FlexCAN_SetTxMsgBuff+0xda>
            {
                Flexcan_Mb_Data[FLEXCAN_IP_SWAP_BYTES_IN_WORD_INDEX(DataByte)] =  msgData[DataByte];
    d630:	9a00      	ldr	r2, [sp, #0]
    d632:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    d634:	441a      	add	r2, r3
    d636:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    d638:	f083 0303 	eor.w	r3, r3, #3
    d63c:	9907      	ldr	r1, [sp, #28]
    d63e:	440b      	add	r3, r1
    d640:	7812      	ldrb	r2, [r2, #0]
    d642:	701a      	strb	r2, [r3, #0]
            for ( ; DataByte < cs->dataLen; DataByte++)
    d644:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    d646:	3301      	adds	r3, #1
    d648:	930a      	str	r3, [sp, #40]	; 0x28
    d64a:	9b02      	ldr	r3, [sp, #8]
    d64c:	689b      	ldr	r3, [r3, #8]
    d64e:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    d650:	429a      	cmp	r2, r3
    d652:	d3ed      	bcc.n	d630 <FlexCAN_SetTxMsgBuff+0xc0>
            }
        #if (FLEXCAN_IP_FEATURE_HAS_FD == STD_ON)
            Payload_Size = FlexCAN_ComputePayloadSize(Dlc_Value);
    d654:	f89d 3013 	ldrb.w	r3, [sp, #19]
    d658:	4618      	mov	r0, r3
    d65a:	f7ff f9ee 	bl	ca3a <FlexCAN_ComputePayloadSize>
    d65e:	4603      	mov	r3, r0
    d660:	f88d 3012 	strb.w	r3, [sp, #18]
            /* Add padding, if needed */
            for (DataByte = cs->dataLen; DataByte < Payload_Size; DataByte++)
    d664:	9b02      	ldr	r3, [sp, #8]
    d666:	689b      	ldr	r3, [r3, #8]
    d668:	930a      	str	r3, [sp, #40]	; 0x28
    d66a:	e00a      	b.n	d682 <FlexCAN_SetTxMsgBuff+0x112>
            {
                Flexcan_Mb_Data[FLEXCAN_IP_SWAP_BYTES_IN_WORD_INDEX(DataByte)] = cs->fd_padding;
    d66c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    d66e:	f083 0303 	eor.w	r3, r3, #3
    d672:	9a07      	ldr	r2, [sp, #28]
    d674:	4413      	add	r3, r2
    d676:	9a02      	ldr	r2, [sp, #8]
    d678:	7b52      	ldrb	r2, [r2, #13]
    d67a:	701a      	strb	r2, [r3, #0]
            for (DataByte = cs->dataLen; DataByte < Payload_Size; DataByte++)
    d67c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    d67e:	3301      	adds	r3, #1
    d680:	930a      	str	r3, [sp, #40]	; 0x28
    d682:	f89d 3012 	ldrb.w	r3, [sp, #18]
    d686:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    d688:	429a      	cmp	r2, r3
    d68a:	d3ef      	bcc.n	d66c <FlexCAN_SetTxMsgBuff+0xfc>
            }
        #endif /* FLEXCAN_IP_FEATURE_HAS_FD */
        }
        /* Set the ID according the format structure */
        if (FLEXCAN_MSG_ID_EXT == cs->msgIdType)
    d68c:	9b02      	ldr	r3, [sp, #8]
    d68e:	685b      	ldr	r3, [r3, #4]
    d690:	2b01      	cmp	r3, #1
    d692:	d111      	bne.n	d6b8 <FlexCAN_SetTxMsgBuff+0x148>
        {
            /* ID [28-0] */
            *Flexcan_Mb_Id &= ~(FLEXCAN_IP_ID_STD_MASK | FLEXCAN_IP_ID_EXT_MASK);
    d694:	9b08      	ldr	r3, [sp, #32]
    d696:	681b      	ldr	r3, [r3, #0]
    d698:	f003 4260 	and.w	r2, r3, #3758096384	; 0xe0000000
    d69c:	9b08      	ldr	r3, [sp, #32]
    d69e:	601a      	str	r2, [r3, #0]
            *Flexcan_Mb_Id |= (msgId & (FLEXCAN_IP_ID_STD_MASK | FLEXCAN_IP_ID_EXT_MASK));
    d6a0:	9b08      	ldr	r3, [sp, #32]
    d6a2:	681a      	ldr	r2, [r3, #0]
    d6a4:	9b01      	ldr	r3, [sp, #4]
    d6a6:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
    d6aa:	431a      	orrs	r2, r3
    d6ac:	9b08      	ldr	r3, [sp, #32]
    d6ae:	601a      	str	r2, [r3, #0]
            /* Set IDE and SRR bit*/
            Flexcan_Mb_Config |= (FLEXCAN_IP_CS_IDE_MASK | FLEXCAN_IP_CS_SRR_MASK);
    d6b0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d6b2:	f443 03c0 	orr.w	r3, r3, #6291456	; 0x600000
    d6b6:	930b      	str	r3, [sp, #44]	; 0x2c
        }
        if (FLEXCAN_MSG_ID_STD == cs->msgIdType)
    d6b8:	9b02      	ldr	r3, [sp, #8]
    d6ba:	685b      	ldr	r3, [r3, #4]
    d6bc:	2b00      	cmp	r3, #0
    d6be:	d114      	bne.n	d6ea <FlexCAN_SetTxMsgBuff+0x17a>
        {
            /* ID[28-18] */
            *Flexcan_Mb_Id &= ~FLEXCAN_IP_ID_STD_MASK;
    d6c0:	9b08      	ldr	r3, [sp, #32]
    d6c2:	681b      	ldr	r3, [r3, #0]
    d6c4:	f023 53ff 	bic.w	r3, r3, #534773760	; 0x1fe00000
    d6c8:	f423 13e0 	bic.w	r3, r3, #1835008	; 0x1c0000
    d6cc:	9a08      	ldr	r2, [sp, #32]
    d6ce:	6013      	str	r3, [r2, #0]
            *Flexcan_Mb_Id |= (msgId << FLEXCAN_IP_ID_STD_SHIFT) & FLEXCAN_IP_ID_STD_MASK;
    d6d0:	9b08      	ldr	r3, [sp, #32]
    d6d2:	681a      	ldr	r2, [r3, #0]
    d6d4:	9b01      	ldr	r3, [sp, #4]
    d6d6:	0499      	lsls	r1, r3, #18
    d6d8:	4b2b      	ldr	r3, [pc, #172]	; (d788 <FlexCAN_SetTxMsgBuff+0x218>)
    d6da:	400b      	ands	r3, r1
    d6dc:	431a      	orrs	r2, r3
    d6de:	9b08      	ldr	r3, [sp, #32]
    d6e0:	601a      	str	r2, [r3, #0]
            /* make sure IDE and SRR are not set */
            Flexcan_Mb_Config &= ~(FLEXCAN_IP_CS_IDE_MASK | FLEXCAN_IP_CS_SRR_MASK);
    d6e2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d6e4:	f423 03c0 	bic.w	r3, r3, #6291456	; 0x600000
    d6e8:	930b      	str	r3, [sp, #44]	; 0x2c
        }
        /* Set the length of data in bytes */
        Flexcan_Mb_Config &= ~FLEXCAN_IP_CS_DLC_MASK;
    d6ea:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d6ec:	f423 2370 	bic.w	r3, r3, #983040	; 0xf0000
    d6f0:	930b      	str	r3, [sp, #44]	; 0x2c
        Flexcan_Mb_Config |= ((uint32)Dlc_Value << FLEXCAN_IP_CS_DLC_SHIFT) & FLEXCAN_IP_CS_DLC_MASK;
    d6f2:	f89d 3013 	ldrb.w	r3, [sp, #19]
    d6f6:	041b      	lsls	r3, r3, #16
    d6f8:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
    d6fc:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    d6fe:	4313      	orrs	r3, r2
    d700:	930b      	str	r3, [sp, #44]	; 0x2c
        /* Set MB CODE */
        if (cs->code != (uint32)FLEXCAN_TX_NOT_USED)
    d702:	9b02      	ldr	r3, [sp, #8]
    d704:	681b      	ldr	r3, [r3, #0]
    d706:	2b0f      	cmp	r3, #15
    d708:	d03a      	beq.n	d780 <FlexCAN_SetTxMsgBuff+0x210>
        {
            if ((uint32)FLEXCAN_TX_REMOTE == cs->code)
    d70a:	9b02      	ldr	r3, [sp, #8]
    d70c:	681b      	ldr	r3, [r3, #0]
    d70e:	2b1c      	cmp	r3, #28
    d710:	d104      	bne.n	d71c <FlexCAN_SetTxMsgBuff+0x1ac>
            {
                /* Set RTR bit */
                Flexcan_Mb_Config |= FLEXCAN_IP_CS_RTR_MASK;
    d712:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d714:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    d718:	930b      	str	r3, [sp, #44]	; 0x2c
    d71a:	e007      	b.n	d72c <FlexCAN_SetTxMsgBuff+0x1bc>
            }
            else
            {
                if (TRUE == isRemote)
    d71c:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
    d720:	2b00      	cmp	r3, #0
    d722:	d003      	beq.n	d72c <FlexCAN_SetTxMsgBuff+0x1bc>
                {
                    /* Set RTR bit */
                    Flexcan_Mb_Config |= FLEXCAN_IP_CS_RTR_MASK;
    d724:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d726:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
    d72a:	930b      	str	r3, [sp, #44]	; 0x2c
                }
            }
            /* Reset the code */
            Flexcan_Mb_Config &= ~FLEXCAN_IP_CS_CODE_MASK;
    d72c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d72e:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
    d732:	930b      	str	r3, [sp, #44]	; 0x2c
            /* Set the code */
            if (cs->fd_enable)
    d734:	9b02      	ldr	r3, [sp, #8]
    d736:	7b1b      	ldrb	r3, [r3, #12]
    d738:	2b00      	cmp	r3, #0
    d73a:	d00e      	beq.n	d75a <FlexCAN_SetTxMsgBuff+0x1ea>
            {
                Flexcan_Mb_Config |= ((cs->code << FLEXCAN_IP_CS_CODE_SHIFT) & FLEXCAN_IP_CS_CODE_MASK) | FLEXCAN_IP_MB_EDL_MASK;
    d73c:	9b02      	ldr	r3, [sp, #8]
    d73e:	681b      	ldr	r3, [r3, #0]
    d740:	061b      	lsls	r3, r3, #24
    d742:	f003 6270 	and.w	r2, r3, #251658240	; 0xf000000
    d746:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d748:	4313      	orrs	r3, r2
    d74a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
    d74e:	930b      	str	r3, [sp, #44]	; 0x2c
                /* In case of FD frame not supported RTR */
                Flexcan_Mb_Config &= ~FLEXCAN_IP_CS_RTR_MASK;
    d750:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d752:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
    d756:	930b      	str	r3, [sp, #44]	; 0x2c
    d758:	e007      	b.n	d76a <FlexCAN_SetTxMsgBuff+0x1fa>
            }
            else
            {
                Flexcan_Mb_Config |= (cs->code << FLEXCAN_IP_CS_CODE_SHIFT) & FLEXCAN_IP_CS_CODE_MASK;
    d75a:	9b02      	ldr	r3, [sp, #8]
    d75c:	681b      	ldr	r3, [r3, #0]
    d75e:	061b      	lsls	r3, r3, #24
    d760:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
    d764:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    d766:	4313      	orrs	r3, r2
    d768:	930b      	str	r3, [sp, #44]	; 0x2c
            }

            if (cs->enable_brs)
    d76a:	9b02      	ldr	r3, [sp, #8]
    d76c:	7b9b      	ldrb	r3, [r3, #14]
    d76e:	2b00      	cmp	r3, #0
    d770:	d003      	beq.n	d77a <FlexCAN_SetTxMsgBuff+0x20a>
            {
                Flexcan_Mb_Config |= FLEXCAN_IP_MB_BRS_MASK;
    d772:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d774:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    d778:	930b      	str	r3, [sp, #44]	; 0x2c
            }
            *Flexcan_Mb = Flexcan_Mb_Config;
    d77a:	9b09      	ldr	r3, [sp, #36]	; 0x24
    d77c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    d77e:	601a      	str	r2, [r3, #0]
        }
}
    d780:	bf00      	nop
    d782:	b00d      	add	sp, #52	; 0x34
    d784:	f85d fb04 	ldr.w	pc, [sp], #4
    d788:	1ffc0000 	.word	0x1ffc0000

0000d78c <FlexCAN_SetMaxMsgBuffNum>:
 * Description   : Set the number of the last Message Buffers.
 * This function will define the number of the last Message Buffers
 *
 *END***************************************************************************/
Flexcan_Ip_StatusType FlexCAN_SetMaxMsgBuffNum(FLEXCAN_Type * base, uint32 maxMsgBuffNum)
{
    d78c:	b500      	push	{lr}
    d78e:	b08f      	sub	sp, #60	; 0x3c
    d790:	9001      	str	r0, [sp, #4]
    d792:	9100      	str	r1, [sp, #0]
    uint32 MsgBuffIdx;
    uint32 DataByte;
    const volatile uint32 * RAM = (uint32*)((Flexcan_Ip_PtrSizeType)base + (uint32)FLEXCAN_IP_FEATURE_RAM_OFFSET);
    d794:	9b01      	ldr	r3, [sp, #4]
    d796:	3380      	adds	r3, #128	; 0x80
    d798:	930a      	str	r3, [sp, #40]	; 0x28
#if (STD_ON == FLEXCAN_IP_FEATURE_HAS_EXPANDABLE_MEMORY)
    const volatile uint32 * RAM_EXPANDED = (uint32*)((Flexcan_Ip_PtrSizeType)base + (uint32)FLEXCAN_IP_FEATURE_EXP_RAM_OFFSET);
#endif /* FLEXCAN_IP_FEATURE_HAS_EXPANDABLE_MEMORY */
    const volatile uint32 * ValEndMbPointer = NULL_PTR;
    d79a:	2300      	movs	r3, #0
    d79c:	9309      	str	r3, [sp, #36]	; 0x24
    volatile uint32 *Flexcan_Mb = NULL_PTR;
    d79e:	2300      	movs	r3, #0
    d7a0:	9308      	str	r3, [sp, #32]
    volatile uint32 *Flexcan_Mb_Id   = NULL_PTR ;
    d7a2:	2300      	movs	r3, #0
    d7a4:	9307      	str	r3, [sp, #28]
    volatile uint8  *Flexcan_Mb_Data = NULL_PTR;
    d7a6:	2300      	movs	r3, #0
    d7a8:	9306      	str	r3, [sp, #24]
    uint8 Arbitration_Field_Size = 8U;
    d7aa:	2308      	movs	r3, #8
    d7ac:	f88d 3017 	strb.w	r3, [sp, #23]
    uint8 Can_Real_Payload = FlexCAN_GetMbPayloadSize(base, maxMsgBuffNum - (uint32)1U);
    d7b0:	9b00      	ldr	r3, [sp, #0]
    d7b2:	3b01      	subs	r3, #1
    d7b4:	4619      	mov	r1, r3
    d7b6:	9801      	ldr	r0, [sp, #4]
    d7b8:	f7ff fcb6 	bl	d128 <FlexCAN_GetMbPayloadSize>
    d7bc:	4603      	mov	r3, r0
    d7be:	f88d 3016 	strb.w	r3, [sp, #22]
    Flexcan_Ip_PtrSizeType ValEndMb = 0U;
    d7c2:	2300      	movs	r3, #0
    d7c4:	9304      	str	r3, [sp, #16]
    Flexcan_Ip_PtrSizeType ValEndRam = 0U;
    d7c6:	2300      	movs	r3, #0
    d7c8:	9303      	str	r3, [sp, #12]
    Flexcan_Ip_StatusType Status = FLEXCAN_STATUS_SUCCESS;
    d7ca:	2300      	movs	r3, #0
    d7cc:	930b      	str	r3, [sp, #44]	; 0x2c

    #if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
        DevAssert(maxMsgBuffNum>0U);
    #endif

    ValEndMbPointer = FlexCAN_GetMsgBuffRegion(base, (maxMsgBuffNum - (uint32)1U));
    d7ce:	9b00      	ldr	r3, [sp, #0]
    d7d0:	3b01      	subs	r3, #1
    d7d2:	4619      	mov	r1, r3
    d7d4:	9801      	ldr	r0, [sp, #4]
    d7d6:	f7ff f979 	bl	cacc <FlexCAN_GetMsgBuffRegion>
    d7da:	9009      	str	r0, [sp, #36]	; 0x24

    ValEndMb = (Flexcan_Ip_PtrSizeType)ValEndMbPointer + Can_Real_Payload + Arbitration_Field_Size;
    d7dc:	f89d 2016 	ldrb.w	r2, [sp, #22]
    d7e0:	9b09      	ldr	r3, [sp, #36]	; 0x24
    d7e2:	441a      	add	r2, r3
    d7e4:	f89d 3017 	ldrb.w	r3, [sp, #23]
    d7e8:	4413      	add	r3, r2
    d7ea:	9304      	str	r3, [sp, #16]
    else
    {
        ValEndRam = (Flexcan_Ip_PtrSizeType)&RAM[(FlexCAN_GetMaxMbNum(base) * 4U)];
    }
#else
    ValEndRam = (Flexcan_Ip_PtrSizeType)&RAM[(FlexCAN_GetMaxMbNum(base) * 4U)];
    d7ec:	9801      	ldr	r0, [sp, #4]
    d7ee:	f7ff f9e7 	bl	cbc0 <FlexCAN_GetMaxMbNum>
    d7f2:	4603      	mov	r3, r0
    d7f4:	011b      	lsls	r3, r3, #4
    d7f6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    d7f8:	4413      	add	r3, r2
    d7fa:	9303      	str	r3, [sp, #12]
#endif /* FLEXCAN_IP_FEATURE_HAS_EXPANDABLE_MEMORY */

    if ((ValEndMb > ValEndRam) || (maxMsgBuffNum > FlexCAN_GetMaxMbNum(base)))
    d7fc:	9a04      	ldr	r2, [sp, #16]
    d7fe:	9b03      	ldr	r3, [sp, #12]
    d800:	429a      	cmp	r2, r3
    d802:	d806      	bhi.n	d812 <FlexCAN_SetMaxMsgBuffNum+0x86>
    d804:	9801      	ldr	r0, [sp, #4]
    d806:	f7ff f9db 	bl	cbc0 <FlexCAN_GetMaxMbNum>
    d80a:	4602      	mov	r2, r0
    d80c:	9b00      	ldr	r3, [sp, #0]
    d80e:	4293      	cmp	r3, r2
    d810:	d901      	bls.n	d816 <FlexCAN_SetMaxMsgBuffNum+0x8a>
    {
        Status = FLEXCAN_STATUS_BUFF_OUT_OF_RANGE;
    d812:	2304      	movs	r3, #4
    d814:	930b      	str	r3, [sp, #44]	; 0x2c
    }

    if (FLEXCAN_STATUS_SUCCESS == Status)
    d816:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d818:	2b00      	cmp	r3, #0
    d81a:	d142      	bne.n	d8a2 <FlexCAN_SetMaxMsgBuffNum+0x116>
    {
        /* Set the maximum number of MBs*/
        base->MCR = (base->MCR & ~FLEXCAN_MCR_MAXMB_MASK) | (((maxMsgBuffNum-1U) << FLEXCAN_MCR_MAXMB_SHIFT) & FLEXCAN_MCR_MAXMB_MASK);
    d81c:	9b01      	ldr	r3, [sp, #4]
    d81e:	681b      	ldr	r3, [r3, #0]
    d820:	f023 027f 	bic.w	r2, r3, #127	; 0x7f
    d824:	9b00      	ldr	r3, [sp, #0]
    d826:	3b01      	subs	r3, #1
    d828:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    d82c:	431a      	orrs	r2, r3
    d82e:	9b01      	ldr	r3, [sp, #4]
    d830:	601a      	str	r2, [r3, #0]
        if (!(((base->MCR & FLEXCAN_MCR_RFEN_MASK) >> FLEXCAN_MCR_RFEN_SHIFT) != 0U))
    d832:	9b01      	ldr	r3, [sp, #4]
    d834:	681b      	ldr	r3, [r3, #0]
    d836:	f003 5300 	and.w	r3, r3, #536870912	; 0x20000000
    d83a:	2b00      	cmp	r3, #0
    d83c:	d131      	bne.n	d8a2 <FlexCAN_SetMaxMsgBuffNum+0x116>
        {
            /* Initialize all message buffers as inactive */
            for (MsgBuffIdx = 0; MsgBuffIdx < maxMsgBuffNum; MsgBuffIdx++)
    d83e:	2300      	movs	r3, #0
    d840:	930d      	str	r3, [sp, #52]	; 0x34
    d842:	e02a      	b.n	d89a <FlexCAN_SetMaxMsgBuffNum+0x10e>
            {
                Flexcan_Mb = FlexCAN_GetMsgBuffRegion(base, MsgBuffIdx);
    d844:	990d      	ldr	r1, [sp, #52]	; 0x34
    d846:	9801      	ldr	r0, [sp, #4]
    d848:	f7ff f940 	bl	cacc <FlexCAN_GetMsgBuffRegion>
    d84c:	9008      	str	r0, [sp, #32]
                Flexcan_Mb_Id   = &Flexcan_Mb[1];
    d84e:	9b08      	ldr	r3, [sp, #32]
    d850:	3304      	adds	r3, #4
    d852:	9307      	str	r3, [sp, #28]
                Flexcan_Mb_Data = (volatile uint8*)(&Flexcan_Mb[2]);
    d854:	9b08      	ldr	r3, [sp, #32]
    d856:	3308      	adds	r3, #8
    d858:	9306      	str	r3, [sp, #24]
                *Flexcan_Mb = 0x0U;
    d85a:	9b08      	ldr	r3, [sp, #32]
    d85c:	2200      	movs	r2, #0
    d85e:	601a      	str	r2, [r3, #0]
                *Flexcan_Mb_Id = 0x0U;
    d860:	9b07      	ldr	r3, [sp, #28]
    d862:	2200      	movs	r2, #0
    d864:	601a      	str	r2, [r3, #0]
                Can_Real_Payload = FlexCAN_GetMbPayloadSize(base, MsgBuffIdx);
    d866:	990d      	ldr	r1, [sp, #52]	; 0x34
    d868:	9801      	ldr	r0, [sp, #4]
    d86a:	f7ff fc5d 	bl	d128 <FlexCAN_GetMbPayloadSize>
    d86e:	4603      	mov	r3, r0
    d870:	f88d 3016 	strb.w	r3, [sp, #22]
                for (DataByte = 0; DataByte < Can_Real_Payload; DataByte++)
    d874:	2300      	movs	r3, #0
    d876:	930c      	str	r3, [sp, #48]	; 0x30
    d878:	e007      	b.n	d88a <FlexCAN_SetMaxMsgBuffNum+0xfe>
                {
                   Flexcan_Mb_Data[DataByte] = 0x0U;
    d87a:	9a06      	ldr	r2, [sp, #24]
    d87c:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    d87e:	4413      	add	r3, r2
    d880:	2200      	movs	r2, #0
    d882:	701a      	strb	r2, [r3, #0]
                for (DataByte = 0; DataByte < Can_Real_Payload; DataByte++)
    d884:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    d886:	3301      	adds	r3, #1
    d888:	930c      	str	r3, [sp, #48]	; 0x30
    d88a:	f89d 3016 	ldrb.w	r3, [sp, #22]
    d88e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    d890:	429a      	cmp	r2, r3
    d892:	d3f2      	bcc.n	d87a <FlexCAN_SetMaxMsgBuffNum+0xee>
            for (MsgBuffIdx = 0; MsgBuffIdx < maxMsgBuffNum; MsgBuffIdx++)
    d894:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    d896:	3301      	adds	r3, #1
    d898:	930d      	str	r3, [sp, #52]	; 0x34
    d89a:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    d89c:	9b00      	ldr	r3, [sp, #0]
    d89e:	429a      	cmp	r2, r3
    d8a0:	d3d0      	bcc.n	d844 <FlexCAN_SetMaxMsgBuffNum+0xb8>
                }
            }
        }
    }
    return Status;
    d8a2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
}
    d8a4:	4618      	mov	r0, r3
    d8a6:	b00f      	add	sp, #60	; 0x3c
    d8a8:	f85d fb04 	ldr.w	pc, [sp], #4

0000d8ac <FlexCAN_SetOperationMode>:
 * Description   : Enable a FlexCAN operation mode.
 * This function will enable one of the modes listed in flexcan_operation_modes_t.
 *
 *END**************************************************************************/
void FlexCAN_SetOperationMode(FLEXCAN_Type * base, Flexcan_Ip_ModesType mode)
{
    d8ac:	b500      	push	{lr}
    d8ae:	b083      	sub	sp, #12
    d8b0:	9001      	str	r0, [sp, #4]
    d8b2:	9100      	str	r1, [sp, #0]
    switch (mode)
    d8b4:	9b00      	ldr	r3, [sp, #0]
    d8b6:	2b02      	cmp	r3, #2
    d8b8:	d01d      	beq.n	d8f6 <FlexCAN_SetOperationMode+0x4a>
    d8ba:	9b00      	ldr	r3, [sp, #0]
    d8bc:	2b02      	cmp	r3, #2
    d8be:	d82b      	bhi.n	d918 <FlexCAN_SetOperationMode+0x6c>
    d8c0:	9b00      	ldr	r3, [sp, #0]
    d8c2:	2b00      	cmp	r3, #0
    d8c4:	d003      	beq.n	d8ce <FlexCAN_SetOperationMode+0x22>
    d8c6:	9b00      	ldr	r3, [sp, #0]
    d8c8:	2b01      	cmp	r3, #1
    d8ca:	d00d      	beq.n	d8e8 <FlexCAN_SetOperationMode+0x3c>
            /* Enable Self Reception */
            FlexCAN_SetSelfReception(base, TRUE);
            break;
        default:
            /* Should not get here */
            break;
    d8cc:	e024      	b.n	d918 <FlexCAN_SetOperationMode+0x6c>
            base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_LOM_MASK) | FLEXCAN_CTRL1_LOM(0U);
    d8ce:	9b01      	ldr	r3, [sp, #4]
    d8d0:	685b      	ldr	r3, [r3, #4]
    d8d2:	f023 0208 	bic.w	r2, r3, #8
    d8d6:	9b01      	ldr	r3, [sp, #4]
    d8d8:	605a      	str	r2, [r3, #4]
            base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_LPB_MASK) | FLEXCAN_CTRL1_LPB(0U);
    d8da:	9b01      	ldr	r3, [sp, #4]
    d8dc:	685b      	ldr	r3, [r3, #4]
    d8de:	f423 5280 	bic.w	r2, r3, #4096	; 0x1000
    d8e2:	9b01      	ldr	r3, [sp, #4]
    d8e4:	605a      	str	r2, [r3, #4]
            break;
    d8e6:	e018      	b.n	d91a <FlexCAN_SetOperationMode+0x6e>
            base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_LOM_MASK) | FLEXCAN_CTRL1_LOM(1U);
    d8e8:	9b01      	ldr	r3, [sp, #4]
    d8ea:	685b      	ldr	r3, [r3, #4]
    d8ec:	f043 0208 	orr.w	r2, r3, #8
    d8f0:	9b01      	ldr	r3, [sp, #4]
    d8f2:	605a      	str	r2, [r3, #4]
            break;
    d8f4:	e011      	b.n	d91a <FlexCAN_SetOperationMode+0x6e>
            base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_LPB_MASK) | FLEXCAN_CTRL1_LPB(1U);
    d8f6:	9b01      	ldr	r3, [sp, #4]
    d8f8:	685b      	ldr	r3, [r3, #4]
    d8fa:	f443 5280 	orr.w	r2, r3, #4096	; 0x1000
    d8fe:	9b01      	ldr	r3, [sp, #4]
    d900:	605a      	str	r2, [r3, #4]
            base->CTRL1 = (base->CTRL1 & ~FLEXCAN_CTRL1_LOM_MASK) | FLEXCAN_CTRL1_LOM(0U);
    d902:	9b01      	ldr	r3, [sp, #4]
    d904:	685b      	ldr	r3, [r3, #4]
    d906:	f023 0208 	bic.w	r2, r3, #8
    d90a:	9b01      	ldr	r3, [sp, #4]
    d90c:	605a      	str	r2, [r3, #4]
            FlexCAN_SetSelfReception(base, TRUE);
    d90e:	2101      	movs	r1, #1
    d910:	9801      	ldr	r0, [sp, #4]
    d912:	f7fe ff7f 	bl	c814 <FlexCAN_SetSelfReception>
            break;
    d916:	e000      	b.n	d91a <FlexCAN_SetOperationMode+0x6e>
            break;
    d918:	bf00      	nop
    }
}
    d91a:	bf00      	nop
    d91c:	b003      	add	sp, #12
    d91e:	f85d fb04 	ldr.w	pc, [sp], #4

0000d922 <FlexCAN_SetRxFifoFilter>:
 *END**************************************************************************/
void FlexCAN_SetRxFifoFilter(FLEXCAN_Type * base,
                             Flexcan_Ip_RxFifoIdElementFormatType idFormat,
                             const Flexcan_Ip_IdTableType * idFilterTable
                            )
{
    d922:	b500      	push	{lr}
    d924:	b08d      	sub	sp, #52	; 0x34
    d926:	9003      	str	r0, [sp, #12]
    d928:	9102      	str	r1, [sp, #8]
    d92a:	9201      	str	r2, [sp, #4]

    /* Set RX FIFO ID filter table elements*/
    uint32 i, j, NumOfFilters;
    uint32 Val1 = 0UL, Val2 = 0UL, Val = 0UL;
    d92c:	2300      	movs	r3, #0
    d92e:	9309      	str	r3, [sp, #36]	; 0x24
    d930:	2300      	movs	r3, #0
    d932:	9308      	str	r3, [sp, #32]
    d934:	2300      	movs	r3, #0
    d936:	9307      	str	r3, [sp, #28]
    volatile uint32 * FilterTable = (uint32 *)((Flexcan_Ip_PtrSizeType)base + (uint32)FLEXCAN_IP_RX_FIFO_FILTER_TABLE_OFFSET);
    d938:	9b03      	ldr	r3, [sp, #12]
    d93a:	33e0      	adds	r3, #224	; 0xe0
    d93c:	9306      	str	r3, [sp, #24]

    #if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
        DevAssert((idFilterTable != NULL_PTR) || (FLEXCAN_RX_FIFO_ID_FORMAT_D == idFormat));
    #endif

    NumOfFilters = (((base->CTRL2) & FLEXCAN_CTRL2_RFFN_MASK) >> FLEXCAN_CTRL2_RFFN_SHIFT);
    d93e:	9b03      	ldr	r3, [sp, #12]
    d940:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    d942:	0e1b      	lsrs	r3, r3, #24
    d944:	f003 030f 	and.w	r3, r3, #15
    d948:	9305      	str	r3, [sp, #20]
    d94a:	9b02      	ldr	r3, [sp, #8]
    d94c:	2b03      	cmp	r3, #3
    d94e:	f200 81e7 	bhi.w	dd20 <FlexCAN_SetRxFifoFilter+0x3fe>
    d952:	a201      	add	r2, pc, #4	; (adr r2, d958 <FlexCAN_SetRxFifoFilter+0x36>)
    d954:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
    d958:	0000d969 	.word	0x0000d969
    d95c:	0000da03 	.word	0x0000da03
    d960:	0000db3d 	.word	0x0000db3d
    d964:	0000dd0b 	.word	0x0000dd0b
    switch (idFormat)
    {
        case (FLEXCAN_RX_FIFO_ID_FORMAT_A):
            /* Start critical section: implementation depends on integrator */
            SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    d968:	f004 ff18 	bl	1279c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            /* One full ID (standard and extended) per ID Filter Table element.*/
            (base->MCR) =
                (((base->MCR) & ~(FLEXCAN_MCR_IDAM_MASK)) |
    d96c:	9b03      	ldr	r3, [sp, #12]
    d96e:	681b      	ldr	r3, [r3, #0]
    d970:	f423 7240 	bic.w	r2, r3, #768	; 0x300
            (base->MCR) =
    d974:	9b03      	ldr	r3, [sp, #12]
    d976:	601a      	str	r2, [r3, #0]
                 ((((uint32)(((uint32)(FLEXCAN_RX_FIFO_ID_FORMAT_A)) << FLEXCAN_MCR_IDAM_SHIFT)) & FLEXCAN_MCR_IDAM_MASK)));
            /* End critical section: implementation depends on integrator */
            SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    d978:	f004 ff3c 	bl	127f4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            for (i = 0U; i < FLEXCAN_IP_RXFIFO_FILTER_ELEM_NUM(NumOfFilters); i++)
    d97c:	2300      	movs	r3, #0
    d97e:	930b      	str	r3, [sp, #44]	; 0x2c
    d980:	e038      	b.n	d9f4 <FlexCAN_SetRxFifoFilter+0xd2>
            {
                Val = 0UL;
    d982:	2300      	movs	r3, #0
    d984:	9307      	str	r3, [sp, #28]

                if (idFilterTable[i].isRemoteFrame)
    d986:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d988:	00db      	lsls	r3, r3, #3
    d98a:	9a01      	ldr	r2, [sp, #4]
    d98c:	4413      	add	r3, r2
    d98e:	781b      	ldrb	r3, [r3, #0]
    d990:	2b00      	cmp	r3, #0
    d992:	d002      	beq.n	d99a <FlexCAN_SetRxFifoFilter+0x78>
                {
                    Val = FLEXCAN_IP_RX_FIFO_ACCEPT_REMOTE_FRAME << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATAB_RTR_SHIFT;
    d994:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
    d998:	9307      	str	r3, [sp, #28]
                }

                if (idFilterTable[i].isExtendedFrame)
    d99a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d99c:	00db      	lsls	r3, r3, #3
    d99e:	9a01      	ldr	r2, [sp, #4]
    d9a0:	4413      	add	r3, r2
    d9a2:	785b      	ldrb	r3, [r3, #1]
    d9a4:	2b00      	cmp	r3, #0
    d9a6:	d013      	beq.n	d9d0 <FlexCAN_SetRxFifoFilter+0xae>
                {
                    Val |= FLEXCAN_IP_RX_FIFO_ACCEPT_EXT_FRAME << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATAB_IDE_SHIFT;
    d9a8:	9b07      	ldr	r3, [sp, #28]
    d9aa:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    d9ae:	9307      	str	r3, [sp, #28]
                    FilterTable[i] = Val + ((idFilterTable[i].id << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATA_EXT_SHIFT) &
    d9b0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d9b2:	00db      	lsls	r3, r3, #3
    d9b4:	9a01      	ldr	r2, [sp, #4]
    d9b6:	4413      	add	r3, r2
    d9b8:	685b      	ldr	r3, [r3, #4]
    d9ba:	005b      	lsls	r3, r3, #1
    d9bc:	f023 4140 	bic.w	r1, r3, #3221225472	; 0xc0000000
    d9c0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d9c2:	009b      	lsls	r3, r3, #2
    d9c4:	9a06      	ldr	r2, [sp, #24]
    d9c6:	4413      	add	r3, r2
    d9c8:	9a07      	ldr	r2, [sp, #28]
    d9ca:	440a      	add	r2, r1
    d9cc:	601a      	str	r2, [r3, #0]
    d9ce:	e00e      	b.n	d9ee <FlexCAN_SetRxFifoFilter+0xcc>
                                             FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATA_EXT_MASK
                                           );
                }
                else
                {
                    FilterTable[i] = Val + ((idFilterTable[i].id << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATA_STD_SHIFT) &
    d9d0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d9d2:	00db      	lsls	r3, r3, #3
    d9d4:	9a01      	ldr	r2, [sp, #4]
    d9d6:	4413      	add	r3, r2
    d9d8:	685b      	ldr	r3, [r3, #4]
    d9da:	04da      	lsls	r2, r3, #19
    d9dc:	4b9d      	ldr	r3, [pc, #628]	; (dc54 <FlexCAN_SetRxFifoFilter+0x332>)
    d9de:	4013      	ands	r3, r2
    d9e0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    d9e2:	0092      	lsls	r2, r2, #2
    d9e4:	9906      	ldr	r1, [sp, #24]
    d9e6:	440a      	add	r2, r1
    d9e8:	9907      	ldr	r1, [sp, #28]
    d9ea:	440b      	add	r3, r1
    d9ec:	6013      	str	r3, [r2, #0]
            for (i = 0U; i < FLEXCAN_IP_RXFIFO_FILTER_ELEM_NUM(NumOfFilters); i++)
    d9ee:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    d9f0:	3301      	adds	r3, #1
    d9f2:	930b      	str	r3, [sp, #44]	; 0x2c
    d9f4:	9b05      	ldr	r3, [sp, #20]
    d9f6:	3301      	adds	r3, #1
    d9f8:	00db      	lsls	r3, r3, #3
    d9fa:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    d9fc:	429a      	cmp	r2, r3
    d9fe:	d3c0      	bcc.n	d982 <FlexCAN_SetRxFifoFilter+0x60>
                                             FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATA_STD_MASK
                                           );
                }
            }
            break;
    da00:	e18f      	b.n	dd22 <FlexCAN_SetRxFifoFilter+0x400>
        case (FLEXCAN_RX_FIFO_ID_FORMAT_B):
            /* Two full standard IDs or two partial 14-bit (standard and extended) IDs*/
            /* per ID Filter Table element.*/
            /* Start critical section: implementation depends on integrator */
            SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    da02:	f004 fecb 	bl	1279c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            (base->MCR) =
                (((base->MCR) & ~(FLEXCAN_MCR_IDAM_MASK)) | ((((uint32)(((uint32)(FLEXCAN_RX_FIFO_ID_FORMAT_B)) << FLEXCAN_MCR_IDAM_SHIFT)) & FLEXCAN_MCR_IDAM_MASK)));
    da06:	9b03      	ldr	r3, [sp, #12]
    da08:	681b      	ldr	r3, [r3, #0]
    da0a:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    da0e:	f443 7280 	orr.w	r2, r3, #256	; 0x100
            (base->MCR) =
    da12:	9b03      	ldr	r3, [sp, #12]
    da14:	601a      	str	r2, [r3, #0]
            /* End critical section: implementation depends on integrator */
            SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    da16:	f004 feed 	bl	127f4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            j = 0U;
    da1a:	2300      	movs	r3, #0
    da1c:	930a      	str	r3, [sp, #40]	; 0x28
            for (i = 0U; i < FLEXCAN_IP_RXFIFO_FILTER_ELEM_NUM(NumOfFilters); i++)
    da1e:	2300      	movs	r3, #0
    da20:	930b      	str	r3, [sp, #44]	; 0x2c
    da22:	e083      	b.n	db2c <FlexCAN_SetRxFifoFilter+0x20a>
            {
                Val1 = 0U;
    da24:	2300      	movs	r3, #0
    da26:	9309      	str	r3, [sp, #36]	; 0x24
                Val2 = 0U;
    da28:	2300      	movs	r3, #0
    da2a:	9308      	str	r3, [sp, #32]

                if (idFilterTable[j].isRemoteFrame)
    da2c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    da2e:	00db      	lsls	r3, r3, #3
    da30:	9a01      	ldr	r2, [sp, #4]
    da32:	4413      	add	r3, r2
    da34:	781b      	ldrb	r3, [r3, #0]
    da36:	2b00      	cmp	r3, #0
    da38:	d002      	beq.n	da40 <FlexCAN_SetRxFifoFilter+0x11e>
                {
                    Val1 = FLEXCAN_IP_RX_FIFO_ACCEPT_REMOTE_FRAME << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATAB_RTR_SHIFT;
    da3a:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
    da3e:	9309      	str	r3, [sp, #36]	; 0x24
                }

                if (idFilterTable[j + 1U].isRemoteFrame)
    da40:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    da42:	3301      	adds	r3, #1
    da44:	00db      	lsls	r3, r3, #3
    da46:	9a01      	ldr	r2, [sp, #4]
    da48:	4413      	add	r3, r2
    da4a:	781b      	ldrb	r3, [r3, #0]
    da4c:	2b00      	cmp	r3, #0
    da4e:	d002      	beq.n	da56 <FlexCAN_SetRxFifoFilter+0x134>
                {
                    Val2 = FLEXCAN_IP_RX_FIFO_ACCEPT_REMOTE_FRAME << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_RTR_SHIFT;
    da50:	f44f 4300 	mov.w	r3, #32768	; 0x8000
    da54:	9308      	str	r3, [sp, #32]
                }

                if (idFilterTable[j].isExtendedFrame)
    da56:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    da58:	00db      	lsls	r3, r3, #3
    da5a:	9a01      	ldr	r2, [sp, #4]
    da5c:	4413      	add	r3, r2
    da5e:	785b      	ldrb	r3, [r3, #1]
    da60:	2b00      	cmp	r3, #0
    da62:	d014      	beq.n	da8e <FlexCAN_SetRxFifoFilter+0x16c>
                {
                    Val1 |= FLEXCAN_IP_RX_FIFO_ACCEPT_EXT_FRAME << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATAB_IDE_SHIFT;
    da64:	9b09      	ldr	r3, [sp, #36]	; 0x24
    da66:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
    da6a:	9309      	str	r3, [sp, #36]	; 0x24

                    FilterTable[i] = Val1 + (((idFilterTable[j].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_MASK) >>
    da6c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    da6e:	00db      	lsls	r3, r3, #3
    da70:	9a01      	ldr	r2, [sp, #4]
    da72:	4413      	add	r3, r2
    da74:	685b      	ldr	r3, [r3, #4]
    da76:	0bdb      	lsrs	r3, r3, #15
                                               FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_CMP_SHIFT
                                             ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_SHIFT1
    da78:	041a      	lsls	r2, r3, #16
    da7a:	4b77      	ldr	r3, [pc, #476]	; (dc58 <FlexCAN_SetRxFifoFilter+0x336>)
    da7c:	4013      	ands	r3, r2
                    FilterTable[i] = Val1 + (((idFilterTable[j].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_MASK) >>
    da7e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    da80:	0092      	lsls	r2, r2, #2
    da82:	9906      	ldr	r1, [sp, #24]
    da84:	440a      	add	r2, r1
    da86:	9909      	ldr	r1, [sp, #36]	; 0x24
    da88:	440b      	add	r3, r1
    da8a:	6013      	str	r3, [r2, #0]
    da8c:	e00e      	b.n	daac <FlexCAN_SetRxFifoFilter+0x18a>
                                            );
                }
                else
                {
                    FilterTable[i] = Val1 + ((idFilterTable[j].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_STD_MASK) <<
    da8e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    da90:	00db      	lsls	r3, r3, #3
    da92:	9a01      	ldr	r2, [sp, #4]
    da94:	4413      	add	r3, r2
    da96:	685b      	ldr	r3, [r3, #4]
    da98:	04da      	lsls	r2, r3, #19
    da9a:	4b6e      	ldr	r3, [pc, #440]	; (dc54 <FlexCAN_SetRxFifoFilter+0x332>)
    da9c:	4013      	ands	r3, r2
    da9e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    daa0:	0092      	lsls	r2, r2, #2
    daa2:	9906      	ldr	r1, [sp, #24]
    daa4:	440a      	add	r2, r1
    daa6:	9909      	ldr	r1, [sp, #36]	; 0x24
    daa8:	440b      	add	r3, r1
    daaa:	6013      	str	r3, [r2, #0]
                                              FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_STD_SHIFT1
                                            );
                }

                if (idFilterTable[j + 1U].isExtendedFrame)
    daac:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    daae:	3301      	adds	r3, #1
    dab0:	00db      	lsls	r3, r3, #3
    dab2:	9a01      	ldr	r2, [sp, #4]
    dab4:	4413      	add	r3, r2
    dab6:	785b      	ldrb	r3, [r3, #1]
    dab8:	2b00      	cmp	r3, #0
    daba:	d01a      	beq.n	daf2 <FlexCAN_SetRxFifoFilter+0x1d0>
                {
                    Val2 |= FLEXCAN_IP_RX_FIFO_ACCEPT_EXT_FRAME << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_IDE_SHIFT;
    dabc:	9b08      	ldr	r3, [sp, #32]
    dabe:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    dac2:	9308      	str	r3, [sp, #32]

                    FilterTable[i] |= Val2 + (((idFilterTable[j + 1U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_MASK) >>
    dac4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    dac6:	009b      	lsls	r3, r3, #2
    dac8:	9a06      	ldr	r2, [sp, #24]
    daca:	4413      	add	r3, r2
    dacc:	6819      	ldr	r1, [r3, #0]
    dace:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    dad0:	3301      	adds	r3, #1
    dad2:	00db      	lsls	r3, r3, #3
    dad4:	9a01      	ldr	r2, [sp, #4]
    dad6:	4413      	add	r3, r2
    dad8:	685b      	ldr	r3, [r3, #4]
    dada:	0bdb      	lsrs	r3, r3, #15
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_CMP_SHIFT
                                              ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_SHIFT2
    dadc:	f3c3 020d 	ubfx	r2, r3, #0, #14
                    FilterTable[i] |= Val2 + (((idFilterTable[j + 1U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_EXT_MASK) >>
    dae0:	9b08      	ldr	r3, [sp, #32]
    dae2:	441a      	add	r2, r3
    dae4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    dae6:	009b      	lsls	r3, r3, #2
    dae8:	9806      	ldr	r0, [sp, #24]
    daea:	4403      	add	r3, r0
    daec:	430a      	orrs	r2, r1
    daee:	601a      	str	r2, [r3, #0]
    daf0:	e016      	b.n	db20 <FlexCAN_SetRxFifoFilter+0x1fe>
                                             );
                }
                else
                {
                    FilterTable[i] |= Val2 + ((idFilterTable[j + 1U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_STD_MASK) <<
    daf2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    daf4:	009b      	lsls	r3, r3, #2
    daf6:	9a06      	ldr	r2, [sp, #24]
    daf8:	4413      	add	r3, r2
    dafa:	6819      	ldr	r1, [r3, #0]
    dafc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    dafe:	3301      	adds	r3, #1
    db00:	00db      	lsls	r3, r3, #3
    db02:	9a01      	ldr	r2, [sp, #4]
    db04:	4413      	add	r3, r2
    db06:	685b      	ldr	r3, [r3, #4]
    db08:	00da      	lsls	r2, r3, #3
    db0a:	f643 73f8 	movw	r3, #16376	; 0x3ff8
    db0e:	4013      	ands	r3, r2
    db10:	9a08      	ldr	r2, [sp, #32]
    db12:	441a      	add	r2, r3
    db14:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    db16:	009b      	lsls	r3, r3, #2
    db18:	9806      	ldr	r0, [sp, #24]
    db1a:	4403      	add	r3, r0
    db1c:	430a      	orrs	r2, r1
    db1e:	601a      	str	r2, [r3, #0]
                                               FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATB_STD_SHIFT2
                                             );
                }

                j = j + 2U;
    db20:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    db22:	3302      	adds	r3, #2
    db24:	930a      	str	r3, [sp, #40]	; 0x28
            for (i = 0U; i < FLEXCAN_IP_RXFIFO_FILTER_ELEM_NUM(NumOfFilters); i++)
    db26:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    db28:	3301      	adds	r3, #1
    db2a:	930b      	str	r3, [sp, #44]	; 0x2c
    db2c:	9b05      	ldr	r3, [sp, #20]
    db2e:	3301      	adds	r3, #1
    db30:	00db      	lsls	r3, r3, #3
    db32:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    db34:	429a      	cmp	r2, r3
    db36:	f4ff af75 	bcc.w	da24 <FlexCAN_SetRxFifoFilter+0x102>
            }
            break;
    db3a:	e0f2      	b.n	dd22 <FlexCAN_SetRxFifoFilter+0x400>
        case (FLEXCAN_RX_FIFO_ID_FORMAT_C):
            /* Four partial 8-bit Standard IDs per ID Filter Table element.*/
            /* Start critical section: implementation depends on integrator */
            SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    db3c:	f004 fe2e 	bl	1279c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            (base->MCR) =
                (((base->MCR) & ~(FLEXCAN_MCR_IDAM_MASK)) |
    db40:	9b03      	ldr	r3, [sp, #12]
    db42:	681b      	ldr	r3, [r3, #0]
    db44:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    db48:	f443 7200 	orr.w	r2, r3, #512	; 0x200
            (base->MCR) =
    db4c:	9b03      	ldr	r3, [sp, #12]
    db4e:	601a      	str	r2, [r3, #0]
                 ((((uint32)(((uint32)(FLEXCAN_RX_FIFO_ID_FORMAT_C)) << FLEXCAN_MCR_IDAM_SHIFT)) & FLEXCAN_MCR_IDAM_MASK))
                );
            /* End critical section: implementation depends on integrator */
            SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    db50:	f004 fe50 	bl	127f4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            j = 0U;
    db54:	2300      	movs	r3, #0
    db56:	930a      	str	r3, [sp, #40]	; 0x28
            for (i = 0U; i < FLEXCAN_IP_RXFIFO_FILTER_ELEM_NUM(NumOfFilters); i++)
    db58:	2300      	movs	r3, #0
    db5a:	930b      	str	r3, [sp, #44]	; 0x2c
    db5c:	e0cd      	b.n	dcfa <FlexCAN_SetRxFifoFilter+0x3d8>
            {
                if (idFilterTable[j].isExtendedFrame)
    db5e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    db60:	00db      	lsls	r3, r3, #3
    db62:	9a01      	ldr	r2, [sp, #4]
    db64:	4413      	add	r3, r2
    db66:	785b      	ldrb	r3, [r3, #1]
    db68:	2b00      	cmp	r3, #0
    db6a:	d00e      	beq.n	db8a <FlexCAN_SetRxFifoFilter+0x268>
                {
                    FilterTable[i] = Val1 + (((idFilterTable[j].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    db6c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    db6e:	00db      	lsls	r3, r3, #3
    db70:	9a01      	ldr	r2, [sp, #4]
    db72:	4413      	add	r3, r2
    db74:	685b      	ldr	r3, [r3, #4]
    db76:	0d5b      	lsrs	r3, r3, #21
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT
                                             ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT1
    db78:	0619      	lsls	r1, r3, #24
                    FilterTable[i] = Val1 + (((idFilterTable[j].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    db7a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    db7c:	009b      	lsls	r3, r3, #2
    db7e:	9a06      	ldr	r2, [sp, #24]
    db80:	4413      	add	r3, r2
    db82:	9a09      	ldr	r2, [sp, #36]	; 0x24
    db84:	440a      	add	r2, r1
    db86:	601a      	str	r2, [r3, #0]
    db88:	e00d      	b.n	dba6 <FlexCAN_SetRxFifoFilter+0x284>
                                            );
                }
                else
                {
                    FilterTable[i] = Val1 + (((idFilterTable[j].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>
    db8a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    db8c:	00db      	lsls	r3, r3, #3
    db8e:	9a01      	ldr	r2, [sp, #4]
    db90:	4413      	add	r3, r2
    db92:	685b      	ldr	r3, [r3, #4]
    db94:	08db      	lsrs	r3, r3, #3
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT
                                             ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT1
    db96:	0619      	lsls	r1, r3, #24
                    FilterTable[i] = Val1 + (((idFilterTable[j].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>
    db98:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    db9a:	009b      	lsls	r3, r3, #2
    db9c:	9a06      	ldr	r2, [sp, #24]
    db9e:	4413      	add	r3, r2
    dba0:	9a09      	ldr	r2, [sp, #36]	; 0x24
    dba2:	440a      	add	r2, r1
    dba4:	601a      	str	r2, [r3, #0]
                                            );
                }

                if (idFilterTable[j + 1U].isExtendedFrame)
    dba6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    dba8:	3301      	adds	r3, #1
    dbaa:	00db      	lsls	r3, r3, #3
    dbac:	9a01      	ldr	r2, [sp, #4]
    dbae:	4413      	add	r3, r2
    dbb0:	785b      	ldrb	r3, [r3, #1]
    dbb2:	2b00      	cmp	r3, #0
    dbb4:	d017      	beq.n	dbe6 <FlexCAN_SetRxFifoFilter+0x2c4>
                {
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 1U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    dbb6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    dbb8:	009b      	lsls	r3, r3, #2
    dbba:	9a06      	ldr	r2, [sp, #24]
    dbbc:	4413      	add	r3, r2
    dbbe:	6819      	ldr	r1, [r3, #0]
    dbc0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    dbc2:	3301      	adds	r3, #1
    dbc4:	00db      	lsls	r3, r3, #3
    dbc6:	9a01      	ldr	r2, [sp, #4]
    dbc8:	4413      	add	r3, r2
    dbca:	685b      	ldr	r3, [r3, #4]
    dbcc:	0d5b      	lsrs	r3, r3, #21
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT
                                              ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT2
    dbce:	041b      	lsls	r3, r3, #16
    dbd0:	f403 027f 	and.w	r2, r3, #16711680	; 0xff0000
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 1U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    dbd4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    dbd6:	441a      	add	r2, r3
    dbd8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    dbda:	009b      	lsls	r3, r3, #2
    dbdc:	9806      	ldr	r0, [sp, #24]
    dbde:	4403      	add	r3, r0
    dbe0:	430a      	orrs	r2, r1
    dbe2:	601a      	str	r2, [r3, #0]
    dbe4:	e016      	b.n	dc14 <FlexCAN_SetRxFifoFilter+0x2f2>
                                             );
                }
                else
                {
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 1U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>
    dbe6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    dbe8:	009b      	lsls	r3, r3, #2
    dbea:	9a06      	ldr	r2, [sp, #24]
    dbec:	4413      	add	r3, r2
    dbee:	6819      	ldr	r1, [r3, #0]
    dbf0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    dbf2:	3301      	adds	r3, #1
    dbf4:	00db      	lsls	r3, r3, #3
    dbf6:	9a01      	ldr	r2, [sp, #4]
    dbf8:	4413      	add	r3, r2
    dbfa:	685b      	ldr	r3, [r3, #4]
    dbfc:	08db      	lsrs	r3, r3, #3
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT
                                              ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT2
    dbfe:	041b      	lsls	r3, r3, #16
    dc00:	f403 027f 	and.w	r2, r3, #16711680	; 0xff0000
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 1U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>
    dc04:	9b09      	ldr	r3, [sp, #36]	; 0x24
    dc06:	441a      	add	r2, r3
    dc08:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    dc0a:	009b      	lsls	r3, r3, #2
    dc0c:	9806      	ldr	r0, [sp, #24]
    dc0e:	4403      	add	r3, r0
    dc10:	430a      	orrs	r2, r1
    dc12:	601a      	str	r2, [r3, #0]
                                             );
                }

                if (idFilterTable[j + 2U].isExtendedFrame)
    dc14:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    dc16:	3302      	adds	r3, #2
    dc18:	00db      	lsls	r3, r3, #3
    dc1a:	9a01      	ldr	r2, [sp, #4]
    dc1c:	4413      	add	r3, r2
    dc1e:	785b      	ldrb	r3, [r3, #1]
    dc20:	2b00      	cmp	r3, #0
    dc22:	d01b      	beq.n	dc5c <FlexCAN_SetRxFifoFilter+0x33a>
                {
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 2U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    dc24:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    dc26:	009b      	lsls	r3, r3, #2
    dc28:	9a06      	ldr	r2, [sp, #24]
    dc2a:	4413      	add	r3, r2
    dc2c:	6819      	ldr	r1, [r3, #0]
    dc2e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    dc30:	3302      	adds	r3, #2
    dc32:	00db      	lsls	r3, r3, #3
    dc34:	9a01      	ldr	r2, [sp, #4]
    dc36:	4413      	add	r3, r2
    dc38:	685b      	ldr	r3, [r3, #4]
    dc3a:	0d5b      	lsrs	r3, r3, #21
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT
                                              ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT3
    dc3c:	021b      	lsls	r3, r3, #8
    dc3e:	b29a      	uxth	r2, r3
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 2U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    dc40:	9b09      	ldr	r3, [sp, #36]	; 0x24
    dc42:	441a      	add	r2, r3
    dc44:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    dc46:	009b      	lsls	r3, r3, #2
    dc48:	9806      	ldr	r0, [sp, #24]
    dc4a:	4403      	add	r3, r0
    dc4c:	430a      	orrs	r2, r1
    dc4e:	601a      	str	r2, [r3, #0]
    dc50:	e01a      	b.n	dc88 <FlexCAN_SetRxFifoFilter+0x366>
    dc52:	bf00      	nop
    dc54:	3ff80000 	.word	0x3ff80000
    dc58:	3fff0000 	.word	0x3fff0000
                                             );
                }
                else
                {
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 2U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>
    dc5c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    dc5e:	009b      	lsls	r3, r3, #2
    dc60:	9a06      	ldr	r2, [sp, #24]
    dc62:	4413      	add	r3, r2
    dc64:	6819      	ldr	r1, [r3, #0]
    dc66:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    dc68:	3302      	adds	r3, #2
    dc6a:	00db      	lsls	r3, r3, #3
    dc6c:	9a01      	ldr	r2, [sp, #4]
    dc6e:	4413      	add	r3, r2
    dc70:	685b      	ldr	r3, [r3, #4]
    dc72:	08db      	lsrs	r3, r3, #3
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT
                                              ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT3
    dc74:	021b      	lsls	r3, r3, #8
    dc76:	b29a      	uxth	r2, r3
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 2U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>
    dc78:	9b09      	ldr	r3, [sp, #36]	; 0x24
    dc7a:	441a      	add	r2, r3
    dc7c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    dc7e:	009b      	lsls	r3, r3, #2
    dc80:	9806      	ldr	r0, [sp, #24]
    dc82:	4403      	add	r3, r0
    dc84:	430a      	orrs	r2, r1
    dc86:	601a      	str	r2, [r3, #0]
                                             );
                }

                if (idFilterTable[j + 3U].isExtendedFrame)
    dc88:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    dc8a:	3303      	adds	r3, #3
    dc8c:	00db      	lsls	r3, r3, #3
    dc8e:	9a01      	ldr	r2, [sp, #4]
    dc90:	4413      	add	r3, r2
    dc92:	785b      	ldrb	r3, [r3, #1]
    dc94:	2b00      	cmp	r3, #0
    dc96:	d015      	beq.n	dcc4 <FlexCAN_SetRxFifoFilter+0x3a2>
                {
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 3U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    dc98:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    dc9a:	009b      	lsls	r3, r3, #2
    dc9c:	9a06      	ldr	r2, [sp, #24]
    dc9e:	4413      	add	r3, r2
    dca0:	6819      	ldr	r1, [r3, #0]
    dca2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    dca4:	3303      	adds	r3, #3
    dca6:	00db      	lsls	r3, r3, #3
    dca8:	9a01      	ldr	r2, [sp, #4]
    dcaa:	4413      	add	r3, r2
    dcac:	685b      	ldr	r3, [r3, #4]
    dcae:	0d5b      	lsrs	r3, r3, #21
                                                FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_CMP_SHIFT
                                              ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT4
    dcb0:	b2da      	uxtb	r2, r3
                    FilterTable[i] |= Val1 + (((idFilterTable[j + 3U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_EXT_MASK) >>
    dcb2:	9b09      	ldr	r3, [sp, #36]	; 0x24
    dcb4:	441a      	add	r2, r3
    dcb6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    dcb8:	009b      	lsls	r3, r3, #2
    dcba:	9806      	ldr	r0, [sp, #24]
    dcbc:	4403      	add	r3, r0
    dcbe:	430a      	orrs	r2, r1
    dcc0:	601a      	str	r2, [r3, #0]
    dcc2:	e014      	b.n	dcee <FlexCAN_SetRxFifoFilter+0x3cc>
                                             );
                }
                else
                {
                    FilterTable[i] |= Val1 +
    dcc4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    dcc6:	009b      	lsls	r3, r3, #2
    dcc8:	9a06      	ldr	r2, [sp, #24]
    dcca:	4413      	add	r3, r2
    dccc:	6819      	ldr	r1, [r3, #0]
                                      (((idFilterTable[j + 3U].id & FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_MASK) >>
    dcce:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    dcd0:	3303      	adds	r3, #3
    dcd2:	00db      	lsls	r3, r3, #3
    dcd4:	9a01      	ldr	r2, [sp, #4]
    dcd6:	4413      	add	r3, r2
    dcd8:	685b      	ldr	r3, [r3, #4]
    dcda:	08db      	lsrs	r3, r3, #3
                                        FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_STD_CMP_SHIFT
                                       ) << FLEXCAN_IP_RX_FIFO_ID_FILTER_FORMATC_SHIFT4
    dcdc:	b2da      	uxtb	r2, r3
                    FilterTable[i] |= Val1 +
    dcde:	9b09      	ldr	r3, [sp, #36]	; 0x24
    dce0:	441a      	add	r2, r3
    dce2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    dce4:	009b      	lsls	r3, r3, #2
    dce6:	9806      	ldr	r0, [sp, #24]
    dce8:	4403      	add	r3, r0
    dcea:	430a      	orrs	r2, r1
    dcec:	601a      	str	r2, [r3, #0]
                                      );
                }

                j = j + 4U;
    dcee:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    dcf0:	3304      	adds	r3, #4
    dcf2:	930a      	str	r3, [sp, #40]	; 0x28
            for (i = 0U; i < FLEXCAN_IP_RXFIFO_FILTER_ELEM_NUM(NumOfFilters); i++)
    dcf4:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    dcf6:	3301      	adds	r3, #1
    dcf8:	930b      	str	r3, [sp, #44]	; 0x2c
    dcfa:	9b05      	ldr	r3, [sp, #20]
    dcfc:	3301      	adds	r3, #1
    dcfe:	00db      	lsls	r3, r3, #3
    dd00:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    dd02:	429a      	cmp	r2, r3
    dd04:	f4ff af2b 	bcc.w	db5e <FlexCAN_SetRxFifoFilter+0x23c>
            }
            break;
    dd08:	e00b      	b.n	dd22 <FlexCAN_SetRxFifoFilter+0x400>
        case (FLEXCAN_RX_FIFO_ID_FORMAT_D):
            /* All frames rejected.*/
            /* Start critical section: implementation depends on integrator */
            SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    dd0a:	f004 fd47 	bl	1279c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            (base->MCR) =
                (((base->MCR) & ~(FLEXCAN_MCR_IDAM_MASK)) |
    dd0e:	9b03      	ldr	r3, [sp, #12]
    dd10:	681b      	ldr	r3, [r3, #0]
    dd12:	f443 7240 	orr.w	r2, r3, #768	; 0x300
            (base->MCR) =
    dd16:	9b03      	ldr	r3, [sp, #12]
    dd18:	601a      	str	r2, [r3, #0]
                 ((((uint32)(((uint32)(FLEXCAN_RX_FIFO_ID_FORMAT_D)) << FLEXCAN_MCR_IDAM_SHIFT)) & FLEXCAN_MCR_IDAM_MASK))
                );
            /* End critical section: implementation depends on integrator */
            SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13();
    dd1a:	f004 fd6b 	bl	127f4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>
            break;
    dd1e:	e000      	b.n	dd22 <FlexCAN_SetRxFifoFilter+0x400>
        default:
            /* Should not get here */
            break;
    dd20:	bf00      	nop
    }
}
    dd22:	bf00      	nop
    dd24:	b00d      	add	sp, #52	; 0x34
    dd26:	f85d fb04 	ldr.w	pc, [sp], #4

0000dd2a <FlexCAN_ReadRxFifo>:
 * Description   : Read Rx FIFO data.
 * This function will copy MB[0] data field into user's buffer.
 *
 *END**************************************************************************/
void FlexCAN_ReadRxFifo(const FLEXCAN_Type * base, Flexcan_Ip_MsgBuffType * rxFifo)
{
    dd2a:	b500      	push	{lr}
    dd2c:	b08b      	sub	sp, #44	; 0x2c
    dd2e:	9001      	str	r0, [sp, #4]
    dd30:	9100      	str	r1, [sp, #0]
    uint32 x;
    uint8 Index;
    const uint8 * p;
    #endif

    volatile const uint32 * flexcan_mb = (uint32 *)((Flexcan_Ip_PtrSizeType)base + (uint32)FLEXCAN_IP_FEATURE_RAM_OFFSET);
    dd32:	9b01      	ldr	r3, [sp, #4]
    dd34:	3380      	adds	r3, #128	; 0x80
    dd36:	9307      	str	r3, [sp, #28]
    volatile const uint32 * flexcan_mb_id = &flexcan_mb[1];
    dd38:	9b07      	ldr	r3, [sp, #28]
    dd3a:	3304      	adds	r3, #4
    dd3c:	9306      	str	r3, [sp, #24]
    volatile const uint32 * flexcan_mb_data_32 = &flexcan_mb[2];
    dd3e:	9b07      	ldr	r3, [sp, #28]
    dd40:	3308      	adds	r3, #8
    dd42:	9305      	str	r3, [sp, #20]
    uint32 * msgData_32 = NULL_PTR;
    dd44:	2300      	movs	r3, #0
    dd46:	9304      	str	r3, [sp, #16]
    uint8 flexcan_mb_dlc_value = (uint8)(((*flexcan_mb) & FLEXCAN_IP_CS_DLC_MASK) >> 16);
    dd48:	9b07      	ldr	r3, [sp, #28]
    dd4a:	681b      	ldr	r3, [r3, #0]
    dd4c:	0c1b      	lsrs	r3, r3, #16
    dd4e:	b2db      	uxtb	r3, r3
    dd50:	f003 030f 	and.w	r3, r3, #15
    dd54:	f88d 300f 	strb.w	r3, [sp, #15]
    uint8 can_real_payload = FlexCAN_ComputePayloadSize(flexcan_mb_dlc_value);
    dd58:	f89d 300f 	ldrb.w	r3, [sp, #15]
    dd5c:	4618      	mov	r0, r3
    dd5e:	f7fe fe6c 	bl	ca3a <FlexCAN_ComputePayloadSize>
    dd62:	4603      	mov	r3, r0
    dd64:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23

    #if (FLEXCAN_IP_DEV_ERROR_DETECT == STD_ON)
        DevAssert(rxFifo != NULL_PTR);
    #endif
    msgData_32 = (uint32 *)(rxFifo->data);
    dd68:	9b00      	ldr	r3, [sp, #0]
    dd6a:	3308      	adds	r3, #8
    dd6c:	9304      	str	r3, [sp, #16]
       Check if the length of received data packet bigger than the maximum length accepted,
       then processing flow shall continue with the maximum length defined by configuration.
       Legacy FIFO just support in normal mode.
    */
    /* no need to check if FD enabled or not because this function just is invoked when legacy fifo enabled only ! */
    if (can_real_payload > 8U)
    dd6e:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    dd72:	2b08      	cmp	r3, #8
    dd74:	d902      	bls.n	dd7c <FlexCAN_ReadRxFifo+0x52>
    {
        can_real_payload = 8U;
    dd76:	2308      	movs	r3, #8
    dd78:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
    }

    rxFifo->dataLen = can_real_payload;
    dd7c:	9b00      	ldr	r3, [sp, #0]
    dd7e:	f89d 2023 	ldrb.w	r2, [sp, #35]	; 0x23
    dd82:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
    rxFifo->cs = *flexcan_mb;
    dd86:	9b07      	ldr	r3, [sp, #28]
    dd88:	681a      	ldr	r2, [r3, #0]
    dd8a:	9b00      	ldr	r3, [sp, #0]
    dd8c:	601a      	str	r2, [r3, #0]
    if ((rxFifo->cs & FLEXCAN_IP_CS_IDE_MASK) != 0U)
    dd8e:	9b00      	ldr	r3, [sp, #0]
    dd90:	681b      	ldr	r3, [r3, #0]
    dd92:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
    dd96:	2b00      	cmp	r3, #0
    dd98:	d004      	beq.n	dda4 <FlexCAN_ReadRxFifo+0x7a>
    {
        rxFifo->msgId = *flexcan_mb_id;
    dd9a:	9b06      	ldr	r3, [sp, #24]
    dd9c:	681a      	ldr	r2, [r3, #0]
    dd9e:	9b00      	ldr	r3, [sp, #0]
    dda0:	605a      	str	r2, [r3, #4]
    dda2:	e004      	b.n	ddae <FlexCAN_ReadRxFifo+0x84>
    }
    else
    {
        rxFifo->msgId = (*flexcan_mb_id) >> FLEXCAN_IP_ID_STD_SHIFT;
    dda4:	9b06      	ldr	r3, [sp, #24]
    dda6:	681b      	ldr	r3, [r3, #0]
    dda8:	0c9a      	lsrs	r2, r3, #18
    ddaa:	9b00      	ldr	r3, [sp, #0]
    ddac:	605a      	str	r2, [r3, #4]
    }
    /* Extract the IDHIT */
    rxFifo->id_hit = (uint8)base->RXFIR;
    ddae:	9b01      	ldr	r3, [sp, #4]
    ddb0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
    ddb2:	b2da      	uxtb	r2, r3
    ddb4:	9b00      	ldr	r3, [sp, #0]
    ddb6:	f883 2049 	strb.w	r2, [r3, #73]	; 0x49
    /* Extract the Time Stamp */
    rxFifo->time_stamp = (uint32)((rxFifo->cs & FLEXCAN_IP_CS_TIME_STAMP_MASK) >> FLEXCAN_IP_CS_TIME_STAMP_SHIFT);
    ddba:	9b00      	ldr	r3, [sp, #0]
    ddbc:	681b      	ldr	r3, [r3, #0]
    ddbe:	b29a      	uxth	r2, r3
    ddc0:	9b00      	ldr	r3, [sp, #0]
    ddc2:	64da      	str	r2, [r3, #76]	; 0x4c
            FLEXCAN_IP_SWAP_BYTES_IN_WORD(MbWord, msgData_32[DataByte >> 2U]);
        }
    }
#else  /* if (defined (CPU_S32K116) || defined (CPU_S32K118)) */
      /* Copy MB[0] data field into user's buffer */
    for (DataByte = 0U; DataByte < can_real_payload; DataByte += 4U)
    ddc4:	2300      	movs	r3, #0
    ddc6:	9309      	str	r3, [sp, #36]	; 0x24
    ddc8:	e01f      	b.n	de0a <FlexCAN_ReadRxFifo+0xe0>
    {
        MbWord = flexcan_mb_data_32[DataByte >> 2U];
    ddca:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ddcc:	089b      	lsrs	r3, r3, #2
    ddce:	009b      	lsls	r3, r3, #2
    ddd0:	9a05      	ldr	r2, [sp, #20]
    ddd2:	4413      	add	r3, r2
    ddd4:	681b      	ldr	r3, [r3, #0]
    ddd6:	9302      	str	r3, [sp, #8]
        FLEXCAN_IP_SWAP_BYTES_IN_WORD((MbWord), (msgData_32[DataByte >> 2U]));
    ddd8:	9b02      	ldr	r3, [sp, #8]
    ddda:	0e1a      	lsrs	r2, r3, #24
    dddc:	9b02      	ldr	r3, [sp, #8]
    ddde:	0a1b      	lsrs	r3, r3, #8
    dde0:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
    dde4:	431a      	orrs	r2, r3
    dde6:	9b02      	ldr	r3, [sp, #8]
    dde8:	021b      	lsls	r3, r3, #8
    ddea:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
    ddee:	ea42 0103 	orr.w	r1, r2, r3
    ddf2:	9b02      	ldr	r3, [sp, #8]
    ddf4:	061a      	lsls	r2, r3, #24
    ddf6:	9b09      	ldr	r3, [sp, #36]	; 0x24
    ddf8:	089b      	lsrs	r3, r3, #2
    ddfa:	009b      	lsls	r3, r3, #2
    ddfc:	9804      	ldr	r0, [sp, #16]
    ddfe:	4403      	add	r3, r0
    de00:	430a      	orrs	r2, r1
    de02:	601a      	str	r2, [r3, #0]
    for (DataByte = 0U; DataByte < can_real_payload; DataByte += 4U)
    de04:	9b09      	ldr	r3, [sp, #36]	; 0x24
    de06:	3304      	adds	r3, #4
    de08:	9309      	str	r3, [sp, #36]	; 0x24
    de0a:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
    de0e:	9a09      	ldr	r2, [sp, #36]	; 0x24
    de10:	429a      	cmp	r2, r3
    de12:	d3da      	bcc.n	ddca <FlexCAN_ReadRxFifo+0xa0>
    }
#endif /* if (defined (CPU_S32K116) || defined (CPU_S32K118)) */
}
    de14:	bf00      	nop
    de16:	bf00      	nop
    de18:	b00b      	add	sp, #44	; 0x2c
    de1a:	f85d fb04 	ldr.w	pc, [sp], #4

0000de1e <FlexCAN_IsMbOutOfRange>:
    const FLEXCAN_Type * pBase,
    uint8 u8MbIndex,
    boolean bIsLegacyFifoEn,
    uint32 u32MaxMbNum
)
{
    de1e:	b088      	sub	sp, #32
    de20:	9003      	str	r0, [sp, #12]
    de22:	9301      	str	r3, [sp, #4]
    de24:	460b      	mov	r3, r1
    de26:	f88d 300b 	strb.w	r3, [sp, #11]
    de2a:	4613      	mov	r3, r2
    de2c:	f88d 300a 	strb.w	r3, [sp, #10]
    boolean ReturnValue = FALSE;
    de30:	2300      	movs	r3, #0
    de32:	f88d 301f 	strb.w	r3, [sp, #31]
    uint32 u32NumOfFiFoElement = 0U;
    de36:	2300      	movs	r3, #0
    de38:	9306      	str	r3, [sp, #24]
    uint32 u32NumOfMbOccupiedByFiFo = 0U;
    de3a:	2300      	movs	r3, #0
    de3c:	9305      	str	r3, [sp, #20]

    if (u8MbIndex >= (uint8)u32MaxMbNum)
    de3e:	9b01      	ldr	r3, [sp, #4]
    de40:	b2db      	uxtb	r3, r3
    de42:	f89d 200b 	ldrb.w	r2, [sp, #11]
    de46:	429a      	cmp	r2, r3
    de48:	d303      	bcc.n	de52 <FlexCAN_IsMbOutOfRange+0x34>
    {
       ReturnValue = TRUE;
    de4a:	2301      	movs	r3, #1
    de4c:	f88d 301f 	strb.w	r3, [sp, #31]
    de50:	e01b      	b.n	de8a <FlexCAN_IsMbOutOfRange+0x6c>
    }
    /* Check if RX FIFO is enabled*/
    else if (TRUE == bIsLegacyFifoEn)
    de52:	f89d 300a 	ldrb.w	r3, [sp, #10]
    de56:	2b00      	cmp	r3, #0
    de58:	d014      	beq.n	de84 <FlexCAN_IsMbOutOfRange+0x66>
    {
        /* Get the number of RX FIFO Filters*/
        u32NumOfFiFoElement = (((pBase->CTRL2) & FLEXCAN_CTRL2_RFFN_MASK) >> FLEXCAN_CTRL2_RFFN_SHIFT);
    de5a:	9b03      	ldr	r3, [sp, #12]
    de5c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
    de5e:	0e1b      	lsrs	r3, r3, #24
    de60:	f003 030f 	and.w	r3, r3, #15
    de64:	9306      	str	r3, [sp, #24]
        /* Get the number if MBs occupied by RX FIFO and ID filter table*/
        /* the Rx FIFO occupies the memory space originally reserved for MB0-5*/
        /* Every number of RFFN means 8 number of RX FIFO filters*/
        /* and every 4 number of RX FIFO filters occupied one MB*/
        u32NumOfMbOccupiedByFiFo = 5U + ((((u32NumOfFiFoElement) + 1U) * 8U) / 4U);
    de66:	9b06      	ldr	r3, [sp, #24]
    de68:	3301      	adds	r3, #1
    de6a:	00db      	lsls	r3, r3, #3
    de6c:	089b      	lsrs	r3, r3, #2
    de6e:	3305      	adds	r3, #5
    de70:	9305      	str	r3, [sp, #20]
        if (u8MbIndex <= u32NumOfMbOccupiedByFiFo)
    de72:	f89d 300b 	ldrb.w	r3, [sp, #11]
    de76:	9a05      	ldr	r2, [sp, #20]
    de78:	429a      	cmp	r2, r3
    de7a:	d306      	bcc.n	de8a <FlexCAN_IsMbOutOfRange+0x6c>
        {
            ReturnValue = TRUE;
    de7c:	2301      	movs	r3, #1
    de7e:	f88d 301f 	strb.w	r3, [sp, #31]
    de82:	e002      	b.n	de8a <FlexCAN_IsMbOutOfRange+0x6c>
        }
    }
    else
    {
        ReturnValue = FALSE;
    de84:	2300      	movs	r3, #0
    de86:	f88d 301f 	strb.w	r3, [sp, #31]
    }

    return ReturnValue;
    de8a:	f89d 301f 	ldrb.w	r3, [sp, #31]
}
    de8e:	4618      	mov	r0, r3
    de90:	b008      	add	sp, #32
    de92:	4770      	bx	lr

0000de94 <FlexCAN_ConfigCtrlOptions>:
 * Description   : configure controller depending on options
 * note: should be call after FD configuration.
 *
 *END**************************************************************************/
void FlexCAN_ConfigCtrlOptions(FLEXCAN_Type * pBase, uint32 u32Options)
{
    de94:	b500      	push	{lr}
    de96:	b083      	sub	sp, #12
    de98:	9001      	str	r0, [sp, #4]
    de9a:	9100      	str	r1, [sp, #0]
#if (FLEXCAN_IP_FEATURE_SWITCHINGISOMODE == STD_ON)
    /* If the FD feature is enabled, in order to be ISO-compliant. */
    if ((u32Options & FLEXCAN_IP_ISO_U32) != 0U)
    de9c:	9b00      	ldr	r3, [sp, #0]
    de9e:	f003 0320 	and.w	r3, r3, #32
    dea2:	2b00      	cmp	r3, #0
    dea4:	d004      	beq.n	deb0 <FlexCAN_ConfigCtrlOptions+0x1c>
    {
        FlexCAN_SetIsoCan(pBase, TRUE);
    dea6:	2101      	movs	r1, #1
    dea8:	9801      	ldr	r0, [sp, #4]
    deaa:	f7fe fcd8 	bl	c85e <FlexCAN_SetIsoCan>
    deae:	e003      	b.n	deb8 <FlexCAN_ConfigCtrlOptions+0x24>
    }
    else
    {
        /* This maybe don't have sense if the Deinit returns the state of registers at init values */
        FlexCAN_SetIsoCan(pBase, FALSE);
    deb0:	2100      	movs	r1, #0
    deb2:	9801      	ldr	r0, [sp, #4]
    deb4:	f7fe fcd3 	bl	c85e <FlexCAN_SetIsoCan>
    }
#endif /*(FLEXCAN_IP_FEATURE_SWITCHINGISOMODE == STD_ON) */
    /* Set Entire Frame Arbitration Field Comparison. */
    if ((u32Options & FLEXCAN_IP_EACEN_U32) != 0U)
    deb8:	9b00      	ldr	r3, [sp, #0]
    deba:	f003 0340 	and.w	r3, r3, #64	; 0x40
    debe:	2b00      	cmp	r3, #0
    dec0:	d004      	beq.n	decc <FlexCAN_ConfigCtrlOptions+0x38>
    {
        FlexCAN_SetEntireFrameArbitrationFieldComparison(pBase, TRUE);
    dec2:	2101      	movs	r1, #1
    dec4:	9801      	ldr	r0, [sp, #4]
    dec6:	f7fe fce1 	bl	c88c <FlexCAN_SetEntireFrameArbitrationFieldComparison>
    deca:	e003      	b.n	ded4 <FlexCAN_ConfigCtrlOptions+0x40>
    }
    else
    {
        FlexCAN_SetEntireFrameArbitrationFieldComparison(pBase, FALSE);
    decc:	2100      	movs	r1, #0
    dece:	9801      	ldr	r0, [sp, #4]
    ded0:	f7fe fcdc 	bl	c88c <FlexCAN_SetEntireFrameArbitrationFieldComparison>
    }
#if (FLEXCAN_IP_FEATURE_PROTOCOLEXCEPTION == STD_ON)
    /* Set protocol Exception */
    if ((u32Options & FLEXCAN_IP_PROTOCOL_EXCEPTION_U32) != 0U)
    ded4:	9b00      	ldr	r3, [sp, #0]
    ded6:	f003 0308 	and.w	r3, r3, #8
    deda:	2b00      	cmp	r3, #0
    dedc:	d004      	beq.n	dee8 <FlexCAN_ConfigCtrlOptions+0x54>
    {
        FlexCAN_SetProtocolException(pBase, TRUE);
    dede:	2101      	movs	r1, #1
    dee0:	9801      	ldr	r0, [sp, #4]
    dee2:	f7fe fcea 	bl	c8ba <FlexCAN_SetProtocolException>
    dee6:	e003      	b.n	def0 <FlexCAN_ConfigCtrlOptions+0x5c>
    }
    else
    {
        FlexCAN_SetProtocolException(pBase, FALSE);
    dee8:	2100      	movs	r1, #0
    deea:	9801      	ldr	r0, [sp, #4]
    deec:	f7fe fce5 	bl	c8ba <FlexCAN_SetProtocolException>
    }
#endif /* Endif  (FLEXCAN_IP_FEATURE_PROTOCOLEXCEPTION == STD_ON)  */
    /* Set CAN Bit Sampling */
    if (((u32Options & FLEXCAN_IP_THREE_SAMPLES_U32) != 0U) && (0U == (pBase->MCR & FLEXCAN_MCR_FDEN_MASK)))
    def0:	9b00      	ldr	r3, [sp, #0]
    def2:	f003 0302 	and.w	r3, r3, #2
    def6:	2b00      	cmp	r3, #0
    def8:	d00a      	beq.n	df10 <FlexCAN_ConfigCtrlOptions+0x7c>
    defa:	9b01      	ldr	r3, [sp, #4]
    defc:	681b      	ldr	r3, [r3, #0]
    defe:	f403 6300 	and.w	r3, r3, #2048	; 0x800
    df02:	2b00      	cmp	r3, #0
    df04:	d104      	bne.n	df10 <FlexCAN_ConfigCtrlOptions+0x7c>
    {
        FlexCAN_CanBitSampling(pBase, TRUE);
    df06:	2101      	movs	r1, #1
    df08:	9801      	ldr	r0, [sp, #4]
    df0a:	f7fe fd31 	bl	c970 <FlexCAN_CanBitSampling>
    df0e:	e003      	b.n	df18 <FlexCAN_ConfigCtrlOptions+0x84>
    }
    else
    {
        FlexCAN_CanBitSampling(pBase, FALSE);
    df10:	2100      	movs	r1, #0
    df12:	9801      	ldr	r0, [sp, #4]
    df14:	f7fe fd2c 	bl	c970 <FlexCAN_CanBitSampling>
    }

    /* Set AutoBusOff Recovery */
    if ((u32Options & FLEXCAN_IP_BUSOFF_RECOVERY_U32) != 0U)
    df18:	9b00      	ldr	r3, [sp, #0]
    df1a:	f003 0304 	and.w	r3, r3, #4
    df1e:	2b00      	cmp	r3, #0
    df20:	d004      	beq.n	df2c <FlexCAN_ConfigCtrlOptions+0x98>
    {
        FlexCAN_SetBusOffAutorecovery(pBase, TRUE);
    df22:	2101      	movs	r1, #1
    df24:	9801      	ldr	r0, [sp, #4]
    df26:	f7fe fcf6 	bl	c916 <FlexCAN_SetBusOffAutorecovery>
    df2a:	e003      	b.n	df34 <FlexCAN_ConfigCtrlOptions+0xa0>
    }
    else
    {
        FlexCAN_SetBusOffAutorecovery(pBase, FALSE);
    df2c:	2100      	movs	r1, #0
    df2e:	9801      	ldr	r0, [sp, #4]
    df30:	f7fe fcf1 	bl	c916 <FlexCAN_SetBusOffAutorecovery>
    }
    /* Set Remote Request Store for received of Remote Request Frames */
    if ((u32Options & FLEXCAN_IP_REM_STORE_U32) != 0U)
    df34:	9b00      	ldr	r3, [sp, #0]
    df36:	f003 0301 	and.w	r3, r3, #1
    df3a:	2b00      	cmp	r3, #0
    df3c:	d004      	beq.n	df48 <FlexCAN_ConfigCtrlOptions+0xb4>
    {
        FlexCAN_SetRemoteReqStore(pBase, TRUE);
    df3e:	2101      	movs	r1, #1
    df40:	9801      	ldr	r0, [sp, #4]
    df42:	f7fe fcd1 	bl	c8e8 <FlexCAN_SetRemoteReqStore>
    df46:	e003      	b.n	df50 <FlexCAN_ConfigCtrlOptions+0xbc>
    }
    else
    {
        FlexCAN_SetRemoteReqStore(pBase, FALSE);
    df48:	2100      	movs	r1, #0
    df4a:	9801      	ldr	r0, [sp, #4]
    df4c:	f7fe fccc 	bl	c8e8 <FlexCAN_SetRemoteReqStore>
    }
#if (FLEXCAN_IP_FEATURE_EDGEFILTER == STD_ON)
    /* Set Edge Filter */
    if ((u32Options & FLEXCAN_IP_EDGE_FILTER_U32) != 0U)
    df50:	9b00      	ldr	r3, [sp, #0]
    df52:	f003 0310 	and.w	r3, r3, #16
    df56:	2b00      	cmp	r3, #0
    df58:	d004      	beq.n	df64 <FlexCAN_ConfigCtrlOptions+0xd0>
    {
        FlexCAN_SetEdgeFilter(pBase, TRUE);
    df5a:	2101      	movs	r1, #1
    df5c:	9801      	ldr	r0, [sp, #4]
    df5e:	f7fe fcf0 	bl	c942 <FlexCAN_SetEdgeFilter>
    else
    {
        FlexCAN_SetEdgeFilter(pBase, FALSE);
    }
#endif /* End of (FLEXCAN_IP_FEATURE_EDGEFILTER == STD_ON)  */
}
    df62:	e003      	b.n	df6c <FlexCAN_ConfigCtrlOptions+0xd8>
        FlexCAN_SetEdgeFilter(pBase, FALSE);
    df64:	2100      	movs	r1, #0
    df66:	9801      	ldr	r0, [sp, #4]
    df68:	f7fe fceb 	bl	c942 <FlexCAN_SetEdgeFilter>
}
    df6c:	bf00      	nop
    df6e:	b003      	add	sp, #12
    df70:	f85d fb04 	ldr.w	pc, [sp], #4

0000df74 <FlexCAN_ResetImaskBuff>:
 * Function Name : FlexCAN_ResetImaskBuff (uses in FlexCAN_Ip_Init function only)
 * Description   : Reset Imask Buffers.
 *
 *END**************************************************************************/
void FlexCAN_ResetImaskBuff(uint8 Instance)
{
    df74:	b084      	sub	sp, #16
    df76:	4603      	mov	r3, r0
    df78:	f88d 3007 	strb.w	r3, [sp, #7]
    uint8 ImaskCnt = 0U;
    df7c:	2300      	movs	r3, #0
    df7e:	f88d 300f 	strb.w	r3, [sp, #15]

    for (ImaskCnt = 0U; ImaskCnt < FLEXCAN_IP_FEATURE_MBDSR_COUNT; ImaskCnt++)
    df82:	2300      	movs	r3, #0
    df84:	f88d 300f 	strb.w	r3, [sp, #15]
    df88:	e00d      	b.n	dfa6 <FlexCAN_ResetImaskBuff+0x32>
    {
        FlexCAN_Ip_au32ImaskBuff[Instance][ImaskCnt] = 0U;
    df8a:	f89d 2007 	ldrb.w	r2, [sp, #7]
    df8e:	f89d 300f 	ldrb.w	r3, [sp, #15]
    df92:	4909      	ldr	r1, [pc, #36]	; (dfb8 <FlexCAN_ResetImaskBuff+0x44>)
    df94:	4413      	add	r3, r2
    df96:	2200      	movs	r2, #0
    df98:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    for (ImaskCnt = 0U; ImaskCnt < FLEXCAN_IP_FEATURE_MBDSR_COUNT; ImaskCnt++)
    df9c:	f89d 300f 	ldrb.w	r3, [sp, #15]
    dfa0:	3301      	adds	r3, #1
    dfa2:	f88d 300f 	strb.w	r3, [sp, #15]
    dfa6:	f89d 300f 	ldrb.w	r3, [sp, #15]
    dfaa:	2b00      	cmp	r3, #0
    dfac:	d0ed      	beq.n	df8a <FlexCAN_ResetImaskBuff+0x16>
    }
}
    dfae:	bf00      	nop
    dfb0:	bf00      	nop
    dfb2:	b004      	add	sp, #16
    dfb4:	4770      	bx	lr
    dfb6:	bf00      	nop
    dfb8:	1fff9054 	.word	0x1fff9054

0000dfbc <CAN0_ORED_IRQHandler>:

#else

/* Implementation of CAN0 handler named in startup code for processing of Tx\Rx Warning and Bus Off reporting. */
ISR(CAN0_ORED_IRQHandler)
{
    dfbc:	b508      	push	{r3, lr}
    FlexCAN_BusOff_IRQHandler(0U);
    dfbe:	2000      	movs	r0, #0
    dfc0:	f7fd fb2a 	bl	b618 <FlexCAN_BusOff_IRQHandler>
    EXIT_INTERRUPT();
    dfc4:	f3bf 8f4f 	dsb	sy
}
    dfc8:	bf00      	nop
    dfca:	bd08      	pop	{r3, pc}

0000dfcc <CAN0_Error_IRQHandler>:

/* Implementation of CAN0 handler named in startup code for processing of Errors reporting. */
ISR(CAN0_Error_IRQHandler)
{
    dfcc:	b508      	push	{r3, lr}
    FlexCAN_Error_IRQHandler(0U);
    dfce:	2000      	movs	r0, #0
    dfd0:	f7fd fac2 	bl	b558 <FlexCAN_Error_IRQHandler>
    EXIT_INTERRUPT();
    dfd4:	f3bf 8f4f 	dsb	sy
}
    dfd8:	bf00      	nop
    dfda:	bd08      	pop	{r3, pc}

0000dfdc <CAN0_ORED_0_15_MB_IRQHandler>:
}
#endif
/* Implementation of CAN0 IRQ handler for interrupts indicating a successful
transmission or reception for Message Buffers 0-15. */
ISR(CAN0_ORED_0_15_MB_IRQHandler)
{
    dfdc:	b508      	push	{r3, lr}
    FlexCAN_IRQHandler(0U, 0U, 15U);
    dfde:	220f      	movs	r2, #15
    dfe0:	2100      	movs	r1, #0
    dfe2:	2000      	movs	r0, #0
    dfe4:	f7fd f9dc 	bl	b3a0 <FlexCAN_IRQHandler>
    EXIT_INTERRUPT();
    dfe8:	f3bf 8f4f 	dsb	sy
}
    dfec:	bf00      	nop
    dfee:	bd08      	pop	{r3, pc}

0000dff0 <CAN0_ORED_16_31_MB_IRQHandler>:

/* Implementation of CAN0 IRQ handler for interrupts indicating a successful
transmission or reception for Message Buffers 16-31. */
ISR(CAN0_ORED_16_31_MB_IRQHandler)
{
    dff0:	b508      	push	{r3, lr}
    FlexCAN_IRQHandler(0U, 16U, 31U);
    dff2:	221f      	movs	r2, #31
    dff4:	2110      	movs	r1, #16
    dff6:	2000      	movs	r0, #0
    dff8:	f7fd f9d2 	bl	b3a0 <FlexCAN_IRQHandler>
    EXIT_INTERRUPT();
    dffc:	f3bf 8f4f 	dsb	sy
}
    e000:	bf00      	nop
    e002:	bd08      	pop	{r3, pc}

0000e004 <CAN1_ORED_IRQHandler>:
#endif /* (defined(S32K142W) || defined(S32K144W) || defined(S32M243) || defined(S32M244)) */

#if (FLEXCAN_INSTANCE_COUNT > 1U)
/* Implementation of CAN1 handler named in startup code for processing of Tx\Rx Warning and Bus Off reporting. */
ISR(CAN1_ORED_IRQHandler)
{
    e004:	b508      	push	{r3, lr}
    FlexCAN_BusOff_IRQHandler(1U);
    e006:	2001      	movs	r0, #1
    e008:	f7fd fb06 	bl	b618 <FlexCAN_BusOff_IRQHandler>
    EXIT_INTERRUPT();
    e00c:	f3bf 8f4f 	dsb	sy
}
    e010:	bf00      	nop
    e012:	bd08      	pop	{r3, pc}

0000e014 <CAN1_Error_IRQHandler>:

/* Implementation of CAN1 handler named in startup code for processing of Errors reporting. */
ISR(CAN1_Error_IRQHandler)
{
    e014:	b508      	push	{r3, lr}
    FlexCAN_Error_IRQHandler(1U);
    e016:	2001      	movs	r0, #1
    e018:	f7fd fa9e 	bl	b558 <FlexCAN_Error_IRQHandler>
    EXIT_INTERRUPT();
    e01c:	f3bf 8f4f 	dsb	sy
}
    e020:	bf00      	nop
    e022:	bd08      	pop	{r3, pc}

0000e024 <CAN1_ORED_0_15_MB_IRQHandler>:

/* Implementation of CAN1 IRQ handler for interrupts indicating a successful
transmission or reception for Message Buffers 0-15. */
ISR(CAN1_ORED_0_15_MB_IRQHandler)
{
    e024:	b508      	push	{r3, lr}
    FlexCAN_IRQHandler(1U, 0U, 15U);
    e026:	220f      	movs	r2, #15
    e028:	2100      	movs	r1, #0
    e02a:	2001      	movs	r0, #1
    e02c:	f7fd f9b8 	bl	b3a0 <FlexCAN_IRQHandler>
    EXIT_INTERRUPT();
    e030:	f3bf 8f4f 	dsb	sy
}
    e034:	bf00      	nop
    e036:	bd08      	pop	{r3, pc}

0000e038 <CAN1_ORED_16_31_MB_IRQHandler>:

/* Implementation of CAN1 IRQ handler for interrupts indicating a successful
transmission or reception for Message Buffers 16-31. */
ISR(CAN1_ORED_16_31_MB_IRQHandler)
{
    e038:	b508      	push	{r3, lr}
    FlexCAN_IRQHandler(1U, 16U, 31U);
    e03a:	221f      	movs	r2, #31
    e03c:	2110      	movs	r1, #16
    e03e:	2001      	movs	r0, #1
    e040:	f7fd f9ae 	bl	b3a0 <FlexCAN_IRQHandler>
    EXIT_INTERRUPT();
    e044:	f3bf 8f4f 	dsb	sy
}
    e048:	bf00      	nop
    e04a:	bd08      	pop	{r3, pc}

0000e04c <CAN2_ORED_IRQHandler>:
#endif /* (FLEXCAN_INSTANCE_COUNT > 1U) */

#if (FLEXCAN_INSTANCE_COUNT > 2U)
/* Implementation of CAN2 handler named in startup code for processing of Errors and Bus Off reporting. */
ISR(CAN2_ORED_IRQHandler)
{
    e04c:	b508      	push	{r3, lr}
    FlexCAN_BusOff_IRQHandler(2U);
    e04e:	2002      	movs	r0, #2
    e050:	f7fd fae2 	bl	b618 <FlexCAN_BusOff_IRQHandler>
    EXIT_INTERRUPT();
    e054:	f3bf 8f4f 	dsb	sy
}
    e058:	bf00      	nop
    e05a:	bd08      	pop	{r3, pc}

0000e05c <CAN2_Error_IRQHandler>:

/* Implementation of CAN1 handler named in startup code for processing of Errors reporting. */
ISR(CAN2_Error_IRQHandler)
{
    e05c:	b508      	push	{r3, lr}
    FlexCAN_Error_IRQHandler(2U);
    e05e:	2002      	movs	r0, #2
    e060:	f7fd fa7a 	bl	b558 <FlexCAN_Error_IRQHandler>
    EXIT_INTERRUPT();
    e064:	f3bf 8f4f 	dsb	sy
}
    e068:	bf00      	nop
    e06a:	bd08      	pop	{r3, pc}

0000e06c <CAN2_ORED_0_15_MB_IRQHandler>:

/* Implementation of CAN2 IRQ handler for interrupts indicating a successful
transmission or reception for Message Buffers 0-15. */
ISR(CAN2_ORED_0_15_MB_IRQHandler)
{
    e06c:	b508      	push	{r3, lr}
    FlexCAN_IRQHandler(2U, 0U, 15U);
    e06e:	220f      	movs	r2, #15
    e070:	2100      	movs	r1, #0
    e072:	2002      	movs	r0, #2
    e074:	f7fd f994 	bl	b3a0 <FlexCAN_IRQHandler>
    EXIT_INTERRUPT();
    e078:	f3bf 8f4f 	dsb	sy
}
    e07c:	bf00      	nop
    e07e:	bd08      	pop	{r3, pc}

0000e080 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_00(void)
{
    e080:	b500      	push	{lr}
    e082:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e084:	f7f2 fd88 	bl	b98 <Sys_GetCoreID>
    e088:	4603      	mov	r3, r0
    e08a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_00[u32CoreId])
    e08c:	4a10      	ldr	r2, [pc, #64]	; (e0d0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_00+0x50>)
    e08e:	9b01      	ldr	r3, [sp, #4]
    e090:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e094:	2b00      	cmp	r3, #0
    e096:	d10d      	bne.n	e0b4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e098:	f7f2 fc70 	bl	97c <Adc_schm_read_msr>
    e09c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e09e:	9b00      	ldr	r3, [sp, #0]
    e0a0:	f003 0301 	and.w	r3, r3, #1
    e0a4:	2b00      	cmp	r3, #0
    e0a6:	d100      	bne.n	e0aa <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e0a8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_00[u32CoreId] = msr;
    e0aa:	490a      	ldr	r1, [pc, #40]	; (e0d4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_00+0x54>)
    e0ac:	9b01      	ldr	r3, [sp, #4]
    e0ae:	9a00      	ldr	r2, [sp, #0]
    e0b0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_00[u32CoreId]++;
    e0b4:	4a06      	ldr	r2, [pc, #24]	; (e0d0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_00+0x50>)
    e0b6:	9b01      	ldr	r3, [sp, #4]
    e0b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e0bc:	1c5a      	adds	r2, r3, #1
    e0be:	4904      	ldr	r1, [pc, #16]	; (e0d0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_00+0x50>)
    e0c0:	9b01      	ldr	r3, [sp, #4]
    e0c2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e0c6:	bf00      	nop
    e0c8:	b003      	add	sp, #12
    e0ca:	f85d fb04 	ldr.w	pc, [sp], #4
    e0ce:	bf00      	nop
    e0d0:	1fff9064 	.word	0x1fff9064
    e0d4:	1fff9060 	.word	0x1fff9060

0000e0d8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_00>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_00(void)
{
    e0d8:	b500      	push	{lr}
    e0da:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e0dc:	f7f2 fd5c 	bl	b98 <Sys_GetCoreID>
    e0e0:	4603      	mov	r3, r0
    e0e2:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_00[u32CoreId]--;
    e0e4:	4a0d      	ldr	r2, [pc, #52]	; (e11c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_00+0x44>)
    e0e6:	9b01      	ldr	r3, [sp, #4]
    e0e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e0ec:	1e5a      	subs	r2, r3, #1
    e0ee:	490b      	ldr	r1, [pc, #44]	; (e11c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_00+0x44>)
    e0f0:	9b01      	ldr	r3, [sp, #4]
    e0f2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
    e0f6:	4a0a      	ldr	r2, [pc, #40]	; (e120 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_00+0x48>)
    e0f8:	9b01      	ldr	r3, [sp, #4]
    e0fa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e0fe:	f003 0301 	and.w	r3, r3, #1
    e102:	2b00      	cmp	r3, #0
    e104:	d106      	bne.n	e114 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_00+0x3c>
    e106:	4a05      	ldr	r2, [pc, #20]	; (e11c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_00+0x44>)
    e108:	9b01      	ldr	r3, [sp, #4]
    e10a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e10e:	2b00      	cmp	r3, #0
    e110:	d100      	bne.n	e114 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    e112:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    e114:	bf00      	nop
    e116:	b003      	add	sp, #12
    e118:	f85d fb04 	ldr.w	pc, [sp], #4
    e11c:	1fff9064 	.word	0x1fff9064
    e120:	1fff9060 	.word	0x1fff9060

0000e124 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_01>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_01(void)
{
    e124:	b500      	push	{lr}
    e126:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e128:	f7f2 fd36 	bl	b98 <Sys_GetCoreID>
    e12c:	4603      	mov	r3, r0
    e12e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_01[u32CoreId])
    e130:	4a10      	ldr	r2, [pc, #64]	; (e174 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_01+0x50>)
    e132:	9b01      	ldr	r3, [sp, #4]
    e134:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e138:	2b00      	cmp	r3, #0
    e13a:	d10d      	bne.n	e158 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e13c:	f7f2 fc1e 	bl	97c <Adc_schm_read_msr>
    e140:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e142:	9b00      	ldr	r3, [sp, #0]
    e144:	f003 0301 	and.w	r3, r3, #1
    e148:	2b00      	cmp	r3, #0
    e14a:	d100      	bne.n	e14e <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e14c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_01[u32CoreId] = msr;
    e14e:	490a      	ldr	r1, [pc, #40]	; (e178 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_01+0x54>)
    e150:	9b01      	ldr	r3, [sp, #4]
    e152:	9a00      	ldr	r2, [sp, #0]
    e154:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_01[u32CoreId]++;
    e158:	4a06      	ldr	r2, [pc, #24]	; (e174 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_01+0x50>)
    e15a:	9b01      	ldr	r3, [sp, #4]
    e15c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e160:	1c5a      	adds	r2, r3, #1
    e162:	4904      	ldr	r1, [pc, #16]	; (e174 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_01+0x50>)
    e164:	9b01      	ldr	r3, [sp, #4]
    e166:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e16a:	bf00      	nop
    e16c:	b003      	add	sp, #12
    e16e:	f85d fb04 	ldr.w	pc, [sp], #4
    e172:	bf00      	nop
    e174:	1fff906c 	.word	0x1fff906c
    e178:	1fff9068 	.word	0x1fff9068

0000e17c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_01>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_01(void)
{
    e17c:	b500      	push	{lr}
    e17e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e180:	f7f2 fd0a 	bl	b98 <Sys_GetCoreID>
    e184:	4603      	mov	r3, r0
    e186:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_01[u32CoreId]--;
    e188:	4a0d      	ldr	r2, [pc, #52]	; (e1c0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_01+0x44>)
    e18a:	9b01      	ldr	r3, [sp, #4]
    e18c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e190:	1e5a      	subs	r2, r3, #1
    e192:	490b      	ldr	r1, [pc, #44]	; (e1c0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_01+0x44>)
    e194:	9b01      	ldr	r3, [sp, #4]
    e196:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
    e19a:	4a0a      	ldr	r2, [pc, #40]	; (e1c4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_01+0x48>)
    e19c:	9b01      	ldr	r3, [sp, #4]
    e19e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e1a2:	f003 0301 	and.w	r3, r3, #1
    e1a6:	2b00      	cmp	r3, #0
    e1a8:	d106      	bne.n	e1b8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_01+0x3c>
    e1aa:	4a05      	ldr	r2, [pc, #20]	; (e1c0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_01+0x44>)
    e1ac:	9b01      	ldr	r3, [sp, #4]
    e1ae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e1b2:	2b00      	cmp	r3, #0
    e1b4:	d100      	bne.n	e1b8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    e1b6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    e1b8:	bf00      	nop
    e1ba:	b003      	add	sp, #12
    e1bc:	f85d fb04 	ldr.w	pc, [sp], #4
    e1c0:	1fff906c 	.word	0x1fff906c
    e1c4:	1fff9068 	.word	0x1fff9068

0000e1c8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_02>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_02(void)
{
    e1c8:	b500      	push	{lr}
    e1ca:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e1cc:	f7f2 fce4 	bl	b98 <Sys_GetCoreID>
    e1d0:	4603      	mov	r3, r0
    e1d2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_02[u32CoreId])
    e1d4:	4a10      	ldr	r2, [pc, #64]	; (e218 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_02+0x50>)
    e1d6:	9b01      	ldr	r3, [sp, #4]
    e1d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e1dc:	2b00      	cmp	r3, #0
    e1de:	d10d      	bne.n	e1fc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_02+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e1e0:	f7f2 fbcc 	bl	97c <Adc_schm_read_msr>
    e1e4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e1e6:	9b00      	ldr	r3, [sp, #0]
    e1e8:	f003 0301 	and.w	r3, r3, #1
    e1ec:	2b00      	cmp	r3, #0
    e1ee:	d100      	bne.n	e1f2 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_02+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e1f0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_02[u32CoreId] = msr;
    e1f2:	490a      	ldr	r1, [pc, #40]	; (e21c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_02+0x54>)
    e1f4:	9b01      	ldr	r3, [sp, #4]
    e1f6:	9a00      	ldr	r2, [sp, #0]
    e1f8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_02[u32CoreId]++;
    e1fc:	4a06      	ldr	r2, [pc, #24]	; (e218 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_02+0x50>)
    e1fe:	9b01      	ldr	r3, [sp, #4]
    e200:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e204:	1c5a      	adds	r2, r3, #1
    e206:	4904      	ldr	r1, [pc, #16]	; (e218 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_02+0x50>)
    e208:	9b01      	ldr	r3, [sp, #4]
    e20a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e20e:	bf00      	nop
    e210:	b003      	add	sp, #12
    e212:	f85d fb04 	ldr.w	pc, [sp], #4
    e216:	bf00      	nop
    e218:	1fff9074 	.word	0x1fff9074
    e21c:	1fff9070 	.word	0x1fff9070

0000e220 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_02>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_02(void)
{
    e220:	b500      	push	{lr}
    e222:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e224:	f7f2 fcb8 	bl	b98 <Sys_GetCoreID>
    e228:	4603      	mov	r3, r0
    e22a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_02[u32CoreId]--;
    e22c:	4a0d      	ldr	r2, [pc, #52]	; (e264 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_02+0x44>)
    e22e:	9b01      	ldr	r3, [sp, #4]
    e230:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e234:	1e5a      	subs	r2, r3, #1
    e236:	490b      	ldr	r1, [pc, #44]	; (e264 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_02+0x44>)
    e238:	9b01      	ldr	r3, [sp, #4]
    e23a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_02[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_02[u32CoreId]))         /*if interrupts were enabled*/
    e23e:	4a0a      	ldr	r2, [pc, #40]	; (e268 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_02+0x48>)
    e240:	9b01      	ldr	r3, [sp, #4]
    e242:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e246:	f003 0301 	and.w	r3, r3, #1
    e24a:	2b00      	cmp	r3, #0
    e24c:	d106      	bne.n	e25c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_02+0x3c>
    e24e:	4a05      	ldr	r2, [pc, #20]	; (e264 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_02+0x44>)
    e250:	9b01      	ldr	r3, [sp, #4]
    e252:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e256:	2b00      	cmp	r3, #0
    e258:	d100      	bne.n	e25c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_02+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    e25a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    e25c:	bf00      	nop
    e25e:	b003      	add	sp, #12
    e260:	f85d fb04 	ldr.w	pc, [sp], #4
    e264:	1fff9074 	.word	0x1fff9074
    e268:	1fff9070 	.word	0x1fff9070

0000e26c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_03>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_03(void)
{
    e26c:	b500      	push	{lr}
    e26e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e270:	f7f2 fc92 	bl	b98 <Sys_GetCoreID>
    e274:	4603      	mov	r3, r0
    e276:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_03[u32CoreId])
    e278:	4a10      	ldr	r2, [pc, #64]	; (e2bc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_03+0x50>)
    e27a:	9b01      	ldr	r3, [sp, #4]
    e27c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e280:	2b00      	cmp	r3, #0
    e282:	d10d      	bne.n	e2a0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_03+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e284:	f7f2 fb7a 	bl	97c <Adc_schm_read_msr>
    e288:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e28a:	9b00      	ldr	r3, [sp, #0]
    e28c:	f003 0301 	and.w	r3, r3, #1
    e290:	2b00      	cmp	r3, #0
    e292:	d100      	bne.n	e296 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_03+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e294:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_03[u32CoreId] = msr;
    e296:	490a      	ldr	r1, [pc, #40]	; (e2c0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_03+0x54>)
    e298:	9b01      	ldr	r3, [sp, #4]
    e29a:	9a00      	ldr	r2, [sp, #0]
    e29c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_03[u32CoreId]++;
    e2a0:	4a06      	ldr	r2, [pc, #24]	; (e2bc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_03+0x50>)
    e2a2:	9b01      	ldr	r3, [sp, #4]
    e2a4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e2a8:	1c5a      	adds	r2, r3, #1
    e2aa:	4904      	ldr	r1, [pc, #16]	; (e2bc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_03+0x50>)
    e2ac:	9b01      	ldr	r3, [sp, #4]
    e2ae:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e2b2:	bf00      	nop
    e2b4:	b003      	add	sp, #12
    e2b6:	f85d fb04 	ldr.w	pc, [sp], #4
    e2ba:	bf00      	nop
    e2bc:	1fff907c 	.word	0x1fff907c
    e2c0:	1fff9078 	.word	0x1fff9078

0000e2c4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_03>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_03(void)
{
    e2c4:	b500      	push	{lr}
    e2c6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e2c8:	f7f2 fc66 	bl	b98 <Sys_GetCoreID>
    e2cc:	4603      	mov	r3, r0
    e2ce:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_03[u32CoreId]--;
    e2d0:	4a0d      	ldr	r2, [pc, #52]	; (e308 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_03+0x44>)
    e2d2:	9b01      	ldr	r3, [sp, #4]
    e2d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e2d8:	1e5a      	subs	r2, r3, #1
    e2da:	490b      	ldr	r1, [pc, #44]	; (e308 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_03+0x44>)
    e2dc:	9b01      	ldr	r3, [sp, #4]
    e2de:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_03[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_03[u32CoreId]))         /*if interrupts were enabled*/
    e2e2:	4a0a      	ldr	r2, [pc, #40]	; (e30c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_03+0x48>)
    e2e4:	9b01      	ldr	r3, [sp, #4]
    e2e6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e2ea:	f003 0301 	and.w	r3, r3, #1
    e2ee:	2b00      	cmp	r3, #0
    e2f0:	d106      	bne.n	e300 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_03+0x3c>
    e2f2:	4a05      	ldr	r2, [pc, #20]	; (e308 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_03+0x44>)
    e2f4:	9b01      	ldr	r3, [sp, #4]
    e2f6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e2fa:	2b00      	cmp	r3, #0
    e2fc:	d100      	bne.n	e300 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_03+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    e2fe:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    e300:	bf00      	nop
    e302:	b003      	add	sp, #12
    e304:	f85d fb04 	ldr.w	pc, [sp], #4
    e308:	1fff907c 	.word	0x1fff907c
    e30c:	1fff9078 	.word	0x1fff9078

0000e310 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_04>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_04(void)
{
    e310:	b500      	push	{lr}
    e312:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e314:	f7f2 fc40 	bl	b98 <Sys_GetCoreID>
    e318:	4603      	mov	r3, r0
    e31a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_04[u32CoreId])
    e31c:	4a10      	ldr	r2, [pc, #64]	; (e360 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_04+0x50>)
    e31e:	9b01      	ldr	r3, [sp, #4]
    e320:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e324:	2b00      	cmp	r3, #0
    e326:	d10d      	bne.n	e344 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_04+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e328:	f7f2 fb28 	bl	97c <Adc_schm_read_msr>
    e32c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e32e:	9b00      	ldr	r3, [sp, #0]
    e330:	f003 0301 	and.w	r3, r3, #1
    e334:	2b00      	cmp	r3, #0
    e336:	d100      	bne.n	e33a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_04+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e338:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_04[u32CoreId] = msr;
    e33a:	490a      	ldr	r1, [pc, #40]	; (e364 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_04+0x54>)
    e33c:	9b01      	ldr	r3, [sp, #4]
    e33e:	9a00      	ldr	r2, [sp, #0]
    e340:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_04[u32CoreId]++;
    e344:	4a06      	ldr	r2, [pc, #24]	; (e360 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_04+0x50>)
    e346:	9b01      	ldr	r3, [sp, #4]
    e348:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e34c:	1c5a      	adds	r2, r3, #1
    e34e:	4904      	ldr	r1, [pc, #16]	; (e360 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_04+0x50>)
    e350:	9b01      	ldr	r3, [sp, #4]
    e352:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e356:	bf00      	nop
    e358:	b003      	add	sp, #12
    e35a:	f85d fb04 	ldr.w	pc, [sp], #4
    e35e:	bf00      	nop
    e360:	1fff9084 	.word	0x1fff9084
    e364:	1fff9080 	.word	0x1fff9080

0000e368 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_04>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_04(void)
{
    e368:	b500      	push	{lr}
    e36a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e36c:	f7f2 fc14 	bl	b98 <Sys_GetCoreID>
    e370:	4603      	mov	r3, r0
    e372:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_04[u32CoreId]--;
    e374:	4a0d      	ldr	r2, [pc, #52]	; (e3ac <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_04+0x44>)
    e376:	9b01      	ldr	r3, [sp, #4]
    e378:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e37c:	1e5a      	subs	r2, r3, #1
    e37e:	490b      	ldr	r1, [pc, #44]	; (e3ac <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_04+0x44>)
    e380:	9b01      	ldr	r3, [sp, #4]
    e382:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_04[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_04[u32CoreId]))         /*if interrupts were enabled*/
    e386:	4a0a      	ldr	r2, [pc, #40]	; (e3b0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_04+0x48>)
    e388:	9b01      	ldr	r3, [sp, #4]
    e38a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e38e:	f003 0301 	and.w	r3, r3, #1
    e392:	2b00      	cmp	r3, #0
    e394:	d106      	bne.n	e3a4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_04+0x3c>
    e396:	4a05      	ldr	r2, [pc, #20]	; (e3ac <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_04+0x44>)
    e398:	9b01      	ldr	r3, [sp, #4]
    e39a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e39e:	2b00      	cmp	r3, #0
    e3a0:	d100      	bne.n	e3a4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_04+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    e3a2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    e3a4:	bf00      	nop
    e3a6:	b003      	add	sp, #12
    e3a8:	f85d fb04 	ldr.w	pc, [sp], #4
    e3ac:	1fff9084 	.word	0x1fff9084
    e3b0:	1fff9080 	.word	0x1fff9080

0000e3b4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_05>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_05(void)
{
    e3b4:	b500      	push	{lr}
    e3b6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e3b8:	f7f2 fbee 	bl	b98 <Sys_GetCoreID>
    e3bc:	4603      	mov	r3, r0
    e3be:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_05[u32CoreId])
    e3c0:	4a10      	ldr	r2, [pc, #64]	; (e404 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_05+0x50>)
    e3c2:	9b01      	ldr	r3, [sp, #4]
    e3c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e3c8:	2b00      	cmp	r3, #0
    e3ca:	d10d      	bne.n	e3e8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_05+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e3cc:	f7f2 fad6 	bl	97c <Adc_schm_read_msr>
    e3d0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e3d2:	9b00      	ldr	r3, [sp, #0]
    e3d4:	f003 0301 	and.w	r3, r3, #1
    e3d8:	2b00      	cmp	r3, #0
    e3da:	d100      	bne.n	e3de <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_05+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e3dc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_05[u32CoreId] = msr;
    e3de:	490a      	ldr	r1, [pc, #40]	; (e408 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_05+0x54>)
    e3e0:	9b01      	ldr	r3, [sp, #4]
    e3e2:	9a00      	ldr	r2, [sp, #0]
    e3e4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_05[u32CoreId]++;
    e3e8:	4a06      	ldr	r2, [pc, #24]	; (e404 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_05+0x50>)
    e3ea:	9b01      	ldr	r3, [sp, #4]
    e3ec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e3f0:	1c5a      	adds	r2, r3, #1
    e3f2:	4904      	ldr	r1, [pc, #16]	; (e404 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_05+0x50>)
    e3f4:	9b01      	ldr	r3, [sp, #4]
    e3f6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e3fa:	bf00      	nop
    e3fc:	b003      	add	sp, #12
    e3fe:	f85d fb04 	ldr.w	pc, [sp], #4
    e402:	bf00      	nop
    e404:	1fff908c 	.word	0x1fff908c
    e408:	1fff9088 	.word	0x1fff9088

0000e40c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_05>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_05(void)
{
    e40c:	b500      	push	{lr}
    e40e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e410:	f7f2 fbc2 	bl	b98 <Sys_GetCoreID>
    e414:	4603      	mov	r3, r0
    e416:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_05[u32CoreId]--;
    e418:	4a0d      	ldr	r2, [pc, #52]	; (e450 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_05+0x44>)
    e41a:	9b01      	ldr	r3, [sp, #4]
    e41c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e420:	1e5a      	subs	r2, r3, #1
    e422:	490b      	ldr	r1, [pc, #44]	; (e450 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_05+0x44>)
    e424:	9b01      	ldr	r3, [sp, #4]
    e426:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_05[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_05[u32CoreId]))         /*if interrupts were enabled*/
    e42a:	4a0a      	ldr	r2, [pc, #40]	; (e454 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_05+0x48>)
    e42c:	9b01      	ldr	r3, [sp, #4]
    e42e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e432:	f003 0301 	and.w	r3, r3, #1
    e436:	2b00      	cmp	r3, #0
    e438:	d106      	bne.n	e448 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_05+0x3c>
    e43a:	4a05      	ldr	r2, [pc, #20]	; (e450 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_05+0x44>)
    e43c:	9b01      	ldr	r3, [sp, #4]
    e43e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e442:	2b00      	cmp	r3, #0
    e444:	d100      	bne.n	e448 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_05+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    e446:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    e448:	bf00      	nop
    e44a:	b003      	add	sp, #12
    e44c:	f85d fb04 	ldr.w	pc, [sp], #4
    e450:	1fff908c 	.word	0x1fff908c
    e454:	1fff9088 	.word	0x1fff9088

0000e458 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_10>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_10(void)
{
    e458:	b500      	push	{lr}
    e45a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e45c:	f7f2 fb9c 	bl	b98 <Sys_GetCoreID>
    e460:	4603      	mov	r3, r0
    e462:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_10[u32CoreId])
    e464:	4a10      	ldr	r2, [pc, #64]	; (e4a8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_10+0x50>)
    e466:	9b01      	ldr	r3, [sp, #4]
    e468:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e46c:	2b00      	cmp	r3, #0
    e46e:	d10d      	bne.n	e48c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_10+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e470:	f7f2 fa84 	bl	97c <Adc_schm_read_msr>
    e474:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e476:	9b00      	ldr	r3, [sp, #0]
    e478:	f003 0301 	and.w	r3, r3, #1
    e47c:	2b00      	cmp	r3, #0
    e47e:	d100      	bne.n	e482 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_10+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e480:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_10[u32CoreId] = msr;
    e482:	490a      	ldr	r1, [pc, #40]	; (e4ac <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_10+0x54>)
    e484:	9b01      	ldr	r3, [sp, #4]
    e486:	9a00      	ldr	r2, [sp, #0]
    e488:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_10[u32CoreId]++;
    e48c:	4a06      	ldr	r2, [pc, #24]	; (e4a8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_10+0x50>)
    e48e:	9b01      	ldr	r3, [sp, #4]
    e490:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e494:	1c5a      	adds	r2, r3, #1
    e496:	4904      	ldr	r1, [pc, #16]	; (e4a8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_10+0x50>)
    e498:	9b01      	ldr	r3, [sp, #4]
    e49a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e49e:	bf00      	nop
    e4a0:	b003      	add	sp, #12
    e4a2:	f85d fb04 	ldr.w	pc, [sp], #4
    e4a6:	bf00      	nop
    e4a8:	1fff9094 	.word	0x1fff9094
    e4ac:	1fff9090 	.word	0x1fff9090

0000e4b0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_10>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_10(void)
{
    e4b0:	b500      	push	{lr}
    e4b2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e4b4:	f7f2 fb70 	bl	b98 <Sys_GetCoreID>
    e4b8:	4603      	mov	r3, r0
    e4ba:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_10[u32CoreId]--;
    e4bc:	4a0d      	ldr	r2, [pc, #52]	; (e4f4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_10+0x44>)
    e4be:	9b01      	ldr	r3, [sp, #4]
    e4c0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e4c4:	1e5a      	subs	r2, r3, #1
    e4c6:	490b      	ldr	r1, [pc, #44]	; (e4f4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_10+0x44>)
    e4c8:	9b01      	ldr	r3, [sp, #4]
    e4ca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_10[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_10[u32CoreId]))         /*if interrupts were enabled*/
    e4ce:	4a0a      	ldr	r2, [pc, #40]	; (e4f8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_10+0x48>)
    e4d0:	9b01      	ldr	r3, [sp, #4]
    e4d2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e4d6:	f003 0301 	and.w	r3, r3, #1
    e4da:	2b00      	cmp	r3, #0
    e4dc:	d106      	bne.n	e4ec <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_10+0x3c>
    e4de:	4a05      	ldr	r2, [pc, #20]	; (e4f4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_10+0x44>)
    e4e0:	9b01      	ldr	r3, [sp, #4]
    e4e2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e4e6:	2b00      	cmp	r3, #0
    e4e8:	d100      	bne.n	e4ec <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_10+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    e4ea:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    e4ec:	bf00      	nop
    e4ee:	b003      	add	sp, #12
    e4f0:	f85d fb04 	ldr.w	pc, [sp], #4
    e4f4:	1fff9094 	.word	0x1fff9094
    e4f8:	1fff9090 	.word	0x1fff9090

0000e4fc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_100>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_100(void)
{
    e4fc:	b500      	push	{lr}
    e4fe:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e500:	f7f2 fb4a 	bl	b98 <Sys_GetCoreID>
    e504:	4603      	mov	r3, r0
    e506:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_100[u32CoreId])
    e508:	4a10      	ldr	r2, [pc, #64]	; (e54c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_100+0x50>)
    e50a:	9b01      	ldr	r3, [sp, #4]
    e50c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e510:	2b00      	cmp	r3, #0
    e512:	d10d      	bne.n	e530 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_100+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e514:	f7f2 fa32 	bl	97c <Adc_schm_read_msr>
    e518:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e51a:	9b00      	ldr	r3, [sp, #0]
    e51c:	f003 0301 	and.w	r3, r3, #1
    e520:	2b00      	cmp	r3, #0
    e522:	d100      	bne.n	e526 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_100+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e524:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_100[u32CoreId] = msr;
    e526:	490a      	ldr	r1, [pc, #40]	; (e550 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_100+0x54>)
    e528:	9b01      	ldr	r3, [sp, #4]
    e52a:	9a00      	ldr	r2, [sp, #0]
    e52c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_100[u32CoreId]++;
    e530:	4a06      	ldr	r2, [pc, #24]	; (e54c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_100+0x50>)
    e532:	9b01      	ldr	r3, [sp, #4]
    e534:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e538:	1c5a      	adds	r2, r3, #1
    e53a:	4904      	ldr	r1, [pc, #16]	; (e54c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_100+0x50>)
    e53c:	9b01      	ldr	r3, [sp, #4]
    e53e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e542:	bf00      	nop
    e544:	b003      	add	sp, #12
    e546:	f85d fb04 	ldr.w	pc, [sp], #4
    e54a:	bf00      	nop
    e54c:	1fff909c 	.word	0x1fff909c
    e550:	1fff9098 	.word	0x1fff9098

0000e554 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_100>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_100(void)
{
    e554:	b500      	push	{lr}
    e556:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e558:	f7f2 fb1e 	bl	b98 <Sys_GetCoreID>
    e55c:	4603      	mov	r3, r0
    e55e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_100[u32CoreId]--;
    e560:	4a0d      	ldr	r2, [pc, #52]	; (e598 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_100+0x44>)
    e562:	9b01      	ldr	r3, [sp, #4]
    e564:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e568:	1e5a      	subs	r2, r3, #1
    e56a:	490b      	ldr	r1, [pc, #44]	; (e598 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_100+0x44>)
    e56c:	9b01      	ldr	r3, [sp, #4]
    e56e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_100[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_100[u32CoreId]))         /*if interrupts were enabled*/
    e572:	4a0a      	ldr	r2, [pc, #40]	; (e59c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_100+0x48>)
    e574:	9b01      	ldr	r3, [sp, #4]
    e576:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e57a:	f003 0301 	and.w	r3, r3, #1
    e57e:	2b00      	cmp	r3, #0
    e580:	d106      	bne.n	e590 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_100+0x3c>
    e582:	4a05      	ldr	r2, [pc, #20]	; (e598 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_100+0x44>)
    e584:	9b01      	ldr	r3, [sp, #4]
    e586:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e58a:	2b00      	cmp	r3, #0
    e58c:	d100      	bne.n	e590 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_100+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    e58e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    e590:	bf00      	nop
    e592:	b003      	add	sp, #12
    e594:	f85d fb04 	ldr.w	pc, [sp], #4
    e598:	1fff909c 	.word	0x1fff909c
    e59c:	1fff9098 	.word	0x1fff9098

0000e5a0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_101>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_101(void)
{
    e5a0:	b500      	push	{lr}
    e5a2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e5a4:	f7f2 faf8 	bl	b98 <Sys_GetCoreID>
    e5a8:	4603      	mov	r3, r0
    e5aa:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_101[u32CoreId])
    e5ac:	4a10      	ldr	r2, [pc, #64]	; (e5f0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_101+0x50>)
    e5ae:	9b01      	ldr	r3, [sp, #4]
    e5b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e5b4:	2b00      	cmp	r3, #0
    e5b6:	d10d      	bne.n	e5d4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_101+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e5b8:	f7f2 f9e0 	bl	97c <Adc_schm_read_msr>
    e5bc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e5be:	9b00      	ldr	r3, [sp, #0]
    e5c0:	f003 0301 	and.w	r3, r3, #1
    e5c4:	2b00      	cmp	r3, #0
    e5c6:	d100      	bne.n	e5ca <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_101+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e5c8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_101[u32CoreId] = msr;
    e5ca:	490a      	ldr	r1, [pc, #40]	; (e5f4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_101+0x54>)
    e5cc:	9b01      	ldr	r3, [sp, #4]
    e5ce:	9a00      	ldr	r2, [sp, #0]
    e5d0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_101[u32CoreId]++;
    e5d4:	4a06      	ldr	r2, [pc, #24]	; (e5f0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_101+0x50>)
    e5d6:	9b01      	ldr	r3, [sp, #4]
    e5d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e5dc:	1c5a      	adds	r2, r3, #1
    e5de:	4904      	ldr	r1, [pc, #16]	; (e5f0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_101+0x50>)
    e5e0:	9b01      	ldr	r3, [sp, #4]
    e5e2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e5e6:	bf00      	nop
    e5e8:	b003      	add	sp, #12
    e5ea:	f85d fb04 	ldr.w	pc, [sp], #4
    e5ee:	bf00      	nop
    e5f0:	1fff90a4 	.word	0x1fff90a4
    e5f4:	1fff90a0 	.word	0x1fff90a0

0000e5f8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_101>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_101(void)
{
    e5f8:	b500      	push	{lr}
    e5fa:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e5fc:	f7f2 facc 	bl	b98 <Sys_GetCoreID>
    e600:	4603      	mov	r3, r0
    e602:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_101[u32CoreId]--;
    e604:	4a0d      	ldr	r2, [pc, #52]	; (e63c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_101+0x44>)
    e606:	9b01      	ldr	r3, [sp, #4]
    e608:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e60c:	1e5a      	subs	r2, r3, #1
    e60e:	490b      	ldr	r1, [pc, #44]	; (e63c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_101+0x44>)
    e610:	9b01      	ldr	r3, [sp, #4]
    e612:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_101[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_101[u32CoreId]))         /*if interrupts were enabled*/
    e616:	4a0a      	ldr	r2, [pc, #40]	; (e640 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_101+0x48>)
    e618:	9b01      	ldr	r3, [sp, #4]
    e61a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e61e:	f003 0301 	and.w	r3, r3, #1
    e622:	2b00      	cmp	r3, #0
    e624:	d106      	bne.n	e634 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_101+0x3c>
    e626:	4a05      	ldr	r2, [pc, #20]	; (e63c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_101+0x44>)
    e628:	9b01      	ldr	r3, [sp, #4]
    e62a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e62e:	2b00      	cmp	r3, #0
    e630:	d100      	bne.n	e634 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_101+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    e632:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    e634:	bf00      	nop
    e636:	b003      	add	sp, #12
    e638:	f85d fb04 	ldr.w	pc, [sp], #4
    e63c:	1fff90a4 	.word	0x1fff90a4
    e640:	1fff90a0 	.word	0x1fff90a0

0000e644 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_102>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_102(void)
{
    e644:	b500      	push	{lr}
    e646:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e648:	f7f2 faa6 	bl	b98 <Sys_GetCoreID>
    e64c:	4603      	mov	r3, r0
    e64e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_102[u32CoreId])
    e650:	4a10      	ldr	r2, [pc, #64]	; (e694 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_102+0x50>)
    e652:	9b01      	ldr	r3, [sp, #4]
    e654:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e658:	2b00      	cmp	r3, #0
    e65a:	d10d      	bne.n	e678 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_102+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e65c:	f7f2 f98e 	bl	97c <Adc_schm_read_msr>
    e660:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e662:	9b00      	ldr	r3, [sp, #0]
    e664:	f003 0301 	and.w	r3, r3, #1
    e668:	2b00      	cmp	r3, #0
    e66a:	d100      	bne.n	e66e <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_102+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e66c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_102[u32CoreId] = msr;
    e66e:	490a      	ldr	r1, [pc, #40]	; (e698 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_102+0x54>)
    e670:	9b01      	ldr	r3, [sp, #4]
    e672:	9a00      	ldr	r2, [sp, #0]
    e674:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_102[u32CoreId]++;
    e678:	4a06      	ldr	r2, [pc, #24]	; (e694 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_102+0x50>)
    e67a:	9b01      	ldr	r3, [sp, #4]
    e67c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e680:	1c5a      	adds	r2, r3, #1
    e682:	4904      	ldr	r1, [pc, #16]	; (e694 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_102+0x50>)
    e684:	9b01      	ldr	r3, [sp, #4]
    e686:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e68a:	bf00      	nop
    e68c:	b003      	add	sp, #12
    e68e:	f85d fb04 	ldr.w	pc, [sp], #4
    e692:	bf00      	nop
    e694:	1fff90ac 	.word	0x1fff90ac
    e698:	1fff90a8 	.word	0x1fff90a8

0000e69c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_102>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_102(void)
{
    e69c:	b500      	push	{lr}
    e69e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e6a0:	f7f2 fa7a 	bl	b98 <Sys_GetCoreID>
    e6a4:	4603      	mov	r3, r0
    e6a6:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_102[u32CoreId]--;
    e6a8:	4a0d      	ldr	r2, [pc, #52]	; (e6e0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_102+0x44>)
    e6aa:	9b01      	ldr	r3, [sp, #4]
    e6ac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e6b0:	1e5a      	subs	r2, r3, #1
    e6b2:	490b      	ldr	r1, [pc, #44]	; (e6e0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_102+0x44>)
    e6b4:	9b01      	ldr	r3, [sp, #4]
    e6b6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_102[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_102[u32CoreId]))         /*if interrupts were enabled*/
    e6ba:	4a0a      	ldr	r2, [pc, #40]	; (e6e4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_102+0x48>)
    e6bc:	9b01      	ldr	r3, [sp, #4]
    e6be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e6c2:	f003 0301 	and.w	r3, r3, #1
    e6c6:	2b00      	cmp	r3, #0
    e6c8:	d106      	bne.n	e6d8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_102+0x3c>
    e6ca:	4a05      	ldr	r2, [pc, #20]	; (e6e0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_102+0x44>)
    e6cc:	9b01      	ldr	r3, [sp, #4]
    e6ce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e6d2:	2b00      	cmp	r3, #0
    e6d4:	d100      	bne.n	e6d8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_102+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    e6d6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    e6d8:	bf00      	nop
    e6da:	b003      	add	sp, #12
    e6dc:	f85d fb04 	ldr.w	pc, [sp], #4
    e6e0:	1fff90ac 	.word	0x1fff90ac
    e6e4:	1fff90a8 	.word	0x1fff90a8

0000e6e8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_103>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_103(void)
{
    e6e8:	b500      	push	{lr}
    e6ea:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e6ec:	f7f2 fa54 	bl	b98 <Sys_GetCoreID>
    e6f0:	4603      	mov	r3, r0
    e6f2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_103[u32CoreId])
    e6f4:	4a10      	ldr	r2, [pc, #64]	; (e738 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_103+0x50>)
    e6f6:	9b01      	ldr	r3, [sp, #4]
    e6f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e6fc:	2b00      	cmp	r3, #0
    e6fe:	d10d      	bne.n	e71c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_103+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e700:	f7f2 f93c 	bl	97c <Adc_schm_read_msr>
    e704:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e706:	9b00      	ldr	r3, [sp, #0]
    e708:	f003 0301 	and.w	r3, r3, #1
    e70c:	2b00      	cmp	r3, #0
    e70e:	d100      	bne.n	e712 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_103+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e710:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_103[u32CoreId] = msr;
    e712:	490a      	ldr	r1, [pc, #40]	; (e73c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_103+0x54>)
    e714:	9b01      	ldr	r3, [sp, #4]
    e716:	9a00      	ldr	r2, [sp, #0]
    e718:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_103[u32CoreId]++;
    e71c:	4a06      	ldr	r2, [pc, #24]	; (e738 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_103+0x50>)
    e71e:	9b01      	ldr	r3, [sp, #4]
    e720:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e724:	1c5a      	adds	r2, r3, #1
    e726:	4904      	ldr	r1, [pc, #16]	; (e738 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_103+0x50>)
    e728:	9b01      	ldr	r3, [sp, #4]
    e72a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e72e:	bf00      	nop
    e730:	b003      	add	sp, #12
    e732:	f85d fb04 	ldr.w	pc, [sp], #4
    e736:	bf00      	nop
    e738:	1fff90b4 	.word	0x1fff90b4
    e73c:	1fff90b0 	.word	0x1fff90b0

0000e740 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_103>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_103(void)
{
    e740:	b500      	push	{lr}
    e742:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e744:	f7f2 fa28 	bl	b98 <Sys_GetCoreID>
    e748:	4603      	mov	r3, r0
    e74a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_103[u32CoreId]--;
    e74c:	4a0d      	ldr	r2, [pc, #52]	; (e784 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_103+0x44>)
    e74e:	9b01      	ldr	r3, [sp, #4]
    e750:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e754:	1e5a      	subs	r2, r3, #1
    e756:	490b      	ldr	r1, [pc, #44]	; (e784 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_103+0x44>)
    e758:	9b01      	ldr	r3, [sp, #4]
    e75a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_103[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_103[u32CoreId]))         /*if interrupts were enabled*/
    e75e:	4a0a      	ldr	r2, [pc, #40]	; (e788 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_103+0x48>)
    e760:	9b01      	ldr	r3, [sp, #4]
    e762:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e766:	f003 0301 	and.w	r3, r3, #1
    e76a:	2b00      	cmp	r3, #0
    e76c:	d106      	bne.n	e77c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_103+0x3c>
    e76e:	4a05      	ldr	r2, [pc, #20]	; (e784 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_103+0x44>)
    e770:	9b01      	ldr	r3, [sp, #4]
    e772:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e776:	2b00      	cmp	r3, #0
    e778:	d100      	bne.n	e77c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_103+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    e77a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    e77c:	bf00      	nop
    e77e:	b003      	add	sp, #12
    e780:	f85d fb04 	ldr.w	pc, [sp], #4
    e784:	1fff90b4 	.word	0x1fff90b4
    e788:	1fff90b0 	.word	0x1fff90b0

0000e78c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_11>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_11(void)
{
    e78c:	b500      	push	{lr}
    e78e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e790:	f7f2 fa02 	bl	b98 <Sys_GetCoreID>
    e794:	4603      	mov	r3, r0
    e796:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_11[u32CoreId])
    e798:	4a10      	ldr	r2, [pc, #64]	; (e7dc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_11+0x50>)
    e79a:	9b01      	ldr	r3, [sp, #4]
    e79c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e7a0:	2b00      	cmp	r3, #0
    e7a2:	d10d      	bne.n	e7c0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_11+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e7a4:	f7f2 f8ea 	bl	97c <Adc_schm_read_msr>
    e7a8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e7aa:	9b00      	ldr	r3, [sp, #0]
    e7ac:	f003 0301 	and.w	r3, r3, #1
    e7b0:	2b00      	cmp	r3, #0
    e7b2:	d100      	bne.n	e7b6 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_11+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e7b4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_11[u32CoreId] = msr;
    e7b6:	490a      	ldr	r1, [pc, #40]	; (e7e0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_11+0x54>)
    e7b8:	9b01      	ldr	r3, [sp, #4]
    e7ba:	9a00      	ldr	r2, [sp, #0]
    e7bc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_11[u32CoreId]++;
    e7c0:	4a06      	ldr	r2, [pc, #24]	; (e7dc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_11+0x50>)
    e7c2:	9b01      	ldr	r3, [sp, #4]
    e7c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e7c8:	1c5a      	adds	r2, r3, #1
    e7ca:	4904      	ldr	r1, [pc, #16]	; (e7dc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_11+0x50>)
    e7cc:	9b01      	ldr	r3, [sp, #4]
    e7ce:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e7d2:	bf00      	nop
    e7d4:	b003      	add	sp, #12
    e7d6:	f85d fb04 	ldr.w	pc, [sp], #4
    e7da:	bf00      	nop
    e7dc:	1fff90bc 	.word	0x1fff90bc
    e7e0:	1fff90b8 	.word	0x1fff90b8

0000e7e4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_11>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_11(void)
{
    e7e4:	b500      	push	{lr}
    e7e6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e7e8:	f7f2 f9d6 	bl	b98 <Sys_GetCoreID>
    e7ec:	4603      	mov	r3, r0
    e7ee:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_11[u32CoreId]--;
    e7f0:	4a0d      	ldr	r2, [pc, #52]	; (e828 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_11+0x44>)
    e7f2:	9b01      	ldr	r3, [sp, #4]
    e7f4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e7f8:	1e5a      	subs	r2, r3, #1
    e7fa:	490b      	ldr	r1, [pc, #44]	; (e828 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_11+0x44>)
    e7fc:	9b01      	ldr	r3, [sp, #4]
    e7fe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_11[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_11[u32CoreId]))         /*if interrupts were enabled*/
    e802:	4a0a      	ldr	r2, [pc, #40]	; (e82c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_11+0x48>)
    e804:	9b01      	ldr	r3, [sp, #4]
    e806:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e80a:	f003 0301 	and.w	r3, r3, #1
    e80e:	2b00      	cmp	r3, #0
    e810:	d106      	bne.n	e820 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_11+0x3c>
    e812:	4a05      	ldr	r2, [pc, #20]	; (e828 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_11+0x44>)
    e814:	9b01      	ldr	r3, [sp, #4]
    e816:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e81a:	2b00      	cmp	r3, #0
    e81c:	d100      	bne.n	e820 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_11+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    e81e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    e820:	bf00      	nop
    e822:	b003      	add	sp, #12
    e824:	f85d fb04 	ldr.w	pc, [sp], #4
    e828:	1fff90bc 	.word	0x1fff90bc
    e82c:	1fff90b8 	.word	0x1fff90b8

0000e830 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_12>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_12(void)
{
    e830:	b500      	push	{lr}
    e832:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e834:	f7f2 f9b0 	bl	b98 <Sys_GetCoreID>
    e838:	4603      	mov	r3, r0
    e83a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_12[u32CoreId])
    e83c:	4a10      	ldr	r2, [pc, #64]	; (e880 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_12+0x50>)
    e83e:	9b01      	ldr	r3, [sp, #4]
    e840:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e844:	2b00      	cmp	r3, #0
    e846:	d10d      	bne.n	e864 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_12+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e848:	f7f2 f898 	bl	97c <Adc_schm_read_msr>
    e84c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e84e:	9b00      	ldr	r3, [sp, #0]
    e850:	f003 0301 	and.w	r3, r3, #1
    e854:	2b00      	cmp	r3, #0
    e856:	d100      	bne.n	e85a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_12+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e858:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_12[u32CoreId] = msr;
    e85a:	490a      	ldr	r1, [pc, #40]	; (e884 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_12+0x54>)
    e85c:	9b01      	ldr	r3, [sp, #4]
    e85e:	9a00      	ldr	r2, [sp, #0]
    e860:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_12[u32CoreId]++;
    e864:	4a06      	ldr	r2, [pc, #24]	; (e880 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_12+0x50>)
    e866:	9b01      	ldr	r3, [sp, #4]
    e868:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e86c:	1c5a      	adds	r2, r3, #1
    e86e:	4904      	ldr	r1, [pc, #16]	; (e880 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_12+0x50>)
    e870:	9b01      	ldr	r3, [sp, #4]
    e872:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e876:	bf00      	nop
    e878:	b003      	add	sp, #12
    e87a:	f85d fb04 	ldr.w	pc, [sp], #4
    e87e:	bf00      	nop
    e880:	1fff90c4 	.word	0x1fff90c4
    e884:	1fff90c0 	.word	0x1fff90c0

0000e888 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_12>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_12(void)
{
    e888:	b500      	push	{lr}
    e88a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e88c:	f7f2 f984 	bl	b98 <Sys_GetCoreID>
    e890:	4603      	mov	r3, r0
    e892:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_12[u32CoreId]--;
    e894:	4a0d      	ldr	r2, [pc, #52]	; (e8cc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_12+0x44>)
    e896:	9b01      	ldr	r3, [sp, #4]
    e898:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e89c:	1e5a      	subs	r2, r3, #1
    e89e:	490b      	ldr	r1, [pc, #44]	; (e8cc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_12+0x44>)
    e8a0:	9b01      	ldr	r3, [sp, #4]
    e8a2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_12[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_12[u32CoreId]))         /*if interrupts were enabled*/
    e8a6:	4a0a      	ldr	r2, [pc, #40]	; (e8d0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_12+0x48>)
    e8a8:	9b01      	ldr	r3, [sp, #4]
    e8aa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e8ae:	f003 0301 	and.w	r3, r3, #1
    e8b2:	2b00      	cmp	r3, #0
    e8b4:	d106      	bne.n	e8c4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_12+0x3c>
    e8b6:	4a05      	ldr	r2, [pc, #20]	; (e8cc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_12+0x44>)
    e8b8:	9b01      	ldr	r3, [sp, #4]
    e8ba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e8be:	2b00      	cmp	r3, #0
    e8c0:	d100      	bne.n	e8c4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_12+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    e8c2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    e8c4:	bf00      	nop
    e8c6:	b003      	add	sp, #12
    e8c8:	f85d fb04 	ldr.w	pc, [sp], #4
    e8cc:	1fff90c4 	.word	0x1fff90c4
    e8d0:	1fff90c0 	.word	0x1fff90c0

0000e8d4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_13>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_13(void)
{
    e8d4:	b500      	push	{lr}
    e8d6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e8d8:	f7f2 f95e 	bl	b98 <Sys_GetCoreID>
    e8dc:	4603      	mov	r3, r0
    e8de:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_13[u32CoreId])
    e8e0:	4a10      	ldr	r2, [pc, #64]	; (e924 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_13+0x50>)
    e8e2:	9b01      	ldr	r3, [sp, #4]
    e8e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e8e8:	2b00      	cmp	r3, #0
    e8ea:	d10d      	bne.n	e908 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_13+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e8ec:	f7f2 f846 	bl	97c <Adc_schm_read_msr>
    e8f0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e8f2:	9b00      	ldr	r3, [sp, #0]
    e8f4:	f003 0301 	and.w	r3, r3, #1
    e8f8:	2b00      	cmp	r3, #0
    e8fa:	d100      	bne.n	e8fe <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_13+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e8fc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_13[u32CoreId] = msr;
    e8fe:	490a      	ldr	r1, [pc, #40]	; (e928 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_13+0x54>)
    e900:	9b01      	ldr	r3, [sp, #4]
    e902:	9a00      	ldr	r2, [sp, #0]
    e904:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_13[u32CoreId]++;
    e908:	4a06      	ldr	r2, [pc, #24]	; (e924 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_13+0x50>)
    e90a:	9b01      	ldr	r3, [sp, #4]
    e90c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e910:	1c5a      	adds	r2, r3, #1
    e912:	4904      	ldr	r1, [pc, #16]	; (e924 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_13+0x50>)
    e914:	9b01      	ldr	r3, [sp, #4]
    e916:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e91a:	bf00      	nop
    e91c:	b003      	add	sp, #12
    e91e:	f85d fb04 	ldr.w	pc, [sp], #4
    e922:	bf00      	nop
    e924:	1fff90cc 	.word	0x1fff90cc
    e928:	1fff90c8 	.word	0x1fff90c8

0000e92c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_13>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_13(void)
{
    e92c:	b500      	push	{lr}
    e92e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e930:	f7f2 f932 	bl	b98 <Sys_GetCoreID>
    e934:	4603      	mov	r3, r0
    e936:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_13[u32CoreId]--;
    e938:	4a0d      	ldr	r2, [pc, #52]	; (e970 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_13+0x44>)
    e93a:	9b01      	ldr	r3, [sp, #4]
    e93c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e940:	1e5a      	subs	r2, r3, #1
    e942:	490b      	ldr	r1, [pc, #44]	; (e970 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_13+0x44>)
    e944:	9b01      	ldr	r3, [sp, #4]
    e946:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_13[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_13[u32CoreId]))         /*if interrupts were enabled*/
    e94a:	4a0a      	ldr	r2, [pc, #40]	; (e974 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_13+0x48>)
    e94c:	9b01      	ldr	r3, [sp, #4]
    e94e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e952:	f003 0301 	and.w	r3, r3, #1
    e956:	2b00      	cmp	r3, #0
    e958:	d106      	bne.n	e968 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_13+0x3c>
    e95a:	4a05      	ldr	r2, [pc, #20]	; (e970 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_13+0x44>)
    e95c:	9b01      	ldr	r3, [sp, #4]
    e95e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e962:	2b00      	cmp	r3, #0
    e964:	d100      	bne.n	e968 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_13+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    e966:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    e968:	bf00      	nop
    e96a:	b003      	add	sp, #12
    e96c:	f85d fb04 	ldr.w	pc, [sp], #4
    e970:	1fff90cc 	.word	0x1fff90cc
    e974:	1fff90c8 	.word	0x1fff90c8

0000e978 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_14>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_14(void)
{
    e978:	b500      	push	{lr}
    e97a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e97c:	f7f2 f90c 	bl	b98 <Sys_GetCoreID>
    e980:	4603      	mov	r3, r0
    e982:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_14[u32CoreId])
    e984:	4a10      	ldr	r2, [pc, #64]	; (e9c8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_14+0x50>)
    e986:	9b01      	ldr	r3, [sp, #4]
    e988:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e98c:	2b00      	cmp	r3, #0
    e98e:	d10d      	bne.n	e9ac <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_14+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    e990:	f7f1 fff4 	bl	97c <Adc_schm_read_msr>
    e994:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    e996:	9b00      	ldr	r3, [sp, #0]
    e998:	f003 0301 	and.w	r3, r3, #1
    e99c:	2b00      	cmp	r3, #0
    e99e:	d100      	bne.n	e9a2 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_14+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    e9a0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_14[u32CoreId] = msr;
    e9a2:	490a      	ldr	r1, [pc, #40]	; (e9cc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_14+0x54>)
    e9a4:	9b01      	ldr	r3, [sp, #4]
    e9a6:	9a00      	ldr	r2, [sp, #0]
    e9a8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_14[u32CoreId]++;
    e9ac:	4a06      	ldr	r2, [pc, #24]	; (e9c8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_14+0x50>)
    e9ae:	9b01      	ldr	r3, [sp, #4]
    e9b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e9b4:	1c5a      	adds	r2, r3, #1
    e9b6:	4904      	ldr	r1, [pc, #16]	; (e9c8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_14+0x50>)
    e9b8:	9b01      	ldr	r3, [sp, #4]
    e9ba:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    e9be:	bf00      	nop
    e9c0:	b003      	add	sp, #12
    e9c2:	f85d fb04 	ldr.w	pc, [sp], #4
    e9c6:	bf00      	nop
    e9c8:	1fff90d4 	.word	0x1fff90d4
    e9cc:	1fff90d0 	.word	0x1fff90d0

0000e9d0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_14>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_14(void)
{
    e9d0:	b500      	push	{lr}
    e9d2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    e9d4:	f7f2 f8e0 	bl	b98 <Sys_GetCoreID>
    e9d8:	4603      	mov	r3, r0
    e9da:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_14[u32CoreId]--;
    e9dc:	4a0d      	ldr	r2, [pc, #52]	; (ea14 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_14+0x44>)
    e9de:	9b01      	ldr	r3, [sp, #4]
    e9e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e9e4:	1e5a      	subs	r2, r3, #1
    e9e6:	490b      	ldr	r1, [pc, #44]	; (ea14 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_14+0x44>)
    e9e8:	9b01      	ldr	r3, [sp, #4]
    e9ea:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_14[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_14[u32CoreId]))         /*if interrupts were enabled*/
    e9ee:	4a0a      	ldr	r2, [pc, #40]	; (ea18 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_14+0x48>)
    e9f0:	9b01      	ldr	r3, [sp, #4]
    e9f2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    e9f6:	f003 0301 	and.w	r3, r3, #1
    e9fa:	2b00      	cmp	r3, #0
    e9fc:	d106      	bne.n	ea0c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_14+0x3c>
    e9fe:	4a05      	ldr	r2, [pc, #20]	; (ea14 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_14+0x44>)
    ea00:	9b01      	ldr	r3, [sp, #4]
    ea02:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ea06:	2b00      	cmp	r3, #0
    ea08:	d100      	bne.n	ea0c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_14+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    ea0a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    ea0c:	bf00      	nop
    ea0e:	b003      	add	sp, #12
    ea10:	f85d fb04 	ldr.w	pc, [sp], #4
    ea14:	1fff90d4 	.word	0x1fff90d4
    ea18:	1fff90d0 	.word	0x1fff90d0

0000ea1c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_15>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_15(void)
{
    ea1c:	b500      	push	{lr}
    ea1e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ea20:	f7f2 f8ba 	bl	b98 <Sys_GetCoreID>
    ea24:	4603      	mov	r3, r0
    ea26:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_15[u32CoreId])
    ea28:	4a10      	ldr	r2, [pc, #64]	; (ea6c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_15+0x50>)
    ea2a:	9b01      	ldr	r3, [sp, #4]
    ea2c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ea30:	2b00      	cmp	r3, #0
    ea32:	d10d      	bne.n	ea50 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_15+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    ea34:	f7f1 ffa2 	bl	97c <Adc_schm_read_msr>
    ea38:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    ea3a:	9b00      	ldr	r3, [sp, #0]
    ea3c:	f003 0301 	and.w	r3, r3, #1
    ea40:	2b00      	cmp	r3, #0
    ea42:	d100      	bne.n	ea46 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_15+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    ea44:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_15[u32CoreId] = msr;
    ea46:	490a      	ldr	r1, [pc, #40]	; (ea70 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_15+0x54>)
    ea48:	9b01      	ldr	r3, [sp, #4]
    ea4a:	9a00      	ldr	r2, [sp, #0]
    ea4c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_15[u32CoreId]++;
    ea50:	4a06      	ldr	r2, [pc, #24]	; (ea6c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_15+0x50>)
    ea52:	9b01      	ldr	r3, [sp, #4]
    ea54:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ea58:	1c5a      	adds	r2, r3, #1
    ea5a:	4904      	ldr	r1, [pc, #16]	; (ea6c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_15+0x50>)
    ea5c:	9b01      	ldr	r3, [sp, #4]
    ea5e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    ea62:	bf00      	nop
    ea64:	b003      	add	sp, #12
    ea66:	f85d fb04 	ldr.w	pc, [sp], #4
    ea6a:	bf00      	nop
    ea6c:	1fff90dc 	.word	0x1fff90dc
    ea70:	1fff90d8 	.word	0x1fff90d8

0000ea74 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_15>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_15(void)
{
    ea74:	b500      	push	{lr}
    ea76:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ea78:	f7f2 f88e 	bl	b98 <Sys_GetCoreID>
    ea7c:	4603      	mov	r3, r0
    ea7e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_15[u32CoreId]--;
    ea80:	4a0d      	ldr	r2, [pc, #52]	; (eab8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_15+0x44>)
    ea82:	9b01      	ldr	r3, [sp, #4]
    ea84:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ea88:	1e5a      	subs	r2, r3, #1
    ea8a:	490b      	ldr	r1, [pc, #44]	; (eab8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_15+0x44>)
    ea8c:	9b01      	ldr	r3, [sp, #4]
    ea8e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_15[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_15[u32CoreId]))         /*if interrupts were enabled*/
    ea92:	4a0a      	ldr	r2, [pc, #40]	; (eabc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_15+0x48>)
    ea94:	9b01      	ldr	r3, [sp, #4]
    ea96:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ea9a:	f003 0301 	and.w	r3, r3, #1
    ea9e:	2b00      	cmp	r3, #0
    eaa0:	d106      	bne.n	eab0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_15+0x3c>
    eaa2:	4a05      	ldr	r2, [pc, #20]	; (eab8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_15+0x44>)
    eaa4:	9b01      	ldr	r3, [sp, #4]
    eaa6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    eaaa:	2b00      	cmp	r3, #0
    eaac:	d100      	bne.n	eab0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_15+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    eaae:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    eab0:	bf00      	nop
    eab2:	b003      	add	sp, #12
    eab4:	f85d fb04 	ldr.w	pc, [sp], #4
    eab8:	1fff90dc 	.word	0x1fff90dc
    eabc:	1fff90d8 	.word	0x1fff90d8

0000eac0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_16>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_16(void)
{
    eac0:	b500      	push	{lr}
    eac2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    eac4:	f7f2 f868 	bl	b98 <Sys_GetCoreID>
    eac8:	4603      	mov	r3, r0
    eaca:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_16[u32CoreId])
    eacc:	4a10      	ldr	r2, [pc, #64]	; (eb10 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_16+0x50>)
    eace:	9b01      	ldr	r3, [sp, #4]
    ead0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ead4:	2b00      	cmp	r3, #0
    ead6:	d10d      	bne.n	eaf4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_16+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    ead8:	f7f1 ff50 	bl	97c <Adc_schm_read_msr>
    eadc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    eade:	9b00      	ldr	r3, [sp, #0]
    eae0:	f003 0301 	and.w	r3, r3, #1
    eae4:	2b00      	cmp	r3, #0
    eae6:	d100      	bne.n	eaea <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_16+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    eae8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_16[u32CoreId] = msr;
    eaea:	490a      	ldr	r1, [pc, #40]	; (eb14 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_16+0x54>)
    eaec:	9b01      	ldr	r3, [sp, #4]
    eaee:	9a00      	ldr	r2, [sp, #0]
    eaf0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_16[u32CoreId]++;
    eaf4:	4a06      	ldr	r2, [pc, #24]	; (eb10 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_16+0x50>)
    eaf6:	9b01      	ldr	r3, [sp, #4]
    eaf8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    eafc:	1c5a      	adds	r2, r3, #1
    eafe:	4904      	ldr	r1, [pc, #16]	; (eb10 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_16+0x50>)
    eb00:	9b01      	ldr	r3, [sp, #4]
    eb02:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    eb06:	bf00      	nop
    eb08:	b003      	add	sp, #12
    eb0a:	f85d fb04 	ldr.w	pc, [sp], #4
    eb0e:	bf00      	nop
    eb10:	1fff90e4 	.word	0x1fff90e4
    eb14:	1fff90e0 	.word	0x1fff90e0

0000eb18 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_16>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_16(void)
{
    eb18:	b500      	push	{lr}
    eb1a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    eb1c:	f7f2 f83c 	bl	b98 <Sys_GetCoreID>
    eb20:	4603      	mov	r3, r0
    eb22:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_16[u32CoreId]--;
    eb24:	4a0d      	ldr	r2, [pc, #52]	; (eb5c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_16+0x44>)
    eb26:	9b01      	ldr	r3, [sp, #4]
    eb28:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    eb2c:	1e5a      	subs	r2, r3, #1
    eb2e:	490b      	ldr	r1, [pc, #44]	; (eb5c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_16+0x44>)
    eb30:	9b01      	ldr	r3, [sp, #4]
    eb32:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_16[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_16[u32CoreId]))         /*if interrupts were enabled*/
    eb36:	4a0a      	ldr	r2, [pc, #40]	; (eb60 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_16+0x48>)
    eb38:	9b01      	ldr	r3, [sp, #4]
    eb3a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    eb3e:	f003 0301 	and.w	r3, r3, #1
    eb42:	2b00      	cmp	r3, #0
    eb44:	d106      	bne.n	eb54 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_16+0x3c>
    eb46:	4a05      	ldr	r2, [pc, #20]	; (eb5c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_16+0x44>)
    eb48:	9b01      	ldr	r3, [sp, #4]
    eb4a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    eb4e:	2b00      	cmp	r3, #0
    eb50:	d100      	bne.n	eb54 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_16+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    eb52:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    eb54:	bf00      	nop
    eb56:	b003      	add	sp, #12
    eb58:	f85d fb04 	ldr.w	pc, [sp], #4
    eb5c:	1fff90e4 	.word	0x1fff90e4
    eb60:	1fff90e0 	.word	0x1fff90e0

0000eb64 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_17>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_17(void)
{
    eb64:	b500      	push	{lr}
    eb66:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    eb68:	f7f2 f816 	bl	b98 <Sys_GetCoreID>
    eb6c:	4603      	mov	r3, r0
    eb6e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_17[u32CoreId])
    eb70:	4a10      	ldr	r2, [pc, #64]	; (ebb4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_17+0x50>)
    eb72:	9b01      	ldr	r3, [sp, #4]
    eb74:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    eb78:	2b00      	cmp	r3, #0
    eb7a:	d10d      	bne.n	eb98 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_17+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    eb7c:	f7f1 fefe 	bl	97c <Adc_schm_read_msr>
    eb80:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    eb82:	9b00      	ldr	r3, [sp, #0]
    eb84:	f003 0301 	and.w	r3, r3, #1
    eb88:	2b00      	cmp	r3, #0
    eb8a:	d100      	bne.n	eb8e <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_17+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    eb8c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_17[u32CoreId] = msr;
    eb8e:	490a      	ldr	r1, [pc, #40]	; (ebb8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_17+0x54>)
    eb90:	9b01      	ldr	r3, [sp, #4]
    eb92:	9a00      	ldr	r2, [sp, #0]
    eb94:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_17[u32CoreId]++;
    eb98:	4a06      	ldr	r2, [pc, #24]	; (ebb4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_17+0x50>)
    eb9a:	9b01      	ldr	r3, [sp, #4]
    eb9c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    eba0:	1c5a      	adds	r2, r3, #1
    eba2:	4904      	ldr	r1, [pc, #16]	; (ebb4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_17+0x50>)
    eba4:	9b01      	ldr	r3, [sp, #4]
    eba6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    ebaa:	bf00      	nop
    ebac:	b003      	add	sp, #12
    ebae:	f85d fb04 	ldr.w	pc, [sp], #4
    ebb2:	bf00      	nop
    ebb4:	1fff90ec 	.word	0x1fff90ec
    ebb8:	1fff90e8 	.word	0x1fff90e8

0000ebbc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_17>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_17(void)
{
    ebbc:	b500      	push	{lr}
    ebbe:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ebc0:	f7f1 ffea 	bl	b98 <Sys_GetCoreID>
    ebc4:	4603      	mov	r3, r0
    ebc6:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_17[u32CoreId]--;
    ebc8:	4a0d      	ldr	r2, [pc, #52]	; (ec00 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_17+0x44>)
    ebca:	9b01      	ldr	r3, [sp, #4]
    ebcc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ebd0:	1e5a      	subs	r2, r3, #1
    ebd2:	490b      	ldr	r1, [pc, #44]	; (ec00 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_17+0x44>)
    ebd4:	9b01      	ldr	r3, [sp, #4]
    ebd6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_17[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_17[u32CoreId]))         /*if interrupts were enabled*/
    ebda:	4a0a      	ldr	r2, [pc, #40]	; (ec04 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_17+0x48>)
    ebdc:	9b01      	ldr	r3, [sp, #4]
    ebde:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ebe2:	f003 0301 	and.w	r3, r3, #1
    ebe6:	2b00      	cmp	r3, #0
    ebe8:	d106      	bne.n	ebf8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_17+0x3c>
    ebea:	4a05      	ldr	r2, [pc, #20]	; (ec00 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_17+0x44>)
    ebec:	9b01      	ldr	r3, [sp, #4]
    ebee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ebf2:	2b00      	cmp	r3, #0
    ebf4:	d100      	bne.n	ebf8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_17+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    ebf6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    ebf8:	bf00      	nop
    ebfa:	b003      	add	sp, #12
    ebfc:	f85d fb04 	ldr.w	pc, [sp], #4
    ec00:	1fff90ec 	.word	0x1fff90ec
    ec04:	1fff90e8 	.word	0x1fff90e8

0000ec08 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_18>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_18(void)
{
    ec08:	b500      	push	{lr}
    ec0a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ec0c:	f7f1 ffc4 	bl	b98 <Sys_GetCoreID>
    ec10:	4603      	mov	r3, r0
    ec12:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_18[u32CoreId])
    ec14:	4a10      	ldr	r2, [pc, #64]	; (ec58 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_18+0x50>)
    ec16:	9b01      	ldr	r3, [sp, #4]
    ec18:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ec1c:	2b00      	cmp	r3, #0
    ec1e:	d10d      	bne.n	ec3c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_18+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    ec20:	f7f1 feac 	bl	97c <Adc_schm_read_msr>
    ec24:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    ec26:	9b00      	ldr	r3, [sp, #0]
    ec28:	f003 0301 	and.w	r3, r3, #1
    ec2c:	2b00      	cmp	r3, #0
    ec2e:	d100      	bne.n	ec32 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_18+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    ec30:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_18[u32CoreId] = msr;
    ec32:	490a      	ldr	r1, [pc, #40]	; (ec5c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_18+0x54>)
    ec34:	9b01      	ldr	r3, [sp, #4]
    ec36:	9a00      	ldr	r2, [sp, #0]
    ec38:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_18[u32CoreId]++;
    ec3c:	4a06      	ldr	r2, [pc, #24]	; (ec58 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_18+0x50>)
    ec3e:	9b01      	ldr	r3, [sp, #4]
    ec40:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ec44:	1c5a      	adds	r2, r3, #1
    ec46:	4904      	ldr	r1, [pc, #16]	; (ec58 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_18+0x50>)
    ec48:	9b01      	ldr	r3, [sp, #4]
    ec4a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    ec4e:	bf00      	nop
    ec50:	b003      	add	sp, #12
    ec52:	f85d fb04 	ldr.w	pc, [sp], #4
    ec56:	bf00      	nop
    ec58:	1fff90f4 	.word	0x1fff90f4
    ec5c:	1fff90f0 	.word	0x1fff90f0

0000ec60 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_18>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_18(void)
{
    ec60:	b500      	push	{lr}
    ec62:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ec64:	f7f1 ff98 	bl	b98 <Sys_GetCoreID>
    ec68:	4603      	mov	r3, r0
    ec6a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_18[u32CoreId]--;
    ec6c:	4a0d      	ldr	r2, [pc, #52]	; (eca4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_18+0x44>)
    ec6e:	9b01      	ldr	r3, [sp, #4]
    ec70:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ec74:	1e5a      	subs	r2, r3, #1
    ec76:	490b      	ldr	r1, [pc, #44]	; (eca4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_18+0x44>)
    ec78:	9b01      	ldr	r3, [sp, #4]
    ec7a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_18[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_18[u32CoreId]))         /*if interrupts were enabled*/
    ec7e:	4a0a      	ldr	r2, [pc, #40]	; (eca8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_18+0x48>)
    ec80:	9b01      	ldr	r3, [sp, #4]
    ec82:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ec86:	f003 0301 	and.w	r3, r3, #1
    ec8a:	2b00      	cmp	r3, #0
    ec8c:	d106      	bne.n	ec9c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_18+0x3c>
    ec8e:	4a05      	ldr	r2, [pc, #20]	; (eca4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_18+0x44>)
    ec90:	9b01      	ldr	r3, [sp, #4]
    ec92:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ec96:	2b00      	cmp	r3, #0
    ec98:	d100      	bne.n	ec9c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_18+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    ec9a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    ec9c:	bf00      	nop
    ec9e:	b003      	add	sp, #12
    eca0:	f85d fb04 	ldr.w	pc, [sp], #4
    eca4:	1fff90f4 	.word	0x1fff90f4
    eca8:	1fff90f0 	.word	0x1fff90f0

0000ecac <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_19>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_19(void)
{
    ecac:	b500      	push	{lr}
    ecae:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ecb0:	f7f1 ff72 	bl	b98 <Sys_GetCoreID>
    ecb4:	4603      	mov	r3, r0
    ecb6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_19[u32CoreId])
    ecb8:	4a10      	ldr	r2, [pc, #64]	; (ecfc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_19+0x50>)
    ecba:	9b01      	ldr	r3, [sp, #4]
    ecbc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ecc0:	2b00      	cmp	r3, #0
    ecc2:	d10d      	bne.n	ece0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_19+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    ecc4:	f7f1 fe5a 	bl	97c <Adc_schm_read_msr>
    ecc8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    ecca:	9b00      	ldr	r3, [sp, #0]
    eccc:	f003 0301 	and.w	r3, r3, #1
    ecd0:	2b00      	cmp	r3, #0
    ecd2:	d100      	bne.n	ecd6 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_19+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    ecd4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_19[u32CoreId] = msr;
    ecd6:	490a      	ldr	r1, [pc, #40]	; (ed00 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_19+0x54>)
    ecd8:	9b01      	ldr	r3, [sp, #4]
    ecda:	9a00      	ldr	r2, [sp, #0]
    ecdc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_19[u32CoreId]++;
    ece0:	4a06      	ldr	r2, [pc, #24]	; (ecfc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_19+0x50>)
    ece2:	9b01      	ldr	r3, [sp, #4]
    ece4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ece8:	1c5a      	adds	r2, r3, #1
    ecea:	4904      	ldr	r1, [pc, #16]	; (ecfc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_19+0x50>)
    ecec:	9b01      	ldr	r3, [sp, #4]
    ecee:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    ecf2:	bf00      	nop
    ecf4:	b003      	add	sp, #12
    ecf6:	f85d fb04 	ldr.w	pc, [sp], #4
    ecfa:	bf00      	nop
    ecfc:	1fff90fc 	.word	0x1fff90fc
    ed00:	1fff90f8 	.word	0x1fff90f8

0000ed04 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_19>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_19(void)
{
    ed04:	b500      	push	{lr}
    ed06:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ed08:	f7f1 ff46 	bl	b98 <Sys_GetCoreID>
    ed0c:	4603      	mov	r3, r0
    ed0e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_19[u32CoreId]--;
    ed10:	4a0d      	ldr	r2, [pc, #52]	; (ed48 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_19+0x44>)
    ed12:	9b01      	ldr	r3, [sp, #4]
    ed14:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ed18:	1e5a      	subs	r2, r3, #1
    ed1a:	490b      	ldr	r1, [pc, #44]	; (ed48 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_19+0x44>)
    ed1c:	9b01      	ldr	r3, [sp, #4]
    ed1e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_19[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_19[u32CoreId]))         /*if interrupts were enabled*/
    ed22:	4a0a      	ldr	r2, [pc, #40]	; (ed4c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_19+0x48>)
    ed24:	9b01      	ldr	r3, [sp, #4]
    ed26:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ed2a:	f003 0301 	and.w	r3, r3, #1
    ed2e:	2b00      	cmp	r3, #0
    ed30:	d106      	bne.n	ed40 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_19+0x3c>
    ed32:	4a05      	ldr	r2, [pc, #20]	; (ed48 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_19+0x44>)
    ed34:	9b01      	ldr	r3, [sp, #4]
    ed36:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ed3a:	2b00      	cmp	r3, #0
    ed3c:	d100      	bne.n	ed40 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_19+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    ed3e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    ed40:	bf00      	nop
    ed42:	b003      	add	sp, #12
    ed44:	f85d fb04 	ldr.w	pc, [sp], #4
    ed48:	1fff90fc 	.word	0x1fff90fc
    ed4c:	1fff90f8 	.word	0x1fff90f8

0000ed50 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_20>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_20(void)
{
    ed50:	b500      	push	{lr}
    ed52:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ed54:	f7f1 ff20 	bl	b98 <Sys_GetCoreID>
    ed58:	4603      	mov	r3, r0
    ed5a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_20[u32CoreId])
    ed5c:	4a10      	ldr	r2, [pc, #64]	; (eda0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_20+0x50>)
    ed5e:	9b01      	ldr	r3, [sp, #4]
    ed60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ed64:	2b00      	cmp	r3, #0
    ed66:	d10d      	bne.n	ed84 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_20+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    ed68:	f7f1 fe08 	bl	97c <Adc_schm_read_msr>
    ed6c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    ed6e:	9b00      	ldr	r3, [sp, #0]
    ed70:	f003 0301 	and.w	r3, r3, #1
    ed74:	2b00      	cmp	r3, #0
    ed76:	d100      	bne.n	ed7a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_20+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    ed78:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_20[u32CoreId] = msr;
    ed7a:	490a      	ldr	r1, [pc, #40]	; (eda4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_20+0x54>)
    ed7c:	9b01      	ldr	r3, [sp, #4]
    ed7e:	9a00      	ldr	r2, [sp, #0]
    ed80:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_20[u32CoreId]++;
    ed84:	4a06      	ldr	r2, [pc, #24]	; (eda0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_20+0x50>)
    ed86:	9b01      	ldr	r3, [sp, #4]
    ed88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ed8c:	1c5a      	adds	r2, r3, #1
    ed8e:	4904      	ldr	r1, [pc, #16]	; (eda0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_20+0x50>)
    ed90:	9b01      	ldr	r3, [sp, #4]
    ed92:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    ed96:	bf00      	nop
    ed98:	b003      	add	sp, #12
    ed9a:	f85d fb04 	ldr.w	pc, [sp], #4
    ed9e:	bf00      	nop
    eda0:	1fff9104 	.word	0x1fff9104
    eda4:	1fff9100 	.word	0x1fff9100

0000eda8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_20>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_20(void)
{
    eda8:	b500      	push	{lr}
    edaa:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    edac:	f7f1 fef4 	bl	b98 <Sys_GetCoreID>
    edb0:	4603      	mov	r3, r0
    edb2:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_20[u32CoreId]--;
    edb4:	4a0d      	ldr	r2, [pc, #52]	; (edec <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_20+0x44>)
    edb6:	9b01      	ldr	r3, [sp, #4]
    edb8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    edbc:	1e5a      	subs	r2, r3, #1
    edbe:	490b      	ldr	r1, [pc, #44]	; (edec <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_20+0x44>)
    edc0:	9b01      	ldr	r3, [sp, #4]
    edc2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_20[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_20[u32CoreId]))         /*if interrupts were enabled*/
    edc6:	4a0a      	ldr	r2, [pc, #40]	; (edf0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_20+0x48>)
    edc8:	9b01      	ldr	r3, [sp, #4]
    edca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    edce:	f003 0301 	and.w	r3, r3, #1
    edd2:	2b00      	cmp	r3, #0
    edd4:	d106      	bne.n	ede4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_20+0x3c>
    edd6:	4a05      	ldr	r2, [pc, #20]	; (edec <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_20+0x44>)
    edd8:	9b01      	ldr	r3, [sp, #4]
    edda:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    edde:	2b00      	cmp	r3, #0
    ede0:	d100      	bne.n	ede4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_20+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    ede2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    ede4:	bf00      	nop
    ede6:	b003      	add	sp, #12
    ede8:	f85d fb04 	ldr.w	pc, [sp], #4
    edec:	1fff9104 	.word	0x1fff9104
    edf0:	1fff9100 	.word	0x1fff9100

0000edf4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_21>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_21(void)
{
    edf4:	b500      	push	{lr}
    edf6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    edf8:	f7f1 fece 	bl	b98 <Sys_GetCoreID>
    edfc:	4603      	mov	r3, r0
    edfe:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_21[u32CoreId])
    ee00:	4a10      	ldr	r2, [pc, #64]	; (ee44 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_21+0x50>)
    ee02:	9b01      	ldr	r3, [sp, #4]
    ee04:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ee08:	2b00      	cmp	r3, #0
    ee0a:	d10d      	bne.n	ee28 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_21+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    ee0c:	f7f1 fdb6 	bl	97c <Adc_schm_read_msr>
    ee10:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    ee12:	9b00      	ldr	r3, [sp, #0]
    ee14:	f003 0301 	and.w	r3, r3, #1
    ee18:	2b00      	cmp	r3, #0
    ee1a:	d100      	bne.n	ee1e <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_21+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    ee1c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_21[u32CoreId] = msr;
    ee1e:	490a      	ldr	r1, [pc, #40]	; (ee48 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_21+0x54>)
    ee20:	9b01      	ldr	r3, [sp, #4]
    ee22:	9a00      	ldr	r2, [sp, #0]
    ee24:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_21[u32CoreId]++;
    ee28:	4a06      	ldr	r2, [pc, #24]	; (ee44 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_21+0x50>)
    ee2a:	9b01      	ldr	r3, [sp, #4]
    ee2c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ee30:	1c5a      	adds	r2, r3, #1
    ee32:	4904      	ldr	r1, [pc, #16]	; (ee44 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_21+0x50>)
    ee34:	9b01      	ldr	r3, [sp, #4]
    ee36:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    ee3a:	bf00      	nop
    ee3c:	b003      	add	sp, #12
    ee3e:	f85d fb04 	ldr.w	pc, [sp], #4
    ee42:	bf00      	nop
    ee44:	1fff910c 	.word	0x1fff910c
    ee48:	1fff9108 	.word	0x1fff9108

0000ee4c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_21>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_21(void)
{
    ee4c:	b500      	push	{lr}
    ee4e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ee50:	f7f1 fea2 	bl	b98 <Sys_GetCoreID>
    ee54:	4603      	mov	r3, r0
    ee56:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_21[u32CoreId]--;
    ee58:	4a0d      	ldr	r2, [pc, #52]	; (ee90 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_21+0x44>)
    ee5a:	9b01      	ldr	r3, [sp, #4]
    ee5c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ee60:	1e5a      	subs	r2, r3, #1
    ee62:	490b      	ldr	r1, [pc, #44]	; (ee90 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_21+0x44>)
    ee64:	9b01      	ldr	r3, [sp, #4]
    ee66:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_21[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_21[u32CoreId]))         /*if interrupts were enabled*/
    ee6a:	4a0a      	ldr	r2, [pc, #40]	; (ee94 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_21+0x48>)
    ee6c:	9b01      	ldr	r3, [sp, #4]
    ee6e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ee72:	f003 0301 	and.w	r3, r3, #1
    ee76:	2b00      	cmp	r3, #0
    ee78:	d106      	bne.n	ee88 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_21+0x3c>
    ee7a:	4a05      	ldr	r2, [pc, #20]	; (ee90 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_21+0x44>)
    ee7c:	9b01      	ldr	r3, [sp, #4]
    ee7e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ee82:	2b00      	cmp	r3, #0
    ee84:	d100      	bne.n	ee88 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_21+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    ee86:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    ee88:	bf00      	nop
    ee8a:	b003      	add	sp, #12
    ee8c:	f85d fb04 	ldr.w	pc, [sp], #4
    ee90:	1fff910c 	.word	0x1fff910c
    ee94:	1fff9108 	.word	0x1fff9108

0000ee98 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_22>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_22(void)
{
    ee98:	b500      	push	{lr}
    ee9a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ee9c:	f7f1 fe7c 	bl	b98 <Sys_GetCoreID>
    eea0:	4603      	mov	r3, r0
    eea2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_22[u32CoreId])
    eea4:	4a10      	ldr	r2, [pc, #64]	; (eee8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_22+0x50>)
    eea6:	9b01      	ldr	r3, [sp, #4]
    eea8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    eeac:	2b00      	cmp	r3, #0
    eeae:	d10d      	bne.n	eecc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_22+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    eeb0:	f7f1 fd64 	bl	97c <Adc_schm_read_msr>
    eeb4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    eeb6:	9b00      	ldr	r3, [sp, #0]
    eeb8:	f003 0301 	and.w	r3, r3, #1
    eebc:	2b00      	cmp	r3, #0
    eebe:	d100      	bne.n	eec2 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_22+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    eec0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_22[u32CoreId] = msr;
    eec2:	490a      	ldr	r1, [pc, #40]	; (eeec <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_22+0x54>)
    eec4:	9b01      	ldr	r3, [sp, #4]
    eec6:	9a00      	ldr	r2, [sp, #0]
    eec8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_22[u32CoreId]++;
    eecc:	4a06      	ldr	r2, [pc, #24]	; (eee8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_22+0x50>)
    eece:	9b01      	ldr	r3, [sp, #4]
    eed0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    eed4:	1c5a      	adds	r2, r3, #1
    eed6:	4904      	ldr	r1, [pc, #16]	; (eee8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_22+0x50>)
    eed8:	9b01      	ldr	r3, [sp, #4]
    eeda:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    eede:	bf00      	nop
    eee0:	b003      	add	sp, #12
    eee2:	f85d fb04 	ldr.w	pc, [sp], #4
    eee6:	bf00      	nop
    eee8:	1fff9114 	.word	0x1fff9114
    eeec:	1fff9110 	.word	0x1fff9110

0000eef0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_22>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_22(void)
{
    eef0:	b500      	push	{lr}
    eef2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    eef4:	f7f1 fe50 	bl	b98 <Sys_GetCoreID>
    eef8:	4603      	mov	r3, r0
    eefa:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_22[u32CoreId]--;
    eefc:	4a0d      	ldr	r2, [pc, #52]	; (ef34 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_22+0x44>)
    eefe:	9b01      	ldr	r3, [sp, #4]
    ef00:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ef04:	1e5a      	subs	r2, r3, #1
    ef06:	490b      	ldr	r1, [pc, #44]	; (ef34 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_22+0x44>)
    ef08:	9b01      	ldr	r3, [sp, #4]
    ef0a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_22[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_22[u32CoreId]))         /*if interrupts were enabled*/
    ef0e:	4a0a      	ldr	r2, [pc, #40]	; (ef38 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_22+0x48>)
    ef10:	9b01      	ldr	r3, [sp, #4]
    ef12:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ef16:	f003 0301 	and.w	r3, r3, #1
    ef1a:	2b00      	cmp	r3, #0
    ef1c:	d106      	bne.n	ef2c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_22+0x3c>
    ef1e:	4a05      	ldr	r2, [pc, #20]	; (ef34 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_22+0x44>)
    ef20:	9b01      	ldr	r3, [sp, #4]
    ef22:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ef26:	2b00      	cmp	r3, #0
    ef28:	d100      	bne.n	ef2c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_22+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    ef2a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    ef2c:	bf00      	nop
    ef2e:	b003      	add	sp, #12
    ef30:	f85d fb04 	ldr.w	pc, [sp], #4
    ef34:	1fff9114 	.word	0x1fff9114
    ef38:	1fff9110 	.word	0x1fff9110

0000ef3c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_23>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_23(void)
{
    ef3c:	b500      	push	{lr}
    ef3e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ef40:	f7f1 fe2a 	bl	b98 <Sys_GetCoreID>
    ef44:	4603      	mov	r3, r0
    ef46:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_23[u32CoreId])
    ef48:	4a10      	ldr	r2, [pc, #64]	; (ef8c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_23+0x50>)
    ef4a:	9b01      	ldr	r3, [sp, #4]
    ef4c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ef50:	2b00      	cmp	r3, #0
    ef52:	d10d      	bne.n	ef70 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_23+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    ef54:	f7f1 fd12 	bl	97c <Adc_schm_read_msr>
    ef58:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    ef5a:	9b00      	ldr	r3, [sp, #0]
    ef5c:	f003 0301 	and.w	r3, r3, #1
    ef60:	2b00      	cmp	r3, #0
    ef62:	d100      	bne.n	ef66 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_23+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    ef64:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_23[u32CoreId] = msr;
    ef66:	490a      	ldr	r1, [pc, #40]	; (ef90 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_23+0x54>)
    ef68:	9b01      	ldr	r3, [sp, #4]
    ef6a:	9a00      	ldr	r2, [sp, #0]
    ef6c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_23[u32CoreId]++;
    ef70:	4a06      	ldr	r2, [pc, #24]	; (ef8c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_23+0x50>)
    ef72:	9b01      	ldr	r3, [sp, #4]
    ef74:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ef78:	1c5a      	adds	r2, r3, #1
    ef7a:	4904      	ldr	r1, [pc, #16]	; (ef8c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_23+0x50>)
    ef7c:	9b01      	ldr	r3, [sp, #4]
    ef7e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    ef82:	bf00      	nop
    ef84:	b003      	add	sp, #12
    ef86:	f85d fb04 	ldr.w	pc, [sp], #4
    ef8a:	bf00      	nop
    ef8c:	1fff911c 	.word	0x1fff911c
    ef90:	1fff9118 	.word	0x1fff9118

0000ef94 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_23>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_23(void)
{
    ef94:	b500      	push	{lr}
    ef96:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ef98:	f7f1 fdfe 	bl	b98 <Sys_GetCoreID>
    ef9c:	4603      	mov	r3, r0
    ef9e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_23[u32CoreId]--;
    efa0:	4a0d      	ldr	r2, [pc, #52]	; (efd8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_23+0x44>)
    efa2:	9b01      	ldr	r3, [sp, #4]
    efa4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    efa8:	1e5a      	subs	r2, r3, #1
    efaa:	490b      	ldr	r1, [pc, #44]	; (efd8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_23+0x44>)
    efac:	9b01      	ldr	r3, [sp, #4]
    efae:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_23[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_23[u32CoreId]))         /*if interrupts were enabled*/
    efb2:	4a0a      	ldr	r2, [pc, #40]	; (efdc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_23+0x48>)
    efb4:	9b01      	ldr	r3, [sp, #4]
    efb6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    efba:	f003 0301 	and.w	r3, r3, #1
    efbe:	2b00      	cmp	r3, #0
    efc0:	d106      	bne.n	efd0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_23+0x3c>
    efc2:	4a05      	ldr	r2, [pc, #20]	; (efd8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_23+0x44>)
    efc4:	9b01      	ldr	r3, [sp, #4]
    efc6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    efca:	2b00      	cmp	r3, #0
    efcc:	d100      	bne.n	efd0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_23+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    efce:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    efd0:	bf00      	nop
    efd2:	b003      	add	sp, #12
    efd4:	f85d fb04 	ldr.w	pc, [sp], #4
    efd8:	1fff911c 	.word	0x1fff911c
    efdc:	1fff9118 	.word	0x1fff9118

0000efe0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_24>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_24(void)
{
    efe0:	b500      	push	{lr}
    efe2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    efe4:	f7f1 fdd8 	bl	b98 <Sys_GetCoreID>
    efe8:	4603      	mov	r3, r0
    efea:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_24[u32CoreId])
    efec:	4a10      	ldr	r2, [pc, #64]	; (f030 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_24+0x50>)
    efee:	9b01      	ldr	r3, [sp, #4]
    eff0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    eff4:	2b00      	cmp	r3, #0
    eff6:	d10d      	bne.n	f014 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_24+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    eff8:	f7f1 fcc0 	bl	97c <Adc_schm_read_msr>
    effc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    effe:	9b00      	ldr	r3, [sp, #0]
    f000:	f003 0301 	and.w	r3, r3, #1
    f004:	2b00      	cmp	r3, #0
    f006:	d100      	bne.n	f00a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_24+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    f008:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_24[u32CoreId] = msr;
    f00a:	490a      	ldr	r1, [pc, #40]	; (f034 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_24+0x54>)
    f00c:	9b01      	ldr	r3, [sp, #4]
    f00e:	9a00      	ldr	r2, [sp, #0]
    f010:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_24[u32CoreId]++;
    f014:	4a06      	ldr	r2, [pc, #24]	; (f030 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_24+0x50>)
    f016:	9b01      	ldr	r3, [sp, #4]
    f018:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f01c:	1c5a      	adds	r2, r3, #1
    f01e:	4904      	ldr	r1, [pc, #16]	; (f030 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_24+0x50>)
    f020:	9b01      	ldr	r3, [sp, #4]
    f022:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    f026:	bf00      	nop
    f028:	b003      	add	sp, #12
    f02a:	f85d fb04 	ldr.w	pc, [sp], #4
    f02e:	bf00      	nop
    f030:	1fff9124 	.word	0x1fff9124
    f034:	1fff9120 	.word	0x1fff9120

0000f038 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_24>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_24(void)
{
    f038:	b500      	push	{lr}
    f03a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f03c:	f7f1 fdac 	bl	b98 <Sys_GetCoreID>
    f040:	4603      	mov	r3, r0
    f042:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_24[u32CoreId]--;
    f044:	4a0d      	ldr	r2, [pc, #52]	; (f07c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_24+0x44>)
    f046:	9b01      	ldr	r3, [sp, #4]
    f048:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f04c:	1e5a      	subs	r2, r3, #1
    f04e:	490b      	ldr	r1, [pc, #44]	; (f07c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_24+0x44>)
    f050:	9b01      	ldr	r3, [sp, #4]
    f052:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_24[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_24[u32CoreId]))         /*if interrupts were enabled*/
    f056:	4a0a      	ldr	r2, [pc, #40]	; (f080 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_24+0x48>)
    f058:	9b01      	ldr	r3, [sp, #4]
    f05a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f05e:	f003 0301 	and.w	r3, r3, #1
    f062:	2b00      	cmp	r3, #0
    f064:	d106      	bne.n	f074 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_24+0x3c>
    f066:	4a05      	ldr	r2, [pc, #20]	; (f07c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_24+0x44>)
    f068:	9b01      	ldr	r3, [sp, #4]
    f06a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f06e:	2b00      	cmp	r3, #0
    f070:	d100      	bne.n	f074 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_24+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    f072:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    f074:	bf00      	nop
    f076:	b003      	add	sp, #12
    f078:	f85d fb04 	ldr.w	pc, [sp], #4
    f07c:	1fff9124 	.word	0x1fff9124
    f080:	1fff9120 	.word	0x1fff9120

0000f084 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_25>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_25(void)
{
    f084:	b500      	push	{lr}
    f086:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f088:	f7f1 fd86 	bl	b98 <Sys_GetCoreID>
    f08c:	4603      	mov	r3, r0
    f08e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_25[u32CoreId])
    f090:	4a10      	ldr	r2, [pc, #64]	; (f0d4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_25+0x50>)
    f092:	9b01      	ldr	r3, [sp, #4]
    f094:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f098:	2b00      	cmp	r3, #0
    f09a:	d10d      	bne.n	f0b8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_25+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    f09c:	f7f1 fc6e 	bl	97c <Adc_schm_read_msr>
    f0a0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    f0a2:	9b00      	ldr	r3, [sp, #0]
    f0a4:	f003 0301 	and.w	r3, r3, #1
    f0a8:	2b00      	cmp	r3, #0
    f0aa:	d100      	bne.n	f0ae <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_25+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    f0ac:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_25[u32CoreId] = msr;
    f0ae:	490a      	ldr	r1, [pc, #40]	; (f0d8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_25+0x54>)
    f0b0:	9b01      	ldr	r3, [sp, #4]
    f0b2:	9a00      	ldr	r2, [sp, #0]
    f0b4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_25[u32CoreId]++;
    f0b8:	4a06      	ldr	r2, [pc, #24]	; (f0d4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_25+0x50>)
    f0ba:	9b01      	ldr	r3, [sp, #4]
    f0bc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f0c0:	1c5a      	adds	r2, r3, #1
    f0c2:	4904      	ldr	r1, [pc, #16]	; (f0d4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_25+0x50>)
    f0c4:	9b01      	ldr	r3, [sp, #4]
    f0c6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    f0ca:	bf00      	nop
    f0cc:	b003      	add	sp, #12
    f0ce:	f85d fb04 	ldr.w	pc, [sp], #4
    f0d2:	bf00      	nop
    f0d4:	1fff912c 	.word	0x1fff912c
    f0d8:	1fff9128 	.word	0x1fff9128

0000f0dc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_25>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_25(void)
{
    f0dc:	b500      	push	{lr}
    f0de:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f0e0:	f7f1 fd5a 	bl	b98 <Sys_GetCoreID>
    f0e4:	4603      	mov	r3, r0
    f0e6:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_25[u32CoreId]--;
    f0e8:	4a0d      	ldr	r2, [pc, #52]	; (f120 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_25+0x44>)
    f0ea:	9b01      	ldr	r3, [sp, #4]
    f0ec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f0f0:	1e5a      	subs	r2, r3, #1
    f0f2:	490b      	ldr	r1, [pc, #44]	; (f120 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_25+0x44>)
    f0f4:	9b01      	ldr	r3, [sp, #4]
    f0f6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_25[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_25[u32CoreId]))         /*if interrupts were enabled*/
    f0fa:	4a0a      	ldr	r2, [pc, #40]	; (f124 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_25+0x48>)
    f0fc:	9b01      	ldr	r3, [sp, #4]
    f0fe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f102:	f003 0301 	and.w	r3, r3, #1
    f106:	2b00      	cmp	r3, #0
    f108:	d106      	bne.n	f118 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_25+0x3c>
    f10a:	4a05      	ldr	r2, [pc, #20]	; (f120 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_25+0x44>)
    f10c:	9b01      	ldr	r3, [sp, #4]
    f10e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f112:	2b00      	cmp	r3, #0
    f114:	d100      	bne.n	f118 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_25+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    f116:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    f118:	bf00      	nop
    f11a:	b003      	add	sp, #12
    f11c:	f85d fb04 	ldr.w	pc, [sp], #4
    f120:	1fff912c 	.word	0x1fff912c
    f124:	1fff9128 	.word	0x1fff9128

0000f128 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_26>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_26(void)
{
    f128:	b500      	push	{lr}
    f12a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f12c:	f7f1 fd34 	bl	b98 <Sys_GetCoreID>
    f130:	4603      	mov	r3, r0
    f132:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_26[u32CoreId])
    f134:	4a10      	ldr	r2, [pc, #64]	; (f178 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_26+0x50>)
    f136:	9b01      	ldr	r3, [sp, #4]
    f138:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f13c:	2b00      	cmp	r3, #0
    f13e:	d10d      	bne.n	f15c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_26+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    f140:	f7f1 fc1c 	bl	97c <Adc_schm_read_msr>
    f144:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    f146:	9b00      	ldr	r3, [sp, #0]
    f148:	f003 0301 	and.w	r3, r3, #1
    f14c:	2b00      	cmp	r3, #0
    f14e:	d100      	bne.n	f152 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_26+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    f150:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_26[u32CoreId] = msr;
    f152:	490a      	ldr	r1, [pc, #40]	; (f17c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_26+0x54>)
    f154:	9b01      	ldr	r3, [sp, #4]
    f156:	9a00      	ldr	r2, [sp, #0]
    f158:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_26[u32CoreId]++;
    f15c:	4a06      	ldr	r2, [pc, #24]	; (f178 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_26+0x50>)
    f15e:	9b01      	ldr	r3, [sp, #4]
    f160:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f164:	1c5a      	adds	r2, r3, #1
    f166:	4904      	ldr	r1, [pc, #16]	; (f178 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_26+0x50>)
    f168:	9b01      	ldr	r3, [sp, #4]
    f16a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    f16e:	bf00      	nop
    f170:	b003      	add	sp, #12
    f172:	f85d fb04 	ldr.w	pc, [sp], #4
    f176:	bf00      	nop
    f178:	1fff9134 	.word	0x1fff9134
    f17c:	1fff9130 	.word	0x1fff9130

0000f180 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_26>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_26(void)
{
    f180:	b500      	push	{lr}
    f182:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f184:	f7f1 fd08 	bl	b98 <Sys_GetCoreID>
    f188:	4603      	mov	r3, r0
    f18a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_26[u32CoreId]--;
    f18c:	4a0d      	ldr	r2, [pc, #52]	; (f1c4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_26+0x44>)
    f18e:	9b01      	ldr	r3, [sp, #4]
    f190:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f194:	1e5a      	subs	r2, r3, #1
    f196:	490b      	ldr	r1, [pc, #44]	; (f1c4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_26+0x44>)
    f198:	9b01      	ldr	r3, [sp, #4]
    f19a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_26[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_26[u32CoreId]))         /*if interrupts were enabled*/
    f19e:	4a0a      	ldr	r2, [pc, #40]	; (f1c8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_26+0x48>)
    f1a0:	9b01      	ldr	r3, [sp, #4]
    f1a2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f1a6:	f003 0301 	and.w	r3, r3, #1
    f1aa:	2b00      	cmp	r3, #0
    f1ac:	d106      	bne.n	f1bc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_26+0x3c>
    f1ae:	4a05      	ldr	r2, [pc, #20]	; (f1c4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_26+0x44>)
    f1b0:	9b01      	ldr	r3, [sp, #4]
    f1b2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f1b6:	2b00      	cmp	r3, #0
    f1b8:	d100      	bne.n	f1bc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_26+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    f1ba:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    f1bc:	bf00      	nop
    f1be:	b003      	add	sp, #12
    f1c0:	f85d fb04 	ldr.w	pc, [sp], #4
    f1c4:	1fff9134 	.word	0x1fff9134
    f1c8:	1fff9130 	.word	0x1fff9130

0000f1cc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_27>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_27(void)
{
    f1cc:	b500      	push	{lr}
    f1ce:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f1d0:	f7f1 fce2 	bl	b98 <Sys_GetCoreID>
    f1d4:	4603      	mov	r3, r0
    f1d6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_27[u32CoreId])
    f1d8:	4a10      	ldr	r2, [pc, #64]	; (f21c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_27+0x50>)
    f1da:	9b01      	ldr	r3, [sp, #4]
    f1dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f1e0:	2b00      	cmp	r3, #0
    f1e2:	d10d      	bne.n	f200 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_27+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    f1e4:	f7f1 fbca 	bl	97c <Adc_schm_read_msr>
    f1e8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    f1ea:	9b00      	ldr	r3, [sp, #0]
    f1ec:	f003 0301 	and.w	r3, r3, #1
    f1f0:	2b00      	cmp	r3, #0
    f1f2:	d100      	bne.n	f1f6 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_27+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    f1f4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_27[u32CoreId] = msr;
    f1f6:	490a      	ldr	r1, [pc, #40]	; (f220 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_27+0x54>)
    f1f8:	9b01      	ldr	r3, [sp, #4]
    f1fa:	9a00      	ldr	r2, [sp, #0]
    f1fc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_27[u32CoreId]++;
    f200:	4a06      	ldr	r2, [pc, #24]	; (f21c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_27+0x50>)
    f202:	9b01      	ldr	r3, [sp, #4]
    f204:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f208:	1c5a      	adds	r2, r3, #1
    f20a:	4904      	ldr	r1, [pc, #16]	; (f21c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_27+0x50>)
    f20c:	9b01      	ldr	r3, [sp, #4]
    f20e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    f212:	bf00      	nop
    f214:	b003      	add	sp, #12
    f216:	f85d fb04 	ldr.w	pc, [sp], #4
    f21a:	bf00      	nop
    f21c:	1fff913c 	.word	0x1fff913c
    f220:	1fff9138 	.word	0x1fff9138

0000f224 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_27>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_27(void)
{
    f224:	b500      	push	{lr}
    f226:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f228:	f7f1 fcb6 	bl	b98 <Sys_GetCoreID>
    f22c:	4603      	mov	r3, r0
    f22e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_27[u32CoreId]--;
    f230:	4a0d      	ldr	r2, [pc, #52]	; (f268 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_27+0x44>)
    f232:	9b01      	ldr	r3, [sp, #4]
    f234:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f238:	1e5a      	subs	r2, r3, #1
    f23a:	490b      	ldr	r1, [pc, #44]	; (f268 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_27+0x44>)
    f23c:	9b01      	ldr	r3, [sp, #4]
    f23e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_27[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_27[u32CoreId]))         /*if interrupts were enabled*/
    f242:	4a0a      	ldr	r2, [pc, #40]	; (f26c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_27+0x48>)
    f244:	9b01      	ldr	r3, [sp, #4]
    f246:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f24a:	f003 0301 	and.w	r3, r3, #1
    f24e:	2b00      	cmp	r3, #0
    f250:	d106      	bne.n	f260 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_27+0x3c>
    f252:	4a05      	ldr	r2, [pc, #20]	; (f268 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_27+0x44>)
    f254:	9b01      	ldr	r3, [sp, #4]
    f256:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f25a:	2b00      	cmp	r3, #0
    f25c:	d100      	bne.n	f260 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_27+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    f25e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    f260:	bf00      	nop
    f262:	b003      	add	sp, #12
    f264:	f85d fb04 	ldr.w	pc, [sp], #4
    f268:	1fff913c 	.word	0x1fff913c
    f26c:	1fff9138 	.word	0x1fff9138

0000f270 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_28>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_28(void)
{
    f270:	b500      	push	{lr}
    f272:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f274:	f7f1 fc90 	bl	b98 <Sys_GetCoreID>
    f278:	4603      	mov	r3, r0
    f27a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_28[u32CoreId])
    f27c:	4a10      	ldr	r2, [pc, #64]	; (f2c0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_28+0x50>)
    f27e:	9b01      	ldr	r3, [sp, #4]
    f280:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f284:	2b00      	cmp	r3, #0
    f286:	d10d      	bne.n	f2a4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_28+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    f288:	f7f1 fb78 	bl	97c <Adc_schm_read_msr>
    f28c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    f28e:	9b00      	ldr	r3, [sp, #0]
    f290:	f003 0301 	and.w	r3, r3, #1
    f294:	2b00      	cmp	r3, #0
    f296:	d100      	bne.n	f29a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_28+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    f298:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_28[u32CoreId] = msr;
    f29a:	490a      	ldr	r1, [pc, #40]	; (f2c4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_28+0x54>)
    f29c:	9b01      	ldr	r3, [sp, #4]
    f29e:	9a00      	ldr	r2, [sp, #0]
    f2a0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_28[u32CoreId]++;
    f2a4:	4a06      	ldr	r2, [pc, #24]	; (f2c0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_28+0x50>)
    f2a6:	9b01      	ldr	r3, [sp, #4]
    f2a8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f2ac:	1c5a      	adds	r2, r3, #1
    f2ae:	4904      	ldr	r1, [pc, #16]	; (f2c0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_28+0x50>)
    f2b0:	9b01      	ldr	r3, [sp, #4]
    f2b2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    f2b6:	bf00      	nop
    f2b8:	b003      	add	sp, #12
    f2ba:	f85d fb04 	ldr.w	pc, [sp], #4
    f2be:	bf00      	nop
    f2c0:	1fff9144 	.word	0x1fff9144
    f2c4:	1fff9140 	.word	0x1fff9140

0000f2c8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_28>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_28(void)
{
    f2c8:	b500      	push	{lr}
    f2ca:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f2cc:	f7f1 fc64 	bl	b98 <Sys_GetCoreID>
    f2d0:	4603      	mov	r3, r0
    f2d2:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_28[u32CoreId]--;
    f2d4:	4a0d      	ldr	r2, [pc, #52]	; (f30c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_28+0x44>)
    f2d6:	9b01      	ldr	r3, [sp, #4]
    f2d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f2dc:	1e5a      	subs	r2, r3, #1
    f2de:	490b      	ldr	r1, [pc, #44]	; (f30c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_28+0x44>)
    f2e0:	9b01      	ldr	r3, [sp, #4]
    f2e2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_28[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_28[u32CoreId]))         /*if interrupts were enabled*/
    f2e6:	4a0a      	ldr	r2, [pc, #40]	; (f310 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_28+0x48>)
    f2e8:	9b01      	ldr	r3, [sp, #4]
    f2ea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f2ee:	f003 0301 	and.w	r3, r3, #1
    f2f2:	2b00      	cmp	r3, #0
    f2f4:	d106      	bne.n	f304 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_28+0x3c>
    f2f6:	4a05      	ldr	r2, [pc, #20]	; (f30c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_28+0x44>)
    f2f8:	9b01      	ldr	r3, [sp, #4]
    f2fa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f2fe:	2b00      	cmp	r3, #0
    f300:	d100      	bne.n	f304 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_28+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    f302:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    f304:	bf00      	nop
    f306:	b003      	add	sp, #12
    f308:	f85d fb04 	ldr.w	pc, [sp], #4
    f30c:	1fff9144 	.word	0x1fff9144
    f310:	1fff9140 	.word	0x1fff9140

0000f314 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_29>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_29(void)
{
    f314:	b500      	push	{lr}
    f316:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f318:	f7f1 fc3e 	bl	b98 <Sys_GetCoreID>
    f31c:	4603      	mov	r3, r0
    f31e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_29[u32CoreId])
    f320:	4a10      	ldr	r2, [pc, #64]	; (f364 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_29+0x50>)
    f322:	9b01      	ldr	r3, [sp, #4]
    f324:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f328:	2b00      	cmp	r3, #0
    f32a:	d10d      	bne.n	f348 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_29+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    f32c:	f7f1 fb26 	bl	97c <Adc_schm_read_msr>
    f330:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    f332:	9b00      	ldr	r3, [sp, #0]
    f334:	f003 0301 	and.w	r3, r3, #1
    f338:	2b00      	cmp	r3, #0
    f33a:	d100      	bne.n	f33e <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_29+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    f33c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_29[u32CoreId] = msr;
    f33e:	490a      	ldr	r1, [pc, #40]	; (f368 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_29+0x54>)
    f340:	9b01      	ldr	r3, [sp, #4]
    f342:	9a00      	ldr	r2, [sp, #0]
    f344:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_29[u32CoreId]++;
    f348:	4a06      	ldr	r2, [pc, #24]	; (f364 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_29+0x50>)
    f34a:	9b01      	ldr	r3, [sp, #4]
    f34c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f350:	1c5a      	adds	r2, r3, #1
    f352:	4904      	ldr	r1, [pc, #16]	; (f364 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_29+0x50>)
    f354:	9b01      	ldr	r3, [sp, #4]
    f356:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    f35a:	bf00      	nop
    f35c:	b003      	add	sp, #12
    f35e:	f85d fb04 	ldr.w	pc, [sp], #4
    f362:	bf00      	nop
    f364:	1fff914c 	.word	0x1fff914c
    f368:	1fff9148 	.word	0x1fff9148

0000f36c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_29>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_29(void)
{
    f36c:	b500      	push	{lr}
    f36e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f370:	f7f1 fc12 	bl	b98 <Sys_GetCoreID>
    f374:	4603      	mov	r3, r0
    f376:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_29[u32CoreId]--;
    f378:	4a0d      	ldr	r2, [pc, #52]	; (f3b0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_29+0x44>)
    f37a:	9b01      	ldr	r3, [sp, #4]
    f37c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f380:	1e5a      	subs	r2, r3, #1
    f382:	490b      	ldr	r1, [pc, #44]	; (f3b0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_29+0x44>)
    f384:	9b01      	ldr	r3, [sp, #4]
    f386:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_29[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_29[u32CoreId]))         /*if interrupts were enabled*/
    f38a:	4a0a      	ldr	r2, [pc, #40]	; (f3b4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_29+0x48>)
    f38c:	9b01      	ldr	r3, [sp, #4]
    f38e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f392:	f003 0301 	and.w	r3, r3, #1
    f396:	2b00      	cmp	r3, #0
    f398:	d106      	bne.n	f3a8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_29+0x3c>
    f39a:	4a05      	ldr	r2, [pc, #20]	; (f3b0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_29+0x44>)
    f39c:	9b01      	ldr	r3, [sp, #4]
    f39e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f3a2:	2b00      	cmp	r3, #0
    f3a4:	d100      	bne.n	f3a8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_29+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    f3a6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    f3a8:	bf00      	nop
    f3aa:	b003      	add	sp, #12
    f3ac:	f85d fb04 	ldr.w	pc, [sp], #4
    f3b0:	1fff914c 	.word	0x1fff914c
    f3b4:	1fff9148 	.word	0x1fff9148

0000f3b8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_30>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_30(void)
{
    f3b8:	b500      	push	{lr}
    f3ba:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f3bc:	f7f1 fbec 	bl	b98 <Sys_GetCoreID>
    f3c0:	4603      	mov	r3, r0
    f3c2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_30[u32CoreId])
    f3c4:	4a10      	ldr	r2, [pc, #64]	; (f408 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_30+0x50>)
    f3c6:	9b01      	ldr	r3, [sp, #4]
    f3c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f3cc:	2b00      	cmp	r3, #0
    f3ce:	d10d      	bne.n	f3ec <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_30+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    f3d0:	f7f1 fad4 	bl	97c <Adc_schm_read_msr>
    f3d4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    f3d6:	9b00      	ldr	r3, [sp, #0]
    f3d8:	f003 0301 	and.w	r3, r3, #1
    f3dc:	2b00      	cmp	r3, #0
    f3de:	d100      	bne.n	f3e2 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_30+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    f3e0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_30[u32CoreId] = msr;
    f3e2:	490a      	ldr	r1, [pc, #40]	; (f40c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_30+0x54>)
    f3e4:	9b01      	ldr	r3, [sp, #4]
    f3e6:	9a00      	ldr	r2, [sp, #0]
    f3e8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_30[u32CoreId]++;
    f3ec:	4a06      	ldr	r2, [pc, #24]	; (f408 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_30+0x50>)
    f3ee:	9b01      	ldr	r3, [sp, #4]
    f3f0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f3f4:	1c5a      	adds	r2, r3, #1
    f3f6:	4904      	ldr	r1, [pc, #16]	; (f408 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_30+0x50>)
    f3f8:	9b01      	ldr	r3, [sp, #4]
    f3fa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    f3fe:	bf00      	nop
    f400:	b003      	add	sp, #12
    f402:	f85d fb04 	ldr.w	pc, [sp], #4
    f406:	bf00      	nop
    f408:	1fff9154 	.word	0x1fff9154
    f40c:	1fff9150 	.word	0x1fff9150

0000f410 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_30>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_30(void)
{
    f410:	b500      	push	{lr}
    f412:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f414:	f7f1 fbc0 	bl	b98 <Sys_GetCoreID>
    f418:	4603      	mov	r3, r0
    f41a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_30[u32CoreId]--;
    f41c:	4a0d      	ldr	r2, [pc, #52]	; (f454 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_30+0x44>)
    f41e:	9b01      	ldr	r3, [sp, #4]
    f420:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f424:	1e5a      	subs	r2, r3, #1
    f426:	490b      	ldr	r1, [pc, #44]	; (f454 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_30+0x44>)
    f428:	9b01      	ldr	r3, [sp, #4]
    f42a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_30[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_30[u32CoreId]))         /*if interrupts were enabled*/
    f42e:	4a0a      	ldr	r2, [pc, #40]	; (f458 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_30+0x48>)
    f430:	9b01      	ldr	r3, [sp, #4]
    f432:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f436:	f003 0301 	and.w	r3, r3, #1
    f43a:	2b00      	cmp	r3, #0
    f43c:	d106      	bne.n	f44c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_30+0x3c>
    f43e:	4a05      	ldr	r2, [pc, #20]	; (f454 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_30+0x44>)
    f440:	9b01      	ldr	r3, [sp, #4]
    f442:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f446:	2b00      	cmp	r3, #0
    f448:	d100      	bne.n	f44c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_30+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    f44a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    f44c:	bf00      	nop
    f44e:	b003      	add	sp, #12
    f450:	f85d fb04 	ldr.w	pc, [sp], #4
    f454:	1fff9154 	.word	0x1fff9154
    f458:	1fff9150 	.word	0x1fff9150

0000f45c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_31>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_31(void)
{
    f45c:	b500      	push	{lr}
    f45e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f460:	f7f1 fb9a 	bl	b98 <Sys_GetCoreID>
    f464:	4603      	mov	r3, r0
    f466:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_31[u32CoreId])
    f468:	4a10      	ldr	r2, [pc, #64]	; (f4ac <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_31+0x50>)
    f46a:	9b01      	ldr	r3, [sp, #4]
    f46c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f470:	2b00      	cmp	r3, #0
    f472:	d10d      	bne.n	f490 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_31+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    f474:	f7f1 fa82 	bl	97c <Adc_schm_read_msr>
    f478:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    f47a:	9b00      	ldr	r3, [sp, #0]
    f47c:	f003 0301 	and.w	r3, r3, #1
    f480:	2b00      	cmp	r3, #0
    f482:	d100      	bne.n	f486 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_31+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    f484:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_31[u32CoreId] = msr;
    f486:	490a      	ldr	r1, [pc, #40]	; (f4b0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_31+0x54>)
    f488:	9b01      	ldr	r3, [sp, #4]
    f48a:	9a00      	ldr	r2, [sp, #0]
    f48c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_31[u32CoreId]++;
    f490:	4a06      	ldr	r2, [pc, #24]	; (f4ac <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_31+0x50>)
    f492:	9b01      	ldr	r3, [sp, #4]
    f494:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f498:	1c5a      	adds	r2, r3, #1
    f49a:	4904      	ldr	r1, [pc, #16]	; (f4ac <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_31+0x50>)
    f49c:	9b01      	ldr	r3, [sp, #4]
    f49e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    f4a2:	bf00      	nop
    f4a4:	b003      	add	sp, #12
    f4a6:	f85d fb04 	ldr.w	pc, [sp], #4
    f4aa:	bf00      	nop
    f4ac:	1fff915c 	.word	0x1fff915c
    f4b0:	1fff9158 	.word	0x1fff9158

0000f4b4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_31>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_31(void)
{
    f4b4:	b500      	push	{lr}
    f4b6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f4b8:	f7f1 fb6e 	bl	b98 <Sys_GetCoreID>
    f4bc:	4603      	mov	r3, r0
    f4be:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_31[u32CoreId]--;
    f4c0:	4a0d      	ldr	r2, [pc, #52]	; (f4f8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_31+0x44>)
    f4c2:	9b01      	ldr	r3, [sp, #4]
    f4c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f4c8:	1e5a      	subs	r2, r3, #1
    f4ca:	490b      	ldr	r1, [pc, #44]	; (f4f8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_31+0x44>)
    f4cc:	9b01      	ldr	r3, [sp, #4]
    f4ce:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_31[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_31[u32CoreId]))         /*if interrupts were enabled*/
    f4d2:	4a0a      	ldr	r2, [pc, #40]	; (f4fc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_31+0x48>)
    f4d4:	9b01      	ldr	r3, [sp, #4]
    f4d6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f4da:	f003 0301 	and.w	r3, r3, #1
    f4de:	2b00      	cmp	r3, #0
    f4e0:	d106      	bne.n	f4f0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_31+0x3c>
    f4e2:	4a05      	ldr	r2, [pc, #20]	; (f4f8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_31+0x44>)
    f4e4:	9b01      	ldr	r3, [sp, #4]
    f4e6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f4ea:	2b00      	cmp	r3, #0
    f4ec:	d100      	bne.n	f4f0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_31+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    f4ee:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    f4f0:	bf00      	nop
    f4f2:	b003      	add	sp, #12
    f4f4:	f85d fb04 	ldr.w	pc, [sp], #4
    f4f8:	1fff915c 	.word	0x1fff915c
    f4fc:	1fff9158 	.word	0x1fff9158

0000f500 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_32>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_32(void)
{
    f500:	b500      	push	{lr}
    f502:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f504:	f7f1 fb48 	bl	b98 <Sys_GetCoreID>
    f508:	4603      	mov	r3, r0
    f50a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_32[u32CoreId])
    f50c:	4a10      	ldr	r2, [pc, #64]	; (f550 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_32+0x50>)
    f50e:	9b01      	ldr	r3, [sp, #4]
    f510:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f514:	2b00      	cmp	r3, #0
    f516:	d10d      	bne.n	f534 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_32+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    f518:	f7f1 fa30 	bl	97c <Adc_schm_read_msr>
    f51c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    f51e:	9b00      	ldr	r3, [sp, #0]
    f520:	f003 0301 	and.w	r3, r3, #1
    f524:	2b00      	cmp	r3, #0
    f526:	d100      	bne.n	f52a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_32+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    f528:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_32[u32CoreId] = msr;
    f52a:	490a      	ldr	r1, [pc, #40]	; (f554 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_32+0x54>)
    f52c:	9b01      	ldr	r3, [sp, #4]
    f52e:	9a00      	ldr	r2, [sp, #0]
    f530:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_32[u32CoreId]++;
    f534:	4a06      	ldr	r2, [pc, #24]	; (f550 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_32+0x50>)
    f536:	9b01      	ldr	r3, [sp, #4]
    f538:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f53c:	1c5a      	adds	r2, r3, #1
    f53e:	4904      	ldr	r1, [pc, #16]	; (f550 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_32+0x50>)
    f540:	9b01      	ldr	r3, [sp, #4]
    f542:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    f546:	bf00      	nop
    f548:	b003      	add	sp, #12
    f54a:	f85d fb04 	ldr.w	pc, [sp], #4
    f54e:	bf00      	nop
    f550:	1fff9164 	.word	0x1fff9164
    f554:	1fff9160 	.word	0x1fff9160

0000f558 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_32>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_32(void)
{
    f558:	b500      	push	{lr}
    f55a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f55c:	f7f1 fb1c 	bl	b98 <Sys_GetCoreID>
    f560:	4603      	mov	r3, r0
    f562:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_32[u32CoreId]--;
    f564:	4a0d      	ldr	r2, [pc, #52]	; (f59c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_32+0x44>)
    f566:	9b01      	ldr	r3, [sp, #4]
    f568:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f56c:	1e5a      	subs	r2, r3, #1
    f56e:	490b      	ldr	r1, [pc, #44]	; (f59c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_32+0x44>)
    f570:	9b01      	ldr	r3, [sp, #4]
    f572:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_32[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_32[u32CoreId]))         /*if interrupts were enabled*/
    f576:	4a0a      	ldr	r2, [pc, #40]	; (f5a0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_32+0x48>)
    f578:	9b01      	ldr	r3, [sp, #4]
    f57a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f57e:	f003 0301 	and.w	r3, r3, #1
    f582:	2b00      	cmp	r3, #0
    f584:	d106      	bne.n	f594 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_32+0x3c>
    f586:	4a05      	ldr	r2, [pc, #20]	; (f59c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_32+0x44>)
    f588:	9b01      	ldr	r3, [sp, #4]
    f58a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f58e:	2b00      	cmp	r3, #0
    f590:	d100      	bne.n	f594 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_32+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    f592:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    f594:	bf00      	nop
    f596:	b003      	add	sp, #12
    f598:	f85d fb04 	ldr.w	pc, [sp], #4
    f59c:	1fff9164 	.word	0x1fff9164
    f5a0:	1fff9160 	.word	0x1fff9160

0000f5a4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_33>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_33(void)
{
    f5a4:	b500      	push	{lr}
    f5a6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f5a8:	f7f1 faf6 	bl	b98 <Sys_GetCoreID>
    f5ac:	4603      	mov	r3, r0
    f5ae:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_33[u32CoreId])
    f5b0:	4a10      	ldr	r2, [pc, #64]	; (f5f4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_33+0x50>)
    f5b2:	9b01      	ldr	r3, [sp, #4]
    f5b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f5b8:	2b00      	cmp	r3, #0
    f5ba:	d10d      	bne.n	f5d8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_33+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    f5bc:	f7f1 f9de 	bl	97c <Adc_schm_read_msr>
    f5c0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    f5c2:	9b00      	ldr	r3, [sp, #0]
    f5c4:	f003 0301 	and.w	r3, r3, #1
    f5c8:	2b00      	cmp	r3, #0
    f5ca:	d100      	bne.n	f5ce <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_33+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    f5cc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_33[u32CoreId] = msr;
    f5ce:	490a      	ldr	r1, [pc, #40]	; (f5f8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_33+0x54>)
    f5d0:	9b01      	ldr	r3, [sp, #4]
    f5d2:	9a00      	ldr	r2, [sp, #0]
    f5d4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_33[u32CoreId]++;
    f5d8:	4a06      	ldr	r2, [pc, #24]	; (f5f4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_33+0x50>)
    f5da:	9b01      	ldr	r3, [sp, #4]
    f5dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f5e0:	1c5a      	adds	r2, r3, #1
    f5e2:	4904      	ldr	r1, [pc, #16]	; (f5f4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_33+0x50>)
    f5e4:	9b01      	ldr	r3, [sp, #4]
    f5e6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    f5ea:	bf00      	nop
    f5ec:	b003      	add	sp, #12
    f5ee:	f85d fb04 	ldr.w	pc, [sp], #4
    f5f2:	bf00      	nop
    f5f4:	1fff916c 	.word	0x1fff916c
    f5f8:	1fff9168 	.word	0x1fff9168

0000f5fc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_33>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_33(void)
{
    f5fc:	b500      	push	{lr}
    f5fe:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f600:	f7f1 faca 	bl	b98 <Sys_GetCoreID>
    f604:	4603      	mov	r3, r0
    f606:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_33[u32CoreId]--;
    f608:	4a0d      	ldr	r2, [pc, #52]	; (f640 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_33+0x44>)
    f60a:	9b01      	ldr	r3, [sp, #4]
    f60c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f610:	1e5a      	subs	r2, r3, #1
    f612:	490b      	ldr	r1, [pc, #44]	; (f640 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_33+0x44>)
    f614:	9b01      	ldr	r3, [sp, #4]
    f616:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_33[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_33[u32CoreId]))         /*if interrupts were enabled*/
    f61a:	4a0a      	ldr	r2, [pc, #40]	; (f644 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_33+0x48>)
    f61c:	9b01      	ldr	r3, [sp, #4]
    f61e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f622:	f003 0301 	and.w	r3, r3, #1
    f626:	2b00      	cmp	r3, #0
    f628:	d106      	bne.n	f638 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_33+0x3c>
    f62a:	4a05      	ldr	r2, [pc, #20]	; (f640 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_33+0x44>)
    f62c:	9b01      	ldr	r3, [sp, #4]
    f62e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f632:	2b00      	cmp	r3, #0
    f634:	d100      	bne.n	f638 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_33+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    f636:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    f638:	bf00      	nop
    f63a:	b003      	add	sp, #12
    f63c:	f85d fb04 	ldr.w	pc, [sp], #4
    f640:	1fff916c 	.word	0x1fff916c
    f644:	1fff9168 	.word	0x1fff9168

0000f648 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_34>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_34(void)
{
    f648:	b500      	push	{lr}
    f64a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f64c:	f7f1 faa4 	bl	b98 <Sys_GetCoreID>
    f650:	4603      	mov	r3, r0
    f652:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_34[u32CoreId])
    f654:	4a10      	ldr	r2, [pc, #64]	; (f698 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_34+0x50>)
    f656:	9b01      	ldr	r3, [sp, #4]
    f658:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f65c:	2b00      	cmp	r3, #0
    f65e:	d10d      	bne.n	f67c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_34+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    f660:	f7f1 f98c 	bl	97c <Adc_schm_read_msr>
    f664:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    f666:	9b00      	ldr	r3, [sp, #0]
    f668:	f003 0301 	and.w	r3, r3, #1
    f66c:	2b00      	cmp	r3, #0
    f66e:	d100      	bne.n	f672 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_34+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    f670:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_34[u32CoreId] = msr;
    f672:	490a      	ldr	r1, [pc, #40]	; (f69c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_34+0x54>)
    f674:	9b01      	ldr	r3, [sp, #4]
    f676:	9a00      	ldr	r2, [sp, #0]
    f678:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_34[u32CoreId]++;
    f67c:	4a06      	ldr	r2, [pc, #24]	; (f698 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_34+0x50>)
    f67e:	9b01      	ldr	r3, [sp, #4]
    f680:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f684:	1c5a      	adds	r2, r3, #1
    f686:	4904      	ldr	r1, [pc, #16]	; (f698 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_34+0x50>)
    f688:	9b01      	ldr	r3, [sp, #4]
    f68a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    f68e:	bf00      	nop
    f690:	b003      	add	sp, #12
    f692:	f85d fb04 	ldr.w	pc, [sp], #4
    f696:	bf00      	nop
    f698:	1fff9174 	.word	0x1fff9174
    f69c:	1fff9170 	.word	0x1fff9170

0000f6a0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_34>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_34(void)
{
    f6a0:	b500      	push	{lr}
    f6a2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f6a4:	f7f1 fa78 	bl	b98 <Sys_GetCoreID>
    f6a8:	4603      	mov	r3, r0
    f6aa:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_34[u32CoreId]--;
    f6ac:	4a0d      	ldr	r2, [pc, #52]	; (f6e4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_34+0x44>)
    f6ae:	9b01      	ldr	r3, [sp, #4]
    f6b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f6b4:	1e5a      	subs	r2, r3, #1
    f6b6:	490b      	ldr	r1, [pc, #44]	; (f6e4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_34+0x44>)
    f6b8:	9b01      	ldr	r3, [sp, #4]
    f6ba:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_34[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_34[u32CoreId]))         /*if interrupts were enabled*/
    f6be:	4a0a      	ldr	r2, [pc, #40]	; (f6e8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_34+0x48>)
    f6c0:	9b01      	ldr	r3, [sp, #4]
    f6c2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f6c6:	f003 0301 	and.w	r3, r3, #1
    f6ca:	2b00      	cmp	r3, #0
    f6cc:	d106      	bne.n	f6dc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_34+0x3c>
    f6ce:	4a05      	ldr	r2, [pc, #20]	; (f6e4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_34+0x44>)
    f6d0:	9b01      	ldr	r3, [sp, #4]
    f6d2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f6d6:	2b00      	cmp	r3, #0
    f6d8:	d100      	bne.n	f6dc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_34+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    f6da:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    f6dc:	bf00      	nop
    f6de:	b003      	add	sp, #12
    f6e0:	f85d fb04 	ldr.w	pc, [sp], #4
    f6e4:	1fff9174 	.word	0x1fff9174
    f6e8:	1fff9170 	.word	0x1fff9170

0000f6ec <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_35>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_35(void)
{
    f6ec:	b500      	push	{lr}
    f6ee:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f6f0:	f7f1 fa52 	bl	b98 <Sys_GetCoreID>
    f6f4:	4603      	mov	r3, r0
    f6f6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_35[u32CoreId])
    f6f8:	4a10      	ldr	r2, [pc, #64]	; (f73c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_35+0x50>)
    f6fa:	9b01      	ldr	r3, [sp, #4]
    f6fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f700:	2b00      	cmp	r3, #0
    f702:	d10d      	bne.n	f720 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_35+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    f704:	f7f1 f93a 	bl	97c <Adc_schm_read_msr>
    f708:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    f70a:	9b00      	ldr	r3, [sp, #0]
    f70c:	f003 0301 	and.w	r3, r3, #1
    f710:	2b00      	cmp	r3, #0
    f712:	d100      	bne.n	f716 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_35+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    f714:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_35[u32CoreId] = msr;
    f716:	490a      	ldr	r1, [pc, #40]	; (f740 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_35+0x54>)
    f718:	9b01      	ldr	r3, [sp, #4]
    f71a:	9a00      	ldr	r2, [sp, #0]
    f71c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_35[u32CoreId]++;
    f720:	4a06      	ldr	r2, [pc, #24]	; (f73c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_35+0x50>)
    f722:	9b01      	ldr	r3, [sp, #4]
    f724:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f728:	1c5a      	adds	r2, r3, #1
    f72a:	4904      	ldr	r1, [pc, #16]	; (f73c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_35+0x50>)
    f72c:	9b01      	ldr	r3, [sp, #4]
    f72e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    f732:	bf00      	nop
    f734:	b003      	add	sp, #12
    f736:	f85d fb04 	ldr.w	pc, [sp], #4
    f73a:	bf00      	nop
    f73c:	1fff917c 	.word	0x1fff917c
    f740:	1fff9178 	.word	0x1fff9178

0000f744 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_35>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_35(void)
{
    f744:	b500      	push	{lr}
    f746:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f748:	f7f1 fa26 	bl	b98 <Sys_GetCoreID>
    f74c:	4603      	mov	r3, r0
    f74e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_35[u32CoreId]--;
    f750:	4a0d      	ldr	r2, [pc, #52]	; (f788 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_35+0x44>)
    f752:	9b01      	ldr	r3, [sp, #4]
    f754:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f758:	1e5a      	subs	r2, r3, #1
    f75a:	490b      	ldr	r1, [pc, #44]	; (f788 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_35+0x44>)
    f75c:	9b01      	ldr	r3, [sp, #4]
    f75e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_35[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_35[u32CoreId]))         /*if interrupts were enabled*/
    f762:	4a0a      	ldr	r2, [pc, #40]	; (f78c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_35+0x48>)
    f764:	9b01      	ldr	r3, [sp, #4]
    f766:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f76a:	f003 0301 	and.w	r3, r3, #1
    f76e:	2b00      	cmp	r3, #0
    f770:	d106      	bne.n	f780 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_35+0x3c>
    f772:	4a05      	ldr	r2, [pc, #20]	; (f788 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_35+0x44>)
    f774:	9b01      	ldr	r3, [sp, #4]
    f776:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f77a:	2b00      	cmp	r3, #0
    f77c:	d100      	bne.n	f780 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_35+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    f77e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    f780:	bf00      	nop
    f782:	b003      	add	sp, #12
    f784:	f85d fb04 	ldr.w	pc, [sp], #4
    f788:	1fff917c 	.word	0x1fff917c
    f78c:	1fff9178 	.word	0x1fff9178

0000f790 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_36>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_36(void)
{
    f790:	b500      	push	{lr}
    f792:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f794:	f7f1 fa00 	bl	b98 <Sys_GetCoreID>
    f798:	4603      	mov	r3, r0
    f79a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_36[u32CoreId])
    f79c:	4a10      	ldr	r2, [pc, #64]	; (f7e0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_36+0x50>)
    f79e:	9b01      	ldr	r3, [sp, #4]
    f7a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f7a4:	2b00      	cmp	r3, #0
    f7a6:	d10d      	bne.n	f7c4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_36+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    f7a8:	f7f1 f8e8 	bl	97c <Adc_schm_read_msr>
    f7ac:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    f7ae:	9b00      	ldr	r3, [sp, #0]
    f7b0:	f003 0301 	and.w	r3, r3, #1
    f7b4:	2b00      	cmp	r3, #0
    f7b6:	d100      	bne.n	f7ba <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_36+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    f7b8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_36[u32CoreId] = msr;
    f7ba:	490a      	ldr	r1, [pc, #40]	; (f7e4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_36+0x54>)
    f7bc:	9b01      	ldr	r3, [sp, #4]
    f7be:	9a00      	ldr	r2, [sp, #0]
    f7c0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_36[u32CoreId]++;
    f7c4:	4a06      	ldr	r2, [pc, #24]	; (f7e0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_36+0x50>)
    f7c6:	9b01      	ldr	r3, [sp, #4]
    f7c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f7cc:	1c5a      	adds	r2, r3, #1
    f7ce:	4904      	ldr	r1, [pc, #16]	; (f7e0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_36+0x50>)
    f7d0:	9b01      	ldr	r3, [sp, #4]
    f7d2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    f7d6:	bf00      	nop
    f7d8:	b003      	add	sp, #12
    f7da:	f85d fb04 	ldr.w	pc, [sp], #4
    f7de:	bf00      	nop
    f7e0:	1fff9184 	.word	0x1fff9184
    f7e4:	1fff9180 	.word	0x1fff9180

0000f7e8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_36>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_36(void)
{
    f7e8:	b500      	push	{lr}
    f7ea:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f7ec:	f7f1 f9d4 	bl	b98 <Sys_GetCoreID>
    f7f0:	4603      	mov	r3, r0
    f7f2:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_36[u32CoreId]--;
    f7f4:	4a0d      	ldr	r2, [pc, #52]	; (f82c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_36+0x44>)
    f7f6:	9b01      	ldr	r3, [sp, #4]
    f7f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f7fc:	1e5a      	subs	r2, r3, #1
    f7fe:	490b      	ldr	r1, [pc, #44]	; (f82c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_36+0x44>)
    f800:	9b01      	ldr	r3, [sp, #4]
    f802:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_36[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_36[u32CoreId]))         /*if interrupts were enabled*/
    f806:	4a0a      	ldr	r2, [pc, #40]	; (f830 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_36+0x48>)
    f808:	9b01      	ldr	r3, [sp, #4]
    f80a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f80e:	f003 0301 	and.w	r3, r3, #1
    f812:	2b00      	cmp	r3, #0
    f814:	d106      	bne.n	f824 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_36+0x3c>
    f816:	4a05      	ldr	r2, [pc, #20]	; (f82c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_36+0x44>)
    f818:	9b01      	ldr	r3, [sp, #4]
    f81a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f81e:	2b00      	cmp	r3, #0
    f820:	d100      	bne.n	f824 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_36+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    f822:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    f824:	bf00      	nop
    f826:	b003      	add	sp, #12
    f828:	f85d fb04 	ldr.w	pc, [sp], #4
    f82c:	1fff9184 	.word	0x1fff9184
    f830:	1fff9180 	.word	0x1fff9180

0000f834 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_37>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_37(void)
{
    f834:	b500      	push	{lr}
    f836:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f838:	f7f1 f9ae 	bl	b98 <Sys_GetCoreID>
    f83c:	4603      	mov	r3, r0
    f83e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_37[u32CoreId])
    f840:	4a10      	ldr	r2, [pc, #64]	; (f884 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_37+0x50>)
    f842:	9b01      	ldr	r3, [sp, #4]
    f844:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f848:	2b00      	cmp	r3, #0
    f84a:	d10d      	bne.n	f868 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_37+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    f84c:	f7f1 f896 	bl	97c <Adc_schm_read_msr>
    f850:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    f852:	9b00      	ldr	r3, [sp, #0]
    f854:	f003 0301 	and.w	r3, r3, #1
    f858:	2b00      	cmp	r3, #0
    f85a:	d100      	bne.n	f85e <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_37+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    f85c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_37[u32CoreId] = msr;
    f85e:	490a      	ldr	r1, [pc, #40]	; (f888 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_37+0x54>)
    f860:	9b01      	ldr	r3, [sp, #4]
    f862:	9a00      	ldr	r2, [sp, #0]
    f864:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_37[u32CoreId]++;
    f868:	4a06      	ldr	r2, [pc, #24]	; (f884 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_37+0x50>)
    f86a:	9b01      	ldr	r3, [sp, #4]
    f86c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f870:	1c5a      	adds	r2, r3, #1
    f872:	4904      	ldr	r1, [pc, #16]	; (f884 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_37+0x50>)
    f874:	9b01      	ldr	r3, [sp, #4]
    f876:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    f87a:	bf00      	nop
    f87c:	b003      	add	sp, #12
    f87e:	f85d fb04 	ldr.w	pc, [sp], #4
    f882:	bf00      	nop
    f884:	1fff918c 	.word	0x1fff918c
    f888:	1fff9188 	.word	0x1fff9188

0000f88c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_37>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_37(void)
{
    f88c:	b500      	push	{lr}
    f88e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f890:	f7f1 f982 	bl	b98 <Sys_GetCoreID>
    f894:	4603      	mov	r3, r0
    f896:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_37[u32CoreId]--;
    f898:	4a0d      	ldr	r2, [pc, #52]	; (f8d0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_37+0x44>)
    f89a:	9b01      	ldr	r3, [sp, #4]
    f89c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f8a0:	1e5a      	subs	r2, r3, #1
    f8a2:	490b      	ldr	r1, [pc, #44]	; (f8d0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_37+0x44>)
    f8a4:	9b01      	ldr	r3, [sp, #4]
    f8a6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_37[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_37[u32CoreId]))         /*if interrupts were enabled*/
    f8aa:	4a0a      	ldr	r2, [pc, #40]	; (f8d4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_37+0x48>)
    f8ac:	9b01      	ldr	r3, [sp, #4]
    f8ae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f8b2:	f003 0301 	and.w	r3, r3, #1
    f8b6:	2b00      	cmp	r3, #0
    f8b8:	d106      	bne.n	f8c8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_37+0x3c>
    f8ba:	4a05      	ldr	r2, [pc, #20]	; (f8d0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_37+0x44>)
    f8bc:	9b01      	ldr	r3, [sp, #4]
    f8be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f8c2:	2b00      	cmp	r3, #0
    f8c4:	d100      	bne.n	f8c8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_37+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    f8c6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    f8c8:	bf00      	nop
    f8ca:	b003      	add	sp, #12
    f8cc:	f85d fb04 	ldr.w	pc, [sp], #4
    f8d0:	1fff918c 	.word	0x1fff918c
    f8d4:	1fff9188 	.word	0x1fff9188

0000f8d8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_38>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_38(void)
{
    f8d8:	b500      	push	{lr}
    f8da:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f8dc:	f7f1 f95c 	bl	b98 <Sys_GetCoreID>
    f8e0:	4603      	mov	r3, r0
    f8e2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_38[u32CoreId])
    f8e4:	4a10      	ldr	r2, [pc, #64]	; (f928 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_38+0x50>)
    f8e6:	9b01      	ldr	r3, [sp, #4]
    f8e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f8ec:	2b00      	cmp	r3, #0
    f8ee:	d10d      	bne.n	f90c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_38+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    f8f0:	f7f1 f844 	bl	97c <Adc_schm_read_msr>
    f8f4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    f8f6:	9b00      	ldr	r3, [sp, #0]
    f8f8:	f003 0301 	and.w	r3, r3, #1
    f8fc:	2b00      	cmp	r3, #0
    f8fe:	d100      	bne.n	f902 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_38+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    f900:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_38[u32CoreId] = msr;
    f902:	490a      	ldr	r1, [pc, #40]	; (f92c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_38+0x54>)
    f904:	9b01      	ldr	r3, [sp, #4]
    f906:	9a00      	ldr	r2, [sp, #0]
    f908:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_38[u32CoreId]++;
    f90c:	4a06      	ldr	r2, [pc, #24]	; (f928 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_38+0x50>)
    f90e:	9b01      	ldr	r3, [sp, #4]
    f910:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f914:	1c5a      	adds	r2, r3, #1
    f916:	4904      	ldr	r1, [pc, #16]	; (f928 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_38+0x50>)
    f918:	9b01      	ldr	r3, [sp, #4]
    f91a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    f91e:	bf00      	nop
    f920:	b003      	add	sp, #12
    f922:	f85d fb04 	ldr.w	pc, [sp], #4
    f926:	bf00      	nop
    f928:	1fff9194 	.word	0x1fff9194
    f92c:	1fff9190 	.word	0x1fff9190

0000f930 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_38>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_38(void)
{
    f930:	b500      	push	{lr}
    f932:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f934:	f7f1 f930 	bl	b98 <Sys_GetCoreID>
    f938:	4603      	mov	r3, r0
    f93a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_38[u32CoreId]--;
    f93c:	4a0d      	ldr	r2, [pc, #52]	; (f974 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_38+0x44>)
    f93e:	9b01      	ldr	r3, [sp, #4]
    f940:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f944:	1e5a      	subs	r2, r3, #1
    f946:	490b      	ldr	r1, [pc, #44]	; (f974 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_38+0x44>)
    f948:	9b01      	ldr	r3, [sp, #4]
    f94a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_38[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_38[u32CoreId]))         /*if interrupts were enabled*/
    f94e:	4a0a      	ldr	r2, [pc, #40]	; (f978 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_38+0x48>)
    f950:	9b01      	ldr	r3, [sp, #4]
    f952:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f956:	f003 0301 	and.w	r3, r3, #1
    f95a:	2b00      	cmp	r3, #0
    f95c:	d106      	bne.n	f96c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_38+0x3c>
    f95e:	4a05      	ldr	r2, [pc, #20]	; (f974 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_38+0x44>)
    f960:	9b01      	ldr	r3, [sp, #4]
    f962:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f966:	2b00      	cmp	r3, #0
    f968:	d100      	bne.n	f96c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_38+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    f96a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    f96c:	bf00      	nop
    f96e:	b003      	add	sp, #12
    f970:	f85d fb04 	ldr.w	pc, [sp], #4
    f974:	1fff9194 	.word	0x1fff9194
    f978:	1fff9190 	.word	0x1fff9190

0000f97c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_39>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_39(void)
{
    f97c:	b500      	push	{lr}
    f97e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f980:	f7f1 f90a 	bl	b98 <Sys_GetCoreID>
    f984:	4603      	mov	r3, r0
    f986:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_39[u32CoreId])
    f988:	4a10      	ldr	r2, [pc, #64]	; (f9cc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_39+0x50>)
    f98a:	9b01      	ldr	r3, [sp, #4]
    f98c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f990:	2b00      	cmp	r3, #0
    f992:	d10d      	bne.n	f9b0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_39+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    f994:	f7f0 fff2 	bl	97c <Adc_schm_read_msr>
    f998:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    f99a:	9b00      	ldr	r3, [sp, #0]
    f99c:	f003 0301 	and.w	r3, r3, #1
    f9a0:	2b00      	cmp	r3, #0
    f9a2:	d100      	bne.n	f9a6 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_39+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    f9a4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_39[u32CoreId] = msr;
    f9a6:	490a      	ldr	r1, [pc, #40]	; (f9d0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_39+0x54>)
    f9a8:	9b01      	ldr	r3, [sp, #4]
    f9aa:	9a00      	ldr	r2, [sp, #0]
    f9ac:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_39[u32CoreId]++;
    f9b0:	4a06      	ldr	r2, [pc, #24]	; (f9cc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_39+0x50>)
    f9b2:	9b01      	ldr	r3, [sp, #4]
    f9b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f9b8:	1c5a      	adds	r2, r3, #1
    f9ba:	4904      	ldr	r1, [pc, #16]	; (f9cc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_39+0x50>)
    f9bc:	9b01      	ldr	r3, [sp, #4]
    f9be:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    f9c2:	bf00      	nop
    f9c4:	b003      	add	sp, #12
    f9c6:	f85d fb04 	ldr.w	pc, [sp], #4
    f9ca:	bf00      	nop
    f9cc:	1fff919c 	.word	0x1fff919c
    f9d0:	1fff9198 	.word	0x1fff9198

0000f9d4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_39>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_39(void)
{
    f9d4:	b500      	push	{lr}
    f9d6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    f9d8:	f7f1 f8de 	bl	b98 <Sys_GetCoreID>
    f9dc:	4603      	mov	r3, r0
    f9de:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_39[u32CoreId]--;
    f9e0:	4a0d      	ldr	r2, [pc, #52]	; (fa18 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_39+0x44>)
    f9e2:	9b01      	ldr	r3, [sp, #4]
    f9e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f9e8:	1e5a      	subs	r2, r3, #1
    f9ea:	490b      	ldr	r1, [pc, #44]	; (fa18 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_39+0x44>)
    f9ec:	9b01      	ldr	r3, [sp, #4]
    f9ee:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_39[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_39[u32CoreId]))         /*if interrupts were enabled*/
    f9f2:	4a0a      	ldr	r2, [pc, #40]	; (fa1c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_39+0x48>)
    f9f4:	9b01      	ldr	r3, [sp, #4]
    f9f6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    f9fa:	f003 0301 	and.w	r3, r3, #1
    f9fe:	2b00      	cmp	r3, #0
    fa00:	d106      	bne.n	fa10 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_39+0x3c>
    fa02:	4a05      	ldr	r2, [pc, #20]	; (fa18 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_39+0x44>)
    fa04:	9b01      	ldr	r3, [sp, #4]
    fa06:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fa0a:	2b00      	cmp	r3, #0
    fa0c:	d100      	bne.n	fa10 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_39+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    fa0e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    fa10:	bf00      	nop
    fa12:	b003      	add	sp, #12
    fa14:	f85d fb04 	ldr.w	pc, [sp], #4
    fa18:	1fff919c 	.word	0x1fff919c
    fa1c:	1fff9198 	.word	0x1fff9198

0000fa20 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_40>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_40(void)
{
    fa20:	b500      	push	{lr}
    fa22:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    fa24:	f7f1 f8b8 	bl	b98 <Sys_GetCoreID>
    fa28:	4603      	mov	r3, r0
    fa2a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_40[u32CoreId])
    fa2c:	4a10      	ldr	r2, [pc, #64]	; (fa70 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_40+0x50>)
    fa2e:	9b01      	ldr	r3, [sp, #4]
    fa30:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fa34:	2b00      	cmp	r3, #0
    fa36:	d10d      	bne.n	fa54 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_40+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    fa38:	f7f0 ffa0 	bl	97c <Adc_schm_read_msr>
    fa3c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    fa3e:	9b00      	ldr	r3, [sp, #0]
    fa40:	f003 0301 	and.w	r3, r3, #1
    fa44:	2b00      	cmp	r3, #0
    fa46:	d100      	bne.n	fa4a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_40+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    fa48:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_40[u32CoreId] = msr;
    fa4a:	490a      	ldr	r1, [pc, #40]	; (fa74 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_40+0x54>)
    fa4c:	9b01      	ldr	r3, [sp, #4]
    fa4e:	9a00      	ldr	r2, [sp, #0]
    fa50:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_40[u32CoreId]++;
    fa54:	4a06      	ldr	r2, [pc, #24]	; (fa70 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_40+0x50>)
    fa56:	9b01      	ldr	r3, [sp, #4]
    fa58:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fa5c:	1c5a      	adds	r2, r3, #1
    fa5e:	4904      	ldr	r1, [pc, #16]	; (fa70 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_40+0x50>)
    fa60:	9b01      	ldr	r3, [sp, #4]
    fa62:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    fa66:	bf00      	nop
    fa68:	b003      	add	sp, #12
    fa6a:	f85d fb04 	ldr.w	pc, [sp], #4
    fa6e:	bf00      	nop
    fa70:	1fff91a4 	.word	0x1fff91a4
    fa74:	1fff91a0 	.word	0x1fff91a0

0000fa78 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_40>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_40(void)
{
    fa78:	b500      	push	{lr}
    fa7a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    fa7c:	f7f1 f88c 	bl	b98 <Sys_GetCoreID>
    fa80:	4603      	mov	r3, r0
    fa82:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_40[u32CoreId]--;
    fa84:	4a0d      	ldr	r2, [pc, #52]	; (fabc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_40+0x44>)
    fa86:	9b01      	ldr	r3, [sp, #4]
    fa88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fa8c:	1e5a      	subs	r2, r3, #1
    fa8e:	490b      	ldr	r1, [pc, #44]	; (fabc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_40+0x44>)
    fa90:	9b01      	ldr	r3, [sp, #4]
    fa92:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_40[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_40[u32CoreId]))         /*if interrupts were enabled*/
    fa96:	4a0a      	ldr	r2, [pc, #40]	; (fac0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_40+0x48>)
    fa98:	9b01      	ldr	r3, [sp, #4]
    fa9a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fa9e:	f003 0301 	and.w	r3, r3, #1
    faa2:	2b00      	cmp	r3, #0
    faa4:	d106      	bne.n	fab4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_40+0x3c>
    faa6:	4a05      	ldr	r2, [pc, #20]	; (fabc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_40+0x44>)
    faa8:	9b01      	ldr	r3, [sp, #4]
    faaa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    faae:	2b00      	cmp	r3, #0
    fab0:	d100      	bne.n	fab4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_40+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    fab2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    fab4:	bf00      	nop
    fab6:	b003      	add	sp, #12
    fab8:	f85d fb04 	ldr.w	pc, [sp], #4
    fabc:	1fff91a4 	.word	0x1fff91a4
    fac0:	1fff91a0 	.word	0x1fff91a0

0000fac4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_41>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_41(void)
{
    fac4:	b500      	push	{lr}
    fac6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    fac8:	f7f1 f866 	bl	b98 <Sys_GetCoreID>
    facc:	4603      	mov	r3, r0
    face:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_41[u32CoreId])
    fad0:	4a10      	ldr	r2, [pc, #64]	; (fb14 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_41+0x50>)
    fad2:	9b01      	ldr	r3, [sp, #4]
    fad4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fad8:	2b00      	cmp	r3, #0
    fada:	d10d      	bne.n	faf8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_41+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    fadc:	f7f0 ff4e 	bl	97c <Adc_schm_read_msr>
    fae0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    fae2:	9b00      	ldr	r3, [sp, #0]
    fae4:	f003 0301 	and.w	r3, r3, #1
    fae8:	2b00      	cmp	r3, #0
    faea:	d100      	bne.n	faee <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_41+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    faec:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_41[u32CoreId] = msr;
    faee:	490a      	ldr	r1, [pc, #40]	; (fb18 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_41+0x54>)
    faf0:	9b01      	ldr	r3, [sp, #4]
    faf2:	9a00      	ldr	r2, [sp, #0]
    faf4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_41[u32CoreId]++;
    faf8:	4a06      	ldr	r2, [pc, #24]	; (fb14 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_41+0x50>)
    fafa:	9b01      	ldr	r3, [sp, #4]
    fafc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fb00:	1c5a      	adds	r2, r3, #1
    fb02:	4904      	ldr	r1, [pc, #16]	; (fb14 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_41+0x50>)
    fb04:	9b01      	ldr	r3, [sp, #4]
    fb06:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    fb0a:	bf00      	nop
    fb0c:	b003      	add	sp, #12
    fb0e:	f85d fb04 	ldr.w	pc, [sp], #4
    fb12:	bf00      	nop
    fb14:	1fff91ac 	.word	0x1fff91ac
    fb18:	1fff91a8 	.word	0x1fff91a8

0000fb1c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_41>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_41(void)
{
    fb1c:	b500      	push	{lr}
    fb1e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    fb20:	f7f1 f83a 	bl	b98 <Sys_GetCoreID>
    fb24:	4603      	mov	r3, r0
    fb26:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_41[u32CoreId]--;
    fb28:	4a0d      	ldr	r2, [pc, #52]	; (fb60 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_41+0x44>)
    fb2a:	9b01      	ldr	r3, [sp, #4]
    fb2c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fb30:	1e5a      	subs	r2, r3, #1
    fb32:	490b      	ldr	r1, [pc, #44]	; (fb60 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_41+0x44>)
    fb34:	9b01      	ldr	r3, [sp, #4]
    fb36:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_41[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_41[u32CoreId]))         /*if interrupts were enabled*/
    fb3a:	4a0a      	ldr	r2, [pc, #40]	; (fb64 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_41+0x48>)
    fb3c:	9b01      	ldr	r3, [sp, #4]
    fb3e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fb42:	f003 0301 	and.w	r3, r3, #1
    fb46:	2b00      	cmp	r3, #0
    fb48:	d106      	bne.n	fb58 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_41+0x3c>
    fb4a:	4a05      	ldr	r2, [pc, #20]	; (fb60 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_41+0x44>)
    fb4c:	9b01      	ldr	r3, [sp, #4]
    fb4e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fb52:	2b00      	cmp	r3, #0
    fb54:	d100      	bne.n	fb58 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_41+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    fb56:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    fb58:	bf00      	nop
    fb5a:	b003      	add	sp, #12
    fb5c:	f85d fb04 	ldr.w	pc, [sp], #4
    fb60:	1fff91ac 	.word	0x1fff91ac
    fb64:	1fff91a8 	.word	0x1fff91a8

0000fb68 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_42>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_42(void)
{
    fb68:	b500      	push	{lr}
    fb6a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    fb6c:	f7f1 f814 	bl	b98 <Sys_GetCoreID>
    fb70:	4603      	mov	r3, r0
    fb72:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_42[u32CoreId])
    fb74:	4a10      	ldr	r2, [pc, #64]	; (fbb8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_42+0x50>)
    fb76:	9b01      	ldr	r3, [sp, #4]
    fb78:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fb7c:	2b00      	cmp	r3, #0
    fb7e:	d10d      	bne.n	fb9c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_42+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    fb80:	f7f0 fefc 	bl	97c <Adc_schm_read_msr>
    fb84:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    fb86:	9b00      	ldr	r3, [sp, #0]
    fb88:	f003 0301 	and.w	r3, r3, #1
    fb8c:	2b00      	cmp	r3, #0
    fb8e:	d100      	bne.n	fb92 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_42+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    fb90:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_42[u32CoreId] = msr;
    fb92:	490a      	ldr	r1, [pc, #40]	; (fbbc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_42+0x54>)
    fb94:	9b01      	ldr	r3, [sp, #4]
    fb96:	9a00      	ldr	r2, [sp, #0]
    fb98:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_42[u32CoreId]++;
    fb9c:	4a06      	ldr	r2, [pc, #24]	; (fbb8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_42+0x50>)
    fb9e:	9b01      	ldr	r3, [sp, #4]
    fba0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fba4:	1c5a      	adds	r2, r3, #1
    fba6:	4904      	ldr	r1, [pc, #16]	; (fbb8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_42+0x50>)
    fba8:	9b01      	ldr	r3, [sp, #4]
    fbaa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    fbae:	bf00      	nop
    fbb0:	b003      	add	sp, #12
    fbb2:	f85d fb04 	ldr.w	pc, [sp], #4
    fbb6:	bf00      	nop
    fbb8:	1fff91b4 	.word	0x1fff91b4
    fbbc:	1fff91b0 	.word	0x1fff91b0

0000fbc0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_42>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_42(void)
{
    fbc0:	b500      	push	{lr}
    fbc2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    fbc4:	f7f0 ffe8 	bl	b98 <Sys_GetCoreID>
    fbc8:	4603      	mov	r3, r0
    fbca:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_42[u32CoreId]--;
    fbcc:	4a0d      	ldr	r2, [pc, #52]	; (fc04 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_42+0x44>)
    fbce:	9b01      	ldr	r3, [sp, #4]
    fbd0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fbd4:	1e5a      	subs	r2, r3, #1
    fbd6:	490b      	ldr	r1, [pc, #44]	; (fc04 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_42+0x44>)
    fbd8:	9b01      	ldr	r3, [sp, #4]
    fbda:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_42[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_42[u32CoreId]))         /*if interrupts were enabled*/
    fbde:	4a0a      	ldr	r2, [pc, #40]	; (fc08 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_42+0x48>)
    fbe0:	9b01      	ldr	r3, [sp, #4]
    fbe2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fbe6:	f003 0301 	and.w	r3, r3, #1
    fbea:	2b00      	cmp	r3, #0
    fbec:	d106      	bne.n	fbfc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_42+0x3c>
    fbee:	4a05      	ldr	r2, [pc, #20]	; (fc04 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_42+0x44>)
    fbf0:	9b01      	ldr	r3, [sp, #4]
    fbf2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fbf6:	2b00      	cmp	r3, #0
    fbf8:	d100      	bne.n	fbfc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_42+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    fbfa:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    fbfc:	bf00      	nop
    fbfe:	b003      	add	sp, #12
    fc00:	f85d fb04 	ldr.w	pc, [sp], #4
    fc04:	1fff91b4 	.word	0x1fff91b4
    fc08:	1fff91b0 	.word	0x1fff91b0

0000fc0c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_43>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_43(void)
{
    fc0c:	b500      	push	{lr}
    fc0e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    fc10:	f7f0 ffc2 	bl	b98 <Sys_GetCoreID>
    fc14:	4603      	mov	r3, r0
    fc16:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_43[u32CoreId])
    fc18:	4a10      	ldr	r2, [pc, #64]	; (fc5c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_43+0x50>)
    fc1a:	9b01      	ldr	r3, [sp, #4]
    fc1c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fc20:	2b00      	cmp	r3, #0
    fc22:	d10d      	bne.n	fc40 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_43+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    fc24:	f7f0 feaa 	bl	97c <Adc_schm_read_msr>
    fc28:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    fc2a:	9b00      	ldr	r3, [sp, #0]
    fc2c:	f003 0301 	and.w	r3, r3, #1
    fc30:	2b00      	cmp	r3, #0
    fc32:	d100      	bne.n	fc36 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_43+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    fc34:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_43[u32CoreId] = msr;
    fc36:	490a      	ldr	r1, [pc, #40]	; (fc60 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_43+0x54>)
    fc38:	9b01      	ldr	r3, [sp, #4]
    fc3a:	9a00      	ldr	r2, [sp, #0]
    fc3c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_43[u32CoreId]++;
    fc40:	4a06      	ldr	r2, [pc, #24]	; (fc5c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_43+0x50>)
    fc42:	9b01      	ldr	r3, [sp, #4]
    fc44:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fc48:	1c5a      	adds	r2, r3, #1
    fc4a:	4904      	ldr	r1, [pc, #16]	; (fc5c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_43+0x50>)
    fc4c:	9b01      	ldr	r3, [sp, #4]
    fc4e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    fc52:	bf00      	nop
    fc54:	b003      	add	sp, #12
    fc56:	f85d fb04 	ldr.w	pc, [sp], #4
    fc5a:	bf00      	nop
    fc5c:	1fff91bc 	.word	0x1fff91bc
    fc60:	1fff91b8 	.word	0x1fff91b8

0000fc64 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_43>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_43(void)
{
    fc64:	b500      	push	{lr}
    fc66:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    fc68:	f7f0 ff96 	bl	b98 <Sys_GetCoreID>
    fc6c:	4603      	mov	r3, r0
    fc6e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_43[u32CoreId]--;
    fc70:	4a0d      	ldr	r2, [pc, #52]	; (fca8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_43+0x44>)
    fc72:	9b01      	ldr	r3, [sp, #4]
    fc74:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fc78:	1e5a      	subs	r2, r3, #1
    fc7a:	490b      	ldr	r1, [pc, #44]	; (fca8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_43+0x44>)
    fc7c:	9b01      	ldr	r3, [sp, #4]
    fc7e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_43[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_43[u32CoreId]))         /*if interrupts were enabled*/
    fc82:	4a0a      	ldr	r2, [pc, #40]	; (fcac <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_43+0x48>)
    fc84:	9b01      	ldr	r3, [sp, #4]
    fc86:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fc8a:	f003 0301 	and.w	r3, r3, #1
    fc8e:	2b00      	cmp	r3, #0
    fc90:	d106      	bne.n	fca0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_43+0x3c>
    fc92:	4a05      	ldr	r2, [pc, #20]	; (fca8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_43+0x44>)
    fc94:	9b01      	ldr	r3, [sp, #4]
    fc96:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fc9a:	2b00      	cmp	r3, #0
    fc9c:	d100      	bne.n	fca0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_43+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    fc9e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    fca0:	bf00      	nop
    fca2:	b003      	add	sp, #12
    fca4:	f85d fb04 	ldr.w	pc, [sp], #4
    fca8:	1fff91bc 	.word	0x1fff91bc
    fcac:	1fff91b8 	.word	0x1fff91b8

0000fcb0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_44>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_44(void)
{
    fcb0:	b500      	push	{lr}
    fcb2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    fcb4:	f7f0 ff70 	bl	b98 <Sys_GetCoreID>
    fcb8:	4603      	mov	r3, r0
    fcba:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_44[u32CoreId])
    fcbc:	4a10      	ldr	r2, [pc, #64]	; (fd00 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_44+0x50>)
    fcbe:	9b01      	ldr	r3, [sp, #4]
    fcc0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fcc4:	2b00      	cmp	r3, #0
    fcc6:	d10d      	bne.n	fce4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_44+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    fcc8:	f7f0 fe58 	bl	97c <Adc_schm_read_msr>
    fccc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    fcce:	9b00      	ldr	r3, [sp, #0]
    fcd0:	f003 0301 	and.w	r3, r3, #1
    fcd4:	2b00      	cmp	r3, #0
    fcd6:	d100      	bne.n	fcda <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_44+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    fcd8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_44[u32CoreId] = msr;
    fcda:	490a      	ldr	r1, [pc, #40]	; (fd04 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_44+0x54>)
    fcdc:	9b01      	ldr	r3, [sp, #4]
    fcde:	9a00      	ldr	r2, [sp, #0]
    fce0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_44[u32CoreId]++;
    fce4:	4a06      	ldr	r2, [pc, #24]	; (fd00 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_44+0x50>)
    fce6:	9b01      	ldr	r3, [sp, #4]
    fce8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fcec:	1c5a      	adds	r2, r3, #1
    fcee:	4904      	ldr	r1, [pc, #16]	; (fd00 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_44+0x50>)
    fcf0:	9b01      	ldr	r3, [sp, #4]
    fcf2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    fcf6:	bf00      	nop
    fcf8:	b003      	add	sp, #12
    fcfa:	f85d fb04 	ldr.w	pc, [sp], #4
    fcfe:	bf00      	nop
    fd00:	1fff91c4 	.word	0x1fff91c4
    fd04:	1fff91c0 	.word	0x1fff91c0

0000fd08 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_44>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_44(void)
{
    fd08:	b500      	push	{lr}
    fd0a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    fd0c:	f7f0 ff44 	bl	b98 <Sys_GetCoreID>
    fd10:	4603      	mov	r3, r0
    fd12:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_44[u32CoreId]--;
    fd14:	4a0d      	ldr	r2, [pc, #52]	; (fd4c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_44+0x44>)
    fd16:	9b01      	ldr	r3, [sp, #4]
    fd18:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fd1c:	1e5a      	subs	r2, r3, #1
    fd1e:	490b      	ldr	r1, [pc, #44]	; (fd4c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_44+0x44>)
    fd20:	9b01      	ldr	r3, [sp, #4]
    fd22:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_44[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_44[u32CoreId]))         /*if interrupts were enabled*/
    fd26:	4a0a      	ldr	r2, [pc, #40]	; (fd50 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_44+0x48>)
    fd28:	9b01      	ldr	r3, [sp, #4]
    fd2a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fd2e:	f003 0301 	and.w	r3, r3, #1
    fd32:	2b00      	cmp	r3, #0
    fd34:	d106      	bne.n	fd44 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_44+0x3c>
    fd36:	4a05      	ldr	r2, [pc, #20]	; (fd4c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_44+0x44>)
    fd38:	9b01      	ldr	r3, [sp, #4]
    fd3a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fd3e:	2b00      	cmp	r3, #0
    fd40:	d100      	bne.n	fd44 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_44+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    fd42:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    fd44:	bf00      	nop
    fd46:	b003      	add	sp, #12
    fd48:	f85d fb04 	ldr.w	pc, [sp], #4
    fd4c:	1fff91c4 	.word	0x1fff91c4
    fd50:	1fff91c0 	.word	0x1fff91c0

0000fd54 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_45>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_45(void)
{
    fd54:	b500      	push	{lr}
    fd56:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    fd58:	f7f0 ff1e 	bl	b98 <Sys_GetCoreID>
    fd5c:	4603      	mov	r3, r0
    fd5e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_45[u32CoreId])
    fd60:	4a10      	ldr	r2, [pc, #64]	; (fda4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_45+0x50>)
    fd62:	9b01      	ldr	r3, [sp, #4]
    fd64:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fd68:	2b00      	cmp	r3, #0
    fd6a:	d10d      	bne.n	fd88 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_45+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    fd6c:	f7f0 fe06 	bl	97c <Adc_schm_read_msr>
    fd70:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    fd72:	9b00      	ldr	r3, [sp, #0]
    fd74:	f003 0301 	and.w	r3, r3, #1
    fd78:	2b00      	cmp	r3, #0
    fd7a:	d100      	bne.n	fd7e <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_45+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    fd7c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_45[u32CoreId] = msr;
    fd7e:	490a      	ldr	r1, [pc, #40]	; (fda8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_45+0x54>)
    fd80:	9b01      	ldr	r3, [sp, #4]
    fd82:	9a00      	ldr	r2, [sp, #0]
    fd84:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_45[u32CoreId]++;
    fd88:	4a06      	ldr	r2, [pc, #24]	; (fda4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_45+0x50>)
    fd8a:	9b01      	ldr	r3, [sp, #4]
    fd8c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fd90:	1c5a      	adds	r2, r3, #1
    fd92:	4904      	ldr	r1, [pc, #16]	; (fda4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_45+0x50>)
    fd94:	9b01      	ldr	r3, [sp, #4]
    fd96:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    fd9a:	bf00      	nop
    fd9c:	b003      	add	sp, #12
    fd9e:	f85d fb04 	ldr.w	pc, [sp], #4
    fda2:	bf00      	nop
    fda4:	1fff91cc 	.word	0x1fff91cc
    fda8:	1fff91c8 	.word	0x1fff91c8

0000fdac <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_45>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_45(void)
{
    fdac:	b500      	push	{lr}
    fdae:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    fdb0:	f7f0 fef2 	bl	b98 <Sys_GetCoreID>
    fdb4:	4603      	mov	r3, r0
    fdb6:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_45[u32CoreId]--;
    fdb8:	4a0d      	ldr	r2, [pc, #52]	; (fdf0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_45+0x44>)
    fdba:	9b01      	ldr	r3, [sp, #4]
    fdbc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fdc0:	1e5a      	subs	r2, r3, #1
    fdc2:	490b      	ldr	r1, [pc, #44]	; (fdf0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_45+0x44>)
    fdc4:	9b01      	ldr	r3, [sp, #4]
    fdc6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_45[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_45[u32CoreId]))         /*if interrupts were enabled*/
    fdca:	4a0a      	ldr	r2, [pc, #40]	; (fdf4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_45+0x48>)
    fdcc:	9b01      	ldr	r3, [sp, #4]
    fdce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fdd2:	f003 0301 	and.w	r3, r3, #1
    fdd6:	2b00      	cmp	r3, #0
    fdd8:	d106      	bne.n	fde8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_45+0x3c>
    fdda:	4a05      	ldr	r2, [pc, #20]	; (fdf0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_45+0x44>)
    fddc:	9b01      	ldr	r3, [sp, #4]
    fdde:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fde2:	2b00      	cmp	r3, #0
    fde4:	d100      	bne.n	fde8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_45+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    fde6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    fde8:	bf00      	nop
    fdea:	b003      	add	sp, #12
    fdec:	f85d fb04 	ldr.w	pc, [sp], #4
    fdf0:	1fff91cc 	.word	0x1fff91cc
    fdf4:	1fff91c8 	.word	0x1fff91c8

0000fdf8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_46>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_46(void)
{
    fdf8:	b500      	push	{lr}
    fdfa:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    fdfc:	f7f0 fecc 	bl	b98 <Sys_GetCoreID>
    fe00:	4603      	mov	r3, r0
    fe02:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_46[u32CoreId])
    fe04:	4a10      	ldr	r2, [pc, #64]	; (fe48 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_46+0x50>)
    fe06:	9b01      	ldr	r3, [sp, #4]
    fe08:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fe0c:	2b00      	cmp	r3, #0
    fe0e:	d10d      	bne.n	fe2c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_46+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    fe10:	f7f0 fdb4 	bl	97c <Adc_schm_read_msr>
    fe14:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    fe16:	9b00      	ldr	r3, [sp, #0]
    fe18:	f003 0301 	and.w	r3, r3, #1
    fe1c:	2b00      	cmp	r3, #0
    fe1e:	d100      	bne.n	fe22 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_46+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    fe20:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_46[u32CoreId] = msr;
    fe22:	490a      	ldr	r1, [pc, #40]	; (fe4c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_46+0x54>)
    fe24:	9b01      	ldr	r3, [sp, #4]
    fe26:	9a00      	ldr	r2, [sp, #0]
    fe28:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_46[u32CoreId]++;
    fe2c:	4a06      	ldr	r2, [pc, #24]	; (fe48 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_46+0x50>)
    fe2e:	9b01      	ldr	r3, [sp, #4]
    fe30:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fe34:	1c5a      	adds	r2, r3, #1
    fe36:	4904      	ldr	r1, [pc, #16]	; (fe48 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_46+0x50>)
    fe38:	9b01      	ldr	r3, [sp, #4]
    fe3a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    fe3e:	bf00      	nop
    fe40:	b003      	add	sp, #12
    fe42:	f85d fb04 	ldr.w	pc, [sp], #4
    fe46:	bf00      	nop
    fe48:	1fff91d4 	.word	0x1fff91d4
    fe4c:	1fff91d0 	.word	0x1fff91d0

0000fe50 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_46>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_46(void)
{
    fe50:	b500      	push	{lr}
    fe52:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    fe54:	f7f0 fea0 	bl	b98 <Sys_GetCoreID>
    fe58:	4603      	mov	r3, r0
    fe5a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_46[u32CoreId]--;
    fe5c:	4a0d      	ldr	r2, [pc, #52]	; (fe94 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_46+0x44>)
    fe5e:	9b01      	ldr	r3, [sp, #4]
    fe60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fe64:	1e5a      	subs	r2, r3, #1
    fe66:	490b      	ldr	r1, [pc, #44]	; (fe94 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_46+0x44>)
    fe68:	9b01      	ldr	r3, [sp, #4]
    fe6a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_46[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_46[u32CoreId]))         /*if interrupts were enabled*/
    fe6e:	4a0a      	ldr	r2, [pc, #40]	; (fe98 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_46+0x48>)
    fe70:	9b01      	ldr	r3, [sp, #4]
    fe72:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fe76:	f003 0301 	and.w	r3, r3, #1
    fe7a:	2b00      	cmp	r3, #0
    fe7c:	d106      	bne.n	fe8c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_46+0x3c>
    fe7e:	4a05      	ldr	r2, [pc, #20]	; (fe94 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_46+0x44>)
    fe80:	9b01      	ldr	r3, [sp, #4]
    fe82:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fe86:	2b00      	cmp	r3, #0
    fe88:	d100      	bne.n	fe8c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_46+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    fe8a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    fe8c:	bf00      	nop
    fe8e:	b003      	add	sp, #12
    fe90:	f85d fb04 	ldr.w	pc, [sp], #4
    fe94:	1fff91d4 	.word	0x1fff91d4
    fe98:	1fff91d0 	.word	0x1fff91d0

0000fe9c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_47>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_47(void)
{
    fe9c:	b500      	push	{lr}
    fe9e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    fea0:	f7f0 fe7a 	bl	b98 <Sys_GetCoreID>
    fea4:	4603      	mov	r3, r0
    fea6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_47[u32CoreId])
    fea8:	4a10      	ldr	r2, [pc, #64]	; (feec <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_47+0x50>)
    feaa:	9b01      	ldr	r3, [sp, #4]
    feac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    feb0:	2b00      	cmp	r3, #0
    feb2:	d10d      	bne.n	fed0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_47+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    feb4:	f7f0 fd62 	bl	97c <Adc_schm_read_msr>
    feb8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    feba:	9b00      	ldr	r3, [sp, #0]
    febc:	f003 0301 	and.w	r3, r3, #1
    fec0:	2b00      	cmp	r3, #0
    fec2:	d100      	bne.n	fec6 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_47+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    fec4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_47[u32CoreId] = msr;
    fec6:	490a      	ldr	r1, [pc, #40]	; (fef0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_47+0x54>)
    fec8:	9b01      	ldr	r3, [sp, #4]
    feca:	9a00      	ldr	r2, [sp, #0]
    fecc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_47[u32CoreId]++;
    fed0:	4a06      	ldr	r2, [pc, #24]	; (feec <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_47+0x50>)
    fed2:	9b01      	ldr	r3, [sp, #4]
    fed4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fed8:	1c5a      	adds	r2, r3, #1
    feda:	4904      	ldr	r1, [pc, #16]	; (feec <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_47+0x50>)
    fedc:	9b01      	ldr	r3, [sp, #4]
    fede:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    fee2:	bf00      	nop
    fee4:	b003      	add	sp, #12
    fee6:	f85d fb04 	ldr.w	pc, [sp], #4
    feea:	bf00      	nop
    feec:	1fff91dc 	.word	0x1fff91dc
    fef0:	1fff91d8 	.word	0x1fff91d8

0000fef4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_47>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_47(void)
{
    fef4:	b500      	push	{lr}
    fef6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    fef8:	f7f0 fe4e 	bl	b98 <Sys_GetCoreID>
    fefc:	4603      	mov	r3, r0
    fefe:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_47[u32CoreId]--;
    ff00:	4a0d      	ldr	r2, [pc, #52]	; (ff38 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_47+0x44>)
    ff02:	9b01      	ldr	r3, [sp, #4]
    ff04:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ff08:	1e5a      	subs	r2, r3, #1
    ff0a:	490b      	ldr	r1, [pc, #44]	; (ff38 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_47+0x44>)
    ff0c:	9b01      	ldr	r3, [sp, #4]
    ff0e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_47[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_47[u32CoreId]))         /*if interrupts were enabled*/
    ff12:	4a0a      	ldr	r2, [pc, #40]	; (ff3c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_47+0x48>)
    ff14:	9b01      	ldr	r3, [sp, #4]
    ff16:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ff1a:	f003 0301 	and.w	r3, r3, #1
    ff1e:	2b00      	cmp	r3, #0
    ff20:	d106      	bne.n	ff30 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_47+0x3c>
    ff22:	4a05      	ldr	r2, [pc, #20]	; (ff38 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_47+0x44>)
    ff24:	9b01      	ldr	r3, [sp, #4]
    ff26:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ff2a:	2b00      	cmp	r3, #0
    ff2c:	d100      	bne.n	ff30 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_47+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    ff2e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    ff30:	bf00      	nop
    ff32:	b003      	add	sp, #12
    ff34:	f85d fb04 	ldr.w	pc, [sp], #4
    ff38:	1fff91dc 	.word	0x1fff91dc
    ff3c:	1fff91d8 	.word	0x1fff91d8

0000ff40 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_48>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_48(void)
{
    ff40:	b500      	push	{lr}
    ff42:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ff44:	f7f0 fe28 	bl	b98 <Sys_GetCoreID>
    ff48:	4603      	mov	r3, r0
    ff4a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_48[u32CoreId])
    ff4c:	4a10      	ldr	r2, [pc, #64]	; (ff90 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_48+0x50>)
    ff4e:	9b01      	ldr	r3, [sp, #4]
    ff50:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ff54:	2b00      	cmp	r3, #0
    ff56:	d10d      	bne.n	ff74 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_48+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    ff58:	f7f0 fd10 	bl	97c <Adc_schm_read_msr>
    ff5c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
    ff5e:	9b00      	ldr	r3, [sp, #0]
    ff60:	f003 0301 	and.w	r3, r3, #1
    ff64:	2b00      	cmp	r3, #0
    ff66:	d100      	bne.n	ff6a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_48+0x2a>
        {
            OsIf_SuspendAllInterrupts();
    ff68:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_48[u32CoreId] = msr;
    ff6a:	490a      	ldr	r1, [pc, #40]	; (ff94 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_48+0x54>)
    ff6c:	9b01      	ldr	r3, [sp, #4]
    ff6e:	9a00      	ldr	r2, [sp, #0]
    ff70:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_48[u32CoreId]++;
    ff74:	4a06      	ldr	r2, [pc, #24]	; (ff90 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_48+0x50>)
    ff76:	9b01      	ldr	r3, [sp, #4]
    ff78:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ff7c:	1c5a      	adds	r2, r3, #1
    ff7e:	4904      	ldr	r1, [pc, #16]	; (ff90 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_48+0x50>)
    ff80:	9b01      	ldr	r3, [sp, #4]
    ff82:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
    ff86:	bf00      	nop
    ff88:	b003      	add	sp, #12
    ff8a:	f85d fb04 	ldr.w	pc, [sp], #4
    ff8e:	bf00      	nop
    ff90:	1fff91e4 	.word	0x1fff91e4
    ff94:	1fff91e0 	.word	0x1fff91e0

0000ff98 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_48>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_48(void)
{
    ff98:	b500      	push	{lr}
    ff9a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ff9c:	f7f0 fdfc 	bl	b98 <Sys_GetCoreID>
    ffa0:	4603      	mov	r3, r0
    ffa2:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_48[u32CoreId]--;
    ffa4:	4a0d      	ldr	r2, [pc, #52]	; (ffdc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_48+0x44>)
    ffa6:	9b01      	ldr	r3, [sp, #4]
    ffa8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ffac:	1e5a      	subs	r2, r3, #1
    ffae:	490b      	ldr	r1, [pc, #44]	; (ffdc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_48+0x44>)
    ffb0:	9b01      	ldr	r3, [sp, #4]
    ffb2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_48[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_48[u32CoreId]))         /*if interrupts were enabled*/
    ffb6:	4a0a      	ldr	r2, [pc, #40]	; (ffe0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_48+0x48>)
    ffb8:	9b01      	ldr	r3, [sp, #4]
    ffba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ffbe:	f003 0301 	and.w	r3, r3, #1
    ffc2:	2b00      	cmp	r3, #0
    ffc4:	d106      	bne.n	ffd4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_48+0x3c>
    ffc6:	4a05      	ldr	r2, [pc, #20]	; (ffdc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_48+0x44>)
    ffc8:	9b01      	ldr	r3, [sp, #4]
    ffca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    ffce:	2b00      	cmp	r3, #0
    ffd0:	d100      	bne.n	ffd4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_48+0x3c>
    {
        OsIf_ResumeAllInterrupts();
    ffd2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
    ffd4:	bf00      	nop
    ffd6:	b003      	add	sp, #12
    ffd8:	f85d fb04 	ldr.w	pc, [sp], #4
    ffdc:	1fff91e4 	.word	0x1fff91e4
    ffe0:	1fff91e0 	.word	0x1fff91e0

0000ffe4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_49>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_49(void)
{
    ffe4:	b500      	push	{lr}
    ffe6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
    ffe8:	f7f0 fdd6 	bl	b98 <Sys_GetCoreID>
    ffec:	4603      	mov	r3, r0
    ffee:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_49[u32CoreId])
    fff0:	4a10      	ldr	r2, [pc, #64]	; (10034 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_49+0x50>)
    fff2:	9b01      	ldr	r3, [sp, #4]
    fff4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
    fff8:	2b00      	cmp	r3, #0
    fffa:	d10d      	bne.n	10018 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_49+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
    fffc:	f7f0 fcbe 	bl	97c <Adc_schm_read_msr>
   10000:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   10002:	9b00      	ldr	r3, [sp, #0]
   10004:	f003 0301 	and.w	r3, r3, #1
   10008:	2b00      	cmp	r3, #0
   1000a:	d100      	bne.n	1000e <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_49+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   1000c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_49[u32CoreId] = msr;
   1000e:	490a      	ldr	r1, [pc, #40]	; (10038 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_49+0x54>)
   10010:	9b01      	ldr	r3, [sp, #4]
   10012:	9a00      	ldr	r2, [sp, #0]
   10014:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_49[u32CoreId]++;
   10018:	4a06      	ldr	r2, [pc, #24]	; (10034 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_49+0x50>)
   1001a:	9b01      	ldr	r3, [sp, #4]
   1001c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10020:	1c5a      	adds	r2, r3, #1
   10022:	4904      	ldr	r1, [pc, #16]	; (10034 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_49+0x50>)
   10024:	9b01      	ldr	r3, [sp, #4]
   10026:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1002a:	bf00      	nop
   1002c:	b003      	add	sp, #12
   1002e:	f85d fb04 	ldr.w	pc, [sp], #4
   10032:	bf00      	nop
   10034:	1fff91ec 	.word	0x1fff91ec
   10038:	1fff91e8 	.word	0x1fff91e8

0001003c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_49>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_49(void)
{
   1003c:	b500      	push	{lr}
   1003e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10040:	f7f0 fdaa 	bl	b98 <Sys_GetCoreID>
   10044:	4603      	mov	r3, r0
   10046:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_49[u32CoreId]--;
   10048:	4a0d      	ldr	r2, [pc, #52]	; (10080 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_49+0x44>)
   1004a:	9b01      	ldr	r3, [sp, #4]
   1004c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10050:	1e5a      	subs	r2, r3, #1
   10052:	490b      	ldr	r1, [pc, #44]	; (10080 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_49+0x44>)
   10054:	9b01      	ldr	r3, [sp, #4]
   10056:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_49[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_49[u32CoreId]))         /*if interrupts were enabled*/
   1005a:	4a0a      	ldr	r2, [pc, #40]	; (10084 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_49+0x48>)
   1005c:	9b01      	ldr	r3, [sp, #4]
   1005e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10062:	f003 0301 	and.w	r3, r3, #1
   10066:	2b00      	cmp	r3, #0
   10068:	d106      	bne.n	10078 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_49+0x3c>
   1006a:	4a05      	ldr	r2, [pc, #20]	; (10080 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_49+0x44>)
   1006c:	9b01      	ldr	r3, [sp, #4]
   1006e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10072:	2b00      	cmp	r3, #0
   10074:	d100      	bne.n	10078 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_49+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   10076:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10078:	bf00      	nop
   1007a:	b003      	add	sp, #12
   1007c:	f85d fb04 	ldr.w	pc, [sp], #4
   10080:	1fff91ec 	.word	0x1fff91ec
   10084:	1fff91e8 	.word	0x1fff91e8

00010088 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_50>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_50(void)
{
   10088:	b500      	push	{lr}
   1008a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1008c:	f7f0 fd84 	bl	b98 <Sys_GetCoreID>
   10090:	4603      	mov	r3, r0
   10092:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_50[u32CoreId])
   10094:	4a10      	ldr	r2, [pc, #64]	; (100d8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_50+0x50>)
   10096:	9b01      	ldr	r3, [sp, #4]
   10098:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1009c:	2b00      	cmp	r3, #0
   1009e:	d10d      	bne.n	100bc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_50+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   100a0:	f7f0 fc6c 	bl	97c <Adc_schm_read_msr>
   100a4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   100a6:	9b00      	ldr	r3, [sp, #0]
   100a8:	f003 0301 	and.w	r3, r3, #1
   100ac:	2b00      	cmp	r3, #0
   100ae:	d100      	bne.n	100b2 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_50+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   100b0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_50[u32CoreId] = msr;
   100b2:	490a      	ldr	r1, [pc, #40]	; (100dc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_50+0x54>)
   100b4:	9b01      	ldr	r3, [sp, #4]
   100b6:	9a00      	ldr	r2, [sp, #0]
   100b8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_50[u32CoreId]++;
   100bc:	4a06      	ldr	r2, [pc, #24]	; (100d8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_50+0x50>)
   100be:	9b01      	ldr	r3, [sp, #4]
   100c0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   100c4:	1c5a      	adds	r2, r3, #1
   100c6:	4904      	ldr	r1, [pc, #16]	; (100d8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_50+0x50>)
   100c8:	9b01      	ldr	r3, [sp, #4]
   100ca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   100ce:	bf00      	nop
   100d0:	b003      	add	sp, #12
   100d2:	f85d fb04 	ldr.w	pc, [sp], #4
   100d6:	bf00      	nop
   100d8:	1fff91f4 	.word	0x1fff91f4
   100dc:	1fff91f0 	.word	0x1fff91f0

000100e0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_50>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_50(void)
{
   100e0:	b500      	push	{lr}
   100e2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   100e4:	f7f0 fd58 	bl	b98 <Sys_GetCoreID>
   100e8:	4603      	mov	r3, r0
   100ea:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_50[u32CoreId]--;
   100ec:	4a0d      	ldr	r2, [pc, #52]	; (10124 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_50+0x44>)
   100ee:	9b01      	ldr	r3, [sp, #4]
   100f0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   100f4:	1e5a      	subs	r2, r3, #1
   100f6:	490b      	ldr	r1, [pc, #44]	; (10124 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_50+0x44>)
   100f8:	9b01      	ldr	r3, [sp, #4]
   100fa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_50[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_50[u32CoreId]))         /*if interrupts were enabled*/
   100fe:	4a0a      	ldr	r2, [pc, #40]	; (10128 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_50+0x48>)
   10100:	9b01      	ldr	r3, [sp, #4]
   10102:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10106:	f003 0301 	and.w	r3, r3, #1
   1010a:	2b00      	cmp	r3, #0
   1010c:	d106      	bne.n	1011c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_50+0x3c>
   1010e:	4a05      	ldr	r2, [pc, #20]	; (10124 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_50+0x44>)
   10110:	9b01      	ldr	r3, [sp, #4]
   10112:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10116:	2b00      	cmp	r3, #0
   10118:	d100      	bne.n	1011c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_50+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1011a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   1011c:	bf00      	nop
   1011e:	b003      	add	sp, #12
   10120:	f85d fb04 	ldr.w	pc, [sp], #4
   10124:	1fff91f4 	.word	0x1fff91f4
   10128:	1fff91f0 	.word	0x1fff91f0

0001012c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_51>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_51(void)
{
   1012c:	b500      	push	{lr}
   1012e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10130:	f7f0 fd32 	bl	b98 <Sys_GetCoreID>
   10134:	4603      	mov	r3, r0
   10136:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_51[u32CoreId])
   10138:	4a10      	ldr	r2, [pc, #64]	; (1017c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_51+0x50>)
   1013a:	9b01      	ldr	r3, [sp, #4]
   1013c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10140:	2b00      	cmp	r3, #0
   10142:	d10d      	bne.n	10160 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_51+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10144:	f7f0 fc1a 	bl	97c <Adc_schm_read_msr>
   10148:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1014a:	9b00      	ldr	r3, [sp, #0]
   1014c:	f003 0301 	and.w	r3, r3, #1
   10150:	2b00      	cmp	r3, #0
   10152:	d100      	bne.n	10156 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_51+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10154:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_51[u32CoreId] = msr;
   10156:	490a      	ldr	r1, [pc, #40]	; (10180 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_51+0x54>)
   10158:	9b01      	ldr	r3, [sp, #4]
   1015a:	9a00      	ldr	r2, [sp, #0]
   1015c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_51[u32CoreId]++;
   10160:	4a06      	ldr	r2, [pc, #24]	; (1017c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_51+0x50>)
   10162:	9b01      	ldr	r3, [sp, #4]
   10164:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10168:	1c5a      	adds	r2, r3, #1
   1016a:	4904      	ldr	r1, [pc, #16]	; (1017c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_51+0x50>)
   1016c:	9b01      	ldr	r3, [sp, #4]
   1016e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10172:	bf00      	nop
   10174:	b003      	add	sp, #12
   10176:	f85d fb04 	ldr.w	pc, [sp], #4
   1017a:	bf00      	nop
   1017c:	1fff91fc 	.word	0x1fff91fc
   10180:	1fff91f8 	.word	0x1fff91f8

00010184 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_51>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_51(void)
{
   10184:	b500      	push	{lr}
   10186:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10188:	f7f0 fd06 	bl	b98 <Sys_GetCoreID>
   1018c:	4603      	mov	r3, r0
   1018e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_51[u32CoreId]--;
   10190:	4a0d      	ldr	r2, [pc, #52]	; (101c8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_51+0x44>)
   10192:	9b01      	ldr	r3, [sp, #4]
   10194:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10198:	1e5a      	subs	r2, r3, #1
   1019a:	490b      	ldr	r1, [pc, #44]	; (101c8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_51+0x44>)
   1019c:	9b01      	ldr	r3, [sp, #4]
   1019e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_51[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_51[u32CoreId]))         /*if interrupts were enabled*/
   101a2:	4a0a      	ldr	r2, [pc, #40]	; (101cc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_51+0x48>)
   101a4:	9b01      	ldr	r3, [sp, #4]
   101a6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   101aa:	f003 0301 	and.w	r3, r3, #1
   101ae:	2b00      	cmp	r3, #0
   101b0:	d106      	bne.n	101c0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_51+0x3c>
   101b2:	4a05      	ldr	r2, [pc, #20]	; (101c8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_51+0x44>)
   101b4:	9b01      	ldr	r3, [sp, #4]
   101b6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   101ba:	2b00      	cmp	r3, #0
   101bc:	d100      	bne.n	101c0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_51+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   101be:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   101c0:	bf00      	nop
   101c2:	b003      	add	sp, #12
   101c4:	f85d fb04 	ldr.w	pc, [sp], #4
   101c8:	1fff91fc 	.word	0x1fff91fc
   101cc:	1fff91f8 	.word	0x1fff91f8

000101d0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_54>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_54(void)
{
   101d0:	b500      	push	{lr}
   101d2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   101d4:	f7f0 fce0 	bl	b98 <Sys_GetCoreID>
   101d8:	4603      	mov	r3, r0
   101da:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_54[u32CoreId])
   101dc:	4a10      	ldr	r2, [pc, #64]	; (10220 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_54+0x50>)
   101de:	9b01      	ldr	r3, [sp, #4]
   101e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   101e4:	2b00      	cmp	r3, #0
   101e6:	d10d      	bne.n	10204 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_54+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   101e8:	f7f0 fbc8 	bl	97c <Adc_schm_read_msr>
   101ec:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   101ee:	9b00      	ldr	r3, [sp, #0]
   101f0:	f003 0301 	and.w	r3, r3, #1
   101f4:	2b00      	cmp	r3, #0
   101f6:	d100      	bne.n	101fa <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_54+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   101f8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_54[u32CoreId] = msr;
   101fa:	490a      	ldr	r1, [pc, #40]	; (10224 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_54+0x54>)
   101fc:	9b01      	ldr	r3, [sp, #4]
   101fe:	9a00      	ldr	r2, [sp, #0]
   10200:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_54[u32CoreId]++;
   10204:	4a06      	ldr	r2, [pc, #24]	; (10220 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_54+0x50>)
   10206:	9b01      	ldr	r3, [sp, #4]
   10208:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1020c:	1c5a      	adds	r2, r3, #1
   1020e:	4904      	ldr	r1, [pc, #16]	; (10220 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_54+0x50>)
   10210:	9b01      	ldr	r3, [sp, #4]
   10212:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10216:	bf00      	nop
   10218:	b003      	add	sp, #12
   1021a:	f85d fb04 	ldr.w	pc, [sp], #4
   1021e:	bf00      	nop
   10220:	1fff9204 	.word	0x1fff9204
   10224:	1fff9200 	.word	0x1fff9200

00010228 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_54>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_54(void)
{
   10228:	b500      	push	{lr}
   1022a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1022c:	f7f0 fcb4 	bl	b98 <Sys_GetCoreID>
   10230:	4603      	mov	r3, r0
   10232:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_54[u32CoreId]--;
   10234:	4a0d      	ldr	r2, [pc, #52]	; (1026c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_54+0x44>)
   10236:	9b01      	ldr	r3, [sp, #4]
   10238:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1023c:	1e5a      	subs	r2, r3, #1
   1023e:	490b      	ldr	r1, [pc, #44]	; (1026c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_54+0x44>)
   10240:	9b01      	ldr	r3, [sp, #4]
   10242:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_54[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_54[u32CoreId]))         /*if interrupts were enabled*/
   10246:	4a0a      	ldr	r2, [pc, #40]	; (10270 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_54+0x48>)
   10248:	9b01      	ldr	r3, [sp, #4]
   1024a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1024e:	f003 0301 	and.w	r3, r3, #1
   10252:	2b00      	cmp	r3, #0
   10254:	d106      	bne.n	10264 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_54+0x3c>
   10256:	4a05      	ldr	r2, [pc, #20]	; (1026c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_54+0x44>)
   10258:	9b01      	ldr	r3, [sp, #4]
   1025a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1025e:	2b00      	cmp	r3, #0
   10260:	d100      	bne.n	10264 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_54+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   10262:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10264:	bf00      	nop
   10266:	b003      	add	sp, #12
   10268:	f85d fb04 	ldr.w	pc, [sp], #4
   1026c:	1fff9204 	.word	0x1fff9204
   10270:	1fff9200 	.word	0x1fff9200

00010274 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_55>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_55(void)
{
   10274:	b500      	push	{lr}
   10276:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10278:	f7f0 fc8e 	bl	b98 <Sys_GetCoreID>
   1027c:	4603      	mov	r3, r0
   1027e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_55[u32CoreId])
   10280:	4a10      	ldr	r2, [pc, #64]	; (102c4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_55+0x50>)
   10282:	9b01      	ldr	r3, [sp, #4]
   10284:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10288:	2b00      	cmp	r3, #0
   1028a:	d10d      	bne.n	102a8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_55+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   1028c:	f7f0 fb76 	bl	97c <Adc_schm_read_msr>
   10290:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   10292:	9b00      	ldr	r3, [sp, #0]
   10294:	f003 0301 	and.w	r3, r3, #1
   10298:	2b00      	cmp	r3, #0
   1029a:	d100      	bne.n	1029e <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_55+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   1029c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_55[u32CoreId] = msr;
   1029e:	490a      	ldr	r1, [pc, #40]	; (102c8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_55+0x54>)
   102a0:	9b01      	ldr	r3, [sp, #4]
   102a2:	9a00      	ldr	r2, [sp, #0]
   102a4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_55[u32CoreId]++;
   102a8:	4a06      	ldr	r2, [pc, #24]	; (102c4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_55+0x50>)
   102aa:	9b01      	ldr	r3, [sp, #4]
   102ac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   102b0:	1c5a      	adds	r2, r3, #1
   102b2:	4904      	ldr	r1, [pc, #16]	; (102c4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_55+0x50>)
   102b4:	9b01      	ldr	r3, [sp, #4]
   102b6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   102ba:	bf00      	nop
   102bc:	b003      	add	sp, #12
   102be:	f85d fb04 	ldr.w	pc, [sp], #4
   102c2:	bf00      	nop
   102c4:	1fff920c 	.word	0x1fff920c
   102c8:	1fff9208 	.word	0x1fff9208

000102cc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_55>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_55(void)
{
   102cc:	b500      	push	{lr}
   102ce:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   102d0:	f7f0 fc62 	bl	b98 <Sys_GetCoreID>
   102d4:	4603      	mov	r3, r0
   102d6:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_55[u32CoreId]--;
   102d8:	4a0d      	ldr	r2, [pc, #52]	; (10310 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_55+0x44>)
   102da:	9b01      	ldr	r3, [sp, #4]
   102dc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   102e0:	1e5a      	subs	r2, r3, #1
   102e2:	490b      	ldr	r1, [pc, #44]	; (10310 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_55+0x44>)
   102e4:	9b01      	ldr	r3, [sp, #4]
   102e6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_55[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_55[u32CoreId]))         /*if interrupts were enabled*/
   102ea:	4a0a      	ldr	r2, [pc, #40]	; (10314 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_55+0x48>)
   102ec:	9b01      	ldr	r3, [sp, #4]
   102ee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   102f2:	f003 0301 	and.w	r3, r3, #1
   102f6:	2b00      	cmp	r3, #0
   102f8:	d106      	bne.n	10308 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_55+0x3c>
   102fa:	4a05      	ldr	r2, [pc, #20]	; (10310 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_55+0x44>)
   102fc:	9b01      	ldr	r3, [sp, #4]
   102fe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10302:	2b00      	cmp	r3, #0
   10304:	d100      	bne.n	10308 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_55+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   10306:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10308:	bf00      	nop
   1030a:	b003      	add	sp, #12
   1030c:	f85d fb04 	ldr.w	pc, [sp], #4
   10310:	1fff920c 	.word	0x1fff920c
   10314:	1fff9208 	.word	0x1fff9208

00010318 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_56>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_56(void)
{
   10318:	b500      	push	{lr}
   1031a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1031c:	f7f0 fc3c 	bl	b98 <Sys_GetCoreID>
   10320:	4603      	mov	r3, r0
   10322:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_56[u32CoreId])
   10324:	4a10      	ldr	r2, [pc, #64]	; (10368 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_56+0x50>)
   10326:	9b01      	ldr	r3, [sp, #4]
   10328:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1032c:	2b00      	cmp	r3, #0
   1032e:	d10d      	bne.n	1034c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_56+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10330:	f7f0 fb24 	bl	97c <Adc_schm_read_msr>
   10334:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   10336:	9b00      	ldr	r3, [sp, #0]
   10338:	f003 0301 	and.w	r3, r3, #1
   1033c:	2b00      	cmp	r3, #0
   1033e:	d100      	bne.n	10342 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_56+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10340:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_56[u32CoreId] = msr;
   10342:	490a      	ldr	r1, [pc, #40]	; (1036c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_56+0x54>)
   10344:	9b01      	ldr	r3, [sp, #4]
   10346:	9a00      	ldr	r2, [sp, #0]
   10348:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_56[u32CoreId]++;
   1034c:	4a06      	ldr	r2, [pc, #24]	; (10368 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_56+0x50>)
   1034e:	9b01      	ldr	r3, [sp, #4]
   10350:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10354:	1c5a      	adds	r2, r3, #1
   10356:	4904      	ldr	r1, [pc, #16]	; (10368 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_56+0x50>)
   10358:	9b01      	ldr	r3, [sp, #4]
   1035a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1035e:	bf00      	nop
   10360:	b003      	add	sp, #12
   10362:	f85d fb04 	ldr.w	pc, [sp], #4
   10366:	bf00      	nop
   10368:	1fff9214 	.word	0x1fff9214
   1036c:	1fff9210 	.word	0x1fff9210

00010370 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_56>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_56(void)
{
   10370:	b500      	push	{lr}
   10372:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10374:	f7f0 fc10 	bl	b98 <Sys_GetCoreID>
   10378:	4603      	mov	r3, r0
   1037a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_56[u32CoreId]--;
   1037c:	4a0d      	ldr	r2, [pc, #52]	; (103b4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_56+0x44>)
   1037e:	9b01      	ldr	r3, [sp, #4]
   10380:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10384:	1e5a      	subs	r2, r3, #1
   10386:	490b      	ldr	r1, [pc, #44]	; (103b4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_56+0x44>)
   10388:	9b01      	ldr	r3, [sp, #4]
   1038a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_56[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_56[u32CoreId]))         /*if interrupts were enabled*/
   1038e:	4a0a      	ldr	r2, [pc, #40]	; (103b8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_56+0x48>)
   10390:	9b01      	ldr	r3, [sp, #4]
   10392:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10396:	f003 0301 	and.w	r3, r3, #1
   1039a:	2b00      	cmp	r3, #0
   1039c:	d106      	bne.n	103ac <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_56+0x3c>
   1039e:	4a05      	ldr	r2, [pc, #20]	; (103b4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_56+0x44>)
   103a0:	9b01      	ldr	r3, [sp, #4]
   103a2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   103a6:	2b00      	cmp	r3, #0
   103a8:	d100      	bne.n	103ac <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_56+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   103aa:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   103ac:	bf00      	nop
   103ae:	b003      	add	sp, #12
   103b0:	f85d fb04 	ldr.w	pc, [sp], #4
   103b4:	1fff9214 	.word	0x1fff9214
   103b8:	1fff9210 	.word	0x1fff9210

000103bc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_57>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_57(void)
{
   103bc:	b500      	push	{lr}
   103be:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   103c0:	f7f0 fbea 	bl	b98 <Sys_GetCoreID>
   103c4:	4603      	mov	r3, r0
   103c6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_57[u32CoreId])
   103c8:	4a10      	ldr	r2, [pc, #64]	; (1040c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_57+0x50>)
   103ca:	9b01      	ldr	r3, [sp, #4]
   103cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   103d0:	2b00      	cmp	r3, #0
   103d2:	d10d      	bne.n	103f0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_57+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   103d4:	f7f0 fad2 	bl	97c <Adc_schm_read_msr>
   103d8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   103da:	9b00      	ldr	r3, [sp, #0]
   103dc:	f003 0301 	and.w	r3, r3, #1
   103e0:	2b00      	cmp	r3, #0
   103e2:	d100      	bne.n	103e6 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_57+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   103e4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_57[u32CoreId] = msr;
   103e6:	490a      	ldr	r1, [pc, #40]	; (10410 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_57+0x54>)
   103e8:	9b01      	ldr	r3, [sp, #4]
   103ea:	9a00      	ldr	r2, [sp, #0]
   103ec:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_57[u32CoreId]++;
   103f0:	4a06      	ldr	r2, [pc, #24]	; (1040c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_57+0x50>)
   103f2:	9b01      	ldr	r3, [sp, #4]
   103f4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   103f8:	1c5a      	adds	r2, r3, #1
   103fa:	4904      	ldr	r1, [pc, #16]	; (1040c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_57+0x50>)
   103fc:	9b01      	ldr	r3, [sp, #4]
   103fe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10402:	bf00      	nop
   10404:	b003      	add	sp, #12
   10406:	f85d fb04 	ldr.w	pc, [sp], #4
   1040a:	bf00      	nop
   1040c:	1fff921c 	.word	0x1fff921c
   10410:	1fff9218 	.word	0x1fff9218

00010414 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_57>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_57(void)
{
   10414:	b500      	push	{lr}
   10416:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10418:	f7f0 fbbe 	bl	b98 <Sys_GetCoreID>
   1041c:	4603      	mov	r3, r0
   1041e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_57[u32CoreId]--;
   10420:	4a0d      	ldr	r2, [pc, #52]	; (10458 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_57+0x44>)
   10422:	9b01      	ldr	r3, [sp, #4]
   10424:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10428:	1e5a      	subs	r2, r3, #1
   1042a:	490b      	ldr	r1, [pc, #44]	; (10458 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_57+0x44>)
   1042c:	9b01      	ldr	r3, [sp, #4]
   1042e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_57[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_57[u32CoreId]))         /*if interrupts were enabled*/
   10432:	4a0a      	ldr	r2, [pc, #40]	; (1045c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_57+0x48>)
   10434:	9b01      	ldr	r3, [sp, #4]
   10436:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1043a:	f003 0301 	and.w	r3, r3, #1
   1043e:	2b00      	cmp	r3, #0
   10440:	d106      	bne.n	10450 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_57+0x3c>
   10442:	4a05      	ldr	r2, [pc, #20]	; (10458 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_57+0x44>)
   10444:	9b01      	ldr	r3, [sp, #4]
   10446:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1044a:	2b00      	cmp	r3, #0
   1044c:	d100      	bne.n	10450 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_57+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1044e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10450:	bf00      	nop
   10452:	b003      	add	sp, #12
   10454:	f85d fb04 	ldr.w	pc, [sp], #4
   10458:	1fff921c 	.word	0x1fff921c
   1045c:	1fff9218 	.word	0x1fff9218

00010460 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_58>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_58(void)
{
   10460:	b500      	push	{lr}
   10462:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10464:	f7f0 fb98 	bl	b98 <Sys_GetCoreID>
   10468:	4603      	mov	r3, r0
   1046a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_58[u32CoreId])
   1046c:	4a10      	ldr	r2, [pc, #64]	; (104b0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_58+0x50>)
   1046e:	9b01      	ldr	r3, [sp, #4]
   10470:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10474:	2b00      	cmp	r3, #0
   10476:	d10d      	bne.n	10494 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_58+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10478:	f7f0 fa80 	bl	97c <Adc_schm_read_msr>
   1047c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1047e:	9b00      	ldr	r3, [sp, #0]
   10480:	f003 0301 	and.w	r3, r3, #1
   10484:	2b00      	cmp	r3, #0
   10486:	d100      	bne.n	1048a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_58+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10488:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_58[u32CoreId] = msr;
   1048a:	490a      	ldr	r1, [pc, #40]	; (104b4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_58+0x54>)
   1048c:	9b01      	ldr	r3, [sp, #4]
   1048e:	9a00      	ldr	r2, [sp, #0]
   10490:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_58[u32CoreId]++;
   10494:	4a06      	ldr	r2, [pc, #24]	; (104b0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_58+0x50>)
   10496:	9b01      	ldr	r3, [sp, #4]
   10498:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1049c:	1c5a      	adds	r2, r3, #1
   1049e:	4904      	ldr	r1, [pc, #16]	; (104b0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_58+0x50>)
   104a0:	9b01      	ldr	r3, [sp, #4]
   104a2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   104a6:	bf00      	nop
   104a8:	b003      	add	sp, #12
   104aa:	f85d fb04 	ldr.w	pc, [sp], #4
   104ae:	bf00      	nop
   104b0:	1fff9224 	.word	0x1fff9224
   104b4:	1fff9220 	.word	0x1fff9220

000104b8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_58>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_58(void)
{
   104b8:	b500      	push	{lr}
   104ba:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   104bc:	f7f0 fb6c 	bl	b98 <Sys_GetCoreID>
   104c0:	4603      	mov	r3, r0
   104c2:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_58[u32CoreId]--;
   104c4:	4a0d      	ldr	r2, [pc, #52]	; (104fc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_58+0x44>)
   104c6:	9b01      	ldr	r3, [sp, #4]
   104c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   104cc:	1e5a      	subs	r2, r3, #1
   104ce:	490b      	ldr	r1, [pc, #44]	; (104fc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_58+0x44>)
   104d0:	9b01      	ldr	r3, [sp, #4]
   104d2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_58[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_58[u32CoreId]))         /*if interrupts were enabled*/
   104d6:	4a0a      	ldr	r2, [pc, #40]	; (10500 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_58+0x48>)
   104d8:	9b01      	ldr	r3, [sp, #4]
   104da:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   104de:	f003 0301 	and.w	r3, r3, #1
   104e2:	2b00      	cmp	r3, #0
   104e4:	d106      	bne.n	104f4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_58+0x3c>
   104e6:	4a05      	ldr	r2, [pc, #20]	; (104fc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_58+0x44>)
   104e8:	9b01      	ldr	r3, [sp, #4]
   104ea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   104ee:	2b00      	cmp	r3, #0
   104f0:	d100      	bne.n	104f4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_58+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   104f2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   104f4:	bf00      	nop
   104f6:	b003      	add	sp, #12
   104f8:	f85d fb04 	ldr.w	pc, [sp], #4
   104fc:	1fff9224 	.word	0x1fff9224
   10500:	1fff9220 	.word	0x1fff9220

00010504 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_59>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_59(void)
{
   10504:	b500      	push	{lr}
   10506:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10508:	f7f0 fb46 	bl	b98 <Sys_GetCoreID>
   1050c:	4603      	mov	r3, r0
   1050e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_59[u32CoreId])
   10510:	4a10      	ldr	r2, [pc, #64]	; (10554 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_59+0x50>)
   10512:	9b01      	ldr	r3, [sp, #4]
   10514:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10518:	2b00      	cmp	r3, #0
   1051a:	d10d      	bne.n	10538 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_59+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   1051c:	f7f0 fa2e 	bl	97c <Adc_schm_read_msr>
   10520:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   10522:	9b00      	ldr	r3, [sp, #0]
   10524:	f003 0301 	and.w	r3, r3, #1
   10528:	2b00      	cmp	r3, #0
   1052a:	d100      	bne.n	1052e <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_59+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   1052c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_59[u32CoreId] = msr;
   1052e:	490a      	ldr	r1, [pc, #40]	; (10558 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_59+0x54>)
   10530:	9b01      	ldr	r3, [sp, #4]
   10532:	9a00      	ldr	r2, [sp, #0]
   10534:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_59[u32CoreId]++;
   10538:	4a06      	ldr	r2, [pc, #24]	; (10554 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_59+0x50>)
   1053a:	9b01      	ldr	r3, [sp, #4]
   1053c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10540:	1c5a      	adds	r2, r3, #1
   10542:	4904      	ldr	r1, [pc, #16]	; (10554 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_59+0x50>)
   10544:	9b01      	ldr	r3, [sp, #4]
   10546:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1054a:	bf00      	nop
   1054c:	b003      	add	sp, #12
   1054e:	f85d fb04 	ldr.w	pc, [sp], #4
   10552:	bf00      	nop
   10554:	1fff922c 	.word	0x1fff922c
   10558:	1fff9228 	.word	0x1fff9228

0001055c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_59>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_59(void)
{
   1055c:	b500      	push	{lr}
   1055e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10560:	f7f0 fb1a 	bl	b98 <Sys_GetCoreID>
   10564:	4603      	mov	r3, r0
   10566:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_59[u32CoreId]--;
   10568:	4a0d      	ldr	r2, [pc, #52]	; (105a0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_59+0x44>)
   1056a:	9b01      	ldr	r3, [sp, #4]
   1056c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10570:	1e5a      	subs	r2, r3, #1
   10572:	490b      	ldr	r1, [pc, #44]	; (105a0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_59+0x44>)
   10574:	9b01      	ldr	r3, [sp, #4]
   10576:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_59[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_59[u32CoreId]))         /*if interrupts were enabled*/
   1057a:	4a0a      	ldr	r2, [pc, #40]	; (105a4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_59+0x48>)
   1057c:	9b01      	ldr	r3, [sp, #4]
   1057e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10582:	f003 0301 	and.w	r3, r3, #1
   10586:	2b00      	cmp	r3, #0
   10588:	d106      	bne.n	10598 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_59+0x3c>
   1058a:	4a05      	ldr	r2, [pc, #20]	; (105a0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_59+0x44>)
   1058c:	9b01      	ldr	r3, [sp, #4]
   1058e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10592:	2b00      	cmp	r3, #0
   10594:	d100      	bne.n	10598 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_59+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   10596:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10598:	bf00      	nop
   1059a:	b003      	add	sp, #12
   1059c:	f85d fb04 	ldr.w	pc, [sp], #4
   105a0:	1fff922c 	.word	0x1fff922c
   105a4:	1fff9228 	.word	0x1fff9228

000105a8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_60>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_60(void)
{
   105a8:	b500      	push	{lr}
   105aa:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   105ac:	f7f0 faf4 	bl	b98 <Sys_GetCoreID>
   105b0:	4603      	mov	r3, r0
   105b2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_60[u32CoreId])
   105b4:	4a10      	ldr	r2, [pc, #64]	; (105f8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_60+0x50>)
   105b6:	9b01      	ldr	r3, [sp, #4]
   105b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   105bc:	2b00      	cmp	r3, #0
   105be:	d10d      	bne.n	105dc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_60+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   105c0:	f7f0 f9dc 	bl	97c <Adc_schm_read_msr>
   105c4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   105c6:	9b00      	ldr	r3, [sp, #0]
   105c8:	f003 0301 	and.w	r3, r3, #1
   105cc:	2b00      	cmp	r3, #0
   105ce:	d100      	bne.n	105d2 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_60+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   105d0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_60[u32CoreId] = msr;
   105d2:	490a      	ldr	r1, [pc, #40]	; (105fc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_60+0x54>)
   105d4:	9b01      	ldr	r3, [sp, #4]
   105d6:	9a00      	ldr	r2, [sp, #0]
   105d8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_60[u32CoreId]++;
   105dc:	4a06      	ldr	r2, [pc, #24]	; (105f8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_60+0x50>)
   105de:	9b01      	ldr	r3, [sp, #4]
   105e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   105e4:	1c5a      	adds	r2, r3, #1
   105e6:	4904      	ldr	r1, [pc, #16]	; (105f8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_60+0x50>)
   105e8:	9b01      	ldr	r3, [sp, #4]
   105ea:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   105ee:	bf00      	nop
   105f0:	b003      	add	sp, #12
   105f2:	f85d fb04 	ldr.w	pc, [sp], #4
   105f6:	bf00      	nop
   105f8:	1fff9234 	.word	0x1fff9234
   105fc:	1fff9230 	.word	0x1fff9230

00010600 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_60>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_60(void)
{
   10600:	b500      	push	{lr}
   10602:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10604:	f7f0 fac8 	bl	b98 <Sys_GetCoreID>
   10608:	4603      	mov	r3, r0
   1060a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_60[u32CoreId]--;
   1060c:	4a0d      	ldr	r2, [pc, #52]	; (10644 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_60+0x44>)
   1060e:	9b01      	ldr	r3, [sp, #4]
   10610:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10614:	1e5a      	subs	r2, r3, #1
   10616:	490b      	ldr	r1, [pc, #44]	; (10644 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_60+0x44>)
   10618:	9b01      	ldr	r3, [sp, #4]
   1061a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_60[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_60[u32CoreId]))         /*if interrupts were enabled*/
   1061e:	4a0a      	ldr	r2, [pc, #40]	; (10648 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_60+0x48>)
   10620:	9b01      	ldr	r3, [sp, #4]
   10622:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10626:	f003 0301 	and.w	r3, r3, #1
   1062a:	2b00      	cmp	r3, #0
   1062c:	d106      	bne.n	1063c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_60+0x3c>
   1062e:	4a05      	ldr	r2, [pc, #20]	; (10644 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_60+0x44>)
   10630:	9b01      	ldr	r3, [sp, #4]
   10632:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10636:	2b00      	cmp	r3, #0
   10638:	d100      	bne.n	1063c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_60+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1063a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   1063c:	bf00      	nop
   1063e:	b003      	add	sp, #12
   10640:	f85d fb04 	ldr.w	pc, [sp], #4
   10644:	1fff9234 	.word	0x1fff9234
   10648:	1fff9230 	.word	0x1fff9230

0001064c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_61>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_61(void)
{
   1064c:	b500      	push	{lr}
   1064e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10650:	f7f0 faa2 	bl	b98 <Sys_GetCoreID>
   10654:	4603      	mov	r3, r0
   10656:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_61[u32CoreId])
   10658:	4a10      	ldr	r2, [pc, #64]	; (1069c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_61+0x50>)
   1065a:	9b01      	ldr	r3, [sp, #4]
   1065c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10660:	2b00      	cmp	r3, #0
   10662:	d10d      	bne.n	10680 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_61+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10664:	f7f0 f98a 	bl	97c <Adc_schm_read_msr>
   10668:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1066a:	9b00      	ldr	r3, [sp, #0]
   1066c:	f003 0301 	and.w	r3, r3, #1
   10670:	2b00      	cmp	r3, #0
   10672:	d100      	bne.n	10676 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_61+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10674:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_61[u32CoreId] = msr;
   10676:	490a      	ldr	r1, [pc, #40]	; (106a0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_61+0x54>)
   10678:	9b01      	ldr	r3, [sp, #4]
   1067a:	9a00      	ldr	r2, [sp, #0]
   1067c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_61[u32CoreId]++;
   10680:	4a06      	ldr	r2, [pc, #24]	; (1069c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_61+0x50>)
   10682:	9b01      	ldr	r3, [sp, #4]
   10684:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10688:	1c5a      	adds	r2, r3, #1
   1068a:	4904      	ldr	r1, [pc, #16]	; (1069c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_61+0x50>)
   1068c:	9b01      	ldr	r3, [sp, #4]
   1068e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10692:	bf00      	nop
   10694:	b003      	add	sp, #12
   10696:	f85d fb04 	ldr.w	pc, [sp], #4
   1069a:	bf00      	nop
   1069c:	1fff923c 	.word	0x1fff923c
   106a0:	1fff9238 	.word	0x1fff9238

000106a4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_61>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_61(void)
{
   106a4:	b500      	push	{lr}
   106a6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   106a8:	f7f0 fa76 	bl	b98 <Sys_GetCoreID>
   106ac:	4603      	mov	r3, r0
   106ae:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_61[u32CoreId]--;
   106b0:	4a0d      	ldr	r2, [pc, #52]	; (106e8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_61+0x44>)
   106b2:	9b01      	ldr	r3, [sp, #4]
   106b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   106b8:	1e5a      	subs	r2, r3, #1
   106ba:	490b      	ldr	r1, [pc, #44]	; (106e8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_61+0x44>)
   106bc:	9b01      	ldr	r3, [sp, #4]
   106be:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_61[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_61[u32CoreId]))         /*if interrupts were enabled*/
   106c2:	4a0a      	ldr	r2, [pc, #40]	; (106ec <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_61+0x48>)
   106c4:	9b01      	ldr	r3, [sp, #4]
   106c6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   106ca:	f003 0301 	and.w	r3, r3, #1
   106ce:	2b00      	cmp	r3, #0
   106d0:	d106      	bne.n	106e0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_61+0x3c>
   106d2:	4a05      	ldr	r2, [pc, #20]	; (106e8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_61+0x44>)
   106d4:	9b01      	ldr	r3, [sp, #4]
   106d6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   106da:	2b00      	cmp	r3, #0
   106dc:	d100      	bne.n	106e0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_61+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   106de:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   106e0:	bf00      	nop
   106e2:	b003      	add	sp, #12
   106e4:	f85d fb04 	ldr.w	pc, [sp], #4
   106e8:	1fff923c 	.word	0x1fff923c
   106ec:	1fff9238 	.word	0x1fff9238

000106f0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_62>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_62(void)
{
   106f0:	b500      	push	{lr}
   106f2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   106f4:	f7f0 fa50 	bl	b98 <Sys_GetCoreID>
   106f8:	4603      	mov	r3, r0
   106fa:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_62[u32CoreId])
   106fc:	4a10      	ldr	r2, [pc, #64]	; (10740 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_62+0x50>)
   106fe:	9b01      	ldr	r3, [sp, #4]
   10700:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10704:	2b00      	cmp	r3, #0
   10706:	d10d      	bne.n	10724 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_62+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10708:	f7f0 f938 	bl	97c <Adc_schm_read_msr>
   1070c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1070e:	9b00      	ldr	r3, [sp, #0]
   10710:	f003 0301 	and.w	r3, r3, #1
   10714:	2b00      	cmp	r3, #0
   10716:	d100      	bne.n	1071a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_62+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10718:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_62[u32CoreId] = msr;
   1071a:	490a      	ldr	r1, [pc, #40]	; (10744 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_62+0x54>)
   1071c:	9b01      	ldr	r3, [sp, #4]
   1071e:	9a00      	ldr	r2, [sp, #0]
   10720:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_62[u32CoreId]++;
   10724:	4a06      	ldr	r2, [pc, #24]	; (10740 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_62+0x50>)
   10726:	9b01      	ldr	r3, [sp, #4]
   10728:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1072c:	1c5a      	adds	r2, r3, #1
   1072e:	4904      	ldr	r1, [pc, #16]	; (10740 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_62+0x50>)
   10730:	9b01      	ldr	r3, [sp, #4]
   10732:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10736:	bf00      	nop
   10738:	b003      	add	sp, #12
   1073a:	f85d fb04 	ldr.w	pc, [sp], #4
   1073e:	bf00      	nop
   10740:	1fff9244 	.word	0x1fff9244
   10744:	1fff9240 	.word	0x1fff9240

00010748 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_62>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_62(void)
{
   10748:	b500      	push	{lr}
   1074a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1074c:	f7f0 fa24 	bl	b98 <Sys_GetCoreID>
   10750:	4603      	mov	r3, r0
   10752:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_62[u32CoreId]--;
   10754:	4a0d      	ldr	r2, [pc, #52]	; (1078c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_62+0x44>)
   10756:	9b01      	ldr	r3, [sp, #4]
   10758:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1075c:	1e5a      	subs	r2, r3, #1
   1075e:	490b      	ldr	r1, [pc, #44]	; (1078c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_62+0x44>)
   10760:	9b01      	ldr	r3, [sp, #4]
   10762:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_62[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_62[u32CoreId]))         /*if interrupts were enabled*/
   10766:	4a0a      	ldr	r2, [pc, #40]	; (10790 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_62+0x48>)
   10768:	9b01      	ldr	r3, [sp, #4]
   1076a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1076e:	f003 0301 	and.w	r3, r3, #1
   10772:	2b00      	cmp	r3, #0
   10774:	d106      	bne.n	10784 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_62+0x3c>
   10776:	4a05      	ldr	r2, [pc, #20]	; (1078c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_62+0x44>)
   10778:	9b01      	ldr	r3, [sp, #4]
   1077a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1077e:	2b00      	cmp	r3, #0
   10780:	d100      	bne.n	10784 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_62+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   10782:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10784:	bf00      	nop
   10786:	b003      	add	sp, #12
   10788:	f85d fb04 	ldr.w	pc, [sp], #4
   1078c:	1fff9244 	.word	0x1fff9244
   10790:	1fff9240 	.word	0x1fff9240

00010794 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_63>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_63(void)
{
   10794:	b500      	push	{lr}
   10796:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10798:	f7f0 f9fe 	bl	b98 <Sys_GetCoreID>
   1079c:	4603      	mov	r3, r0
   1079e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_63[u32CoreId])
   107a0:	4a10      	ldr	r2, [pc, #64]	; (107e4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_63+0x50>)
   107a2:	9b01      	ldr	r3, [sp, #4]
   107a4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   107a8:	2b00      	cmp	r3, #0
   107aa:	d10d      	bne.n	107c8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_63+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   107ac:	f7f0 f8e6 	bl	97c <Adc_schm_read_msr>
   107b0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   107b2:	9b00      	ldr	r3, [sp, #0]
   107b4:	f003 0301 	and.w	r3, r3, #1
   107b8:	2b00      	cmp	r3, #0
   107ba:	d100      	bne.n	107be <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_63+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   107bc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_63[u32CoreId] = msr;
   107be:	490a      	ldr	r1, [pc, #40]	; (107e8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_63+0x54>)
   107c0:	9b01      	ldr	r3, [sp, #4]
   107c2:	9a00      	ldr	r2, [sp, #0]
   107c4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_63[u32CoreId]++;
   107c8:	4a06      	ldr	r2, [pc, #24]	; (107e4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_63+0x50>)
   107ca:	9b01      	ldr	r3, [sp, #4]
   107cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   107d0:	1c5a      	adds	r2, r3, #1
   107d2:	4904      	ldr	r1, [pc, #16]	; (107e4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_63+0x50>)
   107d4:	9b01      	ldr	r3, [sp, #4]
   107d6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   107da:	bf00      	nop
   107dc:	b003      	add	sp, #12
   107de:	f85d fb04 	ldr.w	pc, [sp], #4
   107e2:	bf00      	nop
   107e4:	1fff924c 	.word	0x1fff924c
   107e8:	1fff9248 	.word	0x1fff9248

000107ec <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_63>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_63(void)
{
   107ec:	b500      	push	{lr}
   107ee:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   107f0:	f7f0 f9d2 	bl	b98 <Sys_GetCoreID>
   107f4:	4603      	mov	r3, r0
   107f6:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_63[u32CoreId]--;
   107f8:	4a0d      	ldr	r2, [pc, #52]	; (10830 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_63+0x44>)
   107fa:	9b01      	ldr	r3, [sp, #4]
   107fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10800:	1e5a      	subs	r2, r3, #1
   10802:	490b      	ldr	r1, [pc, #44]	; (10830 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_63+0x44>)
   10804:	9b01      	ldr	r3, [sp, #4]
   10806:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_63[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_63[u32CoreId]))         /*if interrupts were enabled*/
   1080a:	4a0a      	ldr	r2, [pc, #40]	; (10834 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_63+0x48>)
   1080c:	9b01      	ldr	r3, [sp, #4]
   1080e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10812:	f003 0301 	and.w	r3, r3, #1
   10816:	2b00      	cmp	r3, #0
   10818:	d106      	bne.n	10828 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_63+0x3c>
   1081a:	4a05      	ldr	r2, [pc, #20]	; (10830 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_63+0x44>)
   1081c:	9b01      	ldr	r3, [sp, #4]
   1081e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10822:	2b00      	cmp	r3, #0
   10824:	d100      	bne.n	10828 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_63+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   10826:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10828:	bf00      	nop
   1082a:	b003      	add	sp, #12
   1082c:	f85d fb04 	ldr.w	pc, [sp], #4
   10830:	1fff924c 	.word	0x1fff924c
   10834:	1fff9248 	.word	0x1fff9248

00010838 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_64>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_64(void)
{
   10838:	b500      	push	{lr}
   1083a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1083c:	f7f0 f9ac 	bl	b98 <Sys_GetCoreID>
   10840:	4603      	mov	r3, r0
   10842:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_64[u32CoreId])
   10844:	4a10      	ldr	r2, [pc, #64]	; (10888 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_64+0x50>)
   10846:	9b01      	ldr	r3, [sp, #4]
   10848:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1084c:	2b00      	cmp	r3, #0
   1084e:	d10d      	bne.n	1086c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_64+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10850:	f7f0 f894 	bl	97c <Adc_schm_read_msr>
   10854:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   10856:	9b00      	ldr	r3, [sp, #0]
   10858:	f003 0301 	and.w	r3, r3, #1
   1085c:	2b00      	cmp	r3, #0
   1085e:	d100      	bne.n	10862 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_64+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10860:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_64[u32CoreId] = msr;
   10862:	490a      	ldr	r1, [pc, #40]	; (1088c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_64+0x54>)
   10864:	9b01      	ldr	r3, [sp, #4]
   10866:	9a00      	ldr	r2, [sp, #0]
   10868:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_64[u32CoreId]++;
   1086c:	4a06      	ldr	r2, [pc, #24]	; (10888 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_64+0x50>)
   1086e:	9b01      	ldr	r3, [sp, #4]
   10870:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10874:	1c5a      	adds	r2, r3, #1
   10876:	4904      	ldr	r1, [pc, #16]	; (10888 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_64+0x50>)
   10878:	9b01      	ldr	r3, [sp, #4]
   1087a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1087e:	bf00      	nop
   10880:	b003      	add	sp, #12
   10882:	f85d fb04 	ldr.w	pc, [sp], #4
   10886:	bf00      	nop
   10888:	1fff9254 	.word	0x1fff9254
   1088c:	1fff9250 	.word	0x1fff9250

00010890 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_64>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_64(void)
{
   10890:	b500      	push	{lr}
   10892:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10894:	f7f0 f980 	bl	b98 <Sys_GetCoreID>
   10898:	4603      	mov	r3, r0
   1089a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_64[u32CoreId]--;
   1089c:	4a0d      	ldr	r2, [pc, #52]	; (108d4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_64+0x44>)
   1089e:	9b01      	ldr	r3, [sp, #4]
   108a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   108a4:	1e5a      	subs	r2, r3, #1
   108a6:	490b      	ldr	r1, [pc, #44]	; (108d4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_64+0x44>)
   108a8:	9b01      	ldr	r3, [sp, #4]
   108aa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_64[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_64[u32CoreId]))         /*if interrupts were enabled*/
   108ae:	4a0a      	ldr	r2, [pc, #40]	; (108d8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_64+0x48>)
   108b0:	9b01      	ldr	r3, [sp, #4]
   108b2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   108b6:	f003 0301 	and.w	r3, r3, #1
   108ba:	2b00      	cmp	r3, #0
   108bc:	d106      	bne.n	108cc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_64+0x3c>
   108be:	4a05      	ldr	r2, [pc, #20]	; (108d4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_64+0x44>)
   108c0:	9b01      	ldr	r3, [sp, #4]
   108c2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   108c6:	2b00      	cmp	r3, #0
   108c8:	d100      	bne.n	108cc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_64+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   108ca:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   108cc:	bf00      	nop
   108ce:	b003      	add	sp, #12
   108d0:	f85d fb04 	ldr.w	pc, [sp], #4
   108d4:	1fff9254 	.word	0x1fff9254
   108d8:	1fff9250 	.word	0x1fff9250

000108dc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_65>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_65(void)
{
   108dc:	b500      	push	{lr}
   108de:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   108e0:	f7f0 f95a 	bl	b98 <Sys_GetCoreID>
   108e4:	4603      	mov	r3, r0
   108e6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_65[u32CoreId])
   108e8:	4a10      	ldr	r2, [pc, #64]	; (1092c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_65+0x50>)
   108ea:	9b01      	ldr	r3, [sp, #4]
   108ec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   108f0:	2b00      	cmp	r3, #0
   108f2:	d10d      	bne.n	10910 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_65+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   108f4:	f7f0 f842 	bl	97c <Adc_schm_read_msr>
   108f8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   108fa:	9b00      	ldr	r3, [sp, #0]
   108fc:	f003 0301 	and.w	r3, r3, #1
   10900:	2b00      	cmp	r3, #0
   10902:	d100      	bne.n	10906 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_65+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10904:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_65[u32CoreId] = msr;
   10906:	490a      	ldr	r1, [pc, #40]	; (10930 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_65+0x54>)
   10908:	9b01      	ldr	r3, [sp, #4]
   1090a:	9a00      	ldr	r2, [sp, #0]
   1090c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_65[u32CoreId]++;
   10910:	4a06      	ldr	r2, [pc, #24]	; (1092c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_65+0x50>)
   10912:	9b01      	ldr	r3, [sp, #4]
   10914:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10918:	1c5a      	adds	r2, r3, #1
   1091a:	4904      	ldr	r1, [pc, #16]	; (1092c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_65+0x50>)
   1091c:	9b01      	ldr	r3, [sp, #4]
   1091e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10922:	bf00      	nop
   10924:	b003      	add	sp, #12
   10926:	f85d fb04 	ldr.w	pc, [sp], #4
   1092a:	bf00      	nop
   1092c:	1fff925c 	.word	0x1fff925c
   10930:	1fff9258 	.word	0x1fff9258

00010934 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_65>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_65(void)
{
   10934:	b500      	push	{lr}
   10936:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10938:	f7f0 f92e 	bl	b98 <Sys_GetCoreID>
   1093c:	4603      	mov	r3, r0
   1093e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_65[u32CoreId]--;
   10940:	4a0d      	ldr	r2, [pc, #52]	; (10978 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_65+0x44>)
   10942:	9b01      	ldr	r3, [sp, #4]
   10944:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10948:	1e5a      	subs	r2, r3, #1
   1094a:	490b      	ldr	r1, [pc, #44]	; (10978 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_65+0x44>)
   1094c:	9b01      	ldr	r3, [sp, #4]
   1094e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_65[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_65[u32CoreId]))         /*if interrupts were enabled*/
   10952:	4a0a      	ldr	r2, [pc, #40]	; (1097c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_65+0x48>)
   10954:	9b01      	ldr	r3, [sp, #4]
   10956:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1095a:	f003 0301 	and.w	r3, r3, #1
   1095e:	2b00      	cmp	r3, #0
   10960:	d106      	bne.n	10970 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_65+0x3c>
   10962:	4a05      	ldr	r2, [pc, #20]	; (10978 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_65+0x44>)
   10964:	9b01      	ldr	r3, [sp, #4]
   10966:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1096a:	2b00      	cmp	r3, #0
   1096c:	d100      	bne.n	10970 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_65+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1096e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10970:	bf00      	nop
   10972:	b003      	add	sp, #12
   10974:	f85d fb04 	ldr.w	pc, [sp], #4
   10978:	1fff925c 	.word	0x1fff925c
   1097c:	1fff9258 	.word	0x1fff9258

00010980 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_66>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_66(void)
{
   10980:	b500      	push	{lr}
   10982:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10984:	f7f0 f908 	bl	b98 <Sys_GetCoreID>
   10988:	4603      	mov	r3, r0
   1098a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_66[u32CoreId])
   1098c:	4a10      	ldr	r2, [pc, #64]	; (109d0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_66+0x50>)
   1098e:	9b01      	ldr	r3, [sp, #4]
   10990:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10994:	2b00      	cmp	r3, #0
   10996:	d10d      	bne.n	109b4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_66+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10998:	f7ef fff0 	bl	97c <Adc_schm_read_msr>
   1099c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1099e:	9b00      	ldr	r3, [sp, #0]
   109a0:	f003 0301 	and.w	r3, r3, #1
   109a4:	2b00      	cmp	r3, #0
   109a6:	d100      	bne.n	109aa <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_66+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   109a8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_66[u32CoreId] = msr;
   109aa:	490a      	ldr	r1, [pc, #40]	; (109d4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_66+0x54>)
   109ac:	9b01      	ldr	r3, [sp, #4]
   109ae:	9a00      	ldr	r2, [sp, #0]
   109b0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_66[u32CoreId]++;
   109b4:	4a06      	ldr	r2, [pc, #24]	; (109d0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_66+0x50>)
   109b6:	9b01      	ldr	r3, [sp, #4]
   109b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   109bc:	1c5a      	adds	r2, r3, #1
   109be:	4904      	ldr	r1, [pc, #16]	; (109d0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_66+0x50>)
   109c0:	9b01      	ldr	r3, [sp, #4]
   109c2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   109c6:	bf00      	nop
   109c8:	b003      	add	sp, #12
   109ca:	f85d fb04 	ldr.w	pc, [sp], #4
   109ce:	bf00      	nop
   109d0:	1fff9264 	.word	0x1fff9264
   109d4:	1fff9260 	.word	0x1fff9260

000109d8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_66>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_66(void)
{
   109d8:	b500      	push	{lr}
   109da:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   109dc:	f7f0 f8dc 	bl	b98 <Sys_GetCoreID>
   109e0:	4603      	mov	r3, r0
   109e2:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_66[u32CoreId]--;
   109e4:	4a0d      	ldr	r2, [pc, #52]	; (10a1c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_66+0x44>)
   109e6:	9b01      	ldr	r3, [sp, #4]
   109e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   109ec:	1e5a      	subs	r2, r3, #1
   109ee:	490b      	ldr	r1, [pc, #44]	; (10a1c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_66+0x44>)
   109f0:	9b01      	ldr	r3, [sp, #4]
   109f2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_66[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_66[u32CoreId]))         /*if interrupts were enabled*/
   109f6:	4a0a      	ldr	r2, [pc, #40]	; (10a20 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_66+0x48>)
   109f8:	9b01      	ldr	r3, [sp, #4]
   109fa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   109fe:	f003 0301 	and.w	r3, r3, #1
   10a02:	2b00      	cmp	r3, #0
   10a04:	d106      	bne.n	10a14 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_66+0x3c>
   10a06:	4a05      	ldr	r2, [pc, #20]	; (10a1c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_66+0x44>)
   10a08:	9b01      	ldr	r3, [sp, #4]
   10a0a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10a0e:	2b00      	cmp	r3, #0
   10a10:	d100      	bne.n	10a14 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_66+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   10a12:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10a14:	bf00      	nop
   10a16:	b003      	add	sp, #12
   10a18:	f85d fb04 	ldr.w	pc, [sp], #4
   10a1c:	1fff9264 	.word	0x1fff9264
   10a20:	1fff9260 	.word	0x1fff9260

00010a24 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_67>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_67(void)
{
   10a24:	b500      	push	{lr}
   10a26:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10a28:	f7f0 f8b6 	bl	b98 <Sys_GetCoreID>
   10a2c:	4603      	mov	r3, r0
   10a2e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_67[u32CoreId])
   10a30:	4a10      	ldr	r2, [pc, #64]	; (10a74 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_67+0x50>)
   10a32:	9b01      	ldr	r3, [sp, #4]
   10a34:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10a38:	2b00      	cmp	r3, #0
   10a3a:	d10d      	bne.n	10a58 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_67+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10a3c:	f7ef ff9e 	bl	97c <Adc_schm_read_msr>
   10a40:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   10a42:	9b00      	ldr	r3, [sp, #0]
   10a44:	f003 0301 	and.w	r3, r3, #1
   10a48:	2b00      	cmp	r3, #0
   10a4a:	d100      	bne.n	10a4e <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_67+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10a4c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_67[u32CoreId] = msr;
   10a4e:	490a      	ldr	r1, [pc, #40]	; (10a78 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_67+0x54>)
   10a50:	9b01      	ldr	r3, [sp, #4]
   10a52:	9a00      	ldr	r2, [sp, #0]
   10a54:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_67[u32CoreId]++;
   10a58:	4a06      	ldr	r2, [pc, #24]	; (10a74 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_67+0x50>)
   10a5a:	9b01      	ldr	r3, [sp, #4]
   10a5c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10a60:	1c5a      	adds	r2, r3, #1
   10a62:	4904      	ldr	r1, [pc, #16]	; (10a74 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_67+0x50>)
   10a64:	9b01      	ldr	r3, [sp, #4]
   10a66:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10a6a:	bf00      	nop
   10a6c:	b003      	add	sp, #12
   10a6e:	f85d fb04 	ldr.w	pc, [sp], #4
   10a72:	bf00      	nop
   10a74:	1fff926c 	.word	0x1fff926c
   10a78:	1fff9268 	.word	0x1fff9268

00010a7c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_67>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_67(void)
{
   10a7c:	b500      	push	{lr}
   10a7e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10a80:	f7f0 f88a 	bl	b98 <Sys_GetCoreID>
   10a84:	4603      	mov	r3, r0
   10a86:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_67[u32CoreId]--;
   10a88:	4a0d      	ldr	r2, [pc, #52]	; (10ac0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_67+0x44>)
   10a8a:	9b01      	ldr	r3, [sp, #4]
   10a8c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10a90:	1e5a      	subs	r2, r3, #1
   10a92:	490b      	ldr	r1, [pc, #44]	; (10ac0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_67+0x44>)
   10a94:	9b01      	ldr	r3, [sp, #4]
   10a96:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_67[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_67[u32CoreId]))         /*if interrupts were enabled*/
   10a9a:	4a0a      	ldr	r2, [pc, #40]	; (10ac4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_67+0x48>)
   10a9c:	9b01      	ldr	r3, [sp, #4]
   10a9e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10aa2:	f003 0301 	and.w	r3, r3, #1
   10aa6:	2b00      	cmp	r3, #0
   10aa8:	d106      	bne.n	10ab8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_67+0x3c>
   10aaa:	4a05      	ldr	r2, [pc, #20]	; (10ac0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_67+0x44>)
   10aac:	9b01      	ldr	r3, [sp, #4]
   10aae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10ab2:	2b00      	cmp	r3, #0
   10ab4:	d100      	bne.n	10ab8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_67+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   10ab6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10ab8:	bf00      	nop
   10aba:	b003      	add	sp, #12
   10abc:	f85d fb04 	ldr.w	pc, [sp], #4
   10ac0:	1fff926c 	.word	0x1fff926c
   10ac4:	1fff9268 	.word	0x1fff9268

00010ac8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_68>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_68(void)
{
   10ac8:	b500      	push	{lr}
   10aca:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10acc:	f7f0 f864 	bl	b98 <Sys_GetCoreID>
   10ad0:	4603      	mov	r3, r0
   10ad2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_68[u32CoreId])
   10ad4:	4a10      	ldr	r2, [pc, #64]	; (10b18 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_68+0x50>)
   10ad6:	9b01      	ldr	r3, [sp, #4]
   10ad8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10adc:	2b00      	cmp	r3, #0
   10ade:	d10d      	bne.n	10afc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_68+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10ae0:	f7ef ff4c 	bl	97c <Adc_schm_read_msr>
   10ae4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   10ae6:	9b00      	ldr	r3, [sp, #0]
   10ae8:	f003 0301 	and.w	r3, r3, #1
   10aec:	2b00      	cmp	r3, #0
   10aee:	d100      	bne.n	10af2 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_68+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10af0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_68[u32CoreId] = msr;
   10af2:	490a      	ldr	r1, [pc, #40]	; (10b1c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_68+0x54>)
   10af4:	9b01      	ldr	r3, [sp, #4]
   10af6:	9a00      	ldr	r2, [sp, #0]
   10af8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_68[u32CoreId]++;
   10afc:	4a06      	ldr	r2, [pc, #24]	; (10b18 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_68+0x50>)
   10afe:	9b01      	ldr	r3, [sp, #4]
   10b00:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10b04:	1c5a      	adds	r2, r3, #1
   10b06:	4904      	ldr	r1, [pc, #16]	; (10b18 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_68+0x50>)
   10b08:	9b01      	ldr	r3, [sp, #4]
   10b0a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10b0e:	bf00      	nop
   10b10:	b003      	add	sp, #12
   10b12:	f85d fb04 	ldr.w	pc, [sp], #4
   10b16:	bf00      	nop
   10b18:	1fff9274 	.word	0x1fff9274
   10b1c:	1fff9270 	.word	0x1fff9270

00010b20 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_68>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_68(void)
{
   10b20:	b500      	push	{lr}
   10b22:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10b24:	f7f0 f838 	bl	b98 <Sys_GetCoreID>
   10b28:	4603      	mov	r3, r0
   10b2a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_68[u32CoreId]--;
   10b2c:	4a0d      	ldr	r2, [pc, #52]	; (10b64 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_68+0x44>)
   10b2e:	9b01      	ldr	r3, [sp, #4]
   10b30:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10b34:	1e5a      	subs	r2, r3, #1
   10b36:	490b      	ldr	r1, [pc, #44]	; (10b64 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_68+0x44>)
   10b38:	9b01      	ldr	r3, [sp, #4]
   10b3a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_68[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_68[u32CoreId]))         /*if interrupts were enabled*/
   10b3e:	4a0a      	ldr	r2, [pc, #40]	; (10b68 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_68+0x48>)
   10b40:	9b01      	ldr	r3, [sp, #4]
   10b42:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10b46:	f003 0301 	and.w	r3, r3, #1
   10b4a:	2b00      	cmp	r3, #0
   10b4c:	d106      	bne.n	10b5c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_68+0x3c>
   10b4e:	4a05      	ldr	r2, [pc, #20]	; (10b64 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_68+0x44>)
   10b50:	9b01      	ldr	r3, [sp, #4]
   10b52:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10b56:	2b00      	cmp	r3, #0
   10b58:	d100      	bne.n	10b5c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_68+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   10b5a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10b5c:	bf00      	nop
   10b5e:	b003      	add	sp, #12
   10b60:	f85d fb04 	ldr.w	pc, [sp], #4
   10b64:	1fff9274 	.word	0x1fff9274
   10b68:	1fff9270 	.word	0x1fff9270

00010b6c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_69>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_69(void)
{
   10b6c:	b500      	push	{lr}
   10b6e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10b70:	f7f0 f812 	bl	b98 <Sys_GetCoreID>
   10b74:	4603      	mov	r3, r0
   10b76:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_69[u32CoreId])
   10b78:	4a10      	ldr	r2, [pc, #64]	; (10bbc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_69+0x50>)
   10b7a:	9b01      	ldr	r3, [sp, #4]
   10b7c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10b80:	2b00      	cmp	r3, #0
   10b82:	d10d      	bne.n	10ba0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_69+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10b84:	f7ef fefa 	bl	97c <Adc_schm_read_msr>
   10b88:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   10b8a:	9b00      	ldr	r3, [sp, #0]
   10b8c:	f003 0301 	and.w	r3, r3, #1
   10b90:	2b00      	cmp	r3, #0
   10b92:	d100      	bne.n	10b96 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_69+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10b94:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_69[u32CoreId] = msr;
   10b96:	490a      	ldr	r1, [pc, #40]	; (10bc0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_69+0x54>)
   10b98:	9b01      	ldr	r3, [sp, #4]
   10b9a:	9a00      	ldr	r2, [sp, #0]
   10b9c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_69[u32CoreId]++;
   10ba0:	4a06      	ldr	r2, [pc, #24]	; (10bbc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_69+0x50>)
   10ba2:	9b01      	ldr	r3, [sp, #4]
   10ba4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10ba8:	1c5a      	adds	r2, r3, #1
   10baa:	4904      	ldr	r1, [pc, #16]	; (10bbc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_69+0x50>)
   10bac:	9b01      	ldr	r3, [sp, #4]
   10bae:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10bb2:	bf00      	nop
   10bb4:	b003      	add	sp, #12
   10bb6:	f85d fb04 	ldr.w	pc, [sp], #4
   10bba:	bf00      	nop
   10bbc:	1fff927c 	.word	0x1fff927c
   10bc0:	1fff9278 	.word	0x1fff9278

00010bc4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_69>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_69(void)
{
   10bc4:	b500      	push	{lr}
   10bc6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10bc8:	f7ef ffe6 	bl	b98 <Sys_GetCoreID>
   10bcc:	4603      	mov	r3, r0
   10bce:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_69[u32CoreId]--;
   10bd0:	4a0d      	ldr	r2, [pc, #52]	; (10c08 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_69+0x44>)
   10bd2:	9b01      	ldr	r3, [sp, #4]
   10bd4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10bd8:	1e5a      	subs	r2, r3, #1
   10bda:	490b      	ldr	r1, [pc, #44]	; (10c08 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_69+0x44>)
   10bdc:	9b01      	ldr	r3, [sp, #4]
   10bde:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_69[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_69[u32CoreId]))         /*if interrupts were enabled*/
   10be2:	4a0a      	ldr	r2, [pc, #40]	; (10c0c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_69+0x48>)
   10be4:	9b01      	ldr	r3, [sp, #4]
   10be6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10bea:	f003 0301 	and.w	r3, r3, #1
   10bee:	2b00      	cmp	r3, #0
   10bf0:	d106      	bne.n	10c00 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_69+0x3c>
   10bf2:	4a05      	ldr	r2, [pc, #20]	; (10c08 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_69+0x44>)
   10bf4:	9b01      	ldr	r3, [sp, #4]
   10bf6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10bfa:	2b00      	cmp	r3, #0
   10bfc:	d100      	bne.n	10c00 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_69+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   10bfe:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10c00:	bf00      	nop
   10c02:	b003      	add	sp, #12
   10c04:	f85d fb04 	ldr.w	pc, [sp], #4
   10c08:	1fff927c 	.word	0x1fff927c
   10c0c:	1fff9278 	.word	0x1fff9278

00010c10 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_70>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_70(void)
{
   10c10:	b500      	push	{lr}
   10c12:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10c14:	f7ef ffc0 	bl	b98 <Sys_GetCoreID>
   10c18:	4603      	mov	r3, r0
   10c1a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_70[u32CoreId])
   10c1c:	4a10      	ldr	r2, [pc, #64]	; (10c60 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_70+0x50>)
   10c1e:	9b01      	ldr	r3, [sp, #4]
   10c20:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10c24:	2b00      	cmp	r3, #0
   10c26:	d10d      	bne.n	10c44 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_70+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10c28:	f7ef fea8 	bl	97c <Adc_schm_read_msr>
   10c2c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   10c2e:	9b00      	ldr	r3, [sp, #0]
   10c30:	f003 0301 	and.w	r3, r3, #1
   10c34:	2b00      	cmp	r3, #0
   10c36:	d100      	bne.n	10c3a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_70+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10c38:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_70[u32CoreId] = msr;
   10c3a:	490a      	ldr	r1, [pc, #40]	; (10c64 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_70+0x54>)
   10c3c:	9b01      	ldr	r3, [sp, #4]
   10c3e:	9a00      	ldr	r2, [sp, #0]
   10c40:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_70[u32CoreId]++;
   10c44:	4a06      	ldr	r2, [pc, #24]	; (10c60 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_70+0x50>)
   10c46:	9b01      	ldr	r3, [sp, #4]
   10c48:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10c4c:	1c5a      	adds	r2, r3, #1
   10c4e:	4904      	ldr	r1, [pc, #16]	; (10c60 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_70+0x50>)
   10c50:	9b01      	ldr	r3, [sp, #4]
   10c52:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10c56:	bf00      	nop
   10c58:	b003      	add	sp, #12
   10c5a:	f85d fb04 	ldr.w	pc, [sp], #4
   10c5e:	bf00      	nop
   10c60:	1fff9284 	.word	0x1fff9284
   10c64:	1fff9280 	.word	0x1fff9280

00010c68 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_70>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_70(void)
{
   10c68:	b500      	push	{lr}
   10c6a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10c6c:	f7ef ff94 	bl	b98 <Sys_GetCoreID>
   10c70:	4603      	mov	r3, r0
   10c72:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_70[u32CoreId]--;
   10c74:	4a0d      	ldr	r2, [pc, #52]	; (10cac <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_70+0x44>)
   10c76:	9b01      	ldr	r3, [sp, #4]
   10c78:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10c7c:	1e5a      	subs	r2, r3, #1
   10c7e:	490b      	ldr	r1, [pc, #44]	; (10cac <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_70+0x44>)
   10c80:	9b01      	ldr	r3, [sp, #4]
   10c82:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_70[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_70[u32CoreId]))         /*if interrupts were enabled*/
   10c86:	4a0a      	ldr	r2, [pc, #40]	; (10cb0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_70+0x48>)
   10c88:	9b01      	ldr	r3, [sp, #4]
   10c8a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10c8e:	f003 0301 	and.w	r3, r3, #1
   10c92:	2b00      	cmp	r3, #0
   10c94:	d106      	bne.n	10ca4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_70+0x3c>
   10c96:	4a05      	ldr	r2, [pc, #20]	; (10cac <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_70+0x44>)
   10c98:	9b01      	ldr	r3, [sp, #4]
   10c9a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10c9e:	2b00      	cmp	r3, #0
   10ca0:	d100      	bne.n	10ca4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_70+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   10ca2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10ca4:	bf00      	nop
   10ca6:	b003      	add	sp, #12
   10ca8:	f85d fb04 	ldr.w	pc, [sp], #4
   10cac:	1fff9284 	.word	0x1fff9284
   10cb0:	1fff9280 	.word	0x1fff9280

00010cb4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_71>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_71(void)
{
   10cb4:	b500      	push	{lr}
   10cb6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10cb8:	f7ef ff6e 	bl	b98 <Sys_GetCoreID>
   10cbc:	4603      	mov	r3, r0
   10cbe:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_71[u32CoreId])
   10cc0:	4a10      	ldr	r2, [pc, #64]	; (10d04 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_71+0x50>)
   10cc2:	9b01      	ldr	r3, [sp, #4]
   10cc4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10cc8:	2b00      	cmp	r3, #0
   10cca:	d10d      	bne.n	10ce8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_71+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10ccc:	f7ef fe56 	bl	97c <Adc_schm_read_msr>
   10cd0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   10cd2:	9b00      	ldr	r3, [sp, #0]
   10cd4:	f003 0301 	and.w	r3, r3, #1
   10cd8:	2b00      	cmp	r3, #0
   10cda:	d100      	bne.n	10cde <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_71+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10cdc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_71[u32CoreId] = msr;
   10cde:	490a      	ldr	r1, [pc, #40]	; (10d08 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_71+0x54>)
   10ce0:	9b01      	ldr	r3, [sp, #4]
   10ce2:	9a00      	ldr	r2, [sp, #0]
   10ce4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_71[u32CoreId]++;
   10ce8:	4a06      	ldr	r2, [pc, #24]	; (10d04 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_71+0x50>)
   10cea:	9b01      	ldr	r3, [sp, #4]
   10cec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10cf0:	1c5a      	adds	r2, r3, #1
   10cf2:	4904      	ldr	r1, [pc, #16]	; (10d04 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_71+0x50>)
   10cf4:	9b01      	ldr	r3, [sp, #4]
   10cf6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10cfa:	bf00      	nop
   10cfc:	b003      	add	sp, #12
   10cfe:	f85d fb04 	ldr.w	pc, [sp], #4
   10d02:	bf00      	nop
   10d04:	1fff928c 	.word	0x1fff928c
   10d08:	1fff9288 	.word	0x1fff9288

00010d0c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_71>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_71(void)
{
   10d0c:	b500      	push	{lr}
   10d0e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10d10:	f7ef ff42 	bl	b98 <Sys_GetCoreID>
   10d14:	4603      	mov	r3, r0
   10d16:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_71[u32CoreId]--;
   10d18:	4a0d      	ldr	r2, [pc, #52]	; (10d50 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_71+0x44>)
   10d1a:	9b01      	ldr	r3, [sp, #4]
   10d1c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10d20:	1e5a      	subs	r2, r3, #1
   10d22:	490b      	ldr	r1, [pc, #44]	; (10d50 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_71+0x44>)
   10d24:	9b01      	ldr	r3, [sp, #4]
   10d26:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_71[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_71[u32CoreId]))         /*if interrupts were enabled*/
   10d2a:	4a0a      	ldr	r2, [pc, #40]	; (10d54 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_71+0x48>)
   10d2c:	9b01      	ldr	r3, [sp, #4]
   10d2e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10d32:	f003 0301 	and.w	r3, r3, #1
   10d36:	2b00      	cmp	r3, #0
   10d38:	d106      	bne.n	10d48 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_71+0x3c>
   10d3a:	4a05      	ldr	r2, [pc, #20]	; (10d50 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_71+0x44>)
   10d3c:	9b01      	ldr	r3, [sp, #4]
   10d3e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10d42:	2b00      	cmp	r3, #0
   10d44:	d100      	bne.n	10d48 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_71+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   10d46:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10d48:	bf00      	nop
   10d4a:	b003      	add	sp, #12
   10d4c:	f85d fb04 	ldr.w	pc, [sp], #4
   10d50:	1fff928c 	.word	0x1fff928c
   10d54:	1fff9288 	.word	0x1fff9288

00010d58 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_72>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_72(void)
{
   10d58:	b500      	push	{lr}
   10d5a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10d5c:	f7ef ff1c 	bl	b98 <Sys_GetCoreID>
   10d60:	4603      	mov	r3, r0
   10d62:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_72[u32CoreId])
   10d64:	4a10      	ldr	r2, [pc, #64]	; (10da8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_72+0x50>)
   10d66:	9b01      	ldr	r3, [sp, #4]
   10d68:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10d6c:	2b00      	cmp	r3, #0
   10d6e:	d10d      	bne.n	10d8c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_72+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10d70:	f7ef fe04 	bl	97c <Adc_schm_read_msr>
   10d74:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   10d76:	9b00      	ldr	r3, [sp, #0]
   10d78:	f003 0301 	and.w	r3, r3, #1
   10d7c:	2b00      	cmp	r3, #0
   10d7e:	d100      	bne.n	10d82 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_72+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10d80:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_72[u32CoreId] = msr;
   10d82:	490a      	ldr	r1, [pc, #40]	; (10dac <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_72+0x54>)
   10d84:	9b01      	ldr	r3, [sp, #4]
   10d86:	9a00      	ldr	r2, [sp, #0]
   10d88:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_72[u32CoreId]++;
   10d8c:	4a06      	ldr	r2, [pc, #24]	; (10da8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_72+0x50>)
   10d8e:	9b01      	ldr	r3, [sp, #4]
   10d90:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10d94:	1c5a      	adds	r2, r3, #1
   10d96:	4904      	ldr	r1, [pc, #16]	; (10da8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_72+0x50>)
   10d98:	9b01      	ldr	r3, [sp, #4]
   10d9a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10d9e:	bf00      	nop
   10da0:	b003      	add	sp, #12
   10da2:	f85d fb04 	ldr.w	pc, [sp], #4
   10da6:	bf00      	nop
   10da8:	1fff9294 	.word	0x1fff9294
   10dac:	1fff9290 	.word	0x1fff9290

00010db0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_72>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_72(void)
{
   10db0:	b500      	push	{lr}
   10db2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10db4:	f7ef fef0 	bl	b98 <Sys_GetCoreID>
   10db8:	4603      	mov	r3, r0
   10dba:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_72[u32CoreId]--;
   10dbc:	4a0d      	ldr	r2, [pc, #52]	; (10df4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_72+0x44>)
   10dbe:	9b01      	ldr	r3, [sp, #4]
   10dc0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10dc4:	1e5a      	subs	r2, r3, #1
   10dc6:	490b      	ldr	r1, [pc, #44]	; (10df4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_72+0x44>)
   10dc8:	9b01      	ldr	r3, [sp, #4]
   10dca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_72[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_72[u32CoreId]))         /*if interrupts were enabled*/
   10dce:	4a0a      	ldr	r2, [pc, #40]	; (10df8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_72+0x48>)
   10dd0:	9b01      	ldr	r3, [sp, #4]
   10dd2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10dd6:	f003 0301 	and.w	r3, r3, #1
   10dda:	2b00      	cmp	r3, #0
   10ddc:	d106      	bne.n	10dec <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_72+0x3c>
   10dde:	4a05      	ldr	r2, [pc, #20]	; (10df4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_72+0x44>)
   10de0:	9b01      	ldr	r3, [sp, #4]
   10de2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10de6:	2b00      	cmp	r3, #0
   10de8:	d100      	bne.n	10dec <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_72+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   10dea:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10dec:	bf00      	nop
   10dee:	b003      	add	sp, #12
   10df0:	f85d fb04 	ldr.w	pc, [sp], #4
   10df4:	1fff9294 	.word	0x1fff9294
   10df8:	1fff9290 	.word	0x1fff9290

00010dfc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_73>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_73(void)
{
   10dfc:	b500      	push	{lr}
   10dfe:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10e00:	f7ef feca 	bl	b98 <Sys_GetCoreID>
   10e04:	4603      	mov	r3, r0
   10e06:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_73[u32CoreId])
   10e08:	4a10      	ldr	r2, [pc, #64]	; (10e4c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_73+0x50>)
   10e0a:	9b01      	ldr	r3, [sp, #4]
   10e0c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10e10:	2b00      	cmp	r3, #0
   10e12:	d10d      	bne.n	10e30 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_73+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10e14:	f7ef fdb2 	bl	97c <Adc_schm_read_msr>
   10e18:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   10e1a:	9b00      	ldr	r3, [sp, #0]
   10e1c:	f003 0301 	and.w	r3, r3, #1
   10e20:	2b00      	cmp	r3, #0
   10e22:	d100      	bne.n	10e26 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_73+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10e24:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_73[u32CoreId] = msr;
   10e26:	490a      	ldr	r1, [pc, #40]	; (10e50 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_73+0x54>)
   10e28:	9b01      	ldr	r3, [sp, #4]
   10e2a:	9a00      	ldr	r2, [sp, #0]
   10e2c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_73[u32CoreId]++;
   10e30:	4a06      	ldr	r2, [pc, #24]	; (10e4c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_73+0x50>)
   10e32:	9b01      	ldr	r3, [sp, #4]
   10e34:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10e38:	1c5a      	adds	r2, r3, #1
   10e3a:	4904      	ldr	r1, [pc, #16]	; (10e4c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_73+0x50>)
   10e3c:	9b01      	ldr	r3, [sp, #4]
   10e3e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10e42:	bf00      	nop
   10e44:	b003      	add	sp, #12
   10e46:	f85d fb04 	ldr.w	pc, [sp], #4
   10e4a:	bf00      	nop
   10e4c:	1fff929c 	.word	0x1fff929c
   10e50:	1fff9298 	.word	0x1fff9298

00010e54 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_73>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_73(void)
{
   10e54:	b500      	push	{lr}
   10e56:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10e58:	f7ef fe9e 	bl	b98 <Sys_GetCoreID>
   10e5c:	4603      	mov	r3, r0
   10e5e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_73[u32CoreId]--;
   10e60:	4a0d      	ldr	r2, [pc, #52]	; (10e98 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_73+0x44>)
   10e62:	9b01      	ldr	r3, [sp, #4]
   10e64:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10e68:	1e5a      	subs	r2, r3, #1
   10e6a:	490b      	ldr	r1, [pc, #44]	; (10e98 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_73+0x44>)
   10e6c:	9b01      	ldr	r3, [sp, #4]
   10e6e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_73[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_73[u32CoreId]))         /*if interrupts were enabled*/
   10e72:	4a0a      	ldr	r2, [pc, #40]	; (10e9c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_73+0x48>)
   10e74:	9b01      	ldr	r3, [sp, #4]
   10e76:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10e7a:	f003 0301 	and.w	r3, r3, #1
   10e7e:	2b00      	cmp	r3, #0
   10e80:	d106      	bne.n	10e90 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_73+0x3c>
   10e82:	4a05      	ldr	r2, [pc, #20]	; (10e98 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_73+0x44>)
   10e84:	9b01      	ldr	r3, [sp, #4]
   10e86:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10e8a:	2b00      	cmp	r3, #0
   10e8c:	d100      	bne.n	10e90 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_73+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   10e8e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10e90:	bf00      	nop
   10e92:	b003      	add	sp, #12
   10e94:	f85d fb04 	ldr.w	pc, [sp], #4
   10e98:	1fff929c 	.word	0x1fff929c
   10e9c:	1fff9298 	.word	0x1fff9298

00010ea0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_74>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_74(void)
{
   10ea0:	b500      	push	{lr}
   10ea2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10ea4:	f7ef fe78 	bl	b98 <Sys_GetCoreID>
   10ea8:	4603      	mov	r3, r0
   10eaa:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_74[u32CoreId])
   10eac:	4a10      	ldr	r2, [pc, #64]	; (10ef0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_74+0x50>)
   10eae:	9b01      	ldr	r3, [sp, #4]
   10eb0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10eb4:	2b00      	cmp	r3, #0
   10eb6:	d10d      	bne.n	10ed4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_74+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10eb8:	f7ef fd60 	bl	97c <Adc_schm_read_msr>
   10ebc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   10ebe:	9b00      	ldr	r3, [sp, #0]
   10ec0:	f003 0301 	and.w	r3, r3, #1
   10ec4:	2b00      	cmp	r3, #0
   10ec6:	d100      	bne.n	10eca <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_74+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10ec8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_74[u32CoreId] = msr;
   10eca:	490a      	ldr	r1, [pc, #40]	; (10ef4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_74+0x54>)
   10ecc:	9b01      	ldr	r3, [sp, #4]
   10ece:	9a00      	ldr	r2, [sp, #0]
   10ed0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_74[u32CoreId]++;
   10ed4:	4a06      	ldr	r2, [pc, #24]	; (10ef0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_74+0x50>)
   10ed6:	9b01      	ldr	r3, [sp, #4]
   10ed8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10edc:	1c5a      	adds	r2, r3, #1
   10ede:	4904      	ldr	r1, [pc, #16]	; (10ef0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_74+0x50>)
   10ee0:	9b01      	ldr	r3, [sp, #4]
   10ee2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10ee6:	bf00      	nop
   10ee8:	b003      	add	sp, #12
   10eea:	f85d fb04 	ldr.w	pc, [sp], #4
   10eee:	bf00      	nop
   10ef0:	1fff92a4 	.word	0x1fff92a4
   10ef4:	1fff92a0 	.word	0x1fff92a0

00010ef8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_74>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_74(void)
{
   10ef8:	b500      	push	{lr}
   10efa:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10efc:	f7ef fe4c 	bl	b98 <Sys_GetCoreID>
   10f00:	4603      	mov	r3, r0
   10f02:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_74[u32CoreId]--;
   10f04:	4a0d      	ldr	r2, [pc, #52]	; (10f3c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_74+0x44>)
   10f06:	9b01      	ldr	r3, [sp, #4]
   10f08:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10f0c:	1e5a      	subs	r2, r3, #1
   10f0e:	490b      	ldr	r1, [pc, #44]	; (10f3c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_74+0x44>)
   10f10:	9b01      	ldr	r3, [sp, #4]
   10f12:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_74[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_74[u32CoreId]))         /*if interrupts were enabled*/
   10f16:	4a0a      	ldr	r2, [pc, #40]	; (10f40 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_74+0x48>)
   10f18:	9b01      	ldr	r3, [sp, #4]
   10f1a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10f1e:	f003 0301 	and.w	r3, r3, #1
   10f22:	2b00      	cmp	r3, #0
   10f24:	d106      	bne.n	10f34 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_74+0x3c>
   10f26:	4a05      	ldr	r2, [pc, #20]	; (10f3c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_74+0x44>)
   10f28:	9b01      	ldr	r3, [sp, #4]
   10f2a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10f2e:	2b00      	cmp	r3, #0
   10f30:	d100      	bne.n	10f34 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_74+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   10f32:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10f34:	bf00      	nop
   10f36:	b003      	add	sp, #12
   10f38:	f85d fb04 	ldr.w	pc, [sp], #4
   10f3c:	1fff92a4 	.word	0x1fff92a4
   10f40:	1fff92a0 	.word	0x1fff92a0

00010f44 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_75>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_75(void)
{
   10f44:	b500      	push	{lr}
   10f46:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10f48:	f7ef fe26 	bl	b98 <Sys_GetCoreID>
   10f4c:	4603      	mov	r3, r0
   10f4e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_75[u32CoreId])
   10f50:	4a10      	ldr	r2, [pc, #64]	; (10f94 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_75+0x50>)
   10f52:	9b01      	ldr	r3, [sp, #4]
   10f54:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10f58:	2b00      	cmp	r3, #0
   10f5a:	d10d      	bne.n	10f78 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_75+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   10f5c:	f7ef fd0e 	bl	97c <Adc_schm_read_msr>
   10f60:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   10f62:	9b00      	ldr	r3, [sp, #0]
   10f64:	f003 0301 	and.w	r3, r3, #1
   10f68:	2b00      	cmp	r3, #0
   10f6a:	d100      	bne.n	10f6e <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_75+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   10f6c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_75[u32CoreId] = msr;
   10f6e:	490a      	ldr	r1, [pc, #40]	; (10f98 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_75+0x54>)
   10f70:	9b01      	ldr	r3, [sp, #4]
   10f72:	9a00      	ldr	r2, [sp, #0]
   10f74:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_75[u32CoreId]++;
   10f78:	4a06      	ldr	r2, [pc, #24]	; (10f94 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_75+0x50>)
   10f7a:	9b01      	ldr	r3, [sp, #4]
   10f7c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10f80:	1c5a      	adds	r2, r3, #1
   10f82:	4904      	ldr	r1, [pc, #16]	; (10f94 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_75+0x50>)
   10f84:	9b01      	ldr	r3, [sp, #4]
   10f86:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   10f8a:	bf00      	nop
   10f8c:	b003      	add	sp, #12
   10f8e:	f85d fb04 	ldr.w	pc, [sp], #4
   10f92:	bf00      	nop
   10f94:	1fff92ac 	.word	0x1fff92ac
   10f98:	1fff92a8 	.word	0x1fff92a8

00010f9c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_75>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_75(void)
{
   10f9c:	b500      	push	{lr}
   10f9e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10fa0:	f7ef fdfa 	bl	b98 <Sys_GetCoreID>
   10fa4:	4603      	mov	r3, r0
   10fa6:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_75[u32CoreId]--;
   10fa8:	4a0d      	ldr	r2, [pc, #52]	; (10fe0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_75+0x44>)
   10faa:	9b01      	ldr	r3, [sp, #4]
   10fac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10fb0:	1e5a      	subs	r2, r3, #1
   10fb2:	490b      	ldr	r1, [pc, #44]	; (10fe0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_75+0x44>)
   10fb4:	9b01      	ldr	r3, [sp, #4]
   10fb6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_75[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_75[u32CoreId]))         /*if interrupts were enabled*/
   10fba:	4a0a      	ldr	r2, [pc, #40]	; (10fe4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_75+0x48>)
   10fbc:	9b01      	ldr	r3, [sp, #4]
   10fbe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10fc2:	f003 0301 	and.w	r3, r3, #1
   10fc6:	2b00      	cmp	r3, #0
   10fc8:	d106      	bne.n	10fd8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_75+0x3c>
   10fca:	4a05      	ldr	r2, [pc, #20]	; (10fe0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_75+0x44>)
   10fcc:	9b01      	ldr	r3, [sp, #4]
   10fce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10fd2:	2b00      	cmp	r3, #0
   10fd4:	d100      	bne.n	10fd8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_75+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   10fd6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   10fd8:	bf00      	nop
   10fda:	b003      	add	sp, #12
   10fdc:	f85d fb04 	ldr.w	pc, [sp], #4
   10fe0:	1fff92ac 	.word	0x1fff92ac
   10fe4:	1fff92a8 	.word	0x1fff92a8

00010fe8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_76>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_76(void)
{
   10fe8:	b500      	push	{lr}
   10fea:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   10fec:	f7ef fdd4 	bl	b98 <Sys_GetCoreID>
   10ff0:	4603      	mov	r3, r0
   10ff2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_76[u32CoreId])
   10ff4:	4a10      	ldr	r2, [pc, #64]	; (11038 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_76+0x50>)
   10ff6:	9b01      	ldr	r3, [sp, #4]
   10ff8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   10ffc:	2b00      	cmp	r3, #0
   10ffe:	d10d      	bne.n	1101c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_76+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11000:	f7ef fcbc 	bl	97c <Adc_schm_read_msr>
   11004:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   11006:	9b00      	ldr	r3, [sp, #0]
   11008:	f003 0301 	and.w	r3, r3, #1
   1100c:	2b00      	cmp	r3, #0
   1100e:	d100      	bne.n	11012 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_76+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11010:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_76[u32CoreId] = msr;
   11012:	490a      	ldr	r1, [pc, #40]	; (1103c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_76+0x54>)
   11014:	9b01      	ldr	r3, [sp, #4]
   11016:	9a00      	ldr	r2, [sp, #0]
   11018:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_76[u32CoreId]++;
   1101c:	4a06      	ldr	r2, [pc, #24]	; (11038 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_76+0x50>)
   1101e:	9b01      	ldr	r3, [sp, #4]
   11020:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11024:	1c5a      	adds	r2, r3, #1
   11026:	4904      	ldr	r1, [pc, #16]	; (11038 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_76+0x50>)
   11028:	9b01      	ldr	r3, [sp, #4]
   1102a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1102e:	bf00      	nop
   11030:	b003      	add	sp, #12
   11032:	f85d fb04 	ldr.w	pc, [sp], #4
   11036:	bf00      	nop
   11038:	1fff92b4 	.word	0x1fff92b4
   1103c:	1fff92b0 	.word	0x1fff92b0

00011040 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_76>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_76(void)
{
   11040:	b500      	push	{lr}
   11042:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11044:	f7ef fda8 	bl	b98 <Sys_GetCoreID>
   11048:	4603      	mov	r3, r0
   1104a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_76[u32CoreId]--;
   1104c:	4a0d      	ldr	r2, [pc, #52]	; (11084 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_76+0x44>)
   1104e:	9b01      	ldr	r3, [sp, #4]
   11050:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11054:	1e5a      	subs	r2, r3, #1
   11056:	490b      	ldr	r1, [pc, #44]	; (11084 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_76+0x44>)
   11058:	9b01      	ldr	r3, [sp, #4]
   1105a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_76[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_76[u32CoreId]))         /*if interrupts were enabled*/
   1105e:	4a0a      	ldr	r2, [pc, #40]	; (11088 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_76+0x48>)
   11060:	9b01      	ldr	r3, [sp, #4]
   11062:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11066:	f003 0301 	and.w	r3, r3, #1
   1106a:	2b00      	cmp	r3, #0
   1106c:	d106      	bne.n	1107c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_76+0x3c>
   1106e:	4a05      	ldr	r2, [pc, #20]	; (11084 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_76+0x44>)
   11070:	9b01      	ldr	r3, [sp, #4]
   11072:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11076:	2b00      	cmp	r3, #0
   11078:	d100      	bne.n	1107c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_76+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1107a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   1107c:	bf00      	nop
   1107e:	b003      	add	sp, #12
   11080:	f85d fb04 	ldr.w	pc, [sp], #4
   11084:	1fff92b4 	.word	0x1fff92b4
   11088:	1fff92b0 	.word	0x1fff92b0

0001108c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_77>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_77(void)
{
   1108c:	b500      	push	{lr}
   1108e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11090:	f7ef fd82 	bl	b98 <Sys_GetCoreID>
   11094:	4603      	mov	r3, r0
   11096:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_77[u32CoreId])
   11098:	4a10      	ldr	r2, [pc, #64]	; (110dc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_77+0x50>)
   1109a:	9b01      	ldr	r3, [sp, #4]
   1109c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   110a0:	2b00      	cmp	r3, #0
   110a2:	d10d      	bne.n	110c0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_77+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   110a4:	f7ef fc6a 	bl	97c <Adc_schm_read_msr>
   110a8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   110aa:	9b00      	ldr	r3, [sp, #0]
   110ac:	f003 0301 	and.w	r3, r3, #1
   110b0:	2b00      	cmp	r3, #0
   110b2:	d100      	bne.n	110b6 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_77+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   110b4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_77[u32CoreId] = msr;
   110b6:	490a      	ldr	r1, [pc, #40]	; (110e0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_77+0x54>)
   110b8:	9b01      	ldr	r3, [sp, #4]
   110ba:	9a00      	ldr	r2, [sp, #0]
   110bc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_77[u32CoreId]++;
   110c0:	4a06      	ldr	r2, [pc, #24]	; (110dc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_77+0x50>)
   110c2:	9b01      	ldr	r3, [sp, #4]
   110c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   110c8:	1c5a      	adds	r2, r3, #1
   110ca:	4904      	ldr	r1, [pc, #16]	; (110dc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_77+0x50>)
   110cc:	9b01      	ldr	r3, [sp, #4]
   110ce:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   110d2:	bf00      	nop
   110d4:	b003      	add	sp, #12
   110d6:	f85d fb04 	ldr.w	pc, [sp], #4
   110da:	bf00      	nop
   110dc:	1fff92bc 	.word	0x1fff92bc
   110e0:	1fff92b8 	.word	0x1fff92b8

000110e4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_77>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_77(void)
{
   110e4:	b500      	push	{lr}
   110e6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   110e8:	f7ef fd56 	bl	b98 <Sys_GetCoreID>
   110ec:	4603      	mov	r3, r0
   110ee:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_77[u32CoreId]--;
   110f0:	4a0d      	ldr	r2, [pc, #52]	; (11128 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_77+0x44>)
   110f2:	9b01      	ldr	r3, [sp, #4]
   110f4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   110f8:	1e5a      	subs	r2, r3, #1
   110fa:	490b      	ldr	r1, [pc, #44]	; (11128 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_77+0x44>)
   110fc:	9b01      	ldr	r3, [sp, #4]
   110fe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_77[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_77[u32CoreId]))         /*if interrupts were enabled*/
   11102:	4a0a      	ldr	r2, [pc, #40]	; (1112c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_77+0x48>)
   11104:	9b01      	ldr	r3, [sp, #4]
   11106:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1110a:	f003 0301 	and.w	r3, r3, #1
   1110e:	2b00      	cmp	r3, #0
   11110:	d106      	bne.n	11120 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_77+0x3c>
   11112:	4a05      	ldr	r2, [pc, #20]	; (11128 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_77+0x44>)
   11114:	9b01      	ldr	r3, [sp, #4]
   11116:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1111a:	2b00      	cmp	r3, #0
   1111c:	d100      	bne.n	11120 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_77+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1111e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11120:	bf00      	nop
   11122:	b003      	add	sp, #12
   11124:	f85d fb04 	ldr.w	pc, [sp], #4
   11128:	1fff92bc 	.word	0x1fff92bc
   1112c:	1fff92b8 	.word	0x1fff92b8

00011130 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_78>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_78(void)
{
   11130:	b500      	push	{lr}
   11132:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11134:	f7ef fd30 	bl	b98 <Sys_GetCoreID>
   11138:	4603      	mov	r3, r0
   1113a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_78[u32CoreId])
   1113c:	4a10      	ldr	r2, [pc, #64]	; (11180 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_78+0x50>)
   1113e:	9b01      	ldr	r3, [sp, #4]
   11140:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11144:	2b00      	cmp	r3, #0
   11146:	d10d      	bne.n	11164 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_78+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11148:	f7ef fc18 	bl	97c <Adc_schm_read_msr>
   1114c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1114e:	9b00      	ldr	r3, [sp, #0]
   11150:	f003 0301 	and.w	r3, r3, #1
   11154:	2b00      	cmp	r3, #0
   11156:	d100      	bne.n	1115a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_78+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11158:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_78[u32CoreId] = msr;
   1115a:	490a      	ldr	r1, [pc, #40]	; (11184 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_78+0x54>)
   1115c:	9b01      	ldr	r3, [sp, #4]
   1115e:	9a00      	ldr	r2, [sp, #0]
   11160:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_78[u32CoreId]++;
   11164:	4a06      	ldr	r2, [pc, #24]	; (11180 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_78+0x50>)
   11166:	9b01      	ldr	r3, [sp, #4]
   11168:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1116c:	1c5a      	adds	r2, r3, #1
   1116e:	4904      	ldr	r1, [pc, #16]	; (11180 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_78+0x50>)
   11170:	9b01      	ldr	r3, [sp, #4]
   11172:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11176:	bf00      	nop
   11178:	b003      	add	sp, #12
   1117a:	f85d fb04 	ldr.w	pc, [sp], #4
   1117e:	bf00      	nop
   11180:	1fff92c4 	.word	0x1fff92c4
   11184:	1fff92c0 	.word	0x1fff92c0

00011188 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_78>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_78(void)
{
   11188:	b500      	push	{lr}
   1118a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1118c:	f7ef fd04 	bl	b98 <Sys_GetCoreID>
   11190:	4603      	mov	r3, r0
   11192:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_78[u32CoreId]--;
   11194:	4a0d      	ldr	r2, [pc, #52]	; (111cc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_78+0x44>)
   11196:	9b01      	ldr	r3, [sp, #4]
   11198:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1119c:	1e5a      	subs	r2, r3, #1
   1119e:	490b      	ldr	r1, [pc, #44]	; (111cc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_78+0x44>)
   111a0:	9b01      	ldr	r3, [sp, #4]
   111a2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_78[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_78[u32CoreId]))         /*if interrupts were enabled*/
   111a6:	4a0a      	ldr	r2, [pc, #40]	; (111d0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_78+0x48>)
   111a8:	9b01      	ldr	r3, [sp, #4]
   111aa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   111ae:	f003 0301 	and.w	r3, r3, #1
   111b2:	2b00      	cmp	r3, #0
   111b4:	d106      	bne.n	111c4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_78+0x3c>
   111b6:	4a05      	ldr	r2, [pc, #20]	; (111cc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_78+0x44>)
   111b8:	9b01      	ldr	r3, [sp, #4]
   111ba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   111be:	2b00      	cmp	r3, #0
   111c0:	d100      	bne.n	111c4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_78+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   111c2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   111c4:	bf00      	nop
   111c6:	b003      	add	sp, #12
   111c8:	f85d fb04 	ldr.w	pc, [sp], #4
   111cc:	1fff92c4 	.word	0x1fff92c4
   111d0:	1fff92c0 	.word	0x1fff92c0

000111d4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_79>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_79(void)
{
   111d4:	b500      	push	{lr}
   111d6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   111d8:	f7ef fcde 	bl	b98 <Sys_GetCoreID>
   111dc:	4603      	mov	r3, r0
   111de:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_79[u32CoreId])
   111e0:	4a10      	ldr	r2, [pc, #64]	; (11224 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_79+0x50>)
   111e2:	9b01      	ldr	r3, [sp, #4]
   111e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   111e8:	2b00      	cmp	r3, #0
   111ea:	d10d      	bne.n	11208 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_79+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   111ec:	f7ef fbc6 	bl	97c <Adc_schm_read_msr>
   111f0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   111f2:	9b00      	ldr	r3, [sp, #0]
   111f4:	f003 0301 	and.w	r3, r3, #1
   111f8:	2b00      	cmp	r3, #0
   111fa:	d100      	bne.n	111fe <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_79+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   111fc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_79[u32CoreId] = msr;
   111fe:	490a      	ldr	r1, [pc, #40]	; (11228 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_79+0x54>)
   11200:	9b01      	ldr	r3, [sp, #4]
   11202:	9a00      	ldr	r2, [sp, #0]
   11204:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_79[u32CoreId]++;
   11208:	4a06      	ldr	r2, [pc, #24]	; (11224 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_79+0x50>)
   1120a:	9b01      	ldr	r3, [sp, #4]
   1120c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11210:	1c5a      	adds	r2, r3, #1
   11212:	4904      	ldr	r1, [pc, #16]	; (11224 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_79+0x50>)
   11214:	9b01      	ldr	r3, [sp, #4]
   11216:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1121a:	bf00      	nop
   1121c:	b003      	add	sp, #12
   1121e:	f85d fb04 	ldr.w	pc, [sp], #4
   11222:	bf00      	nop
   11224:	1fff92cc 	.word	0x1fff92cc
   11228:	1fff92c8 	.word	0x1fff92c8

0001122c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_79>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_79(void)
{
   1122c:	b500      	push	{lr}
   1122e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11230:	f7ef fcb2 	bl	b98 <Sys_GetCoreID>
   11234:	4603      	mov	r3, r0
   11236:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_79[u32CoreId]--;
   11238:	4a0d      	ldr	r2, [pc, #52]	; (11270 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_79+0x44>)
   1123a:	9b01      	ldr	r3, [sp, #4]
   1123c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11240:	1e5a      	subs	r2, r3, #1
   11242:	490b      	ldr	r1, [pc, #44]	; (11270 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_79+0x44>)
   11244:	9b01      	ldr	r3, [sp, #4]
   11246:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_79[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_79[u32CoreId]))         /*if interrupts were enabled*/
   1124a:	4a0a      	ldr	r2, [pc, #40]	; (11274 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_79+0x48>)
   1124c:	9b01      	ldr	r3, [sp, #4]
   1124e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11252:	f003 0301 	and.w	r3, r3, #1
   11256:	2b00      	cmp	r3, #0
   11258:	d106      	bne.n	11268 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_79+0x3c>
   1125a:	4a05      	ldr	r2, [pc, #20]	; (11270 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_79+0x44>)
   1125c:	9b01      	ldr	r3, [sp, #4]
   1125e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11262:	2b00      	cmp	r3, #0
   11264:	d100      	bne.n	11268 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_79+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   11266:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11268:	bf00      	nop
   1126a:	b003      	add	sp, #12
   1126c:	f85d fb04 	ldr.w	pc, [sp], #4
   11270:	1fff92cc 	.word	0x1fff92cc
   11274:	1fff92c8 	.word	0x1fff92c8

00011278 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_80>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_80(void)
{
   11278:	b500      	push	{lr}
   1127a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1127c:	f7ef fc8c 	bl	b98 <Sys_GetCoreID>
   11280:	4603      	mov	r3, r0
   11282:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_80[u32CoreId])
   11284:	4a10      	ldr	r2, [pc, #64]	; (112c8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_80+0x50>)
   11286:	9b01      	ldr	r3, [sp, #4]
   11288:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1128c:	2b00      	cmp	r3, #0
   1128e:	d10d      	bne.n	112ac <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_80+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11290:	f7ef fb74 	bl	97c <Adc_schm_read_msr>
   11294:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   11296:	9b00      	ldr	r3, [sp, #0]
   11298:	f003 0301 	and.w	r3, r3, #1
   1129c:	2b00      	cmp	r3, #0
   1129e:	d100      	bne.n	112a2 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_80+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   112a0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_80[u32CoreId] = msr;
   112a2:	490a      	ldr	r1, [pc, #40]	; (112cc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_80+0x54>)
   112a4:	9b01      	ldr	r3, [sp, #4]
   112a6:	9a00      	ldr	r2, [sp, #0]
   112a8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_80[u32CoreId]++;
   112ac:	4a06      	ldr	r2, [pc, #24]	; (112c8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_80+0x50>)
   112ae:	9b01      	ldr	r3, [sp, #4]
   112b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   112b4:	1c5a      	adds	r2, r3, #1
   112b6:	4904      	ldr	r1, [pc, #16]	; (112c8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_80+0x50>)
   112b8:	9b01      	ldr	r3, [sp, #4]
   112ba:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   112be:	bf00      	nop
   112c0:	b003      	add	sp, #12
   112c2:	f85d fb04 	ldr.w	pc, [sp], #4
   112c6:	bf00      	nop
   112c8:	1fff92d4 	.word	0x1fff92d4
   112cc:	1fff92d0 	.word	0x1fff92d0

000112d0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_80>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_80(void)
{
   112d0:	b500      	push	{lr}
   112d2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   112d4:	f7ef fc60 	bl	b98 <Sys_GetCoreID>
   112d8:	4603      	mov	r3, r0
   112da:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_80[u32CoreId]--;
   112dc:	4a0d      	ldr	r2, [pc, #52]	; (11314 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_80+0x44>)
   112de:	9b01      	ldr	r3, [sp, #4]
   112e0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   112e4:	1e5a      	subs	r2, r3, #1
   112e6:	490b      	ldr	r1, [pc, #44]	; (11314 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_80+0x44>)
   112e8:	9b01      	ldr	r3, [sp, #4]
   112ea:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_80[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_80[u32CoreId]))         /*if interrupts were enabled*/
   112ee:	4a0a      	ldr	r2, [pc, #40]	; (11318 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_80+0x48>)
   112f0:	9b01      	ldr	r3, [sp, #4]
   112f2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   112f6:	f003 0301 	and.w	r3, r3, #1
   112fa:	2b00      	cmp	r3, #0
   112fc:	d106      	bne.n	1130c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_80+0x3c>
   112fe:	4a05      	ldr	r2, [pc, #20]	; (11314 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_80+0x44>)
   11300:	9b01      	ldr	r3, [sp, #4]
   11302:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11306:	2b00      	cmp	r3, #0
   11308:	d100      	bne.n	1130c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_80+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1130a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   1130c:	bf00      	nop
   1130e:	b003      	add	sp, #12
   11310:	f85d fb04 	ldr.w	pc, [sp], #4
   11314:	1fff92d4 	.word	0x1fff92d4
   11318:	1fff92d0 	.word	0x1fff92d0

0001131c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_81>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_81(void)
{
   1131c:	b500      	push	{lr}
   1131e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11320:	f7ef fc3a 	bl	b98 <Sys_GetCoreID>
   11324:	4603      	mov	r3, r0
   11326:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_81[u32CoreId])
   11328:	4a10      	ldr	r2, [pc, #64]	; (1136c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_81+0x50>)
   1132a:	9b01      	ldr	r3, [sp, #4]
   1132c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11330:	2b00      	cmp	r3, #0
   11332:	d10d      	bne.n	11350 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_81+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11334:	f7ef fb22 	bl	97c <Adc_schm_read_msr>
   11338:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1133a:	9b00      	ldr	r3, [sp, #0]
   1133c:	f003 0301 	and.w	r3, r3, #1
   11340:	2b00      	cmp	r3, #0
   11342:	d100      	bne.n	11346 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_81+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11344:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_81[u32CoreId] = msr;
   11346:	490a      	ldr	r1, [pc, #40]	; (11370 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_81+0x54>)
   11348:	9b01      	ldr	r3, [sp, #4]
   1134a:	9a00      	ldr	r2, [sp, #0]
   1134c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_81[u32CoreId]++;
   11350:	4a06      	ldr	r2, [pc, #24]	; (1136c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_81+0x50>)
   11352:	9b01      	ldr	r3, [sp, #4]
   11354:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11358:	1c5a      	adds	r2, r3, #1
   1135a:	4904      	ldr	r1, [pc, #16]	; (1136c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_81+0x50>)
   1135c:	9b01      	ldr	r3, [sp, #4]
   1135e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11362:	bf00      	nop
   11364:	b003      	add	sp, #12
   11366:	f85d fb04 	ldr.w	pc, [sp], #4
   1136a:	bf00      	nop
   1136c:	1fff92dc 	.word	0x1fff92dc
   11370:	1fff92d8 	.word	0x1fff92d8

00011374 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_81>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_81(void)
{
   11374:	b500      	push	{lr}
   11376:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11378:	f7ef fc0e 	bl	b98 <Sys_GetCoreID>
   1137c:	4603      	mov	r3, r0
   1137e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_81[u32CoreId]--;
   11380:	4a0d      	ldr	r2, [pc, #52]	; (113b8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_81+0x44>)
   11382:	9b01      	ldr	r3, [sp, #4]
   11384:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11388:	1e5a      	subs	r2, r3, #1
   1138a:	490b      	ldr	r1, [pc, #44]	; (113b8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_81+0x44>)
   1138c:	9b01      	ldr	r3, [sp, #4]
   1138e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_81[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_81[u32CoreId]))         /*if interrupts were enabled*/
   11392:	4a0a      	ldr	r2, [pc, #40]	; (113bc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_81+0x48>)
   11394:	9b01      	ldr	r3, [sp, #4]
   11396:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1139a:	f003 0301 	and.w	r3, r3, #1
   1139e:	2b00      	cmp	r3, #0
   113a0:	d106      	bne.n	113b0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_81+0x3c>
   113a2:	4a05      	ldr	r2, [pc, #20]	; (113b8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_81+0x44>)
   113a4:	9b01      	ldr	r3, [sp, #4]
   113a6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   113aa:	2b00      	cmp	r3, #0
   113ac:	d100      	bne.n	113b0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_81+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   113ae:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   113b0:	bf00      	nop
   113b2:	b003      	add	sp, #12
   113b4:	f85d fb04 	ldr.w	pc, [sp], #4
   113b8:	1fff92dc 	.word	0x1fff92dc
   113bc:	1fff92d8 	.word	0x1fff92d8

000113c0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_82>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_82(void)
{
   113c0:	b500      	push	{lr}
   113c2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   113c4:	f7ef fbe8 	bl	b98 <Sys_GetCoreID>
   113c8:	4603      	mov	r3, r0
   113ca:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_82[u32CoreId])
   113cc:	4a10      	ldr	r2, [pc, #64]	; (11410 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_82+0x50>)
   113ce:	9b01      	ldr	r3, [sp, #4]
   113d0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   113d4:	2b00      	cmp	r3, #0
   113d6:	d10d      	bne.n	113f4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_82+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   113d8:	f7ef fad0 	bl	97c <Adc_schm_read_msr>
   113dc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   113de:	9b00      	ldr	r3, [sp, #0]
   113e0:	f003 0301 	and.w	r3, r3, #1
   113e4:	2b00      	cmp	r3, #0
   113e6:	d100      	bne.n	113ea <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_82+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   113e8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_82[u32CoreId] = msr;
   113ea:	490a      	ldr	r1, [pc, #40]	; (11414 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_82+0x54>)
   113ec:	9b01      	ldr	r3, [sp, #4]
   113ee:	9a00      	ldr	r2, [sp, #0]
   113f0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_82[u32CoreId]++;
   113f4:	4a06      	ldr	r2, [pc, #24]	; (11410 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_82+0x50>)
   113f6:	9b01      	ldr	r3, [sp, #4]
   113f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   113fc:	1c5a      	adds	r2, r3, #1
   113fe:	4904      	ldr	r1, [pc, #16]	; (11410 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_82+0x50>)
   11400:	9b01      	ldr	r3, [sp, #4]
   11402:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11406:	bf00      	nop
   11408:	b003      	add	sp, #12
   1140a:	f85d fb04 	ldr.w	pc, [sp], #4
   1140e:	bf00      	nop
   11410:	1fff92e4 	.word	0x1fff92e4
   11414:	1fff92e0 	.word	0x1fff92e0

00011418 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_82>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_82(void)
{
   11418:	b500      	push	{lr}
   1141a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1141c:	f7ef fbbc 	bl	b98 <Sys_GetCoreID>
   11420:	4603      	mov	r3, r0
   11422:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_82[u32CoreId]--;
   11424:	4a0d      	ldr	r2, [pc, #52]	; (1145c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_82+0x44>)
   11426:	9b01      	ldr	r3, [sp, #4]
   11428:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1142c:	1e5a      	subs	r2, r3, #1
   1142e:	490b      	ldr	r1, [pc, #44]	; (1145c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_82+0x44>)
   11430:	9b01      	ldr	r3, [sp, #4]
   11432:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_82[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_82[u32CoreId]))         /*if interrupts were enabled*/
   11436:	4a0a      	ldr	r2, [pc, #40]	; (11460 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_82+0x48>)
   11438:	9b01      	ldr	r3, [sp, #4]
   1143a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1143e:	f003 0301 	and.w	r3, r3, #1
   11442:	2b00      	cmp	r3, #0
   11444:	d106      	bne.n	11454 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_82+0x3c>
   11446:	4a05      	ldr	r2, [pc, #20]	; (1145c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_82+0x44>)
   11448:	9b01      	ldr	r3, [sp, #4]
   1144a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1144e:	2b00      	cmp	r3, #0
   11450:	d100      	bne.n	11454 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_82+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   11452:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11454:	bf00      	nop
   11456:	b003      	add	sp, #12
   11458:	f85d fb04 	ldr.w	pc, [sp], #4
   1145c:	1fff92e4 	.word	0x1fff92e4
   11460:	1fff92e0 	.word	0x1fff92e0

00011464 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_83>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_83(void)
{
   11464:	b500      	push	{lr}
   11466:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11468:	f7ef fb96 	bl	b98 <Sys_GetCoreID>
   1146c:	4603      	mov	r3, r0
   1146e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_83[u32CoreId])
   11470:	4a10      	ldr	r2, [pc, #64]	; (114b4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_83+0x50>)
   11472:	9b01      	ldr	r3, [sp, #4]
   11474:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11478:	2b00      	cmp	r3, #0
   1147a:	d10d      	bne.n	11498 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_83+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   1147c:	f7ef fa7e 	bl	97c <Adc_schm_read_msr>
   11480:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   11482:	9b00      	ldr	r3, [sp, #0]
   11484:	f003 0301 	and.w	r3, r3, #1
   11488:	2b00      	cmp	r3, #0
   1148a:	d100      	bne.n	1148e <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_83+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   1148c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_83[u32CoreId] = msr;
   1148e:	490a      	ldr	r1, [pc, #40]	; (114b8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_83+0x54>)
   11490:	9b01      	ldr	r3, [sp, #4]
   11492:	9a00      	ldr	r2, [sp, #0]
   11494:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_83[u32CoreId]++;
   11498:	4a06      	ldr	r2, [pc, #24]	; (114b4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_83+0x50>)
   1149a:	9b01      	ldr	r3, [sp, #4]
   1149c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   114a0:	1c5a      	adds	r2, r3, #1
   114a2:	4904      	ldr	r1, [pc, #16]	; (114b4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_83+0x50>)
   114a4:	9b01      	ldr	r3, [sp, #4]
   114a6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   114aa:	bf00      	nop
   114ac:	b003      	add	sp, #12
   114ae:	f85d fb04 	ldr.w	pc, [sp], #4
   114b2:	bf00      	nop
   114b4:	1fff92ec 	.word	0x1fff92ec
   114b8:	1fff92e8 	.word	0x1fff92e8

000114bc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_83>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_83(void)
{
   114bc:	b500      	push	{lr}
   114be:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   114c0:	f7ef fb6a 	bl	b98 <Sys_GetCoreID>
   114c4:	4603      	mov	r3, r0
   114c6:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_83[u32CoreId]--;
   114c8:	4a0d      	ldr	r2, [pc, #52]	; (11500 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_83+0x44>)
   114ca:	9b01      	ldr	r3, [sp, #4]
   114cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   114d0:	1e5a      	subs	r2, r3, #1
   114d2:	490b      	ldr	r1, [pc, #44]	; (11500 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_83+0x44>)
   114d4:	9b01      	ldr	r3, [sp, #4]
   114d6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_83[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_83[u32CoreId]))         /*if interrupts were enabled*/
   114da:	4a0a      	ldr	r2, [pc, #40]	; (11504 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_83+0x48>)
   114dc:	9b01      	ldr	r3, [sp, #4]
   114de:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   114e2:	f003 0301 	and.w	r3, r3, #1
   114e6:	2b00      	cmp	r3, #0
   114e8:	d106      	bne.n	114f8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_83+0x3c>
   114ea:	4a05      	ldr	r2, [pc, #20]	; (11500 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_83+0x44>)
   114ec:	9b01      	ldr	r3, [sp, #4]
   114ee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   114f2:	2b00      	cmp	r3, #0
   114f4:	d100      	bne.n	114f8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_83+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   114f6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   114f8:	bf00      	nop
   114fa:	b003      	add	sp, #12
   114fc:	f85d fb04 	ldr.w	pc, [sp], #4
   11500:	1fff92ec 	.word	0x1fff92ec
   11504:	1fff92e8 	.word	0x1fff92e8

00011508 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_84>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_84(void)
{
   11508:	b500      	push	{lr}
   1150a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1150c:	f7ef fb44 	bl	b98 <Sys_GetCoreID>
   11510:	4603      	mov	r3, r0
   11512:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_84[u32CoreId])
   11514:	4a10      	ldr	r2, [pc, #64]	; (11558 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_84+0x50>)
   11516:	9b01      	ldr	r3, [sp, #4]
   11518:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1151c:	2b00      	cmp	r3, #0
   1151e:	d10d      	bne.n	1153c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_84+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11520:	f7ef fa2c 	bl	97c <Adc_schm_read_msr>
   11524:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   11526:	9b00      	ldr	r3, [sp, #0]
   11528:	f003 0301 	and.w	r3, r3, #1
   1152c:	2b00      	cmp	r3, #0
   1152e:	d100      	bne.n	11532 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_84+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11530:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_84[u32CoreId] = msr;
   11532:	490a      	ldr	r1, [pc, #40]	; (1155c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_84+0x54>)
   11534:	9b01      	ldr	r3, [sp, #4]
   11536:	9a00      	ldr	r2, [sp, #0]
   11538:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_84[u32CoreId]++;
   1153c:	4a06      	ldr	r2, [pc, #24]	; (11558 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_84+0x50>)
   1153e:	9b01      	ldr	r3, [sp, #4]
   11540:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11544:	1c5a      	adds	r2, r3, #1
   11546:	4904      	ldr	r1, [pc, #16]	; (11558 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_84+0x50>)
   11548:	9b01      	ldr	r3, [sp, #4]
   1154a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1154e:	bf00      	nop
   11550:	b003      	add	sp, #12
   11552:	f85d fb04 	ldr.w	pc, [sp], #4
   11556:	bf00      	nop
   11558:	1fff92f4 	.word	0x1fff92f4
   1155c:	1fff92f0 	.word	0x1fff92f0

00011560 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_84>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_84(void)
{
   11560:	b500      	push	{lr}
   11562:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11564:	f7ef fb18 	bl	b98 <Sys_GetCoreID>
   11568:	4603      	mov	r3, r0
   1156a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_84[u32CoreId]--;
   1156c:	4a0d      	ldr	r2, [pc, #52]	; (115a4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_84+0x44>)
   1156e:	9b01      	ldr	r3, [sp, #4]
   11570:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11574:	1e5a      	subs	r2, r3, #1
   11576:	490b      	ldr	r1, [pc, #44]	; (115a4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_84+0x44>)
   11578:	9b01      	ldr	r3, [sp, #4]
   1157a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_84[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_84[u32CoreId]))         /*if interrupts were enabled*/
   1157e:	4a0a      	ldr	r2, [pc, #40]	; (115a8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_84+0x48>)
   11580:	9b01      	ldr	r3, [sp, #4]
   11582:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11586:	f003 0301 	and.w	r3, r3, #1
   1158a:	2b00      	cmp	r3, #0
   1158c:	d106      	bne.n	1159c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_84+0x3c>
   1158e:	4a05      	ldr	r2, [pc, #20]	; (115a4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_84+0x44>)
   11590:	9b01      	ldr	r3, [sp, #4]
   11592:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11596:	2b00      	cmp	r3, #0
   11598:	d100      	bne.n	1159c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_84+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1159a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   1159c:	bf00      	nop
   1159e:	b003      	add	sp, #12
   115a0:	f85d fb04 	ldr.w	pc, [sp], #4
   115a4:	1fff92f4 	.word	0x1fff92f4
   115a8:	1fff92f0 	.word	0x1fff92f0

000115ac <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_85>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_85(void)
{
   115ac:	b500      	push	{lr}
   115ae:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   115b0:	f7ef faf2 	bl	b98 <Sys_GetCoreID>
   115b4:	4603      	mov	r3, r0
   115b6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_85[u32CoreId])
   115b8:	4a10      	ldr	r2, [pc, #64]	; (115fc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_85+0x50>)
   115ba:	9b01      	ldr	r3, [sp, #4]
   115bc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   115c0:	2b00      	cmp	r3, #0
   115c2:	d10d      	bne.n	115e0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_85+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   115c4:	f7ef f9da 	bl	97c <Adc_schm_read_msr>
   115c8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   115ca:	9b00      	ldr	r3, [sp, #0]
   115cc:	f003 0301 	and.w	r3, r3, #1
   115d0:	2b00      	cmp	r3, #0
   115d2:	d100      	bne.n	115d6 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_85+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   115d4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_85[u32CoreId] = msr;
   115d6:	490a      	ldr	r1, [pc, #40]	; (11600 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_85+0x54>)
   115d8:	9b01      	ldr	r3, [sp, #4]
   115da:	9a00      	ldr	r2, [sp, #0]
   115dc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_85[u32CoreId]++;
   115e0:	4a06      	ldr	r2, [pc, #24]	; (115fc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_85+0x50>)
   115e2:	9b01      	ldr	r3, [sp, #4]
   115e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   115e8:	1c5a      	adds	r2, r3, #1
   115ea:	4904      	ldr	r1, [pc, #16]	; (115fc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_85+0x50>)
   115ec:	9b01      	ldr	r3, [sp, #4]
   115ee:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   115f2:	bf00      	nop
   115f4:	b003      	add	sp, #12
   115f6:	f85d fb04 	ldr.w	pc, [sp], #4
   115fa:	bf00      	nop
   115fc:	1fff92fc 	.word	0x1fff92fc
   11600:	1fff92f8 	.word	0x1fff92f8

00011604 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_85>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_85(void)
{
   11604:	b500      	push	{lr}
   11606:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11608:	f7ef fac6 	bl	b98 <Sys_GetCoreID>
   1160c:	4603      	mov	r3, r0
   1160e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_85[u32CoreId]--;
   11610:	4a0d      	ldr	r2, [pc, #52]	; (11648 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_85+0x44>)
   11612:	9b01      	ldr	r3, [sp, #4]
   11614:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11618:	1e5a      	subs	r2, r3, #1
   1161a:	490b      	ldr	r1, [pc, #44]	; (11648 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_85+0x44>)
   1161c:	9b01      	ldr	r3, [sp, #4]
   1161e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_85[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_85[u32CoreId]))         /*if interrupts were enabled*/
   11622:	4a0a      	ldr	r2, [pc, #40]	; (1164c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_85+0x48>)
   11624:	9b01      	ldr	r3, [sp, #4]
   11626:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1162a:	f003 0301 	and.w	r3, r3, #1
   1162e:	2b00      	cmp	r3, #0
   11630:	d106      	bne.n	11640 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_85+0x3c>
   11632:	4a05      	ldr	r2, [pc, #20]	; (11648 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_85+0x44>)
   11634:	9b01      	ldr	r3, [sp, #4]
   11636:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1163a:	2b00      	cmp	r3, #0
   1163c:	d100      	bne.n	11640 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_85+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1163e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11640:	bf00      	nop
   11642:	b003      	add	sp, #12
   11644:	f85d fb04 	ldr.w	pc, [sp], #4
   11648:	1fff92fc 	.word	0x1fff92fc
   1164c:	1fff92f8 	.word	0x1fff92f8

00011650 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_86>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_86(void)
{
   11650:	b500      	push	{lr}
   11652:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11654:	f7ef faa0 	bl	b98 <Sys_GetCoreID>
   11658:	4603      	mov	r3, r0
   1165a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_86[u32CoreId])
   1165c:	4a10      	ldr	r2, [pc, #64]	; (116a0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_86+0x50>)
   1165e:	9b01      	ldr	r3, [sp, #4]
   11660:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11664:	2b00      	cmp	r3, #0
   11666:	d10d      	bne.n	11684 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_86+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11668:	f7ef f988 	bl	97c <Adc_schm_read_msr>
   1166c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1166e:	9b00      	ldr	r3, [sp, #0]
   11670:	f003 0301 	and.w	r3, r3, #1
   11674:	2b00      	cmp	r3, #0
   11676:	d100      	bne.n	1167a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_86+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11678:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_86[u32CoreId] = msr;
   1167a:	490a      	ldr	r1, [pc, #40]	; (116a4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_86+0x54>)
   1167c:	9b01      	ldr	r3, [sp, #4]
   1167e:	9a00      	ldr	r2, [sp, #0]
   11680:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_86[u32CoreId]++;
   11684:	4a06      	ldr	r2, [pc, #24]	; (116a0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_86+0x50>)
   11686:	9b01      	ldr	r3, [sp, #4]
   11688:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1168c:	1c5a      	adds	r2, r3, #1
   1168e:	4904      	ldr	r1, [pc, #16]	; (116a0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_86+0x50>)
   11690:	9b01      	ldr	r3, [sp, #4]
   11692:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11696:	bf00      	nop
   11698:	b003      	add	sp, #12
   1169a:	f85d fb04 	ldr.w	pc, [sp], #4
   1169e:	bf00      	nop
   116a0:	1fff9304 	.word	0x1fff9304
   116a4:	1fff9300 	.word	0x1fff9300

000116a8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_86>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_86(void)
{
   116a8:	b500      	push	{lr}
   116aa:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   116ac:	f7ef fa74 	bl	b98 <Sys_GetCoreID>
   116b0:	4603      	mov	r3, r0
   116b2:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_86[u32CoreId]--;
   116b4:	4a0d      	ldr	r2, [pc, #52]	; (116ec <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_86+0x44>)
   116b6:	9b01      	ldr	r3, [sp, #4]
   116b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   116bc:	1e5a      	subs	r2, r3, #1
   116be:	490b      	ldr	r1, [pc, #44]	; (116ec <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_86+0x44>)
   116c0:	9b01      	ldr	r3, [sp, #4]
   116c2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_86[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_86[u32CoreId]))         /*if interrupts were enabled*/
   116c6:	4a0a      	ldr	r2, [pc, #40]	; (116f0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_86+0x48>)
   116c8:	9b01      	ldr	r3, [sp, #4]
   116ca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   116ce:	f003 0301 	and.w	r3, r3, #1
   116d2:	2b00      	cmp	r3, #0
   116d4:	d106      	bne.n	116e4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_86+0x3c>
   116d6:	4a05      	ldr	r2, [pc, #20]	; (116ec <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_86+0x44>)
   116d8:	9b01      	ldr	r3, [sp, #4]
   116da:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   116de:	2b00      	cmp	r3, #0
   116e0:	d100      	bne.n	116e4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_86+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   116e2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   116e4:	bf00      	nop
   116e6:	b003      	add	sp, #12
   116e8:	f85d fb04 	ldr.w	pc, [sp], #4
   116ec:	1fff9304 	.word	0x1fff9304
   116f0:	1fff9300 	.word	0x1fff9300

000116f4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_87>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_87(void)
{
   116f4:	b500      	push	{lr}
   116f6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   116f8:	f7ef fa4e 	bl	b98 <Sys_GetCoreID>
   116fc:	4603      	mov	r3, r0
   116fe:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_87[u32CoreId])
   11700:	4a10      	ldr	r2, [pc, #64]	; (11744 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_87+0x50>)
   11702:	9b01      	ldr	r3, [sp, #4]
   11704:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11708:	2b00      	cmp	r3, #0
   1170a:	d10d      	bne.n	11728 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_87+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   1170c:	f7ef f936 	bl	97c <Adc_schm_read_msr>
   11710:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   11712:	9b00      	ldr	r3, [sp, #0]
   11714:	f003 0301 	and.w	r3, r3, #1
   11718:	2b00      	cmp	r3, #0
   1171a:	d100      	bne.n	1171e <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_87+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   1171c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_87[u32CoreId] = msr;
   1171e:	490a      	ldr	r1, [pc, #40]	; (11748 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_87+0x54>)
   11720:	9b01      	ldr	r3, [sp, #4]
   11722:	9a00      	ldr	r2, [sp, #0]
   11724:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_87[u32CoreId]++;
   11728:	4a06      	ldr	r2, [pc, #24]	; (11744 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_87+0x50>)
   1172a:	9b01      	ldr	r3, [sp, #4]
   1172c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11730:	1c5a      	adds	r2, r3, #1
   11732:	4904      	ldr	r1, [pc, #16]	; (11744 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_87+0x50>)
   11734:	9b01      	ldr	r3, [sp, #4]
   11736:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1173a:	bf00      	nop
   1173c:	b003      	add	sp, #12
   1173e:	f85d fb04 	ldr.w	pc, [sp], #4
   11742:	bf00      	nop
   11744:	1fff930c 	.word	0x1fff930c
   11748:	1fff9308 	.word	0x1fff9308

0001174c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_87>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_87(void)
{
   1174c:	b500      	push	{lr}
   1174e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11750:	f7ef fa22 	bl	b98 <Sys_GetCoreID>
   11754:	4603      	mov	r3, r0
   11756:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_87[u32CoreId]--;
   11758:	4a0d      	ldr	r2, [pc, #52]	; (11790 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_87+0x44>)
   1175a:	9b01      	ldr	r3, [sp, #4]
   1175c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11760:	1e5a      	subs	r2, r3, #1
   11762:	490b      	ldr	r1, [pc, #44]	; (11790 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_87+0x44>)
   11764:	9b01      	ldr	r3, [sp, #4]
   11766:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_87[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_87[u32CoreId]))         /*if interrupts were enabled*/
   1176a:	4a0a      	ldr	r2, [pc, #40]	; (11794 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_87+0x48>)
   1176c:	9b01      	ldr	r3, [sp, #4]
   1176e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11772:	f003 0301 	and.w	r3, r3, #1
   11776:	2b00      	cmp	r3, #0
   11778:	d106      	bne.n	11788 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_87+0x3c>
   1177a:	4a05      	ldr	r2, [pc, #20]	; (11790 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_87+0x44>)
   1177c:	9b01      	ldr	r3, [sp, #4]
   1177e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11782:	2b00      	cmp	r3, #0
   11784:	d100      	bne.n	11788 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_87+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   11786:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11788:	bf00      	nop
   1178a:	b003      	add	sp, #12
   1178c:	f85d fb04 	ldr.w	pc, [sp], #4
   11790:	1fff930c 	.word	0x1fff930c
   11794:	1fff9308 	.word	0x1fff9308

00011798 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_88>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_88(void)
{
   11798:	b500      	push	{lr}
   1179a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1179c:	f7ef f9fc 	bl	b98 <Sys_GetCoreID>
   117a0:	4603      	mov	r3, r0
   117a2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_88[u32CoreId])
   117a4:	4a10      	ldr	r2, [pc, #64]	; (117e8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_88+0x50>)
   117a6:	9b01      	ldr	r3, [sp, #4]
   117a8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   117ac:	2b00      	cmp	r3, #0
   117ae:	d10d      	bne.n	117cc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_88+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   117b0:	f7ef f8e4 	bl	97c <Adc_schm_read_msr>
   117b4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   117b6:	9b00      	ldr	r3, [sp, #0]
   117b8:	f003 0301 	and.w	r3, r3, #1
   117bc:	2b00      	cmp	r3, #0
   117be:	d100      	bne.n	117c2 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_88+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   117c0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_88[u32CoreId] = msr;
   117c2:	490a      	ldr	r1, [pc, #40]	; (117ec <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_88+0x54>)
   117c4:	9b01      	ldr	r3, [sp, #4]
   117c6:	9a00      	ldr	r2, [sp, #0]
   117c8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_88[u32CoreId]++;
   117cc:	4a06      	ldr	r2, [pc, #24]	; (117e8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_88+0x50>)
   117ce:	9b01      	ldr	r3, [sp, #4]
   117d0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   117d4:	1c5a      	adds	r2, r3, #1
   117d6:	4904      	ldr	r1, [pc, #16]	; (117e8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_88+0x50>)
   117d8:	9b01      	ldr	r3, [sp, #4]
   117da:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   117de:	bf00      	nop
   117e0:	b003      	add	sp, #12
   117e2:	f85d fb04 	ldr.w	pc, [sp], #4
   117e6:	bf00      	nop
   117e8:	1fff9314 	.word	0x1fff9314
   117ec:	1fff9310 	.word	0x1fff9310

000117f0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_88>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_88(void)
{
   117f0:	b500      	push	{lr}
   117f2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   117f4:	f7ef f9d0 	bl	b98 <Sys_GetCoreID>
   117f8:	4603      	mov	r3, r0
   117fa:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_88[u32CoreId]--;
   117fc:	4a0d      	ldr	r2, [pc, #52]	; (11834 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_88+0x44>)
   117fe:	9b01      	ldr	r3, [sp, #4]
   11800:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11804:	1e5a      	subs	r2, r3, #1
   11806:	490b      	ldr	r1, [pc, #44]	; (11834 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_88+0x44>)
   11808:	9b01      	ldr	r3, [sp, #4]
   1180a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_88[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_88[u32CoreId]))         /*if interrupts were enabled*/
   1180e:	4a0a      	ldr	r2, [pc, #40]	; (11838 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_88+0x48>)
   11810:	9b01      	ldr	r3, [sp, #4]
   11812:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11816:	f003 0301 	and.w	r3, r3, #1
   1181a:	2b00      	cmp	r3, #0
   1181c:	d106      	bne.n	1182c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_88+0x3c>
   1181e:	4a05      	ldr	r2, [pc, #20]	; (11834 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_88+0x44>)
   11820:	9b01      	ldr	r3, [sp, #4]
   11822:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11826:	2b00      	cmp	r3, #0
   11828:	d100      	bne.n	1182c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_88+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1182a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   1182c:	bf00      	nop
   1182e:	b003      	add	sp, #12
   11830:	f85d fb04 	ldr.w	pc, [sp], #4
   11834:	1fff9314 	.word	0x1fff9314
   11838:	1fff9310 	.word	0x1fff9310

0001183c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_89>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_89(void)
{
   1183c:	b500      	push	{lr}
   1183e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11840:	f7ef f9aa 	bl	b98 <Sys_GetCoreID>
   11844:	4603      	mov	r3, r0
   11846:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_89[u32CoreId])
   11848:	4a10      	ldr	r2, [pc, #64]	; (1188c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_89+0x50>)
   1184a:	9b01      	ldr	r3, [sp, #4]
   1184c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11850:	2b00      	cmp	r3, #0
   11852:	d10d      	bne.n	11870 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_89+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11854:	f7ef f892 	bl	97c <Adc_schm_read_msr>
   11858:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1185a:	9b00      	ldr	r3, [sp, #0]
   1185c:	f003 0301 	and.w	r3, r3, #1
   11860:	2b00      	cmp	r3, #0
   11862:	d100      	bne.n	11866 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_89+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11864:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_89[u32CoreId] = msr;
   11866:	490a      	ldr	r1, [pc, #40]	; (11890 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_89+0x54>)
   11868:	9b01      	ldr	r3, [sp, #4]
   1186a:	9a00      	ldr	r2, [sp, #0]
   1186c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_89[u32CoreId]++;
   11870:	4a06      	ldr	r2, [pc, #24]	; (1188c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_89+0x50>)
   11872:	9b01      	ldr	r3, [sp, #4]
   11874:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11878:	1c5a      	adds	r2, r3, #1
   1187a:	4904      	ldr	r1, [pc, #16]	; (1188c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_89+0x50>)
   1187c:	9b01      	ldr	r3, [sp, #4]
   1187e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11882:	bf00      	nop
   11884:	b003      	add	sp, #12
   11886:	f85d fb04 	ldr.w	pc, [sp], #4
   1188a:	bf00      	nop
   1188c:	1fff931c 	.word	0x1fff931c
   11890:	1fff9318 	.word	0x1fff9318

00011894 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_89>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_89(void)
{
   11894:	b500      	push	{lr}
   11896:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11898:	f7ef f97e 	bl	b98 <Sys_GetCoreID>
   1189c:	4603      	mov	r3, r0
   1189e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_89[u32CoreId]--;
   118a0:	4a0d      	ldr	r2, [pc, #52]	; (118d8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_89+0x44>)
   118a2:	9b01      	ldr	r3, [sp, #4]
   118a4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   118a8:	1e5a      	subs	r2, r3, #1
   118aa:	490b      	ldr	r1, [pc, #44]	; (118d8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_89+0x44>)
   118ac:	9b01      	ldr	r3, [sp, #4]
   118ae:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_89[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_89[u32CoreId]))         /*if interrupts were enabled*/
   118b2:	4a0a      	ldr	r2, [pc, #40]	; (118dc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_89+0x48>)
   118b4:	9b01      	ldr	r3, [sp, #4]
   118b6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   118ba:	f003 0301 	and.w	r3, r3, #1
   118be:	2b00      	cmp	r3, #0
   118c0:	d106      	bne.n	118d0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_89+0x3c>
   118c2:	4a05      	ldr	r2, [pc, #20]	; (118d8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_89+0x44>)
   118c4:	9b01      	ldr	r3, [sp, #4]
   118c6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   118ca:	2b00      	cmp	r3, #0
   118cc:	d100      	bne.n	118d0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_89+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   118ce:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   118d0:	bf00      	nop
   118d2:	b003      	add	sp, #12
   118d4:	f85d fb04 	ldr.w	pc, [sp], #4
   118d8:	1fff931c 	.word	0x1fff931c
   118dc:	1fff9318 	.word	0x1fff9318

000118e0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_90>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_90(void)
{
   118e0:	b500      	push	{lr}
   118e2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   118e4:	f7ef f958 	bl	b98 <Sys_GetCoreID>
   118e8:	4603      	mov	r3, r0
   118ea:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_90[u32CoreId])
   118ec:	4a10      	ldr	r2, [pc, #64]	; (11930 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_90+0x50>)
   118ee:	9b01      	ldr	r3, [sp, #4]
   118f0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   118f4:	2b00      	cmp	r3, #0
   118f6:	d10d      	bne.n	11914 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_90+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   118f8:	f7ef f840 	bl	97c <Adc_schm_read_msr>
   118fc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   118fe:	9b00      	ldr	r3, [sp, #0]
   11900:	f003 0301 	and.w	r3, r3, #1
   11904:	2b00      	cmp	r3, #0
   11906:	d100      	bne.n	1190a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_90+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11908:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_90[u32CoreId] = msr;
   1190a:	490a      	ldr	r1, [pc, #40]	; (11934 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_90+0x54>)
   1190c:	9b01      	ldr	r3, [sp, #4]
   1190e:	9a00      	ldr	r2, [sp, #0]
   11910:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_90[u32CoreId]++;
   11914:	4a06      	ldr	r2, [pc, #24]	; (11930 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_90+0x50>)
   11916:	9b01      	ldr	r3, [sp, #4]
   11918:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1191c:	1c5a      	adds	r2, r3, #1
   1191e:	4904      	ldr	r1, [pc, #16]	; (11930 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_90+0x50>)
   11920:	9b01      	ldr	r3, [sp, #4]
   11922:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11926:	bf00      	nop
   11928:	b003      	add	sp, #12
   1192a:	f85d fb04 	ldr.w	pc, [sp], #4
   1192e:	bf00      	nop
   11930:	1fff9324 	.word	0x1fff9324
   11934:	1fff9320 	.word	0x1fff9320

00011938 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_90>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_90(void)
{
   11938:	b500      	push	{lr}
   1193a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1193c:	f7ef f92c 	bl	b98 <Sys_GetCoreID>
   11940:	4603      	mov	r3, r0
   11942:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_90[u32CoreId]--;
   11944:	4a0d      	ldr	r2, [pc, #52]	; (1197c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_90+0x44>)
   11946:	9b01      	ldr	r3, [sp, #4]
   11948:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1194c:	1e5a      	subs	r2, r3, #1
   1194e:	490b      	ldr	r1, [pc, #44]	; (1197c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_90+0x44>)
   11950:	9b01      	ldr	r3, [sp, #4]
   11952:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_90[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_90[u32CoreId]))         /*if interrupts were enabled*/
   11956:	4a0a      	ldr	r2, [pc, #40]	; (11980 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_90+0x48>)
   11958:	9b01      	ldr	r3, [sp, #4]
   1195a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1195e:	f003 0301 	and.w	r3, r3, #1
   11962:	2b00      	cmp	r3, #0
   11964:	d106      	bne.n	11974 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_90+0x3c>
   11966:	4a05      	ldr	r2, [pc, #20]	; (1197c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_90+0x44>)
   11968:	9b01      	ldr	r3, [sp, #4]
   1196a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1196e:	2b00      	cmp	r3, #0
   11970:	d100      	bne.n	11974 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_90+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   11972:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11974:	bf00      	nop
   11976:	b003      	add	sp, #12
   11978:	f85d fb04 	ldr.w	pc, [sp], #4
   1197c:	1fff9324 	.word	0x1fff9324
   11980:	1fff9320 	.word	0x1fff9320

00011984 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_91>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_91(void)
{
   11984:	b500      	push	{lr}
   11986:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11988:	f7ef f906 	bl	b98 <Sys_GetCoreID>
   1198c:	4603      	mov	r3, r0
   1198e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_91[u32CoreId])
   11990:	4a10      	ldr	r2, [pc, #64]	; (119d4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_91+0x50>)
   11992:	9b01      	ldr	r3, [sp, #4]
   11994:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11998:	2b00      	cmp	r3, #0
   1199a:	d10d      	bne.n	119b8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_91+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   1199c:	f7ee ffee 	bl	97c <Adc_schm_read_msr>
   119a0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   119a2:	9b00      	ldr	r3, [sp, #0]
   119a4:	f003 0301 	and.w	r3, r3, #1
   119a8:	2b00      	cmp	r3, #0
   119aa:	d100      	bne.n	119ae <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_91+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   119ac:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_91[u32CoreId] = msr;
   119ae:	490a      	ldr	r1, [pc, #40]	; (119d8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_91+0x54>)
   119b0:	9b01      	ldr	r3, [sp, #4]
   119b2:	9a00      	ldr	r2, [sp, #0]
   119b4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_91[u32CoreId]++;
   119b8:	4a06      	ldr	r2, [pc, #24]	; (119d4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_91+0x50>)
   119ba:	9b01      	ldr	r3, [sp, #4]
   119bc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   119c0:	1c5a      	adds	r2, r3, #1
   119c2:	4904      	ldr	r1, [pc, #16]	; (119d4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_91+0x50>)
   119c4:	9b01      	ldr	r3, [sp, #4]
   119c6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   119ca:	bf00      	nop
   119cc:	b003      	add	sp, #12
   119ce:	f85d fb04 	ldr.w	pc, [sp], #4
   119d2:	bf00      	nop
   119d4:	1fff932c 	.word	0x1fff932c
   119d8:	1fff9328 	.word	0x1fff9328

000119dc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_91>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_91(void)
{
   119dc:	b500      	push	{lr}
   119de:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   119e0:	f7ef f8da 	bl	b98 <Sys_GetCoreID>
   119e4:	4603      	mov	r3, r0
   119e6:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_91[u32CoreId]--;
   119e8:	4a0d      	ldr	r2, [pc, #52]	; (11a20 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_91+0x44>)
   119ea:	9b01      	ldr	r3, [sp, #4]
   119ec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   119f0:	1e5a      	subs	r2, r3, #1
   119f2:	490b      	ldr	r1, [pc, #44]	; (11a20 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_91+0x44>)
   119f4:	9b01      	ldr	r3, [sp, #4]
   119f6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_91[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_91[u32CoreId]))         /*if interrupts were enabled*/
   119fa:	4a0a      	ldr	r2, [pc, #40]	; (11a24 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_91+0x48>)
   119fc:	9b01      	ldr	r3, [sp, #4]
   119fe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11a02:	f003 0301 	and.w	r3, r3, #1
   11a06:	2b00      	cmp	r3, #0
   11a08:	d106      	bne.n	11a18 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_91+0x3c>
   11a0a:	4a05      	ldr	r2, [pc, #20]	; (11a20 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_91+0x44>)
   11a0c:	9b01      	ldr	r3, [sp, #4]
   11a0e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11a12:	2b00      	cmp	r3, #0
   11a14:	d100      	bne.n	11a18 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_91+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   11a16:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11a18:	bf00      	nop
   11a1a:	b003      	add	sp, #12
   11a1c:	f85d fb04 	ldr.w	pc, [sp], #4
   11a20:	1fff932c 	.word	0x1fff932c
   11a24:	1fff9328 	.word	0x1fff9328

00011a28 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_92>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_92(void)
{
   11a28:	b500      	push	{lr}
   11a2a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11a2c:	f7ef f8b4 	bl	b98 <Sys_GetCoreID>
   11a30:	4603      	mov	r3, r0
   11a32:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_92[u32CoreId])
   11a34:	4a10      	ldr	r2, [pc, #64]	; (11a78 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_92+0x50>)
   11a36:	9b01      	ldr	r3, [sp, #4]
   11a38:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11a3c:	2b00      	cmp	r3, #0
   11a3e:	d10d      	bne.n	11a5c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_92+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11a40:	f7ee ff9c 	bl	97c <Adc_schm_read_msr>
   11a44:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   11a46:	9b00      	ldr	r3, [sp, #0]
   11a48:	f003 0301 	and.w	r3, r3, #1
   11a4c:	2b00      	cmp	r3, #0
   11a4e:	d100      	bne.n	11a52 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_92+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11a50:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_92[u32CoreId] = msr;
   11a52:	490a      	ldr	r1, [pc, #40]	; (11a7c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_92+0x54>)
   11a54:	9b01      	ldr	r3, [sp, #4]
   11a56:	9a00      	ldr	r2, [sp, #0]
   11a58:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_92[u32CoreId]++;
   11a5c:	4a06      	ldr	r2, [pc, #24]	; (11a78 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_92+0x50>)
   11a5e:	9b01      	ldr	r3, [sp, #4]
   11a60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11a64:	1c5a      	adds	r2, r3, #1
   11a66:	4904      	ldr	r1, [pc, #16]	; (11a78 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_92+0x50>)
   11a68:	9b01      	ldr	r3, [sp, #4]
   11a6a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11a6e:	bf00      	nop
   11a70:	b003      	add	sp, #12
   11a72:	f85d fb04 	ldr.w	pc, [sp], #4
   11a76:	bf00      	nop
   11a78:	1fff9334 	.word	0x1fff9334
   11a7c:	1fff9330 	.word	0x1fff9330

00011a80 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_92>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_92(void)
{
   11a80:	b500      	push	{lr}
   11a82:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11a84:	f7ef f888 	bl	b98 <Sys_GetCoreID>
   11a88:	4603      	mov	r3, r0
   11a8a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_92[u32CoreId]--;
   11a8c:	4a0d      	ldr	r2, [pc, #52]	; (11ac4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_92+0x44>)
   11a8e:	9b01      	ldr	r3, [sp, #4]
   11a90:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11a94:	1e5a      	subs	r2, r3, #1
   11a96:	490b      	ldr	r1, [pc, #44]	; (11ac4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_92+0x44>)
   11a98:	9b01      	ldr	r3, [sp, #4]
   11a9a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_92[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_92[u32CoreId]))         /*if interrupts were enabled*/
   11a9e:	4a0a      	ldr	r2, [pc, #40]	; (11ac8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_92+0x48>)
   11aa0:	9b01      	ldr	r3, [sp, #4]
   11aa2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11aa6:	f003 0301 	and.w	r3, r3, #1
   11aaa:	2b00      	cmp	r3, #0
   11aac:	d106      	bne.n	11abc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_92+0x3c>
   11aae:	4a05      	ldr	r2, [pc, #20]	; (11ac4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_92+0x44>)
   11ab0:	9b01      	ldr	r3, [sp, #4]
   11ab2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11ab6:	2b00      	cmp	r3, #0
   11ab8:	d100      	bne.n	11abc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_92+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   11aba:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11abc:	bf00      	nop
   11abe:	b003      	add	sp, #12
   11ac0:	f85d fb04 	ldr.w	pc, [sp], #4
   11ac4:	1fff9334 	.word	0x1fff9334
   11ac8:	1fff9330 	.word	0x1fff9330

00011acc <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_93>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_93(void)
{
   11acc:	b500      	push	{lr}
   11ace:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11ad0:	f7ef f862 	bl	b98 <Sys_GetCoreID>
   11ad4:	4603      	mov	r3, r0
   11ad6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_93[u32CoreId])
   11ad8:	4a10      	ldr	r2, [pc, #64]	; (11b1c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_93+0x50>)
   11ada:	9b01      	ldr	r3, [sp, #4]
   11adc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11ae0:	2b00      	cmp	r3, #0
   11ae2:	d10d      	bne.n	11b00 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_93+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11ae4:	f7ee ff4a 	bl	97c <Adc_schm_read_msr>
   11ae8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   11aea:	9b00      	ldr	r3, [sp, #0]
   11aec:	f003 0301 	and.w	r3, r3, #1
   11af0:	2b00      	cmp	r3, #0
   11af2:	d100      	bne.n	11af6 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_93+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11af4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_93[u32CoreId] = msr;
   11af6:	490a      	ldr	r1, [pc, #40]	; (11b20 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_93+0x54>)
   11af8:	9b01      	ldr	r3, [sp, #4]
   11afa:	9a00      	ldr	r2, [sp, #0]
   11afc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_93[u32CoreId]++;
   11b00:	4a06      	ldr	r2, [pc, #24]	; (11b1c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_93+0x50>)
   11b02:	9b01      	ldr	r3, [sp, #4]
   11b04:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11b08:	1c5a      	adds	r2, r3, #1
   11b0a:	4904      	ldr	r1, [pc, #16]	; (11b1c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_93+0x50>)
   11b0c:	9b01      	ldr	r3, [sp, #4]
   11b0e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11b12:	bf00      	nop
   11b14:	b003      	add	sp, #12
   11b16:	f85d fb04 	ldr.w	pc, [sp], #4
   11b1a:	bf00      	nop
   11b1c:	1fff933c 	.word	0x1fff933c
   11b20:	1fff9338 	.word	0x1fff9338

00011b24 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_93>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_93(void)
{
   11b24:	b500      	push	{lr}
   11b26:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11b28:	f7ef f836 	bl	b98 <Sys_GetCoreID>
   11b2c:	4603      	mov	r3, r0
   11b2e:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_93[u32CoreId]--;
   11b30:	4a0d      	ldr	r2, [pc, #52]	; (11b68 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_93+0x44>)
   11b32:	9b01      	ldr	r3, [sp, #4]
   11b34:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11b38:	1e5a      	subs	r2, r3, #1
   11b3a:	490b      	ldr	r1, [pc, #44]	; (11b68 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_93+0x44>)
   11b3c:	9b01      	ldr	r3, [sp, #4]
   11b3e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_93[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_93[u32CoreId]))         /*if interrupts were enabled*/
   11b42:	4a0a      	ldr	r2, [pc, #40]	; (11b6c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_93+0x48>)
   11b44:	9b01      	ldr	r3, [sp, #4]
   11b46:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11b4a:	f003 0301 	and.w	r3, r3, #1
   11b4e:	2b00      	cmp	r3, #0
   11b50:	d106      	bne.n	11b60 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_93+0x3c>
   11b52:	4a05      	ldr	r2, [pc, #20]	; (11b68 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_93+0x44>)
   11b54:	9b01      	ldr	r3, [sp, #4]
   11b56:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11b5a:	2b00      	cmp	r3, #0
   11b5c:	d100      	bne.n	11b60 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_93+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   11b5e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11b60:	bf00      	nop
   11b62:	b003      	add	sp, #12
   11b64:	f85d fb04 	ldr.w	pc, [sp], #4
   11b68:	1fff933c 	.word	0x1fff933c
   11b6c:	1fff9338 	.word	0x1fff9338

00011b70 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_94>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_94(void)
{
   11b70:	b500      	push	{lr}
   11b72:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11b74:	f7ef f810 	bl	b98 <Sys_GetCoreID>
   11b78:	4603      	mov	r3, r0
   11b7a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_94[u32CoreId])
   11b7c:	4a10      	ldr	r2, [pc, #64]	; (11bc0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_94+0x50>)
   11b7e:	9b01      	ldr	r3, [sp, #4]
   11b80:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11b84:	2b00      	cmp	r3, #0
   11b86:	d10d      	bne.n	11ba4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_94+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11b88:	f7ee fef8 	bl	97c <Adc_schm_read_msr>
   11b8c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   11b8e:	9b00      	ldr	r3, [sp, #0]
   11b90:	f003 0301 	and.w	r3, r3, #1
   11b94:	2b00      	cmp	r3, #0
   11b96:	d100      	bne.n	11b9a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_94+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11b98:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_94[u32CoreId] = msr;
   11b9a:	490a      	ldr	r1, [pc, #40]	; (11bc4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_94+0x54>)
   11b9c:	9b01      	ldr	r3, [sp, #4]
   11b9e:	9a00      	ldr	r2, [sp, #0]
   11ba0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_94[u32CoreId]++;
   11ba4:	4a06      	ldr	r2, [pc, #24]	; (11bc0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_94+0x50>)
   11ba6:	9b01      	ldr	r3, [sp, #4]
   11ba8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11bac:	1c5a      	adds	r2, r3, #1
   11bae:	4904      	ldr	r1, [pc, #16]	; (11bc0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_94+0x50>)
   11bb0:	9b01      	ldr	r3, [sp, #4]
   11bb2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11bb6:	bf00      	nop
   11bb8:	b003      	add	sp, #12
   11bba:	f85d fb04 	ldr.w	pc, [sp], #4
   11bbe:	bf00      	nop
   11bc0:	1fff9344 	.word	0x1fff9344
   11bc4:	1fff9340 	.word	0x1fff9340

00011bc8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_94>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_94(void)
{
   11bc8:	b500      	push	{lr}
   11bca:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11bcc:	f7ee ffe4 	bl	b98 <Sys_GetCoreID>
   11bd0:	4603      	mov	r3, r0
   11bd2:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_94[u32CoreId]--;
   11bd4:	4a0d      	ldr	r2, [pc, #52]	; (11c0c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_94+0x44>)
   11bd6:	9b01      	ldr	r3, [sp, #4]
   11bd8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11bdc:	1e5a      	subs	r2, r3, #1
   11bde:	490b      	ldr	r1, [pc, #44]	; (11c0c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_94+0x44>)
   11be0:	9b01      	ldr	r3, [sp, #4]
   11be2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_94[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_94[u32CoreId]))         /*if interrupts were enabled*/
   11be6:	4a0a      	ldr	r2, [pc, #40]	; (11c10 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_94+0x48>)
   11be8:	9b01      	ldr	r3, [sp, #4]
   11bea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11bee:	f003 0301 	and.w	r3, r3, #1
   11bf2:	2b00      	cmp	r3, #0
   11bf4:	d106      	bne.n	11c04 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_94+0x3c>
   11bf6:	4a05      	ldr	r2, [pc, #20]	; (11c0c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_94+0x44>)
   11bf8:	9b01      	ldr	r3, [sp, #4]
   11bfa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11bfe:	2b00      	cmp	r3, #0
   11c00:	d100      	bne.n	11c04 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_94+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   11c02:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11c04:	bf00      	nop
   11c06:	b003      	add	sp, #12
   11c08:	f85d fb04 	ldr.w	pc, [sp], #4
   11c0c:	1fff9344 	.word	0x1fff9344
   11c10:	1fff9340 	.word	0x1fff9340

00011c14 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_95>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_95(void)
{
   11c14:	b500      	push	{lr}
   11c16:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11c18:	f7ee ffbe 	bl	b98 <Sys_GetCoreID>
   11c1c:	4603      	mov	r3, r0
   11c1e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_95[u32CoreId])
   11c20:	4a10      	ldr	r2, [pc, #64]	; (11c64 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_95+0x50>)
   11c22:	9b01      	ldr	r3, [sp, #4]
   11c24:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11c28:	2b00      	cmp	r3, #0
   11c2a:	d10d      	bne.n	11c48 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_95+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11c2c:	f7ee fea6 	bl	97c <Adc_schm_read_msr>
   11c30:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   11c32:	9b00      	ldr	r3, [sp, #0]
   11c34:	f003 0301 	and.w	r3, r3, #1
   11c38:	2b00      	cmp	r3, #0
   11c3a:	d100      	bne.n	11c3e <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_95+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11c3c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_95[u32CoreId] = msr;
   11c3e:	490a      	ldr	r1, [pc, #40]	; (11c68 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_95+0x54>)
   11c40:	9b01      	ldr	r3, [sp, #4]
   11c42:	9a00      	ldr	r2, [sp, #0]
   11c44:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_95[u32CoreId]++;
   11c48:	4a06      	ldr	r2, [pc, #24]	; (11c64 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_95+0x50>)
   11c4a:	9b01      	ldr	r3, [sp, #4]
   11c4c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11c50:	1c5a      	adds	r2, r3, #1
   11c52:	4904      	ldr	r1, [pc, #16]	; (11c64 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_95+0x50>)
   11c54:	9b01      	ldr	r3, [sp, #4]
   11c56:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11c5a:	bf00      	nop
   11c5c:	b003      	add	sp, #12
   11c5e:	f85d fb04 	ldr.w	pc, [sp], #4
   11c62:	bf00      	nop
   11c64:	1fff934c 	.word	0x1fff934c
   11c68:	1fff9348 	.word	0x1fff9348

00011c6c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_95>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_95(void)
{
   11c6c:	b500      	push	{lr}
   11c6e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11c70:	f7ee ff92 	bl	b98 <Sys_GetCoreID>
   11c74:	4603      	mov	r3, r0
   11c76:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_95[u32CoreId]--;
   11c78:	4a0d      	ldr	r2, [pc, #52]	; (11cb0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_95+0x44>)
   11c7a:	9b01      	ldr	r3, [sp, #4]
   11c7c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11c80:	1e5a      	subs	r2, r3, #1
   11c82:	490b      	ldr	r1, [pc, #44]	; (11cb0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_95+0x44>)
   11c84:	9b01      	ldr	r3, [sp, #4]
   11c86:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_95[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_95[u32CoreId]))         /*if interrupts were enabled*/
   11c8a:	4a0a      	ldr	r2, [pc, #40]	; (11cb4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_95+0x48>)
   11c8c:	9b01      	ldr	r3, [sp, #4]
   11c8e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11c92:	f003 0301 	and.w	r3, r3, #1
   11c96:	2b00      	cmp	r3, #0
   11c98:	d106      	bne.n	11ca8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_95+0x3c>
   11c9a:	4a05      	ldr	r2, [pc, #20]	; (11cb0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_95+0x44>)
   11c9c:	9b01      	ldr	r3, [sp, #4]
   11c9e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11ca2:	2b00      	cmp	r3, #0
   11ca4:	d100      	bne.n	11ca8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_95+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   11ca6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11ca8:	bf00      	nop
   11caa:	b003      	add	sp, #12
   11cac:	f85d fb04 	ldr.w	pc, [sp], #4
   11cb0:	1fff934c 	.word	0x1fff934c
   11cb4:	1fff9348 	.word	0x1fff9348

00011cb8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_96>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_96(void)
{
   11cb8:	b500      	push	{lr}
   11cba:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11cbc:	f7ee ff6c 	bl	b98 <Sys_GetCoreID>
   11cc0:	4603      	mov	r3, r0
   11cc2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_96[u32CoreId])
   11cc4:	4a10      	ldr	r2, [pc, #64]	; (11d08 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_96+0x50>)
   11cc6:	9b01      	ldr	r3, [sp, #4]
   11cc8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11ccc:	2b00      	cmp	r3, #0
   11cce:	d10d      	bne.n	11cec <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_96+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11cd0:	f7ee fe54 	bl	97c <Adc_schm_read_msr>
   11cd4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   11cd6:	9b00      	ldr	r3, [sp, #0]
   11cd8:	f003 0301 	and.w	r3, r3, #1
   11cdc:	2b00      	cmp	r3, #0
   11cde:	d100      	bne.n	11ce2 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_96+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11ce0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_96[u32CoreId] = msr;
   11ce2:	490a      	ldr	r1, [pc, #40]	; (11d0c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_96+0x54>)
   11ce4:	9b01      	ldr	r3, [sp, #4]
   11ce6:	9a00      	ldr	r2, [sp, #0]
   11ce8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_96[u32CoreId]++;
   11cec:	4a06      	ldr	r2, [pc, #24]	; (11d08 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_96+0x50>)
   11cee:	9b01      	ldr	r3, [sp, #4]
   11cf0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11cf4:	1c5a      	adds	r2, r3, #1
   11cf6:	4904      	ldr	r1, [pc, #16]	; (11d08 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_96+0x50>)
   11cf8:	9b01      	ldr	r3, [sp, #4]
   11cfa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11cfe:	bf00      	nop
   11d00:	b003      	add	sp, #12
   11d02:	f85d fb04 	ldr.w	pc, [sp], #4
   11d06:	bf00      	nop
   11d08:	1fff9354 	.word	0x1fff9354
   11d0c:	1fff9350 	.word	0x1fff9350

00011d10 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_96>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_96(void)
{
   11d10:	b500      	push	{lr}
   11d12:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11d14:	f7ee ff40 	bl	b98 <Sys_GetCoreID>
   11d18:	4603      	mov	r3, r0
   11d1a:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_96[u32CoreId]--;
   11d1c:	4a0d      	ldr	r2, [pc, #52]	; (11d54 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_96+0x44>)
   11d1e:	9b01      	ldr	r3, [sp, #4]
   11d20:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11d24:	1e5a      	subs	r2, r3, #1
   11d26:	490b      	ldr	r1, [pc, #44]	; (11d54 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_96+0x44>)
   11d28:	9b01      	ldr	r3, [sp, #4]
   11d2a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_96[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_96[u32CoreId]))         /*if interrupts were enabled*/
   11d2e:	4a0a      	ldr	r2, [pc, #40]	; (11d58 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_96+0x48>)
   11d30:	9b01      	ldr	r3, [sp, #4]
   11d32:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11d36:	f003 0301 	and.w	r3, r3, #1
   11d3a:	2b00      	cmp	r3, #0
   11d3c:	d106      	bne.n	11d4c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_96+0x3c>
   11d3e:	4a05      	ldr	r2, [pc, #20]	; (11d54 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_96+0x44>)
   11d40:	9b01      	ldr	r3, [sp, #4]
   11d42:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11d46:	2b00      	cmp	r3, #0
   11d48:	d100      	bne.n	11d4c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_96+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   11d4a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11d4c:	bf00      	nop
   11d4e:	b003      	add	sp, #12
   11d50:	f85d fb04 	ldr.w	pc, [sp], #4
   11d54:	1fff9354 	.word	0x1fff9354
   11d58:	1fff9350 	.word	0x1fff9350

00011d5c <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_97>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_97(void)
{
   11d5c:	b500      	push	{lr}
   11d5e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11d60:	f7ee ff1a 	bl	b98 <Sys_GetCoreID>
   11d64:	4603      	mov	r3, r0
   11d66:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_97[u32CoreId])
   11d68:	4a10      	ldr	r2, [pc, #64]	; (11dac <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_97+0x50>)
   11d6a:	9b01      	ldr	r3, [sp, #4]
   11d6c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11d70:	2b00      	cmp	r3, #0
   11d72:	d10d      	bne.n	11d90 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_97+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11d74:	f7ee fe02 	bl	97c <Adc_schm_read_msr>
   11d78:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   11d7a:	9b00      	ldr	r3, [sp, #0]
   11d7c:	f003 0301 	and.w	r3, r3, #1
   11d80:	2b00      	cmp	r3, #0
   11d82:	d100      	bne.n	11d86 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_97+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11d84:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_97[u32CoreId] = msr;
   11d86:	490a      	ldr	r1, [pc, #40]	; (11db0 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_97+0x54>)
   11d88:	9b01      	ldr	r3, [sp, #4]
   11d8a:	9a00      	ldr	r2, [sp, #0]
   11d8c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_97[u32CoreId]++;
   11d90:	4a06      	ldr	r2, [pc, #24]	; (11dac <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_97+0x50>)
   11d92:	9b01      	ldr	r3, [sp, #4]
   11d94:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11d98:	1c5a      	adds	r2, r3, #1
   11d9a:	4904      	ldr	r1, [pc, #16]	; (11dac <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_97+0x50>)
   11d9c:	9b01      	ldr	r3, [sp, #4]
   11d9e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11da2:	bf00      	nop
   11da4:	b003      	add	sp, #12
   11da6:	f85d fb04 	ldr.w	pc, [sp], #4
   11daa:	bf00      	nop
   11dac:	1fff935c 	.word	0x1fff935c
   11db0:	1fff9358 	.word	0x1fff9358

00011db4 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_97>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_97(void)
{
   11db4:	b500      	push	{lr}
   11db6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11db8:	f7ee feee 	bl	b98 <Sys_GetCoreID>
   11dbc:	4603      	mov	r3, r0
   11dbe:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_97[u32CoreId]--;
   11dc0:	4a0d      	ldr	r2, [pc, #52]	; (11df8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_97+0x44>)
   11dc2:	9b01      	ldr	r3, [sp, #4]
   11dc4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11dc8:	1e5a      	subs	r2, r3, #1
   11dca:	490b      	ldr	r1, [pc, #44]	; (11df8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_97+0x44>)
   11dcc:	9b01      	ldr	r3, [sp, #4]
   11dce:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_97[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_97[u32CoreId]))         /*if interrupts were enabled*/
   11dd2:	4a0a      	ldr	r2, [pc, #40]	; (11dfc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_97+0x48>)
   11dd4:	9b01      	ldr	r3, [sp, #4]
   11dd6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11dda:	f003 0301 	and.w	r3, r3, #1
   11dde:	2b00      	cmp	r3, #0
   11de0:	d106      	bne.n	11df0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_97+0x3c>
   11de2:	4a05      	ldr	r2, [pc, #20]	; (11df8 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_97+0x44>)
   11de4:	9b01      	ldr	r3, [sp, #4]
   11de6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11dea:	2b00      	cmp	r3, #0
   11dec:	d100      	bne.n	11df0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_97+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   11dee:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11df0:	bf00      	nop
   11df2:	b003      	add	sp, #12
   11df4:	f85d fb04 	ldr.w	pc, [sp], #4
   11df8:	1fff935c 	.word	0x1fff935c
   11dfc:	1fff9358 	.word	0x1fff9358

00011e00 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_98>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_98(void)
{
   11e00:	b500      	push	{lr}
   11e02:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11e04:	f7ee fec8 	bl	b98 <Sys_GetCoreID>
   11e08:	4603      	mov	r3, r0
   11e0a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_98[u32CoreId])
   11e0c:	4a10      	ldr	r2, [pc, #64]	; (11e50 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_98+0x50>)
   11e0e:	9b01      	ldr	r3, [sp, #4]
   11e10:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11e14:	2b00      	cmp	r3, #0
   11e16:	d10d      	bne.n	11e34 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_98+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11e18:	f7ee fdb0 	bl	97c <Adc_schm_read_msr>
   11e1c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   11e1e:	9b00      	ldr	r3, [sp, #0]
   11e20:	f003 0301 	and.w	r3, r3, #1
   11e24:	2b00      	cmp	r3, #0
   11e26:	d100      	bne.n	11e2a <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_98+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11e28:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_98[u32CoreId] = msr;
   11e2a:	490a      	ldr	r1, [pc, #40]	; (11e54 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_98+0x54>)
   11e2c:	9b01      	ldr	r3, [sp, #4]
   11e2e:	9a00      	ldr	r2, [sp, #0]
   11e30:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_98[u32CoreId]++;
   11e34:	4a06      	ldr	r2, [pc, #24]	; (11e50 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_98+0x50>)
   11e36:	9b01      	ldr	r3, [sp, #4]
   11e38:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11e3c:	1c5a      	adds	r2, r3, #1
   11e3e:	4904      	ldr	r1, [pc, #16]	; (11e50 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_98+0x50>)
   11e40:	9b01      	ldr	r3, [sp, #4]
   11e42:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11e46:	bf00      	nop
   11e48:	b003      	add	sp, #12
   11e4a:	f85d fb04 	ldr.w	pc, [sp], #4
   11e4e:	bf00      	nop
   11e50:	1fff9364 	.word	0x1fff9364
   11e54:	1fff9360 	.word	0x1fff9360

00011e58 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_98>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_98(void)
{
   11e58:	b500      	push	{lr}
   11e5a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11e5c:	f7ee fe9c 	bl	b98 <Sys_GetCoreID>
   11e60:	4603      	mov	r3, r0
   11e62:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_98[u32CoreId]--;
   11e64:	4a0d      	ldr	r2, [pc, #52]	; (11e9c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_98+0x44>)
   11e66:	9b01      	ldr	r3, [sp, #4]
   11e68:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11e6c:	1e5a      	subs	r2, r3, #1
   11e6e:	490b      	ldr	r1, [pc, #44]	; (11e9c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_98+0x44>)
   11e70:	9b01      	ldr	r3, [sp, #4]
   11e72:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_98[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_98[u32CoreId]))         /*if interrupts were enabled*/
   11e76:	4a0a      	ldr	r2, [pc, #40]	; (11ea0 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_98+0x48>)
   11e78:	9b01      	ldr	r3, [sp, #4]
   11e7a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11e7e:	f003 0301 	and.w	r3, r3, #1
   11e82:	2b00      	cmp	r3, #0
   11e84:	d106      	bne.n	11e94 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_98+0x3c>
   11e86:	4a05      	ldr	r2, [pc, #20]	; (11e9c <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_98+0x44>)
   11e88:	9b01      	ldr	r3, [sp, #4]
   11e8a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11e8e:	2b00      	cmp	r3, #0
   11e90:	d100      	bne.n	11e94 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_98+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   11e92:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11e94:	bf00      	nop
   11e96:	b003      	add	sp, #12
   11e98:	f85d fb04 	ldr.w	pc, [sp], #4
   11e9c:	1fff9364 	.word	0x1fff9364
   11ea0:	1fff9360 	.word	0x1fff9360

00011ea4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_99>:

void SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_99(void)
{
   11ea4:	b500      	push	{lr}
   11ea6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11ea8:	f7ee fe76 	bl	b98 <Sys_GetCoreID>
   11eac:	4603      	mov	r3, r0
   11eae:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_99[u32CoreId])
   11eb0:	4a10      	ldr	r2, [pc, #64]	; (11ef4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_99+0x50>)
   11eb2:	9b01      	ldr	r3, [sp, #4]
   11eb4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11eb8:	2b00      	cmp	r3, #0
   11eba:	d10d      	bne.n	11ed8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_99+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Adc_schm_read_msr);
#else
        msr = Adc_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11ebc:	f7ee fd5e 	bl	97c <Adc_schm_read_msr>
   11ec0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   11ec2:	9b00      	ldr	r3, [sp, #0]
   11ec4:	f003 0301 	and.w	r3, r3, #1
   11ec8:	2b00      	cmp	r3, #0
   11eca:	d100      	bne.n	11ece <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_99+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11ecc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_ADC_EXCLUSIVE_AREA_99[u32CoreId] = msr;
   11ece:	490a      	ldr	r1, [pc, #40]	; (11ef8 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_99+0x54>)
   11ed0:	9b01      	ldr	r3, [sp, #4]
   11ed2:	9a00      	ldr	r2, [sp, #0]
   11ed4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_ADC_EXCLUSIVE_AREA_99[u32CoreId]++;
   11ed8:	4a06      	ldr	r2, [pc, #24]	; (11ef4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_99+0x50>)
   11eda:	9b01      	ldr	r3, [sp, #4]
   11edc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11ee0:	1c5a      	adds	r2, r3, #1
   11ee2:	4904      	ldr	r1, [pc, #16]	; (11ef4 <SchM_Enter_Adc_ADC_EXCLUSIVE_AREA_99+0x50>)
   11ee4:	9b01      	ldr	r3, [sp, #4]
   11ee6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11eea:	bf00      	nop
   11eec:	b003      	add	sp, #12
   11eee:	f85d fb04 	ldr.w	pc, [sp], #4
   11ef2:	bf00      	nop
   11ef4:	1fff936c 	.word	0x1fff936c
   11ef8:	1fff9368 	.word	0x1fff9368

00011efc <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_99>:

void SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_99(void)
{
   11efc:	b500      	push	{lr}
   11efe:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11f00:	f7ee fe4a 	bl	b98 <Sys_GetCoreID>
   11f04:	4603      	mov	r3, r0
   11f06:	9301      	str	r3, [sp, #4]

    reentry_guard_ADC_EXCLUSIVE_AREA_99[u32CoreId]--;
   11f08:	4a0d      	ldr	r2, [pc, #52]	; (11f40 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_99+0x44>)
   11f0a:	9b01      	ldr	r3, [sp, #4]
   11f0c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11f10:	1e5a      	subs	r2, r3, #1
   11f12:	490b      	ldr	r1, [pc, #44]	; (11f40 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_99+0x44>)
   11f14:	9b01      	ldr	r3, [sp, #4]
   11f16:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_ADC_EXCLUSIVE_AREA_99[u32CoreId]))&&(0UL == reentry_guard_ADC_EXCLUSIVE_AREA_99[u32CoreId]))         /*if interrupts were enabled*/
   11f1a:	4a0a      	ldr	r2, [pc, #40]	; (11f44 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_99+0x48>)
   11f1c:	9b01      	ldr	r3, [sp, #4]
   11f1e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11f22:	f003 0301 	and.w	r3, r3, #1
   11f26:	2b00      	cmp	r3, #0
   11f28:	d106      	bne.n	11f38 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_99+0x3c>
   11f2a:	4a05      	ldr	r2, [pc, #20]	; (11f40 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_99+0x44>)
   11f2c:	9b01      	ldr	r3, [sp, #4]
   11f2e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11f32:	2b00      	cmp	r3, #0
   11f34:	d100      	bne.n	11f38 <SchM_Exit_Adc_ADC_EXCLUSIVE_AREA_99+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   11f36:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11f38:	bf00      	nop
   11f3a:	b003      	add	sp, #12
   11f3c:	f85d fb04 	ldr.w	pc, [sp], #4
   11f40:	1fff936c 	.word	0x1fff936c
   11f44:	1fff9368 	.word	0x1fff9368

00011f48 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00(void)
{
   11f48:	b500      	push	{lr}
   11f4a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11f4c:	f7ee fe24 	bl	b98 <Sys_GetCoreID>
   11f50:	4603      	mov	r3, r0
   11f52:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_00[u32CoreId])
   11f54:	4a10      	ldr	r2, [pc, #64]	; (11f98 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x50>)
   11f56:	9b01      	ldr	r3, [sp, #4]
   11f58:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11f5c:	2b00      	cmp	r3, #0
   11f5e:	d10d      	bne.n	11f7c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   11f60:	f7ee fd15 	bl	98e <Can_43_FLEXCAN_schm_read_msr>
   11f64:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   11f66:	9b00      	ldr	r3, [sp, #0]
   11f68:	f003 0301 	and.w	r3, r3, #1
   11f6c:	2b00      	cmp	r3, #0
   11f6e:	d100      	bne.n	11f72 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   11f70:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_00[u32CoreId] = msr;
   11f72:	490a      	ldr	r1, [pc, #40]	; (11f9c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x54>)
   11f74:	9b01      	ldr	r3, [sp, #4]
   11f76:	9a00      	ldr	r2, [sp, #0]
   11f78:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_00[u32CoreId]++;
   11f7c:	4a06      	ldr	r2, [pc, #24]	; (11f98 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x50>)
   11f7e:	9b01      	ldr	r3, [sp, #4]
   11f80:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11f84:	1c5a      	adds	r2, r3, #1
   11f86:	4904      	ldr	r1, [pc, #16]	; (11f98 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x50>)
   11f88:	9b01      	ldr	r3, [sp, #4]
   11f8a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   11f8e:	bf00      	nop
   11f90:	b003      	add	sp, #12
   11f92:	f85d fb04 	ldr.w	pc, [sp], #4
   11f96:	bf00      	nop
   11f98:	1fff9374 	.word	0x1fff9374
   11f9c:	1fff9370 	.word	0x1fff9370

00011fa0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00(void)
{
   11fa0:	b500      	push	{lr}
   11fa2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11fa4:	f7ee fdf8 	bl	b98 <Sys_GetCoreID>
   11fa8:	4603      	mov	r3, r0
   11faa:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_00[u32CoreId]--;
   11fac:	4a0d      	ldr	r2, [pc, #52]	; (11fe4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x44>)
   11fae:	9b01      	ldr	r3, [sp, #4]
   11fb0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11fb4:	1e5a      	subs	r2, r3, #1
   11fb6:	490b      	ldr	r1, [pc, #44]	; (11fe4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x44>)
   11fb8:	9b01      	ldr	r3, [sp, #4]
   11fba:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
   11fbe:	4a0a      	ldr	r2, [pc, #40]	; (11fe8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x48>)
   11fc0:	9b01      	ldr	r3, [sp, #4]
   11fc2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11fc6:	f003 0301 	and.w	r3, r3, #1
   11fca:	2b00      	cmp	r3, #0
   11fcc:	d106      	bne.n	11fdc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x3c>
   11fce:	4a05      	ldr	r2, [pc, #20]	; (11fe4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x44>)
   11fd0:	9b01      	ldr	r3, [sp, #4]
   11fd2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   11fd6:	2b00      	cmp	r3, #0
   11fd8:	d100      	bne.n	11fdc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   11fda:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   11fdc:	bf00      	nop
   11fde:	b003      	add	sp, #12
   11fe0:	f85d fb04 	ldr.w	pc, [sp], #4
   11fe4:	1fff9374 	.word	0x1fff9374
   11fe8:	1fff9370 	.word	0x1fff9370

00011fec <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01(void)
{
   11fec:	b500      	push	{lr}
   11fee:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   11ff0:	f7ee fdd2 	bl	b98 <Sys_GetCoreID>
   11ff4:	4603      	mov	r3, r0
   11ff6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_01[u32CoreId])
   11ff8:	4a10      	ldr	r2, [pc, #64]	; (1203c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x50>)
   11ffa:	9b01      	ldr	r3, [sp, #4]
   11ffc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12000:	2b00      	cmp	r3, #0
   12002:	d10d      	bne.n	12020 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12004:	f7ee fcc3 	bl	98e <Can_43_FLEXCAN_schm_read_msr>
   12008:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1200a:	9b00      	ldr	r3, [sp, #0]
   1200c:	f003 0301 	and.w	r3, r3, #1
   12010:	2b00      	cmp	r3, #0
   12012:	d100      	bne.n	12016 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12014:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_01[u32CoreId] = msr;
   12016:	490a      	ldr	r1, [pc, #40]	; (12040 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x54>)
   12018:	9b01      	ldr	r3, [sp, #4]
   1201a:	9a00      	ldr	r2, [sp, #0]
   1201c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_01[u32CoreId]++;
   12020:	4a06      	ldr	r2, [pc, #24]	; (1203c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x50>)
   12022:	9b01      	ldr	r3, [sp, #4]
   12024:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12028:	1c5a      	adds	r2, r3, #1
   1202a:	4904      	ldr	r1, [pc, #16]	; (1203c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x50>)
   1202c:	9b01      	ldr	r3, [sp, #4]
   1202e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   12032:	bf00      	nop
   12034:	b003      	add	sp, #12
   12036:	f85d fb04 	ldr.w	pc, [sp], #4
   1203a:	bf00      	nop
   1203c:	1fff937c 	.word	0x1fff937c
   12040:	1fff9378 	.word	0x1fff9378

00012044 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01(void)
{
   12044:	b500      	push	{lr}
   12046:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12048:	f7ee fda6 	bl	b98 <Sys_GetCoreID>
   1204c:	4603      	mov	r3, r0
   1204e:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_01[u32CoreId]--;
   12050:	4a0d      	ldr	r2, [pc, #52]	; (12088 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x44>)
   12052:	9b01      	ldr	r3, [sp, #4]
   12054:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12058:	1e5a      	subs	r2, r3, #1
   1205a:	490b      	ldr	r1, [pc, #44]	; (12088 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x44>)
   1205c:	9b01      	ldr	r3, [sp, #4]
   1205e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
   12062:	4a0a      	ldr	r2, [pc, #40]	; (1208c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x48>)
   12064:	9b01      	ldr	r3, [sp, #4]
   12066:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1206a:	f003 0301 	and.w	r3, r3, #1
   1206e:	2b00      	cmp	r3, #0
   12070:	d106      	bne.n	12080 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x3c>
   12072:	4a05      	ldr	r2, [pc, #20]	; (12088 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x44>)
   12074:	9b01      	ldr	r3, [sp, #4]
   12076:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1207a:	2b00      	cmp	r3, #0
   1207c:	d100      	bne.n	12080 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1207e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12080:	bf00      	nop
   12082:	b003      	add	sp, #12
   12084:	f85d fb04 	ldr.w	pc, [sp], #4
   12088:	1fff937c 	.word	0x1fff937c
   1208c:	1fff9378 	.word	0x1fff9378

00012090 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02(void)
{
   12090:	b500      	push	{lr}
   12092:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12094:	f7ee fd80 	bl	b98 <Sys_GetCoreID>
   12098:	4603      	mov	r3, r0
   1209a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_02[u32CoreId])
   1209c:	4a10      	ldr	r2, [pc, #64]	; (120e0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x50>)
   1209e:	9b01      	ldr	r3, [sp, #4]
   120a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   120a4:	2b00      	cmp	r3, #0
   120a6:	d10d      	bne.n	120c4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   120a8:	f7ee fc71 	bl	98e <Can_43_FLEXCAN_schm_read_msr>
   120ac:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   120ae:	9b00      	ldr	r3, [sp, #0]
   120b0:	f003 0301 	and.w	r3, r3, #1
   120b4:	2b00      	cmp	r3, #0
   120b6:	d100      	bne.n	120ba <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   120b8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_02[u32CoreId] = msr;
   120ba:	490a      	ldr	r1, [pc, #40]	; (120e4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x54>)
   120bc:	9b01      	ldr	r3, [sp, #4]
   120be:	9a00      	ldr	r2, [sp, #0]
   120c0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_02[u32CoreId]++;
   120c4:	4a06      	ldr	r2, [pc, #24]	; (120e0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x50>)
   120c6:	9b01      	ldr	r3, [sp, #4]
   120c8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   120cc:	1c5a      	adds	r2, r3, #1
   120ce:	4904      	ldr	r1, [pc, #16]	; (120e0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x50>)
   120d0:	9b01      	ldr	r3, [sp, #4]
   120d2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   120d6:	bf00      	nop
   120d8:	b003      	add	sp, #12
   120da:	f85d fb04 	ldr.w	pc, [sp], #4
   120de:	bf00      	nop
   120e0:	1fff9384 	.word	0x1fff9384
   120e4:	1fff9380 	.word	0x1fff9380

000120e8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02(void)
{
   120e8:	b500      	push	{lr}
   120ea:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   120ec:	f7ee fd54 	bl	b98 <Sys_GetCoreID>
   120f0:	4603      	mov	r3, r0
   120f2:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_02[u32CoreId]--;
   120f4:	4a0d      	ldr	r2, [pc, #52]	; (1212c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x44>)
   120f6:	9b01      	ldr	r3, [sp, #4]
   120f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   120fc:	1e5a      	subs	r2, r3, #1
   120fe:	490b      	ldr	r1, [pc, #44]	; (1212c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x44>)
   12100:	9b01      	ldr	r3, [sp, #4]
   12102:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_02[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_02[u32CoreId]))         /*if interrupts were enabled*/
   12106:	4a0a      	ldr	r2, [pc, #40]	; (12130 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x48>)
   12108:	9b01      	ldr	r3, [sp, #4]
   1210a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1210e:	f003 0301 	and.w	r3, r3, #1
   12112:	2b00      	cmp	r3, #0
   12114:	d106      	bne.n	12124 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x3c>
   12116:	4a05      	ldr	r2, [pc, #20]	; (1212c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x44>)
   12118:	9b01      	ldr	r3, [sp, #4]
   1211a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1211e:	2b00      	cmp	r3, #0
   12120:	d100      	bne.n	12124 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_02+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   12122:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12124:	bf00      	nop
   12126:	b003      	add	sp, #12
   12128:	f85d fb04 	ldr.w	pc, [sp], #4
   1212c:	1fff9384 	.word	0x1fff9384
   12130:	1fff9380 	.word	0x1fff9380

00012134 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03(void)
{
   12134:	b500      	push	{lr}
   12136:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12138:	f7ee fd2e 	bl	b98 <Sys_GetCoreID>
   1213c:	4603      	mov	r3, r0
   1213e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_03[u32CoreId])
   12140:	4a10      	ldr	r2, [pc, #64]	; (12184 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x50>)
   12142:	9b01      	ldr	r3, [sp, #4]
   12144:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12148:	2b00      	cmp	r3, #0
   1214a:	d10d      	bne.n	12168 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   1214c:	f7ee fc1f 	bl	98e <Can_43_FLEXCAN_schm_read_msr>
   12150:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   12152:	9b00      	ldr	r3, [sp, #0]
   12154:	f003 0301 	and.w	r3, r3, #1
   12158:	2b00      	cmp	r3, #0
   1215a:	d100      	bne.n	1215e <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   1215c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_03[u32CoreId] = msr;
   1215e:	490a      	ldr	r1, [pc, #40]	; (12188 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x54>)
   12160:	9b01      	ldr	r3, [sp, #4]
   12162:	9a00      	ldr	r2, [sp, #0]
   12164:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_03[u32CoreId]++;
   12168:	4a06      	ldr	r2, [pc, #24]	; (12184 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x50>)
   1216a:	9b01      	ldr	r3, [sp, #4]
   1216c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12170:	1c5a      	adds	r2, r3, #1
   12172:	4904      	ldr	r1, [pc, #16]	; (12184 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x50>)
   12174:	9b01      	ldr	r3, [sp, #4]
   12176:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1217a:	bf00      	nop
   1217c:	b003      	add	sp, #12
   1217e:	f85d fb04 	ldr.w	pc, [sp], #4
   12182:	bf00      	nop
   12184:	1fff938c 	.word	0x1fff938c
   12188:	1fff9388 	.word	0x1fff9388

0001218c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03(void)
{
   1218c:	b500      	push	{lr}
   1218e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12190:	f7ee fd02 	bl	b98 <Sys_GetCoreID>
   12194:	4603      	mov	r3, r0
   12196:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_03[u32CoreId]--;
   12198:	4a0d      	ldr	r2, [pc, #52]	; (121d0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x44>)
   1219a:	9b01      	ldr	r3, [sp, #4]
   1219c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   121a0:	1e5a      	subs	r2, r3, #1
   121a2:	490b      	ldr	r1, [pc, #44]	; (121d0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x44>)
   121a4:	9b01      	ldr	r3, [sp, #4]
   121a6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_03[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_03[u32CoreId]))         /*if interrupts were enabled*/
   121aa:	4a0a      	ldr	r2, [pc, #40]	; (121d4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x48>)
   121ac:	9b01      	ldr	r3, [sp, #4]
   121ae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   121b2:	f003 0301 	and.w	r3, r3, #1
   121b6:	2b00      	cmp	r3, #0
   121b8:	d106      	bne.n	121c8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x3c>
   121ba:	4a05      	ldr	r2, [pc, #20]	; (121d0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x44>)
   121bc:	9b01      	ldr	r3, [sp, #4]
   121be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   121c2:	2b00      	cmp	r3, #0
   121c4:	d100      	bne.n	121c8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_03+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   121c6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   121c8:	bf00      	nop
   121ca:	b003      	add	sp, #12
   121cc:	f85d fb04 	ldr.w	pc, [sp], #4
   121d0:	1fff938c 	.word	0x1fff938c
   121d4:	1fff9388 	.word	0x1fff9388

000121d8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04(void)
{
   121d8:	b500      	push	{lr}
   121da:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   121dc:	f7ee fcdc 	bl	b98 <Sys_GetCoreID>
   121e0:	4603      	mov	r3, r0
   121e2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_04[u32CoreId])
   121e4:	4a10      	ldr	r2, [pc, #64]	; (12228 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x50>)
   121e6:	9b01      	ldr	r3, [sp, #4]
   121e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   121ec:	2b00      	cmp	r3, #0
   121ee:	d10d      	bne.n	1220c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   121f0:	f7ee fbcd 	bl	98e <Can_43_FLEXCAN_schm_read_msr>
   121f4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   121f6:	9b00      	ldr	r3, [sp, #0]
   121f8:	f003 0301 	and.w	r3, r3, #1
   121fc:	2b00      	cmp	r3, #0
   121fe:	d100      	bne.n	12202 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12200:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_04[u32CoreId] = msr;
   12202:	490a      	ldr	r1, [pc, #40]	; (1222c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x54>)
   12204:	9b01      	ldr	r3, [sp, #4]
   12206:	9a00      	ldr	r2, [sp, #0]
   12208:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_04[u32CoreId]++;
   1220c:	4a06      	ldr	r2, [pc, #24]	; (12228 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x50>)
   1220e:	9b01      	ldr	r3, [sp, #4]
   12210:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12214:	1c5a      	adds	r2, r3, #1
   12216:	4904      	ldr	r1, [pc, #16]	; (12228 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x50>)
   12218:	9b01      	ldr	r3, [sp, #4]
   1221a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1221e:	bf00      	nop
   12220:	b003      	add	sp, #12
   12222:	f85d fb04 	ldr.w	pc, [sp], #4
   12226:	bf00      	nop
   12228:	1fff9394 	.word	0x1fff9394
   1222c:	1fff9390 	.word	0x1fff9390

00012230 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04(void)
{
   12230:	b500      	push	{lr}
   12232:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12234:	f7ee fcb0 	bl	b98 <Sys_GetCoreID>
   12238:	4603      	mov	r3, r0
   1223a:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_04[u32CoreId]--;
   1223c:	4a0d      	ldr	r2, [pc, #52]	; (12274 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x44>)
   1223e:	9b01      	ldr	r3, [sp, #4]
   12240:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12244:	1e5a      	subs	r2, r3, #1
   12246:	490b      	ldr	r1, [pc, #44]	; (12274 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x44>)
   12248:	9b01      	ldr	r3, [sp, #4]
   1224a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_04[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_04[u32CoreId]))         /*if interrupts were enabled*/
   1224e:	4a0a      	ldr	r2, [pc, #40]	; (12278 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x48>)
   12250:	9b01      	ldr	r3, [sp, #4]
   12252:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12256:	f003 0301 	and.w	r3, r3, #1
   1225a:	2b00      	cmp	r3, #0
   1225c:	d106      	bne.n	1226c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x3c>
   1225e:	4a05      	ldr	r2, [pc, #20]	; (12274 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x44>)
   12260:	9b01      	ldr	r3, [sp, #4]
   12262:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12266:	2b00      	cmp	r3, #0
   12268:	d100      	bne.n	1226c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_04+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1226a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   1226c:	bf00      	nop
   1226e:	b003      	add	sp, #12
   12270:	f85d fb04 	ldr.w	pc, [sp], #4
   12274:	1fff9394 	.word	0x1fff9394
   12278:	1fff9390 	.word	0x1fff9390

0001227c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05(void)
{
   1227c:	b500      	push	{lr}
   1227e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12280:	f7ee fc8a 	bl	b98 <Sys_GetCoreID>
   12284:	4603      	mov	r3, r0
   12286:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_05[u32CoreId])
   12288:	4a10      	ldr	r2, [pc, #64]	; (122cc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x50>)
   1228a:	9b01      	ldr	r3, [sp, #4]
   1228c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12290:	2b00      	cmp	r3, #0
   12292:	d10d      	bne.n	122b0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12294:	f7ee fb7b 	bl	98e <Can_43_FLEXCAN_schm_read_msr>
   12298:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1229a:	9b00      	ldr	r3, [sp, #0]
   1229c:	f003 0301 	and.w	r3, r3, #1
   122a0:	2b00      	cmp	r3, #0
   122a2:	d100      	bne.n	122a6 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   122a4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_05[u32CoreId] = msr;
   122a6:	490a      	ldr	r1, [pc, #40]	; (122d0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x54>)
   122a8:	9b01      	ldr	r3, [sp, #4]
   122aa:	9a00      	ldr	r2, [sp, #0]
   122ac:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_05[u32CoreId]++;
   122b0:	4a06      	ldr	r2, [pc, #24]	; (122cc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x50>)
   122b2:	9b01      	ldr	r3, [sp, #4]
   122b4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   122b8:	1c5a      	adds	r2, r3, #1
   122ba:	4904      	ldr	r1, [pc, #16]	; (122cc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x50>)
   122bc:	9b01      	ldr	r3, [sp, #4]
   122be:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   122c2:	bf00      	nop
   122c4:	b003      	add	sp, #12
   122c6:	f85d fb04 	ldr.w	pc, [sp], #4
   122ca:	bf00      	nop
   122cc:	1fff939c 	.word	0x1fff939c
   122d0:	1fff9398 	.word	0x1fff9398

000122d4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05(void)
{
   122d4:	b500      	push	{lr}
   122d6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   122d8:	f7ee fc5e 	bl	b98 <Sys_GetCoreID>
   122dc:	4603      	mov	r3, r0
   122de:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_05[u32CoreId]--;
   122e0:	4a0d      	ldr	r2, [pc, #52]	; (12318 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x44>)
   122e2:	9b01      	ldr	r3, [sp, #4]
   122e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   122e8:	1e5a      	subs	r2, r3, #1
   122ea:	490b      	ldr	r1, [pc, #44]	; (12318 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x44>)
   122ec:	9b01      	ldr	r3, [sp, #4]
   122ee:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_05[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_05[u32CoreId]))         /*if interrupts were enabled*/
   122f2:	4a0a      	ldr	r2, [pc, #40]	; (1231c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x48>)
   122f4:	9b01      	ldr	r3, [sp, #4]
   122f6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   122fa:	f003 0301 	and.w	r3, r3, #1
   122fe:	2b00      	cmp	r3, #0
   12300:	d106      	bne.n	12310 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x3c>
   12302:	4a05      	ldr	r2, [pc, #20]	; (12318 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x44>)
   12304:	9b01      	ldr	r3, [sp, #4]
   12306:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1230a:	2b00      	cmp	r3, #0
   1230c:	d100      	bne.n	12310 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_05+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1230e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12310:	bf00      	nop
   12312:	b003      	add	sp, #12
   12314:	f85d fb04 	ldr.w	pc, [sp], #4
   12318:	1fff939c 	.word	0x1fff939c
   1231c:	1fff9398 	.word	0x1fff9398

00012320 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06(void)
{
   12320:	b500      	push	{lr}
   12322:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12324:	f7ee fc38 	bl	b98 <Sys_GetCoreID>
   12328:	4603      	mov	r3, r0
   1232a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_06[u32CoreId])
   1232c:	4a10      	ldr	r2, [pc, #64]	; (12370 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x50>)
   1232e:	9b01      	ldr	r3, [sp, #4]
   12330:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12334:	2b00      	cmp	r3, #0
   12336:	d10d      	bne.n	12354 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12338:	f7ee fb29 	bl	98e <Can_43_FLEXCAN_schm_read_msr>
   1233c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1233e:	9b00      	ldr	r3, [sp, #0]
   12340:	f003 0301 	and.w	r3, r3, #1
   12344:	2b00      	cmp	r3, #0
   12346:	d100      	bne.n	1234a <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12348:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_06[u32CoreId] = msr;
   1234a:	490a      	ldr	r1, [pc, #40]	; (12374 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x54>)
   1234c:	9b01      	ldr	r3, [sp, #4]
   1234e:	9a00      	ldr	r2, [sp, #0]
   12350:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_06[u32CoreId]++;
   12354:	4a06      	ldr	r2, [pc, #24]	; (12370 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x50>)
   12356:	9b01      	ldr	r3, [sp, #4]
   12358:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1235c:	1c5a      	adds	r2, r3, #1
   1235e:	4904      	ldr	r1, [pc, #16]	; (12370 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x50>)
   12360:	9b01      	ldr	r3, [sp, #4]
   12362:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   12366:	bf00      	nop
   12368:	b003      	add	sp, #12
   1236a:	f85d fb04 	ldr.w	pc, [sp], #4
   1236e:	bf00      	nop
   12370:	1fff93a4 	.word	0x1fff93a4
   12374:	1fff93a0 	.word	0x1fff93a0

00012378 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06(void)
{
   12378:	b500      	push	{lr}
   1237a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1237c:	f7ee fc0c 	bl	b98 <Sys_GetCoreID>
   12380:	4603      	mov	r3, r0
   12382:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_06[u32CoreId]--;
   12384:	4a0d      	ldr	r2, [pc, #52]	; (123bc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x44>)
   12386:	9b01      	ldr	r3, [sp, #4]
   12388:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1238c:	1e5a      	subs	r2, r3, #1
   1238e:	490b      	ldr	r1, [pc, #44]	; (123bc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x44>)
   12390:	9b01      	ldr	r3, [sp, #4]
   12392:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_06[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_06[u32CoreId]))         /*if interrupts were enabled*/
   12396:	4a0a      	ldr	r2, [pc, #40]	; (123c0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x48>)
   12398:	9b01      	ldr	r3, [sp, #4]
   1239a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1239e:	f003 0301 	and.w	r3, r3, #1
   123a2:	2b00      	cmp	r3, #0
   123a4:	d106      	bne.n	123b4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x3c>
   123a6:	4a05      	ldr	r2, [pc, #20]	; (123bc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x44>)
   123a8:	9b01      	ldr	r3, [sp, #4]
   123aa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   123ae:	2b00      	cmp	r3, #0
   123b0:	d100      	bne.n	123b4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_06+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   123b2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   123b4:	bf00      	nop
   123b6:	b003      	add	sp, #12
   123b8:	f85d fb04 	ldr.w	pc, [sp], #4
   123bc:	1fff93a4 	.word	0x1fff93a4
   123c0:	1fff93a0 	.word	0x1fff93a0

000123c4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07(void)
{
   123c4:	b500      	push	{lr}
   123c6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   123c8:	f7ee fbe6 	bl	b98 <Sys_GetCoreID>
   123cc:	4603      	mov	r3, r0
   123ce:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_07[u32CoreId])
   123d0:	4a10      	ldr	r2, [pc, #64]	; (12414 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x50>)
   123d2:	9b01      	ldr	r3, [sp, #4]
   123d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   123d8:	2b00      	cmp	r3, #0
   123da:	d10d      	bne.n	123f8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   123dc:	f7ee fad7 	bl	98e <Can_43_FLEXCAN_schm_read_msr>
   123e0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   123e2:	9b00      	ldr	r3, [sp, #0]
   123e4:	f003 0301 	and.w	r3, r3, #1
   123e8:	2b00      	cmp	r3, #0
   123ea:	d100      	bne.n	123ee <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   123ec:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_07[u32CoreId] = msr;
   123ee:	490a      	ldr	r1, [pc, #40]	; (12418 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x54>)
   123f0:	9b01      	ldr	r3, [sp, #4]
   123f2:	9a00      	ldr	r2, [sp, #0]
   123f4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_07[u32CoreId]++;
   123f8:	4a06      	ldr	r2, [pc, #24]	; (12414 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x50>)
   123fa:	9b01      	ldr	r3, [sp, #4]
   123fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12400:	1c5a      	adds	r2, r3, #1
   12402:	4904      	ldr	r1, [pc, #16]	; (12414 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x50>)
   12404:	9b01      	ldr	r3, [sp, #4]
   12406:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1240a:	bf00      	nop
   1240c:	b003      	add	sp, #12
   1240e:	f85d fb04 	ldr.w	pc, [sp], #4
   12412:	bf00      	nop
   12414:	1fff93ac 	.word	0x1fff93ac
   12418:	1fff93a8 	.word	0x1fff93a8

0001241c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07(void)
{
   1241c:	b500      	push	{lr}
   1241e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12420:	f7ee fbba 	bl	b98 <Sys_GetCoreID>
   12424:	4603      	mov	r3, r0
   12426:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_07[u32CoreId]--;
   12428:	4a0d      	ldr	r2, [pc, #52]	; (12460 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x44>)
   1242a:	9b01      	ldr	r3, [sp, #4]
   1242c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12430:	1e5a      	subs	r2, r3, #1
   12432:	490b      	ldr	r1, [pc, #44]	; (12460 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x44>)
   12434:	9b01      	ldr	r3, [sp, #4]
   12436:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_07[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_07[u32CoreId]))         /*if interrupts were enabled*/
   1243a:	4a0a      	ldr	r2, [pc, #40]	; (12464 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x48>)
   1243c:	9b01      	ldr	r3, [sp, #4]
   1243e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12442:	f003 0301 	and.w	r3, r3, #1
   12446:	2b00      	cmp	r3, #0
   12448:	d106      	bne.n	12458 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x3c>
   1244a:	4a05      	ldr	r2, [pc, #20]	; (12460 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x44>)
   1244c:	9b01      	ldr	r3, [sp, #4]
   1244e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12452:	2b00      	cmp	r3, #0
   12454:	d100      	bne.n	12458 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_07+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   12456:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12458:	bf00      	nop
   1245a:	b003      	add	sp, #12
   1245c:	f85d fb04 	ldr.w	pc, [sp], #4
   12460:	1fff93ac 	.word	0x1fff93ac
   12464:	1fff93a8 	.word	0x1fff93a8

00012468 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08(void)
{
   12468:	b500      	push	{lr}
   1246a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1246c:	f7ee fb94 	bl	b98 <Sys_GetCoreID>
   12470:	4603      	mov	r3, r0
   12472:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_08[u32CoreId])
   12474:	4a10      	ldr	r2, [pc, #64]	; (124b8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x50>)
   12476:	9b01      	ldr	r3, [sp, #4]
   12478:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1247c:	2b00      	cmp	r3, #0
   1247e:	d10d      	bne.n	1249c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12480:	f7ee fa85 	bl	98e <Can_43_FLEXCAN_schm_read_msr>
   12484:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   12486:	9b00      	ldr	r3, [sp, #0]
   12488:	f003 0301 	and.w	r3, r3, #1
   1248c:	2b00      	cmp	r3, #0
   1248e:	d100      	bne.n	12492 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12490:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_08[u32CoreId] = msr;
   12492:	490a      	ldr	r1, [pc, #40]	; (124bc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x54>)
   12494:	9b01      	ldr	r3, [sp, #4]
   12496:	9a00      	ldr	r2, [sp, #0]
   12498:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_08[u32CoreId]++;
   1249c:	4a06      	ldr	r2, [pc, #24]	; (124b8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x50>)
   1249e:	9b01      	ldr	r3, [sp, #4]
   124a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   124a4:	1c5a      	adds	r2, r3, #1
   124a6:	4904      	ldr	r1, [pc, #16]	; (124b8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x50>)
   124a8:	9b01      	ldr	r3, [sp, #4]
   124aa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   124ae:	bf00      	nop
   124b0:	b003      	add	sp, #12
   124b2:	f85d fb04 	ldr.w	pc, [sp], #4
   124b6:	bf00      	nop
   124b8:	1fff93b4 	.word	0x1fff93b4
   124bc:	1fff93b0 	.word	0x1fff93b0

000124c0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08(void)
{
   124c0:	b500      	push	{lr}
   124c2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   124c4:	f7ee fb68 	bl	b98 <Sys_GetCoreID>
   124c8:	4603      	mov	r3, r0
   124ca:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_08[u32CoreId]--;
   124cc:	4a0d      	ldr	r2, [pc, #52]	; (12504 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x44>)
   124ce:	9b01      	ldr	r3, [sp, #4]
   124d0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   124d4:	1e5a      	subs	r2, r3, #1
   124d6:	490b      	ldr	r1, [pc, #44]	; (12504 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x44>)
   124d8:	9b01      	ldr	r3, [sp, #4]
   124da:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_08[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_08[u32CoreId]))         /*if interrupts were enabled*/
   124de:	4a0a      	ldr	r2, [pc, #40]	; (12508 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x48>)
   124e0:	9b01      	ldr	r3, [sp, #4]
   124e2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   124e6:	f003 0301 	and.w	r3, r3, #1
   124ea:	2b00      	cmp	r3, #0
   124ec:	d106      	bne.n	124fc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x3c>
   124ee:	4a05      	ldr	r2, [pc, #20]	; (12504 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x44>)
   124f0:	9b01      	ldr	r3, [sp, #4]
   124f2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   124f6:	2b00      	cmp	r3, #0
   124f8:	d100      	bne.n	124fc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_08+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   124fa:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   124fc:	bf00      	nop
   124fe:	b003      	add	sp, #12
   12500:	f85d fb04 	ldr.w	pc, [sp], #4
   12504:	1fff93b4 	.word	0x1fff93b4
   12508:	1fff93b0 	.word	0x1fff93b0

0001250c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09(void)
{
   1250c:	b500      	push	{lr}
   1250e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12510:	f7ee fb42 	bl	b98 <Sys_GetCoreID>
   12514:	4603      	mov	r3, r0
   12516:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_09[u32CoreId])
   12518:	4a10      	ldr	r2, [pc, #64]	; (1255c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x50>)
   1251a:	9b01      	ldr	r3, [sp, #4]
   1251c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12520:	2b00      	cmp	r3, #0
   12522:	d10d      	bne.n	12540 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12524:	f7ee fa33 	bl	98e <Can_43_FLEXCAN_schm_read_msr>
   12528:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1252a:	9b00      	ldr	r3, [sp, #0]
   1252c:	f003 0301 	and.w	r3, r3, #1
   12530:	2b00      	cmp	r3, #0
   12532:	d100      	bne.n	12536 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12534:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_09[u32CoreId] = msr;
   12536:	490a      	ldr	r1, [pc, #40]	; (12560 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x54>)
   12538:	9b01      	ldr	r3, [sp, #4]
   1253a:	9a00      	ldr	r2, [sp, #0]
   1253c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_09[u32CoreId]++;
   12540:	4a06      	ldr	r2, [pc, #24]	; (1255c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x50>)
   12542:	9b01      	ldr	r3, [sp, #4]
   12544:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12548:	1c5a      	adds	r2, r3, #1
   1254a:	4904      	ldr	r1, [pc, #16]	; (1255c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x50>)
   1254c:	9b01      	ldr	r3, [sp, #4]
   1254e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   12552:	bf00      	nop
   12554:	b003      	add	sp, #12
   12556:	f85d fb04 	ldr.w	pc, [sp], #4
   1255a:	bf00      	nop
   1255c:	1fff93bc 	.word	0x1fff93bc
   12560:	1fff93b8 	.word	0x1fff93b8

00012564 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09(void)
{
   12564:	b500      	push	{lr}
   12566:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12568:	f7ee fb16 	bl	b98 <Sys_GetCoreID>
   1256c:	4603      	mov	r3, r0
   1256e:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_09[u32CoreId]--;
   12570:	4a0d      	ldr	r2, [pc, #52]	; (125a8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x44>)
   12572:	9b01      	ldr	r3, [sp, #4]
   12574:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12578:	1e5a      	subs	r2, r3, #1
   1257a:	490b      	ldr	r1, [pc, #44]	; (125a8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x44>)
   1257c:	9b01      	ldr	r3, [sp, #4]
   1257e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_09[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_09[u32CoreId]))         /*if interrupts were enabled*/
   12582:	4a0a      	ldr	r2, [pc, #40]	; (125ac <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x48>)
   12584:	9b01      	ldr	r3, [sp, #4]
   12586:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1258a:	f003 0301 	and.w	r3, r3, #1
   1258e:	2b00      	cmp	r3, #0
   12590:	d106      	bne.n	125a0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x3c>
   12592:	4a05      	ldr	r2, [pc, #20]	; (125a8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x44>)
   12594:	9b01      	ldr	r3, [sp, #4]
   12596:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1259a:	2b00      	cmp	r3, #0
   1259c:	d100      	bne.n	125a0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_09+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1259e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   125a0:	bf00      	nop
   125a2:	b003      	add	sp, #12
   125a4:	f85d fb04 	ldr.w	pc, [sp], #4
   125a8:	1fff93bc 	.word	0x1fff93bc
   125ac:	1fff93b8 	.word	0x1fff93b8

000125b0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10(void)
{
   125b0:	b500      	push	{lr}
   125b2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   125b4:	f7ee faf0 	bl	b98 <Sys_GetCoreID>
   125b8:	4603      	mov	r3, r0
   125ba:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_10[u32CoreId])
   125bc:	4a10      	ldr	r2, [pc, #64]	; (12600 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x50>)
   125be:	9b01      	ldr	r3, [sp, #4]
   125c0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   125c4:	2b00      	cmp	r3, #0
   125c6:	d10d      	bne.n	125e4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   125c8:	f7ee f9e1 	bl	98e <Can_43_FLEXCAN_schm_read_msr>
   125cc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   125ce:	9b00      	ldr	r3, [sp, #0]
   125d0:	f003 0301 	and.w	r3, r3, #1
   125d4:	2b00      	cmp	r3, #0
   125d6:	d100      	bne.n	125da <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   125d8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_10[u32CoreId] = msr;
   125da:	490a      	ldr	r1, [pc, #40]	; (12604 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x54>)
   125dc:	9b01      	ldr	r3, [sp, #4]
   125de:	9a00      	ldr	r2, [sp, #0]
   125e0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_10[u32CoreId]++;
   125e4:	4a06      	ldr	r2, [pc, #24]	; (12600 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x50>)
   125e6:	9b01      	ldr	r3, [sp, #4]
   125e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   125ec:	1c5a      	adds	r2, r3, #1
   125ee:	4904      	ldr	r1, [pc, #16]	; (12600 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x50>)
   125f0:	9b01      	ldr	r3, [sp, #4]
   125f2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   125f6:	bf00      	nop
   125f8:	b003      	add	sp, #12
   125fa:	f85d fb04 	ldr.w	pc, [sp], #4
   125fe:	bf00      	nop
   12600:	1fff93c4 	.word	0x1fff93c4
   12604:	1fff93c0 	.word	0x1fff93c0

00012608 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10(void)
{
   12608:	b500      	push	{lr}
   1260a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1260c:	f7ee fac4 	bl	b98 <Sys_GetCoreID>
   12610:	4603      	mov	r3, r0
   12612:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_10[u32CoreId]--;
   12614:	4a0d      	ldr	r2, [pc, #52]	; (1264c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x44>)
   12616:	9b01      	ldr	r3, [sp, #4]
   12618:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1261c:	1e5a      	subs	r2, r3, #1
   1261e:	490b      	ldr	r1, [pc, #44]	; (1264c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x44>)
   12620:	9b01      	ldr	r3, [sp, #4]
   12622:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_10[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_10[u32CoreId]))         /*if interrupts were enabled*/
   12626:	4a0a      	ldr	r2, [pc, #40]	; (12650 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x48>)
   12628:	9b01      	ldr	r3, [sp, #4]
   1262a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1262e:	f003 0301 	and.w	r3, r3, #1
   12632:	2b00      	cmp	r3, #0
   12634:	d106      	bne.n	12644 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x3c>
   12636:	4a05      	ldr	r2, [pc, #20]	; (1264c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x44>)
   12638:	9b01      	ldr	r3, [sp, #4]
   1263a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1263e:	2b00      	cmp	r3, #0
   12640:	d100      	bne.n	12644 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_10+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   12642:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12644:	bf00      	nop
   12646:	b003      	add	sp, #12
   12648:	f85d fb04 	ldr.w	pc, [sp], #4
   1264c:	1fff93c4 	.word	0x1fff93c4
   12650:	1fff93c0 	.word	0x1fff93c0

00012654 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11(void)
{
   12654:	b500      	push	{lr}
   12656:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12658:	f7ee fa9e 	bl	b98 <Sys_GetCoreID>
   1265c:	4603      	mov	r3, r0
   1265e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_11[u32CoreId])
   12660:	4a10      	ldr	r2, [pc, #64]	; (126a4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x50>)
   12662:	9b01      	ldr	r3, [sp, #4]
   12664:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12668:	2b00      	cmp	r3, #0
   1266a:	d10d      	bne.n	12688 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   1266c:	f7ee f98f 	bl	98e <Can_43_FLEXCAN_schm_read_msr>
   12670:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   12672:	9b00      	ldr	r3, [sp, #0]
   12674:	f003 0301 	and.w	r3, r3, #1
   12678:	2b00      	cmp	r3, #0
   1267a:	d100      	bne.n	1267e <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   1267c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_11[u32CoreId] = msr;
   1267e:	490a      	ldr	r1, [pc, #40]	; (126a8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x54>)
   12680:	9b01      	ldr	r3, [sp, #4]
   12682:	9a00      	ldr	r2, [sp, #0]
   12684:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_11[u32CoreId]++;
   12688:	4a06      	ldr	r2, [pc, #24]	; (126a4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x50>)
   1268a:	9b01      	ldr	r3, [sp, #4]
   1268c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12690:	1c5a      	adds	r2, r3, #1
   12692:	4904      	ldr	r1, [pc, #16]	; (126a4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x50>)
   12694:	9b01      	ldr	r3, [sp, #4]
   12696:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1269a:	bf00      	nop
   1269c:	b003      	add	sp, #12
   1269e:	f85d fb04 	ldr.w	pc, [sp], #4
   126a2:	bf00      	nop
   126a4:	1fff93cc 	.word	0x1fff93cc
   126a8:	1fff93c8 	.word	0x1fff93c8

000126ac <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11(void)
{
   126ac:	b500      	push	{lr}
   126ae:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   126b0:	f7ee fa72 	bl	b98 <Sys_GetCoreID>
   126b4:	4603      	mov	r3, r0
   126b6:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_11[u32CoreId]--;
   126b8:	4a0d      	ldr	r2, [pc, #52]	; (126f0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x44>)
   126ba:	9b01      	ldr	r3, [sp, #4]
   126bc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   126c0:	1e5a      	subs	r2, r3, #1
   126c2:	490b      	ldr	r1, [pc, #44]	; (126f0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x44>)
   126c4:	9b01      	ldr	r3, [sp, #4]
   126c6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_11[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_11[u32CoreId]))         /*if interrupts were enabled*/
   126ca:	4a0a      	ldr	r2, [pc, #40]	; (126f4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x48>)
   126cc:	9b01      	ldr	r3, [sp, #4]
   126ce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   126d2:	f003 0301 	and.w	r3, r3, #1
   126d6:	2b00      	cmp	r3, #0
   126d8:	d106      	bne.n	126e8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x3c>
   126da:	4a05      	ldr	r2, [pc, #20]	; (126f0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x44>)
   126dc:	9b01      	ldr	r3, [sp, #4]
   126de:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   126e2:	2b00      	cmp	r3, #0
   126e4:	d100      	bne.n	126e8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_11+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   126e6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   126e8:	bf00      	nop
   126ea:	b003      	add	sp, #12
   126ec:	f85d fb04 	ldr.w	pc, [sp], #4
   126f0:	1fff93cc 	.word	0x1fff93cc
   126f4:	1fff93c8 	.word	0x1fff93c8

000126f8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12(void)
{
   126f8:	b500      	push	{lr}
   126fa:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   126fc:	f7ee fa4c 	bl	b98 <Sys_GetCoreID>
   12700:	4603      	mov	r3, r0
   12702:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_12[u32CoreId])
   12704:	4a10      	ldr	r2, [pc, #64]	; (12748 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x50>)
   12706:	9b01      	ldr	r3, [sp, #4]
   12708:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1270c:	2b00      	cmp	r3, #0
   1270e:	d10d      	bne.n	1272c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12710:	f7ee f93d 	bl	98e <Can_43_FLEXCAN_schm_read_msr>
   12714:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   12716:	9b00      	ldr	r3, [sp, #0]
   12718:	f003 0301 	and.w	r3, r3, #1
   1271c:	2b00      	cmp	r3, #0
   1271e:	d100      	bne.n	12722 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12720:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_12[u32CoreId] = msr;
   12722:	490a      	ldr	r1, [pc, #40]	; (1274c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x54>)
   12724:	9b01      	ldr	r3, [sp, #4]
   12726:	9a00      	ldr	r2, [sp, #0]
   12728:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_12[u32CoreId]++;
   1272c:	4a06      	ldr	r2, [pc, #24]	; (12748 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x50>)
   1272e:	9b01      	ldr	r3, [sp, #4]
   12730:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12734:	1c5a      	adds	r2, r3, #1
   12736:	4904      	ldr	r1, [pc, #16]	; (12748 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x50>)
   12738:	9b01      	ldr	r3, [sp, #4]
   1273a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1273e:	bf00      	nop
   12740:	b003      	add	sp, #12
   12742:	f85d fb04 	ldr.w	pc, [sp], #4
   12746:	bf00      	nop
   12748:	1fff93d4 	.word	0x1fff93d4
   1274c:	1fff93d0 	.word	0x1fff93d0

00012750 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12(void)
{
   12750:	b500      	push	{lr}
   12752:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12754:	f7ee fa20 	bl	b98 <Sys_GetCoreID>
   12758:	4603      	mov	r3, r0
   1275a:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_12[u32CoreId]--;
   1275c:	4a0d      	ldr	r2, [pc, #52]	; (12794 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x44>)
   1275e:	9b01      	ldr	r3, [sp, #4]
   12760:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12764:	1e5a      	subs	r2, r3, #1
   12766:	490b      	ldr	r1, [pc, #44]	; (12794 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x44>)
   12768:	9b01      	ldr	r3, [sp, #4]
   1276a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_12[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_12[u32CoreId]))         /*if interrupts were enabled*/
   1276e:	4a0a      	ldr	r2, [pc, #40]	; (12798 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x48>)
   12770:	9b01      	ldr	r3, [sp, #4]
   12772:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12776:	f003 0301 	and.w	r3, r3, #1
   1277a:	2b00      	cmp	r3, #0
   1277c:	d106      	bne.n	1278c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x3c>
   1277e:	4a05      	ldr	r2, [pc, #20]	; (12794 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x44>)
   12780:	9b01      	ldr	r3, [sp, #4]
   12782:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12786:	2b00      	cmp	r3, #0
   12788:	d100      	bne.n	1278c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_12+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1278a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   1278c:	bf00      	nop
   1278e:	b003      	add	sp, #12
   12790:	f85d fb04 	ldr.w	pc, [sp], #4
   12794:	1fff93d4 	.word	0x1fff93d4
   12798:	1fff93d0 	.word	0x1fff93d0

0001279c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13(void)
{
   1279c:	b500      	push	{lr}
   1279e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   127a0:	f7ee f9fa 	bl	b98 <Sys_GetCoreID>
   127a4:	4603      	mov	r3, r0
   127a6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_13[u32CoreId])
   127a8:	4a10      	ldr	r2, [pc, #64]	; (127ec <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x50>)
   127aa:	9b01      	ldr	r3, [sp, #4]
   127ac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   127b0:	2b00      	cmp	r3, #0
   127b2:	d10d      	bne.n	127d0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   127b4:	f7ee f8eb 	bl	98e <Can_43_FLEXCAN_schm_read_msr>
   127b8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   127ba:	9b00      	ldr	r3, [sp, #0]
   127bc:	f003 0301 	and.w	r3, r3, #1
   127c0:	2b00      	cmp	r3, #0
   127c2:	d100      	bne.n	127c6 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   127c4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_13[u32CoreId] = msr;
   127c6:	490a      	ldr	r1, [pc, #40]	; (127f0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x54>)
   127c8:	9b01      	ldr	r3, [sp, #4]
   127ca:	9a00      	ldr	r2, [sp, #0]
   127cc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_13[u32CoreId]++;
   127d0:	4a06      	ldr	r2, [pc, #24]	; (127ec <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x50>)
   127d2:	9b01      	ldr	r3, [sp, #4]
   127d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   127d8:	1c5a      	adds	r2, r3, #1
   127da:	4904      	ldr	r1, [pc, #16]	; (127ec <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x50>)
   127dc:	9b01      	ldr	r3, [sp, #4]
   127de:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   127e2:	bf00      	nop
   127e4:	b003      	add	sp, #12
   127e6:	f85d fb04 	ldr.w	pc, [sp], #4
   127ea:	bf00      	nop
   127ec:	1fff93dc 	.word	0x1fff93dc
   127f0:	1fff93d8 	.word	0x1fff93d8

000127f4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13(void)
{
   127f4:	b500      	push	{lr}
   127f6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   127f8:	f7ee f9ce 	bl	b98 <Sys_GetCoreID>
   127fc:	4603      	mov	r3, r0
   127fe:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_13[u32CoreId]--;
   12800:	4a0d      	ldr	r2, [pc, #52]	; (12838 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x44>)
   12802:	9b01      	ldr	r3, [sp, #4]
   12804:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12808:	1e5a      	subs	r2, r3, #1
   1280a:	490b      	ldr	r1, [pc, #44]	; (12838 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x44>)
   1280c:	9b01      	ldr	r3, [sp, #4]
   1280e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_13[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_13[u32CoreId]))         /*if interrupts were enabled*/
   12812:	4a0a      	ldr	r2, [pc, #40]	; (1283c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x48>)
   12814:	9b01      	ldr	r3, [sp, #4]
   12816:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1281a:	f003 0301 	and.w	r3, r3, #1
   1281e:	2b00      	cmp	r3, #0
   12820:	d106      	bne.n	12830 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x3c>
   12822:	4a05      	ldr	r2, [pc, #20]	; (12838 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x44>)
   12824:	9b01      	ldr	r3, [sp, #4]
   12826:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1282a:	2b00      	cmp	r3, #0
   1282c:	d100      	bne.n	12830 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_13+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1282e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12830:	bf00      	nop
   12832:	b003      	add	sp, #12
   12834:	f85d fb04 	ldr.w	pc, [sp], #4
   12838:	1fff93dc 	.word	0x1fff93dc
   1283c:	1fff93d8 	.word	0x1fff93d8

00012840 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14(void)
{
   12840:	b500      	push	{lr}
   12842:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12844:	f7ee f9a8 	bl	b98 <Sys_GetCoreID>
   12848:	4603      	mov	r3, r0
   1284a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_14[u32CoreId])
   1284c:	4a10      	ldr	r2, [pc, #64]	; (12890 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x50>)
   1284e:	9b01      	ldr	r3, [sp, #4]
   12850:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12854:	2b00      	cmp	r3, #0
   12856:	d10d      	bne.n	12874 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12858:	f7ee f899 	bl	98e <Can_43_FLEXCAN_schm_read_msr>
   1285c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1285e:	9b00      	ldr	r3, [sp, #0]
   12860:	f003 0301 	and.w	r3, r3, #1
   12864:	2b00      	cmp	r3, #0
   12866:	d100      	bne.n	1286a <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12868:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_14[u32CoreId] = msr;
   1286a:	490a      	ldr	r1, [pc, #40]	; (12894 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x54>)
   1286c:	9b01      	ldr	r3, [sp, #4]
   1286e:	9a00      	ldr	r2, [sp, #0]
   12870:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_14[u32CoreId]++;
   12874:	4a06      	ldr	r2, [pc, #24]	; (12890 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x50>)
   12876:	9b01      	ldr	r3, [sp, #4]
   12878:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1287c:	1c5a      	adds	r2, r3, #1
   1287e:	4904      	ldr	r1, [pc, #16]	; (12890 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x50>)
   12880:	9b01      	ldr	r3, [sp, #4]
   12882:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   12886:	bf00      	nop
   12888:	b003      	add	sp, #12
   1288a:	f85d fb04 	ldr.w	pc, [sp], #4
   1288e:	bf00      	nop
   12890:	1fff93e4 	.word	0x1fff93e4
   12894:	1fff93e0 	.word	0x1fff93e0

00012898 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14(void)
{
   12898:	b500      	push	{lr}
   1289a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1289c:	f7ee f97c 	bl	b98 <Sys_GetCoreID>
   128a0:	4603      	mov	r3, r0
   128a2:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_14[u32CoreId]--;
   128a4:	4a0d      	ldr	r2, [pc, #52]	; (128dc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x44>)
   128a6:	9b01      	ldr	r3, [sp, #4]
   128a8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   128ac:	1e5a      	subs	r2, r3, #1
   128ae:	490b      	ldr	r1, [pc, #44]	; (128dc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x44>)
   128b0:	9b01      	ldr	r3, [sp, #4]
   128b2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_14[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_14[u32CoreId]))         /*if interrupts were enabled*/
   128b6:	4a0a      	ldr	r2, [pc, #40]	; (128e0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x48>)
   128b8:	9b01      	ldr	r3, [sp, #4]
   128ba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   128be:	f003 0301 	and.w	r3, r3, #1
   128c2:	2b00      	cmp	r3, #0
   128c4:	d106      	bne.n	128d4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x3c>
   128c6:	4a05      	ldr	r2, [pc, #20]	; (128dc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x44>)
   128c8:	9b01      	ldr	r3, [sp, #4]
   128ca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   128ce:	2b00      	cmp	r3, #0
   128d0:	d100      	bne.n	128d4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_14+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   128d2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   128d4:	bf00      	nop
   128d6:	b003      	add	sp, #12
   128d8:	f85d fb04 	ldr.w	pc, [sp], #4
   128dc:	1fff93e4 	.word	0x1fff93e4
   128e0:	1fff93e0 	.word	0x1fff93e0

000128e4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15(void)
{
   128e4:	b500      	push	{lr}
   128e6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   128e8:	f7ee f956 	bl	b98 <Sys_GetCoreID>
   128ec:	4603      	mov	r3, r0
   128ee:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_15[u32CoreId])
   128f0:	4a10      	ldr	r2, [pc, #64]	; (12934 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x50>)
   128f2:	9b01      	ldr	r3, [sp, #4]
   128f4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   128f8:	2b00      	cmp	r3, #0
   128fa:	d10d      	bne.n	12918 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   128fc:	f7ee f847 	bl	98e <Can_43_FLEXCAN_schm_read_msr>
   12900:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   12902:	9b00      	ldr	r3, [sp, #0]
   12904:	f003 0301 	and.w	r3, r3, #1
   12908:	2b00      	cmp	r3, #0
   1290a:	d100      	bne.n	1290e <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   1290c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_15[u32CoreId] = msr;
   1290e:	490a      	ldr	r1, [pc, #40]	; (12938 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x54>)
   12910:	9b01      	ldr	r3, [sp, #4]
   12912:	9a00      	ldr	r2, [sp, #0]
   12914:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_15[u32CoreId]++;
   12918:	4a06      	ldr	r2, [pc, #24]	; (12934 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x50>)
   1291a:	9b01      	ldr	r3, [sp, #4]
   1291c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12920:	1c5a      	adds	r2, r3, #1
   12922:	4904      	ldr	r1, [pc, #16]	; (12934 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x50>)
   12924:	9b01      	ldr	r3, [sp, #4]
   12926:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1292a:	bf00      	nop
   1292c:	b003      	add	sp, #12
   1292e:	f85d fb04 	ldr.w	pc, [sp], #4
   12932:	bf00      	nop
   12934:	1fff93ec 	.word	0x1fff93ec
   12938:	1fff93e8 	.word	0x1fff93e8

0001293c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15(void)
{
   1293c:	b500      	push	{lr}
   1293e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12940:	f7ee f92a 	bl	b98 <Sys_GetCoreID>
   12944:	4603      	mov	r3, r0
   12946:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_15[u32CoreId]--;
   12948:	4a0d      	ldr	r2, [pc, #52]	; (12980 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x44>)
   1294a:	9b01      	ldr	r3, [sp, #4]
   1294c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12950:	1e5a      	subs	r2, r3, #1
   12952:	490b      	ldr	r1, [pc, #44]	; (12980 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x44>)
   12954:	9b01      	ldr	r3, [sp, #4]
   12956:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_15[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_15[u32CoreId]))         /*if interrupts were enabled*/
   1295a:	4a0a      	ldr	r2, [pc, #40]	; (12984 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x48>)
   1295c:	9b01      	ldr	r3, [sp, #4]
   1295e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12962:	f003 0301 	and.w	r3, r3, #1
   12966:	2b00      	cmp	r3, #0
   12968:	d106      	bne.n	12978 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x3c>
   1296a:	4a05      	ldr	r2, [pc, #20]	; (12980 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x44>)
   1296c:	9b01      	ldr	r3, [sp, #4]
   1296e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12972:	2b00      	cmp	r3, #0
   12974:	d100      	bne.n	12978 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_15+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   12976:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12978:	bf00      	nop
   1297a:	b003      	add	sp, #12
   1297c:	f85d fb04 	ldr.w	pc, [sp], #4
   12980:	1fff93ec 	.word	0x1fff93ec
   12984:	1fff93e8 	.word	0x1fff93e8

00012988 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16(void)
{
   12988:	b500      	push	{lr}
   1298a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1298c:	f7ee f904 	bl	b98 <Sys_GetCoreID>
   12990:	4603      	mov	r3, r0
   12992:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_16[u32CoreId])
   12994:	4a10      	ldr	r2, [pc, #64]	; (129d8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x50>)
   12996:	9b01      	ldr	r3, [sp, #4]
   12998:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1299c:	2b00      	cmp	r3, #0
   1299e:	d10d      	bne.n	129bc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   129a0:	f7ed fff5 	bl	98e <Can_43_FLEXCAN_schm_read_msr>
   129a4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   129a6:	9b00      	ldr	r3, [sp, #0]
   129a8:	f003 0301 	and.w	r3, r3, #1
   129ac:	2b00      	cmp	r3, #0
   129ae:	d100      	bne.n	129b2 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   129b0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_16[u32CoreId] = msr;
   129b2:	490a      	ldr	r1, [pc, #40]	; (129dc <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x54>)
   129b4:	9b01      	ldr	r3, [sp, #4]
   129b6:	9a00      	ldr	r2, [sp, #0]
   129b8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_16[u32CoreId]++;
   129bc:	4a06      	ldr	r2, [pc, #24]	; (129d8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x50>)
   129be:	9b01      	ldr	r3, [sp, #4]
   129c0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   129c4:	1c5a      	adds	r2, r3, #1
   129c6:	4904      	ldr	r1, [pc, #16]	; (129d8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x50>)
   129c8:	9b01      	ldr	r3, [sp, #4]
   129ca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   129ce:	bf00      	nop
   129d0:	b003      	add	sp, #12
   129d2:	f85d fb04 	ldr.w	pc, [sp], #4
   129d6:	bf00      	nop
   129d8:	1fff93f4 	.word	0x1fff93f4
   129dc:	1fff93f0 	.word	0x1fff93f0

000129e0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16(void)
{
   129e0:	b500      	push	{lr}
   129e2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   129e4:	f7ee f8d8 	bl	b98 <Sys_GetCoreID>
   129e8:	4603      	mov	r3, r0
   129ea:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_16[u32CoreId]--;
   129ec:	4a0d      	ldr	r2, [pc, #52]	; (12a24 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x44>)
   129ee:	9b01      	ldr	r3, [sp, #4]
   129f0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   129f4:	1e5a      	subs	r2, r3, #1
   129f6:	490b      	ldr	r1, [pc, #44]	; (12a24 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x44>)
   129f8:	9b01      	ldr	r3, [sp, #4]
   129fa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_16[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_16[u32CoreId]))         /*if interrupts were enabled*/
   129fe:	4a0a      	ldr	r2, [pc, #40]	; (12a28 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x48>)
   12a00:	9b01      	ldr	r3, [sp, #4]
   12a02:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12a06:	f003 0301 	and.w	r3, r3, #1
   12a0a:	2b00      	cmp	r3, #0
   12a0c:	d106      	bne.n	12a1c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x3c>
   12a0e:	4a05      	ldr	r2, [pc, #20]	; (12a24 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x44>)
   12a10:	9b01      	ldr	r3, [sp, #4]
   12a12:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12a16:	2b00      	cmp	r3, #0
   12a18:	d100      	bne.n	12a1c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_16+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   12a1a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12a1c:	bf00      	nop
   12a1e:	b003      	add	sp, #12
   12a20:	f85d fb04 	ldr.w	pc, [sp], #4
   12a24:	1fff93f4 	.word	0x1fff93f4
   12a28:	1fff93f0 	.word	0x1fff93f0

00012a2c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17(void)
{
   12a2c:	b500      	push	{lr}
   12a2e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12a30:	f7ee f8b2 	bl	b98 <Sys_GetCoreID>
   12a34:	4603      	mov	r3, r0
   12a36:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_17[u32CoreId])
   12a38:	4a10      	ldr	r2, [pc, #64]	; (12a7c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x50>)
   12a3a:	9b01      	ldr	r3, [sp, #4]
   12a3c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12a40:	2b00      	cmp	r3, #0
   12a42:	d10d      	bne.n	12a60 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12a44:	f7ed ffa3 	bl	98e <Can_43_FLEXCAN_schm_read_msr>
   12a48:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   12a4a:	9b00      	ldr	r3, [sp, #0]
   12a4c:	f003 0301 	and.w	r3, r3, #1
   12a50:	2b00      	cmp	r3, #0
   12a52:	d100      	bne.n	12a56 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12a54:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_17[u32CoreId] = msr;
   12a56:	490a      	ldr	r1, [pc, #40]	; (12a80 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x54>)
   12a58:	9b01      	ldr	r3, [sp, #4]
   12a5a:	9a00      	ldr	r2, [sp, #0]
   12a5c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_17[u32CoreId]++;
   12a60:	4a06      	ldr	r2, [pc, #24]	; (12a7c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x50>)
   12a62:	9b01      	ldr	r3, [sp, #4]
   12a64:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12a68:	1c5a      	adds	r2, r3, #1
   12a6a:	4904      	ldr	r1, [pc, #16]	; (12a7c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x50>)
   12a6c:	9b01      	ldr	r3, [sp, #4]
   12a6e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   12a72:	bf00      	nop
   12a74:	b003      	add	sp, #12
   12a76:	f85d fb04 	ldr.w	pc, [sp], #4
   12a7a:	bf00      	nop
   12a7c:	1fff93fc 	.word	0x1fff93fc
   12a80:	1fff93f8 	.word	0x1fff93f8

00012a84 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17(void)
{
   12a84:	b500      	push	{lr}
   12a86:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12a88:	f7ee f886 	bl	b98 <Sys_GetCoreID>
   12a8c:	4603      	mov	r3, r0
   12a8e:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_17[u32CoreId]--;
   12a90:	4a0d      	ldr	r2, [pc, #52]	; (12ac8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x44>)
   12a92:	9b01      	ldr	r3, [sp, #4]
   12a94:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12a98:	1e5a      	subs	r2, r3, #1
   12a9a:	490b      	ldr	r1, [pc, #44]	; (12ac8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x44>)
   12a9c:	9b01      	ldr	r3, [sp, #4]
   12a9e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_17[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_17[u32CoreId]))         /*if interrupts were enabled*/
   12aa2:	4a0a      	ldr	r2, [pc, #40]	; (12acc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x48>)
   12aa4:	9b01      	ldr	r3, [sp, #4]
   12aa6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12aaa:	f003 0301 	and.w	r3, r3, #1
   12aae:	2b00      	cmp	r3, #0
   12ab0:	d106      	bne.n	12ac0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x3c>
   12ab2:	4a05      	ldr	r2, [pc, #20]	; (12ac8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x44>)
   12ab4:	9b01      	ldr	r3, [sp, #4]
   12ab6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12aba:	2b00      	cmp	r3, #0
   12abc:	d100      	bne.n	12ac0 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_17+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   12abe:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12ac0:	bf00      	nop
   12ac2:	b003      	add	sp, #12
   12ac4:	f85d fb04 	ldr.w	pc, [sp], #4
   12ac8:	1fff93fc 	.word	0x1fff93fc
   12acc:	1fff93f8 	.word	0x1fff93f8

00012ad0 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18(void)
{
   12ad0:	b500      	push	{lr}
   12ad2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12ad4:	f7ee f860 	bl	b98 <Sys_GetCoreID>
   12ad8:	4603      	mov	r3, r0
   12ada:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_18[u32CoreId])
   12adc:	4a10      	ldr	r2, [pc, #64]	; (12b20 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x50>)
   12ade:	9b01      	ldr	r3, [sp, #4]
   12ae0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12ae4:	2b00      	cmp	r3, #0
   12ae6:	d10d      	bne.n	12b04 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12ae8:	f7ed ff51 	bl	98e <Can_43_FLEXCAN_schm_read_msr>
   12aec:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   12aee:	9b00      	ldr	r3, [sp, #0]
   12af0:	f003 0301 	and.w	r3, r3, #1
   12af4:	2b00      	cmp	r3, #0
   12af6:	d100      	bne.n	12afa <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12af8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_18[u32CoreId] = msr;
   12afa:	490a      	ldr	r1, [pc, #40]	; (12b24 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x54>)
   12afc:	9b01      	ldr	r3, [sp, #4]
   12afe:	9a00      	ldr	r2, [sp, #0]
   12b00:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_18[u32CoreId]++;
   12b04:	4a06      	ldr	r2, [pc, #24]	; (12b20 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x50>)
   12b06:	9b01      	ldr	r3, [sp, #4]
   12b08:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12b0c:	1c5a      	adds	r2, r3, #1
   12b0e:	4904      	ldr	r1, [pc, #16]	; (12b20 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x50>)
   12b10:	9b01      	ldr	r3, [sp, #4]
   12b12:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   12b16:	bf00      	nop
   12b18:	b003      	add	sp, #12
   12b1a:	f85d fb04 	ldr.w	pc, [sp], #4
   12b1e:	bf00      	nop
   12b20:	1fff9404 	.word	0x1fff9404
   12b24:	1fff9400 	.word	0x1fff9400

00012b28 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18(void)
{
   12b28:	b500      	push	{lr}
   12b2a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12b2c:	f7ee f834 	bl	b98 <Sys_GetCoreID>
   12b30:	4603      	mov	r3, r0
   12b32:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_18[u32CoreId]--;
   12b34:	4a0d      	ldr	r2, [pc, #52]	; (12b6c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x44>)
   12b36:	9b01      	ldr	r3, [sp, #4]
   12b38:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12b3c:	1e5a      	subs	r2, r3, #1
   12b3e:	490b      	ldr	r1, [pc, #44]	; (12b6c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x44>)
   12b40:	9b01      	ldr	r3, [sp, #4]
   12b42:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_18[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_18[u32CoreId]))         /*if interrupts were enabled*/
   12b46:	4a0a      	ldr	r2, [pc, #40]	; (12b70 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x48>)
   12b48:	9b01      	ldr	r3, [sp, #4]
   12b4a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12b4e:	f003 0301 	and.w	r3, r3, #1
   12b52:	2b00      	cmp	r3, #0
   12b54:	d106      	bne.n	12b64 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x3c>
   12b56:	4a05      	ldr	r2, [pc, #20]	; (12b6c <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x44>)
   12b58:	9b01      	ldr	r3, [sp, #4]
   12b5a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12b5e:	2b00      	cmp	r3, #0
   12b60:	d100      	bne.n	12b64 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_18+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   12b62:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12b64:	bf00      	nop
   12b66:	b003      	add	sp, #12
   12b68:	f85d fb04 	ldr.w	pc, [sp], #4
   12b6c:	1fff9404 	.word	0x1fff9404
   12b70:	1fff9400 	.word	0x1fff9400

00012b74 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19(void)
{
   12b74:	b500      	push	{lr}
   12b76:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12b78:	f7ee f80e 	bl	b98 <Sys_GetCoreID>
   12b7c:	4603      	mov	r3, r0
   12b7e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_19[u32CoreId])
   12b80:	4a10      	ldr	r2, [pc, #64]	; (12bc4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x50>)
   12b82:	9b01      	ldr	r3, [sp, #4]
   12b84:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12b88:	2b00      	cmp	r3, #0
   12b8a:	d10d      	bne.n	12ba8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12b8c:	f7ed feff 	bl	98e <Can_43_FLEXCAN_schm_read_msr>
   12b90:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   12b92:	9b00      	ldr	r3, [sp, #0]
   12b94:	f003 0301 	and.w	r3, r3, #1
   12b98:	2b00      	cmp	r3, #0
   12b9a:	d100      	bne.n	12b9e <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12b9c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_19[u32CoreId] = msr;
   12b9e:	490a      	ldr	r1, [pc, #40]	; (12bc8 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x54>)
   12ba0:	9b01      	ldr	r3, [sp, #4]
   12ba2:	9a00      	ldr	r2, [sp, #0]
   12ba4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_19[u32CoreId]++;
   12ba8:	4a06      	ldr	r2, [pc, #24]	; (12bc4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x50>)
   12baa:	9b01      	ldr	r3, [sp, #4]
   12bac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12bb0:	1c5a      	adds	r2, r3, #1
   12bb2:	4904      	ldr	r1, [pc, #16]	; (12bc4 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x50>)
   12bb4:	9b01      	ldr	r3, [sp, #4]
   12bb6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   12bba:	bf00      	nop
   12bbc:	b003      	add	sp, #12
   12bbe:	f85d fb04 	ldr.w	pc, [sp], #4
   12bc2:	bf00      	nop
   12bc4:	1fff940c 	.word	0x1fff940c
   12bc8:	1fff9408 	.word	0x1fff9408

00012bcc <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19(void)
{
   12bcc:	b500      	push	{lr}
   12bce:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12bd0:	f7ed ffe2 	bl	b98 <Sys_GetCoreID>
   12bd4:	4603      	mov	r3, r0
   12bd6:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_19[u32CoreId]--;
   12bd8:	4a0d      	ldr	r2, [pc, #52]	; (12c10 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x44>)
   12bda:	9b01      	ldr	r3, [sp, #4]
   12bdc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12be0:	1e5a      	subs	r2, r3, #1
   12be2:	490b      	ldr	r1, [pc, #44]	; (12c10 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x44>)
   12be4:	9b01      	ldr	r3, [sp, #4]
   12be6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_19[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_19[u32CoreId]))         /*if interrupts were enabled*/
   12bea:	4a0a      	ldr	r2, [pc, #40]	; (12c14 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x48>)
   12bec:	9b01      	ldr	r3, [sp, #4]
   12bee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12bf2:	f003 0301 	and.w	r3, r3, #1
   12bf6:	2b00      	cmp	r3, #0
   12bf8:	d106      	bne.n	12c08 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x3c>
   12bfa:	4a05      	ldr	r2, [pc, #20]	; (12c10 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x44>)
   12bfc:	9b01      	ldr	r3, [sp, #4]
   12bfe:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12c02:	2b00      	cmp	r3, #0
   12c04:	d100      	bne.n	12c08 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_19+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   12c06:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12c08:	bf00      	nop
   12c0a:	b003      	add	sp, #12
   12c0c:	f85d fb04 	ldr.w	pc, [sp], #4
   12c10:	1fff940c 	.word	0x1fff940c
   12c14:	1fff9408 	.word	0x1fff9408

00012c18 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20>:

void SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20(void)
{
   12c18:	b500      	push	{lr}
   12c1a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12c1c:	f7ed ffbc 	bl	b98 <Sys_GetCoreID>
   12c20:	4603      	mov	r3, r0
   12c22:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_20[u32CoreId])
   12c24:	4a10      	ldr	r2, [pc, #64]	; (12c68 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x50>)
   12c26:	9b01      	ldr	r3, [sp, #4]
   12c28:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12c2c:	2b00      	cmp	r3, #0
   12c2e:	d10d      	bne.n	12c4c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Can_43_FLEXCAN_schm_read_msr);
#else
        msr = Can_43_FLEXCAN_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12c30:	f7ed fead 	bl	98e <Can_43_FLEXCAN_schm_read_msr>
   12c34:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   12c36:	9b00      	ldr	r3, [sp, #0]
   12c38:	f003 0301 	and.w	r3, r3, #1
   12c3c:	2b00      	cmp	r3, #0
   12c3e:	d100      	bne.n	12c42 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12c40:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_CAN_EXCLUSIVE_AREA_20[u32CoreId] = msr;
   12c42:	490a      	ldr	r1, [pc, #40]	; (12c6c <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x54>)
   12c44:	9b01      	ldr	r3, [sp, #4]
   12c46:	9a00      	ldr	r2, [sp, #0]
   12c48:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_CAN_EXCLUSIVE_AREA_20[u32CoreId]++;
   12c4c:	4a06      	ldr	r2, [pc, #24]	; (12c68 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x50>)
   12c4e:	9b01      	ldr	r3, [sp, #4]
   12c50:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12c54:	1c5a      	adds	r2, r3, #1
   12c56:	4904      	ldr	r1, [pc, #16]	; (12c68 <SchM_Enter_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x50>)
   12c58:	9b01      	ldr	r3, [sp, #4]
   12c5a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   12c5e:	bf00      	nop
   12c60:	b003      	add	sp, #12
   12c62:	f85d fb04 	ldr.w	pc, [sp], #4
   12c66:	bf00      	nop
   12c68:	1fff9414 	.word	0x1fff9414
   12c6c:	1fff9410 	.word	0x1fff9410

00012c70 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20>:

void SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20(void)
{
   12c70:	b500      	push	{lr}
   12c72:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12c74:	f7ed ff90 	bl	b98 <Sys_GetCoreID>
   12c78:	4603      	mov	r3, r0
   12c7a:	9301      	str	r3, [sp, #4]

    reentry_guard_CAN_EXCLUSIVE_AREA_20[u32CoreId]--;
   12c7c:	4a0d      	ldr	r2, [pc, #52]	; (12cb4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x44>)
   12c7e:	9b01      	ldr	r3, [sp, #4]
   12c80:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12c84:	1e5a      	subs	r2, r3, #1
   12c86:	490b      	ldr	r1, [pc, #44]	; (12cb4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x44>)
   12c88:	9b01      	ldr	r3, [sp, #4]
   12c8a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_CAN_EXCLUSIVE_AREA_20[u32CoreId]))&&(0UL == reentry_guard_CAN_EXCLUSIVE_AREA_20[u32CoreId]))         /*if interrupts were enabled*/
   12c8e:	4a0a      	ldr	r2, [pc, #40]	; (12cb8 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x48>)
   12c90:	9b01      	ldr	r3, [sp, #4]
   12c92:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12c96:	f003 0301 	and.w	r3, r3, #1
   12c9a:	2b00      	cmp	r3, #0
   12c9c:	d106      	bne.n	12cac <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x3c>
   12c9e:	4a05      	ldr	r2, [pc, #20]	; (12cb4 <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x44>)
   12ca0:	9b01      	ldr	r3, [sp, #4]
   12ca2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12ca6:	2b00      	cmp	r3, #0
   12ca8:	d100      	bne.n	12cac <SchM_Exit_Can_43_FLEXCAN_CAN_EXCLUSIVE_AREA_20+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   12caa:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12cac:	bf00      	nop
   12cae:	b003      	add	sp, #12
   12cb0:	f85d fb04 	ldr.w	pc, [sp], #4
   12cb4:	1fff9414 	.word	0x1fff9414
   12cb8:	1fff9410 	.word	0x1fff9410

00012cbc <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00(void)
{
   12cbc:	b500      	push	{lr}
   12cbe:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12cc0:	f7ed ff6a 	bl	b98 <Sys_GetCoreID>
   12cc4:	4603      	mov	r3, r0
   12cc6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId])
   12cc8:	4a10      	ldr	r2, [pc, #64]	; (12d0c <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x50>)
   12cca:	9b01      	ldr	r3, [sp, #4]
   12ccc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12cd0:	2b00      	cmp	r3, #0
   12cd2:	d10d      	bne.n	12cf0 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Mcu_schm_read_msr);
#else
        msr = Mcu_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12cd4:	f7ed fe64 	bl	9a0 <Mcu_schm_read_msr>
   12cd8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   12cda:	9b00      	ldr	r3, [sp, #0]
   12cdc:	f003 0301 	and.w	r3, r3, #1
   12ce0:	2b00      	cmp	r3, #0
   12ce2:	d100      	bne.n	12ce6 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12ce4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_MCU_EXCLUSIVE_AREA_00[u32CoreId] = msr;
   12ce6:	490a      	ldr	r1, [pc, #40]	; (12d10 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x54>)
   12ce8:	9b01      	ldr	r3, [sp, #4]
   12cea:	9a00      	ldr	r2, [sp, #0]
   12cec:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId]++;
   12cf0:	4a06      	ldr	r2, [pc, #24]	; (12d0c <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x50>)
   12cf2:	9b01      	ldr	r3, [sp, #4]
   12cf4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12cf8:	1c5a      	adds	r2, r3, #1
   12cfa:	4904      	ldr	r1, [pc, #16]	; (12d0c <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_00+0x50>)
   12cfc:	9b01      	ldr	r3, [sp, #4]
   12cfe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   12d02:	bf00      	nop
   12d04:	b003      	add	sp, #12
   12d06:	f85d fb04 	ldr.w	pc, [sp], #4
   12d0a:	bf00      	nop
   12d0c:	1fff941c 	.word	0x1fff941c
   12d10:	1fff9418 	.word	0x1fff9418

00012d14 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00>:

void SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00(void)
{
   12d14:	b500      	push	{lr}
   12d16:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12d18:	f7ed ff3e 	bl	b98 <Sys_GetCoreID>
   12d1c:	4603      	mov	r3, r0
   12d1e:	9301      	str	r3, [sp, #4]

    reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId]--;
   12d20:	4a0d      	ldr	r2, [pc, #52]	; (12d58 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x44>)
   12d22:	9b01      	ldr	r3, [sp, #4]
   12d24:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12d28:	1e5a      	subs	r2, r3, #1
   12d2a:	490b      	ldr	r1, [pc, #44]	; (12d58 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x44>)
   12d2c:	9b01      	ldr	r3, [sp, #4]
   12d2e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_MCU_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
   12d32:	4a0a      	ldr	r2, [pc, #40]	; (12d5c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x48>)
   12d34:	9b01      	ldr	r3, [sp, #4]
   12d36:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12d3a:	f003 0301 	and.w	r3, r3, #1
   12d3e:	2b00      	cmp	r3, #0
   12d40:	d106      	bne.n	12d50 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x3c>
   12d42:	4a05      	ldr	r2, [pc, #20]	; (12d58 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x44>)
   12d44:	9b01      	ldr	r3, [sp, #4]
   12d46:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12d4a:	2b00      	cmp	r3, #0
   12d4c:	d100      	bne.n	12d50 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   12d4e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12d50:	bf00      	nop
   12d52:	b003      	add	sp, #12
   12d54:	f85d fb04 	ldr.w	pc, [sp], #4
   12d58:	1fff941c 	.word	0x1fff941c
   12d5c:	1fff9418 	.word	0x1fff9418

00012d60 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01>:

void SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01(void)
{
   12d60:	b500      	push	{lr}
   12d62:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12d64:	f7ed ff18 	bl	b98 <Sys_GetCoreID>
   12d68:	4603      	mov	r3, r0
   12d6a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId])
   12d6c:	4a10      	ldr	r2, [pc, #64]	; (12db0 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x50>)
   12d6e:	9b01      	ldr	r3, [sp, #4]
   12d70:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12d74:	2b00      	cmp	r3, #0
   12d76:	d10d      	bne.n	12d94 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Mcu_schm_read_msr);
#else
        msr = Mcu_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12d78:	f7ed fe12 	bl	9a0 <Mcu_schm_read_msr>
   12d7c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   12d7e:	9b00      	ldr	r3, [sp, #0]
   12d80:	f003 0301 	and.w	r3, r3, #1
   12d84:	2b00      	cmp	r3, #0
   12d86:	d100      	bne.n	12d8a <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12d88:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_MCU_EXCLUSIVE_AREA_01[u32CoreId] = msr;
   12d8a:	490a      	ldr	r1, [pc, #40]	; (12db4 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x54>)
   12d8c:	9b01      	ldr	r3, [sp, #4]
   12d8e:	9a00      	ldr	r2, [sp, #0]
   12d90:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId]++;
   12d94:	4a06      	ldr	r2, [pc, #24]	; (12db0 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x50>)
   12d96:	9b01      	ldr	r3, [sp, #4]
   12d98:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12d9c:	1c5a      	adds	r2, r3, #1
   12d9e:	4904      	ldr	r1, [pc, #16]	; (12db0 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_01+0x50>)
   12da0:	9b01      	ldr	r3, [sp, #4]
   12da2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   12da6:	bf00      	nop
   12da8:	b003      	add	sp, #12
   12daa:	f85d fb04 	ldr.w	pc, [sp], #4
   12dae:	bf00      	nop
   12db0:	1fff9424 	.word	0x1fff9424
   12db4:	1fff9420 	.word	0x1fff9420

00012db8 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01>:

void SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01(void)
{
   12db8:	b500      	push	{lr}
   12dba:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12dbc:	f7ed feec 	bl	b98 <Sys_GetCoreID>
   12dc0:	4603      	mov	r3, r0
   12dc2:	9301      	str	r3, [sp, #4]

    reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId]--;
   12dc4:	4a0d      	ldr	r2, [pc, #52]	; (12dfc <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x44>)
   12dc6:	9b01      	ldr	r3, [sp, #4]
   12dc8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12dcc:	1e5a      	subs	r2, r3, #1
   12dce:	490b      	ldr	r1, [pc, #44]	; (12dfc <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x44>)
   12dd0:	9b01      	ldr	r3, [sp, #4]
   12dd2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_MCU_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
   12dd6:	4a0a      	ldr	r2, [pc, #40]	; (12e00 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x48>)
   12dd8:	9b01      	ldr	r3, [sp, #4]
   12dda:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12dde:	f003 0301 	and.w	r3, r3, #1
   12de2:	2b00      	cmp	r3, #0
   12de4:	d106      	bne.n	12df4 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x3c>
   12de6:	4a05      	ldr	r2, [pc, #20]	; (12dfc <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x44>)
   12de8:	9b01      	ldr	r3, [sp, #4]
   12dea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12dee:	2b00      	cmp	r3, #0
   12df0:	d100      	bne.n	12df4 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   12df2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12df4:	bf00      	nop
   12df6:	b003      	add	sp, #12
   12df8:	f85d fb04 	ldr.w	pc, [sp], #4
   12dfc:	1fff9424 	.word	0x1fff9424
   12e00:	1fff9420 	.word	0x1fff9420

00012e04 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02>:

void SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02(void)
{
   12e04:	b500      	push	{lr}
   12e06:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12e08:	f7ed fec6 	bl	b98 <Sys_GetCoreID>
   12e0c:	4603      	mov	r3, r0
   12e0e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId])
   12e10:	4a10      	ldr	r2, [pc, #64]	; (12e54 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x50>)
   12e12:	9b01      	ldr	r3, [sp, #4]
   12e14:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12e18:	2b00      	cmp	r3, #0
   12e1a:	d10d      	bne.n	12e38 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Mcu_schm_read_msr);
#else
        msr = Mcu_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12e1c:	f7ed fdc0 	bl	9a0 <Mcu_schm_read_msr>
   12e20:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   12e22:	9b00      	ldr	r3, [sp, #0]
   12e24:	f003 0301 	and.w	r3, r3, #1
   12e28:	2b00      	cmp	r3, #0
   12e2a:	d100      	bne.n	12e2e <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12e2c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_MCU_EXCLUSIVE_AREA_02[u32CoreId] = msr;
   12e2e:	490a      	ldr	r1, [pc, #40]	; (12e58 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x54>)
   12e30:	9b01      	ldr	r3, [sp, #4]
   12e32:	9a00      	ldr	r2, [sp, #0]
   12e34:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId]++;
   12e38:	4a06      	ldr	r2, [pc, #24]	; (12e54 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x50>)
   12e3a:	9b01      	ldr	r3, [sp, #4]
   12e3c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12e40:	1c5a      	adds	r2, r3, #1
   12e42:	4904      	ldr	r1, [pc, #16]	; (12e54 <SchM_Enter_Mcu_MCU_EXCLUSIVE_AREA_02+0x50>)
   12e44:	9b01      	ldr	r3, [sp, #4]
   12e46:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   12e4a:	bf00      	nop
   12e4c:	b003      	add	sp, #12
   12e4e:	f85d fb04 	ldr.w	pc, [sp], #4
   12e52:	bf00      	nop
   12e54:	1fff942c 	.word	0x1fff942c
   12e58:	1fff9428 	.word	0x1fff9428

00012e5c <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02>:

void SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02(void)
{
   12e5c:	b500      	push	{lr}
   12e5e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12e60:	f7ed fe9a 	bl	b98 <Sys_GetCoreID>
   12e64:	4603      	mov	r3, r0
   12e66:	9301      	str	r3, [sp, #4]

    reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId]--;
   12e68:	4a0d      	ldr	r2, [pc, #52]	; (12ea0 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x44>)
   12e6a:	9b01      	ldr	r3, [sp, #4]
   12e6c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12e70:	1e5a      	subs	r2, r3, #1
   12e72:	490b      	ldr	r1, [pc, #44]	; (12ea0 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x44>)
   12e74:	9b01      	ldr	r3, [sp, #4]
   12e76:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_MCU_EXCLUSIVE_AREA_02[u32CoreId]))&&(0UL == reentry_guard_MCU_EXCLUSIVE_AREA_02[u32CoreId]))         /*if interrupts were enabled*/
   12e7a:	4a0a      	ldr	r2, [pc, #40]	; (12ea4 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x48>)
   12e7c:	9b01      	ldr	r3, [sp, #4]
   12e7e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12e82:	f003 0301 	and.w	r3, r3, #1
   12e86:	2b00      	cmp	r3, #0
   12e88:	d106      	bne.n	12e98 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x3c>
   12e8a:	4a05      	ldr	r2, [pc, #20]	; (12ea0 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x44>)
   12e8c:	9b01      	ldr	r3, [sp, #4]
   12e8e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12e92:	2b00      	cmp	r3, #0
   12e94:	d100      	bne.n	12e98 <SchM_Exit_Mcu_MCU_EXCLUSIVE_AREA_02+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   12e96:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12e98:	bf00      	nop
   12e9a:	b003      	add	sp, #12
   12e9c:	f85d fb04 	ldr.w	pc, [sp], #4
   12ea0:	1fff942c 	.word	0x1fff942c
   12ea4:	1fff9428 	.word	0x1fff9428

00012ea8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00>:
==================================================================================================*/
#define RTE_START_SEC_CODE
#include "Rte_MemMap.h"

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00(void)
{
   12ea8:	b500      	push	{lr}
   12eaa:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12eac:	f7ed fe74 	bl	b98 <Sys_GetCoreID>
   12eb0:	4603      	mov	r3, r0
   12eb2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId])
   12eb4:	4a10      	ldr	r2, [pc, #64]	; (12ef8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x50>)
   12eb6:	9b01      	ldr	r3, [sp, #4]
   12eb8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12ebc:	2b00      	cmp	r3, #0
   12ebe:	d10d      	bne.n	12edc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12ec0:	f7ed fd77 	bl	9b2 <Port_schm_read_msr>
   12ec4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   12ec6:	9b00      	ldr	r3, [sp, #0]
   12ec8:	f003 0301 	and.w	r3, r3, #1
   12ecc:	2b00      	cmp	r3, #0
   12ece:	d100      	bne.n	12ed2 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12ed0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_00[u32CoreId] = msr;
   12ed2:	490a      	ldr	r1, [pc, #40]	; (12efc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x54>)
   12ed4:	9b01      	ldr	r3, [sp, #4]
   12ed6:	9a00      	ldr	r2, [sp, #0]
   12ed8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId]++;
   12edc:	4a06      	ldr	r2, [pc, #24]	; (12ef8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x50>)
   12ede:	9b01      	ldr	r3, [sp, #4]
   12ee0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12ee4:	1c5a      	adds	r2, r3, #1
   12ee6:	4904      	ldr	r1, [pc, #16]	; (12ef8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_00+0x50>)
   12ee8:	9b01      	ldr	r3, [sp, #4]
   12eea:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   12eee:	bf00      	nop
   12ef0:	b003      	add	sp, #12
   12ef2:	f85d fb04 	ldr.w	pc, [sp], #4
   12ef6:	bf00      	nop
   12ef8:	1fff9434 	.word	0x1fff9434
   12efc:	1fff9430 	.word	0x1fff9430

00012f00 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00(void)
{
   12f00:	b500      	push	{lr}
   12f02:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12f04:	f7ed fe48 	bl	b98 <Sys_GetCoreID>
   12f08:	4603      	mov	r3, r0
   12f0a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId]--;
   12f0c:	4a0d      	ldr	r2, [pc, #52]	; (12f44 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x44>)
   12f0e:	9b01      	ldr	r3, [sp, #4]
   12f10:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12f14:	1e5a      	subs	r2, r3, #1
   12f16:	490b      	ldr	r1, [pc, #44]	; (12f44 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x44>)
   12f18:	9b01      	ldr	r3, [sp, #4]
   12f1a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_00[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_00[u32CoreId]))         /*if interrupts were enabled*/
   12f1e:	4a0a      	ldr	r2, [pc, #40]	; (12f48 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x48>)
   12f20:	9b01      	ldr	r3, [sp, #4]
   12f22:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12f26:	f003 0301 	and.w	r3, r3, #1
   12f2a:	2b00      	cmp	r3, #0
   12f2c:	d106      	bne.n	12f3c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x3c>
   12f2e:	4a05      	ldr	r2, [pc, #20]	; (12f44 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x44>)
   12f30:	9b01      	ldr	r3, [sp, #4]
   12f32:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12f36:	2b00      	cmp	r3, #0
   12f38:	d100      	bne.n	12f3c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_00+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   12f3a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12f3c:	bf00      	nop
   12f3e:	b003      	add	sp, #12
   12f40:	f85d fb04 	ldr.w	pc, [sp], #4
   12f44:	1fff9434 	.word	0x1fff9434
   12f48:	1fff9430 	.word	0x1fff9430

00012f4c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01(void)
{
   12f4c:	b500      	push	{lr}
   12f4e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12f50:	f7ed fe22 	bl	b98 <Sys_GetCoreID>
   12f54:	4603      	mov	r3, r0
   12f56:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId])
   12f58:	4a10      	ldr	r2, [pc, #64]	; (12f9c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x50>)
   12f5a:	9b01      	ldr	r3, [sp, #4]
   12f5c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12f60:	2b00      	cmp	r3, #0
   12f62:	d10d      	bne.n	12f80 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   12f64:	f7ed fd25 	bl	9b2 <Port_schm_read_msr>
   12f68:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   12f6a:	9b00      	ldr	r3, [sp, #0]
   12f6c:	f003 0301 	and.w	r3, r3, #1
   12f70:	2b00      	cmp	r3, #0
   12f72:	d100      	bne.n	12f76 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   12f74:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_01[u32CoreId] = msr;
   12f76:	490a      	ldr	r1, [pc, #40]	; (12fa0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x54>)
   12f78:	9b01      	ldr	r3, [sp, #4]
   12f7a:	9a00      	ldr	r2, [sp, #0]
   12f7c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId]++;
   12f80:	4a06      	ldr	r2, [pc, #24]	; (12f9c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x50>)
   12f82:	9b01      	ldr	r3, [sp, #4]
   12f84:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12f88:	1c5a      	adds	r2, r3, #1
   12f8a:	4904      	ldr	r1, [pc, #16]	; (12f9c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_01+0x50>)
   12f8c:	9b01      	ldr	r3, [sp, #4]
   12f8e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   12f92:	bf00      	nop
   12f94:	b003      	add	sp, #12
   12f96:	f85d fb04 	ldr.w	pc, [sp], #4
   12f9a:	bf00      	nop
   12f9c:	1fff943c 	.word	0x1fff943c
   12fa0:	1fff9438 	.word	0x1fff9438

00012fa4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01(void)
{
   12fa4:	b500      	push	{lr}
   12fa6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12fa8:	f7ed fdf6 	bl	b98 <Sys_GetCoreID>
   12fac:	4603      	mov	r3, r0
   12fae:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId]--;
   12fb0:	4a0d      	ldr	r2, [pc, #52]	; (12fe8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x44>)
   12fb2:	9b01      	ldr	r3, [sp, #4]
   12fb4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12fb8:	1e5a      	subs	r2, r3, #1
   12fba:	490b      	ldr	r1, [pc, #44]	; (12fe8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x44>)
   12fbc:	9b01      	ldr	r3, [sp, #4]
   12fbe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_01[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_01[u32CoreId]))         /*if interrupts were enabled*/
   12fc2:	4a0a      	ldr	r2, [pc, #40]	; (12fec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x48>)
   12fc4:	9b01      	ldr	r3, [sp, #4]
   12fc6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12fca:	f003 0301 	and.w	r3, r3, #1
   12fce:	2b00      	cmp	r3, #0
   12fd0:	d106      	bne.n	12fe0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x3c>
   12fd2:	4a05      	ldr	r2, [pc, #20]	; (12fe8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x44>)
   12fd4:	9b01      	ldr	r3, [sp, #4]
   12fd6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   12fda:	2b00      	cmp	r3, #0
   12fdc:	d100      	bne.n	12fe0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_01+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   12fde:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   12fe0:	bf00      	nop
   12fe2:	b003      	add	sp, #12
   12fe4:	f85d fb04 	ldr.w	pc, [sp], #4
   12fe8:	1fff943c 	.word	0x1fff943c
   12fec:	1fff9438 	.word	0x1fff9438

00012ff0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02(void)
{
   12ff0:	b500      	push	{lr}
   12ff2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   12ff4:	f7ed fdd0 	bl	b98 <Sys_GetCoreID>
   12ff8:	4603      	mov	r3, r0
   12ffa:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId])
   12ffc:	4a10      	ldr	r2, [pc, #64]	; (13040 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x50>)
   12ffe:	9b01      	ldr	r3, [sp, #4]
   13000:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13004:	2b00      	cmp	r3, #0
   13006:	d10d      	bne.n	13024 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13008:	f7ed fcd3 	bl	9b2 <Port_schm_read_msr>
   1300c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1300e:	9b00      	ldr	r3, [sp, #0]
   13010:	f003 0301 	and.w	r3, r3, #1
   13014:	2b00      	cmp	r3, #0
   13016:	d100      	bne.n	1301a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13018:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_02[u32CoreId] = msr;
   1301a:	490a      	ldr	r1, [pc, #40]	; (13044 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x54>)
   1301c:	9b01      	ldr	r3, [sp, #4]
   1301e:	9a00      	ldr	r2, [sp, #0]
   13020:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId]++;
   13024:	4a06      	ldr	r2, [pc, #24]	; (13040 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x50>)
   13026:	9b01      	ldr	r3, [sp, #4]
   13028:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1302c:	1c5a      	adds	r2, r3, #1
   1302e:	4904      	ldr	r1, [pc, #16]	; (13040 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_02+0x50>)
   13030:	9b01      	ldr	r3, [sp, #4]
   13032:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   13036:	bf00      	nop
   13038:	b003      	add	sp, #12
   1303a:	f85d fb04 	ldr.w	pc, [sp], #4
   1303e:	bf00      	nop
   13040:	1fff9444 	.word	0x1fff9444
   13044:	1fff9440 	.word	0x1fff9440

00013048 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02(void)
{
   13048:	b500      	push	{lr}
   1304a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1304c:	f7ed fda4 	bl	b98 <Sys_GetCoreID>
   13050:	4603      	mov	r3, r0
   13052:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId]--;
   13054:	4a0d      	ldr	r2, [pc, #52]	; (1308c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x44>)
   13056:	9b01      	ldr	r3, [sp, #4]
   13058:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1305c:	1e5a      	subs	r2, r3, #1
   1305e:	490b      	ldr	r1, [pc, #44]	; (1308c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x44>)
   13060:	9b01      	ldr	r3, [sp, #4]
   13062:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_02[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_02[u32CoreId]))         /*if interrupts were enabled*/
   13066:	4a0a      	ldr	r2, [pc, #40]	; (13090 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x48>)
   13068:	9b01      	ldr	r3, [sp, #4]
   1306a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1306e:	f003 0301 	and.w	r3, r3, #1
   13072:	2b00      	cmp	r3, #0
   13074:	d106      	bne.n	13084 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x3c>
   13076:	4a05      	ldr	r2, [pc, #20]	; (1308c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x44>)
   13078:	9b01      	ldr	r3, [sp, #4]
   1307a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1307e:	2b00      	cmp	r3, #0
   13080:	d100      	bne.n	13084 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_02+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   13082:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13084:	bf00      	nop
   13086:	b003      	add	sp, #12
   13088:	f85d fb04 	ldr.w	pc, [sp], #4
   1308c:	1fff9444 	.word	0x1fff9444
   13090:	1fff9440 	.word	0x1fff9440

00013094 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03(void)
{
   13094:	b500      	push	{lr}
   13096:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13098:	f7ed fd7e 	bl	b98 <Sys_GetCoreID>
   1309c:	4603      	mov	r3, r0
   1309e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId])
   130a0:	4a10      	ldr	r2, [pc, #64]	; (130e4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x50>)
   130a2:	9b01      	ldr	r3, [sp, #4]
   130a4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   130a8:	2b00      	cmp	r3, #0
   130aa:	d10d      	bne.n	130c8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   130ac:	f7ed fc81 	bl	9b2 <Port_schm_read_msr>
   130b0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   130b2:	9b00      	ldr	r3, [sp, #0]
   130b4:	f003 0301 	and.w	r3, r3, #1
   130b8:	2b00      	cmp	r3, #0
   130ba:	d100      	bne.n	130be <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   130bc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_03[u32CoreId] = msr;
   130be:	490a      	ldr	r1, [pc, #40]	; (130e8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x54>)
   130c0:	9b01      	ldr	r3, [sp, #4]
   130c2:	9a00      	ldr	r2, [sp, #0]
   130c4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId]++;
   130c8:	4a06      	ldr	r2, [pc, #24]	; (130e4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x50>)
   130ca:	9b01      	ldr	r3, [sp, #4]
   130cc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   130d0:	1c5a      	adds	r2, r3, #1
   130d2:	4904      	ldr	r1, [pc, #16]	; (130e4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_03+0x50>)
   130d4:	9b01      	ldr	r3, [sp, #4]
   130d6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   130da:	bf00      	nop
   130dc:	b003      	add	sp, #12
   130de:	f85d fb04 	ldr.w	pc, [sp], #4
   130e2:	bf00      	nop
   130e4:	1fff944c 	.word	0x1fff944c
   130e8:	1fff9448 	.word	0x1fff9448

000130ec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03(void)
{
   130ec:	b500      	push	{lr}
   130ee:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   130f0:	f7ed fd52 	bl	b98 <Sys_GetCoreID>
   130f4:	4603      	mov	r3, r0
   130f6:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId]--;
   130f8:	4a0d      	ldr	r2, [pc, #52]	; (13130 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x44>)
   130fa:	9b01      	ldr	r3, [sp, #4]
   130fc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13100:	1e5a      	subs	r2, r3, #1
   13102:	490b      	ldr	r1, [pc, #44]	; (13130 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x44>)
   13104:	9b01      	ldr	r3, [sp, #4]
   13106:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_03[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_03[u32CoreId]))         /*if interrupts were enabled*/
   1310a:	4a0a      	ldr	r2, [pc, #40]	; (13134 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x48>)
   1310c:	9b01      	ldr	r3, [sp, #4]
   1310e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13112:	f003 0301 	and.w	r3, r3, #1
   13116:	2b00      	cmp	r3, #0
   13118:	d106      	bne.n	13128 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x3c>
   1311a:	4a05      	ldr	r2, [pc, #20]	; (13130 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x44>)
   1311c:	9b01      	ldr	r3, [sp, #4]
   1311e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13122:	2b00      	cmp	r3, #0
   13124:	d100      	bne.n	13128 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_03+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   13126:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13128:	bf00      	nop
   1312a:	b003      	add	sp, #12
   1312c:	f85d fb04 	ldr.w	pc, [sp], #4
   13130:	1fff944c 	.word	0x1fff944c
   13134:	1fff9448 	.word	0x1fff9448

00013138 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04(void)
{
   13138:	b500      	push	{lr}
   1313a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1313c:	f7ed fd2c 	bl	b98 <Sys_GetCoreID>
   13140:	4603      	mov	r3, r0
   13142:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId])
   13144:	4a10      	ldr	r2, [pc, #64]	; (13188 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x50>)
   13146:	9b01      	ldr	r3, [sp, #4]
   13148:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1314c:	2b00      	cmp	r3, #0
   1314e:	d10d      	bne.n	1316c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13150:	f7ed fc2f 	bl	9b2 <Port_schm_read_msr>
   13154:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   13156:	9b00      	ldr	r3, [sp, #0]
   13158:	f003 0301 	and.w	r3, r3, #1
   1315c:	2b00      	cmp	r3, #0
   1315e:	d100      	bne.n	13162 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13160:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_04[u32CoreId] = msr;
   13162:	490a      	ldr	r1, [pc, #40]	; (1318c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x54>)
   13164:	9b01      	ldr	r3, [sp, #4]
   13166:	9a00      	ldr	r2, [sp, #0]
   13168:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId]++;
   1316c:	4a06      	ldr	r2, [pc, #24]	; (13188 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x50>)
   1316e:	9b01      	ldr	r3, [sp, #4]
   13170:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13174:	1c5a      	adds	r2, r3, #1
   13176:	4904      	ldr	r1, [pc, #16]	; (13188 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_04+0x50>)
   13178:	9b01      	ldr	r3, [sp, #4]
   1317a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1317e:	bf00      	nop
   13180:	b003      	add	sp, #12
   13182:	f85d fb04 	ldr.w	pc, [sp], #4
   13186:	bf00      	nop
   13188:	1fff9454 	.word	0x1fff9454
   1318c:	1fff9450 	.word	0x1fff9450

00013190 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04(void)
{
   13190:	b500      	push	{lr}
   13192:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13194:	f7ed fd00 	bl	b98 <Sys_GetCoreID>
   13198:	4603      	mov	r3, r0
   1319a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId]--;
   1319c:	4a0d      	ldr	r2, [pc, #52]	; (131d4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x44>)
   1319e:	9b01      	ldr	r3, [sp, #4]
   131a0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   131a4:	1e5a      	subs	r2, r3, #1
   131a6:	490b      	ldr	r1, [pc, #44]	; (131d4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x44>)
   131a8:	9b01      	ldr	r3, [sp, #4]
   131aa:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_04[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_04[u32CoreId]))         /*if interrupts were enabled*/
   131ae:	4a0a      	ldr	r2, [pc, #40]	; (131d8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x48>)
   131b0:	9b01      	ldr	r3, [sp, #4]
   131b2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   131b6:	f003 0301 	and.w	r3, r3, #1
   131ba:	2b00      	cmp	r3, #0
   131bc:	d106      	bne.n	131cc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x3c>
   131be:	4a05      	ldr	r2, [pc, #20]	; (131d4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x44>)
   131c0:	9b01      	ldr	r3, [sp, #4]
   131c2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   131c6:	2b00      	cmp	r3, #0
   131c8:	d100      	bne.n	131cc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_04+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   131ca:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   131cc:	bf00      	nop
   131ce:	b003      	add	sp, #12
   131d0:	f85d fb04 	ldr.w	pc, [sp], #4
   131d4:	1fff9454 	.word	0x1fff9454
   131d8:	1fff9450 	.word	0x1fff9450

000131dc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05(void)
{
   131dc:	b500      	push	{lr}
   131de:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   131e0:	f7ed fcda 	bl	b98 <Sys_GetCoreID>
   131e4:	4603      	mov	r3, r0
   131e6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId])
   131e8:	4a10      	ldr	r2, [pc, #64]	; (1322c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x50>)
   131ea:	9b01      	ldr	r3, [sp, #4]
   131ec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   131f0:	2b00      	cmp	r3, #0
   131f2:	d10d      	bne.n	13210 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   131f4:	f7ed fbdd 	bl	9b2 <Port_schm_read_msr>
   131f8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   131fa:	9b00      	ldr	r3, [sp, #0]
   131fc:	f003 0301 	and.w	r3, r3, #1
   13200:	2b00      	cmp	r3, #0
   13202:	d100      	bne.n	13206 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13204:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_05[u32CoreId] = msr;
   13206:	490a      	ldr	r1, [pc, #40]	; (13230 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x54>)
   13208:	9b01      	ldr	r3, [sp, #4]
   1320a:	9a00      	ldr	r2, [sp, #0]
   1320c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId]++;
   13210:	4a06      	ldr	r2, [pc, #24]	; (1322c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x50>)
   13212:	9b01      	ldr	r3, [sp, #4]
   13214:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13218:	1c5a      	adds	r2, r3, #1
   1321a:	4904      	ldr	r1, [pc, #16]	; (1322c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_05+0x50>)
   1321c:	9b01      	ldr	r3, [sp, #4]
   1321e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   13222:	bf00      	nop
   13224:	b003      	add	sp, #12
   13226:	f85d fb04 	ldr.w	pc, [sp], #4
   1322a:	bf00      	nop
   1322c:	1fff945c 	.word	0x1fff945c
   13230:	1fff9458 	.word	0x1fff9458

00013234 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05(void)
{
   13234:	b500      	push	{lr}
   13236:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13238:	f7ed fcae 	bl	b98 <Sys_GetCoreID>
   1323c:	4603      	mov	r3, r0
   1323e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId]--;
   13240:	4a0d      	ldr	r2, [pc, #52]	; (13278 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x44>)
   13242:	9b01      	ldr	r3, [sp, #4]
   13244:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13248:	1e5a      	subs	r2, r3, #1
   1324a:	490b      	ldr	r1, [pc, #44]	; (13278 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x44>)
   1324c:	9b01      	ldr	r3, [sp, #4]
   1324e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_05[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_05[u32CoreId]))         /*if interrupts were enabled*/
   13252:	4a0a      	ldr	r2, [pc, #40]	; (1327c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x48>)
   13254:	9b01      	ldr	r3, [sp, #4]
   13256:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1325a:	f003 0301 	and.w	r3, r3, #1
   1325e:	2b00      	cmp	r3, #0
   13260:	d106      	bne.n	13270 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x3c>
   13262:	4a05      	ldr	r2, [pc, #20]	; (13278 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x44>)
   13264:	9b01      	ldr	r3, [sp, #4]
   13266:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1326a:	2b00      	cmp	r3, #0
   1326c:	d100      	bne.n	13270 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_05+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1326e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13270:	bf00      	nop
   13272:	b003      	add	sp, #12
   13274:	f85d fb04 	ldr.w	pc, [sp], #4
   13278:	1fff945c 	.word	0x1fff945c
   1327c:	1fff9458 	.word	0x1fff9458

00013280 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06(void)
{
   13280:	b500      	push	{lr}
   13282:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13284:	f7ed fc88 	bl	b98 <Sys_GetCoreID>
   13288:	4603      	mov	r3, r0
   1328a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId])
   1328c:	4a10      	ldr	r2, [pc, #64]	; (132d0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x50>)
   1328e:	9b01      	ldr	r3, [sp, #4]
   13290:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13294:	2b00      	cmp	r3, #0
   13296:	d10d      	bne.n	132b4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13298:	f7ed fb8b 	bl	9b2 <Port_schm_read_msr>
   1329c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1329e:	9b00      	ldr	r3, [sp, #0]
   132a0:	f003 0301 	and.w	r3, r3, #1
   132a4:	2b00      	cmp	r3, #0
   132a6:	d100      	bne.n	132aa <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   132a8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_06[u32CoreId] = msr;
   132aa:	490a      	ldr	r1, [pc, #40]	; (132d4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x54>)
   132ac:	9b01      	ldr	r3, [sp, #4]
   132ae:	9a00      	ldr	r2, [sp, #0]
   132b0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId]++;
   132b4:	4a06      	ldr	r2, [pc, #24]	; (132d0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x50>)
   132b6:	9b01      	ldr	r3, [sp, #4]
   132b8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   132bc:	1c5a      	adds	r2, r3, #1
   132be:	4904      	ldr	r1, [pc, #16]	; (132d0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_06+0x50>)
   132c0:	9b01      	ldr	r3, [sp, #4]
   132c2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   132c6:	bf00      	nop
   132c8:	b003      	add	sp, #12
   132ca:	f85d fb04 	ldr.w	pc, [sp], #4
   132ce:	bf00      	nop
   132d0:	1fff9464 	.word	0x1fff9464
   132d4:	1fff9460 	.word	0x1fff9460

000132d8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06(void)
{
   132d8:	b500      	push	{lr}
   132da:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   132dc:	f7ed fc5c 	bl	b98 <Sys_GetCoreID>
   132e0:	4603      	mov	r3, r0
   132e2:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId]--;
   132e4:	4a0d      	ldr	r2, [pc, #52]	; (1331c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x44>)
   132e6:	9b01      	ldr	r3, [sp, #4]
   132e8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   132ec:	1e5a      	subs	r2, r3, #1
   132ee:	490b      	ldr	r1, [pc, #44]	; (1331c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x44>)
   132f0:	9b01      	ldr	r3, [sp, #4]
   132f2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_06[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_06[u32CoreId]))         /*if interrupts were enabled*/
   132f6:	4a0a      	ldr	r2, [pc, #40]	; (13320 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x48>)
   132f8:	9b01      	ldr	r3, [sp, #4]
   132fa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   132fe:	f003 0301 	and.w	r3, r3, #1
   13302:	2b00      	cmp	r3, #0
   13304:	d106      	bne.n	13314 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x3c>
   13306:	4a05      	ldr	r2, [pc, #20]	; (1331c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x44>)
   13308:	9b01      	ldr	r3, [sp, #4]
   1330a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1330e:	2b00      	cmp	r3, #0
   13310:	d100      	bne.n	13314 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_06+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   13312:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13314:	bf00      	nop
   13316:	b003      	add	sp, #12
   13318:	f85d fb04 	ldr.w	pc, [sp], #4
   1331c:	1fff9464 	.word	0x1fff9464
   13320:	1fff9460 	.word	0x1fff9460

00013324 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07(void)
{
   13324:	b500      	push	{lr}
   13326:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13328:	f7ed fc36 	bl	b98 <Sys_GetCoreID>
   1332c:	4603      	mov	r3, r0
   1332e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId])
   13330:	4a10      	ldr	r2, [pc, #64]	; (13374 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x50>)
   13332:	9b01      	ldr	r3, [sp, #4]
   13334:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13338:	2b00      	cmp	r3, #0
   1333a:	d10d      	bne.n	13358 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   1333c:	f7ed fb39 	bl	9b2 <Port_schm_read_msr>
   13340:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   13342:	9b00      	ldr	r3, [sp, #0]
   13344:	f003 0301 	and.w	r3, r3, #1
   13348:	2b00      	cmp	r3, #0
   1334a:	d100      	bne.n	1334e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   1334c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_07[u32CoreId] = msr;
   1334e:	490a      	ldr	r1, [pc, #40]	; (13378 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x54>)
   13350:	9b01      	ldr	r3, [sp, #4]
   13352:	9a00      	ldr	r2, [sp, #0]
   13354:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId]++;
   13358:	4a06      	ldr	r2, [pc, #24]	; (13374 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x50>)
   1335a:	9b01      	ldr	r3, [sp, #4]
   1335c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13360:	1c5a      	adds	r2, r3, #1
   13362:	4904      	ldr	r1, [pc, #16]	; (13374 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_07+0x50>)
   13364:	9b01      	ldr	r3, [sp, #4]
   13366:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1336a:	bf00      	nop
   1336c:	b003      	add	sp, #12
   1336e:	f85d fb04 	ldr.w	pc, [sp], #4
   13372:	bf00      	nop
   13374:	1fff946c 	.word	0x1fff946c
   13378:	1fff9468 	.word	0x1fff9468

0001337c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07(void)
{
   1337c:	b500      	push	{lr}
   1337e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13380:	f7ed fc0a 	bl	b98 <Sys_GetCoreID>
   13384:	4603      	mov	r3, r0
   13386:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId]--;
   13388:	4a0d      	ldr	r2, [pc, #52]	; (133c0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x44>)
   1338a:	9b01      	ldr	r3, [sp, #4]
   1338c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13390:	1e5a      	subs	r2, r3, #1
   13392:	490b      	ldr	r1, [pc, #44]	; (133c0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x44>)
   13394:	9b01      	ldr	r3, [sp, #4]
   13396:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_07[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_07[u32CoreId]))         /*if interrupts were enabled*/
   1339a:	4a0a      	ldr	r2, [pc, #40]	; (133c4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x48>)
   1339c:	9b01      	ldr	r3, [sp, #4]
   1339e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   133a2:	f003 0301 	and.w	r3, r3, #1
   133a6:	2b00      	cmp	r3, #0
   133a8:	d106      	bne.n	133b8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x3c>
   133aa:	4a05      	ldr	r2, [pc, #20]	; (133c0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x44>)
   133ac:	9b01      	ldr	r3, [sp, #4]
   133ae:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   133b2:	2b00      	cmp	r3, #0
   133b4:	d100      	bne.n	133b8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_07+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   133b6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   133b8:	bf00      	nop
   133ba:	b003      	add	sp, #12
   133bc:	f85d fb04 	ldr.w	pc, [sp], #4
   133c0:	1fff946c 	.word	0x1fff946c
   133c4:	1fff9468 	.word	0x1fff9468

000133c8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08(void)
{
   133c8:	b500      	push	{lr}
   133ca:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   133cc:	f7ed fbe4 	bl	b98 <Sys_GetCoreID>
   133d0:	4603      	mov	r3, r0
   133d2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId])
   133d4:	4a10      	ldr	r2, [pc, #64]	; (13418 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x50>)
   133d6:	9b01      	ldr	r3, [sp, #4]
   133d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   133dc:	2b00      	cmp	r3, #0
   133de:	d10d      	bne.n	133fc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   133e0:	f7ed fae7 	bl	9b2 <Port_schm_read_msr>
   133e4:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   133e6:	9b00      	ldr	r3, [sp, #0]
   133e8:	f003 0301 	and.w	r3, r3, #1
   133ec:	2b00      	cmp	r3, #0
   133ee:	d100      	bne.n	133f2 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   133f0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_08[u32CoreId] = msr;
   133f2:	490a      	ldr	r1, [pc, #40]	; (1341c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x54>)
   133f4:	9b01      	ldr	r3, [sp, #4]
   133f6:	9a00      	ldr	r2, [sp, #0]
   133f8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId]++;
   133fc:	4a06      	ldr	r2, [pc, #24]	; (13418 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x50>)
   133fe:	9b01      	ldr	r3, [sp, #4]
   13400:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13404:	1c5a      	adds	r2, r3, #1
   13406:	4904      	ldr	r1, [pc, #16]	; (13418 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_08+0x50>)
   13408:	9b01      	ldr	r3, [sp, #4]
   1340a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1340e:	bf00      	nop
   13410:	b003      	add	sp, #12
   13412:	f85d fb04 	ldr.w	pc, [sp], #4
   13416:	bf00      	nop
   13418:	1fff9474 	.word	0x1fff9474
   1341c:	1fff9470 	.word	0x1fff9470

00013420 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08(void)
{
   13420:	b500      	push	{lr}
   13422:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13424:	f7ed fbb8 	bl	b98 <Sys_GetCoreID>
   13428:	4603      	mov	r3, r0
   1342a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId]--;
   1342c:	4a0d      	ldr	r2, [pc, #52]	; (13464 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x44>)
   1342e:	9b01      	ldr	r3, [sp, #4]
   13430:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13434:	1e5a      	subs	r2, r3, #1
   13436:	490b      	ldr	r1, [pc, #44]	; (13464 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x44>)
   13438:	9b01      	ldr	r3, [sp, #4]
   1343a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_08[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_08[u32CoreId]))         /*if interrupts were enabled*/
   1343e:	4a0a      	ldr	r2, [pc, #40]	; (13468 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x48>)
   13440:	9b01      	ldr	r3, [sp, #4]
   13442:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13446:	f003 0301 	and.w	r3, r3, #1
   1344a:	2b00      	cmp	r3, #0
   1344c:	d106      	bne.n	1345c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x3c>
   1344e:	4a05      	ldr	r2, [pc, #20]	; (13464 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x44>)
   13450:	9b01      	ldr	r3, [sp, #4]
   13452:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13456:	2b00      	cmp	r3, #0
   13458:	d100      	bne.n	1345c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_08+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1345a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   1345c:	bf00      	nop
   1345e:	b003      	add	sp, #12
   13460:	f85d fb04 	ldr.w	pc, [sp], #4
   13464:	1fff9474 	.word	0x1fff9474
   13468:	1fff9470 	.word	0x1fff9470

0001346c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09(void)
{
   1346c:	b500      	push	{lr}
   1346e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13470:	f7ed fb92 	bl	b98 <Sys_GetCoreID>
   13474:	4603      	mov	r3, r0
   13476:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId])
   13478:	4a10      	ldr	r2, [pc, #64]	; (134bc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x50>)
   1347a:	9b01      	ldr	r3, [sp, #4]
   1347c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13480:	2b00      	cmp	r3, #0
   13482:	d10d      	bne.n	134a0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13484:	f7ed fa95 	bl	9b2 <Port_schm_read_msr>
   13488:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1348a:	9b00      	ldr	r3, [sp, #0]
   1348c:	f003 0301 	and.w	r3, r3, #1
   13490:	2b00      	cmp	r3, #0
   13492:	d100      	bne.n	13496 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13494:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_09[u32CoreId] = msr;
   13496:	490a      	ldr	r1, [pc, #40]	; (134c0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x54>)
   13498:	9b01      	ldr	r3, [sp, #4]
   1349a:	9a00      	ldr	r2, [sp, #0]
   1349c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId]++;
   134a0:	4a06      	ldr	r2, [pc, #24]	; (134bc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x50>)
   134a2:	9b01      	ldr	r3, [sp, #4]
   134a4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   134a8:	1c5a      	adds	r2, r3, #1
   134aa:	4904      	ldr	r1, [pc, #16]	; (134bc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_09+0x50>)
   134ac:	9b01      	ldr	r3, [sp, #4]
   134ae:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   134b2:	bf00      	nop
   134b4:	b003      	add	sp, #12
   134b6:	f85d fb04 	ldr.w	pc, [sp], #4
   134ba:	bf00      	nop
   134bc:	1fff947c 	.word	0x1fff947c
   134c0:	1fff9478 	.word	0x1fff9478

000134c4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09(void)
{
   134c4:	b500      	push	{lr}
   134c6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   134c8:	f7ed fb66 	bl	b98 <Sys_GetCoreID>
   134cc:	4603      	mov	r3, r0
   134ce:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId]--;
   134d0:	4a0d      	ldr	r2, [pc, #52]	; (13508 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x44>)
   134d2:	9b01      	ldr	r3, [sp, #4]
   134d4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   134d8:	1e5a      	subs	r2, r3, #1
   134da:	490b      	ldr	r1, [pc, #44]	; (13508 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x44>)
   134dc:	9b01      	ldr	r3, [sp, #4]
   134de:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_09[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_09[u32CoreId]))         /*if interrupts were enabled*/
   134e2:	4a0a      	ldr	r2, [pc, #40]	; (1350c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x48>)
   134e4:	9b01      	ldr	r3, [sp, #4]
   134e6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   134ea:	f003 0301 	and.w	r3, r3, #1
   134ee:	2b00      	cmp	r3, #0
   134f0:	d106      	bne.n	13500 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x3c>
   134f2:	4a05      	ldr	r2, [pc, #20]	; (13508 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x44>)
   134f4:	9b01      	ldr	r3, [sp, #4]
   134f6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   134fa:	2b00      	cmp	r3, #0
   134fc:	d100      	bne.n	13500 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_09+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   134fe:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13500:	bf00      	nop
   13502:	b003      	add	sp, #12
   13504:	f85d fb04 	ldr.w	pc, [sp], #4
   13508:	1fff947c 	.word	0x1fff947c
   1350c:	1fff9478 	.word	0x1fff9478

00013510 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10(void)
{
   13510:	b500      	push	{lr}
   13512:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13514:	f7ed fb40 	bl	b98 <Sys_GetCoreID>
   13518:	4603      	mov	r3, r0
   1351a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId])
   1351c:	4a10      	ldr	r2, [pc, #64]	; (13560 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x50>)
   1351e:	9b01      	ldr	r3, [sp, #4]
   13520:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13524:	2b00      	cmp	r3, #0
   13526:	d10d      	bne.n	13544 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13528:	f7ed fa43 	bl	9b2 <Port_schm_read_msr>
   1352c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1352e:	9b00      	ldr	r3, [sp, #0]
   13530:	f003 0301 	and.w	r3, r3, #1
   13534:	2b00      	cmp	r3, #0
   13536:	d100      	bne.n	1353a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13538:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_10[u32CoreId] = msr;
   1353a:	490a      	ldr	r1, [pc, #40]	; (13564 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x54>)
   1353c:	9b01      	ldr	r3, [sp, #4]
   1353e:	9a00      	ldr	r2, [sp, #0]
   13540:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId]++;
   13544:	4a06      	ldr	r2, [pc, #24]	; (13560 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x50>)
   13546:	9b01      	ldr	r3, [sp, #4]
   13548:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1354c:	1c5a      	adds	r2, r3, #1
   1354e:	4904      	ldr	r1, [pc, #16]	; (13560 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_10+0x50>)
   13550:	9b01      	ldr	r3, [sp, #4]
   13552:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   13556:	bf00      	nop
   13558:	b003      	add	sp, #12
   1355a:	f85d fb04 	ldr.w	pc, [sp], #4
   1355e:	bf00      	nop
   13560:	1fff9484 	.word	0x1fff9484
   13564:	1fff9480 	.word	0x1fff9480

00013568 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10(void)
{
   13568:	b500      	push	{lr}
   1356a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1356c:	f7ed fb14 	bl	b98 <Sys_GetCoreID>
   13570:	4603      	mov	r3, r0
   13572:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId]--;
   13574:	4a0d      	ldr	r2, [pc, #52]	; (135ac <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x44>)
   13576:	9b01      	ldr	r3, [sp, #4]
   13578:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1357c:	1e5a      	subs	r2, r3, #1
   1357e:	490b      	ldr	r1, [pc, #44]	; (135ac <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x44>)
   13580:	9b01      	ldr	r3, [sp, #4]
   13582:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_10[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_10[u32CoreId]))         /*if interrupts were enabled*/
   13586:	4a0a      	ldr	r2, [pc, #40]	; (135b0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x48>)
   13588:	9b01      	ldr	r3, [sp, #4]
   1358a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1358e:	f003 0301 	and.w	r3, r3, #1
   13592:	2b00      	cmp	r3, #0
   13594:	d106      	bne.n	135a4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x3c>
   13596:	4a05      	ldr	r2, [pc, #20]	; (135ac <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x44>)
   13598:	9b01      	ldr	r3, [sp, #4]
   1359a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1359e:	2b00      	cmp	r3, #0
   135a0:	d100      	bne.n	135a4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_10+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   135a2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   135a4:	bf00      	nop
   135a6:	b003      	add	sp, #12
   135a8:	f85d fb04 	ldr.w	pc, [sp], #4
   135ac:	1fff9484 	.word	0x1fff9484
   135b0:	1fff9480 	.word	0x1fff9480

000135b4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11(void)
{
   135b4:	b500      	push	{lr}
   135b6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   135b8:	f7ed faee 	bl	b98 <Sys_GetCoreID>
   135bc:	4603      	mov	r3, r0
   135be:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId])
   135c0:	4a10      	ldr	r2, [pc, #64]	; (13604 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x50>)
   135c2:	9b01      	ldr	r3, [sp, #4]
   135c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   135c8:	2b00      	cmp	r3, #0
   135ca:	d10d      	bne.n	135e8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   135cc:	f7ed f9f1 	bl	9b2 <Port_schm_read_msr>
   135d0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   135d2:	9b00      	ldr	r3, [sp, #0]
   135d4:	f003 0301 	and.w	r3, r3, #1
   135d8:	2b00      	cmp	r3, #0
   135da:	d100      	bne.n	135de <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   135dc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_11[u32CoreId] = msr;
   135de:	490a      	ldr	r1, [pc, #40]	; (13608 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x54>)
   135e0:	9b01      	ldr	r3, [sp, #4]
   135e2:	9a00      	ldr	r2, [sp, #0]
   135e4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId]++;
   135e8:	4a06      	ldr	r2, [pc, #24]	; (13604 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x50>)
   135ea:	9b01      	ldr	r3, [sp, #4]
   135ec:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   135f0:	1c5a      	adds	r2, r3, #1
   135f2:	4904      	ldr	r1, [pc, #16]	; (13604 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_11+0x50>)
   135f4:	9b01      	ldr	r3, [sp, #4]
   135f6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   135fa:	bf00      	nop
   135fc:	b003      	add	sp, #12
   135fe:	f85d fb04 	ldr.w	pc, [sp], #4
   13602:	bf00      	nop
   13604:	1fff948c 	.word	0x1fff948c
   13608:	1fff9488 	.word	0x1fff9488

0001360c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11(void)
{
   1360c:	b500      	push	{lr}
   1360e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13610:	f7ed fac2 	bl	b98 <Sys_GetCoreID>
   13614:	4603      	mov	r3, r0
   13616:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId]--;
   13618:	4a0d      	ldr	r2, [pc, #52]	; (13650 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x44>)
   1361a:	9b01      	ldr	r3, [sp, #4]
   1361c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13620:	1e5a      	subs	r2, r3, #1
   13622:	490b      	ldr	r1, [pc, #44]	; (13650 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x44>)
   13624:	9b01      	ldr	r3, [sp, #4]
   13626:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_11[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_11[u32CoreId]))         /*if interrupts were enabled*/
   1362a:	4a0a      	ldr	r2, [pc, #40]	; (13654 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x48>)
   1362c:	9b01      	ldr	r3, [sp, #4]
   1362e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13632:	f003 0301 	and.w	r3, r3, #1
   13636:	2b00      	cmp	r3, #0
   13638:	d106      	bne.n	13648 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x3c>
   1363a:	4a05      	ldr	r2, [pc, #20]	; (13650 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x44>)
   1363c:	9b01      	ldr	r3, [sp, #4]
   1363e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13642:	2b00      	cmp	r3, #0
   13644:	d100      	bne.n	13648 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_11+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   13646:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13648:	bf00      	nop
   1364a:	b003      	add	sp, #12
   1364c:	f85d fb04 	ldr.w	pc, [sp], #4
   13650:	1fff948c 	.word	0x1fff948c
   13654:	1fff9488 	.word	0x1fff9488

00013658 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12(void)
{
   13658:	b500      	push	{lr}
   1365a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1365c:	f7ed fa9c 	bl	b98 <Sys_GetCoreID>
   13660:	4603      	mov	r3, r0
   13662:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId])
   13664:	4a10      	ldr	r2, [pc, #64]	; (136a8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x50>)
   13666:	9b01      	ldr	r3, [sp, #4]
   13668:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1366c:	2b00      	cmp	r3, #0
   1366e:	d10d      	bne.n	1368c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13670:	f7ed f99f 	bl	9b2 <Port_schm_read_msr>
   13674:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   13676:	9b00      	ldr	r3, [sp, #0]
   13678:	f003 0301 	and.w	r3, r3, #1
   1367c:	2b00      	cmp	r3, #0
   1367e:	d100      	bne.n	13682 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13680:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_12[u32CoreId] = msr;
   13682:	490a      	ldr	r1, [pc, #40]	; (136ac <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x54>)
   13684:	9b01      	ldr	r3, [sp, #4]
   13686:	9a00      	ldr	r2, [sp, #0]
   13688:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId]++;
   1368c:	4a06      	ldr	r2, [pc, #24]	; (136a8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x50>)
   1368e:	9b01      	ldr	r3, [sp, #4]
   13690:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13694:	1c5a      	adds	r2, r3, #1
   13696:	4904      	ldr	r1, [pc, #16]	; (136a8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_12+0x50>)
   13698:	9b01      	ldr	r3, [sp, #4]
   1369a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1369e:	bf00      	nop
   136a0:	b003      	add	sp, #12
   136a2:	f85d fb04 	ldr.w	pc, [sp], #4
   136a6:	bf00      	nop
   136a8:	1fff9494 	.word	0x1fff9494
   136ac:	1fff9490 	.word	0x1fff9490

000136b0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12(void)
{
   136b0:	b500      	push	{lr}
   136b2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   136b4:	f7ed fa70 	bl	b98 <Sys_GetCoreID>
   136b8:	4603      	mov	r3, r0
   136ba:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId]--;
   136bc:	4a0d      	ldr	r2, [pc, #52]	; (136f4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x44>)
   136be:	9b01      	ldr	r3, [sp, #4]
   136c0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   136c4:	1e5a      	subs	r2, r3, #1
   136c6:	490b      	ldr	r1, [pc, #44]	; (136f4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x44>)
   136c8:	9b01      	ldr	r3, [sp, #4]
   136ca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_12[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_12[u32CoreId]))         /*if interrupts were enabled*/
   136ce:	4a0a      	ldr	r2, [pc, #40]	; (136f8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x48>)
   136d0:	9b01      	ldr	r3, [sp, #4]
   136d2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   136d6:	f003 0301 	and.w	r3, r3, #1
   136da:	2b00      	cmp	r3, #0
   136dc:	d106      	bne.n	136ec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x3c>
   136de:	4a05      	ldr	r2, [pc, #20]	; (136f4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x44>)
   136e0:	9b01      	ldr	r3, [sp, #4]
   136e2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   136e6:	2b00      	cmp	r3, #0
   136e8:	d100      	bne.n	136ec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_12+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   136ea:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   136ec:	bf00      	nop
   136ee:	b003      	add	sp, #12
   136f0:	f85d fb04 	ldr.w	pc, [sp], #4
   136f4:	1fff9494 	.word	0x1fff9494
   136f8:	1fff9490 	.word	0x1fff9490

000136fc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13(void)
{
   136fc:	b500      	push	{lr}
   136fe:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13700:	f7ed fa4a 	bl	b98 <Sys_GetCoreID>
   13704:	4603      	mov	r3, r0
   13706:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId])
   13708:	4a10      	ldr	r2, [pc, #64]	; (1374c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x50>)
   1370a:	9b01      	ldr	r3, [sp, #4]
   1370c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13710:	2b00      	cmp	r3, #0
   13712:	d10d      	bne.n	13730 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13714:	f7ed f94d 	bl	9b2 <Port_schm_read_msr>
   13718:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   1371a:	9b00      	ldr	r3, [sp, #0]
   1371c:	f003 0301 	and.w	r3, r3, #1
   13720:	2b00      	cmp	r3, #0
   13722:	d100      	bne.n	13726 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13724:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_13[u32CoreId] = msr;
   13726:	490a      	ldr	r1, [pc, #40]	; (13750 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x54>)
   13728:	9b01      	ldr	r3, [sp, #4]
   1372a:	9a00      	ldr	r2, [sp, #0]
   1372c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId]++;
   13730:	4a06      	ldr	r2, [pc, #24]	; (1374c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x50>)
   13732:	9b01      	ldr	r3, [sp, #4]
   13734:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13738:	1c5a      	adds	r2, r3, #1
   1373a:	4904      	ldr	r1, [pc, #16]	; (1374c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_13+0x50>)
   1373c:	9b01      	ldr	r3, [sp, #4]
   1373e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   13742:	bf00      	nop
   13744:	b003      	add	sp, #12
   13746:	f85d fb04 	ldr.w	pc, [sp], #4
   1374a:	bf00      	nop
   1374c:	1fff949c 	.word	0x1fff949c
   13750:	1fff9498 	.word	0x1fff9498

00013754 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13(void)
{
   13754:	b500      	push	{lr}
   13756:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13758:	f7ed fa1e 	bl	b98 <Sys_GetCoreID>
   1375c:	4603      	mov	r3, r0
   1375e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId]--;
   13760:	4a0d      	ldr	r2, [pc, #52]	; (13798 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x44>)
   13762:	9b01      	ldr	r3, [sp, #4]
   13764:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13768:	1e5a      	subs	r2, r3, #1
   1376a:	490b      	ldr	r1, [pc, #44]	; (13798 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x44>)
   1376c:	9b01      	ldr	r3, [sp, #4]
   1376e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_13[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_13[u32CoreId]))         /*if interrupts were enabled*/
   13772:	4a0a      	ldr	r2, [pc, #40]	; (1379c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x48>)
   13774:	9b01      	ldr	r3, [sp, #4]
   13776:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1377a:	f003 0301 	and.w	r3, r3, #1
   1377e:	2b00      	cmp	r3, #0
   13780:	d106      	bne.n	13790 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x3c>
   13782:	4a05      	ldr	r2, [pc, #20]	; (13798 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x44>)
   13784:	9b01      	ldr	r3, [sp, #4]
   13786:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1378a:	2b00      	cmp	r3, #0
   1378c:	d100      	bne.n	13790 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_13+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1378e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13790:	bf00      	nop
   13792:	b003      	add	sp, #12
   13794:	f85d fb04 	ldr.w	pc, [sp], #4
   13798:	1fff949c 	.word	0x1fff949c
   1379c:	1fff9498 	.word	0x1fff9498

000137a0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14(void)
{
   137a0:	b500      	push	{lr}
   137a2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   137a4:	f7ed f9f8 	bl	b98 <Sys_GetCoreID>
   137a8:	4603      	mov	r3, r0
   137aa:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId])
   137ac:	4a10      	ldr	r2, [pc, #64]	; (137f0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x50>)
   137ae:	9b01      	ldr	r3, [sp, #4]
   137b0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   137b4:	2b00      	cmp	r3, #0
   137b6:	d10d      	bne.n	137d4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   137b8:	f7ed f8fb 	bl	9b2 <Port_schm_read_msr>
   137bc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   137be:	9b00      	ldr	r3, [sp, #0]
   137c0:	f003 0301 	and.w	r3, r3, #1
   137c4:	2b00      	cmp	r3, #0
   137c6:	d100      	bne.n	137ca <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   137c8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_14[u32CoreId] = msr;
   137ca:	490a      	ldr	r1, [pc, #40]	; (137f4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x54>)
   137cc:	9b01      	ldr	r3, [sp, #4]
   137ce:	9a00      	ldr	r2, [sp, #0]
   137d0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId]++;
   137d4:	4a06      	ldr	r2, [pc, #24]	; (137f0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x50>)
   137d6:	9b01      	ldr	r3, [sp, #4]
   137d8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   137dc:	1c5a      	adds	r2, r3, #1
   137de:	4904      	ldr	r1, [pc, #16]	; (137f0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_14+0x50>)
   137e0:	9b01      	ldr	r3, [sp, #4]
   137e2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   137e6:	bf00      	nop
   137e8:	b003      	add	sp, #12
   137ea:	f85d fb04 	ldr.w	pc, [sp], #4
   137ee:	bf00      	nop
   137f0:	1fff94a4 	.word	0x1fff94a4
   137f4:	1fff94a0 	.word	0x1fff94a0

000137f8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14(void)
{
   137f8:	b500      	push	{lr}
   137fa:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   137fc:	f7ed f9cc 	bl	b98 <Sys_GetCoreID>
   13800:	4603      	mov	r3, r0
   13802:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId]--;
   13804:	4a0d      	ldr	r2, [pc, #52]	; (1383c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x44>)
   13806:	9b01      	ldr	r3, [sp, #4]
   13808:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1380c:	1e5a      	subs	r2, r3, #1
   1380e:	490b      	ldr	r1, [pc, #44]	; (1383c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x44>)
   13810:	9b01      	ldr	r3, [sp, #4]
   13812:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_14[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_14[u32CoreId]))         /*if interrupts were enabled*/
   13816:	4a0a      	ldr	r2, [pc, #40]	; (13840 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x48>)
   13818:	9b01      	ldr	r3, [sp, #4]
   1381a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1381e:	f003 0301 	and.w	r3, r3, #1
   13822:	2b00      	cmp	r3, #0
   13824:	d106      	bne.n	13834 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x3c>
   13826:	4a05      	ldr	r2, [pc, #20]	; (1383c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x44>)
   13828:	9b01      	ldr	r3, [sp, #4]
   1382a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   1382e:	2b00      	cmp	r3, #0
   13830:	d100      	bne.n	13834 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_14+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   13832:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13834:	bf00      	nop
   13836:	b003      	add	sp, #12
   13838:	f85d fb04 	ldr.w	pc, [sp], #4
   1383c:	1fff94a4 	.word	0x1fff94a4
   13840:	1fff94a0 	.word	0x1fff94a0

00013844 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15(void)
{
   13844:	b500      	push	{lr}
   13846:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13848:	f7ed f9a6 	bl	b98 <Sys_GetCoreID>
   1384c:	4603      	mov	r3, r0
   1384e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId])
   13850:	4a10      	ldr	r2, [pc, #64]	; (13894 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x50>)
   13852:	9b01      	ldr	r3, [sp, #4]
   13854:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13858:	2b00      	cmp	r3, #0
   1385a:	d10d      	bne.n	13878 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   1385c:	f7ed f8a9 	bl	9b2 <Port_schm_read_msr>
   13860:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   13862:	9b00      	ldr	r3, [sp, #0]
   13864:	f003 0301 	and.w	r3, r3, #1
   13868:	2b00      	cmp	r3, #0
   1386a:	d100      	bne.n	1386e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   1386c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_15[u32CoreId] = msr;
   1386e:	490a      	ldr	r1, [pc, #40]	; (13898 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x54>)
   13870:	9b01      	ldr	r3, [sp, #4]
   13872:	9a00      	ldr	r2, [sp, #0]
   13874:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId]++;
   13878:	4a06      	ldr	r2, [pc, #24]	; (13894 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x50>)
   1387a:	9b01      	ldr	r3, [sp, #4]
   1387c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13880:	1c5a      	adds	r2, r3, #1
   13882:	4904      	ldr	r1, [pc, #16]	; (13894 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_15+0x50>)
   13884:	9b01      	ldr	r3, [sp, #4]
   13886:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1388a:	bf00      	nop
   1388c:	b003      	add	sp, #12
   1388e:	f85d fb04 	ldr.w	pc, [sp], #4
   13892:	bf00      	nop
   13894:	1fff94ac 	.word	0x1fff94ac
   13898:	1fff94a8 	.word	0x1fff94a8

0001389c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15(void)
{
   1389c:	b500      	push	{lr}
   1389e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   138a0:	f7ed f97a 	bl	b98 <Sys_GetCoreID>
   138a4:	4603      	mov	r3, r0
   138a6:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId]--;
   138a8:	4a0d      	ldr	r2, [pc, #52]	; (138e0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x44>)
   138aa:	9b01      	ldr	r3, [sp, #4]
   138ac:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   138b0:	1e5a      	subs	r2, r3, #1
   138b2:	490b      	ldr	r1, [pc, #44]	; (138e0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x44>)
   138b4:	9b01      	ldr	r3, [sp, #4]
   138b6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_15[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_15[u32CoreId]))         /*if interrupts were enabled*/
   138ba:	4a0a      	ldr	r2, [pc, #40]	; (138e4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x48>)
   138bc:	9b01      	ldr	r3, [sp, #4]
   138be:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   138c2:	f003 0301 	and.w	r3, r3, #1
   138c6:	2b00      	cmp	r3, #0
   138c8:	d106      	bne.n	138d8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x3c>
   138ca:	4a05      	ldr	r2, [pc, #20]	; (138e0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x44>)
   138cc:	9b01      	ldr	r3, [sp, #4]
   138ce:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   138d2:	2b00      	cmp	r3, #0
   138d4:	d100      	bne.n	138d8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_15+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   138d6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   138d8:	bf00      	nop
   138da:	b003      	add	sp, #12
   138dc:	f85d fb04 	ldr.w	pc, [sp], #4
   138e0:	1fff94ac 	.word	0x1fff94ac
   138e4:	1fff94a8 	.word	0x1fff94a8

000138e8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16(void)
{
   138e8:	b500      	push	{lr}
   138ea:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   138ec:	f7ed f954 	bl	b98 <Sys_GetCoreID>
   138f0:	4603      	mov	r3, r0
   138f2:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId])
   138f4:	4a10      	ldr	r2, [pc, #64]	; (13938 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x50>)
   138f6:	9b01      	ldr	r3, [sp, #4]
   138f8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   138fc:	2b00      	cmp	r3, #0
   138fe:	d10d      	bne.n	1391c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13900:	f7ed f857 	bl	9b2 <Port_schm_read_msr>
   13904:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   13906:	9b00      	ldr	r3, [sp, #0]
   13908:	f003 0301 	and.w	r3, r3, #1
   1390c:	2b00      	cmp	r3, #0
   1390e:	d100      	bne.n	13912 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13910:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_16[u32CoreId] = msr;
   13912:	490a      	ldr	r1, [pc, #40]	; (1393c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x54>)
   13914:	9b01      	ldr	r3, [sp, #4]
   13916:	9a00      	ldr	r2, [sp, #0]
   13918:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId]++;
   1391c:	4a06      	ldr	r2, [pc, #24]	; (13938 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x50>)
   1391e:	9b01      	ldr	r3, [sp, #4]
   13920:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13924:	1c5a      	adds	r2, r3, #1
   13926:	4904      	ldr	r1, [pc, #16]	; (13938 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_16+0x50>)
   13928:	9b01      	ldr	r3, [sp, #4]
   1392a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1392e:	bf00      	nop
   13930:	b003      	add	sp, #12
   13932:	f85d fb04 	ldr.w	pc, [sp], #4
   13936:	bf00      	nop
   13938:	1fff94b4 	.word	0x1fff94b4
   1393c:	1fff94b0 	.word	0x1fff94b0

00013940 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16(void)
{
   13940:	b500      	push	{lr}
   13942:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13944:	f7ed f928 	bl	b98 <Sys_GetCoreID>
   13948:	4603      	mov	r3, r0
   1394a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId]--;
   1394c:	4a0d      	ldr	r2, [pc, #52]	; (13984 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x44>)
   1394e:	9b01      	ldr	r3, [sp, #4]
   13950:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13954:	1e5a      	subs	r2, r3, #1
   13956:	490b      	ldr	r1, [pc, #44]	; (13984 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x44>)
   13958:	9b01      	ldr	r3, [sp, #4]
   1395a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_16[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_16[u32CoreId]))         /*if interrupts were enabled*/
   1395e:	4a0a      	ldr	r2, [pc, #40]	; (13988 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x48>)
   13960:	9b01      	ldr	r3, [sp, #4]
   13962:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13966:	f003 0301 	and.w	r3, r3, #1
   1396a:	2b00      	cmp	r3, #0
   1396c:	d106      	bne.n	1397c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x3c>
   1396e:	4a05      	ldr	r2, [pc, #20]	; (13984 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x44>)
   13970:	9b01      	ldr	r3, [sp, #4]
   13972:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13976:	2b00      	cmp	r3, #0
   13978:	d100      	bne.n	1397c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_16+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   1397a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   1397c:	bf00      	nop
   1397e:	b003      	add	sp, #12
   13980:	f85d fb04 	ldr.w	pc, [sp], #4
   13984:	1fff94b4 	.word	0x1fff94b4
   13988:	1fff94b0 	.word	0x1fff94b0

0001398c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17(void)
{
   1398c:	b500      	push	{lr}
   1398e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13990:	f7ed f902 	bl	b98 <Sys_GetCoreID>
   13994:	4603      	mov	r3, r0
   13996:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId])
   13998:	4a10      	ldr	r2, [pc, #64]	; (139dc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x50>)
   1399a:	9b01      	ldr	r3, [sp, #4]
   1399c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   139a0:	2b00      	cmp	r3, #0
   139a2:	d10d      	bne.n	139c0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   139a4:	f7ed f805 	bl	9b2 <Port_schm_read_msr>
   139a8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   139aa:	9b00      	ldr	r3, [sp, #0]
   139ac:	f003 0301 	and.w	r3, r3, #1
   139b0:	2b00      	cmp	r3, #0
   139b2:	d100      	bne.n	139b6 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   139b4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_17[u32CoreId] = msr;
   139b6:	490a      	ldr	r1, [pc, #40]	; (139e0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x54>)
   139b8:	9b01      	ldr	r3, [sp, #4]
   139ba:	9a00      	ldr	r2, [sp, #0]
   139bc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId]++;
   139c0:	4a06      	ldr	r2, [pc, #24]	; (139dc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x50>)
   139c2:	9b01      	ldr	r3, [sp, #4]
   139c4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   139c8:	1c5a      	adds	r2, r3, #1
   139ca:	4904      	ldr	r1, [pc, #16]	; (139dc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_17+0x50>)
   139cc:	9b01      	ldr	r3, [sp, #4]
   139ce:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   139d2:	bf00      	nop
   139d4:	b003      	add	sp, #12
   139d6:	f85d fb04 	ldr.w	pc, [sp], #4
   139da:	bf00      	nop
   139dc:	1fff94bc 	.word	0x1fff94bc
   139e0:	1fff94b8 	.word	0x1fff94b8

000139e4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17(void)
{
   139e4:	b500      	push	{lr}
   139e6:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   139e8:	f7ed f8d6 	bl	b98 <Sys_GetCoreID>
   139ec:	4603      	mov	r3, r0
   139ee:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId]--;
   139f0:	4a0d      	ldr	r2, [pc, #52]	; (13a28 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x44>)
   139f2:	9b01      	ldr	r3, [sp, #4]
   139f4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   139f8:	1e5a      	subs	r2, r3, #1
   139fa:	490b      	ldr	r1, [pc, #44]	; (13a28 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x44>)
   139fc:	9b01      	ldr	r3, [sp, #4]
   139fe:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_17[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_17[u32CoreId]))         /*if interrupts were enabled*/
   13a02:	4a0a      	ldr	r2, [pc, #40]	; (13a2c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x48>)
   13a04:	9b01      	ldr	r3, [sp, #4]
   13a06:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13a0a:	f003 0301 	and.w	r3, r3, #1
   13a0e:	2b00      	cmp	r3, #0
   13a10:	d106      	bne.n	13a20 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x3c>
   13a12:	4a05      	ldr	r2, [pc, #20]	; (13a28 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x44>)
   13a14:	9b01      	ldr	r3, [sp, #4]
   13a16:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13a1a:	2b00      	cmp	r3, #0
   13a1c:	d100      	bne.n	13a20 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_17+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   13a1e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13a20:	bf00      	nop
   13a22:	b003      	add	sp, #12
   13a24:	f85d fb04 	ldr.w	pc, [sp], #4
   13a28:	1fff94bc 	.word	0x1fff94bc
   13a2c:	1fff94b8 	.word	0x1fff94b8

00013a30 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18(void)
{
   13a30:	b500      	push	{lr}
   13a32:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13a34:	f7ed f8b0 	bl	b98 <Sys_GetCoreID>
   13a38:	4603      	mov	r3, r0
   13a3a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId])
   13a3c:	4a10      	ldr	r2, [pc, #64]	; (13a80 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x50>)
   13a3e:	9b01      	ldr	r3, [sp, #4]
   13a40:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13a44:	2b00      	cmp	r3, #0
   13a46:	d10d      	bne.n	13a64 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13a48:	f7ec ffb3 	bl	9b2 <Port_schm_read_msr>
   13a4c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   13a4e:	9b00      	ldr	r3, [sp, #0]
   13a50:	f003 0301 	and.w	r3, r3, #1
   13a54:	2b00      	cmp	r3, #0
   13a56:	d100      	bne.n	13a5a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13a58:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_18[u32CoreId] = msr;
   13a5a:	490a      	ldr	r1, [pc, #40]	; (13a84 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x54>)
   13a5c:	9b01      	ldr	r3, [sp, #4]
   13a5e:	9a00      	ldr	r2, [sp, #0]
   13a60:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId]++;
   13a64:	4a06      	ldr	r2, [pc, #24]	; (13a80 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x50>)
   13a66:	9b01      	ldr	r3, [sp, #4]
   13a68:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13a6c:	1c5a      	adds	r2, r3, #1
   13a6e:	4904      	ldr	r1, [pc, #16]	; (13a80 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_18+0x50>)
   13a70:	9b01      	ldr	r3, [sp, #4]
   13a72:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   13a76:	bf00      	nop
   13a78:	b003      	add	sp, #12
   13a7a:	f85d fb04 	ldr.w	pc, [sp], #4
   13a7e:	bf00      	nop
   13a80:	1fff94c4 	.word	0x1fff94c4
   13a84:	1fff94c0 	.word	0x1fff94c0

00013a88 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18(void)
{
   13a88:	b500      	push	{lr}
   13a8a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13a8c:	f7ed f884 	bl	b98 <Sys_GetCoreID>
   13a90:	4603      	mov	r3, r0
   13a92:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId]--;
   13a94:	4a0d      	ldr	r2, [pc, #52]	; (13acc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x44>)
   13a96:	9b01      	ldr	r3, [sp, #4]
   13a98:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13a9c:	1e5a      	subs	r2, r3, #1
   13a9e:	490b      	ldr	r1, [pc, #44]	; (13acc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x44>)
   13aa0:	9b01      	ldr	r3, [sp, #4]
   13aa2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_18[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_18[u32CoreId]))         /*if interrupts were enabled*/
   13aa6:	4a0a      	ldr	r2, [pc, #40]	; (13ad0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x48>)
   13aa8:	9b01      	ldr	r3, [sp, #4]
   13aaa:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13aae:	f003 0301 	and.w	r3, r3, #1
   13ab2:	2b00      	cmp	r3, #0
   13ab4:	d106      	bne.n	13ac4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x3c>
   13ab6:	4a05      	ldr	r2, [pc, #20]	; (13acc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x44>)
   13ab8:	9b01      	ldr	r3, [sp, #4]
   13aba:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13abe:	2b00      	cmp	r3, #0
   13ac0:	d100      	bne.n	13ac4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_18+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   13ac2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13ac4:	bf00      	nop
   13ac6:	b003      	add	sp, #12
   13ac8:	f85d fb04 	ldr.w	pc, [sp], #4
   13acc:	1fff94c4 	.word	0x1fff94c4
   13ad0:	1fff94c0 	.word	0x1fff94c0

00013ad4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19(void)
{
   13ad4:	b500      	push	{lr}
   13ad6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13ad8:	f7ed f85e 	bl	b98 <Sys_GetCoreID>
   13adc:	4603      	mov	r3, r0
   13ade:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId])
   13ae0:	4a10      	ldr	r2, [pc, #64]	; (13b24 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x50>)
   13ae2:	9b01      	ldr	r3, [sp, #4]
   13ae4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13ae8:	2b00      	cmp	r3, #0
   13aea:	d10d      	bne.n	13b08 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13aec:	f7ec ff61 	bl	9b2 <Port_schm_read_msr>
   13af0:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   13af2:	9b00      	ldr	r3, [sp, #0]
   13af4:	f003 0301 	and.w	r3, r3, #1
   13af8:	2b00      	cmp	r3, #0
   13afa:	d100      	bne.n	13afe <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13afc:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_19[u32CoreId] = msr;
   13afe:	490a      	ldr	r1, [pc, #40]	; (13b28 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x54>)
   13b00:	9b01      	ldr	r3, [sp, #4]
   13b02:	9a00      	ldr	r2, [sp, #0]
   13b04:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId]++;
   13b08:	4a06      	ldr	r2, [pc, #24]	; (13b24 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x50>)
   13b0a:	9b01      	ldr	r3, [sp, #4]
   13b0c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13b10:	1c5a      	adds	r2, r3, #1
   13b12:	4904      	ldr	r1, [pc, #16]	; (13b24 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_19+0x50>)
   13b14:	9b01      	ldr	r3, [sp, #4]
   13b16:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   13b1a:	bf00      	nop
   13b1c:	b003      	add	sp, #12
   13b1e:	f85d fb04 	ldr.w	pc, [sp], #4
   13b22:	bf00      	nop
   13b24:	1fff94cc 	.word	0x1fff94cc
   13b28:	1fff94c8 	.word	0x1fff94c8

00013b2c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19(void)
{
   13b2c:	b500      	push	{lr}
   13b2e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13b30:	f7ed f832 	bl	b98 <Sys_GetCoreID>
   13b34:	4603      	mov	r3, r0
   13b36:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId]--;
   13b38:	4a0d      	ldr	r2, [pc, #52]	; (13b70 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x44>)
   13b3a:	9b01      	ldr	r3, [sp, #4]
   13b3c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13b40:	1e5a      	subs	r2, r3, #1
   13b42:	490b      	ldr	r1, [pc, #44]	; (13b70 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x44>)
   13b44:	9b01      	ldr	r3, [sp, #4]
   13b46:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_19[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_19[u32CoreId]))         /*if interrupts were enabled*/
   13b4a:	4a0a      	ldr	r2, [pc, #40]	; (13b74 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x48>)
   13b4c:	9b01      	ldr	r3, [sp, #4]
   13b4e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13b52:	f003 0301 	and.w	r3, r3, #1
   13b56:	2b00      	cmp	r3, #0
   13b58:	d106      	bne.n	13b68 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x3c>
   13b5a:	4a05      	ldr	r2, [pc, #20]	; (13b70 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x44>)
   13b5c:	9b01      	ldr	r3, [sp, #4]
   13b5e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13b62:	2b00      	cmp	r3, #0
   13b64:	d100      	bne.n	13b68 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_19+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   13b66:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13b68:	bf00      	nop
   13b6a:	b003      	add	sp, #12
   13b6c:	f85d fb04 	ldr.w	pc, [sp], #4
   13b70:	1fff94cc 	.word	0x1fff94cc
   13b74:	1fff94c8 	.word	0x1fff94c8

00013b78 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20(void)
{
   13b78:	b500      	push	{lr}
   13b7a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13b7c:	f7ed f80c 	bl	b98 <Sys_GetCoreID>
   13b80:	4603      	mov	r3, r0
   13b82:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId])
   13b84:	4a10      	ldr	r2, [pc, #64]	; (13bc8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x50>)
   13b86:	9b01      	ldr	r3, [sp, #4]
   13b88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13b8c:	2b00      	cmp	r3, #0
   13b8e:	d10d      	bne.n	13bac <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13b90:	f7ec ff0f 	bl	9b2 <Port_schm_read_msr>
   13b94:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   13b96:	9b00      	ldr	r3, [sp, #0]
   13b98:	f003 0301 	and.w	r3, r3, #1
   13b9c:	2b00      	cmp	r3, #0
   13b9e:	d100      	bne.n	13ba2 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13ba0:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_20[u32CoreId] = msr;
   13ba2:	490a      	ldr	r1, [pc, #40]	; (13bcc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x54>)
   13ba4:	9b01      	ldr	r3, [sp, #4]
   13ba6:	9a00      	ldr	r2, [sp, #0]
   13ba8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId]++;
   13bac:	4a06      	ldr	r2, [pc, #24]	; (13bc8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x50>)
   13bae:	9b01      	ldr	r3, [sp, #4]
   13bb0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13bb4:	1c5a      	adds	r2, r3, #1
   13bb6:	4904      	ldr	r1, [pc, #16]	; (13bc8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_20+0x50>)
   13bb8:	9b01      	ldr	r3, [sp, #4]
   13bba:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   13bbe:	bf00      	nop
   13bc0:	b003      	add	sp, #12
   13bc2:	f85d fb04 	ldr.w	pc, [sp], #4
   13bc6:	bf00      	nop
   13bc8:	1fff94d4 	.word	0x1fff94d4
   13bcc:	1fff94d0 	.word	0x1fff94d0

00013bd0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20(void)
{
   13bd0:	b500      	push	{lr}
   13bd2:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13bd4:	f7ec ffe0 	bl	b98 <Sys_GetCoreID>
   13bd8:	4603      	mov	r3, r0
   13bda:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId]--;
   13bdc:	4a0d      	ldr	r2, [pc, #52]	; (13c14 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x44>)
   13bde:	9b01      	ldr	r3, [sp, #4]
   13be0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13be4:	1e5a      	subs	r2, r3, #1
   13be6:	490b      	ldr	r1, [pc, #44]	; (13c14 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x44>)
   13be8:	9b01      	ldr	r3, [sp, #4]
   13bea:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_20[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_20[u32CoreId]))         /*if interrupts were enabled*/
   13bee:	4a0a      	ldr	r2, [pc, #40]	; (13c18 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x48>)
   13bf0:	9b01      	ldr	r3, [sp, #4]
   13bf2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13bf6:	f003 0301 	and.w	r3, r3, #1
   13bfa:	2b00      	cmp	r3, #0
   13bfc:	d106      	bne.n	13c0c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x3c>
   13bfe:	4a05      	ldr	r2, [pc, #20]	; (13c14 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x44>)
   13c00:	9b01      	ldr	r3, [sp, #4]
   13c02:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13c06:	2b00      	cmp	r3, #0
   13c08:	d100      	bne.n	13c0c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_20+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   13c0a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13c0c:	bf00      	nop
   13c0e:	b003      	add	sp, #12
   13c10:	f85d fb04 	ldr.w	pc, [sp], #4
   13c14:	1fff94d4 	.word	0x1fff94d4
   13c18:	1fff94d0 	.word	0x1fff94d0

00013c1c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21(void)
{
   13c1c:	b500      	push	{lr}
   13c1e:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13c20:	f7ec ffba 	bl	b98 <Sys_GetCoreID>
   13c24:	4603      	mov	r3, r0
   13c26:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId])
   13c28:	4a10      	ldr	r2, [pc, #64]	; (13c6c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x50>)
   13c2a:	9b01      	ldr	r3, [sp, #4]
   13c2c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13c30:	2b00      	cmp	r3, #0
   13c32:	d10d      	bne.n	13c50 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13c34:	f7ec febd 	bl	9b2 <Port_schm_read_msr>
   13c38:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   13c3a:	9b00      	ldr	r3, [sp, #0]
   13c3c:	f003 0301 	and.w	r3, r3, #1
   13c40:	2b00      	cmp	r3, #0
   13c42:	d100      	bne.n	13c46 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13c44:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_21[u32CoreId] = msr;
   13c46:	490a      	ldr	r1, [pc, #40]	; (13c70 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x54>)
   13c48:	9b01      	ldr	r3, [sp, #4]
   13c4a:	9a00      	ldr	r2, [sp, #0]
   13c4c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId]++;
   13c50:	4a06      	ldr	r2, [pc, #24]	; (13c6c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x50>)
   13c52:	9b01      	ldr	r3, [sp, #4]
   13c54:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13c58:	1c5a      	adds	r2, r3, #1
   13c5a:	4904      	ldr	r1, [pc, #16]	; (13c6c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_21+0x50>)
   13c5c:	9b01      	ldr	r3, [sp, #4]
   13c5e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   13c62:	bf00      	nop
   13c64:	b003      	add	sp, #12
   13c66:	f85d fb04 	ldr.w	pc, [sp], #4
   13c6a:	bf00      	nop
   13c6c:	1fff94dc 	.word	0x1fff94dc
   13c70:	1fff94d8 	.word	0x1fff94d8

00013c74 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21(void)
{
   13c74:	b500      	push	{lr}
   13c76:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13c78:	f7ec ff8e 	bl	b98 <Sys_GetCoreID>
   13c7c:	4603      	mov	r3, r0
   13c7e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId]--;
   13c80:	4a0d      	ldr	r2, [pc, #52]	; (13cb8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x44>)
   13c82:	9b01      	ldr	r3, [sp, #4]
   13c84:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13c88:	1e5a      	subs	r2, r3, #1
   13c8a:	490b      	ldr	r1, [pc, #44]	; (13cb8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x44>)
   13c8c:	9b01      	ldr	r3, [sp, #4]
   13c8e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_21[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_21[u32CoreId]))         /*if interrupts were enabled*/
   13c92:	4a0a      	ldr	r2, [pc, #40]	; (13cbc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x48>)
   13c94:	9b01      	ldr	r3, [sp, #4]
   13c96:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13c9a:	f003 0301 	and.w	r3, r3, #1
   13c9e:	2b00      	cmp	r3, #0
   13ca0:	d106      	bne.n	13cb0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x3c>
   13ca2:	4a05      	ldr	r2, [pc, #20]	; (13cb8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x44>)
   13ca4:	9b01      	ldr	r3, [sp, #4]
   13ca6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13caa:	2b00      	cmp	r3, #0
   13cac:	d100      	bne.n	13cb0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_21+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   13cae:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13cb0:	bf00      	nop
   13cb2:	b003      	add	sp, #12
   13cb4:	f85d fb04 	ldr.w	pc, [sp], #4
   13cb8:	1fff94dc 	.word	0x1fff94dc
   13cbc:	1fff94d8 	.word	0x1fff94d8

00013cc0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22(void)
{
   13cc0:	b500      	push	{lr}
   13cc2:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13cc4:	f7ec ff68 	bl	b98 <Sys_GetCoreID>
   13cc8:	4603      	mov	r3, r0
   13cca:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId])
   13ccc:	4a10      	ldr	r2, [pc, #64]	; (13d10 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x50>)
   13cce:	9b01      	ldr	r3, [sp, #4]
   13cd0:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13cd4:	2b00      	cmp	r3, #0
   13cd6:	d10d      	bne.n	13cf4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13cd8:	f7ec fe6b 	bl	9b2 <Port_schm_read_msr>
   13cdc:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   13cde:	9b00      	ldr	r3, [sp, #0]
   13ce0:	f003 0301 	and.w	r3, r3, #1
   13ce4:	2b00      	cmp	r3, #0
   13ce6:	d100      	bne.n	13cea <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13ce8:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_22[u32CoreId] = msr;
   13cea:	490a      	ldr	r1, [pc, #40]	; (13d14 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x54>)
   13cec:	9b01      	ldr	r3, [sp, #4]
   13cee:	9a00      	ldr	r2, [sp, #0]
   13cf0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId]++;
   13cf4:	4a06      	ldr	r2, [pc, #24]	; (13d10 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x50>)
   13cf6:	9b01      	ldr	r3, [sp, #4]
   13cf8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13cfc:	1c5a      	adds	r2, r3, #1
   13cfe:	4904      	ldr	r1, [pc, #16]	; (13d10 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_22+0x50>)
   13d00:	9b01      	ldr	r3, [sp, #4]
   13d02:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   13d06:	bf00      	nop
   13d08:	b003      	add	sp, #12
   13d0a:	f85d fb04 	ldr.w	pc, [sp], #4
   13d0e:	bf00      	nop
   13d10:	1fff94e4 	.word	0x1fff94e4
   13d14:	1fff94e0 	.word	0x1fff94e0

00013d18 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22(void)
{
   13d18:	b500      	push	{lr}
   13d1a:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13d1c:	f7ec ff3c 	bl	b98 <Sys_GetCoreID>
   13d20:	4603      	mov	r3, r0
   13d22:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId]--;
   13d24:	4a0d      	ldr	r2, [pc, #52]	; (13d5c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x44>)
   13d26:	9b01      	ldr	r3, [sp, #4]
   13d28:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13d2c:	1e5a      	subs	r2, r3, #1
   13d2e:	490b      	ldr	r1, [pc, #44]	; (13d5c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x44>)
   13d30:	9b01      	ldr	r3, [sp, #4]
   13d32:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_22[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_22[u32CoreId]))         /*if interrupts were enabled*/
   13d36:	4a0a      	ldr	r2, [pc, #40]	; (13d60 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x48>)
   13d38:	9b01      	ldr	r3, [sp, #4]
   13d3a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13d3e:	f003 0301 	and.w	r3, r3, #1
   13d42:	2b00      	cmp	r3, #0
   13d44:	d106      	bne.n	13d54 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x3c>
   13d46:	4a05      	ldr	r2, [pc, #20]	; (13d5c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x44>)
   13d48:	9b01      	ldr	r3, [sp, #4]
   13d4a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13d4e:	2b00      	cmp	r3, #0
   13d50:	d100      	bne.n	13d54 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_22+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   13d52:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13d54:	bf00      	nop
   13d56:	b003      	add	sp, #12
   13d58:	f85d fb04 	ldr.w	pc, [sp], #4
   13d5c:	1fff94e4 	.word	0x1fff94e4
   13d60:	1fff94e0 	.word	0x1fff94e0

00013d64 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23(void)
{
   13d64:	b500      	push	{lr}
   13d66:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13d68:	f7ec ff16 	bl	b98 <Sys_GetCoreID>
   13d6c:	4603      	mov	r3, r0
   13d6e:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId])
   13d70:	4a10      	ldr	r2, [pc, #64]	; (13db4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x50>)
   13d72:	9b01      	ldr	r3, [sp, #4]
   13d74:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13d78:	2b00      	cmp	r3, #0
   13d7a:	d10d      	bne.n	13d98 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13d7c:	f7ec fe19 	bl	9b2 <Port_schm_read_msr>
   13d80:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   13d82:	9b00      	ldr	r3, [sp, #0]
   13d84:	f003 0301 	and.w	r3, r3, #1
   13d88:	2b00      	cmp	r3, #0
   13d8a:	d100      	bne.n	13d8e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13d8c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_23[u32CoreId] = msr;
   13d8e:	490a      	ldr	r1, [pc, #40]	; (13db8 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x54>)
   13d90:	9b01      	ldr	r3, [sp, #4]
   13d92:	9a00      	ldr	r2, [sp, #0]
   13d94:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId]++;
   13d98:	4a06      	ldr	r2, [pc, #24]	; (13db4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x50>)
   13d9a:	9b01      	ldr	r3, [sp, #4]
   13d9c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13da0:	1c5a      	adds	r2, r3, #1
   13da2:	4904      	ldr	r1, [pc, #16]	; (13db4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_23+0x50>)
   13da4:	9b01      	ldr	r3, [sp, #4]
   13da6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   13daa:	bf00      	nop
   13dac:	b003      	add	sp, #12
   13dae:	f85d fb04 	ldr.w	pc, [sp], #4
   13db2:	bf00      	nop
   13db4:	1fff94ec 	.word	0x1fff94ec
   13db8:	1fff94e8 	.word	0x1fff94e8

00013dbc <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23(void)
{
   13dbc:	b500      	push	{lr}
   13dbe:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13dc0:	f7ec feea 	bl	b98 <Sys_GetCoreID>
   13dc4:	4603      	mov	r3, r0
   13dc6:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId]--;
   13dc8:	4a0d      	ldr	r2, [pc, #52]	; (13e00 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x44>)
   13dca:	9b01      	ldr	r3, [sp, #4]
   13dcc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13dd0:	1e5a      	subs	r2, r3, #1
   13dd2:	490b      	ldr	r1, [pc, #44]	; (13e00 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x44>)
   13dd4:	9b01      	ldr	r3, [sp, #4]
   13dd6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_23[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_23[u32CoreId]))         /*if interrupts were enabled*/
   13dda:	4a0a      	ldr	r2, [pc, #40]	; (13e04 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x48>)
   13ddc:	9b01      	ldr	r3, [sp, #4]
   13dde:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13de2:	f003 0301 	and.w	r3, r3, #1
   13de6:	2b00      	cmp	r3, #0
   13de8:	d106      	bne.n	13df8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x3c>
   13dea:	4a05      	ldr	r2, [pc, #20]	; (13e00 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x44>)
   13dec:	9b01      	ldr	r3, [sp, #4]
   13dee:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13df2:	2b00      	cmp	r3, #0
   13df4:	d100      	bne.n	13df8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_23+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   13df6:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13df8:	bf00      	nop
   13dfa:	b003      	add	sp, #12
   13dfc:	f85d fb04 	ldr.w	pc, [sp], #4
   13e00:	1fff94ec 	.word	0x1fff94ec
   13e04:	1fff94e8 	.word	0x1fff94e8

00013e08 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24(void)
{
   13e08:	b500      	push	{lr}
   13e0a:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13e0c:	f7ec fec4 	bl	b98 <Sys_GetCoreID>
   13e10:	4603      	mov	r3, r0
   13e12:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId])
   13e14:	4a10      	ldr	r2, [pc, #64]	; (13e58 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x50>)
   13e16:	9b01      	ldr	r3, [sp, #4]
   13e18:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13e1c:	2b00      	cmp	r3, #0
   13e1e:	d10d      	bne.n	13e3c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13e20:	f7ec fdc7 	bl	9b2 <Port_schm_read_msr>
   13e24:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   13e26:	9b00      	ldr	r3, [sp, #0]
   13e28:	f003 0301 	and.w	r3, r3, #1
   13e2c:	2b00      	cmp	r3, #0
   13e2e:	d100      	bne.n	13e32 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13e30:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_24[u32CoreId] = msr;
   13e32:	490a      	ldr	r1, [pc, #40]	; (13e5c <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x54>)
   13e34:	9b01      	ldr	r3, [sp, #4]
   13e36:	9a00      	ldr	r2, [sp, #0]
   13e38:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId]++;
   13e3c:	4a06      	ldr	r2, [pc, #24]	; (13e58 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x50>)
   13e3e:	9b01      	ldr	r3, [sp, #4]
   13e40:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13e44:	1c5a      	adds	r2, r3, #1
   13e46:	4904      	ldr	r1, [pc, #16]	; (13e58 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_24+0x50>)
   13e48:	9b01      	ldr	r3, [sp, #4]
   13e4a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   13e4e:	bf00      	nop
   13e50:	b003      	add	sp, #12
   13e52:	f85d fb04 	ldr.w	pc, [sp], #4
   13e56:	bf00      	nop
   13e58:	1fff94f4 	.word	0x1fff94f4
   13e5c:	1fff94f0 	.word	0x1fff94f0

00013e60 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24(void)
{
   13e60:	b500      	push	{lr}
   13e62:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13e64:	f7ec fe98 	bl	b98 <Sys_GetCoreID>
   13e68:	4603      	mov	r3, r0
   13e6a:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId]--;
   13e6c:	4a0d      	ldr	r2, [pc, #52]	; (13ea4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x44>)
   13e6e:	9b01      	ldr	r3, [sp, #4]
   13e70:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13e74:	1e5a      	subs	r2, r3, #1
   13e76:	490b      	ldr	r1, [pc, #44]	; (13ea4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x44>)
   13e78:	9b01      	ldr	r3, [sp, #4]
   13e7a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_24[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_24[u32CoreId]))         /*if interrupts were enabled*/
   13e7e:	4a0a      	ldr	r2, [pc, #40]	; (13ea8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x48>)
   13e80:	9b01      	ldr	r3, [sp, #4]
   13e82:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13e86:	f003 0301 	and.w	r3, r3, #1
   13e8a:	2b00      	cmp	r3, #0
   13e8c:	d106      	bne.n	13e9c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x3c>
   13e8e:	4a05      	ldr	r2, [pc, #20]	; (13ea4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x44>)
   13e90:	9b01      	ldr	r3, [sp, #4]
   13e92:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13e96:	2b00      	cmp	r3, #0
   13e98:	d100      	bne.n	13e9c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_24+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   13e9a:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13e9c:	bf00      	nop
   13e9e:	b003      	add	sp, #12
   13ea0:	f85d fb04 	ldr.w	pc, [sp], #4
   13ea4:	1fff94f4 	.word	0x1fff94f4
   13ea8:	1fff94f0 	.word	0x1fff94f0

00013eac <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25(void)
{
   13eac:	b500      	push	{lr}
   13eae:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13eb0:	f7ec fe72 	bl	b98 <Sys_GetCoreID>
   13eb4:	4603      	mov	r3, r0
   13eb6:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId])
   13eb8:	4a10      	ldr	r2, [pc, #64]	; (13efc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x50>)
   13eba:	9b01      	ldr	r3, [sp, #4]
   13ebc:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13ec0:	2b00      	cmp	r3, #0
   13ec2:	d10d      	bne.n	13ee0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13ec4:	f7ec fd75 	bl	9b2 <Port_schm_read_msr>
   13ec8:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   13eca:	9b00      	ldr	r3, [sp, #0]
   13ecc:	f003 0301 	and.w	r3, r3, #1
   13ed0:	2b00      	cmp	r3, #0
   13ed2:	d100      	bne.n	13ed6 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13ed4:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_25[u32CoreId] = msr;
   13ed6:	490a      	ldr	r1, [pc, #40]	; (13f00 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x54>)
   13ed8:	9b01      	ldr	r3, [sp, #4]
   13eda:	9a00      	ldr	r2, [sp, #0]
   13edc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId]++;
   13ee0:	4a06      	ldr	r2, [pc, #24]	; (13efc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x50>)
   13ee2:	9b01      	ldr	r3, [sp, #4]
   13ee4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13ee8:	1c5a      	adds	r2, r3, #1
   13eea:	4904      	ldr	r1, [pc, #16]	; (13efc <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_25+0x50>)
   13eec:	9b01      	ldr	r3, [sp, #4]
   13eee:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   13ef2:	bf00      	nop
   13ef4:	b003      	add	sp, #12
   13ef6:	f85d fb04 	ldr.w	pc, [sp], #4
   13efa:	bf00      	nop
   13efc:	1fff94fc 	.word	0x1fff94fc
   13f00:	1fff94f8 	.word	0x1fff94f8

00013f04 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25(void)
{
   13f04:	b500      	push	{lr}
   13f06:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13f08:	f7ec fe46 	bl	b98 <Sys_GetCoreID>
   13f0c:	4603      	mov	r3, r0
   13f0e:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId]--;
   13f10:	4a0d      	ldr	r2, [pc, #52]	; (13f48 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x44>)
   13f12:	9b01      	ldr	r3, [sp, #4]
   13f14:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13f18:	1e5a      	subs	r2, r3, #1
   13f1a:	490b      	ldr	r1, [pc, #44]	; (13f48 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x44>)
   13f1c:	9b01      	ldr	r3, [sp, #4]
   13f1e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_25[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_25[u32CoreId]))         /*if interrupts were enabled*/
   13f22:	4a0a      	ldr	r2, [pc, #40]	; (13f4c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x48>)
   13f24:	9b01      	ldr	r3, [sp, #4]
   13f26:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13f2a:	f003 0301 	and.w	r3, r3, #1
   13f2e:	2b00      	cmp	r3, #0
   13f30:	d106      	bne.n	13f40 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x3c>
   13f32:	4a05      	ldr	r2, [pc, #20]	; (13f48 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x44>)
   13f34:	9b01      	ldr	r3, [sp, #4]
   13f36:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13f3a:	2b00      	cmp	r3, #0
   13f3c:	d100      	bne.n	13f40 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_25+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   13f3e:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13f40:	bf00      	nop
   13f42:	b003      	add	sp, #12
   13f44:	f85d fb04 	ldr.w	pc, [sp], #4
   13f48:	1fff94fc 	.word	0x1fff94fc
   13f4c:	1fff94f8 	.word	0x1fff94f8

00013f50 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26(void)
{
   13f50:	b500      	push	{lr}
   13f52:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13f54:	f7ec fe20 	bl	b98 <Sys_GetCoreID>
   13f58:	4603      	mov	r3, r0
   13f5a:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId])
   13f5c:	4a10      	ldr	r2, [pc, #64]	; (13fa0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x50>)
   13f5e:	9b01      	ldr	r3, [sp, #4]
   13f60:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13f64:	2b00      	cmp	r3, #0
   13f66:	d10d      	bne.n	13f84 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   13f68:	f7ec fd23 	bl	9b2 <Port_schm_read_msr>
   13f6c:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   13f6e:	9b00      	ldr	r3, [sp, #0]
   13f70:	f003 0301 	and.w	r3, r3, #1
   13f74:	2b00      	cmp	r3, #0
   13f76:	d100      	bne.n	13f7a <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   13f78:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_26[u32CoreId] = msr;
   13f7a:	490a      	ldr	r1, [pc, #40]	; (13fa4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x54>)
   13f7c:	9b01      	ldr	r3, [sp, #4]
   13f7e:	9a00      	ldr	r2, [sp, #0]
   13f80:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId]++;
   13f84:	4a06      	ldr	r2, [pc, #24]	; (13fa0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x50>)
   13f86:	9b01      	ldr	r3, [sp, #4]
   13f88:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13f8c:	1c5a      	adds	r2, r3, #1
   13f8e:	4904      	ldr	r1, [pc, #16]	; (13fa0 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_26+0x50>)
   13f90:	9b01      	ldr	r3, [sp, #4]
   13f92:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   13f96:	bf00      	nop
   13f98:	b003      	add	sp, #12
   13f9a:	f85d fb04 	ldr.w	pc, [sp], #4
   13f9e:	bf00      	nop
   13fa0:	1fff9504 	.word	0x1fff9504
   13fa4:	1fff9500 	.word	0x1fff9500

00013fa8 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26(void)
{
   13fa8:	b500      	push	{lr}
   13faa:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13fac:	f7ec fdf4 	bl	b98 <Sys_GetCoreID>
   13fb0:	4603      	mov	r3, r0
   13fb2:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId]--;
   13fb4:	4a0d      	ldr	r2, [pc, #52]	; (13fec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x44>)
   13fb6:	9b01      	ldr	r3, [sp, #4]
   13fb8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13fbc:	1e5a      	subs	r2, r3, #1
   13fbe:	490b      	ldr	r1, [pc, #44]	; (13fec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x44>)
   13fc0:	9b01      	ldr	r3, [sp, #4]
   13fc2:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_26[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_26[u32CoreId]))         /*if interrupts were enabled*/
   13fc6:	4a0a      	ldr	r2, [pc, #40]	; (13ff0 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x48>)
   13fc8:	9b01      	ldr	r3, [sp, #4]
   13fca:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13fce:	f003 0301 	and.w	r3, r3, #1
   13fd2:	2b00      	cmp	r3, #0
   13fd4:	d106      	bne.n	13fe4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x3c>
   13fd6:	4a05      	ldr	r2, [pc, #20]	; (13fec <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x44>)
   13fd8:	9b01      	ldr	r3, [sp, #4]
   13fda:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   13fde:	2b00      	cmp	r3, #0
   13fe0:	d100      	bne.n	13fe4 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_26+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   13fe2:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   13fe4:	bf00      	nop
   13fe6:	b003      	add	sp, #12
   13fe8:	f85d fb04 	ldr.w	pc, [sp], #4
   13fec:	1fff9504 	.word	0x1fff9504
   13ff0:	1fff9500 	.word	0x1fff9500

00013ff4 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27>:

void SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27(void)
{
   13ff4:	b500      	push	{lr}
   13ff6:	b083      	sub	sp, #12
    uint32 msr;
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   13ff8:	f7ec fdce 	bl	b98 <Sys_GetCoreID>
   13ffc:	4603      	mov	r3, r0
   13ffe:	9301      	str	r3, [sp, #4]

    if(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId])
   14000:	4a10      	ldr	r2, [pc, #64]	; (14044 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x50>)
   14002:	9b01      	ldr	r3, [sp, #4]
   14004:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14008:	2b00      	cmp	r3, #0
   1400a:	d10d      	bne.n	14028 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x34>
    {
#if (defined MCAL_ENABLE_USER_MODE_SUPPORT)
        msr = OsIf_Trusted_Call_Return(Port_schm_read_msr);
#else
        msr = Port_schm_read_msr();  /*read MSR (to store interrupts state)*/
   1400c:	f7ec fcd1 	bl	9b2 <Port_schm_read_msr>
   14010:	9000      	str	r0, [sp, #0]
#endif /* MCAL_ENABLE_USER_MODE_SUPPORT */
        if (ISR_ON(msr)) /*if MSR[EE] = 0, skip calling Suspend/Resume AllInterrupts*/
   14012:	9b00      	ldr	r3, [sp, #0]
   14014:	f003 0301 	and.w	r3, r3, #1
   14018:	2b00      	cmp	r3, #0
   1401a:	d100      	bne.n	1401e <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x2a>
        {
            OsIf_SuspendAllInterrupts();
   1401c:	b672      	cpsid	i
#ifdef _ARM_DS5_C_S32K1XX_
            ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
        }
        msr_PORT_EXCLUSIVE_AREA_27[u32CoreId] = msr;
   1401e:	490a      	ldr	r1, [pc, #40]	; (14048 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x54>)
   14020:	9b01      	ldr	r3, [sp, #4]
   14022:	9a00      	ldr	r2, [sp, #0]
   14024:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    }
    reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId]++;
   14028:	4a06      	ldr	r2, [pc, #24]	; (14044 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x50>)
   1402a:	9b01      	ldr	r3, [sp, #4]
   1402c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14030:	1c5a      	adds	r2, r3, #1
   14032:	4904      	ldr	r1, [pc, #16]	; (14044 <SchM_Enter_Port_PORT_EXCLUSIVE_AREA_27+0x50>)
   14034:	9b01      	ldr	r3, [sp, #4]
   14036:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
   1403a:	bf00      	nop
   1403c:	b003      	add	sp, #12
   1403e:	f85d fb04 	ldr.w	pc, [sp], #4
   14042:	bf00      	nop
   14044:	1fff950c 	.word	0x1fff950c
   14048:	1fff9508 	.word	0x1fff9508

0001404c <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27>:

void SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27(void)
{
   1404c:	b500      	push	{lr}
   1404e:	b083      	sub	sp, #12
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14050:	f7ec fda2 	bl	b98 <Sys_GetCoreID>
   14054:	4603      	mov	r3, r0
   14056:	9301      	str	r3, [sp, #4]

    reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId]--;
   14058:	4a0d      	ldr	r2, [pc, #52]	; (14090 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x44>)
   1405a:	9b01      	ldr	r3, [sp, #4]
   1405c:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14060:	1e5a      	subs	r2, r3, #1
   14062:	490b      	ldr	r1, [pc, #44]	; (14090 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x44>)
   14064:	9b01      	ldr	r3, [sp, #4]
   14066:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    if ((ISR_ON(msr_PORT_EXCLUSIVE_AREA_27[u32CoreId]))&&(0UL == reentry_guard_PORT_EXCLUSIVE_AREA_27[u32CoreId]))         /*if interrupts were enabled*/
   1406a:	4a0a      	ldr	r2, [pc, #40]	; (14094 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x48>)
   1406c:	9b01      	ldr	r3, [sp, #4]
   1406e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14072:	f003 0301 	and.w	r3, r3, #1
   14076:	2b00      	cmp	r3, #0
   14078:	d106      	bne.n	14088 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x3c>
   1407a:	4a05      	ldr	r2, [pc, #20]	; (14090 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x44>)
   1407c:	9b01      	ldr	r3, [sp, #4]
   1407e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
   14082:	2b00      	cmp	r3, #0
   14084:	d100      	bne.n	14088 <SchM_Exit_Port_PORT_EXCLUSIVE_AREA_27+0x3c>
    {
        OsIf_ResumeAllInterrupts();
   14086:	b662      	cpsie	i
#ifdef _ARM_DS5_C_S32K1XX_
        ASM_KEYWORD(" nop ");/* Compiler fix - forces the CSPID instruction to be generated with -02, -Ospace are selected*/
#endif
    }
}
   14088:	bf00      	nop
   1408a:	b003      	add	sp, #12
   1408c:	f85d fb04 	ldr.w	pc, [sp], #4
   14090:	1fff950c 	.word	0x1fff950c
   14094:	1fff9508 	.word	0x1fff9508

00014098 <Det_Init>:
*
* @requirements   DET008
*
*/
void Det_Init(void)
{
   14098:	b508      	push	{r3, lr}
    SEGGER_RTT_Init();  //Initializing RTT library.
   1409a:	f7ec ff1b 	bl	ed4 <SEGGER_RTT_Init>
}
   1409e:	bf00      	nop
   140a0:	bd08      	pop	{r3, pc}

000140a2 <Det_SearchApi>:
 * @param[in] ApiId Api id where error was detected.
 * @return StringPtr Ptr to string of api name.
 * 
 * @note If the Api Id isnt registered in the hash table it will return NULL; 
 */
const char* Det_SearchApi( uint8 ModuleIndex, uint8 ApiId ) {
   140a2:	b084      	sub	sp, #16
   140a4:	4603      	mov	r3, r0
   140a6:	460a      	mov	r2, r1
   140a8:	f88d 3007 	strb.w	r3, [sp, #7]
   140ac:	4613      	mov	r3, r2
   140ae:	f88d 3006 	strb.w	r3, [sp, #6]
    //local data.
    uint8 i = 0;
   140b2:	2300      	movs	r3, #0
   140b4:	f88d 300f 	strb.w	r3, [sp, #15]
    const char *StringPtr = NULL_PTR;
   140b8:	2300      	movs	r3, #0
   140ba:	9302      	str	r3, [sp, #8]

    for ( i = 0; i < ModuleStrings_Ptr[ ModuleIndex ].Apis; i++ ) { //Searching for api.
   140bc:	2300      	movs	r3, #0
   140be:	f88d 300f 	strb.w	r3, [sp, #15]
   140c2:	e026      	b.n	14112 <Det_SearchApi+0x70>
        if ( ModuleStrings_Ptr[ ModuleIndex ].ApiNames[i].ApiId == ApiId ) {
   140c4:	491b      	ldr	r1, [pc, #108]	; (14134 <Det_SearchApi+0x92>)
   140c6:	f89d 2007 	ldrb.w	r2, [sp, #7]
   140ca:	4613      	mov	r3, r2
   140cc:	005b      	lsls	r3, r3, #1
   140ce:	4413      	add	r3, r2
   140d0:	00db      	lsls	r3, r3, #3
   140d2:	440b      	add	r3, r1
   140d4:	68da      	ldr	r2, [r3, #12]
   140d6:	f89d 300f 	ldrb.w	r3, [sp, #15]
   140da:	00db      	lsls	r3, r3, #3
   140dc:	4413      	add	r3, r2
   140de:	781b      	ldrb	r3, [r3, #0]
   140e0:	f89d 2006 	ldrb.w	r2, [sp, #6]
   140e4:	429a      	cmp	r2, r3
   140e6:	d10f      	bne.n	14108 <Det_SearchApi+0x66>
            StringPtr = ModuleStrings_Ptr[ ModuleIndex ].ApiNames[i].ApiName;
   140e8:	4912      	ldr	r1, [pc, #72]	; (14134 <Det_SearchApi+0x92>)
   140ea:	f89d 2007 	ldrb.w	r2, [sp, #7]
   140ee:	4613      	mov	r3, r2
   140f0:	005b      	lsls	r3, r3, #1
   140f2:	4413      	add	r3, r2
   140f4:	00db      	lsls	r3, r3, #3
   140f6:	440b      	add	r3, r1
   140f8:	68da      	ldr	r2, [r3, #12]
   140fa:	f89d 300f 	ldrb.w	r3, [sp, #15]
   140fe:	00db      	lsls	r3, r3, #3
   14100:	4413      	add	r3, r2
   14102:	685b      	ldr	r3, [r3, #4]
   14104:	9302      	str	r3, [sp, #8]
            break;
   14106:	e011      	b.n	1412c <Det_SearchApi+0x8a>
    for ( i = 0; i < ModuleStrings_Ptr[ ModuleIndex ].Apis; i++ ) { //Searching for api.
   14108:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1410c:	3301      	adds	r3, #1
   1410e:	f88d 300f 	strb.w	r3, [sp, #15]
   14112:	4908      	ldr	r1, [pc, #32]	; (14134 <Det_SearchApi+0x92>)
   14114:	f89d 2007 	ldrb.w	r2, [sp, #7]
   14118:	4613      	mov	r3, r2
   1411a:	005b      	lsls	r3, r3, #1
   1411c:	4413      	add	r3, r2
   1411e:	00db      	lsls	r3, r3, #3
   14120:	440b      	add	r3, r1
   14122:	7a1b      	ldrb	r3, [r3, #8]
   14124:	f89d 200f 	ldrb.w	r2, [sp, #15]
   14128:	429a      	cmp	r2, r3
   1412a:	d3cb      	bcc.n	140c4 <Det_SearchApi+0x22>
        }
    }

    return StringPtr;
   1412c:	9b02      	ldr	r3, [sp, #8]
}
   1412e:	4618      	mov	r0, r3
   14130:	b004      	add	sp, #16
   14132:	4770      	bx	lr
   14134:	00015fe4 	.word	0x00015fe4

00014138 <Det_SearchError>:
 * @param[in] ErrorId Error id reported.
 * @return StringPtr Ptr to string of error meaning.
 * 
 * @note If the Error Id isnt registered in the hash table it will return NULL; 
 */
const char* Det_SearchError( uint8 ModuleIndex, uint8 ErrorId ) {
   14138:	b084      	sub	sp, #16
   1413a:	4603      	mov	r3, r0
   1413c:	460a      	mov	r2, r1
   1413e:	f88d 3007 	strb.w	r3, [sp, #7]
   14142:	4613      	mov	r3, r2
   14144:	f88d 3006 	strb.w	r3, [sp, #6]
    //local data.
    uint8 i = 0;
   14148:	2300      	movs	r3, #0
   1414a:	f88d 300f 	strb.w	r3, [sp, #15]
    const char *StringPtr = NULL_PTR;
   1414e:	2300      	movs	r3, #0
   14150:	9302      	str	r3, [sp, #8]

    for ( i = 0; i < ModuleStrings_Ptr[ ModuleIndex ].Errors; i++ ) { //Searching for api.
   14152:	2300      	movs	r3, #0
   14154:	f88d 300f 	strb.w	r3, [sp, #15]
   14158:	e026      	b.n	141a8 <Det_SearchError+0x70>
        if ( ModuleStrings_Ptr[ ModuleIndex ].ErrorMeanings[i].ErrorId == ErrorId ) {
   1415a:	491c      	ldr	r1, [pc, #112]	; (141cc <Det_SearchError+0x94>)
   1415c:	f89d 2007 	ldrb.w	r2, [sp, #7]
   14160:	4613      	mov	r3, r2
   14162:	005b      	lsls	r3, r3, #1
   14164:	4413      	add	r3, r2
   14166:	00db      	lsls	r3, r3, #3
   14168:	440b      	add	r3, r1
   1416a:	695a      	ldr	r2, [r3, #20]
   1416c:	f89d 300f 	ldrb.w	r3, [sp, #15]
   14170:	00db      	lsls	r3, r3, #3
   14172:	4413      	add	r3, r2
   14174:	781b      	ldrb	r3, [r3, #0]
   14176:	f89d 2006 	ldrb.w	r2, [sp, #6]
   1417a:	429a      	cmp	r2, r3
   1417c:	d10f      	bne.n	1419e <Det_SearchError+0x66>
            StringPtr = ModuleStrings_Ptr[ ModuleIndex ].ErrorMeanings[i].ErrorMeaning;
   1417e:	4913      	ldr	r1, [pc, #76]	; (141cc <Det_SearchError+0x94>)
   14180:	f89d 2007 	ldrb.w	r2, [sp, #7]
   14184:	4613      	mov	r3, r2
   14186:	005b      	lsls	r3, r3, #1
   14188:	4413      	add	r3, r2
   1418a:	00db      	lsls	r3, r3, #3
   1418c:	440b      	add	r3, r1
   1418e:	695a      	ldr	r2, [r3, #20]
   14190:	f89d 300f 	ldrb.w	r3, [sp, #15]
   14194:	00db      	lsls	r3, r3, #3
   14196:	4413      	add	r3, r2
   14198:	685b      	ldr	r3, [r3, #4]
   1419a:	9302      	str	r3, [sp, #8]
            break;
   1419c:	e011      	b.n	141c2 <Det_SearchError+0x8a>
    for ( i = 0; i < ModuleStrings_Ptr[ ModuleIndex ].Errors; i++ ) { //Searching for api.
   1419e:	f89d 300f 	ldrb.w	r3, [sp, #15]
   141a2:	3301      	adds	r3, #1
   141a4:	f88d 300f 	strb.w	r3, [sp, #15]
   141a8:	4908      	ldr	r1, [pc, #32]	; (141cc <Det_SearchError+0x94>)
   141aa:	f89d 2007 	ldrb.w	r2, [sp, #7]
   141ae:	4613      	mov	r3, r2
   141b0:	005b      	lsls	r3, r3, #1
   141b2:	4413      	add	r3, r2
   141b4:	00db      	lsls	r3, r3, #3
   141b6:	440b      	add	r3, r1
   141b8:	7c1b      	ldrb	r3, [r3, #16]
   141ba:	f89d 200f 	ldrb.w	r2, [sp, #15]
   141be:	429a      	cmp	r2, r3
   141c0:	d3cb      	bcc.n	1415a <Det_SearchError+0x22>
        }
    }

    return StringPtr;
   141c2:	9b02      	ldr	r3, [sp, #8]
}
   141c4:	4618      	mov	r0, r3
   141c6:	b004      	add	sp, #16
   141c8:	4770      	bx	lr
   141ca:	bf00      	nop
   141cc:	00015fe4 	.word	0x00015fe4

000141d0 <Det_GetModuleName>:
 * @param[in] ModuleId Module Id where error was detected.
 * @return StringPtr Pointer to string module name.
 * 
 * @note If the module Id isnt registered it will return NULL;
 */
const char* Det_GetModuleName( uint16 ModuleId ) {
   141d0:	b084      	sub	sp, #16
   141d2:	4603      	mov	r3, r0
   141d4:	f8ad 3006 	strh.w	r3, [sp, #6]
    //local data 
    uint8 i = 0;
   141d8:	2300      	movs	r3, #0
   141da:	f88d 300f 	strb.w	r3, [sp, #15]
    const char *StringPtr = NULL_PTR;
   141de:	2300      	movs	r3, #0
   141e0:	9302      	str	r3, [sp, #8]

    for ( i = 0; i < DET_MODULES; i++ ) {  //Searching module name.
   141e2:	2300      	movs	r3, #0
   141e4:	f88d 300f 	strb.w	r3, [sp, #15]
   141e8:	e01c      	b.n	14224 <Det_GetModuleName+0x54>
        if ( ModuleStrings_Ptr[i].ModuleId == ModuleId ) {
   141ea:	4912      	ldr	r1, [pc, #72]	; (14234 <Det_GetModuleName+0x64>)
   141ec:	f89d 200f 	ldrb.w	r2, [sp, #15]
   141f0:	4613      	mov	r3, r2
   141f2:	005b      	lsls	r3, r3, #1
   141f4:	4413      	add	r3, r2
   141f6:	00db      	lsls	r3, r3, #3
   141f8:	440b      	add	r3, r1
   141fa:	881b      	ldrh	r3, [r3, #0]
   141fc:	f8bd 2006 	ldrh.w	r2, [sp, #6]
   14200:	429a      	cmp	r2, r3
   14202:	d10a      	bne.n	1421a <Det_GetModuleName+0x4a>
            StringPtr = ModuleStrings_Ptr[i].ModuleName;
   14204:	490b      	ldr	r1, [pc, #44]	; (14234 <Det_GetModuleName+0x64>)
   14206:	f89d 200f 	ldrb.w	r2, [sp, #15]
   1420a:	4613      	mov	r3, r2
   1420c:	005b      	lsls	r3, r3, #1
   1420e:	4413      	add	r3, r2
   14210:	00db      	lsls	r3, r3, #3
   14212:	440b      	add	r3, r1
   14214:	685b      	ldr	r3, [r3, #4]
   14216:	9302      	str	r3, [sp, #8]
            break;
   14218:	e008      	b.n	1422c <Det_GetModuleName+0x5c>
    for ( i = 0; i < DET_MODULES; i++ ) {  //Searching module name.
   1421a:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1421e:	3301      	adds	r3, #1
   14220:	f88d 300f 	strb.w	r3, [sp, #15]
   14224:	f89d 300f 	ldrb.w	r3, [sp, #15]
   14228:	2b0a      	cmp	r3, #10
   1422a:	d9de      	bls.n	141ea <Det_GetModuleName+0x1a>
        }
    }

    return StringPtr;
   1422c:	9b02      	ldr	r3, [sp, #8]
}
   1422e:	4618      	mov	r0, r3
   14230:	b004      	add	sp, #16
   14232:	4770      	bx	lr
   14234:	00015fe4 	.word	0x00015fe4

00014238 <Det_GetApiName>:
 * @param[in] ApiId Api Id where error was detected 
 * @return StringPtr Pointer to string Api name.
 * 
 * @note If the Api Id isnt registered in the hash table it will return NULL;
 */
const char* Det_GetApiName( uint16 ModuleId, uint8 ApiId ) {
   14238:	b500      	push	{lr}
   1423a:	b085      	sub	sp, #20
   1423c:	4603      	mov	r3, r0
   1423e:	460a      	mov	r2, r1
   14240:	f8ad 3006 	strh.w	r3, [sp, #6]
   14244:	4613      	mov	r3, r2
   14246:	f88d 3005 	strb.w	r3, [sp, #5]
    //local data.
    uint8 i = 0;
   1424a:	2300      	movs	r3, #0
   1424c:	f88d 300f 	strb.w	r3, [sp, #15]
    const char *StringPtr = NULL_PTR;
   14250:	2300      	movs	r3, #0
   14252:	9302      	str	r3, [sp, #8]

    for ( i = 0; i < DET_MODULES; i++ ) {  //Searching for module.
   14254:	2300      	movs	r3, #0
   14256:	f88d 300f 	strb.w	r3, [sp, #15]
   1425a:	e01b      	b.n	14294 <Det_GetApiName+0x5c>
        if ( ModuleStrings_Ptr[i].ModuleId == ModuleId ) {
   1425c:	4912      	ldr	r1, [pc, #72]	; (142a8 <Det_GetApiName+0x70>)
   1425e:	f89d 200f 	ldrb.w	r2, [sp, #15]
   14262:	4613      	mov	r3, r2
   14264:	005b      	lsls	r3, r3, #1
   14266:	4413      	add	r3, r2
   14268:	00db      	lsls	r3, r3, #3
   1426a:	440b      	add	r3, r1
   1426c:	881b      	ldrh	r3, [r3, #0]
   1426e:	f8bd 2006 	ldrh.w	r2, [sp, #6]
   14272:	429a      	cmp	r2, r3
   14274:	d109      	bne.n	1428a <Det_GetApiName+0x52>
            StringPtr = Det_SearchApi( i , ApiId ); //Searching Api.
   14276:	f89d 2005 	ldrb.w	r2, [sp, #5]
   1427a:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1427e:	4611      	mov	r1, r2
   14280:	4618      	mov	r0, r3
   14282:	f7ff ff0e 	bl	140a2 <Det_SearchApi>
   14286:	9002      	str	r0, [sp, #8]
            break;
   14288:	e008      	b.n	1429c <Det_GetApiName+0x64>
    for ( i = 0; i < DET_MODULES; i++ ) {  //Searching for module.
   1428a:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1428e:	3301      	adds	r3, #1
   14290:	f88d 300f 	strb.w	r3, [sp, #15]
   14294:	f89d 300f 	ldrb.w	r3, [sp, #15]
   14298:	2b0a      	cmp	r3, #10
   1429a:	d9df      	bls.n	1425c <Det_GetApiName+0x24>
        }
    }

    return StringPtr;
   1429c:	9b02      	ldr	r3, [sp, #8]
}
   1429e:	4618      	mov	r0, r3
   142a0:	b005      	add	sp, #20
   142a2:	f85d fb04 	ldr.w	pc, [sp], #4
   142a6:	bf00      	nop
   142a8:	00015fe4 	.word	0x00015fe4

000142ac <Det_GetErrorMeaning>:
 * @param[in] ErrorId Error Id reported. 
 * @return StringPtr Pointer to string Error meaning.
 * 
 * @note If the Error Id isnt registered in the hash table it will return NULL;
 */
const char* Det_GetErrorMeaning( uint16 ModuleId, uint8 ErrorId ) {
   142ac:	b500      	push	{lr}
   142ae:	b085      	sub	sp, #20
   142b0:	4603      	mov	r3, r0
   142b2:	460a      	mov	r2, r1
   142b4:	f8ad 3006 	strh.w	r3, [sp, #6]
   142b8:	4613      	mov	r3, r2
   142ba:	f88d 3005 	strb.w	r3, [sp, #5]
    //local data.
    uint8 i = 0;
   142be:	2300      	movs	r3, #0
   142c0:	f88d 300f 	strb.w	r3, [sp, #15]
    const char * StringPtr = NULL_PTR;
   142c4:	2300      	movs	r3, #0
   142c6:	9302      	str	r3, [sp, #8]

    for ( i = 0; i < DET_MODULES; i++ ) {  //Searching for module.
   142c8:	2300      	movs	r3, #0
   142ca:	f88d 300f 	strb.w	r3, [sp, #15]
   142ce:	e01b      	b.n	14308 <Det_GetErrorMeaning+0x5c>
        if ( ModuleStrings_Ptr[i].ModuleId == ModuleId ) {
   142d0:	4912      	ldr	r1, [pc, #72]	; (1431c <Det_GetErrorMeaning+0x70>)
   142d2:	f89d 200f 	ldrb.w	r2, [sp, #15]
   142d6:	4613      	mov	r3, r2
   142d8:	005b      	lsls	r3, r3, #1
   142da:	4413      	add	r3, r2
   142dc:	00db      	lsls	r3, r3, #3
   142de:	440b      	add	r3, r1
   142e0:	881b      	ldrh	r3, [r3, #0]
   142e2:	f8bd 2006 	ldrh.w	r2, [sp, #6]
   142e6:	429a      	cmp	r2, r3
   142e8:	d109      	bne.n	142fe <Det_GetErrorMeaning+0x52>
            StringPtr = Det_SearchError( i, ErrorId );
   142ea:	f89d 2005 	ldrb.w	r2, [sp, #5]
   142ee:	f89d 300f 	ldrb.w	r3, [sp, #15]
   142f2:	4611      	mov	r1, r2
   142f4:	4618      	mov	r0, r3
   142f6:	f7ff ff1f 	bl	14138 <Det_SearchError>
   142fa:	9002      	str	r0, [sp, #8]
            break;
   142fc:	e008      	b.n	14310 <Det_GetErrorMeaning+0x64>
    for ( i = 0; i < DET_MODULES; i++ ) {  //Searching for module.
   142fe:	f89d 300f 	ldrb.w	r3, [sp, #15]
   14302:	3301      	adds	r3, #1
   14304:	f88d 300f 	strb.w	r3, [sp, #15]
   14308:	f89d 300f 	ldrb.w	r3, [sp, #15]
   1430c:	2b0a      	cmp	r3, #10
   1430e:	d9df      	bls.n	142d0 <Det_GetErrorMeaning+0x24>
        }
    }

    return StringPtr;
   14310:	9b02      	ldr	r3, [sp, #8]
}
   14312:	4618      	mov	r0, r3
   14314:	b005      	add	sp, #20
   14316:	f85d fb04 	ldr.w	pc, [sp], #4
   1431a:	bf00      	nop
   1431c:	00015fe4 	.word	0x00015fe4

00014320 <Det_ReportError>:
*/
Std_ReturnType Det_ReportError(uint16 ModuleId,
                               uint8 InstanceId,
                               uint8 ApiId,
                               uint8 ErrorId)
{
   14320:	b510      	push	{r4, lr}
   14322:	b088      	sub	sp, #32
   14324:	4604      	mov	r4, r0
   14326:	4608      	mov	r0, r1
   14328:	4611      	mov	r1, r2
   1432a:	461a      	mov	r2, r3
   1432c:	4623      	mov	r3, r4
   1432e:	f8ad 300e 	strh.w	r3, [sp, #14]
   14332:	4603      	mov	r3, r0
   14334:	f88d 300d 	strb.w	r3, [sp, #13]
   14338:	460b      	mov	r3, r1
   1433a:	f88d 300c 	strb.w	r3, [sp, #12]
   1433e:	4613      	mov	r3, r2
   14340:	f88d 300b 	strb.w	r3, [sp, #11]
    //local data.
    const char* Strings_error[3]; //Pointer to strings for the error message.

    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14344:	f7ec fc28 	bl	b98 <Sys_GetCoreID>
   14348:	4603      	mov	r3, r0
   1434a:	9307      	str	r3, [sp, #28]

    Det_ModuleId[u32CoreId] = ModuleId;
   1434c:	4921      	ldr	r1, [pc, #132]	; (143d4 <Det_ReportError+0xb4>)
   1434e:	9b07      	ldr	r3, [sp, #28]
   14350:	f8bd 200e 	ldrh.w	r2, [sp, #14]
   14354:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
    Det_InstanceId[u32CoreId] = InstanceId;
   14358:	4a1f      	ldr	r2, [pc, #124]	; (143d8 <Det_ReportError+0xb8>)
   1435a:	9b07      	ldr	r3, [sp, #28]
   1435c:	4413      	add	r3, r2
   1435e:	f89d 200d 	ldrb.w	r2, [sp, #13]
   14362:	701a      	strb	r2, [r3, #0]
    Det_ApiId[u32CoreId] = ApiId;
   14364:	4a1d      	ldr	r2, [pc, #116]	; (143dc <Det_ReportError+0xbc>)
   14366:	9b07      	ldr	r3, [sp, #28]
   14368:	4413      	add	r3, r2
   1436a:	f89d 200c 	ldrb.w	r2, [sp, #12]
   1436e:	701a      	strb	r2, [r3, #0]
    Det_ErrorId[u32CoreId] = ErrorId;
   14370:	4a1b      	ldr	r2, [pc, #108]	; (143e0 <Det_ReportError+0xc0>)
   14372:	9b07      	ldr	r3, [sp, #28]
   14374:	4413      	add	r3, r2
   14376:	f89d 200b 	ldrb.w	r2, [sp, #11]
   1437a:	701a      	strb	r2, [r3, #0]

    //Obtaining strings for error message.
    Strings_error[0] = Det_GetModuleName( ModuleId );
   1437c:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   14380:	4618      	mov	r0, r3
   14382:	f7ff ff25 	bl	141d0 <Det_GetModuleName>
   14386:	4603      	mov	r3, r0
   14388:	9304      	str	r3, [sp, #16]
    Strings_error[1] = Det_GetApiName( ModuleId, ApiId );
   1438a:	f89d 200c 	ldrb.w	r2, [sp, #12]
   1438e:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   14392:	4611      	mov	r1, r2
   14394:	4618      	mov	r0, r3
   14396:	f7ff ff4f 	bl	14238 <Det_GetApiName>
   1439a:	4603      	mov	r3, r0
   1439c:	9305      	str	r3, [sp, #20]
    Strings_error[2] = Det_GetErrorMeaning( ModuleId, ErrorId );
   1439e:	f89d 200b 	ldrb.w	r2, [sp, #11]
   143a2:	f8bd 300e 	ldrh.w	r3, [sp, #14]
   143a6:	4611      	mov	r1, r2
   143a8:	4618      	mov	r0, r3
   143aa:	f7ff ff7f 	bl	142ac <Det_GetErrorMeaning>
   143ae:	4603      	mov	r3, r0
   143b0:	9306      	str	r3, [sp, #24]

    SEGGER_RTT_printf( 0, "Error: Error in %s in function %s with the instance %d, %s\n", 
   143b2:	9904      	ldr	r1, [sp, #16]
   143b4:	9805      	ldr	r0, [sp, #20]
   143b6:	f89d 300d 	ldrb.w	r3, [sp, #13]
   143ba:	9a06      	ldr	r2, [sp, #24]
   143bc:	9201      	str	r2, [sp, #4]
   143be:	9300      	str	r3, [sp, #0]
   143c0:	4603      	mov	r3, r0
   143c2:	460a      	mov	r2, r1
   143c4:	4907      	ldr	r1, [pc, #28]	; (143e4 <Det_ReportError+0xc4>)
   143c6:	2000      	movs	r0, #0
   143c8:	f7ed f8ec 	bl	15a4 <SEGGER_RTT_printf>
    Strings_error[0], Strings_error[1], InstanceId, Strings_error[2] );

    return E_OK;
   143cc:	2300      	movs	r3, #0
}
   143ce:	4618      	mov	r0, r3
   143d0:	b008      	add	sp, #32
   143d2:	bd10      	pop	{r4, pc}
   143d4:	1fff9538 	.word	0x1fff9538
   143d8:	1fff9510 	.word	0x1fff9510
   143dc:	1fff9514 	.word	0x1fff9514
   143e0:	1fff9518 	.word	0x1fff9518
   143e4:	000153e0 	.word	0x000153e0

000143e8 <Det_ReportRuntimeError>:
*/
Std_ReturnType Det_ReportRuntimeError(uint16 ModuleId,
                                      uint8 InstanceId,
                                      uint8 ApiId,
                                      uint8 ErrorId)
{
   143e8:	b510      	push	{r4, lr}
   143ea:	b084      	sub	sp, #16
   143ec:	4604      	mov	r4, r0
   143ee:	4608      	mov	r0, r1
   143f0:	4611      	mov	r1, r2
   143f2:	461a      	mov	r2, r3
   143f4:	4623      	mov	r3, r4
   143f6:	f8ad 3006 	strh.w	r3, [sp, #6]
   143fa:	4603      	mov	r3, r0
   143fc:	f88d 3005 	strb.w	r3, [sp, #5]
   14400:	460b      	mov	r3, r1
   14402:	f88d 3004 	strb.w	r3, [sp, #4]
   14406:	4613      	mov	r3, r2
   14408:	f88d 3003 	strb.w	r3, [sp, #3]
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   1440c:	f7ec fbc4 	bl	b98 <Sys_GetCoreID>
   14410:	4603      	mov	r3, r0
   14412:	9303      	str	r3, [sp, #12]

    Det_RuntimeModuleId[u32CoreId] = ModuleId;
   14414:	490d      	ldr	r1, [pc, #52]	; (1444c <Det_ReportRuntimeError+0x64>)
   14416:	9b03      	ldr	r3, [sp, #12]
   14418:	f8bd 2006 	ldrh.w	r2, [sp, #6]
   1441c:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
    Det_RuntimeInstanceId[u32CoreId] = InstanceId;
   14420:	4a0b      	ldr	r2, [pc, #44]	; (14450 <Det_ReportRuntimeError+0x68>)
   14422:	9b03      	ldr	r3, [sp, #12]
   14424:	4413      	add	r3, r2
   14426:	f89d 2005 	ldrb.w	r2, [sp, #5]
   1442a:	701a      	strb	r2, [r3, #0]
    Det_RuntimeApiId[u32CoreId] = ApiId;
   1442c:	4a09      	ldr	r2, [pc, #36]	; (14454 <Det_ReportRuntimeError+0x6c>)
   1442e:	9b03      	ldr	r3, [sp, #12]
   14430:	4413      	add	r3, r2
   14432:	f89d 2004 	ldrb.w	r2, [sp, #4]
   14436:	701a      	strb	r2, [r3, #0]
    Det_RuntimeErrorId[u32CoreId] = ErrorId;
   14438:	4a07      	ldr	r2, [pc, #28]	; (14458 <Det_ReportRuntimeError+0x70>)
   1443a:	9b03      	ldr	r3, [sp, #12]
   1443c:	4413      	add	r3, r2
   1443e:	f89d 2003 	ldrb.w	r2, [sp, #3]
   14442:	701a      	strb	r2, [r3, #0]

    return E_OK;
   14444:	2300      	movs	r3, #0
}
   14446:	4618      	mov	r0, r3
   14448:	b004      	add	sp, #16
   1444a:	bd10      	pop	{r4, pc}
   1444c:	1fff953c 	.word	0x1fff953c
   14450:	1fff951c 	.word	0x1fff951c
   14454:	1fff9520 	.word	0x1fff9520
   14458:	1fff9524 	.word	0x1fff9524

0001445c <Det_ReportTransientFault>:
*/
Std_ReturnType Det_ReportTransientFault(uint16 ModuleId,
                                        uint8 InstanceId,
                                        uint8 ApiId,
                                        uint8 FaultId)
{
   1445c:	b510      	push	{r4, lr}
   1445e:	b084      	sub	sp, #16
   14460:	4604      	mov	r4, r0
   14462:	4608      	mov	r0, r1
   14464:	4611      	mov	r1, r2
   14466:	461a      	mov	r2, r3
   14468:	4623      	mov	r3, r4
   1446a:	f8ad 3006 	strh.w	r3, [sp, #6]
   1446e:	4603      	mov	r3, r0
   14470:	f88d 3005 	strb.w	r3, [sp, #5]
   14474:	460b      	mov	r3, r1
   14476:	f88d 3004 	strb.w	r3, [sp, #4]
   1447a:	4613      	mov	r3, r2
   1447c:	f88d 3003 	strb.w	r3, [sp, #3]
    uint32 u32CoreId = (uint32)OsIf_GetCoreID();
   14480:	f7ec fb8a 	bl	b98 <Sys_GetCoreID>
   14484:	4603      	mov	r3, r0
   14486:	9303      	str	r3, [sp, #12]

    Det_TransientModuleId[u32CoreId] = ModuleId;
   14488:	490d      	ldr	r1, [pc, #52]	; (144c0 <Det_ReportTransientFault+0x64>)
   1448a:	9b03      	ldr	r3, [sp, #12]
   1448c:	f8bd 2006 	ldrh.w	r2, [sp, #6]
   14490:	f821 2013 	strh.w	r2, [r1, r3, lsl #1]
    Det_TransientInstanceId[u32CoreId] = InstanceId;
   14494:	4a0b      	ldr	r2, [pc, #44]	; (144c4 <Det_ReportTransientFault+0x68>)
   14496:	9b03      	ldr	r3, [sp, #12]
   14498:	4413      	add	r3, r2
   1449a:	f89d 2005 	ldrb.w	r2, [sp, #5]
   1449e:	701a      	strb	r2, [r3, #0]
    Det_TransientApiId[u32CoreId] = ApiId;
   144a0:	4a09      	ldr	r2, [pc, #36]	; (144c8 <Det_ReportTransientFault+0x6c>)
   144a2:	9b03      	ldr	r3, [sp, #12]
   144a4:	4413      	add	r3, r2
   144a6:	f89d 2004 	ldrb.w	r2, [sp, #4]
   144aa:	701a      	strb	r2, [r3, #0]
    Det_TransientFaultId[u32CoreId] = FaultId;
   144ac:	4a07      	ldr	r2, [pc, #28]	; (144cc <Det_ReportTransientFault+0x70>)
   144ae:	9b03      	ldr	r3, [sp, #12]
   144b0:	4413      	add	r3, r2
   144b2:	f89d 2003 	ldrb.w	r2, [sp, #3]
   144b6:	701a      	strb	r2, [r3, #0]

    return E_OK;
   144b8:	2300      	movs	r3, #0
}
   144ba:	4618      	mov	r0, r3
   144bc:	b004      	add	sp, #16
   144be:	bd10      	pop	{r4, pc}
   144c0:	1fff9534 	.word	0x1fff9534
   144c4:	1fff9528 	.word	0x1fff9528
   144c8:	1fff952c 	.word	0x1fff952c
   144cc:	1fff9530 	.word	0x1fff9530

000144d0 <Det_Start>:
* @requirement DET010
*/
void Det_Start(void)
{
    /* Do nothing */
}
   144d0:	bf00      	nop
   144d2:	4770      	bx	lr

000144d4 <CanIf_Init>:
 * @brief This function initialices the CanIf Driver.
 * 
 * @param ConfigPtr Pointer to driver control structure. 
 */
void CanIf_Init(const CanIf_ConfigType * ConfigPtr)
{
   144d4:	b082      	sub	sp, #8
   144d6:	9001      	str	r0, [sp, #4]
    #if (STD_ON == CANIF_PRECOMPILE_SUPPORT)
    CanIf_ConfigPtr = &CanIf_Config;
    (void)ConfigPtr;
    #else
    CanIf_ConfigPtr = ConfigPtr;
   144d8:	4a02      	ldr	r2, [pc, #8]	; (144e4 <CanIf_Init+0x10>)
   144da:	9b01      	ldr	r3, [sp, #4]
   144dc:	6013      	str	r3, [r2, #0]
    #endif
}
   144de:	bf00      	nop
   144e0:	b002      	add	sp, #8
   144e2:	4770      	bx	lr
   144e4:	1fff9540 	.word	0x1fff9540

000144e8 <CanIf_Transmit>:
Std_ReturnType CanIf_Transmit
(
    PduIdType CanTxPduId,
    const PduInfoType * PduInfoPtr
)
{
   144e8:	b500      	push	{lr}
   144ea:	b08b      	sub	sp, #44	; 0x2c
   144ec:	4603      	mov	r3, r0
   144ee:	9100      	str	r1, [sp, #0]
   144f0:	f8ad 3006 	strh.w	r3, [sp, #6]
    Std_ReturnType RetVal = E_NOT_OK;
   144f4:	2301      	movs	r3, #1
   144f6:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
    Can_HwHandleType CanHth = 0U;
   144fa:	2300      	movs	r3, #0
   144fc:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
    Can_PduType PduInfo;
    const CanIf_TxPduType * TxPduInfo = NULL_PTR;
   14500:	2300      	movs	r3, #0
   14502:	9308      	str	r3, [sp, #32]
    uint8 CanIfControllerId = 0U;
   14504:	2300      	movs	r3, #0
   14506:	f88d 301f 	strb.w	r3, [sp, #31]
    const CanIf_CtrlPCConfigType * CanIfController = NULL_PTR;
   1450a:	2300      	movs	r3, #0
   1450c:	9306      	str	r3, [sp, #24]

    if (NULL_PTR != CanIf_ConfigPtr)
   1450e:	4b31      	ldr	r3, [pc, #196]	; (145d4 <CanIf_Transmit+0xec>)
   14510:	681b      	ldr	r3, [r3, #0]
   14512:	2b00      	cmp	r3, #0
   14514:	d057      	beq.n	145c6 <CanIf_Transmit+0xde>
    {
        if (CanTxPduId < (CanIf_ConfigPtr->NumTxPdu))
   14516:	4b2f      	ldr	r3, [pc, #188]	; (145d4 <CanIf_Transmit+0xec>)
   14518:	681b      	ldr	r3, [r3, #0]
   1451a:	785b      	ldrb	r3, [r3, #1]
   1451c:	b29b      	uxth	r3, r3
   1451e:	f8bd 2006 	ldrh.w	r2, [sp, #6]
   14522:	429a      	cmp	r2, r3
   14524:	d24f      	bcs.n	145c6 <CanIf_Transmit+0xde>
        {
            TxPduInfo = &CanIf_ConfigPtr->CanIf_TxPduConfigPtr[CanTxPduId];
   14526:	4b2b      	ldr	r3, [pc, #172]	; (145d4 <CanIf_Transmit+0xec>)
   14528:	681b      	ldr	r3, [r3, #0]
   1452a:	68d9      	ldr	r1, [r3, #12]
   1452c:	f8bd 2006 	ldrh.w	r2, [sp, #6]
   14530:	4613      	mov	r3, r2
   14532:	009b      	lsls	r3, r3, #2
   14534:	4413      	add	r3, r2
   14536:	009b      	lsls	r3, r3, #2
   14538:	440b      	add	r3, r1
   1453a:	9308      	str	r3, [sp, #32]
            CanIfControllerId = TxPduInfo->CanIfCtrlId;
   1453c:	9b08      	ldr	r3, [sp, #32]
   1453e:	7b9b      	ldrb	r3, [r3, #14]
   14540:	f88d 301f 	strb.w	r3, [sp, #31]
            CanIfController = &CanIf_PCConfig.CanIfCtrlConfigPtr[CanIfControllerId];
   14544:	4b24      	ldr	r3, [pc, #144]	; (145d8 <CanIf_Transmit+0xf0>)
   14546:	685a      	ldr	r2, [r3, #4]
   14548:	f89d 301f 	ldrb.w	r3, [sp, #31]
   1454c:	00db      	lsls	r3, r3, #3
   1454e:	4413      	add	r3, r2
   14550:	9306      	str	r3, [sp, #24]

            CanHth = TxPduInfo->CanHth;
   14552:	9b08      	ldr	r3, [sp, #32]
   14554:	899b      	ldrh	r3, [r3, #12]
   14556:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24

            PduInfo.id = TxPduInfo->CanId;
   1455a:	9b08      	ldr	r3, [sp, #32]
   1455c:	685b      	ldr	r3, [r3, #4]
   1455e:	9303      	str	r3, [sp, #12]
            /* Convert Id by adding two most significant bits specify the frame type */
            switch (TxPduInfo->CanFrameType)
   14560:	9b08      	ldr	r3, [sp, #32]
   14562:	689b      	ldr	r3, [r3, #8]
   14564:	2b03      	cmp	r3, #3
   14566:	d010      	beq.n	1458a <CanIf_Transmit+0xa2>
   14568:	2b03      	cmp	r3, #3
   1456a:	d813      	bhi.n	14594 <CanIf_Transmit+0xac>
   1456c:	2b00      	cmp	r3, #0
   1456e:	d002      	beq.n	14576 <CanIf_Transmit+0x8e>
   14570:	2b01      	cmp	r3, #1
   14572:	d005      	beq.n	14580 <CanIf_Transmit+0x98>
                    PduInfo.id |= 0x40000000U;
                    break;
                }
                default:
                {
                    break;
   14574:	e00e      	b.n	14594 <CanIf_Transmit+0xac>
                    PduInfo.id |= 0x80000000U;
   14576:	9b03      	ldr	r3, [sp, #12]
   14578:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   1457c:	9303      	str	r3, [sp, #12]
                    break;
   1457e:	e00a      	b.n	14596 <CanIf_Transmit+0xae>
                    PduInfo.id |= 0xC0000000U;
   14580:	9b03      	ldr	r3, [sp, #12]
   14582:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
   14586:	9303      	str	r3, [sp, #12]
                    break;
   14588:	e005      	b.n	14596 <CanIf_Transmit+0xae>
                    PduInfo.id |= 0x40000000U;
   1458a:	9b03      	ldr	r3, [sp, #12]
   1458c:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
   14590:	9303      	str	r3, [sp, #12]
                    break;
   14592:	e000      	b.n	14596 <CanIf_Transmit+0xae>
                    break;
   14594:	bf00      	nop
                }
            }
            
            PduInfo.length = (uint8)(PduInfoPtr->SduLength);
   14596:	9b00      	ldr	r3, [sp, #0]
   14598:	689b      	ldr	r3, [r3, #8]
   1459a:	b2db      	uxtb	r3, r3
   1459c:	f88d 3012 	strb.w	r3, [sp, #18]
            PduInfo.sdu = PduInfoPtr->SduDataPtr;
   145a0:	9b00      	ldr	r3, [sp, #0]
   145a2:	681b      	ldr	r3, [r3, #0]
   145a4:	9305      	str	r3, [sp, #20]
            PduInfo.swPduHandle = CanTxPduId;
   145a6:	f8bd 3006 	ldrh.w	r3, [sp, #6]
   145aa:	f8ad 3010 	strh.w	r3, [sp, #16]

            RetVal = CanIfController->CanDrvConfigPtr->CanApi->CanWrite(CanHth, &PduInfo); 
   145ae:	9b06      	ldr	r3, [sp, #24]
   145b0:	685b      	ldr	r3, [r3, #4]
   145b2:	685b      	ldr	r3, [r3, #4]
   145b4:	681b      	ldr	r3, [r3, #0]
   145b6:	a903      	add	r1, sp, #12
   145b8:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
   145bc:	4610      	mov	r0, r2
   145be:	4798      	blx	r3
   145c0:	4603      	mov	r3, r0
   145c2:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
        }
    }
    return RetVal;
   145c6:	f89d 3027 	ldrb.w	r3, [sp, #39]	; 0x27
}
   145ca:	4618      	mov	r0, r3
   145cc:	b00b      	add	sp, #44	; 0x2c
   145ce:	f85d fb04 	ldr.w	pc, [sp], #4
   145d2:	bf00      	nop
   145d4:	1fff9540 	.word	0x1fff9540
   145d8:	0001611c 	.word	0x0001611c

000145dc <CanIf_TxConfirmation>:

void CanIf_TxConfirmation
(
    PduIdType CanTxPduId
)
{
   145dc:	b500      	push	{lr}
   145de:	b085      	sub	sp, #20
   145e0:	4603      	mov	r3, r0
   145e2:	f8ad 3006 	strh.w	r3, [sp, #6]
    PduIdType UserPduId;
    const CanIf_TxPduType * TxPduInfo = NULL_PTR;
   145e6:	2300      	movs	r3, #0
   145e8:	9303      	str	r3, [sp, #12]

    if (NULL_PTR != CanIf_ConfigPtr)
   145ea:	4b15      	ldr	r3, [pc, #84]	; (14640 <CanIf_TxConfirmation+0x64>)
   145ec:	681b      	ldr	r3, [r3, #0]
   145ee:	2b00      	cmp	r3, #0
   145f0:	d021      	beq.n	14636 <CanIf_TxConfirmation+0x5a>
    {
        if (CanTxPduId < (CanIf_ConfigPtr->NumTxPdu))
   145f2:	4b13      	ldr	r3, [pc, #76]	; (14640 <CanIf_TxConfirmation+0x64>)
   145f4:	681b      	ldr	r3, [r3, #0]
   145f6:	785b      	ldrb	r3, [r3, #1]
   145f8:	b29b      	uxth	r3, r3
   145fa:	f8bd 2006 	ldrh.w	r2, [sp, #6]
   145fe:	429a      	cmp	r2, r3
   14600:	d219      	bcs.n	14636 <CanIf_TxConfirmation+0x5a>
        {
            TxPduInfo = &CanIf_ConfigPtr->CanIf_TxPduConfigPtr[CanTxPduId];
   14602:	4b0f      	ldr	r3, [pc, #60]	; (14640 <CanIf_TxConfirmation+0x64>)
   14604:	681b      	ldr	r3, [r3, #0]
   14606:	68d9      	ldr	r1, [r3, #12]
   14608:	f8bd 2006 	ldrh.w	r2, [sp, #6]
   1460c:	4613      	mov	r3, r2
   1460e:	009b      	lsls	r3, r3, #2
   14610:	4413      	add	r3, r2
   14612:	009b      	lsls	r3, r3, #2
   14614:	440b      	add	r3, r1
   14616:	9303      	str	r3, [sp, #12]

            if (NULL_PTR != TxPduInfo->UserTxConfirmation)
   14618:	9b03      	ldr	r3, [sp, #12]
   1461a:	691b      	ldr	r3, [r3, #16]
   1461c:	2b00      	cmp	r3, #0
   1461e:	d00a      	beq.n	14636 <CanIf_TxConfirmation+0x5a>
            {
                UserPduId = TxPduInfo->PduId;
   14620:	9b03      	ldr	r3, [sp, #12]
   14622:	881b      	ldrh	r3, [r3, #0]
   14624:	f8ad 300a 	strh.w	r3, [sp, #10]
                TxPduInfo->UserTxConfirmation(UserPduId, E_OK);
   14628:	9b03      	ldr	r3, [sp, #12]
   1462a:	691b      	ldr	r3, [r3, #16]
   1462c:	f8bd 200a 	ldrh.w	r2, [sp, #10]
   14630:	2100      	movs	r1, #0
   14632:	4610      	mov	r0, r2
   14634:	4798      	blx	r3
            }
        }
    }
}
   14636:	bf00      	nop
   14638:	b005      	add	sp, #20
   1463a:	f85d fb04 	ldr.w	pc, [sp], #4
   1463e:	bf00      	nop
   14640:	1fff9540 	.word	0x1fff9540

00014644 <CanIf_RxIndication>:
void CanIf_RxIndication
(
    const Can_HwType * Mailbox,
    const PduInfoType * PduInfoPtr
)
{
   14644:	b500      	push	{lr}
   14646:	b089      	sub	sp, #36	; 0x24
   14648:	9001      	str	r0, [sp, #4]
   1464a:	9100      	str	r1, [sp, #0]
    PduIdType UserPduId = 0U;
   1464c:	2300      	movs	r3, #0
   1464e:	f8ad 301e 	strh.w	r3, [sp, #30]
    PduInfoType PduInfo;
    const CanIf_RxPduType * RxPduInfo = NULL_PTR;
   14652:	2300      	movs	r3, #0
   14654:	9306      	str	r3, [sp, #24]
    uint8 CanDrvId = 0U;
   14656:	2300      	movs	r3, #0
   14658:	f88d 3017 	strb.w	r3, [sp, #23]

    if (NULL_PTR != CanIf_ConfigPtr)
   1465c:	4b2c      	ldr	r3, [pc, #176]	; (14710 <CanIf_RxIndication+0xcc>)
   1465e:	681b      	ldr	r3, [r3, #0]
   14660:	2b00      	cmp	r3, #0
   14662:	d050      	beq.n	14706 <CanIf_RxIndication+0xc2>
    {
        if ((Mailbox->ControllerId) < (CanIf_PCConfig.NumOfCtrl))
   14664:	9b01      	ldr	r3, [sp, #4]
   14666:	799a      	ldrb	r2, [r3, #6]
   14668:	4b2a      	ldr	r3, [pc, #168]	; (14714 <CanIf_RxIndication+0xd0>)
   1466a:	781b      	ldrb	r3, [r3, #0]
   1466c:	429a      	cmp	r2, r3
   1466e:	d24a      	bcs.n	14706 <CanIf_RxIndication+0xc2>
        {
            if ((Mailbox->Hoh) < (CanIf_PCConfig.CanIfCtrlConfigPtr[Mailbox->ControllerId].CanDrvConfigPtr->NumCanHoh))
   14670:	9b01      	ldr	r3, [sp, #4]
   14672:	889a      	ldrh	r2, [r3, #4]
   14674:	4b27      	ldr	r3, [pc, #156]	; (14714 <CanIf_RxIndication+0xd0>)
   14676:	6859      	ldr	r1, [r3, #4]
   14678:	9b01      	ldr	r3, [sp, #4]
   1467a:	799b      	ldrb	r3, [r3, #6]
   1467c:	00db      	lsls	r3, r3, #3
   1467e:	440b      	add	r3, r1
   14680:	685b      	ldr	r3, [r3, #4]
   14682:	885b      	ldrh	r3, [r3, #2]
   14684:	429a      	cmp	r2, r3
   14686:	d23e      	bcs.n	14706 <CanIf_RxIndication+0xc2>
            {
                CanDrvId = CanIf_PCConfig.CanIfCtrlConfigPtr[Mailbox->ControllerId].CanDrvConfigPtr->CanDrvId;
   14688:	4b22      	ldr	r3, [pc, #136]	; (14714 <CanIf_RxIndication+0xd0>)
   1468a:	685a      	ldr	r2, [r3, #4]
   1468c:	9b01      	ldr	r3, [sp, #4]
   1468e:	799b      	ldrb	r3, [r3, #6]
   14690:	00db      	lsls	r3, r3, #3
   14692:	4413      	add	r3, r2
   14694:	685b      	ldr	r3, [r3, #4]
   14696:	781b      	ldrb	r3, [r3, #0]
   14698:	f88d 3017 	strb.w	r3, [sp, #23]
                RxPduInfo = CanIf_ConfigPtr->CanDrvConfigPtr[CanDrvId]->HohToRxPduMappingPtr[Mailbox->Hoh];
   1469c:	4b1c      	ldr	r3, [pc, #112]	; (14710 <CanIf_RxIndication+0xcc>)
   1469e:	681b      	ldr	r3, [r3, #0]
   146a0:	685a      	ldr	r2, [r3, #4]
   146a2:	f89d 3017 	ldrb.w	r3, [sp, #23]
   146a6:	009b      	lsls	r3, r3, #2
   146a8:	4413      	add	r3, r2
   146aa:	681b      	ldr	r3, [r3, #0]
   146ac:	681a      	ldr	r2, [r3, #0]
   146ae:	9b01      	ldr	r3, [sp, #4]
   146b0:	889b      	ldrh	r3, [r3, #4]
   146b2:	009b      	lsls	r3, r3, #2
   146b4:	4413      	add	r3, r2
   146b6:	681b      	ldr	r3, [r3, #0]
   146b8:	9306      	str	r3, [sp, #24]
                
                /* Will discard the Can HOH if it was not referred by any CanIf RxPDU */
                if (NULL_PTR != RxPduInfo)
   146ba:	9b06      	ldr	r3, [sp, #24]
   146bc:	2b00      	cmp	r3, #0
   146be:	d022      	beq.n	14706 <CanIf_RxIndication+0xc2>
                {
                    if (NULL_PTR != RxPduInfo->UserRxIndication)
   146c0:	9b06      	ldr	r3, [sp, #24]
   146c2:	689b      	ldr	r3, [r3, #8]
   146c4:	2b00      	cmp	r3, #0
   146c6:	d01e      	beq.n	14706 <CanIf_RxIndication+0xc2>
                    {
                        UserPduId = RxPduInfo->PduId;
   146c8:	9b06      	ldr	r3, [sp, #24]
   146ca:	881b      	ldrh	r3, [r3, #0]
   146cc:	f8ad 301e 	strh.w	r3, [sp, #30]
                        if ((TRUE == RxPduInfo->PduLengthCheck) && (PduInfoPtr->SduLength > (RxPduInfo->PduLength)))
   146d0:	9b06      	ldr	r3, [sp, #24]
   146d2:	789b      	ldrb	r3, [r3, #2]
   146d4:	2b00      	cmp	r3, #0
   146d6:	d009      	beq.n	146ec <CanIf_RxIndication+0xa8>
   146d8:	9b00      	ldr	r3, [sp, #0]
   146da:	689b      	ldr	r3, [r3, #8]
   146dc:	9a06      	ldr	r2, [sp, #24]
   146de:	8892      	ldrh	r2, [r2, #4]
   146e0:	4293      	cmp	r3, r2
   146e2:	d903      	bls.n	146ec <CanIf_RxIndication+0xa8>
                        {
                            PduInfo.SduLength = RxPduInfo->PduLength; /* Truncates exceeded data as configured on GUI */
   146e4:	9b06      	ldr	r3, [sp, #24]
   146e6:	889b      	ldrh	r3, [r3, #4]
   146e8:	9304      	str	r3, [sp, #16]
   146ea:	e002      	b.n	146f2 <CanIf_RxIndication+0xae>
                        }
                        else
                        {
                            PduInfo.SduLength = PduInfoPtr->SduLength;
   146ec:	9b00      	ldr	r3, [sp, #0]
   146ee:	689b      	ldr	r3, [r3, #8]
   146f0:	9304      	str	r3, [sp, #16]
                        }
                        PduInfo.SduDataPtr = PduInfoPtr->SduDataPtr;
   146f2:	9b00      	ldr	r3, [sp, #0]
   146f4:	681b      	ldr	r3, [r3, #0]
   146f6:	9302      	str	r3, [sp, #8]
                        RxPduInfo->UserRxIndication(UserPduId, &PduInfo);
   146f8:	9b06      	ldr	r3, [sp, #24]
   146fa:	689b      	ldr	r3, [r3, #8]
   146fc:	a902      	add	r1, sp, #8
   146fe:	f8bd 201e 	ldrh.w	r2, [sp, #30]
   14702:	4610      	mov	r0, r2
   14704:	4798      	blx	r3
                    }
                }
            }
        }
    }
}
   14706:	bf00      	nop
   14708:	b009      	add	sp, #36	; 0x24
   1470a:	f85d fb04 	ldr.w	pc, [sp], #4
   1470e:	bf00      	nop
   14710:	1fff9540 	.word	0x1fff9540
   14714:	0001611c 	.word	0x0001611c

00014718 <CanIf_ControllerModeIndication>:
void CanIf_ControllerModeIndication
( 
    uint8 ControllerId, 
    Can_ControllerStateType ControllerMode 
)
{
   14718:	b082      	sub	sp, #8
   1471a:	4603      	mov	r3, r0
   1471c:	9100      	str	r1, [sp, #0]
   1471e:	f88d 3007 	strb.w	r3, [sp, #7]
    (void)ControllerId; 
    (void)ControllerMode;
}
   14722:	bf00      	nop
   14724:	b002      	add	sp, #8
   14726:	4770      	bx	lr

00014728 <CanIf_ControllerBusOff>:

void CanIf_ControllerBusOff
(
    uint8 ControllerId
)
{
   14728:	b082      	sub	sp, #8
   1472a:	4603      	mov	r3, r0
   1472c:	f88d 3007 	strb.w	r3, [sp, #7]
    (void)ControllerId;
}
   14730:	bf00      	nop
   14732:	b002      	add	sp, #8
   14734:	4770      	bx	lr

00014736 <CanIf_SetControllerMode>:
 * 
 * @param Controller CanIf controller ID.
 * @param Transition Desired state.
 * @return RetVal Status of the operation.
 */
Std_ReturnType CanIf_SetControllerMode( uint8 Controller, Can_ControllerStateType Transition ) {
   14736:	b500      	push	{lr}
   14738:	b087      	sub	sp, #28
   1473a:	4603      	mov	r3, r0
   1473c:	9100      	str	r1, [sp, #0]
   1473e:	f88d 3007 	strb.w	r3, [sp, #7]
    //Local data.
    Std_ReturnType RetVal = E_NOT_OK;
   14742:	2301      	movs	r3, #1
   14744:	f88d 3017 	strb.w	r3, [sp, #23]
    const CanIf_CtrlPCConfigType * CanIfControllerConf = NULL_PTR;    //Pointer to CanIf controller configuration.
   14748:	2300      	movs	r3, #0
   1474a:	9304      	str	r3, [sp, #16]
    uint8 CanController_ID = 0; //Can controller ID.
   1474c:	2300      	movs	r3, #0
   1474e:	f88d 300f 	strb.w	r3, [sp, #15]


    if ( CanIf_ConfigPtr != NULL_PTR ) { 
   14752:	4b13      	ldr	r3, [pc, #76]	; (147a0 <CanIf_SetControllerMode+0x6a>)
   14754:	681b      	ldr	r3, [r3, #0]
   14756:	2b00      	cmp	r3, #0
   14758:	d01c      	beq.n	14794 <CanIf_SetControllerMode+0x5e>
        if ( Controller < CanIf_PCConfig.NumOfCtrl ) { //Operation can be done as normal.
   1475a:	4b12      	ldr	r3, [pc, #72]	; (147a4 <CanIf_SetControllerMode+0x6e>)
   1475c:	781b      	ldrb	r3, [r3, #0]
   1475e:	f89d 2007 	ldrb.w	r2, [sp, #7]
   14762:	429a      	cmp	r2, r3
   14764:	d216      	bcs.n	14794 <CanIf_SetControllerMode+0x5e>
            CanIfControllerConf = &CanIf_PCConfig.CanIfCtrlConfigPtr[ Controller ];
   14766:	4b0f      	ldr	r3, [pc, #60]	; (147a4 <CanIf_SetControllerMode+0x6e>)
   14768:	685a      	ldr	r2, [r3, #4]
   1476a:	f89d 3007 	ldrb.w	r3, [sp, #7]
   1476e:	00db      	lsls	r3, r3, #3
   14770:	4413      	add	r3, r2
   14772:	9304      	str	r3, [sp, #16]
            CanController_ID = CanIfControllerConf->CanCtrlId;
   14774:	9b04      	ldr	r3, [sp, #16]
   14776:	785b      	ldrb	r3, [r3, #1]
   14778:	f88d 300f 	strb.w	r3, [sp, #15]
            RetVal = CanIfControllerConf->CanDrvConfigPtr->CanApi->CanSetMode( CanController_ID, Transition );   //Calling Can Driver Api.
   1477c:	9b04      	ldr	r3, [sp, #16]
   1477e:	685b      	ldr	r3, [r3, #4]
   14780:	685b      	ldr	r3, [r3, #4]
   14782:	685b      	ldr	r3, [r3, #4]
   14784:	f89d 200f 	ldrb.w	r2, [sp, #15]
   14788:	9900      	ldr	r1, [sp, #0]
   1478a:	4610      	mov	r0, r2
   1478c:	4798      	blx	r3
   1478e:	4603      	mov	r3, r0
   14790:	f88d 3017 	strb.w	r3, [sp, #23]
        }
    }

    return RetVal;
   14794:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
   14798:	4618      	mov	r0, r3
   1479a:	b007      	add	sp, #28
   1479c:	f85d fb04 	ldr.w	pc, [sp], #4
   147a0:	1fff9540 	.word	0x1fff9540
   147a4:	0001611c 	.word	0x0001611c

000147a8 <CanIf_EnableControllerInterrupts>:
/**
 * @brief This function enables the interrupts of a given CanIf controller.
 * 
 * @param Controller CanIf controller ID.
 */
void CanIf_EnableControllerInterrupts( uint8 Controller ) {
   147a8:	b500      	push	{lr}
   147aa:	b085      	sub	sp, #20
   147ac:	4603      	mov	r3, r0
   147ae:	f88d 3007 	strb.w	r3, [sp, #7]
    //local data.
    const CanIf_CtrlPCConfigType * CanIfControllerConf = NULL_PTR;    //Pointer to CanIf controller configuration.
   147b2:	2300      	movs	r3, #0
   147b4:	9303      	str	r3, [sp, #12]
    uint8 CanController_ID = 0; //Can controller ID.
   147b6:	2300      	movs	r3, #0
   147b8:	f88d 300b 	strb.w	r3, [sp, #11]

    if ( CanIf_ConfigPtr != NULL_PTR ) { 
   147bc:	4b10      	ldr	r3, [pc, #64]	; (14800 <CanIf_EnableControllerInterrupts+0x58>)
   147be:	681b      	ldr	r3, [r3, #0]
   147c0:	2b00      	cmp	r3, #0
   147c2:	d018      	beq.n	147f6 <CanIf_EnableControllerInterrupts+0x4e>
        if ( Controller < CanIf_PCConfig.NumOfCtrl ) { //Operation can be done as normal.
   147c4:	4b0f      	ldr	r3, [pc, #60]	; (14804 <CanIf_EnableControllerInterrupts+0x5c>)
   147c6:	781b      	ldrb	r3, [r3, #0]
   147c8:	f89d 2007 	ldrb.w	r2, [sp, #7]
   147cc:	429a      	cmp	r2, r3
   147ce:	d212      	bcs.n	147f6 <CanIf_EnableControllerInterrupts+0x4e>
            CanIfControllerConf = &CanIf_PCConfig.CanIfCtrlConfigPtr[ Controller ];
   147d0:	4b0c      	ldr	r3, [pc, #48]	; (14804 <CanIf_EnableControllerInterrupts+0x5c>)
   147d2:	685a      	ldr	r2, [r3, #4]
   147d4:	f89d 3007 	ldrb.w	r3, [sp, #7]
   147d8:	00db      	lsls	r3, r3, #3
   147da:	4413      	add	r3, r2
   147dc:	9303      	str	r3, [sp, #12]
            CanController_ID = CanIfControllerConf->CanCtrlId;
   147de:	9b03      	ldr	r3, [sp, #12]
   147e0:	785b      	ldrb	r3, [r3, #1]
   147e2:	f88d 300b 	strb.w	r3, [sp, #11]
            CanIfControllerConf->CanDrvConfigPtr->CanApi->CanEnableInterrupts( CanController_ID );   //Calling Can Driver Api.
   147e6:	9b03      	ldr	r3, [sp, #12]
   147e8:	685b      	ldr	r3, [r3, #4]
   147ea:	685b      	ldr	r3, [r3, #4]
   147ec:	689b      	ldr	r3, [r3, #8]
   147ee:	f89d 200b 	ldrb.w	r2, [sp, #11]
   147f2:	4610      	mov	r0, r2
   147f4:	4798      	blx	r3
        }
    }
}
   147f6:	bf00      	nop
   147f8:	b005      	add	sp, #20
   147fa:	f85d fb04 	ldr.w	pc, [sp], #4
   147fe:	bf00      	nop
   14800:	1fff9540 	.word	0x1fff9540
   14804:	0001611c 	.word	0x0001611c

00014808 <CanIf_DisableControllerInterrupts>:
/**
 * @brief This function disables the interrupts of a given CanIf controller.
 * 
 * @param Controller CanIf controller ID.
 */
void CanIf_DisableControllerInterrupts( uint8 Controller ) {
   14808:	b500      	push	{lr}
   1480a:	b085      	sub	sp, #20
   1480c:	4603      	mov	r3, r0
   1480e:	f88d 3007 	strb.w	r3, [sp, #7]
    //local data.
    const CanIf_CtrlPCConfigType * CanIfControllerConf = NULL_PTR;    //Pointer to CanIf controller configuration.
   14812:	2300      	movs	r3, #0
   14814:	9303      	str	r3, [sp, #12]
    uint8 CanController_ID = 0; //Can controller ID.
   14816:	2300      	movs	r3, #0
   14818:	f88d 300b 	strb.w	r3, [sp, #11]

    if ( CanIf_ConfigPtr != NULL_PTR ) { 
   1481c:	4b10      	ldr	r3, [pc, #64]	; (14860 <CanIf_DisableControllerInterrupts+0x58>)
   1481e:	681b      	ldr	r3, [r3, #0]
   14820:	2b00      	cmp	r3, #0
   14822:	d018      	beq.n	14856 <CanIf_DisableControllerInterrupts+0x4e>
        if ( Controller < CanIf_PCConfig.NumOfCtrl ) { //Operation can be done as normal.
   14824:	4b0f      	ldr	r3, [pc, #60]	; (14864 <CanIf_DisableControllerInterrupts+0x5c>)
   14826:	781b      	ldrb	r3, [r3, #0]
   14828:	f89d 2007 	ldrb.w	r2, [sp, #7]
   1482c:	429a      	cmp	r2, r3
   1482e:	d212      	bcs.n	14856 <CanIf_DisableControllerInterrupts+0x4e>
            CanIfControllerConf = &CanIf_PCConfig.CanIfCtrlConfigPtr[ Controller ];
   14830:	4b0c      	ldr	r3, [pc, #48]	; (14864 <CanIf_DisableControllerInterrupts+0x5c>)
   14832:	685a      	ldr	r2, [r3, #4]
   14834:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14838:	00db      	lsls	r3, r3, #3
   1483a:	4413      	add	r3, r2
   1483c:	9303      	str	r3, [sp, #12]
            CanController_ID = CanIfControllerConf->CanCtrlId;
   1483e:	9b03      	ldr	r3, [sp, #12]
   14840:	785b      	ldrb	r3, [r3, #1]
   14842:	f88d 300b 	strb.w	r3, [sp, #11]
            CanIfControllerConf->CanDrvConfigPtr->CanApi->CanDisableInterrupts( CanController_ID );   //Calling Can Driver Api.
   14846:	9b03      	ldr	r3, [sp, #12]
   14848:	685b      	ldr	r3, [r3, #4]
   1484a:	685b      	ldr	r3, [r3, #4]
   1484c:	68db      	ldr	r3, [r3, #12]
   1484e:	f89d 200b 	ldrb.w	r2, [sp, #11]
   14852:	4610      	mov	r0, r2
   14854:	4798      	blx	r3
        }
    }
}
   14856:	bf00      	nop
   14858:	b005      	add	sp, #20
   1485a:	f85d fb04 	ldr.w	pc, [sp], #4
   1485e:	bf00      	nop
   14860:	1fff9540 	.word	0x1fff9540
   14864:	0001611c 	.word	0x0001611c

00014868 <CanIf_GetControllerErrorState>:
 * 
 * @param ControllerId CanIf controller ID.
 * @param ErrorStatePtr Pointer to variable to store the actual error state of the controller.
 * @return RetVal Status of the operation. 
 */
Std_ReturnType CanIf_GetControllerErrorState( uint8 ControllerId, Can_ErrorStateType *ErrorStatePtr) {
   14868:	b500      	push	{lr}
   1486a:	b087      	sub	sp, #28
   1486c:	4603      	mov	r3, r0
   1486e:	9100      	str	r1, [sp, #0]
   14870:	f88d 3007 	strb.w	r3, [sp, #7]
    //Local data.
    Std_ReturnType RetVal = E_NOT_OK;
   14874:	2301      	movs	r3, #1
   14876:	f88d 3017 	strb.w	r3, [sp, #23]
    const CanIf_CtrlPCConfigType * CanIfControllerConf = NULL_PTR;    //Pointer to CanIf controller configuration.
   1487a:	2300      	movs	r3, #0
   1487c:	9304      	str	r3, [sp, #16]
    uint8 CanController_ID = 0; //Can controller ID.
   1487e:	2300      	movs	r3, #0
   14880:	f88d 300f 	strb.w	r3, [sp, #15]

    if ( CanIf_ConfigPtr != NULL_PTR ) { 
   14884:	4b13      	ldr	r3, [pc, #76]	; (148d4 <CanIf_GetControllerErrorState+0x6c>)
   14886:	681b      	ldr	r3, [r3, #0]
   14888:	2b00      	cmp	r3, #0
   1488a:	d01c      	beq.n	148c6 <CanIf_GetControllerErrorState+0x5e>
        if ( ControllerId < CanIf_PCConfig.NumOfCtrl ) { //Operation can be done as normal.
   1488c:	4b12      	ldr	r3, [pc, #72]	; (148d8 <CanIf_GetControllerErrorState+0x70>)
   1488e:	781b      	ldrb	r3, [r3, #0]
   14890:	f89d 2007 	ldrb.w	r2, [sp, #7]
   14894:	429a      	cmp	r2, r3
   14896:	d216      	bcs.n	148c6 <CanIf_GetControllerErrorState+0x5e>
            CanIfControllerConf = &CanIf_PCConfig.CanIfCtrlConfigPtr[ ControllerId ];
   14898:	4b0f      	ldr	r3, [pc, #60]	; (148d8 <CanIf_GetControllerErrorState+0x70>)
   1489a:	685a      	ldr	r2, [r3, #4]
   1489c:	f89d 3007 	ldrb.w	r3, [sp, #7]
   148a0:	00db      	lsls	r3, r3, #3
   148a2:	4413      	add	r3, r2
   148a4:	9304      	str	r3, [sp, #16]
            CanController_ID = CanIfControllerConf->CanCtrlId;
   148a6:	9b04      	ldr	r3, [sp, #16]
   148a8:	785b      	ldrb	r3, [r3, #1]
   148aa:	f88d 300f 	strb.w	r3, [sp, #15]
            RetVal = CanIfControllerConf->CanDrvConfigPtr->CanApi->CanGetErrorState( CanController_ID, ErrorStatePtr );   //Calling Can Driver Api.
   148ae:	9b04      	ldr	r3, [sp, #16]
   148b0:	685b      	ldr	r3, [r3, #4]
   148b2:	685b      	ldr	r3, [r3, #4]
   148b4:	691b      	ldr	r3, [r3, #16]
   148b6:	f89d 200f 	ldrb.w	r2, [sp, #15]
   148ba:	9900      	ldr	r1, [sp, #0]
   148bc:	4610      	mov	r0, r2
   148be:	4798      	blx	r3
   148c0:	4603      	mov	r3, r0
   148c2:	f88d 3017 	strb.w	r3, [sp, #23]
        }
    }

    return RetVal;
   148c6:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
   148ca:	4618      	mov	r0, r3
   148cc:	b007      	add	sp, #28
   148ce:	f85d fb04 	ldr.w	pc, [sp], #4
   148d2:	bf00      	nop
   148d4:	1fff9540 	.word	0x1fff9540
   148d8:	0001611c 	.word	0x0001611c

000148dc <CanIf_GetControllerMode>:
 * 
 * @param Controller CanIf controller ID.
 * @param ControllerModePtr Pointer to variable to store the actual state of the controller.
 * @return RetVal Status of the operation.
 */
Std_ReturnType CanIf_GetControllerMode( uint8 Controller, Can_ControllerStateType *ControllerModePtr ) {
   148dc:	b500      	push	{lr}
   148de:	b087      	sub	sp, #28
   148e0:	4603      	mov	r3, r0
   148e2:	9100      	str	r1, [sp, #0]
   148e4:	f88d 3007 	strb.w	r3, [sp, #7]
    //Local data.
    Std_ReturnType RetVal = E_NOT_OK;
   148e8:	2301      	movs	r3, #1
   148ea:	f88d 3017 	strb.w	r3, [sp, #23]
    const CanIf_CtrlPCConfigType * CanIfControllerConf = NULL_PTR;    //Pointer to CanIf controller configuration.
   148ee:	2300      	movs	r3, #0
   148f0:	9304      	str	r3, [sp, #16]
    uint8 CanController_ID = 0; //Can controller ID.
   148f2:	2300      	movs	r3, #0
   148f4:	f88d 300f 	strb.w	r3, [sp, #15]

    if ( CanIf_ConfigPtr != NULL_PTR ) { 
   148f8:	4b13      	ldr	r3, [pc, #76]	; (14948 <CanIf_GetControllerMode+0x6c>)
   148fa:	681b      	ldr	r3, [r3, #0]
   148fc:	2b00      	cmp	r3, #0
   148fe:	d01c      	beq.n	1493a <CanIf_GetControllerMode+0x5e>
        if ( Controller < CanIf_PCConfig.NumOfCtrl ) { //Operation can be done as normal.
   14900:	4b12      	ldr	r3, [pc, #72]	; (1494c <CanIf_GetControllerMode+0x70>)
   14902:	781b      	ldrb	r3, [r3, #0]
   14904:	f89d 2007 	ldrb.w	r2, [sp, #7]
   14908:	429a      	cmp	r2, r3
   1490a:	d216      	bcs.n	1493a <CanIf_GetControllerMode+0x5e>
            CanIfControllerConf = &CanIf_PCConfig.CanIfCtrlConfigPtr[ Controller ];
   1490c:	4b0f      	ldr	r3, [pc, #60]	; (1494c <CanIf_GetControllerMode+0x70>)
   1490e:	685a      	ldr	r2, [r3, #4]
   14910:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14914:	00db      	lsls	r3, r3, #3
   14916:	4413      	add	r3, r2
   14918:	9304      	str	r3, [sp, #16]
            CanController_ID = CanIfControllerConf->CanCtrlId;
   1491a:	9b04      	ldr	r3, [sp, #16]
   1491c:	785b      	ldrb	r3, [r3, #1]
   1491e:	f88d 300f 	strb.w	r3, [sp, #15]
            RetVal = CanIfControllerConf->CanDrvConfigPtr->CanApi->CanGetMode( CanController_ID, ControllerModePtr );   //Calling Can Driver Api.
   14922:	9b04      	ldr	r3, [sp, #16]
   14924:	685b      	ldr	r3, [r3, #4]
   14926:	685b      	ldr	r3, [r3, #4]
   14928:	695b      	ldr	r3, [r3, #20]
   1492a:	f89d 200f 	ldrb.w	r2, [sp, #15]
   1492e:	9900      	ldr	r1, [sp, #0]
   14930:	4610      	mov	r0, r2
   14932:	4798      	blx	r3
   14934:	4603      	mov	r3, r0
   14936:	f88d 3017 	strb.w	r3, [sp, #23]
        }
    }

    return RetVal;
   1493a:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
   1493e:	4618      	mov	r0, r3
   14940:	b007      	add	sp, #28
   14942:	f85d fb04 	ldr.w	pc, [sp], #4
   14946:	bf00      	nop
   14948:	1fff9540 	.word	0x1fff9540
   1494c:	0001611c 	.word	0x0001611c

00014950 <CanIf_GetControllerRxErrorCounter>:
 * 
 * @param ControllerId CanIf controller ID.
 * @param RxErrorCounterPtr Pointer to variable to store the actual value of the rx error counter of the controller.
 * @return RetVal Status of the operation.
 */
Std_ReturnType CanIf_GetControllerRxErrorCounter( uint8 ControllerId, uint8 *RxErrorCounterPtr ) {
   14950:	b500      	push	{lr}
   14952:	b087      	sub	sp, #28
   14954:	4603      	mov	r3, r0
   14956:	9100      	str	r1, [sp, #0]
   14958:	f88d 3007 	strb.w	r3, [sp, #7]
    //Local data.
    Std_ReturnType RetVal = E_NOT_OK;
   1495c:	2301      	movs	r3, #1
   1495e:	f88d 3017 	strb.w	r3, [sp, #23]
    const CanIf_CtrlPCConfigType * CanIfControllerConf = NULL_PTR;    //Pointer to CanIf controller configuration.
   14962:	2300      	movs	r3, #0
   14964:	9304      	str	r3, [sp, #16]
    uint8 CanController_ID = 0; //Can controller ID.
   14966:	2300      	movs	r3, #0
   14968:	f88d 300f 	strb.w	r3, [sp, #15]

    if ( CanIf_ConfigPtr != NULL_PTR ) { 
   1496c:	4b13      	ldr	r3, [pc, #76]	; (149bc <CanIf_GetControllerRxErrorCounter+0x6c>)
   1496e:	681b      	ldr	r3, [r3, #0]
   14970:	2b00      	cmp	r3, #0
   14972:	d01c      	beq.n	149ae <CanIf_GetControllerRxErrorCounter+0x5e>
        if ( ControllerId < CanIf_PCConfig.NumOfCtrl ) { //Operation can be done as normal.
   14974:	4b12      	ldr	r3, [pc, #72]	; (149c0 <CanIf_GetControllerRxErrorCounter+0x70>)
   14976:	781b      	ldrb	r3, [r3, #0]
   14978:	f89d 2007 	ldrb.w	r2, [sp, #7]
   1497c:	429a      	cmp	r2, r3
   1497e:	d216      	bcs.n	149ae <CanIf_GetControllerRxErrorCounter+0x5e>
            CanIfControllerConf = &CanIf_PCConfig.CanIfCtrlConfigPtr[ ControllerId ];
   14980:	4b0f      	ldr	r3, [pc, #60]	; (149c0 <CanIf_GetControllerRxErrorCounter+0x70>)
   14982:	685a      	ldr	r2, [r3, #4]
   14984:	f89d 3007 	ldrb.w	r3, [sp, #7]
   14988:	00db      	lsls	r3, r3, #3
   1498a:	4413      	add	r3, r2
   1498c:	9304      	str	r3, [sp, #16]
            CanController_ID = CanIfControllerConf->CanCtrlId;
   1498e:	9b04      	ldr	r3, [sp, #16]
   14990:	785b      	ldrb	r3, [r3, #1]
   14992:	f88d 300f 	strb.w	r3, [sp, #15]
            RetVal = CanIfControllerConf->CanDrvConfigPtr->CanApi->CanGetRxErrorCounter( CanController_ID, RxErrorCounterPtr );   //Calling Can Driver Api.
   14996:	9b04      	ldr	r3, [sp, #16]
   14998:	685b      	ldr	r3, [r3, #4]
   1499a:	685b      	ldr	r3, [r3, #4]
   1499c:	699b      	ldr	r3, [r3, #24]
   1499e:	f89d 200f 	ldrb.w	r2, [sp, #15]
   149a2:	9900      	ldr	r1, [sp, #0]
   149a4:	4610      	mov	r0, r2
   149a6:	4798      	blx	r3
   149a8:	4603      	mov	r3, r0
   149aa:	f88d 3017 	strb.w	r3, [sp, #23]
        }
    }

    return RetVal;
   149ae:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
   149b2:	4618      	mov	r0, r3
   149b4:	b007      	add	sp, #28
   149b6:	f85d fb04 	ldr.w	pc, [sp], #4
   149ba:	bf00      	nop
   149bc:	1fff9540 	.word	0x1fff9540
   149c0:	0001611c 	.word	0x0001611c

000149c4 <CanIf_GetControllerTxErrorCounter>:
 * 
 * @param ControllerId CanIf controller ID.
 * @param TxErrorCounterPtr Pointer to variable to store the actual value of the tx error counter of the controller.
 * @return RetVal Status of the operation. 
 */
Std_ReturnType CanIf_GetControllerTxErrorCounter( uint8 ControllerId, uint8 *TxErrorCounterPtr ) {
   149c4:	b500      	push	{lr}
   149c6:	b087      	sub	sp, #28
   149c8:	4603      	mov	r3, r0
   149ca:	9100      	str	r1, [sp, #0]
   149cc:	f88d 3007 	strb.w	r3, [sp, #7]
    //Local data.
    Std_ReturnType RetVal = E_NOT_OK;
   149d0:	2301      	movs	r3, #1
   149d2:	f88d 3017 	strb.w	r3, [sp, #23]
    const CanIf_CtrlPCConfigType * CanIfControllerConf = NULL_PTR;    //Pointer to CanIf controller configuration.
   149d6:	2300      	movs	r3, #0
   149d8:	9304      	str	r3, [sp, #16]
    uint8 CanController_ID = 0; //Can controller ID.
   149da:	2300      	movs	r3, #0
   149dc:	f88d 300f 	strb.w	r3, [sp, #15]

    if ( CanIf_ConfigPtr != NULL_PTR ) { 
   149e0:	4b13      	ldr	r3, [pc, #76]	; (14a30 <CanIf_GetControllerTxErrorCounter+0x6c>)
   149e2:	681b      	ldr	r3, [r3, #0]
   149e4:	2b00      	cmp	r3, #0
   149e6:	d01c      	beq.n	14a22 <CanIf_GetControllerTxErrorCounter+0x5e>
        if ( ControllerId < CanIf_PCConfig.NumOfCtrl ) { //Operation can be done as normal.
   149e8:	4b12      	ldr	r3, [pc, #72]	; (14a34 <CanIf_GetControllerTxErrorCounter+0x70>)
   149ea:	781b      	ldrb	r3, [r3, #0]
   149ec:	f89d 2007 	ldrb.w	r2, [sp, #7]
   149f0:	429a      	cmp	r2, r3
   149f2:	d216      	bcs.n	14a22 <CanIf_GetControllerTxErrorCounter+0x5e>
            CanIfControllerConf = &CanIf_PCConfig.CanIfCtrlConfigPtr[ ControllerId ];
   149f4:	4b0f      	ldr	r3, [pc, #60]	; (14a34 <CanIf_GetControllerTxErrorCounter+0x70>)
   149f6:	685a      	ldr	r2, [r3, #4]
   149f8:	f89d 3007 	ldrb.w	r3, [sp, #7]
   149fc:	00db      	lsls	r3, r3, #3
   149fe:	4413      	add	r3, r2
   14a00:	9304      	str	r3, [sp, #16]
            CanController_ID = CanIfControllerConf->CanCtrlId;
   14a02:	9b04      	ldr	r3, [sp, #16]
   14a04:	785b      	ldrb	r3, [r3, #1]
   14a06:	f88d 300f 	strb.w	r3, [sp, #15]
            RetVal = CanIfControllerConf->CanDrvConfigPtr->CanApi->CanGetTxErrorCounter( CanController_ID, TxErrorCounterPtr );   //Calling Can Driver Api.
   14a0a:	9b04      	ldr	r3, [sp, #16]
   14a0c:	685b      	ldr	r3, [r3, #4]
   14a0e:	685b      	ldr	r3, [r3, #4]
   14a10:	69db      	ldr	r3, [r3, #28]
   14a12:	f89d 200f 	ldrb.w	r2, [sp, #15]
   14a16:	9900      	ldr	r1, [sp, #0]
   14a18:	4610      	mov	r0, r2
   14a1a:	4798      	blx	r3
   14a1c:	4603      	mov	r3, r0
   14a1e:	f88d 3017 	strb.w	r3, [sp, #23]
        }
    }

    return RetVal;
   14a22:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
   14a26:	4618      	mov	r0, r3
   14a28:	b007      	add	sp, #28
   14a2a:	f85d fb04 	ldr.w	pc, [sp], #4
   14a2e:	bf00      	nop
   14a30:	1fff9540 	.word	0x1fff9540
   14a34:	0001611c 	.word	0x0001611c

00014a38 <Fls_ACEraseRomEnd>:
   14a38:	04030201 	.word	0x04030201
   14a3c:	08070605 	.word	0x08070605
   14a40:	30201000 	.word	0x30201000
   14a44:	70605040 	.word	0x70605040
   14a48:	5f75634d 	.word	0x5f75634d
   14a4c:	74696e49 	.word	0x74696e49
   14a50:	00002928 	.word	0x00002928
   14a54:	5f75634d 	.word	0x5f75634d
   14a58:	74696e49 	.word	0x74696e49
   14a5c:	636f6c43 	.word	0x636f6c43
   14a60:	0029286b 	.word	0x0029286b
   14a64:	5f75634d 	.word	0x5f75634d
   14a68:	4d746553 	.word	0x4d746553
   14a6c:	2865646f 	.word	0x2865646f
   14a70:	00000029 	.word	0x00000029
   14a74:	5f75634d 	.word	0x5f75634d
   14a78:	56746547 	.word	0x56746547
   14a7c:	69737265 	.word	0x69737265
   14a80:	6e496e6f 	.word	0x6e496e6f
   14a84:	29286f66 	.word	0x29286f66
   14a88:	00000000 	.word	0x00000000
   14a8c:	61766e49 	.word	0x61766e49
   14a90:	2064696c 	.word	0x2064696c
   14a94:	666e6f63 	.word	0x666e6f63
   14a98:	696f7020 	.word	0x696f7020
   14a9c:	7265746e 	.word	0x7265746e
   14aa0:	00000000 	.word	0x00000000
   14aa4:	76697244 	.word	0x76697244
   14aa8:	75207265 	.word	0x75207265
   14aac:	696e696e 	.word	0x696e696e
   14ab0:	6c616974 	.word	0x6c616974
   14ab4:	64657a69 	.word	0x64657a69
   14ab8:	00000000 	.word	0x00000000
   14abc:	76697244 	.word	0x76697244
   14ac0:	61207265 	.word	0x61207265
   14ac4:	6165726c 	.word	0x6165726c
   14ac8:	69207964 	.word	0x69207964
   14acc:	6974696e 	.word	0x6974696e
   14ad0:	7a696c61 	.word	0x7a696c61
   14ad4:	00006465 	.word	0x00006465
   14ad8:	61766e49 	.word	0x61766e49
   14adc:	2064696c 	.word	0x2064696c
   14ae0:	75706e69 	.word	0x75706e69
   14ae4:	61702074 	.word	0x61702074
   14ae8:	656d6172 	.word	0x656d6172
   14aec:	00726574 	.word	0x00726574
   14af0:	74616c50 	.word	0x74616c50
   14af4:	6d726f66 	.word	0x6d726f66
   14af8:	696e495f 	.word	0x696e495f
   14afc:	00292874 	.word	0x00292874
   14b00:	74616c50 	.word	0x74616c50
   14b04:	6d726f66 	.word	0x6d726f66
   14b08:	7465535f 	.word	0x7465535f
   14b0c:	28717249 	.word	0x28717249
   14b10:	00000029 	.word	0x00000029
   14b14:	74616c50 	.word	0x74616c50
   14b18:	6d726f66 	.word	0x6d726f66
   14b1c:	7465535f 	.word	0x7465535f
   14b20:	50717249 	.word	0x50717249
   14b24:	726f6972 	.word	0x726f6972
   14b28:	28797469 	.word	0x28797469
   14b2c:	00000029 	.word	0x00000029
   14b30:	74616c50 	.word	0x74616c50
   14b34:	6d726f66 	.word	0x6d726f66
   14b38:	7465475f 	.word	0x7465475f
   14b3c:	50717249 	.word	0x50717249
   14b40:	726f6972 	.word	0x726f6972
   14b44:	28797469 	.word	0x28797469
   14b48:	00000029 	.word	0x00000029
   14b4c:	74616c50 	.word	0x74616c50
   14b50:	6d726f66 	.word	0x6d726f66
   14b54:	736e495f 	.word	0x736e495f
   14b58:	6c6c6174 	.word	0x6c6c6174
   14b5c:	48717249 	.word	0x48717249
   14b60:	6c646e61 	.word	0x6c646e61
   14b64:	29287265 	.word	0x29287265
   14b68:	00000000 	.word	0x00000000
   14b6c:	61766e49 	.word	0x61766e49
   14b70:	2064696c 	.word	0x2064696c
   14b74:	6e696f70 	.word	0x6e696f70
   14b78:	00726574 	.word	0x00726574
   14b7c:	6c6c6143 	.word	0x6c6c6143
   14b80:	6f726620 	.word	0x6f726620
   14b84:	7277206d 	.word	0x7277206d
   14b88:	20676e6f 	.word	0x20676e6f
   14b8c:	7070616d 	.word	0x7070616d
   14b90:	70206465 	.word	0x70206465
   14b94:	69747261 	.word	0x69747261
   14b98:	6e6f6974 	.word	0x6e6f6974
   14b9c:	00000000 	.word	0x00000000
   14ba0:	61726150 	.word	0x61726150
   14ba4:	6574656d 	.word	0x6574656d
   14ba8:	756f2072 	.word	0x756f2072
   14bac:	666f2074 	.word	0x666f2074
   14bb0:	6e617220 	.word	0x6e617220
   14bb4:	00006567 	.word	0x00006567
   14bb8:	74726f50 	.word	0x74726f50
   14bbc:	696e495f 	.word	0x696e495f
   14bc0:	00292874 	.word	0x00292874
   14bc4:	74726f50 	.word	0x74726f50
   14bc8:	7465535f 	.word	0x7465535f
   14bcc:	446e6950 	.word	0x446e6950
   14bd0:	63657269 	.word	0x63657269
   14bd4:	6e6f6974 	.word	0x6e6f6974
   14bd8:	00002928 	.word	0x00002928
   14bdc:	74726f50 	.word	0x74726f50
   14be0:	7465535f 	.word	0x7465535f
   14be4:	4d6e6950 	.word	0x4d6e6950
   14be8:	2865646f 	.word	0x2865646f
   14bec:	00000029 	.word	0x00000029
   14bf0:	74726f50 	.word	0x74726f50
   14bf4:	6665525f 	.word	0x6665525f
   14bf8:	68736572 	.word	0x68736572
   14bfc:	74726f50 	.word	0x74726f50
   14c00:	65726944 	.word	0x65726944
   14c04:	6f697463 	.word	0x6f697463
   14c08:	0029286e 	.word	0x0029286e
   14c0c:	74726f50 	.word	0x74726f50
   14c10:	7465475f 	.word	0x7465475f
   14c14:	73726556 	.word	0x73726556
   14c18:	496e6f69 	.word	0x496e6f69
   14c1c:	286f666e 	.word	0x286f666e
   14c20:	00000029 	.word	0x00000029
   14c24:	61766e49 	.word	0x61766e49
   14c28:	2064696c 	.word	0x2064696c
   14c2c:	74726f50 	.word	0x74726f50
   14c30:	6e695020 	.word	0x6e695020
   14c34:	00444920 	.word	0x00444920
   14c38:	74726f50 	.word	0x74726f50
   14c3c:	6e697020 	.word	0x6e697020
   14c40:	646f6d20 	.word	0x646f6d20
   14c44:	73692065 	.word	0x73692065
   14c48:	636e7520 	.word	0x636e7520
   14c4c:	676e6168 	.word	0x676e6168
   14c50:	6c626165 	.word	0x6c626165
   14c54:	00000065 	.word	0x00000065
   14c58:	61766e49 	.word	0x61766e49
   14c5c:	2064696c 	.word	0x2064696c
   14c60:	74726f70 	.word	0x74726f70
   14c64:	6e697020 	.word	0x6e697020
   14c68:	646f6d20 	.word	0x646f6d20
   14c6c:	00000065 	.word	0x00000065
   14c70:	5f6f6944 	.word	0x5f6f6944
   14c74:	74697257 	.word	0x74697257
   14c78:	61684365 	.word	0x61684365
   14c7c:	6c656e6e 	.word	0x6c656e6e
   14c80:	00002928 	.word	0x00002928
   14c84:	5f6f6944 	.word	0x5f6f6944
   14c88:	64616552 	.word	0x64616552
   14c8c:	6e616843 	.word	0x6e616843
   14c90:	286c656e 	.word	0x286c656e
   14c94:	00000029 	.word	0x00000029
   14c98:	5f6f6944 	.word	0x5f6f6944
   14c9c:	70696c46 	.word	0x70696c46
   14ca0:	6e616843 	.word	0x6e616843
   14ca4:	286c656e 	.word	0x286c656e
   14ca8:	00000029 	.word	0x00000029
   14cac:	5f6f6944 	.word	0x5f6f6944
   14cb0:	74697257 	.word	0x74697257
   14cb4:	61684365 	.word	0x61684365
   14cb8:	6c656e6e 	.word	0x6c656e6e
   14cbc:	756f7247 	.word	0x756f7247
   14cc0:	00292870 	.word	0x00292870
   14cc4:	5f6f6944 	.word	0x5f6f6944
   14cc8:	64616552 	.word	0x64616552
   14ccc:	6e616843 	.word	0x6e616843
   14cd0:	476c656e 	.word	0x476c656e
   14cd4:	70756f72 	.word	0x70756f72
   14cd8:	00002928 	.word	0x00002928
   14cdc:	5f6f6944 	.word	0x5f6f6944
   14ce0:	74697257 	.word	0x74697257
   14ce4:	726f5065 	.word	0x726f5065
   14ce8:	00292874 	.word	0x00292874
   14cec:	5f6f6944 	.word	0x5f6f6944
   14cf0:	64616552 	.word	0x64616552
   14cf4:	74726f50 	.word	0x74726f50
   14cf8:	00002928 	.word	0x00002928
   14cfc:	5f6f6944 	.word	0x5f6f6944
   14d00:	56746547 	.word	0x56746547
   14d04:	69737265 	.word	0x69737265
   14d08:	6e496e6f 	.word	0x6e496e6f
   14d0c:	29286f66 	.word	0x29286f66
   14d10:	00000000 	.word	0x00000000
   14d14:	61766e49 	.word	0x61766e49
   14d18:	2064696c 	.word	0x2064696c
   14d1c:	206f6964 	.word	0x206f6964
   14d20:	6e616863 	.word	0x6e616863
   14d24:	206c656e 	.word	0x206c656e
   14d28:	6576656c 	.word	0x6576656c
   14d2c:	0000006c 	.word	0x0000006c
   14d30:	61766e49 	.word	0x61766e49
   14d34:	2064696c 	.word	0x2064696c
   14d38:	206f6964 	.word	0x206f6964
   14d3c:	6e616863 	.word	0x6e616863
   14d40:	206c656e 	.word	0x206c656e
   14d44:	00006469 	.word	0x00006469
   14d48:	61766e49 	.word	0x61766e49
   14d4c:	2064696c 	.word	0x2064696c
   14d50:	74726f70 	.word	0x74726f70
   14d54:	00646920 	.word	0x00646920
   14d58:	61766e49 	.word	0x61766e49
   14d5c:	2064696c 	.word	0x2064696c
   14d60:	6e616863 	.word	0x6e616863
   14d64:	206c656e 	.word	0x206c656e
   14d68:	756f7267 	.word	0x756f7267
   14d6c:	64692070 	.word	0x64692070
   14d70:	00000000 	.word	0x00000000
   14d74:	61766e49 	.word	0x61766e49
   14d78:	2064696c 	.word	0x2064696c
   14d7c:	666e6f63 	.word	0x666e6f63
   14d80:	70206769 	.word	0x70206769
   14d84:	6d617261 	.word	0x6d617261
   14d88:	72657465 	.word	0x72657465
   14d8c:	00000000 	.word	0x00000000
   14d90:	5f6d7750 	.word	0x5f6d7750
   14d94:	74696e49 	.word	0x74696e49
   14d98:	00002928 	.word	0x00002928
   14d9c:	5f6d7750 	.word	0x5f6d7750
   14da0:	6e496544 	.word	0x6e496544
   14da4:	29287469 	.word	0x29287469
   14da8:	00000000 	.word	0x00000000
   14dac:	5f6d7750 	.word	0x5f6d7750
   14db0:	44746553 	.word	0x44746553
   14db4:	43797475 	.word	0x43797475
   14db8:	656c6379 	.word	0x656c6379
   14dbc:	00002928 	.word	0x00002928
   14dc0:	5f6d7750 	.word	0x5f6d7750
   14dc4:	50746553 	.word	0x50746553
   14dc8:	6f697265 	.word	0x6f697265
   14dcc:	646e4164 	.word	0x646e4164
   14dd0:	79747544 	.word	0x79747544
   14dd4:	00002928 	.word	0x00002928
   14dd8:	5f6d7750 	.word	0x5f6d7750
   14ddc:	4f746553 	.word	0x4f746553
   14de0:	75707475 	.word	0x75707475
   14de4:	496f5474 	.word	0x496f5474
   14de8:	28656c64 	.word	0x28656c64
   14dec:	00000029 	.word	0x00000029
   14df0:	5f6d7750 	.word	0x5f6d7750
   14df4:	56746547 	.word	0x56746547
   14df8:	69737265 	.word	0x69737265
   14dfc:	6e496e6f 	.word	0x6e496e6f
   14e00:	29286f66 	.word	0x29286f66
   14e04:	00000000 	.word	0x00000000
   14e08:	61766e49 	.word	0x61766e49
   14e0c:	2064696c 	.word	0x2064696c
   14e10:	666e6f63 	.word	0x666e6f63
   14e14:	70206769 	.word	0x70206769
   14e18:	746e696f 	.word	0x746e696f
   14e1c:	00007265 	.word	0x00007265
   14e20:	61766e49 	.word	0x61766e49
   14e24:	2064696c 	.word	0x2064696c
   14e28:	206d7770 	.word	0x206d7770
   14e2c:	6e616863 	.word	0x6e616863
   14e30:	006c656e 	.word	0x006c656e
   14e34:	206d7750 	.word	0x206d7750
   14e38:	6e616863 	.word	0x6e616863
   14e3c:	206c656e 	.word	0x206c656e
   14e40:	69726570 	.word	0x69726570
   14e44:	6920646f 	.word	0x6920646f
   14e48:	6e752073 	.word	0x6e752073
   14e4c:	6e616863 	.word	0x6e616863
   14e50:	62616567 	.word	0x62616567
   14e54:	0000656c 	.word	0x0000656c
   14e58:	5f636441 	.word	0x5f636441
   14e5c:	74696e49 	.word	0x74696e49
   14e60:	00002928 	.word	0x00002928
   14e64:	5f636441 	.word	0x5f636441
   14e68:	6e496544 	.word	0x6e496544
   14e6c:	29287469 	.word	0x29287469
   14e70:	00000000 	.word	0x00000000
   14e74:	5f636441 	.word	0x5f636441
   14e78:	72617453 	.word	0x72617453
   14e7c:	6f724774 	.word	0x6f724774
   14e80:	6f437075 	.word	0x6f437075
   14e84:	7265766e 	.word	0x7265766e
   14e88:	6e6f6973 	.word	0x6e6f6973
   14e8c:	00002928 	.word	0x00002928
   14e90:	5f636441 	.word	0x5f636441
   14e94:	706f7453 	.word	0x706f7453
   14e98:	756f7247 	.word	0x756f7247
   14e9c:	6e6f4370 	.word	0x6e6f4370
   14ea0:	73726576 	.word	0x73726576
   14ea4:	286e6f69 	.word	0x286e6f69
   14ea8:	00000029 	.word	0x00000029
   14eac:	5f636441 	.word	0x5f636441
   14eb0:	64616552 	.word	0x64616552
   14eb4:	756f7247 	.word	0x756f7247
   14eb8:	00292870 	.word	0x00292870
   14ebc:	5f636441 	.word	0x5f636441
   14ec0:	47746547 	.word	0x47746547
   14ec4:	70756f72 	.word	0x70756f72
   14ec8:	74617453 	.word	0x74617453
   14ecc:	29287375 	.word	0x29287375
   14ed0:	00000000 	.word	0x00000000
   14ed4:	5f636441 	.word	0x5f636441
   14ed8:	696c6143 	.word	0x696c6143
   14edc:	74617262 	.word	0x74617262
   14ee0:	00292865 	.word	0x00292865
   14ee4:	5f636441 	.word	0x5f636441
   14ee8:	75746553 	.word	0x75746553
   14eec:	73655270 	.word	0x73655270
   14ef0:	42746c75 	.word	0x42746c75
   14ef4:	65666675 	.word	0x65666675
   14ef8:	00292872 	.word	0x00292872
   14efc:	5f636441 	.word	0x5f636441
   14f00:	56746547 	.word	0x56746547
   14f04:	69737265 	.word	0x69737265
   14f08:	6e496e6f 	.word	0x6e496e6f
   14f0c:	29286f66 	.word	0x29286f66
   14f10:	00000000 	.word	0x00000000
   14f14:	61766e49 	.word	0x61766e49
   14f18:	2064696c 	.word	0x2064696c
   14f1c:	20636461 	.word	0x20636461
   14f20:	756f7267 	.word	0x756f7267
   14f24:	00000070 	.word	0x00000070
   14f28:	66667542 	.word	0x66667542
   14f2c:	70207265 	.word	0x70207265
   14f30:	746e696f 	.word	0x746e696f
   14f34:	6e207265 	.word	0x6e207265
   14f38:	6920746f 	.word	0x6920746f
   14f3c:	6974696e 	.word	0x6974696e
   14f40:	7a696c61 	.word	0x7a696c61
   14f44:	00006465 	.word	0x00006465
   14f48:	696c6143 	.word	0x696c6143
   14f4c:	74617262 	.word	0x74617262
   14f50:	206e6f69 	.word	0x206e6f69
   14f54:	7265706f 	.word	0x7265706f
   14f58:	6f697461 	.word	0x6f697461
   14f5c:	6974206e 	.word	0x6974206e
   14f60:	2064656d 	.word	0x2064656d
   14f64:	0074756f 	.word	0x0074756f
   14f68:	65686353 	.word	0x65686353
   14f6c:	656c7564 	.word	0x656c7564
   14f70:	6e495f72 	.word	0x6e495f72
   14f74:	29287469 	.word	0x29287469
   14f78:	00000000 	.word	0x00000000
   14f7c:	65686353 	.word	0x65686353
   14f80:	656c7564 	.word	0x656c7564
   14f84:	65475f72 	.word	0x65475f72
   14f88:	61745374 	.word	0x61745374
   14f8c:	51737574 	.word	0x51737574
   14f90:	65756575 	.word	0x65756575
   14f94:	00002928 	.word	0x00002928
   14f98:	65686353 	.word	0x65686353
   14f9c:	656c7564 	.word	0x656c7564
   14fa0:	6c465f72 	.word	0x6c465f72
   14fa4:	51687375 	.word	0x51687375
   14fa8:	65756575 	.word	0x65756575
   14fac:	00002928 	.word	0x00002928
   14fb0:	65686353 	.word	0x65686353
   14fb4:	656c7564 	.word	0x656c7564
   14fb8:	72575f72 	.word	0x72575f72
   14fbc:	51657469 	.word	0x51657469
   14fc0:	65756575 	.word	0x65756575
   14fc4:	00002928 	.word	0x00002928
   14fc8:	65686353 	.word	0x65686353
   14fcc:	656c7564 	.word	0x656c7564
   14fd0:	65525f72 	.word	0x65525f72
   14fd4:	75516461 	.word	0x75516461
   14fd8:	28657565 	.word	0x28657565
   14fdc:	00000029 	.word	0x00000029
   14fe0:	65686353 	.word	0x65686353
   14fe4:	656c7564 	.word	0x656c7564
   14fe8:	74535f72 	.word	0x74535f72
   14fec:	54747261 	.word	0x54747261
   14ff0:	286b7361 	.word	0x286b7361
   14ff4:	00000029 	.word	0x00000029
   14ff8:	65686353 	.word	0x65686353
   14ffc:	656c7564 	.word	0x656c7564
   15000:	74535f72 	.word	0x74535f72
   15004:	6154706f 	.word	0x6154706f
   15008:	29286b73 	.word	0x29286b73
   1500c:	00000000 	.word	0x00000000
   15010:	65686353 	.word	0x65686353
   15014:	656c7564 	.word	0x656c7564
   15018:	65505f72 	.word	0x65505f72
   1501c:	646f6972 	.word	0x646f6972
   15020:	6b736154 	.word	0x6b736154
   15024:	00002928 	.word	0x00002928
   15028:	65686353 	.word	0x65686353
   1502c:	656c7564 	.word	0x656c7564
   15030:	74535f72 	.word	0x74535f72
   15034:	54747261 	.word	0x54747261
   15038:	72656d69 	.word	0x72656d69
   1503c:	00002928 	.word	0x00002928
   15040:	65686353 	.word	0x65686353
   15044:	656c7564 	.word	0x656c7564
   15048:	74535f72 	.word	0x74535f72
   1504c:	6954706f 	.word	0x6954706f
   15050:	2872656d 	.word	0x2872656d
   15054:	00000029 	.word	0x00000029
   15058:	65686353 	.word	0x65686353
   1505c:	656c7564 	.word	0x656c7564
   15060:	65475f72 	.word	0x65475f72
   15064:	6d695474 	.word	0x6d695474
   15068:	29287265 	.word	0x29287265
   1506c:	00000000 	.word	0x00000000
   15070:	65686353 	.word	0x65686353
   15074:	656c7564 	.word	0x656c7564
   15078:	65525f72 	.word	0x65525f72
   1507c:	64616f6c 	.word	0x64616f6c
   15080:	656d6954 	.word	0x656d6954
   15084:	00292872 	.word	0x00292872
   15088:	65686353 	.word	0x65686353
   1508c:	656c7564 	.word	0x656c7564
   15090:	614d5f72 	.word	0x614d5f72
   15094:	75466e69 	.word	0x75466e69
   15098:	6974636e 	.word	0x6974636e
   1509c:	29286e6f 	.word	0x29286e6f
   150a0:	00000000 	.word	0x00000000
   150a4:	75657551 	.word	0x75657551
   150a8:	64692065 	.word	0x64692065
   150ac:	74756f20 	.word	0x74756f20
   150b0:	20666f20 	.word	0x20666f20
   150b4:	676e6172 	.word	0x676e6172
   150b8:	00000065 	.word	0x00000065
   150bc:	61766e49 	.word	0x61766e49
   150c0:	2064696c 	.word	0x2064696c
   150c4:	75657571 	.word	0x75657571
   150c8:	74732065 	.word	0x74732065
   150cc:	73757461 	.word	0x73757461
   150d0:	616c6620 	.word	0x616c6620
   150d4:	00000067 	.word	0x00000067
   150d8:	6b736154 	.word	0x6b736154
   150dc:	20646920 	.word	0x20646920
   150e0:	2074756f 	.word	0x2074756f
   150e4:	7220666f 	.word	0x7220666f
   150e8:	65676e61 	.word	0x65676e61
   150ec:	00000000 	.word	0x00000000
   150f0:	61766e49 	.word	0x61766e49
   150f4:	2064696c 	.word	0x2064696c
   150f8:	6b736174 	.word	0x6b736174
   150fc:	20726f20 	.word	0x20726f20
   15100:	656d6974 	.word	0x656d6974
   15104:	65702072 	.word	0x65702072
   15108:	646f6972 	.word	0x646f6972
   1510c:	74696369 	.word	0x74696369
   15110:	00000079 	.word	0x00000079
   15114:	656d6954 	.word	0x656d6954
   15118:	64692072 	.word	0x64692072
   1511c:	74756f20 	.word	0x74756f20
   15120:	20666f20 	.word	0x20666f20
   15124:	676e6172 	.word	0x676e6172
   15128:	00000065 	.word	0x00000065
   1512c:	65686353 	.word	0x65686353
   15130:	656c7564 	.word	0x656c7564
   15134:	6e752072 	.word	0x6e752072
   15138:	74696e69 	.word	0x74696e69
   1513c:	696c6169 	.word	0x696c6169
   15140:	0064657a 	.word	0x0064657a
   15144:	6f497748 	.word	0x6f497748
   15148:	425f6241 	.word	0x425f6241
   1514c:	6f747475 	.word	0x6f747475
   15150:	495f736e 	.word	0x495f736e
   15154:	2874696e 	.word	0x2874696e
   15158:	00000029 	.word	0x00000029
   1515c:	6f497748 	.word	0x6f497748
   15160:	425f6241 	.word	0x425f6241
   15164:	6f747475 	.word	0x6f747475
   15168:	475f736e 	.word	0x475f736e
   1516c:	76457465 	.word	0x76457465
   15170:	28746e65 	.word	0x28746e65
   15174:	00000029 	.word	0x00000029
   15178:	6f497748 	.word	0x6f497748
   1517c:	425f6241 	.word	0x425f6241
   15180:	6f747475 	.word	0x6f747475
   15184:	4d5f736e 	.word	0x4d5f736e
   15188:	466e6961 	.word	0x466e6961
   1518c:	74636e75 	.word	0x74636e75
   15190:	286e6f69 	.word	0x286e6f69
   15194:	00000029 	.word	0x00000029
   15198:	61766e49 	.word	0x61766e49
   1519c:	2064696c 	.word	0x2064696c
   151a0:	74747562 	.word	0x74747562
   151a4:	69206e6f 	.word	0x69206e6f
   151a8:	00000064 	.word	0x00000064
   151ac:	61766e49 	.word	0x61766e49
   151b0:	2064696c 	.word	0x2064696c
   151b4:	74747562 	.word	0x74747562
   151b8:	73206e6f 	.word	0x73206e6f
   151bc:	65746174 	.word	0x65746174
   151c0:	00000000 	.word	0x00000000
   151c4:	75646f4d 	.word	0x75646f4d
   151c8:	7520656c 	.word	0x7520656c
   151cc:	696e696e 	.word	0x696e696e
   151d0:	6c616974 	.word	0x6c616974
   151d4:	64657a69 	.word	0x64657a69
   151d8:	00000000 	.word	0x00000000
   151dc:	6f497748 	.word	0x6f497748
   151e0:	4c5f6241 	.word	0x4c5f6241
   151e4:	5f736465 	.word	0x5f736465
   151e8:	74696e49 	.word	0x74696e49
   151ec:	00002928 	.word	0x00002928
   151f0:	6f497748 	.word	0x6f497748
   151f4:	4c5f6241 	.word	0x4c5f6241
   151f8:	5f736465 	.word	0x5f736465
   151fc:	6e727554 	.word	0x6e727554
   15200:	29286e4f 	.word	0x29286e4f
   15204:	00000000 	.word	0x00000000
   15208:	6f497748 	.word	0x6f497748
   1520c:	4c5f6241 	.word	0x4c5f6241
   15210:	5f736465 	.word	0x5f736465
   15214:	6e727554 	.word	0x6e727554
   15218:	2866664f 	.word	0x2866664f
   1521c:	00000029 	.word	0x00000029
   15220:	6f497748 	.word	0x6f497748
   15224:	4c5f6241 	.word	0x4c5f6241
   15228:	5f736465 	.word	0x5f736465
   1522c:	6e727554 	.word	0x6e727554
   15230:	67676f54 	.word	0x67676f54
   15234:	2928656c 	.word	0x2928656c
   15238:	00000000 	.word	0x00000000
   1523c:	61766e49 	.word	0x61766e49
   15240:	2064696c 	.word	0x2064696c
   15244:	2064656c 	.word	0x2064656c
   15248:	00006469 	.word	0x00006469
   1524c:	6f497748 	.word	0x6f497748
   15250:	505f6241 	.word	0x505f6241
   15254:	5f73746f 	.word	0x5f73746f
   15258:	74696e49 	.word	0x74696e49
   1525c:	00002928 	.word	0x00002928
   15260:	6f497748 	.word	0x6f497748
   15264:	505f6241 	.word	0x505f6241
   15268:	5f73746f 	.word	0x5f73746f
   1526c:	56746547 	.word	0x56746547
   15270:	65756c61 	.word	0x65756c61
   15274:	00002928 	.word	0x00002928
   15278:	6f497748 	.word	0x6f497748
   1527c:	505f6241 	.word	0x505f6241
   15280:	5f73746f 	.word	0x5f73746f
   15284:	41746547 	.word	0x41746547
   15288:	6156746c 	.word	0x6156746c
   1528c:	2865756c 	.word	0x2865756c
   15290:	00000029 	.word	0x00000029
   15294:	61766e49 	.word	0x61766e49
   15298:	2064696c 	.word	0x2064696c
   1529c:	75706e69 	.word	0x75706e69
   152a0:	6f702074 	.word	0x6f702074
   152a4:	65746e69 	.word	0x65746e69
   152a8:	00000072 	.word	0x00000072
   152ac:	6f497748 	.word	0x6f497748
   152b0:	425f6241 	.word	0x425f6241
   152b4:	657a7a75 	.word	0x657a7a75
   152b8:	6e495f72 	.word	0x6e495f72
   152bc:	29287469 	.word	0x29287469
   152c0:	00000000 	.word	0x00000000
   152c4:	6f497748 	.word	0x6f497748
   152c8:	425f6241 	.word	0x425f6241
   152cc:	657a7a75 	.word	0x657a7a75
   152d0:	65425f72 	.word	0x65425f72
   152d4:	29287065 	.word	0x29287065
   152d8:	00000000 	.word	0x00000000
   152dc:	6f497748 	.word	0x6f497748
   152e0:	425f6241 	.word	0x425f6241
   152e4:	657a7a75 	.word	0x657a7a75
   152e8:	74535f72 	.word	0x74535f72
   152ec:	2928706f 	.word	0x2928706f
   152f0:	00000000 	.word	0x00000000
   152f4:	61766e49 	.word	0x61766e49
   152f8:	2064696c 	.word	0x2064696c
   152fc:	7a7a7562 	.word	0x7a7a7562
   15300:	74207265 	.word	0x74207265
   15304:	00656e6f 	.word	0x00656e6f
   15308:	2075634d 	.word	0x2075634d
   1530c:	75646f6d 	.word	0x75646f6d
   15310:	0000656c 	.word	0x0000656c
   15314:	74616c50 	.word	0x74616c50
   15318:	6d726f66 	.word	0x6d726f66
   1531c:	646f6d20 	.word	0x646f6d20
   15320:	00656c75 	.word	0x00656c75
   15324:	74726f50 	.word	0x74726f50
   15328:	646f6d20 	.word	0x646f6d20
   1532c:	00656c75 	.word	0x00656c75
   15330:	206f6944 	.word	0x206f6944
   15334:	75646f6d 	.word	0x75646f6d
   15338:	0000656c 	.word	0x0000656c
   1533c:	206d7750 	.word	0x206d7750
   15340:	75646f6d 	.word	0x75646f6d
   15344:	0000656c 	.word	0x0000656c
   15348:	20636441 	.word	0x20636441
   1534c:	75646f6d 	.word	0x75646f6d
   15350:	0000656c 	.word	0x0000656c
   15354:	65686353 	.word	0x65686353
   15358:	656c7564 	.word	0x656c7564
   1535c:	6f6d2072 	.word	0x6f6d2072
   15360:	656c7564 	.word	0x656c7564
   15364:	00000000 	.word	0x00000000
   15368:	74747542 	.word	0x74747542
   1536c:	20736e6f 	.word	0x20736e6f
   15370:	61204f49 	.word	0x61204f49
   15374:	72747362 	.word	0x72747362
   15378:	69746361 	.word	0x69746361
   1537c:	6d206e6f 	.word	0x6d206e6f
   15380:	6c75646f 	.word	0x6c75646f
   15384:	00000065 	.word	0x00000065
   15388:	7364654c 	.word	0x7364654c
   1538c:	204f4920 	.word	0x204f4920
   15390:	74736261 	.word	0x74736261
   15394:	74636172 	.word	0x74636172
   15398:	206e6f69 	.word	0x206e6f69
   1539c:	75646f6d 	.word	0x75646f6d
   153a0:	0000656c 	.word	0x0000656c
   153a4:	73746f50 	.word	0x73746f50
   153a8:	204f4920 	.word	0x204f4920
   153ac:	74736261 	.word	0x74736261
   153b0:	74636172 	.word	0x74636172
   153b4:	206e6f69 	.word	0x206e6f69
   153b8:	75646f6d 	.word	0x75646f6d
   153bc:	0000656c 	.word	0x0000656c
   153c0:	7a7a7542 	.word	0x7a7a7542
   153c4:	49207265 	.word	0x49207265
   153c8:	6261204f 	.word	0x6261204f
   153cc:	61727473 	.word	0x61727473
   153d0:	6f697463 	.word	0x6f697463
   153d4:	6f6d206e 	.word	0x6f6d206e
   153d8:	656c7564 	.word	0x656c7564
   153dc:	00000000 	.word	0x00000000
   153e0:	6f727245 	.word	0x6f727245
   153e4:	45203a72 	.word	0x45203a72
   153e8:	726f7272 	.word	0x726f7272
   153ec:	206e6920 	.word	0x206e6920
   153f0:	69207325 	.word	0x69207325
   153f4:	7566206e 	.word	0x7566206e
   153f8:	6974636e 	.word	0x6974636e
   153fc:	25206e6f 	.word	0x25206e6f
   15400:	69772073 	.word	0x69772073
   15404:	74206874 	.word	0x74206874
   15408:	69206568 	.word	0x69206568
   1540c:	6174736e 	.word	0x6174736e
   15410:	2065636e 	.word	0x2065636e
   15414:	202c6425 	.word	0x202c6425
   15418:	000a7325 	.word	0x000a7325
   1541c:	6d726554 	.word	0x6d726554
   15420:	6c616e69 	.word	0x6c616e69
   15424:	00000000 	.word	0x00000000
   15428:	4c554e28 	.word	0x4c554e28
   1542c:	0000294c 	.word	0x0000294c

00015430 <Clock_Ip_au8DividerCallbackIndex>:
   15430:	0e0d0c00 06030201 0a070409 000b0805     ................

00015440 <Clock_Ip_au8DividerTriggerCallbackIndex>:
	...

00015450 <Clock_Ip_au8XoscCallbackIndex>:
   15450:	00000100 00000000 00000000 00000000     ................

00015460 <Clock_Ip_au8IrcoscCallbackIndex>:
   15460:	03020100 00000004 00000000 00000000     ................

00015470 <Clock_Ip_au8GateCallbackIndex>:
   15470:	06010200 01040301 00000500 00000000     ................

00015480 <Clock_Ip_au8FractionalDividerCallbackIndex>:
	...

00015490 <Clock_Ip_au8PllCallbackIndex>:
   15490:	00000100 00000000 00000000 00000000     ................

000154a0 <Clock_Ip_au8SelectorCallbackIndex>:
   154a0:	0a090800 03020109 07060504 00000000     ................

000154b0 <Clock_Ip_au8PcfsCallbackIndex>:
	...

000154c0 <Clock_Ip_au8CmuCallbackIndex>:
	...

000154d0 <Clock_Ip_au8ClockFeatures>:
	...
   154e0:	01000000 00000000 00000000 00000002     ................
   154f0:	00000000 00000300 00000000 00040000     ................
   15500:	00000000 05000000 00000000 00000000     ................
   15510:	00000006 00000000 00000100 00000000     ................
   15520:	00010000 00000000 04000000 00000000     ................
   15530:	00000000 00000005 00000001 00000401     ................
   15540:	00000200 00050100 00030000 04020000     ................
   15550:	04000000 02000000 00000005 00000005     ................
   15560:	00000403 00000600 00050300 00070000     ................
   15570:	05000000 00000000 00000000 00000006     ................
	...
   155b0:	00050000 00000000 06000000 00000100     ................
   155c0:	00000000 00030007 00000000 00000000     ................
   155d0:	00000000 00060000 00000000 07000000     ................
   155e0:	00000100 00000000 00030008 00000000     ................
	...
   155f8:	00090000 00000000 0a000000 00000100     ................
   15608:	00000000 0003000b 00000000 00000000     ................
   15618:	00000000 000c0000 00000000 0d000000     ................
   15628:	00000100 00000000 0003000e 00000000     ................
   15638:	00000800 00000000 00090000 00000000     ................
   15648:	0a000000 00000000 00000000 0000000b     ................
   15658:	00000000 00000b01 00000000 000b0200     ................
   15668:	00000000 0b030000 00000000 00000000     ................
	...
   15680:	00000400 003b003b 00040000 27002700     ....;.;......'.'
   15690:	01000000 00000000 00000000 00000007     ................
   156a0:	00007300 00000700 00320000 00090000     .s........2.....
   156b0:	02000000 07000000 00000000 00000021     ............!...
   156c0:	00000009 00000400 00000900 00030000     ................
   156d0:	00070000 61000000 07000000 00000000     .......a........
   156e0:	00000024 00000007 00002500 00000700     $........%......
   156f0:	002b0000 00040000 5a005a00 07000000     ..+......Z.Z....
   15700:	00000000 00000020 38000004 00003800     .... ......8.8..
   15710:	00000400 00390039 00040000 3a003a00     ....9.9......:.:
   15720:	04000000 00260000 00000026 66000004     ......&.&......f
   15730:	00006600 00000400 00370037 00040000     .f......7.7.....
   15740:	2c002c00 04000000 002d0000 0000002d     .,.,......-.-...
   15750:	2e000004 00002e00 00000200 00404040     ............@@@.
   15760:	00040000 6a006a00 04000000 006b0000     .....j.j......k.
   15770:	0000006b 6c000004 00006c00 00000900     k......l.l......
   15780:	00010000 00090000 00000000 07000000     ................
   15790:	00000000 00000036 00000007 00003100     ....6........1..
   157a0:	00000700 00490000 00070000 4a000000     ......I........J
   157b0:	07000000 00000000 0000004b 00000007     ........K.......
   157c0:	00004c00 00000700 004d0000 00070000     .L........M.....
   157d0:	3d000000 03000000 00000000 00000000     ...=............

000157e0 <Clock_Ip_au16SelectorEntryHardwareValue>:
   157e0:	01010a03 01010001 04040002 02000603     ................
   157f0:	00010810 02020100 00000000 00000007     ................
   15800:	00000009 00000000 00000c0e 00000000     ................
	...

00015838 <Clock_Ip_au8SelectorEntryScsHardwareValue>:
   15838:	00020000 00000300 00000601 00000000     ................
	...

00015868 <Clock_Ip_au8SelectorEntryPcsHardwareValue>:
   15868:	00000700 00000000 02020000 01010303     ................
   15878:	03020606 00000000 00000000 00000000     ................
	...

00015898 <Clock_Ip_au8SelectorEntrySIMHardwareValue>:
   15898:	00000001 00000000 02020000 01010303     ................
   158a8:	03020606 00000000 00000000 00000000     ................
	...

000158c8 <Clock_Ip_au8DividerValueHardwareValue>:
   158c8:	00020100 00000003 00000004 00000000     ................
   158d8:	00000005 00000000 00000000 00000000     ................
   158e8:	00000006 00000000 00000000 00000000     ................
	...
   15908:	00000007                                ....

0001590c <Clock_Ip_apxScgPeriphAsyncDivs>:
   1590c:	40064204 40064304 40064104 40064604     .B.@.C.@.A.@.F.@

0001591c <Clock_Ip_aeSourceTypeClockName>:
   1591c:	00000000 00000001 00000001 00000001     ................
   1592c:	00000001 00000001 00000001 00000001     ................
   1593c:	00000002 00000003 00000001 00000001     ................
   1594c:	00000001 00000001 00000002 00000002     ................
   1595c:	00000003 00000003 00000001 00000001     ................
   1596c:	00000004 00000004 00000004 00000004     ................
	...

000159d8 <Clock_Ip_aeHwPllName>:
   159d8:	00000009                                ....

000159dc <Clock_Ip_aeHwDfsName>:
   159dc:	00000057                                W...

000159e0 <Clock_Ip_axDividerCallbacks>:
   159e0:	00002e5d 00002e67 00002e81 00002e9b     ]...g...........
   159f0:	00002eb5 00002ecf 00002ee9 00002f03     ............./..
   15a00:	00002f1d 00002f37 00002f51 00002f6b     ./..7/..Q/..k/..
   15a10:	00002f85 00002f9f 00002fb9              ./.../.../..

00015a1c <Clock_Ip_axDividerTriggerCallbacks>:
   15a1c:	0000332d 0000332d                       -3..-3..

00015a24 <Clock_Ip_axExtOscCallbacks>:
   15a24:	00003339 00003339 00003339 00003343     93..93..93..C3..
   15a34:	00003339 0000334d 00003367 00003381     93..M3..g3...3..
   15a44:	00003405 00003419                       .4...4..

00015a4c <Clock_Ip_axFracDivCallbacks>:
   15a4c:	000035d9 000035d9 000035e3              .5...5...5..

00015a58 <Clock_Ip_axGateCallbacks>:
   15a58:	000035fd 00003607 00003707 00003721     .5...6...7..!7..
   15a68:	000036b7 000036d1 00003667 00003681     .6...6..g6...6..
   15a78:	00003617 00003631 00003757 00003771     .6..16..W7..q7..
   15a88:	000037a7 000037c1                       .7...7..

00015a90 <Clock_Ip_axIntOscCallbacks>:
   15a90:	0000396d 0000396d 00003977 00003981     m9..m9..w9...9..
   15aa0:	0000399b 000039b5 000039c9 000039e3     .9...9...9...9..
   15ab0:	000039fd 00003a11 00003a2b 00003a45     .9...:..+:..E:..
   15ac0:	00003aed 00003b07 00003b21              .:...;..!;..

00015acc <Clock_Ip_axCmuCallbacks>:
   15acc:	000040bd 000040c7 000040d3 000040bd     .@...@...@...@..

00015adc <Clock_Ip_axPllCallbacks>:
   15adc:	000040dd 000040dd 000040e7 000040dd     .@...@...@...@..
   15aec:	000040f3 000040fd 00004117 00004131     .@...@...A..1A..
   15afc:	000041d5 000041c1                       .A...A..

00015b04 <Clock_Ip_axPcfsCallbacks>:
   15b04:	00004331                                1C..

00015b08 <Clock_Ip_axSelectorCallbacks>:
   15b08:	0000433d 0000433d 00004347 00004361     =C..=C..GC..aC..
   15b18:	0000433d 0000437b 00004395 000043af     =C..{C...C...C..
   15b28:	000043c9 000043e3 000043fd 00004417     .C...C...C...D..
   15b38:	00004431 0000444b 00004465 0000447f     1D..KD..eD...D..
   15b48:	00004499 000044b3 000044cd 000044e7     .D...D...D...D..
   15b58:	00004501 0000451b                       .E...E..

00015b60 <ClockSource>:
   15b60:	00000000 00000008 00000002 00000005     ................
	...
   15b78:	00000009                                ....

00015b7c <ResetReasonArray>:
   15b7c:	00000000 00000001 00000002 00000003     ................
   15b8c:	00000004 00000005 00000006 00000007     ................
   15b9c:	00000008 00000009 0000000a 0000000b     ................
   15bac:	0000000c 0000000d 0000000e              ............

00015bb8 <Port_au32PortCiPortBaseAddr>:
   15bb8:	40049000 4004a000 4004b000 4004c000     ...@...@...@...@
   15bc8:	4004d000                                ...@

00015bcc <Port_au32PortCiGpioBaseAddr>:
   15bcc:	400ff000 400ff040 400ff080 400ff0c0     ...@@..@...@...@
   15bdc:	400ff100                                ...@

00015be0 <Adc_Ip_apxBase>:
   15be0:	4003b000 40027000                       ...@.p.@

00015be8 <Flexcan_Ip_apxBase>:
   15be8:	40024000 40025000 4002b000              .@.@.P.@...@

00015bf4 <payload_code.3>:
   15bf4:	03020100 07060504 09090908 0a0a0a09     ................
   15c04:	0b0b0b0a 0c0c0c0b 0d0d0d0c 0d0d0d0d     ................
   15c14:	0e0e0e0d 0e0e0e0e 0e0e0e0e 0e0e0e0e     ................
   15c24:	0f0f0f0e 0f0f0f0f 0f0f0f0f 0f0f0f0f     ................
   15c34:	0000000f                                ....

00015c38 <flexcanBase.2>:
   15c38:	40024000 40025000 4002b000              .@.@.P.@...@

00015c44 <maxMbNum.1>:
   15c44:	00000020 00000010 00000010               ...........

00015c50 <flexcanBase.0>:
   15c50:	40024000                                .@.@

00015c54 <McuApis>:
   15c54:	00000000 00014a48 00000002 00014a54     ....HJ......TJ..
   15c64:	00000008 00014a64 00000009 00014a74     ....dJ......tJ..

00015c74 <McuErrors>:
   15c74:	00000011 00014a8c 0000000f 00014aa4     .....J.......J..
   15c84:	00000013 00014abc 0000000b 00014ad8     .....J.......J..
   15c94:	0000000c 00014ad8 00000010 00014ad8     .....J.......J..

00015ca4 <PlatformApis>:
   15ca4:	00000020 00014af0 00000021 00014b00      ....J..!....K..
   15cb4:	00000022 00014b14 00000023 00014b30     "....K..#...0K..
   15cc4:	00000024 00014b4c                       $...LK..

00015ccc <PlatformErrors>:
   15ccc:	00000001 00014b6c 00000004 00014b7c     ....lK......|K..
   15cdc:	00000002 00014ba0                       .....K..

00015ce4 <PortApis>:
   15ce4:	00000000 00014bb8 00000001 00014bc4     .....K.......K..
   15cf4:	00000004 00014bdc 00000002 00014bf0     .....K.......K..
   15d04:	00000003 00014c0c                       .....L..

00015d0c <PortErrors>:
   15d0c:	0000000a 00014c24 0000000e 00014c38     ....$L......8L..
   15d1c:	0000000c 00014a8c 000000f0 00014a8c     .....J.......J..
   15d2c:	0000000d 00014c58 0000000f 00014aa4     ....XL.......J..
   15d3c:	00000010 00014ad8                       .....J..

00015d44 <DioApis>:
   15d44:	00000001 00014c70 00000000 00014c84     ....pL.......L..
   15d54:	00000011 00014c98 00000005 00014cac     .....L.......L..
   15d64:	00000004 00014cc4 00000003 00014cdc     .....L.......L..
   15d74:	00000002 00014cec 00000012 00014cfc     .....L.......L..

00015d84 <DioErrors>:
   15d84:	00000021 00014d14 00000020 00014ad8     !....M.. ....J..
   15d94:	0000000a 00014d30 00000014 00014d48     ....0M......HM..
   15da4:	0000001f 00014d58 000000f0 00014d74     ....XM......tM..

00015db4 <PwmApis>:
   15db4:	00000000 00014d90 00000001 00014d9c     .....M.......M..
   15dc4:	00000002 00014dac 00000003 00014dc0     .....M.......M..
   15dd4:	00000004 00014dd8 00000008 00014df0     .....M.......M..

00015de4 <PwmErrors>:
   15de4:	00000010 00014e08 00000011 00014aa4     .....N.......J..
   15df4:	00000014 00014abc 00000012 00014e20     .....J...... N..
   15e04:	00000013 00014e34 00000015 00014ad8     ....4N.......J..

00015e14 <AdcApis>:
   15e14:	00000000 00014e58 00000001 00014e64     ....XN......dN..
   15e24:	00000002 00014e74 00000003 00014e90     ....tN.......N..
   15e34:	00000004 00014eac 00000009 00014ebc     .....N.......N..
   15e44:	00000029 00014ed4 0000000c 00014ee4     )....N.......N..
   15e54:	0000000a 00014efc                       .....N..

00015e5c <AdcErrors>:
   15e5c:	0000000a 00014aa4 0000000d 00014abc     .....J.......J..
   15e6c:	00000014 00014b6c 00000015 00014f14     ....lK.......O..
   15e7c:	00000019 00014f28 0000002b 00014f48     ....(O..+...HO..

00015e8c <SchedulerApis>:
   15e8c:	00000000 00014f68 00000002 00014f7c     ....hO......|O..
   15e9c:	00000003 00014f98 00000004 00014fb0     .....O.......O..
   15eac:	00000005 00014fc8 00000006 00014fe0     .....O.......O..
   15ebc:	00000007 00014ff8 00000008 00015010     .....O.......P..
   15ecc:	00000009 00015028 0000000a 00015040     ....(P......@P..
   15edc:	0000000b 00015058 0000000c 00015070     ....XP......pP..
   15eec:	0000000d 00015088                       .....P..

00015ef4 <SchedulerErrors>:
   15ef4:	00000000 00014e08 00000001 000150a4     .....N.......P..
   15f04:	00000002 000150bc 00000003 000150d8     .....P.......P..
   15f14:	00000004 000150f0 00000005 00015114     .....P.......Q..
   15f24:	00000006 0001512c                       ....,Q..

00015f2c <HwIoAb_ButtonsApis>:
   15f2c:	00000000 00015144 00000001 0001515c     ....DQ......\Q..
   15f3c:	00000002 00015178                       ....xQ..

00015f44 <HwIoAb_ButtonsErrors>:
   15f44:	00000000 00014e08 00000001 00015198     .....N.......Q..
   15f54:	00000002 000151ac 00000003 000151c4     .....Q.......Q..

00015f64 <HwIoAb_LedsApis>:
   15f64:	00000000 000151dc 00000001 000151f0     .....Q.......Q..
   15f74:	00000002 00015208 00000003 00015220     .....R...... R..

00015f84 <HwIoAb_LedsErrors>:
   15f84:	00000000 00014e08 00000001 0001523c     .....N......<R..
   15f94:	00000002 000151c4                       .....Q..

00015f9c <HwIoAb_PotsApis>:
   15f9c:	00000000 0001524c 00000001 00015260     ....LR......`R..
   15fac:	00000002 00015278                       ....xR..

00015fb4 <HwIoAb_PotsErrors>:
   15fb4:	00000000 00015294 00000001 000151c4     .....R.......Q..

00015fc4 <HwIoAb_BuzzerApis>:
   15fc4:	00000000 000152ac 00000001 000152c4     .....R.......R..
   15fd4:	00000002 000152dc                       .....R..

00015fdc <HwIoAb_BuzzerErrors>:
   15fdc:	00000000 000152f4                       .....R..

00015fe4 <ModuleStrings>:
   15fe4:	00000065 00015308 00000004 00015c54     e....S......T\..
   15ff4:	00000006 00015c74 000000ff 00015314     ....t\.......S..
   16004:	00000005 00015ca4 00000003 00015ccc     .....\.......\..
   16014:	0000007c 00015324 00000005 00015ce4     |...$S.......\..
   16024:	00000007 00015d0c 00000078 00015330     .....]..x...0S..
   16034:	00000008 00015d44 00000006 00015d84     ....D].......]..
   16044:	00000079 0001533c 00000006 00015db4     y...<S.......]..
   16054:	00000006 00015de4 0000007b 00015348     .....]..{...HS..
   16064:	00000009 00015e14 00000006 00015e5c     .....^......\^..
   16074:	0000012c 00015354 0000000d 00015e8c     ,...TS.......^..
   16084:	00000007 00015ef4 0000012d 00015368     .....^..-...hS..
   16094:	00000003 00015f2c 00000004 00015f44     ....,_......D_..
   160a4:	0000012e 00015388 00000004 00015f64     .....S......d_..
   160b4:	00000003 00015f84 0000012f 000153a4     ....._../....S..
   160c4:	00000003 00015f9c 00000002 00015fb4     ....._......._..
   160d4:	00000130 000153c0 00000003 00015fc4     0....S......._..
   160e4:	00000001 00015fdc                       ....._..

000160ec <Can_43_FLEXCAN_Driver_P2Func>:
   160ec:	00008949 000085c5 00008769 00008709     I.......i.......
   160fc:	000087e1 0000886d 000088a1 000088f5     ....m...........

0001610c <Can_43_FLEXCAN_Driver_Config>:
   1610c:	00010000 000160ec                       .....`..

00016114 <CanIf_CtrlPCConfig>:
   16114:	00000000 0001610c                       .....a..

0001611c <CanIf_PCConfig>:
   1611c:	00000001 00016114                       .....a..

00016124 <CanIf_TxPdu>:
   16124:	00000000 00000123 00000002 00000000     ....#...........
   16134:	000009c5 00000001 00000124 00000002     ........$.......
   16144:	00000000 000009c5                       ........

0001614c <CanIf_Can_43_FLEXCAN_HohToRxPduMapping>:
   1614c:	00000000                                ....

00016150 <CanIf_Can_43_FLEXCAN_DrvConfig>:
   16150:	0001614c                                La..

00016154 <CanIf_CanDrvConfig>:
   16154:	00016150                                Pa..

00016158 <CanIf_Config>:
   16158:	00000200 00016154 00000000 00016124     ....Ta......$a..

00016168 <Can_43_FLEXCANIpwHwChannelConfig0>:
   16168:	00016600                                .f..

0001616c <Can_au32HwBufferAddr_Ctrl0>:
   1616c:	4002b080 4002b090                       ...@...@

00016174 <Can_aCtrlOffsetToCtrlIDMap>:
   16174:	0000ffff                                ....

00016178 <Can_aHwObjIDToCtrlIDMap>:
   16178:	00000000                                ....

0001617c <Can_aHwObjectConfig>:
   1617c:	00000000 00000001 00000000 ff020000     ................
   1618c:	00000008 00000000 00000003 00000000     ................
   1619c:	0001616c                                la..

000161a0 <Can_aBaudrateConfig_Ctrl0>:
   161a0:	06030000 001d0003 00000000 00000000     ................
	...

000161b8 <Can_apHwObject_Ctrl0>:
   161b8:	0001617c                                |a..

000161bc <Can_aControllerConfig>:
   161bc:	00020000 4002b000 00000001 ffffffff     .......@........
	...
   161d8:	00010000 000161a0 00016168 00000001     .....a..ha......
   161e8:	000161b8                                .a..

000161ec <Can_apController>:
   161ec:	000161bc                                .a..

000161f0 <Can_43_FLEXCAN_Config>:
	...
   161f8:	00016174 00016178 0001617c 000161ec     ta..xa..|a...a..

00016208 <Mcu_aClockConfigPB>:
	...
   16210:	14000002 0400000e 01000020 00000002     ........ .......
   16220:	01000001 00000001 00000005 00000001     ................
   16230:	00000000 00000057 00000000 00000000     ....W...........
	...
   16248:	00000057 00000000 00000057 00000000     W.......W.......
	...
   16270:	00000019 00000005 0000001a 00000002     ................
   16280:	0000001b 00000005 0000002a 00000002     ........*.......
   16290:	0000003f 0000000a 00000040 0000000a     ?.......@.......
   162a0:	00000041 00000000 00000042 00000000     A.......B.......
   162b0:	00000031 0000000b 00000045 00000000     1.......E.......
   162c0:	00000046 00000000 00000047 00000000     F.......G.......
   162d0:	00000044 00000000 00000030 0000000b     D.......0.......
   162e0:	0000003d 00000000 00000043 00000000     =.......C.......
   162f0:	00000049 00000000 0000004a 00000000     I.......J.......
   16300:	0000004b 00000000 00000048 00000000     K.......H.......
   16310:	00000057 00000057 00000057 00000057     W...W...W...W...
   16320:	00000057 00000057 00000057 00000057     W...W...W...W...
   16330:	00000057 00000057 00000057 00000057     W...W...W...W...
   16340:	00000057 00000057 00000057 00000057     W...W...W...W...
   16350:	0000000a 00000001 00000000 0000000b     ................
   16360:	00000001 00000000 0000000c 00000001     ................
   16370:	00000000 0000000d 00000002 00000000     ................
   16380:	0000001d 00000001 00000000 0000001e     ................
   16390:	00000002 00000000 0000001f 00000001     ................
   163a0:	00000000 00000021 00000001 00000000     ....!...........
   163b0:	00000022 00000002 00000000 00000023     "...........#...
   163c0:	00000001 00000000 00000025 00000002     ........%.......
   163d0:	00000000 00000026 00000004 00000000     ....&...........
   163e0:	00000027 00000002 00000000 00000048     '...........H...
   163f0:	00000001 00000001 00000057 00000000     ........W.......
   16400:	00000000 00000057 00000000 00000000     ....W...........
   16410:	00000057 00000000 00000000 00000057     W...........W...
	...
   16428:	00000057 00000000 00000000 00000057     W...........W...
	...
   16440:	00000057 00000000 00000057 00000057     W.......W...W...
	...
   1645c:	00000014 00007d00 00000015 00007d00     .....}.......}..
   1646c:	00000016 00007d00 00000017 00008000     .....}..........
   1647c:	00000030 00000001 00000031 00000001     0.......1.......
   1648c:	00000033 00000000 00000034 00000000     3.......4.......
   1649c:	00000036 00000000 00000039 00000000     6.......9.......
   164ac:	0000003a 00000000 0000003b 00000000     :.......;.......
   164bc:	0000003c 00000001 0000003d 00000000     <.......=.......
   164cc:	0000003e 00000000 0000003f 00000000     >.......?.......
   164dc:	00000040 00000001 00000041 00000000     @.......A.......
   164ec:	00000042 00000000 00000043 00000000     B.......C.......
   164fc:	00000044 00000000 00000045 00000000     D.......E.......
   1650c:	00000046 00000000 00000047 00000000     F.......G.......
   1651c:	00000048 00000000 00000049 00000000     H.......I.......
   1652c:	0000004a 00000000 0000004b 00000000     J.......K.......
   1653c:	0000004e 00000001 0000004f 00000001     N.......O.......
   1654c:	00000050 00000001 00000051 00000001     P.......Q.......
   1655c:	00000052 00000001 00000053 00000001     R.......S.......
   1656c:	00000054 00000001 00000055 00000000     T.......U.......
   1657c:	00000057 00000000 00000057 00000000     W.......W.......
   1658c:	00000057 00000000 00000057 00000000     W.......W.......
   1659c:	00000057 00000000 00000057 00000000     W.......W.......
   165ac:	00000057 00000000 00000057 00000000     W.......W.......
   165bc:	00000057 00000000 00000057 00000000     W.......W.......
   165cc:	00000000 00000057 00000000 00000057     ....W.......W...
	...

00016600 <Flexcan_aCtrlConfigPB>:
   16600:	00000002 00000000 00000000 00000000     ................
   16610:	00000040 00000000 00000100 00000003     @...............
   16620:	00000006 00000003 0000001d 00000000     ................
   16630:	00000004 00000006 00000003 0000001d     ................
	...
   16648:	00009b21 00009bcd                       !.......

00016650 <aIrqConfiguration>:
   16650:	00000027 00000000 000082ed 00000028     '...........(...
   16660:	00000000 000082fd 0000005c 00000f01     ........\.......
   16670:	0000e04d 0000005d 00000f01 0000e05d     M...].......]...
   16680:	0000005f 00000f01 0000e06d              _.......m...

0001668c <intCtrlConfig>:
   1668c:	00000005 00016650                       ....Pf..

00016694 <Mcu_Config>:
   16694:	0000005a 00000000 00000001 00000001     Z...............
   166a4:	00016bbc 00016208 00016bc8              .k...b...k..

000166b0 <OsIf_xPredefinedConfig>:
   166b0:	00000000 02dc6c00                       .....l..

000166b8 <OsIf_apxPredefinedConfig>:
   166b8:	000166b0                                .f..

000166bc <Platform_uConfiguration>:
   166bc:	000166c4                                .f..

000166c0 <Platform_Config>:
   166c0:	000166bc                                .f..

000166c4 <ipwConfig>:
   166c4:	0001668c 00000000                       .f......

000166cc <Port_au16PinDescription>:
   166cc:	0003ffff 0003ffff 0003ffff 0003ffff     ................
   166dc:	0001ffff 0003ffff 0003ffff 0003ffff     ................
   166ec:	0003ffff 0001ffff 0003ffcf 0003ffff     ................
   166fc:	0003ffff 0003fcff 0001dfef 0003f36f     ............o...
   1670c:	0003fe3f 0003f3ff 00026e3f 0001bebf     ?.......?n......
   1671c:	0002cf9f 0000302f 000030cc 000183ef     ..../0...0......
   1672c:	0001ec7c 00000b1f 00000023 00000010     |.......#.......
   1673c:	0001010c 00000033 000072cf 0000003c     ....3....r..<...
   1674c:	0000cff3 00001b2f 00018c7f 00000433     ..../.......3...
   1675c:	00000000 00000030 0000600b 00018c38     ....0....`..8...

0001676c <g_pin_mux_InitConfigArr>:
   1676c:	4004b000 400ff080 00000008 00000002     ...@...@........
   1677c:	00000001 00000002 00000000 00000000     ................
	...
   16794:	4004b000 400ff080 00000009 00000002     ...@...@........
   167a4:	00000001 00000002 00000000 00000000     ................
	...
   167bc:	4004b000 400ff080 0000000a 00000002     ...@...@........
   167cc:	00000001 00000002 00000000 00000000     ................
	...
   167e4:	4004b000 400ff080 0000000b 00000002     ...@...@........
   167f4:	00000001 00000002 00000000 00000000     ................
	...
   1680c:	4004b000 400ff080 0000000d 00000002     ...@...@........
   1681c:	00000001 00000002 00000000 00000000     ................
	...
   16834:	4004b000 400ff080 0000000e 00000002     ...@...@........
   16844:	00000001 00000002 00000000 00000000     ................
	...
   1685c:	4004b000 00000000 00000010 00000002     ...@............
   1686c:	00000003 00000001 00000000 00000000     ................
	...
   16884:	4004b000 00000000 00000011 00000002     ...@............
   16894:	00000003 00000002 00000000 00000000     ................
	...
   168ac:	4004d000 400ff100 0000000c 00000002     ...@...@........
   168bc:	00000001 00000001 00000000 00000000     ................
	...
   168d4:	4004c000 400ff0c0 00000011 00000002     ...@...@........
   168e4:	00000001 00000001 00000000 00000000     ................
	...
   168fc:	40049000 400ff000 0000000c 00000002     ...@...@........
   1690c:	00000001 00000001 00000000 00000000     ................
	...
   16924:	40049000 00000000 0000000d 00000002     ...@............
   16934:	00000002 00000002 00000000 00000000     ................
	...
   1694c:	4004a000 00000000 00000001 00000002     ...@............
   1695c:	00000000 00000001 00000000 00000000     ................
	...
   16974:	4004a000 00000000 0000000d 00000002     ...@............
   16984:	00000000 00000001 00000000 00000000     ................
	...

0001699c <au8Port_PartitionList>:
   1699c:	00000001                                ....

000169a0 <au32Port_PinToPartitionMap>:
   169a0:	00000001 00000001 00000001 00000001     ................
   169b0:	00000001 00000001 00000001 00000001     ................
   169c0:	00000001 00000001 00000001 00000001     ................
   169d0:	00000001 00000001                       ........

000169d8 <Port_au16NoUnUsedPadsArrayDefault>:
   169d8:	00010000 00030002 00070006 00090008     ................
   169e8:	000e000b 0010000f 00200011 00230022     .......... .".#.
   169f8:	00250024 00270026 00290028 002b002a     $.%.&.'.(.).*.+.
   16a08:	002e002c 0030002f 00400031 00420041     ,.../.0.1.@.A.B.
   16a18:	00460043 004c0047 0060004f 00620061     C.F.G.L.O.`.a.b.
   16a28:	00640063 00660065 00680067 006a0069     c.d.e.f.g.h.i.j.
   16a38:	006c006b 006e006d 0070006f 00810080     k.l.m.n.o.p.....
   16a48:	00830082 00850084 00870086 00890088     ................
   16a58:	008b008a 008e008d 0090008f              ............

00016a64 <Port_UnUsedPin>:
   16a64:	00000000 00000001 00000000              ............

00016a70 <Port_aPinConfigDefault>:
   16a70:	00000048 00000100 00000000 00000002     H...............
   16a80:	00010001 00000049 00000100 00000000     ....I...........
   16a90:	00000002 00010101 0000004a 00000100     ........J.......
   16aa0:	00000000 00000002 00010101 0000008c     ................
   16ab0:	00000100 00000000 00000001 00010101     ................
   16ac0:	0000004b 00000100 00000000 00000002     K...............
   16ad0:	00010101 0000004d 00000100 00000000     ....M...........
   16ae0:	00000002 00010101 0000004e 00000100     ........N.......
   16af0:	00000000 00000002 00010101 00000071     ............q...
   16b00:	00000100 00000000 00000001 00010101     ................
   16b10:	0000000c 00000100 00000000 00000001     ................
   16b20:	00010101 00000021 00000000 00000002     ....!...........
   16b30:	00000000 00010000 0000002d 00000000     ........-.......
   16b40:	00000002 00000000 00010000 0000000d     ................
   16b50:	00000200 00000000 00000002 00010000     ................
   16b60:	00000050 00000300 00000000 00000001     P...............
   16b70:	00010000 00000051 00000300 00000000     ....Q...........
   16b80:	00000002 00010000                       ........

00016b88 <Port_Config>:
   16b88:	0046000e 000169d8 00016a64 00016a70     ..F..i..dj..pj..
	...
   16ba0:	000169a0 0001699c 0001676c              .i...i..lg..

00016bac <Power_Ip_RCM_ConfigPB>:
	...

00016bb4 <Power_Ip_PMC_ConfigPB>:
   16bb4:	00000000                                ....

00016bb8 <Power_Ip_SMC_ConfigPB>:
   16bb8:	00000000                                ....

00016bbc <Power_Ip_aModeConfigPB>:
	...

00016bc8 <Power_Ip_HwIPsConfigPB>:
   16bc8:	00016bac 00016bb4 00016bb8              .k...k...k..

00016bd4 <_aInitStr.0>:
   16bd4:	00000000 54540000 45522052 53454747     ......TTR REGGES
   16be4:	00000000                                ....

00016be8 <_aV2C.0>:
   16be8:	33323130 37363534 42413938 46454443     0123456789ABCDEF

00016bf8 <__INIT_TABLE>:
   16bf8:	00000002 	.word	0x00000002
   16bfc:	1fff8b10 	.word	0x1fff8b10
   16c00:	00016c20 	.word	0x00016c20
   16c04:	00016c38 	.word	0x00016c38
   16c08:	1fff8800 	.word	0x1fff8800
   16c0c:	00000000 	.word	0x00000000
   16c10:	00000310 	.word	0x00000310

00016c14 <__ZERO_TABLE>:
   16c14:	00000001 	.word	0x00000001
   16c18:	1fff8b30 	.word	0x1fff8b30
   16c1c:	1fff9a10 	.word	0x1fff9a10
